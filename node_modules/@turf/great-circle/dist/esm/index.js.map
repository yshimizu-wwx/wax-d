{"version":3,"sources":["../../index.ts"],"sourcesContent":["import type {\n  Feature,\n  GeoJsonProperties,\n  LineString,\n  MultiLineString,\n  Point,\n  Position,\n} from \"geojson\";\nimport { lineString } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GreatCircle } from \"arc\";\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`. If the `start` and `end` positions are the same\n * then a `LineString` will be returned with duplicate coordinates the length of the `npoints` option.\n *\n * @name greatCircle\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(\n  start: Feature<Point, GeoJsonProperties> | Point | Position,\n  end: Feature<Point, GeoJsonProperties> | Point | Position,\n  options: {\n    properties?: GeoJsonProperties;\n    npoints?: number;\n    offset?: number;\n  } = {}\n): Feature<LineString | MultiLineString> {\n  // Optional parameters\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  const { properties = {}, npoints = 100, offset = 10 } = options;\n\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n\n  if (startCoord[0] === endCoord[0] && startCoord[1] === endCoord[1]) {\n    const arr = Array(npoints).fill([startCoord[0], startCoord[1]]);\n    return lineString(arr, properties);\n  }\n\n  const generator = new GreatCircle(\n    { x: startCoord[0], y: startCoord[1] },\n    { x: endCoord[0], y: endCoord[1] },\n    properties || {}\n  );\n\n  const line = generator.Arc(npoints, { offset: offset });\n\n  return line.json() as Feature<\n    LineString | MultiLineString,\n    GeoJsonProperties\n  >;\n}\n\nexport { greatCircle };\nexport default greatCircle;\n"],"mappings":";AAQA,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AACzB,SAAS,mBAAmB;AA0B5B,SAAS,YACP,OACA,KACA,UAII,CAAC,GACkC;AAEvC,MAAI,OAAO,YAAY,SAAU,OAAM,IAAI,MAAM,oBAAoB;AACrE,QAAM,EAAE,aAAa,CAAC,GAAG,UAAU,KAAK,SAAS,GAAG,IAAI;AAExD,QAAM,aAAa,SAAS,KAAK;AACjC,QAAM,WAAW,SAAS,GAAG;AAE7B,MAAI,WAAW,CAAC,MAAM,SAAS,CAAC,KAAK,WAAW,CAAC,MAAM,SAAS,CAAC,GAAG;AAClE,UAAM,MAAM,MAAM,OAAO,EAAE,KAAK,CAAC,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC;AAC9D,WAAO,WAAW,KAAK,UAAU;AAAA,EACnC;AAEA,QAAM,YAAY,IAAI;AAAA,IACpB,EAAE,GAAG,WAAW,CAAC,GAAG,GAAG,WAAW,CAAC,EAAE;AAAA,IACrC,EAAE,GAAG,SAAS,CAAC,GAAG,GAAG,SAAS,CAAC,EAAE;AAAA,IACjC,cAAc,CAAC;AAAA,EACjB;AAEA,QAAM,OAAO,UAAU,IAAI,SAAS,EAAE,OAAe,CAAC;AAEtD,SAAO,KAAK,KAAK;AAInB;AAGA,IAAO,gBAAQ;","names":[]}