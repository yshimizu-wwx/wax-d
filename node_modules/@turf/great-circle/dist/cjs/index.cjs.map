{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-great-circle/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"AAAA;ACQA,wCAA2B;AAC3B,4CAAyB;AACzB,0BAA4B;AA0B5B,SAAS,WAAA,CACP,KAAA,EACA,GAAA,EACA,QAAA,EAII,CAAC,CAAA,EACkC;AAEvC,EAAA,GAAA,CAAI,OAAO,QAAA,IAAY,QAAA,EAAU,MAAM,IAAI,KAAA,CAAM,oBAAoB,CAAA;AACrE,EAAA,MAAM,EAAE,WAAA,EAAa,CAAC,CAAA,EAAG,QAAA,EAAU,GAAA,EAAK,OAAA,EAAS,GAAG,EAAA,EAAI,OAAA;AAExD,EAAA,MAAM,WAAA,EAAa,iCAAA,KAAc,CAAA;AACjC,EAAA,MAAM,SAAA,EAAW,iCAAA,GAAY,CAAA;AAE7B,EAAA,GAAA,CAAI,UAAA,CAAW,CAAC,EAAA,IAAM,QAAA,CAAS,CAAC,EAAA,GAAK,UAAA,CAAW,CAAC,EAAA,IAAM,QAAA,CAAS,CAAC,CAAA,EAAG;AAClE,IAAA,MAAM,IAAA,EAAM,KAAA,CAAM,OAAO,CAAA,CAAE,IAAA,CAAK,CAAC,UAAA,CAAW,CAAC,CAAA,EAAG,UAAA,CAAW,CAAC,CAAC,CAAC,CAAA;AAC9D,IAAA,OAAO,iCAAA,GAAW,EAAK,UAAU,CAAA;AAAA,EACnC;AAEA,EAAA,MAAM,UAAA,EAAY,IAAI,qBAAA;AAAA,IACpB,EAAE,CAAA,EAAG,UAAA,CAAW,CAAC,CAAA,EAAG,CAAA,EAAG,UAAA,CAAW,CAAC,EAAE,CAAA;AAAA,IACrC,EAAE,CAAA,EAAG,QAAA,CAAS,CAAC,CAAA,EAAG,CAAA,EAAG,QAAA,CAAS,CAAC,EAAE,CAAA;AAAA,IACjC,WAAA,GAAc,CAAC;AAAA,EACjB,CAAA;AAEA,EAAA,MAAM,KAAA,EAAO,SAAA,CAAU,GAAA,CAAI,OAAA,EAAS,EAAE,OAAe,CAAC,CAAA;AAEtD,EAAA,OAAO,IAAA,CAAK,IAAA,CAAK,CAAA;AAInB;AAGA,IAAO,cAAA,EAAQ,WAAA;ADlDf;AACE;AACA;AACF,mEAAC","file":"/home/runner/work/turf/turf/packages/turf-great-circle/dist/cjs/index.cjs","sourcesContent":[null,"import type {\n  Feature,\n  GeoJsonProperties,\n  LineString,\n  MultiLineString,\n  Point,\n  Position,\n} from \"geojson\";\nimport { lineString } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GreatCircle } from \"arc\";\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`. If the `start` and `end` positions are the same\n * then a `LineString` will be returned with duplicate coordinates the length of the `npoints` option.\n *\n * @name greatCircle\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(\n  start: Feature<Point, GeoJsonProperties> | Point | Position,\n  end: Feature<Point, GeoJsonProperties> | Point | Position,\n  options: {\n    properties?: GeoJsonProperties;\n    npoints?: number;\n    offset?: number;\n  } = {}\n): Feature<LineString | MultiLineString> {\n  // Optional parameters\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  const { properties = {}, npoints = 100, offset = 10 } = options;\n\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n\n  if (startCoord[0] === endCoord[0] && startCoord[1] === endCoord[1]) {\n    const arr = Array(npoints).fill([startCoord[0], startCoord[1]]);\n    return lineString(arr, properties);\n  }\n\n  const generator = new GreatCircle(\n    { x: startCoord[0], y: startCoord[1] },\n    { x: endCoord[0], y: endCoord[1] },\n    properties || {}\n  );\n\n  const line = generator.Arc(npoints, { offset: offset });\n\n  return line.json() as Feature<\n    LineString | MultiLineString,\n    GeoJsonProperties\n  >;\n}\n\nexport { greatCircle };\nexport default greatCircle;\n"]}