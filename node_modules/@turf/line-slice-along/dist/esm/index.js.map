{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineString, isObject, Units } from \"@turf/helpers\";\nimport { Feature, LineString, Point, Position } from \"geojson\";\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @function\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(\n  line: Feature<LineString> | LineString,\n  startDist: number,\n  stopDist: number,\n  options: { units?: Units } = {}\n): Feature<LineString> {\n  // Optional parameters\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { units = \"kilometers\" } = options;\n\n  var coords: Position[];\n  var slice: Position[] = [];\n\n  // Validation\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;\n  else if (line.type === \"LineString\") coords = line.coordinates;\n  else throw new Error(\"input must be a LineString Feature or Geometry\");\n  const origCoordsLength = coords.length;\n  let travelled = 0;\n  let overshot: number, direction: number, interpolated: Feature<Point>;\n  for (let i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;\n    else if (travelled > startDist && slice.length === 0) {\n      let overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, { units });\n      slice.push(interpolated.geometry.coordinates);\n    }\n\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, { units });\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n\n    travelled += distance(coords[i], coords[i + 1], { units });\n  }\n\n  if (travelled < startDist && coords.length === origCoordsLength)\n    throw new Error(\"Start position is beyond line\");\n\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\n\nexport { lineSliceAlong };\nexport default lineSliceAlong;\n"],"mappings":";AAAA,SAAS,eAAe;AACxB,SAAS,gBAAgB;AACzB,SAAS,mBAAmB;AAC5B,SAAS,YAAY,gBAAuB;AA0B5C,SAAS,eACP,MACA,WACA,UACA,UAA6B,CAAC,GACT;AAErB,MAAI,CAAC,SAAS,OAAO,EAAG,OAAM,IAAI,MAAM,oBAAoB;AAC5D,QAAM,EAAE,QAAQ,aAAa,IAAI;AAEjC,MAAI;AACJ,MAAI,QAAoB,CAAC;AAGzB,MAAI,KAAK,SAAS,UAAW,UAAS,KAAK,SAAS;AAAA,WAC3C,KAAK,SAAS,aAAc,UAAS,KAAK;AAAA,MAC9C,OAAM,IAAI,MAAM,gDAAgD;AACrE,QAAM,mBAAmB,OAAO;AAChC,MAAI,YAAY;AAChB,MAAI,UAAkB,WAAmB;AACzC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,QAAI,aAAa,aAAa,MAAM,OAAO,SAAS,EAAG;AAAA,aAC9C,YAAY,aAAa,MAAM,WAAW,GAAG;AACpD,UAAIA,YAAW,YAAY;AAC3B,UAAI,CAACA,WAAU;AACb,cAAM,KAAK,OAAO,CAAC,CAAC;AACpB,eAAO,WAAW,KAAK;AAAA,MACzB;AACA,kBAAY,QAAQ,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,IAAI;AAChD,qBAAe,YAAY,OAAO,CAAC,GAAGA,WAAU,WAAW,EAAE,MAAM,CAAC;AACpE,YAAM,KAAK,aAAa,SAAS,WAAW;AAAA,IAC9C;AAEA,QAAI,aAAa,UAAU;AACzB,iBAAW,WAAW;AACtB,UAAI,CAAC,UAAU;AACb,cAAM,KAAK,OAAO,CAAC,CAAC;AACpB,eAAO,WAAW,KAAK;AAAA,MACzB;AACA,kBAAY,QAAQ,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,IAAI;AAChD,qBAAe,YAAY,OAAO,CAAC,GAAG,UAAU,WAAW,EAAE,MAAM,CAAC;AACpE,YAAM,KAAK,aAAa,SAAS,WAAW;AAC5C,aAAO,WAAW,KAAK;AAAA,IACzB;AAEA,QAAI,aAAa,WAAW;AAC1B,YAAM,KAAK,OAAO,CAAC,CAAC;AAAA,IACtB;AAEA,QAAI,MAAM,OAAO,SAAS,GAAG;AAC3B,aAAO,WAAW,KAAK;AAAA,IACzB;AAEA,iBAAa,SAAS,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC;AAAA,EAC3D;AAEA,MAAI,YAAY,aAAa,OAAO,WAAW;AAC7C,UAAM,IAAI,MAAM,+BAA+B;AAEjD,MAAI,OAAO,OAAO,OAAO,SAAS,CAAC;AACnC,SAAO,WAAW,CAAC,MAAM,IAAI,CAAC;AAChC;AAGA,IAAO,gBAAQ;","names":["overshot"]}