"use strict";Object.defineProperty(exports, "__esModule", {value: true});// index.ts
var _invariant = require('@turf/invariant');
var _helpers = require('@turf/helpers');
var _nearestpointonline = require('@turf/nearest-point-on-line');
function lineSlice(startPt, stopPt, line) {
  const coords = _invariant.getCoords.call(void 0, line);
  if (_invariant.getType.call(void 0, line) !== "LineString")
    throw new Error("line must be a LineString");
  const startVertex = _nearestpointonline.nearestPointOnLine.call(void 0, line, startPt);
  const stopVertex = _nearestpointonline.nearestPointOnLine.call(void 0, line, stopPt);
  fixSegmentIndexBounds(line, startVertex);
  fixSegmentIndexBounds(line, stopVertex);
  const ends = startVertex.properties.segmentIndex <= stopVertex.properties.segmentIndex ? [startVertex, stopVertex] : [stopVertex, startVertex];
  const clipCoords = [ends[0].geometry.coordinates];
  for (let i = ends[0].properties.segmentIndex + 1; i < ends[1].properties.segmentIndex + 1; i++) {
    clipCoords.push(coords[i]);
  }
  clipCoords.push(ends[1].geometry.coordinates);
  return _helpers.lineString.call(void 0, clipCoords, line.type === "Feature" ? line.properties : {});
}
function fixSegmentIndexBounds(line, vertex) {
  let geometry = line.type === "Feature" ? line.geometry : line;
  if (vertex.properties.segmentIndex >= geometry.coordinates.length - 1) {
    vertex.properties.segmentIndex = geometry.coordinates.length - 2;
  }
}
var index_default = lineSlice;



exports.default = index_default; exports.lineSlice = lineSlice;
//# sourceMappingURL=index.cjs.map