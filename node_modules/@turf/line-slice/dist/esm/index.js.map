{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { getCoords, getType } from \"@turf/invariant\";\nimport { Coord, lineString as linestring } from \"@turf/helpers\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport type { Feature, LineString, Point } from \"geojson\";\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @function\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(\n  startPt: Coord,\n  stopPt: Coord,\n  line: Feature<LineString> | LineString\n): Feature<LineString> {\n  // Validation\n  const coords = getCoords(line);\n  if (getType(line) !== \"LineString\")\n    throw new Error(\"line must be a LineString\");\n\n  const startVertex = nearestPointOnLine(line, startPt);\n  const stopVertex = nearestPointOnLine(line, stopPt);\n\n  // Workaround until we can fix backwards incompatible nearestPointOnLine bug\n  // #3016\n  fixSegmentIndexBounds(line, startVertex);\n  fixSegmentIndexBounds(line, stopVertex);\n\n  const ends =\n    startVertex.properties.segmentIndex <= stopVertex.properties.segmentIndex\n      ? [startVertex, stopVertex]\n      : [stopVertex, startVertex];\n  const clipCoords = [ends[0].geometry.coordinates];\n  for (\n    let i = ends[0].properties.segmentIndex + 1;\n    i < ends[1].properties.segmentIndex + 1;\n    i++\n  ) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return linestring(clipCoords, line.type === \"Feature\" ? line.properties : {});\n}\n\nfunction fixSegmentIndexBounds(\n  line: Feature<LineString> | LineString,\n  vertex: Feature<Point, { segmentIndex: number }>\n) {\n  // There is a bug in nearestPointOnLine where the returned segmentIndex can\n  // refer to a non-existent segment (overflows). Until we can fix that bug\n  // (see https://github.com/Turfjs/turf/issues/3016) we adjust the\n  // segmentIndex here to make sure it's in range.\n\n  let geometry: LineString = line.type === \"Feature\" ? line.geometry : line;\n\n  if (vertex.properties.segmentIndex >= geometry.coordinates.length - 1) {\n    // segmentIndex refers to a non-existent segment beyond the end of the\n    // lineString. Override it.\n    vertex.properties.segmentIndex = geometry.coordinates.length - 2;\n  }\n}\n\nexport { lineSlice };\nexport default lineSlice;\n"],"mappings":";AAAA,SAAS,WAAW,eAAe;AACnC,SAAgB,cAAc,kBAAkB;AAChD,SAAS,0BAA0B;AAgCnC,SAAS,UACP,SACA,QACA,MACqB;AAErB,QAAM,SAAS,UAAU,IAAI;AAC7B,MAAI,QAAQ,IAAI,MAAM;AACpB,UAAM,IAAI,MAAM,2BAA2B;AAE7C,QAAM,cAAc,mBAAmB,MAAM,OAAO;AACpD,QAAM,aAAa,mBAAmB,MAAM,MAAM;AAIlD,wBAAsB,MAAM,WAAW;AACvC,wBAAsB,MAAM,UAAU;AAEtC,QAAM,OACJ,YAAY,WAAW,gBAAgB,WAAW,WAAW,eACzD,CAAC,aAAa,UAAU,IACxB,CAAC,YAAY,WAAW;AAC9B,QAAM,aAAa,CAAC,KAAK,CAAC,EAAE,SAAS,WAAW;AAChD,WACM,IAAI,KAAK,CAAC,EAAE,WAAW,eAAe,GAC1C,IAAI,KAAK,CAAC,EAAE,WAAW,eAAe,GACtC,KACA;AACA,eAAW,KAAK,OAAO,CAAC,CAAC;AAAA,EAC3B;AACA,aAAW,KAAK,KAAK,CAAC,EAAE,SAAS,WAAW;AAC5C,SAAO,WAAW,YAAY,KAAK,SAAS,YAAY,KAAK,aAAa,CAAC,CAAC;AAC9E;AAEA,SAAS,sBACP,MACA,QACA;AAMA,MAAI,WAAuB,KAAK,SAAS,YAAY,KAAK,WAAW;AAErE,MAAI,OAAO,WAAW,gBAAgB,SAAS,YAAY,SAAS,GAAG;AAGrE,WAAO,WAAW,eAAe,SAAS,YAAY,SAAS;AAAA,EACjE;AACF;AAGA,IAAO,gBAAQ;","names":[]}