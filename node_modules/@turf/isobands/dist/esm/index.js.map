{"version":3,"sources":["../../index.ts","../../lib/grid-to-matrix.ts"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf } from \"@turf/invariant\";\nimport {\n  polygon,\n  multiPolygon,\n  featureCollection,\n  isObject,\n} from \"@turf/helpers\";\n\nimport {\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n  MultiPolygon,\n  Position,\n  Polygon,\n  Feature,\n} from \"geojson\";\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\n\ntype GroupRingProps = { [prop: string]: string };\ntype GroupedRings =\n  | {\n      groupedRings: Position[][][];\n    }\n  | GroupRingProps;\n\n/**\n * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates filled contour isobands.\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular and already gridded. That is, to have consistent x and y dimensions and be at least 2x2 in size.\n * @param {Array<number>} breaks where to draw contours\n * @param {Object} [options={}] options on output\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)\n * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands\n */\nfunction isobands(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n): FeatureCollection<MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties is not an Array\");\n\n  // Isoband methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n\n  // A quick note on what 'top' and 'bottom' mean in coordinate system of `matrix`:\n  // Remember that the southern hemisphere is represented by negative numbers,\n  // so a matrix Y of 0 is actually the *bottom*, and a Y of dy - 1 is the *top*.\n\n  // check that the resulting matrix has consistent x and y dimensions and\n  // has at least a 2x2 size so that we can actually build grid squares\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    // collect all properties\n    const contourProperties = {\n      ...commonProperties,\n      ...breaksProperties[index],\n    };\n\n    contourProperties[zProperty] = (contour as GroupRingProps)[zProperty];\n\n    const multiP = multiPolygon(\n      contour.groupedRings as Position[][][],\n      contourProperties\n    );\n    return multiP;\n  });\n\n  return featureCollection(multipolygons);\n}\n\n/**\n * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} [property='elevation'] Property\n * @returns {Array<any>} contours\n */\nfunction createContourLines(\n  matrix: number[][],\n  breaks: number[],\n  property: string\n): GroupedRings[] {\n  const contours: GroupedRings[] = [];\n\n  let prevSegments: Position[][];\n  for (let i = 1; i < breaks.length; i++) {\n    // the first time through this loop, we need to create the segments for the first break\n    if (i === 1) {\n      prevSegments = getSegments(matrix, +breaks[0]);\n    }\n\n    const upperBand = +breaks[i]; // make sure the breaks value is a number\n    const lowerBand = +breaks[i - 1];\n    const segments = getSegments(matrix, upperBand);\n\n    // We will use breaks[i]'s rings to help close breaks[i-1]'s rings.\n    // breaks[i]'s rings are clockwise from the point of view of breaks[i - 1] and must be reversed for proper counterclockwise ordering.\n    // At the same time, we clone each Position, so that we don't use the same Position Array instance in different output geometries.\n    const reverseSegments = segments.map((segment) =>\n      // note that we (in-place) reverse the array result of .map and not the original segment itself.\n      segment.map((pos) => [pos[0], pos[1]]).reverse()\n    );\n\n    // use the segments from breaks[i-1] and breaks[i] to create rings, which will\n    // then be combined into polygons in the next steps.\n    const rings = assembleRings(prevSegments!.concat(reverseSegments), matrix);\n\n    // as per GeoJson rules for creating a Polygon, make sure the first element\n    // in the array of LinearRings represents the exterior ring (i.e. biggest area),\n    // and any subsequent elements represent interior rings (i.e. smaller area);\n    // this avoids rendering issues of the MultiPolygons on the map\n    const orderedRings = orderByArea(rings);\n    const polygons = groupNestedRings(orderedRings);\n\n    // If we got no polygons, we can infer that the values are either all above, below, or between the thresholds.\n    // If everything is between, we need a polygon that covers the entire grid\n    // see https://github.com/Turfjs/turf/issues/1797, https://github.com/Turfjs/turf/issues/2956\n    if (\n      polygons.length === 0 &&\n      matrix[0][0] < upperBand &&\n      matrix[0][0] >= lowerBand\n    ) {\n      const dx = matrix[0].length;\n      const dy = matrix.length;\n      polygons.push([\n        [\n          [0, 0],\n          [dx - 1, 0],\n          [dx - 1, dy - 1],\n          [0, dy - 1],\n          [0, 0],\n        ],\n      ]);\n    }\n\n    // this can add an entry where groupedRings is exactly an empty array\n    contours.push({\n      groupedRings: polygons,\n      [property]: lowerBand + \"-\" + upperBand,\n    });\n\n    prevSegments = segments;\n  }\n\n  return contours;\n}\n\n/**\n * Run marching squares across the matrix and calculate the implied counterclockwise ordered line segments from each cell.\n * @see https://en.wikipedia.org/wiki/Marching_squares for an visualization of the different cases\n * @private\n */\nfunction getSegments(\n  matrix: ReadonlyArray<ReadonlyArray<number>>,\n  threshold: number\n): [Position, Position][] {\n  const segments: [Position, Position][] = [];\n\n  const dx = matrix[0].length;\n  const dy = matrix.length;\n\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n\n      let grid =\n        (tl >= threshold ? 8 : 0) |\n        (tr >= threshold ? 4 : 0) |\n        (br >= threshold ? 2 : 0) |\n        (bl >= threshold ? 1 : 0);\n\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 2:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 3:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 4:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 5: {\n          // use the average of the 4 corners to differentiate the saddle case and correctly honor the counter-clockwise winding\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x, y + frac(bl, tl)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x + 1, y + frac(br, tr)],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x + 1, y + frac(br, tr)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x, y + frac(bl, tl)],\n              ]\n            );\n          }\n          break;\n        }\n        case 6:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 7:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 8:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 9:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 10: {\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(bl, br), y],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(tl, tr), y + 1],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(tl, tr), y + 1],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(bl, br), y],\n              ]\n            );\n          }\n          break;\n        }\n        case 11:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 12:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 13:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 14:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 15:\n          // all above\n          continue;\n      }\n    }\n  }\n\n  return segments;\n\n  // get the linear interpolation fraction of how far z is between z0 and z1\n  // See https://github.com/fschutt/marching-squares/blob/master/src/lib.rs\n  function frac(z0: number, z1: number): number {\n    if (z0 === z1) {\n      return 0.5;\n    }\n\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\n\n/**\n * Create a list of closed rings from the combined segments from breaks[i] and breaks[i-1].\n * @private\n */\nfunction assembleRings(\n  segments: Position[][],\n  matrix: number[][]\n): Position[][] {\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n\n  const contours: Position[][] = [];\n  const result: Position[][] = [];\n\n  // Assemble contiguous line segments into contours. These are at least LineStrings,\n  // but for features that do not touch the edge of the matrix, they will actually wind up\n  // being an entirely closed LinearRing.\n  while (segments.length > 0) {\n    const contour: Position[] = [...segments.shift()!];\n    contours.push(contour);\n\n    let found: boolean;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // add the segment's end point to the end of the contour\n        if (\n          segment[0][0] === contour[contour.length - 1][0] &&\n          segment[0][1] === contour[contour.length - 1][1]\n        ) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        // add the segment's start point to the start of the contour\n        if (\n          segment[1][0] === contour[0][0] &&\n          segment[1][1] === contour[0][1]\n        ) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n\n        // note that because the segments are all guaranteed to be counterclockwise,\n        // we do not join segment start to end of the contour or segment end to the start of contour\n      }\n\n      // if we reach here with found === false, that means that no remaining segments can be\n      // added to our contour. We begin again creating the next indepdenent contour.\n    } while (found);\n  }\n\n  // Now we loop again, taking the contours and ensuring that all of them are closed rings.\n  // Using segments from two different breaks[], and enforcing closed polygons are the\n  // two the major difference between the implementation of @turf/isolines and @turf/isobands.\n  while (contours.length > 0) {\n    const contour = contours[0];\n\n    // if a contour is closed, store it in the results and move to the next contour\n    if (\n      contour[0][0] === contour[contour.length - 1][0] &&\n      contour[0][1] === contour[contour.length - 1][1]\n    ) {\n      result.push(contour);\n      contours.shift();\n      continue;\n    }\n\n    // A contour that is not already closed is guaranteed to touch the bounding box of the matrix.\n    // We know that the polygon is ordered counter-clockwise, so we just need to follow\n    // the bounding box in a counterclockwise direction, looking for a contour to append.\n    // We may need to insert new positions along the corners, but we will eventually close the ring.\n\n    const end = contour[contour.length - 1];\n\n    let match: number;\n    let corner: Position;\n    if (end[0] === 0 && end[1] !== 0) {\n      // left side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === 0 && contour[0][1] < end[1], // left side, below end\n        (a, b) => b[0][1] - a[0][1] // prefer positions to the top\n      );\n      corner = [0, 0]; // bottom left corner\n    } else if (end[1] === 0 && end[0] !== dx - 1) {\n      // bottom side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === 0 && contour[0][0] > end[0], // bottom side, right of end\n        (a, b) => a[0][0] - b[0][0] // prefer positions to the left\n      );\n      corner = [dx - 1, 0]; // bottom right corner\n    } else if (end[0] === dx - 1 && end[1] !== dy - 1) {\n      // right side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === dx - 1 && contour[0][1] > end[1], // right side, above end\n        (a, b) => a[0][1] - b[0][1] // prefer positions to the bottom\n      );\n      corner = [dx - 1, dy - 1]; // top right corner\n    } else if (end[1] === dy - 1 && end[0] !== 0) {\n      // top side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === dy - 1 && contour[0][0] < end[0], // top side, left of end\n        (a, b) => b[0][0] - a[0][0] // prefer positions to the right\n      );\n      corner = [0, dy - 1]; // top left corner\n    } else {\n      throw new Error(\"Contour not closed but is not along an edge\");\n    }\n\n    if (match === -1) {\n      // we did not match a contour on this side, so we add a point in the corner to\n      // continue creating our linestring in counterclockwise order. The next\n      // run of the loop will continue trying to assemble the current contour on the next side.\n      contour.push(corner);\n    } else if (match === 0) {\n      // We looped back to a contour, and it was ourself. That means that we finished closing the ring.\n      // Add the contour to the result and remove it from the contours list to start working\n      // on the next contour.\n      contour.push([contour[0][0], contour[0][1]]);\n      result.push(contour);\n      contours.shift();\n    } else {\n      // We matched a contour, but it is not the one we're currently closing.\n      // That means that we get to add its points to our own, and remove that contour entirely.\n      // On the next loop, we'll continue trying to close the same contour, but this time from\n      // the final Position in contour will be the end of contours[match].\n      const matchedContour = contours[match];\n      contours.splice(match, 1);\n      for (const p of matchedContour) {\n        contour.push(p);\n      }\n    }\n  }\n\n  // If we get *just* a corner we close it immediately with itself, which results in\n  // a 2 point 'ring', which has zero area. We omit these before returning.\n  for (let i = 0; i < result.length; i++) {\n    if (result[i].length < 4) {\n      result.splice(i, 1);\n      i--;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Transform isobands of 2D grid to polygons for the map\n *\n * @private\n * @param {Array<any>} contours Contours\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<any>} contours\n */\nfunction rescaleContours(\n  contours: GroupedRings[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n): GroupedRings[] {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  // resize and shift each point/line of the isobands\n  return contours.map(function (contour) {\n    contour.groupedRings = (contour.groupedRings as Position[][][]).map(\n      function (lineRingSet) {\n        return lineRingSet.map(function (lineRing) {\n          return lineRing.map((point: Position) => [\n            point[0] * scaleX + x0,\n            point[1] * scaleY + y0,\n          ]);\n        });\n      }\n    );\n\n    return contour;\n  });\n}\n\n/*  utility functions */\n\n/**\n * Returns an array of coordinates (of LinearRings) in descending order by area\n *\n * @private\n * @param {Array<LineString>} ringsCoords array of closed LineString\n * @returns {Array} array of the input LineString ordered by area\n */\nfunction orderByArea(ringsCoords: Position[][]): Position[][] {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    // associate each lineRing with its area\n    return { ring: coords, area: area(polygon([coords])) };\n  });\n  ringsWithArea.sort(function (a, b) {\n    // bigger --> smaller\n    return b.area - a.area;\n  });\n  // create a new array of linearRings coordinates ordered by their area\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\n\n/**\n * Returns an array of arrays of coordinates, each representing\n * a set of (coordinates of) nested LinearRings,\n * i.e. the first ring contains all the others\n *\n * @private\n * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area\n * @returns {Array<Array>} Array of coordinates of nested LinearRings\n */\nfunction groupNestedRings(orderedLinearRings: Position[][]): Position[][][] {\n  // create a list of the (coordinates of) LinearRings\n  const lrList = orderedLinearRings.map((lr) => {\n    return { lrCoordinates: lr, grouped: false };\n  });\n  const groupedLinearRingsCoords: Position[][][] = [];\n\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        // create new group starting with the larger not already grouped ring\n        const group: Position[][] = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        // group all the rings contained by the outermost ring\n        OUTER: for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              // we cannot group any linear rings that are contained in hole rings for this group\n              for (let k = 1; k < group.length; k++) {\n                if (isInside(lrPoly, polygon([group[k]]))) {\n                  continue OUTER;\n                }\n              }\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        // insert the new group\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\n\n/**\n * @private\n * @param {Polygon} testPolygon polygon of interest\n * @param {Polygon} targetPolygon polygon you want to compare with\n * @returns {boolean} true if test-Polygon is inside target-Polygon\n */\nfunction isInside(\n  testPolygon: Feature<Polygon>,\n  targetPolygon: Feature<Polygon>\n): boolean {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @private\n * @param {Array<Object>} list list of objects which might contain the 'group' attribute\n * @returns {boolean} true if all the objects in the list are marked as grouped\n */\nfunction allGrouped(\n  list: { grouped: boolean; lrCoordinates: Position[] }[]\n): boolean {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Utility function to help close contours into rings\n *\n * @private\n * @param contours The list of contours\n * @param test Return true if a contour is a candidate for being joined\n * @param sort Compare two candidates, returning a positive number will swap the best match from a to b\n * @returns An index of the contour to join, or -1 if no contour was found\n */\nfunction getAdjacentContour(\n  contours: Position[][],\n  test: (contour: Position[]) => boolean,\n  sort: (a: Position[], b: Position[]) => number\n): number {\n  let match = -1;\n  for (let j = 0; j < contours.length; j++) {\n    if (test(contours[j])) {\n      if (match === -1 || sort(contours[match], contours[j]) > 0) {\n        match = j;\n      }\n    }\n  }\n\n  return match;\n}\n\nexport { isobands };\nexport default isobands;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nimport { Feature, FeatureCollection, Point } from \"geojson\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nexport function gridToMatrix(\n  grid: FeatureCollection<Point>,\n  options: { zProperty?: string; flip?: boolean; flags?: boolean } = {}\n): any {\n  // Optional parameters\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { zProperty = \"elevation\", flip = false, flags = false } = options;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties == null) {\n        point.properties = {};\n      }\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points: FeatureCollection<Point>, flip: boolean) {\n  var pointsByLatitude: Record<number | string, Feature<Point>[]> = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, (point) => {\n    var lat = getCoords(point)[1] as number;\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  const pointMatrix: Feature<Point>[][] = [];\n  for (const row of Object.values(pointsByLatitude)) {\n    pointMatrix.push(row.sort((a, b) => getCoords(a)[0] - getCoords(b)[0]));\n  }\n\n  // sort rows (of points with the same latitude) by latitude\n  pointMatrix.sort(\n    flip\n      ? (a, b) => getCoords(a[0])[1] - getCoords(b[0])[1]\n      : (a, b) => getCoords(b[0])[1] - getCoords(a[0])[1]\n  );\n\n  return pointMatrix;\n}\n"],"mappings":"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","names":["collectionOf","isObject","isObject","collectionOf","contour"]}