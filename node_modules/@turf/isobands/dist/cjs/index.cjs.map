{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-isobands/dist/cjs/index.cjs","../../index.ts","../../lib/grid-to-matrix.ts"],"names":["isObject","collectionOf","contour"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-isobands/dist/cjs/index.cjs","sourcesContent":[null,"import { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf } from \"@turf/invariant\";\nimport {\n  polygon,\n  multiPolygon,\n  featureCollection,\n  isObject,\n} from \"@turf/helpers\";\n\nimport {\n  FeatureCollection,\n  Point,\n  GeoJsonProperties,\n  MultiPolygon,\n  Position,\n  Polygon,\n  Feature,\n} from \"geojson\";\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\n\ntype GroupRingProps = { [prop: string]: string };\ntype GroupedRings =\n  | {\n      groupedRings: Position[][][];\n    }\n  | GroupRingProps;\n\n/**\n * Takes a square or rectangular grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates filled contour isobands.\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular and already gridded. That is, to have consistent x and y dimensions and be at least 2x2 in size.\n * @param {Array<number>} breaks where to draw contours\n * @param {Object} [options={}] options on output\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isobands\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoband (order defined by breaks)\n * @returns {FeatureCollection<MultiPolygon>} a FeatureCollection of {@link MultiPolygon} features representing isobands\n */\nfunction isobands(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n): FeatureCollection<MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties is not an Array\");\n\n  // Isoband methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n\n  // A quick note on what 'top' and 'bottom' mean in coordinate system of `matrix`:\n  // Remember that the southern hemisphere is represented by negative numbers,\n  // so a matrix Y of 0 is actually the *bottom*, and a Y of dy - 1 is the *top*.\n\n  // check that the resulting matrix has consistent x and y dimensions and\n  // has at least a 2x2 size so that we can actually build grid squares\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    // collect all properties\n    const contourProperties = {\n      ...commonProperties,\n      ...breaksProperties[index],\n    };\n\n    contourProperties[zProperty] = (contour as GroupRingProps)[zProperty];\n\n    const multiP = multiPolygon(\n      contour.groupedRings as Position[][][],\n      contourProperties\n    );\n    return multiP;\n  });\n\n  return featureCollection(multipolygons);\n}\n\n/**\n * Creates the contours lines (featuresCollection of polygon features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the IsoBands function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} [property='elevation'] Property\n * @returns {Array<any>} contours\n */\nfunction createContourLines(\n  matrix: number[][],\n  breaks: number[],\n  property: string\n): GroupedRings[] {\n  const contours: GroupedRings[] = [];\n\n  let prevSegments: Position[][];\n  for (let i = 1; i < breaks.length; i++) {\n    // the first time through this loop, we need to create the segments for the first break\n    if (i === 1) {\n      prevSegments = getSegments(matrix, +breaks[0]);\n    }\n\n    const upperBand = +breaks[i]; // make sure the breaks value is a number\n    const lowerBand = +breaks[i - 1];\n    const segments = getSegments(matrix, upperBand);\n\n    // We will use breaks[i]'s rings to help close breaks[i-1]'s rings.\n    // breaks[i]'s rings are clockwise from the point of view of breaks[i - 1] and must be reversed for proper counterclockwise ordering.\n    // At the same time, we clone each Position, so that we don't use the same Position Array instance in different output geometries.\n    const reverseSegments = segments.map((segment) =>\n      // note that we (in-place) reverse the array result of .map and not the original segment itself.\n      segment.map((pos) => [pos[0], pos[1]]).reverse()\n    );\n\n    // use the segments from breaks[i-1] and breaks[i] to create rings, which will\n    // then be combined into polygons in the next steps.\n    const rings = assembleRings(prevSegments!.concat(reverseSegments), matrix);\n\n    // as per GeoJson rules for creating a Polygon, make sure the first element\n    // in the array of LinearRings represents the exterior ring (i.e. biggest area),\n    // and any subsequent elements represent interior rings (i.e. smaller area);\n    // this avoids rendering issues of the MultiPolygons on the map\n    const orderedRings = orderByArea(rings);\n    const polygons = groupNestedRings(orderedRings);\n\n    // If we got no polygons, we can infer that the values are either all above, below, or between the thresholds.\n    // If everything is between, we need a polygon that covers the entire grid\n    // see https://github.com/Turfjs/turf/issues/1797, https://github.com/Turfjs/turf/issues/2956\n    if (\n      polygons.length === 0 &&\n      matrix[0][0] < upperBand &&\n      matrix[0][0] >= lowerBand\n    ) {\n      const dx = matrix[0].length;\n      const dy = matrix.length;\n      polygons.push([\n        [\n          [0, 0],\n          [dx - 1, 0],\n          [dx - 1, dy - 1],\n          [0, dy - 1],\n          [0, 0],\n        ],\n      ]);\n    }\n\n    // this can add an entry where groupedRings is exactly an empty array\n    contours.push({\n      groupedRings: polygons,\n      [property]: lowerBand + \"-\" + upperBand,\n    });\n\n    prevSegments = segments;\n  }\n\n  return contours;\n}\n\n/**\n * Run marching squares across the matrix and calculate the implied counterclockwise ordered line segments from each cell.\n * @see https://en.wikipedia.org/wiki/Marching_squares for an visualization of the different cases\n * @private\n */\nfunction getSegments(\n  matrix: ReadonlyArray<ReadonlyArray<number>>,\n  threshold: number\n): [Position, Position][] {\n  const segments: [Position, Position][] = [];\n\n  const dx = matrix[0].length;\n  const dy = matrix.length;\n\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n\n      let grid =\n        (tl >= threshold ? 8 : 0) |\n        (tr >= threshold ? 4 : 0) |\n        (br >= threshold ? 2 : 0) |\n        (bl >= threshold ? 1 : 0);\n\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 2:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 3:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 4:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 5: {\n          // use the average of the 4 corners to differentiate the saddle case and correctly honor the counter-clockwise winding\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x, y + frac(bl, tl)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x + 1, y + frac(br, tr)],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x + 1, y + frac(br, tr)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x, y + frac(bl, tl)],\n              ]\n            );\n          }\n          break;\n        }\n        case 6:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 7:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 8:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 9:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 10: {\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(bl, br), y],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(tl, tr), y + 1],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(tl, tr), y + 1],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(bl, br), y],\n              ]\n            );\n          }\n          break;\n        }\n        case 11:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 12:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 13:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 14:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 15:\n          // all above\n          continue;\n      }\n    }\n  }\n\n  return segments;\n\n  // get the linear interpolation fraction of how far z is between z0 and z1\n  // See https://github.com/fschutt/marching-squares/blob/master/src/lib.rs\n  function frac(z0: number, z1: number): number {\n    if (z0 === z1) {\n      return 0.5;\n    }\n\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\n\n/**\n * Create a list of closed rings from the combined segments from breaks[i] and breaks[i-1].\n * @private\n */\nfunction assembleRings(\n  segments: Position[][],\n  matrix: number[][]\n): Position[][] {\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n\n  const contours: Position[][] = [];\n  const result: Position[][] = [];\n\n  // Assemble contiguous line segments into contours. These are at least LineStrings,\n  // but for features that do not touch the edge of the matrix, they will actually wind up\n  // being an entirely closed LinearRing.\n  while (segments.length > 0) {\n    const contour: Position[] = [...segments.shift()!];\n    contours.push(contour);\n\n    let found: boolean;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // add the segment's end point to the end of the contour\n        if (\n          segment[0][0] === contour[contour.length - 1][0] &&\n          segment[0][1] === contour[contour.length - 1][1]\n        ) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        // add the segment's start point to the start of the contour\n        if (\n          segment[1][0] === contour[0][0] &&\n          segment[1][1] === contour[0][1]\n        ) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n\n        // note that because the segments are all guaranteed to be counterclockwise,\n        // we do not join segment start to end of the contour or segment end to the start of contour\n      }\n\n      // if we reach here with found === false, that means that no remaining segments can be\n      // added to our contour. We begin again creating the next indepdenent contour.\n    } while (found);\n  }\n\n  // Now we loop again, taking the contours and ensuring that all of them are closed rings.\n  // Using segments from two different breaks[], and enforcing closed polygons are the\n  // two the major difference between the implementation of @turf/isolines and @turf/isobands.\n  while (contours.length > 0) {\n    const contour = contours[0];\n\n    // if a contour is closed, store it in the results and move to the next contour\n    if (\n      contour[0][0] === contour[contour.length - 1][0] &&\n      contour[0][1] === contour[contour.length - 1][1]\n    ) {\n      result.push(contour);\n      contours.shift();\n      continue;\n    }\n\n    // A contour that is not already closed is guaranteed to touch the bounding box of the matrix.\n    // We know that the polygon is ordered counter-clockwise, so we just need to follow\n    // the bounding box in a counterclockwise direction, looking for a contour to append.\n    // We may need to insert new positions along the corners, but we will eventually close the ring.\n\n    const end = contour[contour.length - 1];\n\n    let match: number;\n    let corner: Position;\n    if (end[0] === 0 && end[1] !== 0) {\n      // left side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === 0 && contour[0][1] < end[1], // left side, below end\n        (a, b) => b[0][1] - a[0][1] // prefer positions to the top\n      );\n      corner = [0, 0]; // bottom left corner\n    } else if (end[1] === 0 && end[0] !== dx - 1) {\n      // bottom side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === 0 && contour[0][0] > end[0], // bottom side, right of end\n        (a, b) => a[0][0] - b[0][0] // prefer positions to the left\n      );\n      corner = [dx - 1, 0]; // bottom right corner\n    } else if (end[0] === dx - 1 && end[1] !== dy - 1) {\n      // right side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][0] === dx - 1 && contour[0][1] > end[1], // right side, above end\n        (a, b) => a[0][1] - b[0][1] // prefer positions to the bottom\n      );\n      corner = [dx - 1, dy - 1]; // top right corner\n    } else if (end[1] === dy - 1 && end[0] !== 0) {\n      // top side\n      match = getAdjacentContour(\n        contours,\n        (contour) => contour[0][1] === dy - 1 && contour[0][0] < end[0], // top side, left of end\n        (a, b) => b[0][0] - a[0][0] // prefer positions to the right\n      );\n      corner = [0, dy - 1]; // top left corner\n    } else {\n      throw new Error(\"Contour not closed but is not along an edge\");\n    }\n\n    if (match === -1) {\n      // we did not match a contour on this side, so we add a point in the corner to\n      // continue creating our linestring in counterclockwise order. The next\n      // run of the loop will continue trying to assemble the current contour on the next side.\n      contour.push(corner);\n    } else if (match === 0) {\n      // We looped back to a contour, and it was ourself. That means that we finished closing the ring.\n      // Add the contour to the result and remove it from the contours list to start working\n      // on the next contour.\n      contour.push([contour[0][0], contour[0][1]]);\n      result.push(contour);\n      contours.shift();\n    } else {\n      // We matched a contour, but it is not the one we're currently closing.\n      // That means that we get to add its points to our own, and remove that contour entirely.\n      // On the next loop, we'll continue trying to close the same contour, but this time from\n      // the final Position in contour will be the end of contours[match].\n      const matchedContour = contours[match];\n      contours.splice(match, 1);\n      for (const p of matchedContour) {\n        contour.push(p);\n      }\n    }\n  }\n\n  // If we get *just* a corner we close it immediately with itself, which results in\n  // a 2 point 'ring', which has zero area. We omit these before returning.\n  for (let i = 0; i < result.length; i++) {\n    if (result[i].length < 4) {\n      result.splice(i, 1);\n      i--;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Transform isobands of 2D grid to polygons for the map\n *\n * @private\n * @param {Array<any>} contours Contours\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<any>} contours\n */\nfunction rescaleContours(\n  contours: GroupedRings[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n): GroupedRings[] {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  // resize and shift each point/line of the isobands\n  return contours.map(function (contour) {\n    contour.groupedRings = (contour.groupedRings as Position[][][]).map(\n      function (lineRingSet) {\n        return lineRingSet.map(function (lineRing) {\n          return lineRing.map((point: Position) => [\n            point[0] * scaleX + x0,\n            point[1] * scaleY + y0,\n          ]);\n        });\n      }\n    );\n\n    return contour;\n  });\n}\n\n/*  utility functions */\n\n/**\n * Returns an array of coordinates (of LinearRings) in descending order by area\n *\n * @private\n * @param {Array<LineString>} ringsCoords array of closed LineString\n * @returns {Array} array of the input LineString ordered by area\n */\nfunction orderByArea(ringsCoords: Position[][]): Position[][] {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    // associate each lineRing with its area\n    return { ring: coords, area: area(polygon([coords])) };\n  });\n  ringsWithArea.sort(function (a, b) {\n    // bigger --> smaller\n    return b.area - a.area;\n  });\n  // create a new array of linearRings coordinates ordered by their area\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\n\n/**\n * Returns an array of arrays of coordinates, each representing\n * a set of (coordinates of) nested LinearRings,\n * i.e. the first ring contains all the others\n *\n * @private\n * @param {Array} orderedLinearRings array of coordinates (of LinearRings) in descending order by area\n * @returns {Array<Array>} Array of coordinates of nested LinearRings\n */\nfunction groupNestedRings(orderedLinearRings: Position[][]): Position[][][] {\n  // create a list of the (coordinates of) LinearRings\n  const lrList = orderedLinearRings.map((lr) => {\n    return { lrCoordinates: lr, grouped: false };\n  });\n  const groupedLinearRingsCoords: Position[][][] = [];\n\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        // create new group starting with the larger not already grouped ring\n        const group: Position[][] = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        // group all the rings contained by the outermost ring\n        OUTER: for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              // we cannot group any linear rings that are contained in hole rings for this group\n              for (let k = 1; k < group.length; k++) {\n                if (isInside(lrPoly, polygon([group[k]]))) {\n                  continue OUTER;\n                }\n              }\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        // insert the new group\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\n\n/**\n * @private\n * @param {Polygon} testPolygon polygon of interest\n * @param {Polygon} targetPolygon polygon you want to compare with\n * @returns {boolean} true if test-Polygon is inside target-Polygon\n */\nfunction isInside(\n  testPolygon: Feature<Polygon>,\n  targetPolygon: Feature<Polygon>\n): boolean {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @private\n * @param {Array<Object>} list list of objects which might contain the 'group' attribute\n * @returns {boolean} true if all the objects in the list are marked as grouped\n */\nfunction allGrouped(\n  list: { grouped: boolean; lrCoordinates: Position[] }[]\n): boolean {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Utility function to help close contours into rings\n *\n * @private\n * @param contours The list of contours\n * @param test Return true if a contour is a candidate for being joined\n * @param sort Compare two candidates, returning a positive number will swap the best match from a to b\n * @returns An index of the contour to join, or -1 if no contour was found\n */\nfunction getAdjacentContour(\n  contours: Position[][],\n  test: (contour: Position[]) => boolean,\n  sort: (a: Position[], b: Position[]) => number\n): number {\n  let match = -1;\n  for (let j = 0; j < contours.length; j++) {\n    if (test(contours[j])) {\n      if (match === -1 || sort(contours[match], contours[j]) > 0) {\n        match = j;\n      }\n    }\n  }\n\n  return match;\n}\n\nexport { isobands };\nexport default isobands;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nimport { Feature, FeatureCollection, Point } from \"geojson\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nexport function gridToMatrix(\n  grid: FeatureCollection<Point>,\n  options: { zProperty?: string; flip?: boolean; flags?: boolean } = {}\n): any {\n  // Optional parameters\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { zProperty = \"elevation\", flip = false, flags = false } = options;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties == null) {\n        point.properties = {};\n      }\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points: FeatureCollection<Point>, flip: boolean) {\n  var pointsByLatitude: Record<number | string, Feature<Point>[]> = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, (point) => {\n    var lat = getCoords(point)[1] as number;\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  const pointMatrix: Feature<Point>[][] = [];\n  for (const row of Object.values(pointsByLatitude)) {\n    pointMatrix.push(row.sort((a, b) => getCoords(a)[0] - getCoords(b)[0]));\n  }\n\n  // sort rows (of points with the same latitude) by latitude\n  pointMatrix.sort(\n    flip\n      ? (a, b) => getCoords(a[0])[1] - getCoords(b[0])[1]\n      : (a, b) => getCoords(b[0])[1] - getCoords(a[0])[1]\n  );\n\n  return pointMatrix;\n}\n"]}