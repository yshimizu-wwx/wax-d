{"version":3,"sources":["../../index.ts","../../lib/javascript-astar.ts"],"sourcesContent":["import {\n  Polygon,\n  Feature,\n  FeatureCollection,\n  LineString,\n  Geometry,\n  Point,\n} from \"geojson\";\nimport { bbox } from \"@turf/bbox\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { distance } from \"@turf/distance\";\nimport { transformScale as scale } from \"@turf/transform-scale\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nimport {\n  Coord,\n  Units,\n  point,\n  isNumber,\n  lineString,\n  isObject,\n  featureCollection,\n  feature,\n} from \"@turf/helpers\";\nimport { Graph, GridNode, astar } from \"./lib/javascript-astar.js\";\n\n/**\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\n * any {@link Feature} in obstacles {@link FeatureCollection}<{@link Polygon}>\n *\n * @function\n * @param {Coord} start point\n * @param {Coord} end point\n * @param {Object} [options={}] optional parameters\n * @param {Polygon|Feature<Polygon>|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\n * @param {Units} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}.\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\n * @returns {Feature<LineString>} shortest path between start and end\n * @example\n * var start = [-5, -6];\n * var end = [9, -6];\n * var options = {\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]]).geometry\n * };\n *\n * var path = turf.shortestPath(start, end, options);\n *\n * //addToMap\n * var addToMap = [start, end, options.obstacles, path];\n */\nfunction shortestPath(\n  start: Coord,\n  end: Coord,\n  options: {\n    obstacles?: Polygon | Feature<Polygon> | FeatureCollection<Polygon>;\n    units?: Units;\n    resolution?: number;\n  } = {}\n): Feature<LineString> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  let obstacles = options.obstacles || featureCollection([]);\n  let resolution = options.resolution || 100;\n\n  // validation\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && (!isNumber(resolution) || resolution <= 0))\n    throw new Error(\"options.resolution must be a number, greater than 0\");\n\n  // Normalize Inputs\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n\n  // Handle obstacles\n  if (obstacles.type === \"FeatureCollection\") {\n    if (obstacles.features.length === 0) {\n      return lineString([startCoord, endCoord]);\n    }\n  } else if (\n    obstacles.type === \"Feature\" &&\n    obstacles.geometry.type === \"Polygon\"\n  ) {\n    obstacles = featureCollection([obstacles]);\n  } else if (obstacles.type === \"Polygon\") {\n    obstacles = featureCollection([feature(getGeom(obstacles))]);\n  } else {\n    throw new Error(\"invalid obstacles\");\n  }\n\n  // define path grid area\n  const collection: FeatureCollection<Geometry> = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  const box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\n  const [west, south, east, north] = box;\n\n  collection.features.pop();\n  collection.features.pop();\n\n  const columnsWithFraction =\n    distance([west, south], [east, south], options) / resolution;\n  const cellWidth = (east - west) / columnsWithFraction;\n\n  const rowsWithFraction =\n    distance([west, south], [west, north], options) / resolution;\n  const cellHeight = (north - south) / rowsWithFraction;\n\n  // adjust origin of the grid\n  const deltaX = ((columnsWithFraction % 1) * cellWidth) / 2;\n  const deltaY = ((rowsWithFraction % 1) * cellHeight) / 2;\n\n  // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n  const pointMatrix: string[][] = [];\n  const matrix: number[][] = [];\n\n  let closestToStart: { x: number; y: number };\n  let closestToEnd: { x: number; y: number };\n  let minDistStart = Infinity;\n  let minDistEnd = Infinity;\n  let currentY = north - deltaY;\n  let r = 0;\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    const matrixRow = [];\n    const pointMatrixRow = [];\n    let currentX = west + deltaX;\n    let c = 0;\n    while (currentX <= east) {\n      const pt = point([currentX, currentY]);\n      const isInsideObstacle = isInside(pt, obstacles);\n      // feed obstacles matrix\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      // set closest points\n      const distStart = distance(pt, start);\n      // if (distStart < minDistStart) {\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = { x: c, y: r };\n      }\n      const distEnd = distance(pt, end);\n      // if (distEnd < minDistEnd) {\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = { x: c, y: r };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n\n  // find path on matrix grid\n\n  // javascript-astar ----------------------\n  const graph = new Graph(matrix, { diagonal: true });\n  const startOnMatrix = graph.grid[closestToStart!.y][closestToStart!.x];\n  const endOnMatrix = graph.grid[closestToEnd!.y][closestToEnd!.x];\n  const result: GridNode[] = astar.search(graph, startOnMatrix, endOnMatrix);\n\n  const path = [startCoord];\n  result.forEach(function (coord) {\n    const coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord);\n  // ---------------------------------------\n\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return cleanCoords(lineString(path));\n}\n\n/**\n * Checks if Point is inside any of the Polygons\n *\n * @private\n * @param {Feature<Point>} pt to check\n * @param {FeatureCollection<Polygon>} polygons features\n * @returns {boolean} if inside or not\n */\nfunction isInside(pt: Feature<Point>, polygons: FeatureCollection<Polygon>) {\n  for (let i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport { shortestPath };\nexport default shortestPath;\n","// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node: GridNode) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap<GridNode>(function (node) {\n    return node.f;\n  });\n}\n\n/**\n * Astar\n * @private\n */\nexport var astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (\n    graph: Graph,\n    start: GridNode,\n    end: GridNode,\n    options: {\n      closest?: boolean;\n    } = {}\n  ) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = astar.heuristics.manhattan,\n      closest = options.closest ?? false;\n\n    var openHeap = getHeap(),\n      closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (\n              neighbor.h < closestNode.h ||\n              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\n            ) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (\n      pos0: { x: number; y: number },\n      pos1: { x: number; y: number }\n    ) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (\n      pos0: { x: number; y: number },\n      pos1: { x: number; y: number }\n    ) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    },\n  },\n  cleanNode: function (node: GridNode) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = undefined;\n  },\n};\n\n/**\n * A graph memory structure\n *\n * @private\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options] Options\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n * @returns {void} Graph\n */\nexport class Graph {\n  nodes: GridNode[] = [];\n  diagonal: boolean;\n  grid: GridNode[][] = [];\n  dirtyNodes: GridNode[] = [];\n\n  constructor(gridIn: number[][], options: { diagonal?: boolean } = {}) {\n    this.diagonal = !!options.diagonal;\n    for (var x = 0; x < gridIn.length; x++) {\n      this.grid[x] = [];\n\n      for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n        var node = new GridNode(x, y, row[y]);\n        this.grid[x][y] = node;\n        this.nodes.push(node);\n      }\n    }\n    this.init();\n  }\n\n  init() {\n    this.dirtyNodes = [];\n    for (var i = 0; i < this.nodes.length; i++) {\n      astar.cleanNode(this.nodes[i]);\n    }\n  }\n\n  cleanDirty() {\n    for (var i = 0; i < this.dirtyNodes.length; i++) {\n      astar.cleanNode(this.dirtyNodes[i]);\n    }\n    this.dirtyNodes = [];\n  }\n\n  markDirty(node: GridNode) {\n    this.dirtyNodes.push(node);\n  }\n\n  neighbors(node: GridNode) {\n    var ret = [],\n      x = node.x,\n      y = node.y,\n      grid = this.grid;\n\n    // West\n    if (grid[x - 1] && grid[x - 1][y]) {\n      ret.push(grid[x - 1][y]);\n    }\n\n    // East\n    if (grid[x + 1] && grid[x + 1][y]) {\n      ret.push(grid[x + 1][y]);\n    }\n\n    // South\n    if (grid[x] && grid[x][y - 1]) {\n      ret.push(grid[x][y - 1]);\n    }\n\n    // North\n    if (grid[x] && grid[x][y + 1]) {\n      ret.push(grid[x][y + 1]);\n    }\n\n    if (this.diagonal) {\n      // Southwest\n      if (grid[x - 1] && grid[x - 1][y - 1]) {\n        ret.push(grid[x - 1][y - 1]);\n      }\n\n      // Southeast\n      if (grid[x + 1] && grid[x + 1][y - 1]) {\n        ret.push(grid[x + 1][y - 1]);\n      }\n\n      // Northwest\n      if (grid[x - 1] && grid[x - 1][y + 1]) {\n        ret.push(grid[x - 1][y + 1]);\n      }\n\n      // Northeast\n      if (grid[x + 1] && grid[x + 1][y + 1]) {\n        ret.push(grid[x + 1][y + 1]);\n      }\n    }\n\n    return ret;\n  }\n\n  toString() {\n    var graphString = [],\n      nodes = this.grid, // when using grid\n      rowDebug,\n      row,\n      y,\n      l;\n    for (var x = 0, len = nodes.length; x < len; x++) {\n      rowDebug = [];\n      row = nodes[x];\n      for (y = 0, l = row.length; y < l; y++) {\n        rowDebug.push(row[y].weight);\n      }\n      graphString.push(rowDebug.join(\" \"));\n    }\n    return graphString.join(\"\\n\");\n  }\n}\n\nexport class GridNode {\n  x: number;\n  y: number;\n  weight: number;\n\n  visited: boolean = false;\n  parent?: GridNode;\n  h: number = 0;\n  g: number = 0;\n  f: number = 0;\n  closed: boolean = false;\n\n  constructor(x: number, y: number, weight: number) {\n    this.x = x;\n    this.y = y;\n    this.weight = weight;\n  }\n  toString() {\n    return \"[\" + this.x + \" \" + this.y + \"]\";\n  }\n\n  getCost(fromNeighbor: GridNode) {\n    // Take diagonal weight into consideration.\n    if (\n      fromNeighbor &&\n      fromNeighbor.x !== this.x &&\n      fromNeighbor.y !== this.y\n    ) {\n      return this.weight * 1.41421;\n    }\n    return this.weight;\n  }\n\n  isWall() {\n    return this.weight === 0;\n  }\n}\n\nclass BinaryHeap<T> {\n  content: T[] = [];\n  scoreFunction: (o: T) => number;\n\n  constructor(scoreFunction: (o: T) => number) {\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element: T) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end!;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove(node: T) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop()!;\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  rescoreElement(node: T) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown(n: number) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1,\n        parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n        // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  }\n\n  bubbleUp(n: number) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null,\n        child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)!) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n        // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  }\n}\n"],"mappings":"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","names":[]}