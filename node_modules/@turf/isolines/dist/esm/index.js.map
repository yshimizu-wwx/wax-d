{"version":3,"sources":["../../index.ts","../../lib/grid-to-matrix.ts"],"sourcesContent":["import { bbox } from \"@turf/bbox\";\nimport { coordEach } from \"@turf/meta\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { multiLineString, featureCollection, isObject } from \"@turf/helpers\";\nimport { gridToMatrix } from \"./lib/grid-to-matrix.js\";\nimport {\n  FeatureCollection,\n  Point,\n  MultiLineString,\n  Feature,\n  GeoJsonProperties,\n  Position,\n} from \"geojson\";\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @function\n * @param {FeatureCollection<Point>} pointGrid input points - must be square or rectangular and already gridded. That is, to have consistent x and y dimensions and be at least 2x2 in size.\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(\n  pointGrid: FeatureCollection<Point>,\n  breaks: number[],\n  options?: {\n    zProperty?: string;\n    commonProperties?: GeoJsonProperties;\n    breaksProperties?: GeoJsonProperties[];\n  }\n) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  const matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n\n  // A quick note on what 'top' and 'bottom' mean in coordinate system of `matrix`:\n  // Remember that the southern hemisphere is represented by negative numbers,\n  // so a matrix Y of 0 is actually the *bottom*, and a Y of dy - 1 is the *top*.\n\n  // check that the resulting matrix has consistent x and y dimensions and\n  // has at least a 2x2 size so that we can actually build grid squares\n  const dx = matrix[0].length;\n  if (matrix.length < 2 || dx < 2) {\n    throw new Error(\"Matrix of points must be at least 2x2\");\n  }\n  for (let i = 1; i < matrix.length; i++) {\n    if (matrix[i].length !== dx) {\n      throw new Error(\"Matrix of points is not uniform in the x dimension\");\n    }\n  }\n\n  const createdIsoLines = createIsoLines(\n    matrix,\n    breaks,\n    zProperty,\n    commonProperties,\n    breaksProperties\n  );\n  const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n\n  return featureCollection(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks BreakProps\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(\n  matrix: number[][],\n  breaks: number[],\n  zProperty: string,\n  commonProperties: GeoJsonProperties,\n  breaksProperties: GeoJsonProperties[]\n): Feature<MultiLineString>[] {\n  const results = [];\n  for (let i = 0; i < breaks.length; i++) {\n    const threshold = +breaks[i]; // make sure it's a number\n\n    const properties = { ...commonProperties, ...breaksProperties[i] };\n    properties[zProperty] = threshold;\n    const isoline = multiLineString(isoContours(matrix, threshold), properties);\n\n    results.push(isoline);\n  }\n  return results;\n}\n\nfunction isoContours(\n  matrix: ReadonlyArray<ReadonlyArray<number>>,\n  threshold: number\n): Position[][] {\n  // see https://en.wikipedia.org/wiki/Marching_squares\n  const segments: [Position, Position][] = [];\n\n  const dy = matrix.length;\n  const dx = matrix[0].length;\n\n  for (let y = 0; y < dy - 1; y++) {\n    for (let x = 0; x < dx - 1; x++) {\n      const tr = matrix[y + 1][x + 1];\n      const br = matrix[y][x + 1];\n      const bl = matrix[y][x];\n      const tl = matrix[y + 1][x];\n\n      let grid =\n        (tl >= threshold ? 8 : 0) |\n        (tr >= threshold ? 4 : 0) |\n        (br >= threshold ? 2 : 0) |\n        (bl >= threshold ? 1 : 0);\n\n      switch (grid) {\n        case 0:\n          continue;\n        case 1:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 2:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 3:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 4:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 5: {\n          // use the average of the 4 corners to differentiate the saddle case and correctly honor the counter-clockwise winding\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x, y + frac(bl, tl)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x + 1, y + frac(br, tr)],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x + frac(tl, tr), y + 1],\n                [x + 1, y + frac(br, tr)],\n              ],\n              [\n                [x + frac(bl, br), y],\n                [x, y + frac(bl, tl)],\n              ]\n            );\n          }\n          break;\n        }\n        case 6:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 7:\n          segments.push([\n            [x + frac(tl, tr), y + 1],\n            [x, y + frac(bl, tl)],\n          ]);\n          break;\n        case 8:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 9:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 10: {\n          const avg = (tl + tr + br + bl) / 4;\n          const above = avg >= threshold;\n\n          if (above) {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(bl, br), y],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(tl, tr), y + 1],\n              ]\n            );\n          } else {\n            segments.push(\n              [\n                [x, y + frac(bl, tl)],\n                [x + frac(tl, tr), y + 1],\n              ],\n              [\n                [x + 1, y + frac(br, tr)],\n                [x + frac(bl, br), y],\n              ]\n            );\n          }\n          break;\n        }\n        case 11:\n          segments.push([\n            [x + 1, y + frac(br, tr)],\n            [x + frac(tl, tr), y + 1],\n          ]);\n          break;\n        case 12:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 13:\n          segments.push([\n            [x + frac(bl, br), y],\n            [x + 1, y + frac(br, tr)],\n          ]);\n          break;\n        case 14:\n          segments.push([\n            [x, y + frac(bl, tl)],\n            [x + frac(bl, br), y],\n          ]);\n          break;\n        case 15:\n          // all above\n          continue;\n      }\n    }\n  }\n\n  const contours: Position[][] = [];\n\n  while (segments.length > 0) {\n    const contour: Position[] = [...segments.shift()!];\n    contours.push(contour);\n\n    let found: boolean;\n    do {\n      found = false;\n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        // add the segment's end point to the end of the contour\n        if (\n          segment[0][0] === contour[contour.length - 1][0] &&\n          segment[0][1] === contour[contour.length - 1][1]\n        ) {\n          found = true;\n          contour.push(segment[1]);\n          segments.splice(i, 1);\n          break;\n        }\n        // add the segment's start point to the start of the contour\n        if (\n          segment[1][0] === contour[0][0] &&\n          segment[1][1] === contour[0][1]\n        ) {\n          found = true;\n          contour.unshift(segment[0]);\n          segments.splice(i, 1);\n          break;\n        }\n      }\n    } while (found);\n  }\n\n  return contours;\n\n  // get the linear interpolation fraction of how far z is between z0 and z1\n  // See https://github.com/fschutt/marching-squares/blob/master/src/lib.rs\n  function frac(z0: number, z1: number): number {\n    if (z0 === z1) {\n      return 0.5;\n    }\n\n    let t = (threshold - z0) / (z1 - z0);\n    return t > 1 ? 1 : t < 0 ? 0 : t;\n  }\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(\n  createdIsoLines: Feature<MultiLineString>[],\n  matrix: number[][],\n  points: FeatureCollection<Point>\n) {\n  // get dimensions (on the map) of the original grid\n  const gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n\n  // get number of cells per side\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n\n  const resize = (point: number[]) => {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach((isoline) => {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport { isolines };\nexport default isolines;\n","import { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nimport { Feature, FeatureCollection, Point } from \"geojson\";\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nexport function gridToMatrix(\n  grid: FeatureCollection<Point>,\n  options: { zProperty?: string; flip?: boolean; flags?: boolean } = {}\n): any {\n  // Optional parameters\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { zProperty = \"elevation\", flip = false, flags = false } = options;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties == null) {\n        point.properties = {};\n      }\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points: FeatureCollection<Point>, flip: boolean) {\n  var pointsByLatitude: Record<number | string, Feature<Point>[]> = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, (point) => {\n    var lat = getCoords(point)[1] as number;\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  const pointMatrix: Feature<Point>[][] = [];\n  for (const row of Object.values(pointsByLatitude)) {\n    pointMatrix.push(row.sort((a, b) => getCoords(a)[0] - getCoords(b)[0]));\n  }\n\n  // sort rows (of points with the same latitude) by latitude\n  pointMatrix.sort(\n    flip\n      ? (a, b) => getCoords(a[0])[1] - getCoords(b[0])[1]\n      : (a, b) => getCoords(b[0])[1] - getCoords(a[0])[1]\n  );\n\n  return pointMatrix;\n}\n"],"mappings":"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","names":["collectionOf","isObject","isObject","collectionOf"]}