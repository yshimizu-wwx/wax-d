{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { Position } from \"geojson\";\nimport { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { booleanPointOnLine } from \"@turf/boolean-point-on-line\";\nimport { lineString } from \"@turf/helpers\";\n\n// To-Do => Improve Typescript GeoJSON handling\n\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @function\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(\n  geojson: any,\n  options: {\n    mutate?: boolean;\n  } = {}\n) {\n  // Backwards compatible with v4.0\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson);\n\n  // Store new \"clean\" points in this Array\n  var newCoords = [];\n\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson, type);\n      break;\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line, type));\n      });\n      break;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons: any) {\n        var polyPoints: Position[] = [];\n        polygons.forEach(function (ring: Position[]) {\n          polyPoints.push(cleanLine(ring, type));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n    case \"Point\":\n      return geojson;\n    case \"MultiPoint\":\n      var existing: Record<string, true> = {};\n      getCoords(geojson).forEach(function (coord: any) {\n        var key = coord.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n    default:\n      throw new Error(type + \" geometry not supported\");\n  }\n\n  // Support input mutation\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n    return { type: type, coordinates: newCoords };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n    return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id,\n    });\n  }\n}\n\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @param {string} type Type of geometry\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line: Position[], type: string) {\n  const points = getCoords(line);\n  // handle \"clean\" segment\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n\n  const newPoints = [];\n\n  // Segments based approach. With initial segment a-b, keep comparing to a\n  // longer segment a-c and as long as b is still on a-c, b is a redundant\n  // point.\n  let a = 0,\n    b = 1,\n    c = 2;\n\n  // Guaranteed we'll use the first point.\n  newPoints.push(points[a]);\n  // While there is still room to extend the segment ...\n  while (c < points.length) {\n    if (booleanPointOnLine(points[b], lineString([points[a], points[c]]))) {\n      // b is on a-c, so we can discard point b, and extend a-b to be the same\n      // as a-c as the basis for comparison during the next iteration.\n      b = c;\n    } else {\n      // b is NOT on a-c, suggesting a-c is not an extension of a-b. Commit a-b\n      // as a necessary segment.\n      newPoints.push(points[b]);\n\n      // Make our a-b for the next iteration start from the end of the segment\n      // that was just locked in i.e. next a-b should be the current b-(b+1).\n      a = b;\n      b++;\n      c = b;\n    }\n    // Plan to look at the next point during the next iteration.\n    c++;\n  }\n  // No remaining points, so commit the current a-b segment.\n  newPoints.push(points[b]);\n\n  if (type === \"Polygon\" || type === \"MultiPolygon\") {\n    // For polygons need to make sure the start / end point wasn't one of the\n    // points that needed to be cleaned.\n    // https://github.com/Turfjs/turf/issues/2406\n    // For points [a, b, c, ..., z, a]\n    // if a is on line b-z, it too can be removed. New array becomes\n    // [b, c, ..., z, b]\n    if (\n      booleanPointOnLine(\n        newPoints[0],\n        lineString([newPoints[1], newPoints[newPoints.length - 2]])\n      )\n    ) {\n      newPoints.shift(); // Discard starting point.\n      newPoints.pop(); // Discard closing point.\n      newPoints.push(newPoints[0]); // Duplicate the new closing point to end of array.\n    }\n\n    // (Multi)Polygons must have at least 4 points and be closed.\n    if (newPoints.length < 4) {\n      throw new Error(\"invalid polygon, fewer than 4 points\");\n    }\n    if (!equals(newPoints[0], newPoints[newPoints.length - 1])) {\n      throw new Error(\"invalid polygon, first and last points not equal\");\n    }\n  }\n\n  return newPoints;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1: Position, pt2: Position) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport { cleanCoords };\nexport default cleanCoords;\n"],"mappings":"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","names":[]}