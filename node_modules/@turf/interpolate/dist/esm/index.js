// index.ts
import { bbox } from "@turf/bbox";
import { hexGrid } from "@turf/hex-grid";
import { pointGrid } from "@turf/point-grid";
import { distance } from "@turf/distance";
import { centroid } from "@turf/centroid";
import { squareGrid } from "@turf/square-grid";
import { triangleGrid } from "@turf/triangle-grid";
import { clone } from "@turf/clone";
import { featureCollection, validateBBox } from "@turf/helpers";
import { featureEach } from "@turf/meta";
import { collectionOf } from "@turf/invariant";
function interpolate(points, cellSize, options) {
  var _a, _b, _c, _d;
  options = options || {};
  if (typeof options !== "object") {
    throw new Error("options is invalid");
  }
  if (!points) {
    throw new Error("points is required");
  }
  collectionOf(points, "Point", "input must contain Points");
  if (!cellSize) {
    throw new Error("cellSize is required");
  }
  var gridType = (_a = options.gridType) != null ? _a : "square";
  var property = (_b = options.property) != null ? _b : "elevation";
  var weight = (_c = options.weight) != null ? _c : 1;
  var box = (_d = options.bbox) != null ? _d : bbox(points);
  if (weight !== void 0 && typeof weight !== "number") {
    throw new Error("weight must be a number");
  }
  validateBBox(box);
  var grid;
  switch (gridType) {
    case "point":
    case "points":
      grid = pointGrid(box, cellSize, options);
      break;
    case "square":
    case "squares":
      grid = squareGrid(box, cellSize, options);
      break;
    case "hex":
    case "hexes":
      grid = hexGrid(box, cellSize, options);
      break;
    case "triangle":
    case "triangles":
      grid = triangleGrid(box, cellSize, options);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var results = [];
  featureEach(grid, function(gridFeature) {
    var _a2;
    var zw = 0;
    var sw = 0;
    featureEach(points, function(point) {
      var _a3;
      var gridPoint = gridType === "point" ? gridFeature : centroid(gridFeature);
      var d = distance(gridPoint, point, options);
      var zValue;
      if (property !== void 0) {
        zValue = (_a3 = point.properties) == null ? void 0 : _a3[property];
      }
      if (zValue === void 0) {
        zValue = point.geometry.coordinates[2];
      }
      if (zValue === void 0) {
        throw new Error("zValue is missing");
      }
      if (d === 0) {
        zw = zValue;
      }
      var w = 1 / Math.pow(d, weight);
      sw += w;
      zw += w * zValue;
    });
    var newFeature = clone(gridFeature);
    (_a2 = newFeature.properties) != null ? _a2 : newFeature.properties = {};
    newFeature.properties[property] = zw / sw;
    results.push(newFeature);
  });
  return featureCollection(results);
}
var index_default = interpolate;
export {
  index_default as default,
  interpolate
};
//# sourceMappingURL=index.js.map