{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-interpolate/dist/cjs/index.cjs","../../index.ts"],"names":["_a"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-interpolate/dist/cjs/index.cjs","sourcesContent":[null,"import { bbox } from \"@turf/bbox\";\nimport { hexGrid } from \"@turf/hex-grid\";\nimport { pointGrid } from \"@turf/point-grid\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { squareGrid } from \"@turf/square-grid\";\nimport { triangleGrid } from \"@turf/triangle-grid\";\nimport { clone } from \"@turf/clone\";\nimport { featureCollection, Grid, Units, validateBBox } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { BBox, Feature, FeatureCollection, Point, Polygon } from \"geojson\";\n\n/**\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\n *\n * @function\n * @param {FeatureCollection<Point>} points with known value\n * @param {number} cellSize the distance across each grid point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\n * @param {Units} [options.units='kilometers'] used in calculating cellSize. Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}.\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\n * @param {BBox}   [options.bbox=bbox(points)] Bounding Box Array [west, south, east, north] associated with the FeatureCollection.\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\n * @example\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point\n * turf.featureEach(points, function(point) {\n *     point.properties.solRad = Math.random() * 50;\n * });\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\n * var grid = turf.interpolate(points, 100, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction interpolate<T extends Grid = \"square\">(\n  points: FeatureCollection<Point>,\n  cellSize: number,\n  options?: {\n    gridType?: T;\n    property?: string;\n    units?: Units;\n    weight?: number;\n    bbox?: BBox;\n  }\n): FeatureCollection<T extends \"point\" ? Point : Polygon> {\n  // Optional parameters\n  options = options || {};\n\n  // Validation pre-options parsing\n  if (typeof options !== \"object\") {\n    throw new Error(\"options is invalid\");\n  }\n  if (!points) {\n    throw new Error(\"points is required\");\n  }\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) {\n    throw new Error(\"cellSize is required\");\n  }\n\n  var gridType = options.gridType ?? \"square\";\n  var property = options.property ?? \"elevation\";\n  var weight = options.weight ?? 1;\n  var box = options.bbox ?? bbox(points);\n\n  // validation post options-parsing\n  if (weight !== undefined && typeof weight !== \"number\") {\n    throw new Error(\"weight must be a number\");\n  }\n\n  validateBBox(box);\n\n  var grid;\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n  var results: Feature<Point | Polygon>[] = [];\n  featureEach<Point | Polygon>(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0;\n    // calculate the distance from each input point to the grid points\n    featureEach(points, function (point) {\n      var gridPoint =\n        gridType === \"point\"\n          ? (gridFeature as Feature<Point>)\n          : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue;\n      // property has priority for zValue, fallbacks to 3rd coordinate from geometry\n      if (property !== undefined) {\n        zValue = point.properties?.[property];\n      }\n      if (zValue === undefined) {\n        zValue = point.geometry.coordinates[2];\n      }\n      if (zValue === undefined) {\n        throw new Error(\"zValue is missing\");\n      }\n      if (d === 0) {\n        zw = zValue;\n      }\n      var w = 1.0 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    });\n    // write interpolated value for each grid point\n    var newFeature = clone(gridFeature);\n    newFeature.properties ??= {};\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results) as FeatureCollection<\n    T extends \"point\" ? Point : Polygon\n  >;\n}\n\nexport { interpolate };\nexport default interpolate;\n"]}