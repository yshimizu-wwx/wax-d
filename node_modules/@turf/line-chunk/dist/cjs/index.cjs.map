{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-line-chunk/dist/cjs/index.cjs","../../index.ts"],"names":[],"mappings":"AAAA;ACAA,sCAAuB;AACvB,wDAA+B;AAC/B,kCAA4B;AAC5B,wCAAmD;AA4BnD,SAAS,SAAA,CACP,OAAA,EAMA,aAAA,EACA,QAAA,EAGI,CAAC,CAAA,EAC0B;AAE/B,EAAA,GAAA,CAAI,CAAC,+BAAA,OAAgB,CAAA,EAAG,MAAM,IAAI,KAAA,CAAM,oBAAoB,CAAA;AAC5D,EAAA,MAAM,EAAE,MAAA,EAAQ,YAAA,EAAc,QAAA,EAAU,MAAM,EAAA,EAAI,OAAA;AAGlD,EAAA,GAAA,CAAI,CAAC,OAAA,EAAS,MAAM,IAAI,KAAA,CAAM,qBAAqB,CAAA;AACnD,EAAA,GAAA,CAAI,cAAA,GAAiB,CAAA,EAAG;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,sCAAsC,CAAA;AAAA,EACxD;AAGA,EAAA,MAAM,QAAA,EAAiC,CAAC,CAAA;AAGxC,EAAA,+BAAA,OAAY,EAAS,CAAC,OAAA,EAAA,GAAwB;AAE5C,IAAA,GAAA,CAAI,OAAA,EAAS;AACX,MAAA,OAAA,CAAQ,QAAA,CAAS,YAAA,EAAc,OAAA,CAAQ,QAAA,CAAS,WAAA,CAAY,OAAA,CAAQ,CAAA;AAAA,IACtE;AAEA,IAAA,iBAAA;AAAA,MACE,OAAA;AAAA,MACA,aAAA;AAAA,MACA,KAAA;AAAA,MACA,CAAC,OAAA,EAAA,GAAY;AACX,QAAA,OAAA,CAAQ,IAAA,CAAK,OAAO,CAAA;AAAA,MACtB;AAAA,IACF,CAAA;AAAA,EACF,CAAC,CAAA;AACD,EAAA,OAAO,wCAAA,OAAyB,CAAA;AAClC;AAYA,SAAS,iBAAA,CACP,IAAA,EACA,aAAA,EACA,KAAA,EACA,QAAA,EACM;AACN,EAAA,IAAI,WAAA,EAAa,4BAAA,IAAO,EAAM,EAAE,MAAa,CAAC,CAAA;AAG9C,EAAA,GAAA,CAAI,WAAA,GAAc,aAAA,EAAe;AAC/B,IAAA,OAAO,QAAA,CAAS,IAAI,CAAA;AAAA,EACtB;AAEA,EAAA,IAAI,iBAAA,EAAmB,WAAA,EAAa,aAAA;AAGpC,EAAA,GAAA,CAAI,CAAC,MAAA,CAAO,SAAA,CAAU,gBAAgB,CAAA,EAAG;AACvC,IAAA,iBAAA,EAAmB,IAAA,CAAK,KAAA,CAAM,gBAAgB,EAAA,EAAI,CAAA;AAAA,EACpD;AAEA,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,gBAAA,EAAkB,CAAA,EAAA,EAAK;AACzC,IAAA,IAAI,QAAA,EAAU,4CAAA;AAAA,MACZ,IAAA;AAAA,MACA,cAAA,EAAgB,CAAA;AAAA,MAChB,cAAA,EAAA,CAAiB,EAAA,EAAI,CAAA,CAAA;AAAA,MACrB,EAAE,MAAa;AAAA,IACjB,CAAA;AACA,IAAA,QAAA,CAAS,OAAO,CAAA;AAAA,EAClB;AACF;AAGA,IAAO,cAAA,EAAQ,SAAA;ADtEf;AACE;AACA;AACF,+DAAC","file":"/home/runner/work/turf/turf/packages/turf-line-chunk/dist/cjs/index.cjs","sourcesContent":[null,"import { length } from \"@turf/length\";\nimport { lineSliceAlong } from \"@turf/line-slice-along\";\nimport { flattenEach } from \"@turf/meta\";\nimport { featureCollection, isObject, Units } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n} from \"geojson\";\n\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @function\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\nfunction lineChunk<T extends LineString | MultiLineString>(\n  geojson:\n    | Feature<T>\n    | FeatureCollection<T>\n    | T\n    | GeometryCollection\n    | Feature<GeometryCollection>,\n  segmentLength: number,\n  options: {\n    units?: Units;\n    reverse?: boolean;\n  } = {}\n): FeatureCollection<LineString> {\n  // Optional parameters\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { units = \"kilometers\", reverse = false } = options;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0) {\n    throw new Error(\"segmentLength must be greater than 0\");\n  }\n\n  // Container\n  const results: Feature<LineString>[] = [];\n\n  // Flatten each feature to simple LineString\n  flattenEach(geojson, (feature: Feature<T>) => {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse) {\n      feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n    }\n\n    sliceLineSegments(\n      feature as Feature<LineString>,\n      segmentLength,\n      units,\n      (segment) => {\n        results.push(segment);\n      }\n    );\n  });\n  return featureCollection(results);\n}\n\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {Units}[units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\nfunction sliceLineSegments(\n  line: Feature<LineString>,\n  segmentLength: number,\n  units: Units,\n  callback: (feature: Feature<LineString>) => void\n): void {\n  var lineLength = length(line, { units: units });\n\n  // If the line is shorter than the segment length then the orginal line is returned.\n  if (lineLength <= segmentLength) {\n    return callback(line);\n  }\n\n  var numberOfSegments = lineLength / segmentLength;\n\n  // If numberOfSegments is integer, no need to plus 1\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(\n      line,\n      segmentLength * i,\n      segmentLength * (i + 1),\n      { units: units }\n    );\n    callback(outline);\n  }\n}\n\nexport { lineChunk };\nexport default lineChunk;\n"]}