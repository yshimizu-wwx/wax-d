"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// index.ts
var _clone = require('@turf/clone');
var _kdbush = require('kdbush'); var _kdbush2 = _interopRequireDefault(_kdbush);
var _geokdbush = require('geokdbush'); var geokdbush = _interopRequireWildcard(_geokdbush);
function clustersDbscan(points, maxDistance, options = {}) {
  if (options.mutate !== true) points = _clone.clone.call(void 0, points);
  const minPoints = options.minPoints || 3;
  const kdIndex = new (0, _kdbush2.default)(points.features.length);
  for (const point of points.features) {
    kdIndex.add(point.geometry.coordinates[0], point.geometry.coordinates[1]);
  }
  kdIndex.finish();
  var visited = points.features.map((_) => false);
  var assigned = points.features.map((_) => false);
  var isnoise = points.features.map((_) => false);
  var clusterIds = points.features.map((_) => -1);
  const regionQuery = (index) => {
    const point = points.features[index];
    const [x, y] = point.geometry.coordinates;
    return geokdbush.around(kdIndex, x, y, void 0, maxDistance).map((id) => ({
      minX: points.features[id].geometry.coordinates[0],
      minY: points.features[id].geometry.coordinates[1],
      maxX: points.features[id].geometry.coordinates[0],
      maxY: points.features[id].geometry.coordinates[1],
      index: id
    }));
  };
  const expandCluster = (clusteredId, neighbors) => {
    for (var i = 0; i < neighbors.length; i++) {
      var neighbor = neighbors[i];
      const neighborIndex = neighbor.index;
      if (!visited[neighborIndex]) {
        visited[neighborIndex] = true;
        const nextNeighbors = regionQuery(neighborIndex);
        if (nextNeighbors.length >= minPoints) {
          neighbors.push(...nextNeighbors);
        }
      }
      if (!assigned[neighborIndex]) {
        assigned[neighborIndex] = true;
        clusterIds[neighborIndex] = clusteredId;
      }
    }
  };
  var nextClusteredId = 0;
  points.features.forEach((_, index) => {
    if (visited[index]) return;
    const neighbors = regionQuery(index);
    if (neighbors.length >= minPoints) {
      const clusteredId = nextClusteredId;
      nextClusteredId++;
      visited[index] = true;
      expandCluster(clusteredId, neighbors);
    } else {
      isnoise[index] = true;
    }
  });
  points.features.forEach((_, index) => {
    var clusterPoint = points.features[index];
    if (!clusterPoint.properties) {
      clusterPoint.properties = {};
    }
    if (clusterIds[index] >= 0) {
      clusterPoint.properties.dbscan = isnoise[index] ? "edge" : "core";
      clusterPoint.properties.cluster = clusterIds[index];
    } else {
      clusterPoint.properties.dbscan = "noise";
    }
  });
  return points;
}
var index_default = clustersDbscan;



exports.clustersDbscan = clustersDbscan; exports.default = index_default;
//# sourceMappingURL=index.cjs.map