{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { GeoJsonProperties, FeatureCollection, Point } from \"geojson\";\nimport { clone } from \"@turf/clone\";\nimport { Units } from \"@turf/helpers\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\n\n/**\n * Point classification within the cluster.\n *\n * @typedef {\"core\" | \"edge\" | \"noise\"} Dbscan\n */\ntype Dbscan = \"core\" | \"edge\" | \"noise\";\n\n/**\n * Properties assigned to each clustered point.\n *\n * @extends GeoJsonProperties\n * @typedef {object} DbscanProps\n * @property {Dbscan} [dbscan] type of point it has been classified as\n * @property {number} [cluster] associated clusterId\n */\ntype DbscanProps = GeoJsonProperties & {\n  dbscan?: Dbscan;\n  cluster?: number;\n};\n\n// Structure of a point in the spatial index\ntype IndexedPoint = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  index: number;\n};\n\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link https://en.wikipedia.org/wiki/DBSCAN|DBSCAN's} data clustering algorithm.\n *\n * @function\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers by default, see options)\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units=\"kilometers\"] in which `maxDistance` is expressed, Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point, DbscanProps>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(\n  points: FeatureCollection<Point>,\n  maxDistance: number,\n  options: {\n    units?: Units;\n    minPoints?: number;\n    mutate?: boolean;\n  } = {}\n): FeatureCollection<Point, DbscanProps> {\n  // Input validation being handled by Typescript\n  // TODO oops! No it isn't. Typescript doesn't do runtime checking. We should\n  // re-enable these checks, though will have to wait for a major version bump\n  // as more restrictive checks could break currently working code.\n  // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n  // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n  // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n  // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n\n  // Clone points to prevent any mutations\n  if (options.mutate !== true) points = clone(points);\n\n  // Defaults\n  const minPoints = options.minPoints || 3;\n\n  // Create a spatial index\n  const kdIndex = new KDBush(points.features.length);\n  // Index each point for spatial queries\n  for (const point of points.features) {\n    kdIndex.add(point.geometry.coordinates[0], point.geometry.coordinates[1]);\n  }\n  kdIndex.finish();\n\n  // Keeps track of whether a point has been visited or not.\n  var visited = points.features.map((_) => false);\n\n  // Keeps track of whether a point is assigned to a cluster or not.\n  var assigned = points.features.map((_) => false);\n\n  // Keeps track of whether a point is noise|edge or not.\n  var isnoise = points.features.map((_) => false);\n\n  // Keeps track of the clusterId for each point\n  var clusterIds: number[] = points.features.map((_) => -1);\n\n  // Function to find neighbors of a point within a given distance\n  const regionQuery = (index: number): IndexedPoint[] => {\n    const point = points.features[index];\n    const [x, y] = point.geometry.coordinates;\n\n    return (\n      geokdbush\n        // @ts-expect-error 2345 until https://github.com/mourner/geokdbush/issues/20 is resolved\n        .around<number>(kdIndex, x, y, undefined, maxDistance)\n        .map((id) => ({\n          minX: points.features[id].geometry.coordinates[0],\n          minY: points.features[id].geometry.coordinates[1],\n          maxX: points.features[id].geometry.coordinates[0],\n          maxY: points.features[id].geometry.coordinates[1],\n          index: id,\n        }))\n    );\n  };\n\n  // Function to expand a cluster\n  const expandCluster = (clusteredId: number, neighbors: IndexedPoint[]) => {\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i];\n      const neighborIndex = neighbor.index;\n      if (!visited[neighborIndex]) {\n        visited[neighborIndex] = true;\n        const nextNeighbors = regionQuery(neighborIndex);\n        if (nextNeighbors.length >= minPoints) {\n          neighbors.push(...nextNeighbors);\n        }\n      }\n      if (!assigned[neighborIndex]) {\n        assigned[neighborIndex] = true;\n        clusterIds[neighborIndex] = clusteredId;\n      }\n    }\n  };\n\n  // Main DBSCAN clustering algorithm\n  var nextClusteredId = 0;\n  points.features.forEach((_, index) => {\n    if (visited[index]) return;\n    const neighbors = regionQuery(index);\n    if (neighbors.length >= minPoints) {\n      const clusteredId = nextClusteredId;\n      nextClusteredId++;\n      visited[index] = true;\n      expandCluster(clusteredId, neighbors);\n    } else {\n      isnoise[index] = true;\n    }\n  });\n\n  // Assign DBSCAN properties to each point\n  points.features.forEach((_, index) => {\n    var clusterPoint = points.features[index];\n    if (!clusterPoint.properties) {\n      clusterPoint.properties = {};\n    }\n\n    if (clusterIds[index] >= 0) {\n      clusterPoint.properties.dbscan = isnoise[index] ? \"edge\" : \"core\";\n      clusterPoint.properties.cluster = clusterIds[index];\n    } else {\n      clusterPoint.properties.dbscan = \"noise\";\n    }\n  });\n\n  return points as FeatureCollection<Point, DbscanProps>;\n}\n\nexport { Dbscan, DbscanProps, clustersDbscan };\nexport default clustersDbscan;\n"],"mappings":";AACA,SAAS,aAAa;AAEtB,OAAO,YAAY;AACnB,YAAY,eAAe;AAsD3B,SAAS,eACP,QACA,aACA,UAII,CAAC,GACkC;AAWvC,MAAI,QAAQ,WAAW,KAAM,UAAS,MAAM,MAAM;AAGlD,QAAM,YAAY,QAAQ,aAAa;AAGvC,QAAM,UAAU,IAAI,OAAO,OAAO,SAAS,MAAM;AAEjD,aAAW,SAAS,OAAO,UAAU;AACnC,YAAQ,IAAI,MAAM,SAAS,YAAY,CAAC,GAAG,MAAM,SAAS,YAAY,CAAC,CAAC;AAAA,EAC1E;AACA,UAAQ,OAAO;AAGf,MAAI,UAAU,OAAO,SAAS,IAAI,CAAC,MAAM,KAAK;AAG9C,MAAI,WAAW,OAAO,SAAS,IAAI,CAAC,MAAM,KAAK;AAG/C,MAAI,UAAU,OAAO,SAAS,IAAI,CAAC,MAAM,KAAK;AAG9C,MAAI,aAAuB,OAAO,SAAS,IAAI,CAAC,MAAM,EAAE;AAGxD,QAAM,cAAc,CAAC,UAAkC;AACrD,UAAM,QAAQ,OAAO,SAAS,KAAK;AACnC,UAAM,CAAC,GAAG,CAAC,IAAI,MAAM,SAAS;AAE9B,WAGK,iBAAe,SAAS,GAAG,GAAG,QAAW,WAAW,EACpD,IAAI,CAAC,QAAQ;AAAA,MACZ,MAAM,OAAO,SAAS,EAAE,EAAE,SAAS,YAAY,CAAC;AAAA,MAChD,MAAM,OAAO,SAAS,EAAE,EAAE,SAAS,YAAY,CAAC;AAAA,MAChD,MAAM,OAAO,SAAS,EAAE,EAAE,SAAS,YAAY,CAAC;AAAA,MAChD,MAAM,OAAO,SAAS,EAAE,EAAE,SAAS,YAAY,CAAC;AAAA,MAChD,OAAO;AAAA,IACT,EAAE;AAAA,EAER;AAGA,QAAM,gBAAgB,CAAC,aAAqB,cAA8B;AACxE,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,WAAW,UAAU,CAAC;AAC1B,YAAM,gBAAgB,SAAS;AAC/B,UAAI,CAAC,QAAQ,aAAa,GAAG;AAC3B,gBAAQ,aAAa,IAAI;AACzB,cAAM,gBAAgB,YAAY,aAAa;AAC/C,YAAI,cAAc,UAAU,WAAW;AACrC,oBAAU,KAAK,GAAG,aAAa;AAAA,QACjC;AAAA,MACF;AACA,UAAI,CAAC,SAAS,aAAa,GAAG;AAC5B,iBAAS,aAAa,IAAI;AAC1B,mBAAW,aAAa,IAAI;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AAGA,MAAI,kBAAkB;AACtB,SAAO,SAAS,QAAQ,CAAC,GAAG,UAAU;AACpC,QAAI,QAAQ,KAAK,EAAG;AACpB,UAAM,YAAY,YAAY,KAAK;AACnC,QAAI,UAAU,UAAU,WAAW;AACjC,YAAM,cAAc;AACpB;AACA,cAAQ,KAAK,IAAI;AACjB,oBAAc,aAAa,SAAS;AAAA,IACtC,OAAO;AACL,cAAQ,KAAK,IAAI;AAAA,IACnB;AAAA,EACF,CAAC;AAGD,SAAO,SAAS,QAAQ,CAAC,GAAG,UAAU;AACpC,QAAI,eAAe,OAAO,SAAS,KAAK;AACxC,QAAI,CAAC,aAAa,YAAY;AAC5B,mBAAa,aAAa,CAAC;AAAA,IAC7B;AAEA,QAAI,WAAW,KAAK,KAAK,GAAG;AAC1B,mBAAa,WAAW,SAAS,QAAQ,KAAK,IAAI,SAAS;AAC3D,mBAAa,WAAW,UAAU,WAAW,KAAK;AAAA,IACpD,OAAO;AACL,mBAAa,WAAW,SAAS;AAAA,IACnC;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAGA,IAAO,gBAAQ;","names":[]}