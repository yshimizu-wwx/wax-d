{"version":3,"sources":["../../index.ts"],"sourcesContent":["import {\n  polygon,\n  isObject,\n  isNumber,\n  Coord,\n  Units,\n  point,\n  radiansToDegrees,\n} from \"@turf/helpers\";\nimport { destination } from \"@turf/destination\";\nimport { transformRotate } from \"@turf/transform-rotate\";\nimport { getCoord } from \"@turf/invariant\";\nimport { GeoJsonProperties, Feature, Polygon, Position } from \"geojson\";\n\n/**\n * Takes a {@link Point} and calculates the ellipse polygon given two semi-axes expressed in variable units and steps for precision.\n *\n * @param {Coord} center center point\n * @param {number} xSemiAxis semi (major) axis of the ellipse along the x-axis\n * @param {number} ySemiAxis semi (minor) axis of the ellipse along the y-axis\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.angle=0] angle of rotation in decimal degrees, positive clockwise\n * @param {Coord} [options.pivot=center] point around which any rotation will be performed\n * @param {number} [options.steps=64] number of steps\n * @param {Units} [options.units='kilometers'] unit of measurement for axes. Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} ellipse polygon\n * @example\n * var center = [-75, 40];\n * var xSemiAxis = 5;\n * var ySemiAxis = 2;\n * var ellipse = turf.ellipse(center, xSemiAxis, ySemiAxis);\n *\n * //addToMap\n * var addToMap = [turf.point(center), ellipse]\n */\nfunction ellipse(\n  center: Coord,\n  xSemiAxis: number,\n  ySemiAxis: number,\n  options: {\n    steps?: number;\n    units?: Units;\n    angle?: number;\n    pivot?: Coord;\n    properties?: GeoJsonProperties;\n  }\n): Feature<Polygon> {\n  // Optional params\n  options = options || {};\n  let steps = options.steps || 64;\n  const units = options.units || \"kilometers\";\n  let angle = options.angle || 0;\n  const pivot = options.pivot || center;\n  const properties = options.properties || {};\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (!xSemiAxis) throw new Error(\"xSemiAxis is required\");\n  if (!ySemiAxis) throw new Error(\"ySemiAxis is required\");\n  if (!isObject(options)) throw new Error(\"options must be an object\");\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isNumber(angle)) throw new Error(\"angle must be a number\");\n\n  const centerCoords = getCoord(\n    transformRotate(point(getCoord(center)), angle, { pivot })\n  );\n\n  angle = -90 + angle;\n\n  // Divide steps by 4 for one quadrant\n  steps = Math.ceil(steps / 4);\n\n  let quadrantParameters = [];\n  let parameters = [];\n\n  const a = xSemiAxis;\n  const b = ySemiAxis;\n\n  // Gradient x intersect\n  const c = b;\n\n  // Gradient of line\n  const m = (a - b) / (Math.PI / 2);\n\n  // Area under line\n  const A = ((a + b) * Math.PI) / 4;\n\n  // Weighting function\n  const v = 0.5;\n\n  const k = steps;\n\n  let w = 0;\n  let x = 0;\n\n  for (let i = 0; i < steps; i++) {\n    x += w;\n\n    if (m === 0) {\n      // It's a circle, so use simplified c*w - A/k == 0\n      w = A / k / c;\n    } else {\n      // Otherwise, use full (v*m)*w^2 + (m*x+c)*w - A/k == 0\n      // Solve as quadratic ax^2 + bx + c = 0\n      w =\n        (-(m * x + c) +\n          Math.sqrt(Math.pow(m * x + c, 2) - 4 * (v * m) * -(A / k))) /\n        (2 * (v * m));\n    }\n    if (x != 0) {\n      // easier to add it later to avoid having twice the same point\n      quadrantParameters.push(x);\n    }\n  }\n\n  //NE\n  parameters.push(0);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(quadrantParameters[i]);\n  }\n  //NW\n  parameters.push(Math.PI / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(\n      Math.PI - quadrantParameters[quadrantParameters.length - i - 1]\n    );\n  }\n  //SW\n  parameters.push(Math.PI);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(Math.PI + quadrantParameters[i]);\n  }\n  //SE\n  parameters.push((3 * Math.PI) / 2);\n  for (let i = 0; i < quadrantParameters.length; i++) {\n    parameters.push(\n      2 * Math.PI - quadrantParameters[quadrantParameters.length - i - 1]\n    );\n  }\n  parameters.push(0);\n\n  // We can now construct the ellipse\n  const coords: Position[] = [];\n  for (const param of parameters) {\n    const theta = Math.atan2(b * Math.sin(param), a * Math.cos(param));\n    const r = Math.sqrt(\n      (Math.pow(a, 2) * Math.pow(b, 2)) /\n        (Math.pow(a * Math.sin(theta), 2) + Math.pow(b * Math.cos(theta), 2))\n    );\n    coords.push(\n      destination(centerCoords, r, angle + radiansToDegrees(theta), {\n        units: units,\n      }).geometry.coordinates\n    );\n  }\n  return polygon([coords], properties);\n}\n\nexport { ellipse };\nexport default ellipse;\n"],"mappings":"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","names":[]}