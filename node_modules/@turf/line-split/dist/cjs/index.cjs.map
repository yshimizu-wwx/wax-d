{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-line-split/dist/cjs/index.cjs","../../index.ts"],"names":["feature","line"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-line-split/dist/cjs/index.cjs","sourcesContent":[null,"import { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { truncate } from \"@turf/truncate\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { getCoords, getCoord, getType } from \"@turf/invariant\";\nimport { featureEach, featureReduce, flattenEach } from \"@turf/meta\";\nimport { lineString, featureCollection, feature } from \"@turf/helpers\";\nimport {\n  Feature,\n  FeatureCollection,\n  GeoJsonTypes,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\n\ntype Splitter = Feature<\n  Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon\n>;\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @function\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter, split]\n *\n * split.features[0].properties.stroke = \"red\";\n * split.features[1].properties.stroke = \"blue\";\n */\nfunction lineSplit<T extends LineString>(\n  line: Feature<T> | T,\n  splitter: Splitter\n): FeatureCollection<T> {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n\n  const lineType = getType(line) as Exclude<GeoJsonTypes, \"Feature\">;\n  const splitterType = getType(splitter) as Exclude<GeoJsonTypes, \"Feature\">;\n\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\")\n    throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\")\n    throw new Error(\"splitter cannot be a GeometryCollection\");\n\n  // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n  var truncatedSplitter = truncate(splitter, { precision: 7 });\n\n  // Ensure we're consistently sending Feature<LineString> into the splitLine methods.\n  if (line.type !== \"Feature\") {\n    line = feature(line);\n  }\n\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(\n        line as Feature<LineString>,\n        truncatedSplitter as Feature<Point>\n      ) as FeatureCollection<T>;\n    case \"MultiPoint\":\n      return splitLineWithPoints(\n        line as Feature<LineString>,\n        truncatedSplitter as Feature<MultiPoint>\n      ) as FeatureCollection<T>;\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(\n        line as Feature<LineString>,\n        lineIntersect(\n          line,\n          truncatedSplitter as Feature<\n            LineString | MultiLineString | Polygon | MultiPolygon\n          >,\n          {\n            ignoreSelfIntersections: true,\n          }\n        )\n      ) as FeatureCollection<T>;\n  }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(\n  line: Feature<LineString>,\n  splitter: FeatureCollection<Point> | Feature<MultiPoint>\n) {\n  var results: Feature<LineString>[] = [];\n  var tree = rbush<LineString>();\n\n  flattenEach(\n    splitter as FeatureCollection<Point>, // this cast should be unnecessary (and is wrong, it could contain MultiPoints), but is a workaround for bad flattenEach typings\n    function (point: Feature<Point>) {\n      // Add index/id to features (needed for filter)\n      results.forEach(function (feature, index) {\n        feature.id = index;\n      });\n      // First Point - doesn't need to handle any previous line results\n      if (!results.length) {\n        results = splitLineWithPoint(line, point).features;\n        tree.load(featureCollection(results));\n        // Split with remaining points - lines might needed to be split multiple times\n      } else {\n        // Find all lines that are within the splitter's bbox\n        var search = tree.search(point);\n\n        if (search.features.length) {\n          // RBush might return multiple lines - only process the closest line to splitter\n          var closestLine = findClosestFeature(point, search);\n\n          // Remove closest line from results since this will be split into two lines\n          // This removes any duplicates inside the results & index\n          results = results.filter(function (feature) {\n            return feature.id !== closestLine.id;\n          });\n          tree.remove(closestLine);\n\n          // Append the two newly split lines into the results\n          featureEach(splitLineWithPoint(closestLine, point), function (line) {\n            results.push(line);\n            tree.insert(line);\n          });\n        }\n      }\n    }\n  );\n  return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(\n  line: Feature<LineString>,\n  splitter: Feature<Point>\n) {\n  var results = [];\n\n  // handle endpoints\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (\n    pointsEquals(startPoint, getCoord(splitter)) ||\n    pointsEquals(endPoint, getCoord(splitter))\n  )\n    return featureCollection([line]);\n\n  // Create spatial index\n  var tree = rbush<LineString>();\n  var segments = lineSegment(line);\n  tree.load(segments);\n\n  // Find all segments that are within bbox of splitter\n  var search = tree.search(splitter);\n\n  // Return itself if point is not within spatial index\n  if (!search.features.length) return featureCollection([line]);\n\n  // RBush might return multiple lines - only process the closest line to splitter\n  var closestSegment = findClosestFeature(splitter, search);\n\n  // Initial value is the first point of the first segments (beginning of line)\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(\n    segments,\n    function (previous, current, index) {\n      var currentCoords = getCoords(current)[1];\n      var splitterCoords = getCoord(splitter);\n\n      // Location where segment intersects with line\n      if (index === closestSegment.id) {\n        previous.push(splitterCoords);\n        results.push(lineString(previous));\n        // Don't duplicate splitter coordinate (Issue #688)\n        if (pointsEquals(splitterCoords, currentCoords))\n          return [splitterCoords];\n        return [splitterCoords, currentCoords];\n\n        // Keep iterating over coords until finished or intersection is found\n      } else {\n        previous.push(currentCoords);\n        return previous;\n      }\n    },\n    initialValue\n  );\n  // Append last line to final split results\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(\n  point: Feature<Point>,\n  lines: FeatureCollection<LineString>\n): Feature<LineString> {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  // Filter to one segment that is the closest to the line\n  if (lines.features.length === 1) return lines.features[0];\n\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature!;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1: number[], pt2: number[]) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport { Splitter, lineSplit };\nexport default lineSplit;\n"]}