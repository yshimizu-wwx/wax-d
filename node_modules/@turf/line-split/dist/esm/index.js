// index.ts
import { geojsonRbush as rbush } from "@turf/geojson-rbush";
import { truncate } from "@turf/truncate";
import { lineSegment } from "@turf/line-segment";
import { lineIntersect } from "@turf/line-intersect";
import { nearestPointOnLine } from "@turf/nearest-point-on-line";
import { getCoords, getCoord, getType } from "@turf/invariant";
import { featureEach, featureReduce, flattenEach } from "@turf/meta";
import { lineString, featureCollection, feature } from "@turf/helpers";
function lineSplit(line, splitter) {
  if (!line) throw new Error("line is required");
  if (!splitter) throw new Error("splitter is required");
  const lineType = getType(line);
  const splitterType = getType(splitter);
  if (lineType !== "LineString") throw new Error("line must be LineString");
  if (splitterType === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (splitterType === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var truncatedSplitter = truncate(splitter, { precision: 7 });
  if (line.type !== "Feature") {
    line = feature(line);
  }
  switch (splitterType) {
    case "Point":
      return splitLineWithPoint(
        line,
        truncatedSplitter
      );
    case "MultiPoint":
      return splitLineWithPoints(
        line,
        truncatedSplitter
      );
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return splitLineWithPoints(
        line,
        lineIntersect(
          line,
          truncatedSplitter,
          {
            ignoreSelfIntersections: true
          }
        )
      );
  }
}
function splitLineWithPoints(line, splitter) {
  var results = [];
  var tree = rbush();
  flattenEach(
    splitter,
    // this cast should be unnecessary (and is wrong, it could contain MultiPoints), but is a workaround for bad flattenEach typings
    function(point) {
      results.forEach(function(feature2, index) {
        feature2.id = index;
      });
      if (!results.length) {
        results = splitLineWithPoint(line, point).features;
        tree.load(featureCollection(results));
      } else {
        var search = tree.search(point);
        if (search.features.length) {
          var closestLine = findClosestFeature(point, search);
          results = results.filter(function(feature2) {
            return feature2.id !== closestLine.id;
          });
          tree.remove(closestLine);
          featureEach(splitLineWithPoint(closestLine, point), function(line2) {
            results.push(line2);
            tree.insert(line2);
          });
        }
      }
    }
  );
  return featureCollection(results);
}
function splitLineWithPoint(line, splitter) {
  var results = [];
  var startPoint = getCoords(line)[0];
  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];
  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter)))
    return featureCollection([line]);
  var tree = rbush();
  var segments = lineSegment(line);
  tree.load(segments);
  var search = tree.search(splitter);
  if (!search.features.length) return featureCollection([line]);
  var closestSegment = findClosestFeature(splitter, search);
  var initialValue = [startPoint];
  var lastCoords = featureReduce(
    segments,
    function(previous, current, index) {
      var currentCoords = getCoords(current)[1];
      var splitterCoords = getCoord(splitter);
      if (index === closestSegment.id) {
        previous.push(splitterCoords);
        results.push(lineString(previous));
        if (pointsEquals(splitterCoords, currentCoords))
          return [splitterCoords];
        return [splitterCoords, currentCoords];
      } else {
        previous.push(currentCoords);
        return previous;
      }
    },
    initialValue
  );
  if (lastCoords.length > 1) {
    results.push(lineString(lastCoords));
  }
  return featureCollection(results);
}
function findClosestFeature(point, lines) {
  if (!lines.features.length) throw new Error("lines must contain features");
  if (lines.features.length === 1) return lines.features[0];
  var closestFeature;
  var closestDistance = Infinity;
  featureEach(lines, function(segment) {
    var pt = nearestPointOnLine(segment, point);
    var dist = pt.properties.dist;
    if (dist < closestDistance) {
      closestFeature = segment;
      closestDistance = dist;
    }
  });
  return closestFeature;
}
function pointsEquals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
var index_default = lineSplit;
export {
  index_default as default,
  lineSplit
};
//# sourceMappingURL=index.js.map