{"version":3,"sources":["/home/runner/work/turf/turf/packages/turf-line-offset/dist/cjs/index.cjs","../../index.ts","../../lib/intersection.ts"],"names":["intersection"],"mappings":"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","file":"/home/runner/work/turf/turf/packages/turf-line-offset/dist/cjs/index.cjs","sourcesContent":[null,"import { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport {\n  isObject,\n  lineString,\n  multiLineString,\n  lengthToDegrees,\n  Units,\n} from \"@turf/helpers\";\nimport { intersection } from \"./lib/intersection.js\";\nimport { Feature, LineString, MultiLineString, Position } from \"geojson\";\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @function\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {Units} [options.units='kilometers'] Supports all valid Turf {@link https://turfjs.org/docs/api/types/Units Units}.\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset<T extends LineString | MultiLineString>(\n  geojson: Feature<T> | T,\n  distance: number,\n  options: { units?: Units } = {}\n): Feature<T> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const { units = \"kilometers\" } = options;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n\n  var type = getType(geojson);\n  var properties = geojson.type === \"Feature\" ? geojson.properties : {};\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units) as Feature<T>;\n    case \"MultiLineString\":\n      var coords: Position[][] = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties) as Feature<T>;\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(\n  line: Feature<LineString | MultiLineString> | LineString | MultiLineString,\n  distance: number,\n  units: Units\n) {\n  var segments: [[number, number], [number, number]][] = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords: [number, number][] = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(\n    finalCoords,\n    line.type === \"Feature\" ? line.properties : {}\n  );\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(\n  point1: [number, number],\n  point2: [number, number],\n  offset: number\n): [[number, number], [number, number]] {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) +\n      (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n\n  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;\n  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;\n  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;\n  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y],\n  ];\n}\n\nexport { lineOffset };\nexport default lineOffset;\n","/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment: [number, number][]): [number, number] {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1: [number, number], v2: [number, number]) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1: [number, number], v2: [number, number]): [number, number] {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1: [number, number], v2: [number, number]): [number, number] {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s: number, v: [number, number]): [number, number] {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(\n  a: [number, number][],\n  b: [number, number][]\n): [number, number] {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a: [number, number][], b: [number, number][]): boolean {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nexport function intersection(\n  a: [number, number][],\n  b: [number, number][]\n): [number, number] | false {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n"]}