{"version":3,"file":"splaytree.js","sources":["../src/node.ts","../src/index.ts"],"sourcesContent":["\nexport default class Node<Key, Value> {\n  public key:Key;\n  public data:any;\n  public left:Node<Key, Value>|null;\n  public right:Node<Key, Value>|null;\n  public next:Node<Key, Value>|null = null;\n\n  constructor (key:Key, data?:any) {\n    this.key    = key;\n    this.data   = data;\n    this.left   = null;\n    this.right  = null;\n  }\n}","import Node from \"./node\";\nimport { Key, Value } from \"./types\";\n\nexport type Comparator<Key> = (a: Key, b: Key) => number;\nexport type Visitor<Key, Value> = (\n  node: Node<Key, Value>\n) => undefined | boolean | void;\nexport type NodePrinter<Key, Value> = (node: Node<Key, Value>) => string;\n\n/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\nfunction DEFAULT_COMPARE(a: Key, b: Key): number {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\ntype TreeNodeList<Key, Value> = { head: Node<Key, Value> | null };\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n */\nfunction splay(\n  i: Key,\n  t: Node<Key, Value>,\n  comparator: Comparator<Key>\n): Node<Key, Value> {\n  const N = new Node(null, null);\n  let l = N;\n  let r = N;\n\n  while (true) {\n    const cmp = comparator(i, t!.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t!.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        const y = t.left; /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t; /* link right */\n      r = t;\n      t = t.left;\n      //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        const y = t.right; /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t; /* link left */\n      l = t;\n      t = t.right;\n    } else break;\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\nfunction insert(\n  i: Key,\n  data: Value,\n  t: Node<Key, Value>,\n  comparator: Comparator<Key>\n): Node<Key, Value> {\n  const node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\nfunction split(\n  key: Key,\n  v: Node<Key, Value>,\n  comparator: Comparator<Key>\n): {\n  left: Node<Key, Value> | null;\n  right: Node<Key, Value> | null;\n} {\n  let left = null;\n  let right = null;\n  if (v) {\n    v = splay(key, v, comparator);\n\n    const cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right = v.right;\n      v.right = null;\n      left = v;\n    } else {\n      left = v.left;\n      v.left = null;\n      right = v;\n    }\n  }\n  return { left, right };\n}\n\nfunction merge(\n  left: Node<Key, Value> | null,\n  right: Node<Key, Value> | null,\n  comparator: Comparator<Key>\n) {\n  if (right === null) return left;\n  if (left === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\ntype StringCollector = (s: string) => void;\n\n/**\n * Prints level of the tree\n */\nfunction printRow(\n  root: Node<Key, Value>,\n  prefix: string,\n  isTail: boolean,\n  out: StringCollector,\n  printNode: NodePrinter<Key, Value>\n) {\n  if (root) {\n    out(`${prefix}${isTail ? \"└── \" : \"├── \"}${printNode(root)}\\n`);\n    const indent = prefix + (isTail ? \"    \" : \"│   \");\n    if (root.left) printRow(root.left, indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true, out, printNode);\n  }\n}\n\nexport default class Tree<Key = number, Value = any> {\n  private _comparator: Comparator<Key>;\n  private _root: Node<Key, Value> | null = null;\n  private _size: number = 0;\n\n  constructor(comparator = DEFAULT_COMPARE) {\n    this._comparator = comparator;\n  }\n\n  /**\n   * Inserts a key, allows duplicates\n   */\n  public insert(key: Key, data?: Value): Node<Key, Value> {\n    this._size++;\n    return (this._root = insert(key, data, this._root!, this._comparator));\n  }\n\n  /**\n   * Adds a key, if it is not present in the tree\n   */\n  public add(key: Key, data?: Value): Node<Key, Value> {\n    const node = new Node(key, data);\n\n    if (this._root === null) {\n      node.left = node.right = null;\n      this._size++;\n      this._root = node;\n    }\n\n    const comparator = this._comparator;\n    const t = splay(key, this._root, comparator);\n    const cmp = comparator(key, t.key);\n    if (cmp === 0) this._root = t;\n    else {\n      if (cmp < 0) {\n        node.left = t.left;\n        node.right = t;\n        t.left = null;\n      } else if (cmp > 0) {\n        node.right = t.right;\n        node.left = t;\n        t.right = null;\n      }\n      this._size++;\n      this._root = node;\n    }\n\n    return this._root;\n  }\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  public remove(key: Key): void {\n    this._root = this._remove(key, this._root!, this._comparator);\n  }\n\n  /**\n   * Deletes i from the tree if it's there\n   */\n  private _remove(i: Key, t: Node<Key, Value>, comparator: Comparator<Key>) {\n    let x;\n    if (t === null) return null;\n    t = splay(i, t, comparator);\n    const cmp = comparator(i, t.key);\n    if (cmp === 0) {\n      /* found it */\n      if (t.left === null) {\n        x = t.right!;\n      } else {\n        x = splay(i, t.left, comparator);\n        x.right = t.right;\n      }\n      this._size--;\n      return x;\n    }\n    return t; /* It wasn't there */\n  }\n\n  /**\n   * Removes and returns the node with smallest key\n   */\n  public pop(): { key: Key; data: Value } | null {\n    let node = this._root;\n    if (node) {\n      while (node.left) node = node.left;\n      this._root = splay(node.key, this._root!, this._comparator);\n      this._root = this._remove(node.key, this._root, this._comparator);\n      return { key: node.key, data: node.data };\n    }\n    return null;\n  }\n\n  /**\n   * Find without splaying\n   */\n  public findStatic(key: Key): Node<Key, Value> | null {\n    let current = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0) return current;\n      else if (cmp < 0) current = current.left;\n      else current = current.right;\n    }\n    return null;\n  }\n\n  public find(key: Key): Node<Key, Value> | null {\n    if (this._root) {\n      this._root = splay(key, this._root, this._comparator);\n      if (this._comparator(key, this._root.key) !== 0) return null;\n    }\n    return this._root;\n  }\n\n  public contains(key: Key): boolean {\n    let current = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0) return true;\n      else if (cmp < 0) current = current.left;\n      else current = current.right;\n    }\n    return false;\n  }\n\n  public forEach(visitor: Visitor<Key, Value>, ctx?: any): Tree<Key, Value> {\n    let current = this._root;\n    const Q = []; /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !== null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop()!;\n          visitor.call(ctx, current);\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   */\n  public range(\n    low: Key,\n    high: Key,\n    fn: Visitor<Key, Value>,\n    ctx?: any\n  ): Tree<Key, Value> {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root;\n    let cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop()!;\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns array of keys\n   */\n  public keys(): Key[] {\n    const keys: Key[] = [];\n    this.forEach(({ key }) => {\n      keys.push(key);\n    });\n    return keys;\n  }\n\n  /**\n   * Returns array of all the data in the nodes\n   */\n  public values(): Value[] {\n    const values: Value[] = [];\n    this.forEach(({ data }) => {\n      values.push(data);\n    });\n    return values;\n  }\n\n  public min(): Key | null {\n    if (this._root) return this.minNode(this._root)!.key;\n    return null;\n  }\n\n  public max(): Key | null {\n    if (this._root) return this.maxNode(this._root)!.key;\n    return null;\n  }\n\n  public minNode(t = this._root): Node<Key, Value> | null {\n    if (t) while (t.left) t = t.left;\n    return t;\n  }\n\n  public maxNode(t = this._root): Node<Key, Value> | null {\n    if (t) while (t.right) t = t.right;\n    return t;\n  }\n\n  /**\n   * Returns node at given index\n   */\n  public at(index: number): Node<Key, Value> | null {\n    let current = this._root;\n    let done = false;\n    let i = 0;\n    const Q = [];\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = Q.pop()!;\n          if (i === index) return current;\n          i++;\n          current = current.right!;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n  public next(d: Node<Key, Value>): Node<Key, Value> | null {\n    let root = this._root;\n    let successor = null;\n\n    if (d.right) {\n      successor = d.right;\n      while (successor.left) successor = successor.left;\n      return successor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) {\n        successor = root;\n        root = root.left;\n      } else root = root.right;\n    }\n\n    return successor;\n  }\n\n  public prev(d: Node<Key, Value>): Node<Key, Value> | null {\n    let root = this._root;\n    let predecessor = null;\n\n    if (d.left !== null) {\n      predecessor = d.left;\n      while (predecessor.right) predecessor = predecessor.right;\n      return predecessor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) root = root.left;\n      else {\n        predecessor = root;\n        root = root.right;\n      }\n    }\n    return predecessor;\n  }\n\n  public clear(): Tree<Key, Value> {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n  public toList() {\n    return toList(this._root!);\n  }\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   */\n  public load(keys: Key[], values: Value[] = [], presort: boolean = false) {\n    let size = keys.length;\n    const comparator = this._comparator;\n\n    // sort if needed\n    if (presort) sort(keys, values, 0, size - 1, comparator);\n\n    if (this._root === null) {\n      // empty tree\n      this._root = loadRecursive(keys, values, 0, size);\n      this._size = size;\n    } else {\n      // that re-builds the whole tree from two in-order traversals\n      const mergedList = mergeLists(\n        this.toList(),\n        createList(keys, values),\n        comparator\n      );\n      size = this._size + size;\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\n    }\n    return this;\n  }\n\n  public isEmpty(): boolean {\n    return this._root === null;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n  get root(): Node<Key, Value> | null {\n    return this._root;\n  }\n\n  public toString(\n    printNode: NodePrinter<Key, Value> = (n) => String(n.key)\n  ): string {\n    const out: string[] = [];\n    printRow(this._root!, \"\", true, (v) => out.push(v), printNode);\n    return out.join(\"\");\n  }\n\n  public update(key: Key, newKey: Key, newData?: Value): void {\n    const comparator = this._comparator;\n    let { left, right } = split(key, this._root!, comparator);\n    if (comparator(key, newKey) < 0) {\n      right = insert(newKey, newData, right!, comparator);\n    } else {\n      left = insert(newKey, newData, left!, comparator);\n    }\n    this._root = merge(left, right, comparator);\n  }\n\n  public split(key: Key) {\n    return split(key, this._root!, this._comparator);\n  }\n\n  *[Symbol.iterator]() {\n    let current = this._root;\n    const Q: Node<Key, Value>[] = []; /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !== null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop()!;\n          yield current;\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n  }\n}\n\nfunction loadRecursive(\n  keys: Key[],\n  values: Value[],\n  start: number,\n  end: number\n): Node<Key, Value> | null {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key = keys[middle];\n    const data = values[middle];\n    const node = new Node(key, data);\n    node.left = loadRecursive(keys, values, start, middle);\n    node.right = loadRecursive(keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\nfunction createList(keys: Key[], values: Value[]): Node<Key, Value> {\n  const head = new Node<Key, Value>(null, null);\n  let p: Node<Key, Value> = head;\n  for (let i = 0; i < keys.length; i++) {\n    p = p.next = new Node(keys[i], values[i]);\n  }\n  p.next = null;\n  return head.next!;\n}\n\nfunction toList(root: Node<Key, Value>): Node<Key, Value> {\n  let current = root;\n  const Q = [];\n  let done = false;\n\n  const head = new Node<Key, Value>(null, null);\n  let p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left!;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop()!;\n        current = current.right!;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next!;\n}\n\nfunction sortedListToBST(\n  list: TreeNodeList<Key, Value>,\n  start: number,\n  end: number\n) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const left = sortedListToBST(list, start, middle);\n\n    const root = list.head;\n    root!.left = left;\n\n    list.head = list.head!.next;\n\n    root!.right = sortedListToBST(list, middle + 1, end);\n    return root!;\n  }\n  return null;\n}\n\nfunction mergeLists<Key, Value>(\n  l1: Node<Key, Value>,\n  l2: Node<Key, Value>,\n  compare: Comparator<Key>\n): Node<Key, Value> {\n  const head: Node<Key, Value> = new Node<Key, Value>(null as Key, null); // dummy\n  let p = head;\n\n  let p1: Node<Key, Value> = l1;\n  let p2: Node<Key, Value> = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next!;\n    } else {\n      p.next = p2;\n      p2 = p2.next!;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null) {\n    p.next = p1;\n  } else if (p2 !== null) {\n    p.next = p2;\n  }\n\n  return head.next!;\n}\n\nfunction sort(\n  keys: Key[],\n  values: Value[],\n  left: number,\n  right: number,\n  compare: Comparator<Key>\n) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++;\n    while (compare(keys[i], pivot) < 0);\n    do j--;\n    while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values, left, j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n"],"names":["Node","key","data","DEFAULT_COMPARE","a","b","splay","i","comparator","N","r","cmp","y","insert","t","node","split","v","left","right","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","x","current","compare","visitor","ctx","Q","done","low","high","fn","keys","values","index","d","successor","predecessor","toList","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","n","newKey","newData","start","end","middle","head","p","list","l1","l2","p1","p2","pivot","j","tmp"],"mappings":"AACA,MAAqBA,EAAiB;AAAA,EAOpC,YAAaC,GAASC,GAAW;AAFjC,SAAO,OAA6B,MAGlC,KAAK,MAASD,GACd,KAAK,OAASC,GACd,KAAK,OAAS,MACd,KAAK,QAAS;AAAA,EAChB;AACF;ACDA,SAASC,EAAgBC,GAAQC,GAAgB;AAC/C,SAAOD,IAAIC,IAAI,IAAID,IAAIC,IAAI,KAAK;AAClC;AAOA,SAASC,EACPC,GACA,GACAC,GACkB;AAClB,QAAMC,IAAI,IAAIT,EAAK,MAAM,IAAI;AAC7B,MAAI,IAAIS,GACJC,IAAID;AAER,aAAa;AACX,UAAME,IAAMH,EAAWD,GAAG,EAAG,GAAG;AAEhC,QAAII,IAAM,GAAG;AACX,UAAI,EAAG,SAAS,KAAM;AAEtB,UAAIH,EAAWD,GAAG,EAAE,KAAK,GAAG,IAAI,GAAG;AACjC,cAAMK,IAAI,EAAE;AAIZ,YAHA,EAAE,OAAOA,EAAE,OACXA,EAAE,QAAQ,GACV,IAAIA,GACA,EAAE,SAAS,KAAM;AAAA,MACvB;AACA,MAAAF,EAAE,OAAO,GACTA,IAAI,GACJ,IAAI,EAAE;AAAA,IAER,WAAWC,IAAM,GAAG;AAClB,UAAI,EAAE,UAAU,KAAM;AAEtB,UAAIH,EAAWD,GAAG,EAAE,MAAM,GAAG,IAAI,GAAG;AAClC,cAAMK,IAAI,EAAE;AAIZ,YAHA,EAAE,QAAQA,EAAE,MACZA,EAAE,OAAO,GACT,IAAIA,GACA,EAAE,UAAU,KAAM;AAAA,MACxB;AACA,QAAE,QAAQ,GACV,IAAI,GACJ,IAAI,EAAE;AAAA,IACR,MAAO;AAAA,EACT;AAEA,WAAE,QAAQ,EAAE,MACZF,EAAE,OAAO,EAAE,OACX,EAAE,OAAOD,EAAE,OACX,EAAE,QAAQA,EAAE,MACL;AACT;AAEA,SAASI,EACPN,GACAL,GACAY,GACAN,GACkB;AAClB,QAAMO,IAAO,IAAIf,EAAKO,GAAGL,CAAI;AAE7B,MAAIY,MAAM;AACR,WAAAC,EAAK,OAAOA,EAAK,QAAQ,MAClBA;AAGT,EAAAD,IAAIR,EAAMC,GAAGO,GAAGN,CAAU;AAC1B,QAAMG,IAAMH,EAAWD,GAAGO,EAAE,GAAG;AAC/B,SAAIH,IAAM,KACRI,EAAK,OAAOD,EAAE,MACdC,EAAK,QAAQD,GACbA,EAAE,OAAO,QACAH,KAAO,MAChBI,EAAK,QAAQD,EAAE,OACfC,EAAK,OAAOD,GACZA,EAAE,QAAQ,OAELC;AACT;AAEA,SAASC,EACPf,GACAgB,GACAT,GAIA;AACA,MAAIU,IAAO,MACPC,IAAQ;AACZ,MAAIF,GAAG;AACL,IAAAA,IAAIX,EAAML,GAAKgB,GAAGT,CAAU;AAE5B,UAAMG,IAAMH,EAAWS,EAAE,KAAKhB,CAAG;AACjC,IAAIU,MAAQ,KACVO,IAAOD,EAAE,MACTE,IAAQF,EAAE,SACDN,IAAM,KACfQ,IAAQF,EAAE,OACVA,EAAE,QAAQ,MACVC,IAAOD,MAEPC,IAAOD,EAAE,MACTA,EAAE,OAAO,MACTE,IAAQF;AAAA,EAEZ;AACA,SAAO,EAAE,MAAAC,GAAM,OAAAC,EAAA;AACjB;AAEA,SAASC,EACPF,GACAC,GACAX,GACA;AACA,SAAIW,MAAU,OAAaD,KACvBA,MAAS,SAEbC,IAAQb,EAAMY,EAAK,KAAKC,GAAOX,CAAU,GACzCW,EAAM,OAAOD,IACNC;AACT;AAOA,SAASE,EACPC,GACAC,GACAC,GACAC,GACAC,GACA;AACA,MAAIJ,GAAM;AACR,IAAAG,EAAI,GAAGF,CAAM,GAAGC,IAAS,SAAS,MAAM,GAAGE,EAAUJ,CAAI,CAAC;AAAA,CAAI;AAC9D,UAAMK,IAASJ,KAAUC,IAAS,SAAS;AAC3C,IAAIF,EAAK,QAAMD,EAASC,EAAK,MAAMK,GAAQ,IAAOF,GAAKC,CAAS,GAC5DJ,EAAK,SAAOD,EAASC,EAAK,OAAOK,GAAQ,IAAMF,GAAKC,CAAS;AAAA,EACnE;AACF;AAEA,MAAqBE,EAAgC;AAAA,EAKnD,YAAYpB,IAAaL,GAAiB;AAH1C,SAAQ,QAAiC,MACzC,KAAQ,QAAgB,GAGtB,KAAK,cAAcK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKO,OAAOP,GAAUC,GAAgC;AACtD,gBAAK,SACG,KAAK,QAAQW,EAAOZ,GAAKC,GAAM,KAAK,OAAQ,KAAK,WAAW;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKO,IAAID,GAAUC,GAAgC;AACnD,UAAMa,IAAO,IAAIf,EAAKC,GAAKC,CAAI;AAE/B,IAAI,KAAK,UAAU,SACjBa,EAAK,OAAOA,EAAK,QAAQ,MACzB,KAAK,SACL,KAAK,QAAQA;AAGf,UAAMP,IAAa,KAAK,aAClBM,IAAIR,EAAML,GAAK,KAAK,OAAOO,CAAU,GACrCG,IAAMH,EAAWP,GAAKa,EAAE,GAAG;AACjC,WAAIH,MAAQ,IAAG,KAAK,QAAQG,KAEtBH,IAAM,KACRI,EAAK,OAAOD,EAAE,MACdC,EAAK,QAAQD,GACbA,EAAE,OAAO,QACAH,IAAM,MACfI,EAAK,QAAQD,EAAE,OACfC,EAAK,OAAOD,GACZA,EAAE,QAAQ,OAEZ,KAAK,SACL,KAAK,QAAQC,IAGR,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAOd,GAAgB;AAC5B,SAAK,QAAQ,KAAK,QAAQA,GAAK,KAAK,OAAQ,KAAK,WAAW;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKQ,QAAQM,GAAQO,GAAqBN,GAA6B;AACxE,QAAIqB;AACJ,WAAIf,MAAM,OAAa,QACvBA,IAAIR,EAAMC,GAAGO,GAAGN,CAAU,GACdA,EAAWD,GAAGO,EAAE,GAAG,MACnB,KAENA,EAAE,SAAS,OACbe,IAAIf,EAAE,SAENe,IAAIvB,EAAMC,GAAGO,EAAE,MAAMN,CAAU,GAC/BqB,EAAE,QAAQf,EAAE,QAEd,KAAK,SACEe,KAEFf;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,MAAwC;AAC7C,QAAIC,IAAO,KAAK;AAChB,QAAIA,GAAM;AACR,aAAOA,EAAK,OAAM,CAAAA,IAAOA,EAAK;AAC9B,kBAAK,QAAQT,EAAMS,EAAK,KAAK,KAAK,OAAQ,KAAK,WAAW,GAC1D,KAAK,QAAQ,KAAK,QAAQA,EAAK,KAAK,KAAK,OAAO,KAAK,WAAW,GACzD,EAAE,KAAKA,EAAK,KAAK,MAAMA,EAAK,KAAA;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,WAAWd,GAAmC;AACnD,QAAI6B,IAAU,KAAK;AACnB,UAAMC,IAAU,KAAK;AACrB,WAAOD,KAAS;AACd,YAAMnB,IAAMoB,EAAQ9B,GAAK6B,EAAQ,GAAG;AACpC,UAAInB,MAAQ,EAAG,QAAOmB;AAAA,MACbnB,IAAM,IAAGmB,IAAUA,EAAQ,WACrBA,EAAQ;AAAA,IACzB;AACA,WAAO;AAAA,EACT;AAAA,EAEO,KAAK7B,GAAmC;AAC7C,WAAI,KAAK,UACP,KAAK,QAAQK,EAAML,GAAK,KAAK,OAAO,KAAK,WAAW,GAChD,KAAK,YAAYA,GAAK,KAAK,MAAM,GAAG,MAAM,KAAU,OAEnD,KAAK;AAAA,EACd;AAAA,EAEO,SAASA,GAAmB;AACjC,QAAI6B,IAAU,KAAK;AACnB,UAAMC,IAAU,KAAK;AACrB,WAAOD,KAAS;AACd,YAAMnB,IAAMoB,EAAQ9B,GAAK6B,EAAQ,GAAG;AACpC,UAAInB,MAAQ,EAAG,QAAO;AAAA,MACbA,IAAM,IAAGmB,IAAUA,EAAQ,WACrBA,EAAQ;AAAA,IACzB;AACA,WAAO;AAAA,EACT;AAAA,EAEO,QAAQE,GAA8BC,GAA6B;AACxE,QAAIH,IAAU,KAAK;AACnB,UAAMI,IAAI,CAAA;AACV,QAAIC,IAAO;AAEX,WAAO,CAACA;AACN,MAAIL,MAAY,QACdI,EAAE,KAAKJ,CAAO,GACdA,IAAUA,EAAQ,QAEdI,EAAE,WAAW,KACfJ,IAAUI,EAAE,IAAA,GACZF,EAAQ,KAAKC,GAAKH,CAAO,GAEzBA,IAAUA,EAAQ,SACbK,IAAO;AAGlB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,MACLC,GACAC,GACAC,GACAL,GACkB;AAClB,UAAMC,IAAI,CAAA,GACJH,IAAU,KAAK;AACrB,QAAIhB,IAAO,KAAK,OACZJ;AAEJ,WAAOuB,EAAE,WAAW,KAAKnB;AACvB,UAAIA;AACF,QAAAmB,EAAE,KAAKnB,CAAI,GACXA,IAAOA,EAAK;AAAA,WACP;AAGL,YAFAA,IAAOmB,EAAE,IAAA,GACTvB,IAAMoB,EAAQhB,EAAK,KAAKsB,CAAI,GACxB1B,IAAM;AACR;YACSoB,EAAQhB,EAAK,KAAKqB,CAAG,KAAK,KAC/BE,EAAG,KAAKL,GAAKlB,CAAI;AAAG,iBAAO;AAEjC,QAAAA,IAAOA,EAAK;AAAA,MACd;AAEF,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,OAAc;AACnB,UAAMwB,IAAc,CAAA;AACpB,gBAAK,QAAQ,CAAC,EAAE,KAAAtC,QAAU;AACxB,MAAAsC,EAAK,KAAKtC,CAAG;AAAA,IACf,CAAC,GACMsC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,SAAkB;AACvB,UAAMC,IAAkB,CAAA;AACxB,gBAAK,QAAQ,CAAC,EAAE,MAAAtC,QAAW;AACzB,MAAAsC,EAAO,KAAKtC,CAAI;AAAA,IAClB,CAAC,GACMsC;AAAA,EACT;AAAA,EAEO,MAAkB;AACvB,WAAI,KAAK,QAAc,KAAK,QAAQ,KAAK,KAAK,EAAG,MAC1C;AAAA,EACT;AAAA,EAEO,MAAkB;AACvB,WAAI,KAAK,QAAc,KAAK,QAAQ,KAAK,KAAK,EAAG,MAC1C;AAAA,EACT;AAAA,EAEO,QAAQ,IAAI,KAAK,OAAgC;AACtD,QAAI,EAAG,QAAO,EAAE,YAAU,EAAE;AAC5B,WAAO;AAAA,EACT;AAAA,EAEO,QAAQ,IAAI,KAAK,OAAgC;AACtD,QAAI,EAAG,QAAO,EAAE,aAAW,EAAE;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKO,GAAGC,GAAwC;AAChD,QAAIX,IAAU,KAAK,OACfK,IAAO,IACP5B,IAAI;AACR,UAAM2B,IAAI,CAAA;AAEV,WAAO,CAACC;AACN,UAAIL;AACF,QAAAI,EAAE,KAAKJ,CAAO,GACdA,IAAUA,EAAQ;AAAA,eAEdI,EAAE,SAAS,GAAG;AAEhB,YADAJ,IAAUI,EAAE,IAAA,GACR3B,MAAMkC,EAAO,QAAOX;AACxB,QAAAvB,KACAuB,IAAUA,EAAQ;AAAA,MACpB,MAAO,CAAAK,IAAO;AAGlB,WAAO;AAAA,EACT;AAAA,EAEO,KAAKO,GAA8C;AACxD,QAAIpB,IAAO,KAAK,OACZqB,IAAY;AAEhB,QAAID,EAAE,OAAO;AAEX,WADAC,IAAYD,EAAE,OACPC,EAAU,OAAM,CAAAA,IAAYA,EAAU;AAC7C,aAAOA;AAAA,IACT;AAEA,UAAMnC,IAAa,KAAK;AACxB,WAAOc,KAAM;AACX,YAAMX,IAAMH,EAAWkC,EAAE,KAAKpB,EAAK,GAAG;AACtC,UAAIX,MAAQ,EAAG;AAAA,MACNA,IAAM,KACbgC,IAAYrB,GACZA,IAAOA,EAAK,YACAA,EAAK;AAAA,IACrB;AAEA,WAAOqB;AAAA,EACT;AAAA,EAEO,KAAKD,GAA8C;AACxD,QAAIpB,IAAO,KAAK,OACZsB,IAAc;AAElB,QAAIF,EAAE,SAAS,MAAM;AAEnB,WADAE,IAAcF,EAAE,MACTE,EAAY,QAAO,CAAAA,IAAcA,EAAY;AACpD,aAAOA;AAAA,IACT;AAEA,UAAMpC,IAAa,KAAK;AACxB,WAAOc,KAAM;AACX,YAAMX,IAAMH,EAAWkC,EAAE,KAAKpB,EAAK,GAAG;AACtC,UAAIX,MAAQ,EAAG;AAAA,MACNA,IAAM,IAAGW,IAAOA,EAAK,QAE5BsB,IAActB,GACdA,IAAOA,EAAK;AAAA,IAEhB;AACA,WAAOsB;AAAA,EACT;AAAA,EAEO,QAA0B;AAC/B,gBAAK,QAAQ,MACb,KAAK,QAAQ,GACN;AAAA,EACT;AAAA,EAEO,SAAS;AACd,WAAOC,EAAO,KAAK,KAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKO,KAAKN,GAAaC,IAAkB,CAAA,GAAIM,IAAmB,IAAO;AACvE,QAAIC,IAAOR,EAAK;AAChB,UAAM/B,IAAa,KAAK;AAKxB,QAFIsC,KAASE,EAAKT,GAAMC,GAAQ,GAAGO,IAAO,GAAGvC,CAAU,GAEnD,KAAK,UAAU;AAEjB,WAAK,QAAQyC,EAAcV,GAAMC,GAAQ,GAAGO,CAAI,GAChD,KAAK,QAAQA;AAAA,SACR;AAEL,YAAMG,IAAaC;AAAA,QACjB,KAAK,OAAA;AAAA,QACLC,EAAWb,GAAMC,CAAM;AAAA,QACvBhC;AAAA,MAAA;AAEF,MAAAuC,IAAO,KAAK,QAAQA,GACpB,KAAK,QAAQM,EAAgB,EAAE,MAAMH,EAAA,GAAc,GAAGH,CAAI;AAAA,IAC5D;AACA,WAAO;AAAA,EACT;AAAA,EAEO,UAAmB;AACxB,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA,EAEA,IAAI,OAAe;AACjB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,OAAgC;AAClC,WAAO,KAAK;AAAA,EACd;AAAA,EAEO,SACLrB,IAAqC,CAAC4B,MAAM,OAAOA,EAAE,GAAG,GAChD;AACR,UAAM7B,IAAgB,CAAA;AACtB,WAAAJ,EAAS,KAAK,OAAQ,IAAI,IAAM,CAACJ,MAAMQ,EAAI,KAAKR,CAAC,GAAGS,CAAS,GACtDD,EAAI,KAAK,EAAE;AAAA,EACpB;AAAA,EAEO,OAAOxB,GAAUsD,GAAaC,GAAuB;AAC1D,UAAMhD,IAAa,KAAK;AACxB,QAAI,EAAE,MAAAU,GAAM,OAAAC,MAAUH,EAAMf,GAAK,KAAK,OAAQO,CAAU;AACxD,IAAIA,EAAWP,GAAKsD,CAAM,IAAI,IAC5BpC,IAAQN,EAAO0C,GAAQC,GAASrC,GAAQX,CAAU,IAElDU,IAAOL,EAAO0C,GAAQC,GAAStC,GAAOV,CAAU,GAElD,KAAK,QAAQY,EAAMF,GAAMC,GAAOX,CAAU;AAAA,EAC5C;AAAA,EAEO,MAAMP,GAAU;AACrB,WAAOe,EAAMf,GAAK,KAAK,OAAQ,KAAK,WAAW;AAAA,EACjD;AAAA,EAEA,EAAE,OAAO,QAAQ,IAAI;AACnB,QAAI6B,IAAU,KAAK;AACnB,UAAMI,IAAwB,CAAA;AAC9B,QAAIC,IAAO;AAEX,WAAO,CAACA;AACN,MAAIL,MAAY,QACdI,EAAE,KAAKJ,CAAO,GACdA,IAAUA,EAAQ,QAEdI,EAAE,WAAW,KACfJ,IAAUI,EAAE,IAAA,GACZ,MAAMJ,GAENA,IAAUA,EAAQ,SACbK,IAAO;AAAA,EAGpB;AACF;AAEA,SAASc,EACPV,GACAC,GACAiB,GACAC,GACyB;AACzB,QAAMX,IAAOW,IAAMD;AACnB,MAAIV,IAAO,GAAG;AACZ,UAAMY,IAASF,IAAQ,KAAK,MAAMV,IAAO,CAAC,GACpC9C,IAAMsC,EAAKoB,CAAM,GACjBzD,IAAOsC,EAAOmB,CAAM,GACpB5C,IAAO,IAAIf,EAAKC,GAAKC,CAAI;AAC/B,WAAAa,EAAK,OAAOkC,EAAcV,GAAMC,GAAQiB,GAAOE,CAAM,GACrD5C,EAAK,QAAQkC,EAAcV,GAAMC,GAAQmB,IAAS,GAAGD,CAAG,GACjD3C;AAAA,EACT;AACA,SAAO;AACT;AAEA,SAASqC,EAAWb,GAAaC,GAAmC;AAClE,QAAMoB,IAAO,IAAI5D,EAAiB,MAAM,IAAI;AAC5C,MAAI6D,IAAsBD;AAC1B,WAASrD,IAAI,GAAGA,IAAIgC,EAAK,QAAQhC;AAC/B,IAAAsD,IAAIA,EAAE,OAAO,IAAI7D,EAAKuC,EAAKhC,CAAC,GAAGiC,EAAOjC,CAAC,CAAC;AAE1C,SAAAsD,EAAE,OAAO,MACFD,EAAK;AACd;AAEA,SAASf,EAAOvB,GAA0C;AACxD,MAAIQ,IAAUR;AACd,QAAMY,IAAI,CAAA;AACV,MAAIC,IAAO;AAEX,QAAMyB,IAAO,IAAI5D,EAAiB,MAAM,IAAI;AAC5C,MAAI6D,IAAID;AAER,SAAO,CAACzB;AACN,IAAIL,KACFI,EAAE,KAAKJ,CAAO,GACdA,IAAUA,EAAQ,QAEdI,EAAE,SAAS,KACbJ,IAAU+B,IAAIA,EAAE,OAAO3B,EAAE,IAAA,GACzBJ,IAAUA,EAAQ,SACbK,IAAO;AAGlB,SAAA0B,EAAE,OAAO,MACFD,EAAK;AACd;AAEA,SAASP,EACPS,GACAL,GACAC,GACA;AACA,QAAMX,IAAOW,IAAMD;AACnB,MAAIV,IAAO,GAAG;AACZ,UAAMY,IAASF,IAAQ,KAAK,MAAMV,IAAO,CAAC,GACpC7B,IAAOmC,EAAgBS,GAAML,GAAOE,CAAM,GAE1CrC,IAAOwC,EAAK;AAClB,WAAAxC,EAAM,OAAOJ,GAEb4C,EAAK,OAAOA,EAAK,KAAM,MAEvBxC,EAAM,QAAQ+B,EAAgBS,GAAMH,IAAS,GAAGD,CAAG,GAC5CpC;AAAA,EACT;AACA,SAAO;AACT;AAEA,SAAS6B,EACPY,GACAC,GACAjC,GACkB;AAClB,QAAM6B,IAAyB,IAAI5D,EAAiB,MAAa,IAAI;AACrE,MAAI6D,IAAID,GAEJK,IAAuBF,GACvBG,IAAuBF;AAE3B,SAAOC,MAAO,QAAQC,MAAO;AAC3B,IAAInC,EAAQkC,EAAG,KAAKC,EAAG,GAAG,IAAI,KAC5BL,EAAE,OAAOI,GACTA,IAAKA,EAAG,SAERJ,EAAE,OAAOK,GACTA,IAAKA,EAAG,OAEVL,IAAIA,EAAE;AAGR,SAAII,MAAO,OACTJ,EAAE,OAAOI,IACAC,MAAO,SAChBL,EAAE,OAAOK,IAGJN,EAAK;AACd;AAEA,SAASZ,EACPT,GACAC,GACAtB,GACAC,GACAY,GACA;AACA,MAAIb,KAAQC,EAAO;AAEnB,QAAMgD,IAAQ5B,EAAMrB,IAAOC,KAAU,CAAC;AACtC,MAAIZ,IAAIW,IAAO,GACXkD,IAAIjD,IAAQ;AAEhB,aAAa;AACX;AAAG,MAAAZ;AAAA,WACIwB,EAAQQ,EAAKhC,CAAC,GAAG4D,CAAK,IAAI;AACjC;AAAG,MAAAC;AAAA,WACIrC,EAAQQ,EAAK6B,CAAC,GAAGD,CAAK,IAAI;AACjC,QAAI5D,KAAK6D,EAAG;AAEZ,QAAIC,IAAM9B,EAAKhC,CAAC;AAChB,IAAAgC,EAAKhC,CAAC,IAAIgC,EAAK6B,CAAC,GAChB7B,EAAK6B,CAAC,IAAIC,GAEVA,IAAM7B,EAAOjC,CAAC,GACdiC,EAAOjC,CAAC,IAAIiC,EAAO4B,CAAC,GACpB5B,EAAO4B,CAAC,IAAIC;AAAA,EACd;AAEA,EAAArB,EAAKT,GAAMC,GAAQtB,GAAMkD,GAAGrC,CAAO,GACnCiB,EAAKT,GAAMC,GAAQ4B,IAAI,GAAGjD,GAAOY,CAAO;AAC1C;"}