/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_PolygonMap_tsx"],{

/***/ "(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.js":
/*!********************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n Leaflet.draw 1.0.4, a plugin that adds drawing and editing tools to Leaflet powered maps.\n (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet\n\n https://github.com/Leaflet/Leaflet.draw\n http://leafletjs.com\n */ !function(t, e, i) {\n    function o(t, e) {\n        for(; (t = t.parentElement) && !t.classList.contains(e););\n        return t;\n    }\n    L.drawVersion = \"1.0.4\", L.Draw = {}, L.drawLocal = {\n        draw: {\n            toolbar: {\n                actions: {\n                    title: \"Cancel drawing\",\n                    text: \"Cancel\"\n                },\n                finish: {\n                    title: \"Finish drawing\",\n                    text: \"Finish\"\n                },\n                undo: {\n                    title: \"Delete last point drawn\",\n                    text: \"Delete last point\"\n                },\n                buttons: {\n                    polyline: \"Draw a polyline\",\n                    polygon: \"Draw a polygon\",\n                    rectangle: \"Draw a rectangle\",\n                    circle: \"Draw a circle\",\n                    marker: \"Draw a marker\",\n                    circlemarker: \"Draw a circlemarker\"\n                }\n            },\n            handlers: {\n                circle: {\n                    tooltip: {\n                        start: \"Click and drag to draw circle.\"\n                    },\n                    radius: \"Radius\"\n                },\n                circlemarker: {\n                    tooltip: {\n                        start: \"Click map to place circle marker.\"\n                    }\n                },\n                marker: {\n                    tooltip: {\n                        start: \"Click map to place marker.\"\n                    }\n                },\n                polygon: {\n                    tooltip: {\n                        start: \"Click to start drawing shape.\",\n                        cont: \"Click to continue drawing shape.\",\n                        end: \"Click first point to close this shape.\"\n                    }\n                },\n                polyline: {\n                    error: \"<strong>Error:</strong> shape edges cannot cross!\",\n                    tooltip: {\n                        start: \"Click to start drawing line.\",\n                        cont: \"Click to continue drawing line.\",\n                        end: \"Click last point to finish line.\"\n                    }\n                },\n                rectangle: {\n                    tooltip: {\n                        start: \"Click and drag to draw rectangle.\"\n                    }\n                },\n                simpleshape: {\n                    tooltip: {\n                        end: \"Release mouse to finish drawing.\"\n                    }\n                }\n            }\n        },\n        edit: {\n            toolbar: {\n                actions: {\n                    save: {\n                        title: \"Save changes\",\n                        text: \"Save\"\n                    },\n                    cancel: {\n                        title: \"Cancel editing, discards all changes\",\n                        text: \"Cancel\"\n                    },\n                    clearAll: {\n                        title: \"Clear all layers\",\n                        text: \"Clear All\"\n                    }\n                },\n                buttons: {\n                    edit: \"Edit layers\",\n                    editDisabled: \"No layers to edit\",\n                    remove: \"Delete layers\",\n                    removeDisabled: \"No layers to delete\"\n                }\n            },\n            handlers: {\n                edit: {\n                    tooltip: {\n                        text: \"Drag handles or markers to edit features.\",\n                        subtext: \"Click cancel to undo changes.\"\n                    }\n                },\n                remove: {\n                    tooltip: {\n                        text: \"Click on a feature to remove.\"\n                    }\n                }\n            }\n        }\n    }, L.Draw.Event = {}, L.Draw.Event.CREATED = \"draw:created\", L.Draw.Event.EDITED = \"draw:edited\", L.Draw.Event.DELETED = \"draw:deleted\", L.Draw.Event.DRAWSTART = \"draw:drawstart\", L.Draw.Event.DRAWSTOP = \"draw:drawstop\", L.Draw.Event.DRAWVERTEX = \"draw:drawvertex\", L.Draw.Event.EDITSTART = \"draw:editstart\", L.Draw.Event.EDITMOVE = \"draw:editmove\", L.Draw.Event.EDITRESIZE = \"draw:editresize\", L.Draw.Event.EDITVERTEX = \"draw:editvertex\", L.Draw.Event.EDITSTOP = \"draw:editstop\", L.Draw.Event.DELETESTART = \"draw:deletestart\", L.Draw.Event.DELETESTOP = \"draw:deletestop\", L.Draw.Event.TOOLBAROPENED = \"draw:toolbaropened\", L.Draw.Event.TOOLBARCLOSED = \"draw:toolbarclosed\", L.Draw.Event.MARKERCONTEXT = \"draw:markercontext\", L.Draw = L.Draw || {}, L.Draw.Feature = L.Handler.extend({\n        initialize: function(t, e) {\n            this._map = t, this._container = t._container, this._overlayPane = t._panes.overlayPane, this._popupPane = t._panes.popupPane, e && e.shapeOptions && (e.shapeOptions = L.Util.extend({}, this.options.shapeOptions, e.shapeOptions)), L.setOptions(this, e);\n            var i = L.version.split(\".\");\n            1 === parseInt(i[0], 10) && parseInt(i[1], 10) >= 2 ? L.Draw.Feature.include(L.Evented.prototype) : L.Draw.Feature.include(L.Mixin.Events);\n        },\n        enable: function() {\n            this._enabled || (L.Handler.prototype.enable.call(this), this.fire(\"enabled\", {\n                handler: this.type\n            }), this._map.fire(L.Draw.Event.DRAWSTART, {\n                layerType: this.type\n            }));\n        },\n        disable: function() {\n            this._enabled && (L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.DRAWSTOP, {\n                layerType: this.type\n            }), this.fire(\"disabled\", {\n                handler: this.type\n            }));\n        },\n        addHooks: function() {\n            var t = this._map;\n            t && (L.DomUtil.disableTextSelection(), t.getContainer().focus(), this._tooltip = new L.Draw.Tooltip(this._map), L.DomEvent.on(this._container, \"keyup\", this._cancelDrawing, this));\n        },\n        removeHooks: function() {\n            this._map && (L.DomUtil.enableTextSelection(), this._tooltip.dispose(), this._tooltip = null, L.DomEvent.off(this._container, \"keyup\", this._cancelDrawing, this));\n        },\n        setOptions: function(t) {\n            L.setOptions(this, t);\n        },\n        _fireCreatedEvent: function(t) {\n            this._map.fire(L.Draw.Event.CREATED, {\n                layer: t,\n                layerType: this.type\n            });\n        },\n        _cancelDrawing: function(t) {\n            27 === t.keyCode && (this._map.fire(\"draw:canceled\", {\n                layerType: this.type\n            }), this.disable());\n        }\n    }), L.Draw.Polyline = L.Draw.Feature.extend({\n        statics: {\n            TYPE: \"polyline\"\n        },\n        Poly: L.Polyline,\n        options: {\n            allowIntersection: !0,\n            repeatMode: !1,\n            drawError: {\n                color: \"#b00b00\",\n                timeout: 2500\n            },\n            icon: new L.DivIcon({\n                iconSize: new L.Point(8, 8),\n                className: \"leaflet-div-icon leaflet-editing-icon\"\n            }),\n            touchIcon: new L.DivIcon({\n                iconSize: new L.Point(20, 20),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\"\n            }),\n            guidelineDistance: 20,\n            maxGuideLineLength: 4e3,\n            shapeOptions: {\n                stroke: !0,\n                color: \"#3388ff\",\n                weight: 4,\n                opacity: .5,\n                fill: !1,\n                clickable: !0\n            },\n            metric: !0,\n            feet: !0,\n            nautic: !1,\n            showLength: !0,\n            zIndexOffset: 2e3,\n            factor: 1,\n            maxPoints: 0\n        },\n        initialize: function(t, e) {\n            L.Browser.touch && (this.options.icon = this.options.touchIcon), this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error, e && e.drawError && (e.drawError = L.Util.extend({}, this.options.drawError, e.drawError)), this.type = L.Draw.Polyline.TYPE, L.Draw.Feature.prototype.initialize.call(this, t, e);\n        },\n        addHooks: function() {\n            L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._markers = [], this._markerGroup = new L.LayerGroup, this._map.addLayer(this._markerGroup), this._poly = new L.Polyline([], this.options.shapeOptions), this._tooltip.updateContent(this._getTooltipText()), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), {\n                icon: L.divIcon({\n                    className: \"leaflet-mouse-marker\",\n                    iconAnchor: [\n                        20,\n                        20\n                    ],\n                    iconSize: [\n                        40,\n                        40\n                    ]\n                }),\n                opacity: 0,\n                zIndexOffset: this.options.zIndexOffset\n            })), this._mouseMarker.on(\"mouseout\", this._onMouseOut, this).on(\"mousemove\", this._onMouseMove, this).on(\"mousedown\", this._onMouseDown, this).on(\"mouseup\", this._onMouseUp, this).addTo(this._map), this._map.on(\"mouseup\", this._onMouseUp, this).on(\"mousemove\", this._onMouseMove, this).on(\"zoomlevelschange\", this._onZoomEnd, this).on(\"touchstart\", this._onTouch, this).on(\"zoomend\", this._onZoomEnd, this));\n        },\n        removeHooks: function() {\n            L.Draw.Feature.prototype.removeHooks.call(this), this._clearHideErrorTimeout(), this._cleanUpShape(), this._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers, this._map.removeLayer(this._poly), delete this._poly, this._mouseMarker.off(\"mousedown\", this._onMouseDown, this).off(\"mouseout\", this._onMouseOut, this).off(\"mouseup\", this._onMouseUp, this).off(\"mousemove\", this._onMouseMove, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._clearGuides(), this._map.off(\"mouseup\", this._onMouseUp, this).off(\"mousemove\", this._onMouseMove, this).off(\"zoomlevelschange\", this._onZoomEnd, this).off(\"zoomend\", this._onZoomEnd, this).off(\"touchstart\", this._onTouch, this).off(\"click\", this._onTouch, this);\n        },\n        deleteLastVertex: function() {\n            if (!(this._markers.length <= 1)) {\n                var t = this._markers.pop(), e = this._poly, i = e.getLatLngs(), o = i.splice(-1, 1)[0];\n                this._poly.setLatLngs(i), this._markerGroup.removeLayer(t), e.getLatLngs().length < 2 && this._map.removeLayer(e), this._vertexChanged(o, !1);\n            }\n        },\n        addVertex: function(t) {\n            if (this._markers.length >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(t)) return void this._showErrorTooltip();\n            this._errorShown && this._hideErrorTooltip(), this._markers.push(this._createMarker(t)), this._poly.addLatLng(t), 2 === this._poly.getLatLngs().length && this._map.addLayer(this._poly), this._vertexChanged(t, !0);\n        },\n        completeShape: function() {\n            this._markers.length <= 1 || !this._shapeIsValid() || (this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable());\n        },\n        _finishShape: function() {\n            var t = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs(), e = this._poly.newLatLngIntersects(t[t.length - 1]);\n            if (!this.options.allowIntersection && e || !this._shapeIsValid()) return void this._showErrorTooltip();\n            this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();\n        },\n        _shapeIsValid: function() {\n            return !0;\n        },\n        _onZoomEnd: function() {\n            null !== this._markers && this._updateGuide();\n        },\n        _onMouseMove: function(t) {\n            var e = this._map.mouseEventToLayerPoint(t.originalEvent), i = this._map.layerPointToLatLng(e);\n            this._currentLatLng = i, this._updateTooltip(i), this._updateGuide(e), this._mouseMarker.setLatLng(i), L.DomEvent.preventDefault(t.originalEvent);\n        },\n        _vertexChanged: function(t, e) {\n            this._map.fire(L.Draw.Event.DRAWVERTEX, {\n                layers: this._markerGroup\n            }), this._updateFinishHandler(), this._updateRunningMeasure(t, e), this._clearGuides(), this._updateTooltip();\n        },\n        _onMouseDown: function(t) {\n            if (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\n                this._onMouseMove(t), this._clickHandled = !0, this._disableNewMarkers();\n                var e = t.originalEvent, i = e.clientX, o = e.clientY;\n                this._startPoint.call(this, i, o);\n            }\n        },\n        _startPoint: function(t, e) {\n            this._mouseDownOrigin = L.point(t, e);\n        },\n        _onMouseUp: function(t) {\n            var e = t.originalEvent, i = e.clientX, o = e.clientY;\n            this._endPoint.call(this, i, o, t), this._clickHandled = null;\n        },\n        _endPoint: function(e, i, o) {\n            if (this._mouseDownOrigin) {\n                var a = L.point(e, i).distanceTo(this._mouseDownOrigin), n = this._calculateFinishDistance(o.latlng);\n                this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1 ? (this.addVertex(o.latlng), this._finishShape()) : n < 10 && L.Browser.touch ? this._finishShape() : Math.abs(a) < 9 * (t.devicePixelRatio || 1) && this.addVertex(o.latlng), this._enableNewMarkers();\n            }\n            this._mouseDownOrigin = null;\n        },\n        _onTouch: function(t) {\n            var e, i, o = t.originalEvent;\n            !o.touches || !o.touches[0] || this._clickHandled || this._touchHandled || this._disableMarkers || (e = o.touches[0].clientX, i = o.touches[0].clientY, this._disableNewMarkers(), this._touchHandled = !0, this._startPoint.call(this, e, i), this._endPoint.call(this, e, i, t), this._touchHandled = null), this._clickHandled = null;\n        },\n        _onMouseOut: function() {\n            this._tooltip && this._tooltip._onMouseOut.call(this._tooltip);\n        },\n        _calculateFinishDistance: function(t) {\n            var e;\n            if (this._markers.length > 0) {\n                var i;\n                if (this.type === L.Draw.Polyline.TYPE) i = this._markers[this._markers.length - 1];\n                else {\n                    if (this.type !== L.Draw.Polygon.TYPE) return 1 / 0;\n                    i = this._markers[0];\n                }\n                var o = this._map.latLngToContainerPoint(i.getLatLng()), a = new L.Marker(t, {\n                    icon: this.options.icon,\n                    zIndexOffset: 2 * this.options.zIndexOffset\n                }), n = this._map.latLngToContainerPoint(a.getLatLng());\n                e = o.distanceTo(n);\n            } else e = 1 / 0;\n            return e;\n        },\n        _updateFinishHandler: function() {\n            var t = this._markers.length;\n            t > 1 && this._markers[t - 1].on(\"click\", this._finishShape, this), t > 2 && this._markers[t - 2].off(\"click\", this._finishShape, this);\n        },\n        _createMarker: function(t) {\n            var e = new L.Marker(t, {\n                icon: this.options.icon,\n                zIndexOffset: 2 * this.options.zIndexOffset\n            });\n            return this._markerGroup.addLayer(e), e;\n        },\n        _updateGuide: function(t) {\n            var e = this._markers ? this._markers.length : 0;\n            e > 0 && (t = t || this._map.latLngToLayerPoint(this._currentLatLng), this._clearGuides(), this._drawGuide(this._map.latLngToLayerPoint(this._markers[e - 1].getLatLng()), t));\n        },\n        _updateTooltip: function(t) {\n            var e = this._getTooltipText();\n            t && this._tooltip.updatePosition(t), this._errorShown || this._tooltip.updateContent(e);\n        },\n        _drawGuide: function(t, e) {\n            var i, o, a, n = Math.floor(Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))), s = this.options.guidelineDistance, r = this.options.maxGuideLineLength, l = n > r ? n - r : s;\n            for(this._guidesContainer || (this._guidesContainer = L.DomUtil.create(\"div\", \"leaflet-draw-guides\", this._overlayPane)); l < n; l += this.options.guidelineDistance)i = l / n, o = {\n                x: Math.floor(t.x * (1 - i) + i * e.x),\n                y: Math.floor(t.y * (1 - i) + i * e.y)\n            }, a = L.DomUtil.create(\"div\", \"leaflet-draw-guide-dash\", this._guidesContainer), a.style.backgroundColor = this._errorShown ? this.options.drawError.color : this.options.shapeOptions.color, L.DomUtil.setPosition(a, o);\n        },\n        _updateGuideColor: function(t) {\n            if (this._guidesContainer) for(var e = 0, i = this._guidesContainer.childNodes.length; e < i; e++)this._guidesContainer.childNodes[e].style.backgroundColor = t;\n        },\n        _clearGuides: function() {\n            if (this._guidesContainer) for(; this._guidesContainer.firstChild;)this._guidesContainer.removeChild(this._guidesContainer.firstChild);\n        },\n        _getTooltipText: function() {\n            var t, e, i = this.options.showLength;\n            return 0 === this._markers.length ? t = {\n                text: L.drawLocal.draw.handlers.polyline.tooltip.start\n            } : (e = i ? this._getMeasurementString() : \"\", t = 1 === this._markers.length ? {\n                text: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n                subtext: e\n            } : {\n                text: L.drawLocal.draw.handlers.polyline.tooltip.end,\n                subtext: e\n            }), t;\n        },\n        _updateRunningMeasure: function(t, e) {\n            var i, o, a = this._markers.length;\n            1 === this._markers.length ? this._measurementRunningTotal = 0 : (i = a - (e ? 2 : 1), o = L.GeometryUtil.isVersion07x() ? t.distanceTo(this._markers[i].getLatLng()) * (this.options.factor || 1) : this._map.distance(t, this._markers[i].getLatLng()) * (this.options.factor || 1), this._measurementRunningTotal += o * (e ? 1 : -1));\n        },\n        _getMeasurementString: function() {\n            var t, e = this._currentLatLng, i = this._markers[this._markers.length - 1].getLatLng();\n            return t = L.GeometryUtil.isVersion07x() ? i && e && e.distanceTo ? this._measurementRunningTotal + e.distanceTo(i) * (this.options.factor || 1) : this._measurementRunningTotal || 0 : i && e ? this._measurementRunningTotal + this._map.distance(e, i) * (this.options.factor || 1) : this._measurementRunningTotal || 0, L.GeometryUtil.readableDistance(t, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\n        },\n        _showErrorTooltip: function() {\n            this._errorShown = !0, this._tooltip.showAsError().updateContent({\n                text: this.options.drawError.message\n            }), this._updateGuideColor(this.options.drawError.color), this._poly.setStyle({\n                color: this.options.drawError.color\n            }), this._clearHideErrorTimeout(), this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n        },\n        _hideErrorTooltip: function() {\n            this._errorShown = !1, this._clearHideErrorTimeout(), this._tooltip.removeError().updateContent(this._getTooltipText()), this._updateGuideColor(this.options.shapeOptions.color), this._poly.setStyle({\n                color: this.options.shapeOptions.color\n            });\n        },\n        _clearHideErrorTimeout: function() {\n            this._hideErrorTimeout && (clearTimeout(this._hideErrorTimeout), this._hideErrorTimeout = null);\n        },\n        _disableNewMarkers: function() {\n            this._disableMarkers = !0;\n        },\n        _enableNewMarkers: function() {\n            setTimeout((function() {\n                this._disableMarkers = !1;\n            }).bind(this), 50);\n        },\n        _cleanUpShape: function() {\n            this._markers.length > 1 && this._markers[this._markers.length - 1].off(\"click\", this._finishShape, this);\n        },\n        _fireCreatedEvent: function() {\n            var t = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n            L.Draw.Feature.prototype._fireCreatedEvent.call(this, t);\n        }\n    }), L.Draw.Polygon = L.Draw.Polyline.extend({\n        statics: {\n            TYPE: \"polygon\"\n        },\n        Poly: L.Polygon,\n        options: {\n            showArea: !1,\n            showLength: !1,\n            shapeOptions: {\n                stroke: !0,\n                color: \"#3388ff\",\n                weight: 4,\n                opacity: .5,\n                fill: !0,\n                fillColor: null,\n                fillOpacity: .2,\n                clickable: !0\n            },\n            metric: !0,\n            feet: !0,\n            nautic: !1,\n            precision: {}\n        },\n        initialize: function(t, e) {\n            L.Draw.Polyline.prototype.initialize.call(this, t, e), this.type = L.Draw.Polygon.TYPE;\n        },\n        _updateFinishHandler: function() {\n            var t = this._markers.length;\n            1 === t && this._markers[0].on(\"click\", this._finishShape, this), t > 2 && (this._markers[t - 1].on(\"dblclick\", this._finishShape, this), t > 3 && this._markers[t - 2].off(\"dblclick\", this._finishShape, this));\n        },\n        _getTooltipText: function() {\n            var t, e;\n            return 0 === this._markers.length ? t = L.drawLocal.draw.handlers.polygon.tooltip.start : this._markers.length < 3 ? (t = L.drawLocal.draw.handlers.polygon.tooltip.cont, e = this._getMeasurementString()) : (t = L.drawLocal.draw.handlers.polygon.tooltip.end, e = this._getMeasurementString()), {\n                text: t,\n                subtext: e\n            };\n        },\n        _getMeasurementString: function() {\n            var t = this._area, e = \"\";\n            return t || this.options.showLength ? (this.options.showLength && (e = L.Draw.Polyline.prototype._getMeasurementString.call(this)), t && (e += \"<br>\" + L.GeometryUtil.readableArea(t, this.options.metric, this.options.precision)), e) : null;\n        },\n        _shapeIsValid: function() {\n            return this._markers.length >= 3;\n        },\n        _vertexChanged: function(t, e) {\n            var i;\n            !this.options.allowIntersection && this.options.showArea && (i = this._poly.getLatLngs(), this._area = L.GeometryUtil.geodesicArea(i)), L.Draw.Polyline.prototype._vertexChanged.call(this, t, e);\n        },\n        _cleanUpShape: function() {\n            var t = this._markers.length;\n            t > 0 && (this._markers[0].off(\"click\", this._finishShape, this), t > 2 && this._markers[t - 1].off(\"dblclick\", this._finishShape, this));\n        }\n    }), L.SimpleShape = {}, L.Draw.SimpleShape = L.Draw.Feature.extend({\n        options: {\n            repeatMode: !1\n        },\n        initialize: function(t, e) {\n            this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end, L.Draw.Feature.prototype.initialize.call(this, t, e);\n        },\n        addHooks: function() {\n            L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._mapDraggable = this._map.dragging.enabled(), this._mapDraggable && this._map.dragging.disable(), this._container.style.cursor = \"crosshair\", this._tooltip.updateContent({\n                text: this._initialLabelText\n            }), this._map.on(\"mousedown\", this._onMouseDown, this).on(\"mousemove\", this._onMouseMove, this).on(\"touchstart\", this._onMouseDown, this).on(\"touchmove\", this._onMouseMove, this), e.addEventListener(\"touchstart\", L.DomEvent.preventDefault, {\n                passive: !1\n            }));\n        },\n        removeHooks: function() {\n            L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._mapDraggable && this._map.dragging.enable(), this._container.style.cursor = \"\", this._map.off(\"mousedown\", this._onMouseDown, this).off(\"mousemove\", this._onMouseMove, this).off(\"touchstart\", this._onMouseDown, this).off(\"touchmove\", this._onMouseMove, this), L.DomEvent.off(e, \"mouseup\", this._onMouseUp, this), L.DomEvent.off(e, \"touchend\", this._onMouseUp, this), e.removeEventListener(\"touchstart\", L.DomEvent.preventDefault), this._shape && (this._map.removeLayer(this._shape), delete this._shape)), this._isDrawing = !1;\n        },\n        _getTooltipText: function() {\n            return {\n                text: this._endLabelText\n            };\n        },\n        _onMouseDown: function(t) {\n            this._isDrawing = !0, this._startLatLng = t.latlng, L.DomEvent.on(e, \"mouseup\", this._onMouseUp, this).on(e, \"touchend\", this._onMouseUp, this).preventDefault(t.originalEvent);\n        },\n        _onMouseMove: function(t) {\n            var e = t.latlng;\n            this._tooltip.updatePosition(e), this._isDrawing && (this._tooltip.updateContent(this._getTooltipText()), this._drawShape(e));\n        },\n        _onMouseUp: function() {\n            this._shape && this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();\n        }\n    }), L.Draw.Rectangle = L.Draw.SimpleShape.extend({\n        statics: {\n            TYPE: \"rectangle\"\n        },\n        options: {\n            shapeOptions: {\n                stroke: !0,\n                color: \"#3388ff\",\n                weight: 4,\n                opacity: .5,\n                fill: !0,\n                fillColor: null,\n                fillOpacity: .2,\n                clickable: !0\n            },\n            showArea: !0,\n            metric: !0\n        },\n        initialize: function(t, e) {\n            this.type = L.Draw.Rectangle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, t, e);\n        },\n        disable: function() {\n            this._enabled && (this._isCurrentlyTwoClickDrawing = !1, L.Draw.SimpleShape.prototype.disable.call(this));\n        },\n        _onMouseUp: function(t) {\n            if (!this._shape && !this._isCurrentlyTwoClickDrawing) return void (this._isCurrentlyTwoClickDrawing = !0);\n            this._isCurrentlyTwoClickDrawing && !o(t.target, \"leaflet-pane\") || L.Draw.SimpleShape.prototype._onMouseUp.call(this);\n        },\n        _drawShape: function(t) {\n            this._shape ? this._shape.setBounds(new L.LatLngBounds(this._startLatLng, t)) : (this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, t), this.options.shapeOptions), this._map.addLayer(this._shape));\n        },\n        _fireCreatedEvent: function() {\n            var t = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\n            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t);\n        },\n        _getTooltipText: function() {\n            var t, e, i, o = L.Draw.SimpleShape.prototype._getTooltipText.call(this), a = this._shape, n = this.options.showArea;\n            return a && (t = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(), e = L.GeometryUtil.geodesicArea(t), i = n ? L.GeometryUtil.readableArea(e, this.options.metric) : \"\"), {\n                text: o.text,\n                subtext: i\n            };\n        }\n    }), L.Draw.Marker = L.Draw.Feature.extend({\n        statics: {\n            TYPE: \"marker\"\n        },\n        options: {\n            icon: new L.Icon.Default,\n            repeatMode: !1,\n            zIndexOffset: 2e3\n        },\n        initialize: function(t, e) {\n            this.type = L.Draw.Marker.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start, L.Draw.Feature.prototype.initialize.call(this, t, e);\n        },\n        addHooks: function() {\n            L.Draw.Feature.prototype.addHooks.call(this), this._map && (this._tooltip.updateContent({\n                text: this._initialLabelText\n            }), this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), {\n                icon: L.divIcon({\n                    className: \"leaflet-mouse-marker\",\n                    iconAnchor: [\n                        20,\n                        20\n                    ],\n                    iconSize: [\n                        40,\n                        40\n                    ]\n                }),\n                opacity: 0,\n                zIndexOffset: this.options.zIndexOffset\n            })), this._mouseMarker.on(\"click\", this._onClick, this).addTo(this._map), this._map.on(\"mousemove\", this._onMouseMove, this), this._map.on(\"click\", this._onTouch, this));\n        },\n        removeHooks: function() {\n            L.Draw.Feature.prototype.removeHooks.call(this), this._map && (this._map.off(\"click\", this._onClick, this).off(\"click\", this._onTouch, this), this._marker && (this._marker.off(\"click\", this._onClick, this), this._map.removeLayer(this._marker), delete this._marker), this._mouseMarker.off(\"click\", this._onClick, this), this._map.removeLayer(this._mouseMarker), delete this._mouseMarker, this._map.off(\"mousemove\", this._onMouseMove, this));\n        },\n        _onMouseMove: function(t) {\n            var e = t.latlng;\n            this._tooltip.updatePosition(e), this._mouseMarker.setLatLng(e), this._marker ? (e = this._mouseMarker.getLatLng(), this._marker.setLatLng(e)) : (this._marker = this._createMarker(e), this._marker.on(\"click\", this._onClick, this), this._map.on(\"click\", this._onClick, this).addLayer(this._marker));\n        },\n        _createMarker: function(t) {\n            return new L.Marker(t, {\n                icon: this.options.icon,\n                zIndexOffset: this.options.zIndexOffset\n            });\n        },\n        _onClick: function() {\n            this._fireCreatedEvent(), this.disable(), this.options.repeatMode && this.enable();\n        },\n        _onTouch: function(t) {\n            this._onMouseMove(t), this._onClick();\n        },\n        _fireCreatedEvent: function() {\n            var t = new L.Marker.Touch(this._marker.getLatLng(), {\n                icon: this.options.icon\n            });\n            L.Draw.Feature.prototype._fireCreatedEvent.call(this, t);\n        }\n    }), L.Draw.CircleMarker = L.Draw.Marker.extend({\n        statics: {\n            TYPE: \"circlemarker\"\n        },\n        options: {\n            stroke: !0,\n            color: \"#3388ff\",\n            weight: 4,\n            opacity: .5,\n            fill: !0,\n            fillColor: null,\n            fillOpacity: .2,\n            clickable: !0,\n            zIndexOffset: 2e3\n        },\n        initialize: function(t, e) {\n            this.type = L.Draw.CircleMarker.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start, L.Draw.Feature.prototype.initialize.call(this, t, e);\n        },\n        _fireCreatedEvent: function() {\n            var t = new L.CircleMarker(this._marker.getLatLng(), this.options);\n            L.Draw.Feature.prototype._fireCreatedEvent.call(this, t);\n        },\n        _createMarker: function(t) {\n            return new L.CircleMarker(t, this.options);\n        }\n    }), L.Draw.Circle = L.Draw.SimpleShape.extend({\n        statics: {\n            TYPE: \"circle\"\n        },\n        options: {\n            shapeOptions: {\n                stroke: !0,\n                color: \"#3388ff\",\n                weight: 4,\n                opacity: .5,\n                fill: !0,\n                fillColor: null,\n                fillOpacity: .2,\n                clickable: !0\n            },\n            showRadius: !0,\n            metric: !0,\n            feet: !0,\n            nautic: !1\n        },\n        initialize: function(t, e) {\n            this.type = L.Draw.Circle.TYPE, this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start, L.Draw.SimpleShape.prototype.initialize.call(this, t, e);\n        },\n        _drawShape: function(t) {\n            if (L.GeometryUtil.isVersion07x()) var e = this._startLatLng.distanceTo(t);\n            else var e = this._map.distance(this._startLatLng, t);\n            this._shape ? this._shape.setRadius(e) : (this._shape = new L.Circle(this._startLatLng, e, this.options.shapeOptions), this._map.addLayer(this._shape));\n        },\n        _fireCreatedEvent: function() {\n            var t = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\n            L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t);\n        },\n        _onMouseMove: function(t) {\n            var e, i = t.latlng, o = this.options.showRadius, a = this.options.metric;\n            if (this._tooltip.updatePosition(i), this._isDrawing) {\n                this._drawShape(i), e = this._shape.getRadius().toFixed(1);\n                var n = \"\";\n                o && (n = L.drawLocal.draw.handlers.circle.radius + \": \" + L.GeometryUtil.readableDistance(e, a, this.options.feet, this.options.nautic)), this._tooltip.updateContent({\n                    text: this._endLabelText,\n                    subtext: n\n                });\n            }\n        }\n    }), L.Edit = L.Edit || {}, L.Edit.Marker = L.Handler.extend({\n        initialize: function(t, e) {\n            this._marker = t, L.setOptions(this, e);\n        },\n        addHooks: function() {\n            var t = this._marker;\n            t.dragging.enable(), t.on(\"dragend\", this._onDragEnd, t), this._toggleMarkerHighlight();\n        },\n        removeHooks: function() {\n            var t = this._marker;\n            t.dragging.disable(), t.off(\"dragend\", this._onDragEnd, t), this._toggleMarkerHighlight();\n        },\n        _onDragEnd: function(t) {\n            var e = t.target;\n            e.edited = !0, this._map.fire(L.Draw.Event.EDITMOVE, {\n                layer: e\n            });\n        },\n        _toggleMarkerHighlight: function() {\n            var t = this._marker._icon;\n            t && (t.style.display = \"none\", L.DomUtil.hasClass(t, \"leaflet-edit-marker-selected\") ? (L.DomUtil.removeClass(t, \"leaflet-edit-marker-selected\"), this._offsetMarker(t, -4)) : (L.DomUtil.addClass(t, \"leaflet-edit-marker-selected\"), this._offsetMarker(t, 4)), t.style.display = \"\");\n        },\n        _offsetMarker: function(t, e) {\n            var i = parseInt(t.style.marginTop, 10) - e, o = parseInt(t.style.marginLeft, 10) - e;\n            t.style.marginTop = i + \"px\", t.style.marginLeft = o + \"px\";\n        }\n    }), L.Marker.addInitHook(function() {\n        L.Edit.Marker && (this.editing = new L.Edit.Marker(this), this.options.editable && this.editing.enable());\n    }), L.Edit = L.Edit || {}, L.Edit.Poly = L.Handler.extend({\n        initialize: function(t) {\n            this.latlngs = [\n                t._latlngs\n            ], t._holes && (this.latlngs = this.latlngs.concat(t._holes)), this._poly = t, this._poly.on(\"revert-edited\", this._updateLatLngs, this);\n        },\n        _defaultShape: function() {\n            return L.Polyline._flat ? L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0] : this._poly._latlngs;\n        },\n        _eachVertexHandler: function(t) {\n            for(var e = 0; e < this._verticesHandlers.length; e++)t(this._verticesHandlers[e]);\n        },\n        addHooks: function() {\n            this._initHandlers(), this._eachVertexHandler(function(t) {\n                t.addHooks();\n            });\n        },\n        removeHooks: function() {\n            this._eachVertexHandler(function(t) {\n                t.removeHooks();\n            });\n        },\n        updateMarkers: function() {\n            this._eachVertexHandler(function(t) {\n                t.updateMarkers();\n            });\n        },\n        _initHandlers: function() {\n            this._verticesHandlers = [];\n            for(var t = 0; t < this.latlngs.length; t++)this._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[t], this._poly.options.poly));\n        },\n        _updateLatLngs: function(t) {\n            this.latlngs = [\n                t.layer._latlngs\n            ], t.layer._holes && (this.latlngs = this.latlngs.concat(t.layer._holes));\n        }\n    }), L.Edit.PolyVerticesEdit = L.Handler.extend({\n        options: {\n            icon: new L.DivIcon({\n                iconSize: new L.Point(8, 8),\n                className: \"leaflet-div-icon leaflet-editing-icon\"\n            }),\n            touchIcon: new L.DivIcon({\n                iconSize: new L.Point(20, 20),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon\"\n            }),\n            drawError: {\n                color: \"#b00b00\",\n                timeout: 1e3\n            }\n        },\n        initialize: function(t, e, i) {\n            L.Browser.touch && (this.options.icon = this.options.touchIcon), this._poly = t, i && i.drawError && (i.drawError = L.Util.extend({}, this.options.drawError, i.drawError)), this._latlngs = e, L.setOptions(this, i);\n        },\n        _defaultShape: function() {\n            return L.Polyline._flat ? L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0] : this._latlngs;\n        },\n        addHooks: function() {\n            var t = this._poly, e = t._path;\n            t instanceof L.Polygon || (t.options.fill = !1, t.options.editing && (t.options.editing.fill = !1)), e && t.options.editing && t.options.editing.className && (t.options.original.className && t.options.original.className.split(\" \").forEach(function(t) {\n                L.DomUtil.removeClass(e, t);\n            }), t.options.editing.className.split(\" \").forEach(function(t) {\n                L.DomUtil.addClass(e, t);\n            })), t.setStyle(t.options.editing), this._poly._map && (this._map = this._poly._map, this._markerGroup || this._initMarkers(), this._poly._map.addLayer(this._markerGroup));\n        },\n        removeHooks: function() {\n            var t = this._poly, e = t._path;\n            e && t.options.editing && t.options.editing.className && (t.options.editing.className.split(\" \").forEach(function(t) {\n                L.DomUtil.removeClass(e, t);\n            }), t.options.original.className && t.options.original.className.split(\" \").forEach(function(t) {\n                L.DomUtil.addClass(e, t);\n            })), t.setStyle(t.options.original), t._map && (t._map.removeLayer(this._markerGroup), delete this._markerGroup, delete this._markers);\n        },\n        updateMarkers: function() {\n            this._markerGroup.clearLayers(), this._initMarkers();\n        },\n        _initMarkers: function() {\n            this._markerGroup || (this._markerGroup = new L.LayerGroup), this._markers = [];\n            var t, e, i, o, a = this._defaultShape();\n            for(t = 0, i = a.length; t < i; t++)o = this._createMarker(a[t], t), o.on(\"click\", this._onMarkerClick, this), o.on(\"contextmenu\", this._onContextMenu, this), this._markers.push(o);\n            var n, s;\n            for(t = 0, e = i - 1; t < i; e = t++)(0 !== t || L.Polygon && this._poly instanceof L.Polygon) && (n = this._markers[e], s = this._markers[t], this._createMiddleMarker(n, s), this._updatePrevNext(n, s));\n        },\n        _createMarker: function(t, e) {\n            var i = new L.Marker.Touch(t, {\n                draggable: !0,\n                icon: this.options.icon\n            });\n            return i._origLatLng = t, i._index = e, i.on(\"dragstart\", this._onMarkerDragStart, this).on(\"drag\", this._onMarkerDrag, this).on(\"dragend\", this._fireEdit, this).on(\"touchmove\", this._onTouchMove, this).on(\"touchend\", this._fireEdit, this).on(\"MSPointerMove\", this._onTouchMove, this).on(\"MSPointerUp\", this._fireEdit, this), this._markerGroup.addLayer(i), i;\n        },\n        _onMarkerDragStart: function() {\n            this._poly.fire(\"editstart\");\n        },\n        _spliceLatLngs: function() {\n            var t = this._defaultShape(), e = [].splice.apply(t, arguments);\n            return this._poly._convertLatLngs(t, !0), this._poly.redraw(), e;\n        },\n        _removeMarker: function(t) {\n            var e = t._index;\n            this._markerGroup.removeLayer(t), this._markers.splice(e, 1), this._spliceLatLngs(e, 1), this._updateIndexes(e, -1), t.off(\"dragstart\", this._onMarkerDragStart, this).off(\"drag\", this._onMarkerDrag, this).off(\"dragend\", this._fireEdit, this).off(\"touchmove\", this._onMarkerDrag, this).off(\"touchend\", this._fireEdit, this).off(\"click\", this._onMarkerClick, this).off(\"MSPointerMove\", this._onTouchMove, this).off(\"MSPointerUp\", this._fireEdit, this);\n        },\n        _fireEdit: function() {\n            this._poly.edited = !0, this._poly.fire(\"edit\"), this._poly._map.fire(L.Draw.Event.EDITVERTEX, {\n                layers: this._markerGroup,\n                poly: this._poly\n            });\n        },\n        _onMarkerDrag: function(t) {\n            var e = t.target, i = this._poly, o = L.LatLngUtil.cloneLatLng(e._origLatLng);\n            if (L.extend(e._origLatLng, e._latlng), i.options.poly) {\n                var a = i._map._editTooltip;\n                if (!i.options.poly.allowIntersection && i.intersects()) {\n                    L.extend(e._origLatLng, o), e.setLatLng(o);\n                    var n = i.options.color;\n                    i.setStyle({\n                        color: this.options.drawError.color\n                    }), a && a.updateContent({\n                        text: L.drawLocal.draw.handlers.polyline.error\n                    }), setTimeout(function() {\n                        i.setStyle({\n                            color: n\n                        }), a && a.updateContent({\n                            text: L.drawLocal.edit.handlers.edit.tooltip.text,\n                            subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n                        });\n                    }, 1e3);\n                }\n            }\n            e._middleLeft && e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev, e)), e._middleRight && e._middleRight.setLatLng(this._getMiddleLatLng(e, e._next)), this._poly._bounds._southWest = L.latLng(1 / 0, 1 / 0), this._poly._bounds._northEast = L.latLng(-1 / 0, -1 / 0);\n            var s = this._poly.getLatLngs();\n            this._poly._convertLatLngs(s, !0), this._poly.redraw(), this._poly.fire(\"editdrag\");\n        },\n        _onMarkerClick: function(t) {\n            var e = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3, i = t.target;\n            this._defaultShape().length < e || (this._removeMarker(i), this._updatePrevNext(i._prev, i._next), i._middleLeft && this._markerGroup.removeLayer(i._middleLeft), i._middleRight && this._markerGroup.removeLayer(i._middleRight), i._prev && i._next ? this._createMiddleMarker(i._prev, i._next) : i._prev ? i._next || (i._prev._middleRight = null) : i._next._middleLeft = null, this._fireEdit());\n        },\n        _onContextMenu: function(t) {\n            var e = t.target;\n            this._poly;\n            this._poly._map.fire(L.Draw.Event.MARKERCONTEXT, {\n                marker: e,\n                layers: this._markerGroup,\n                poly: this._poly\n            }), L.DomEvent.stopPropagation;\n        },\n        _onTouchMove: function(t) {\n            var e = this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]), i = this._map.layerPointToLatLng(e), o = t.target;\n            L.extend(o._origLatLng, i), o._middleLeft && o._middleLeft.setLatLng(this._getMiddleLatLng(o._prev, o)), o._middleRight && o._middleRight.setLatLng(this._getMiddleLatLng(o, o._next)), this._poly.redraw(), this.updateMarkers();\n        },\n        _updateIndexes: function(t, e) {\n            this._markerGroup.eachLayer(function(i) {\n                i._index > t && (i._index += e);\n            });\n        },\n        _createMiddleMarker: function(t, e) {\n            var i, o, a, n = this._getMiddleLatLng(t, e), s = this._createMarker(n);\n            s.setOpacity(.6), t._middleRight = e._middleLeft = s, o = function() {\n                s.off(\"touchmove\", o, this);\n                var a = e._index;\n                s._index = a, s.off(\"click\", i, this).on(\"click\", this._onMarkerClick, this), n.lat = s.getLatLng().lat, n.lng = s.getLatLng().lng, this._spliceLatLngs(a, 0, n), this._markers.splice(a, 0, s), s.setOpacity(1), this._updateIndexes(a, 1), e._index++, this._updatePrevNext(t, s), this._updatePrevNext(s, e), this._poly.fire(\"editstart\");\n            }, a = function() {\n                s.off(\"dragstart\", o, this), s.off(\"dragend\", a, this), s.off(\"touchmove\", o, this), this._createMiddleMarker(t, s), this._createMiddleMarker(s, e);\n            }, i = function() {\n                o.call(this), a.call(this), this._fireEdit();\n            }, s.on(\"click\", i, this).on(\"dragstart\", o, this).on(\"dragend\", a, this).on(\"touchmove\", o, this), this._markerGroup.addLayer(s);\n        },\n        _updatePrevNext: function(t, e) {\n            t && (t._next = e), e && (e._prev = t);\n        },\n        _getMiddleLatLng: function(t, e) {\n            var i = this._poly._map, o = i.project(t.getLatLng()), a = i.project(e.getLatLng());\n            return i.unproject(o._add(a)._divideBy(2));\n        }\n    }), L.Polyline.addInitHook(function() {\n        this.editing || (L.Edit.Poly && (this.editing = new L.Edit.Poly(this), this.options.editable && this.editing.enable()), this.on(\"add\", function() {\n            this.editing && this.editing.enabled() && this.editing.addHooks();\n        }), this.on(\"remove\", function() {\n            this.editing && this.editing.enabled() && this.editing.removeHooks();\n        }));\n    }), L.Edit = L.Edit || {}, L.Edit.SimpleShape = L.Handler.extend({\n        options: {\n            moveIcon: new L.DivIcon({\n                iconSize: new L.Point(8, 8),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-move\"\n            }),\n            resizeIcon: new L.DivIcon({\n                iconSize: new L.Point(8, 8),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize\"\n            }),\n            touchMoveIcon: new L.DivIcon({\n                iconSize: new L.Point(20, 20),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon\"\n            }),\n            touchResizeIcon: new L.DivIcon({\n                iconSize: new L.Point(20, 20),\n                className: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon\"\n            })\n        },\n        initialize: function(t, e) {\n            L.Browser.touch && (this.options.moveIcon = this.options.touchMoveIcon, this.options.resizeIcon = this.options.touchResizeIcon), this._shape = t, L.Util.setOptions(this, e);\n        },\n        addHooks: function() {\n            var t = this._shape;\n            this._shape._map && (this._map = this._shape._map, t.setStyle(t.options.editing), t._map && (this._map = t._map, this._markerGroup || this._initMarkers(), this._map.addLayer(this._markerGroup)));\n        },\n        removeHooks: function() {\n            var t = this._shape;\n            if (t.setStyle(t.options.original), t._map) {\n                this._unbindMarker(this._moveMarker);\n                for(var e = 0, i = this._resizeMarkers.length; e < i; e++)this._unbindMarker(this._resizeMarkers[e]);\n                this._resizeMarkers = null, this._map.removeLayer(this._markerGroup), delete this._markerGroup;\n            }\n            this._map = null;\n        },\n        updateMarkers: function() {\n            this._markerGroup.clearLayers(), this._initMarkers();\n        },\n        _initMarkers: function() {\n            this._markerGroup || (this._markerGroup = new L.LayerGroup), this._createMoveMarker(), this._createResizeMarker();\n        },\n        _createMoveMarker: function() {},\n        _createResizeMarker: function() {},\n        _createMarker: function(t, e) {\n            var i = new L.Marker.Touch(t, {\n                draggable: !0,\n                icon: e,\n                zIndexOffset: 10\n            });\n            return this._bindMarker(i), this._markerGroup.addLayer(i), i;\n        },\n        _bindMarker: function(t) {\n            t.on(\"dragstart\", this._onMarkerDragStart, this).on(\"drag\", this._onMarkerDrag, this).on(\"dragend\", this._onMarkerDragEnd, this).on(\"touchstart\", this._onTouchStart, this).on(\"touchmove\", this._onTouchMove, this).on(\"MSPointerMove\", this._onTouchMove, this).on(\"touchend\", this._onTouchEnd, this).on(\"MSPointerUp\", this._onTouchEnd, this);\n        },\n        _unbindMarker: function(t) {\n            t.off(\"dragstart\", this._onMarkerDragStart, this).off(\"drag\", this._onMarkerDrag, this).off(\"dragend\", this._onMarkerDragEnd, this).off(\"touchstart\", this._onTouchStart, this).off(\"touchmove\", this._onTouchMove, this).off(\"MSPointerMove\", this._onTouchMove, this).off(\"touchend\", this._onTouchEnd, this).off(\"MSPointerUp\", this._onTouchEnd, this);\n        },\n        _onMarkerDragStart: function(t) {\n            t.target.setOpacity(0), this._shape.fire(\"editstart\");\n        },\n        _fireEdit: function() {\n            this._shape.edited = !0, this._shape.fire(\"edit\");\n        },\n        _onMarkerDrag: function(t) {\n            var e = t.target, i = e.getLatLng();\n            e === this._moveMarker ? this._move(i) : this._resize(i), this._shape.redraw(), this._shape.fire(\"editdrag\");\n        },\n        _onMarkerDragEnd: function(t) {\n            t.target.setOpacity(1), this._fireEdit();\n        },\n        _onTouchStart: function(t) {\n            if (L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, t), \"function\" == typeof this._getCorners) {\n                var e = this._getCorners(), i = t.target, o = i._cornerIndex;\n                i.setOpacity(0), this._oppositeCorner = e[(o + 2) % 4], this._toggleCornerMarkers(0, o);\n            }\n            this._shape.fire(\"editstart\");\n        },\n        _onTouchMove: function(t) {\n            var e = this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]), i = this._map.layerPointToLatLng(e);\n            return t.target === this._moveMarker ? this._move(i) : this._resize(i), this._shape.redraw(), !1;\n        },\n        _onTouchEnd: function(t) {\n            t.target.setOpacity(1), this.updateMarkers(), this._fireEdit();\n        },\n        _move: function() {},\n        _resize: function() {}\n    }), L.Edit = L.Edit || {}, L.Edit.Rectangle = L.Edit.SimpleShape.extend({\n        _createMoveMarker: function() {\n            var t = this._shape.getBounds(), e = t.getCenter();\n            this._moveMarker = this._createMarker(e, this.options.moveIcon);\n        },\n        _createResizeMarker: function() {\n            var t = this._getCorners();\n            this._resizeMarkers = [];\n            for(var e = 0, i = t.length; e < i; e++)this._resizeMarkers.push(this._createMarker(t[e], this.options.resizeIcon)), this._resizeMarkers[e]._cornerIndex = e;\n        },\n        _onMarkerDragStart: function(t) {\n            L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, t);\n            var e = this._getCorners(), i = t.target, o = i._cornerIndex;\n            this._oppositeCorner = e[(o + 2) % 4], this._toggleCornerMarkers(0, o);\n        },\n        _onMarkerDragEnd: function(t) {\n            var e, i, o = t.target;\n            o === this._moveMarker && (e = this._shape.getBounds(), i = e.getCenter(), o.setLatLng(i)), this._toggleCornerMarkers(1), this._repositionCornerMarkers(), L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, t);\n        },\n        _move: function(t) {\n            for(var e, i = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(), o = this._shape.getBounds(), a = o.getCenter(), n = [], s = 0, r = i.length; s < r; s++)e = [\n                i[s].lat - a.lat,\n                i[s].lng - a.lng\n            ], n.push([\n                t.lat + e[0],\n                t.lng + e[1]\n            ]);\n            this._shape.setLatLngs(n), this._repositionCornerMarkers(), this._map.fire(L.Draw.Event.EDITMOVE, {\n                layer: this._shape\n            });\n        },\n        _resize: function(t) {\n            var e;\n            this._shape.setBounds(L.latLngBounds(t, this._oppositeCorner)), e = this._shape.getBounds(), this._moveMarker.setLatLng(e.getCenter()), this._map.fire(L.Draw.Event.EDITRESIZE, {\n                layer: this._shape\n            });\n        },\n        _getCorners: function() {\n            var t = this._shape.getBounds();\n            return [\n                t.getNorthWest(),\n                t.getNorthEast(),\n                t.getSouthEast(),\n                t.getSouthWest()\n            ];\n        },\n        _toggleCornerMarkers: function(t) {\n            for(var e = 0, i = this._resizeMarkers.length; e < i; e++)this._resizeMarkers[e].setOpacity(t);\n        },\n        _repositionCornerMarkers: function() {\n            for(var t = this._getCorners(), e = 0, i = this._resizeMarkers.length; e < i; e++)this._resizeMarkers[e].setLatLng(t[e]);\n        }\n    }), L.Rectangle.addInitHook(function() {\n        L.Edit.Rectangle && (this.editing = new L.Edit.Rectangle(this), this.options.editable && this.editing.enable());\n    }), L.Edit = L.Edit || {}, L.Edit.CircleMarker = L.Edit.SimpleShape.extend({\n        _createMoveMarker: function() {\n            var t = this._shape.getLatLng();\n            this._moveMarker = this._createMarker(t, this.options.moveIcon);\n        },\n        _createResizeMarker: function() {\n            this._resizeMarkers = [];\n        },\n        _move: function(t) {\n            if (this._resizeMarkers.length) {\n                var e = this._getResizeMarkerPoint(t);\n                this._resizeMarkers[0].setLatLng(e);\n            }\n            this._shape.setLatLng(t), this._map.fire(L.Draw.Event.EDITMOVE, {\n                layer: this._shape\n            });\n        }\n    }), L.CircleMarker.addInitHook(function() {\n        L.Edit.CircleMarker && (this.editing = new L.Edit.CircleMarker(this), this.options.editable && this.editing.enable()), this.on(\"add\", function() {\n            this.editing && this.editing.enabled() && this.editing.addHooks();\n        }), this.on(\"remove\", function() {\n            this.editing && this.editing.enabled() && this.editing.removeHooks();\n        });\n    }), L.Edit = L.Edit || {}, L.Edit.Circle = L.Edit.CircleMarker.extend({\n        _createResizeMarker: function() {\n            var t = this._shape.getLatLng(), e = this._getResizeMarkerPoint(t);\n            this._resizeMarkers = [], this._resizeMarkers.push(this._createMarker(e, this.options.resizeIcon));\n        },\n        _getResizeMarkerPoint: function(t) {\n            var e = this._shape._radius * Math.cos(Math.PI / 4), i = this._map.project(t);\n            return this._map.unproject([\n                i.x + e,\n                i.y - e\n            ]);\n        },\n        _resize: function(t) {\n            var e = this._moveMarker.getLatLng();\n            L.GeometryUtil.isVersion07x() ? radius = e.distanceTo(t) : radius = this._map.distance(e, t), this._shape.setRadius(radius), this._map.editTooltip && this._map._editTooltip.updateContent({\n                text: L.drawLocal.edit.handlers.edit.tooltip.subtext + \"<br />\" + L.drawLocal.edit.handlers.edit.tooltip.text,\n                subtext: L.drawLocal.draw.handlers.circle.radius + \": \" + L.GeometryUtil.readableDistance(radius, !0, this.options.feet, this.options.nautic)\n            }), this._shape.setRadius(radius), this._map.fire(L.Draw.Event.EDITRESIZE, {\n                layer: this._shape\n            });\n        }\n    }), L.Circle.addInitHook(function() {\n        L.Edit.Circle && (this.editing = new L.Edit.Circle(this), this.options.editable && this.editing.enable());\n    }), L.Map.mergeOptions({\n        touchExtend: !0\n    }), L.Map.TouchExtend = L.Handler.extend({\n        initialize: function(t) {\n            this._map = t, this._container = t._container, this._pane = t._panes.overlayPane;\n        },\n        addHooks: function() {\n            L.DomEvent.on(this._container, \"touchstart\", this._onTouchStart, this), L.DomEvent.on(this._container, \"touchend\", this._onTouchEnd, this), L.DomEvent.on(this._container, \"touchmove\", this._onTouchMove, this), this._detectIE() ? (L.DomEvent.on(this._container, \"MSPointerDown\", this._onTouchStart, this), L.DomEvent.on(this._container, \"MSPointerUp\", this._onTouchEnd, this), L.DomEvent.on(this._container, \"MSPointerMove\", this._onTouchMove, this), L.DomEvent.on(this._container, \"MSPointerCancel\", this._onTouchCancel, this)) : (L.DomEvent.on(this._container, \"touchcancel\", this._onTouchCancel, this), L.DomEvent.on(this._container, \"touchleave\", this._onTouchLeave, this));\n        },\n        removeHooks: function() {\n            L.DomEvent.off(this._container, \"touchstart\", this._onTouchStart, this), L.DomEvent.off(this._container, \"touchend\", this._onTouchEnd, this), L.DomEvent.off(this._container, \"touchmove\", this._onTouchMove, this), this._detectIE() ? (L.DomEvent.off(this._container, \"MSPointerDown\", this._onTouchStart, this), L.DomEvent.off(this._container, \"MSPointerUp\", this._onTouchEnd, this), L.DomEvent.off(this._container, \"MSPointerMove\", this._onTouchMove, this), L.DomEvent.off(this._container, \"MSPointerCancel\", this._onTouchCancel, this)) : (L.DomEvent.off(this._container, \"touchcancel\", this._onTouchCancel, this), L.DomEvent.off(this._container, \"touchleave\", this._onTouchLeave, this));\n        },\n        _touchEvent: function(t, e) {\n            var i = {};\n            if (void 0 !== t.touches) {\n                if (!t.touches.length) return;\n                i = t.touches[0];\n            } else {\n                if (\"touch\" !== t.pointerType) return;\n                if (i = t, !this._filterClick(t)) return;\n            }\n            var o = this._map.mouseEventToContainerPoint(i), a = this._map.mouseEventToLayerPoint(i), n = this._map.layerPointToLatLng(a);\n            this._map.fire(e, {\n                latlng: n,\n                layerPoint: a,\n                containerPoint: o,\n                pageX: i.pageX,\n                pageY: i.pageY,\n                originalEvent: t\n            });\n        },\n        _filterClick: function(t) {\n            var e = t.timeStamp || t.originalEvent.timeStamp, i = L.DomEvent._lastClick && e - L.DomEvent._lastClick;\n            return i && i > 100 && i < 500 || t.target._simulatedClick && !t._simulated ? (L.DomEvent.stop(t), !1) : (L.DomEvent._lastClick = e, !0);\n        },\n        _onTouchStart: function(t) {\n            if (this._map._loaded) {\n                this._touchEvent(t, \"touchstart\");\n            }\n        },\n        _onTouchEnd: function(t) {\n            if (this._map._loaded) {\n                this._touchEvent(t, \"touchend\");\n            }\n        },\n        _onTouchCancel: function(t) {\n            if (this._map._loaded) {\n                var e = \"touchcancel\";\n                this._detectIE() && (e = \"pointercancel\"), this._touchEvent(t, e);\n            }\n        },\n        _onTouchLeave: function(t) {\n            if (this._map._loaded) {\n                this._touchEvent(t, \"touchleave\");\n            }\n        },\n        _onTouchMove: function(t) {\n            if (this._map._loaded) {\n                this._touchEvent(t, \"touchmove\");\n            }\n        },\n        _detectIE: function() {\n            var e = t.navigator.userAgent, i = e.indexOf(\"MSIE \");\n            if (i > 0) return parseInt(e.substring(i + 5, e.indexOf(\".\", i)), 10);\n            if (e.indexOf(\"Trident/\") > 0) {\n                var o = e.indexOf(\"rv:\");\n                return parseInt(e.substring(o + 3, e.indexOf(\".\", o)), 10);\n            }\n            var a = e.indexOf(\"Edge/\");\n            return a > 0 && parseInt(e.substring(a + 5, e.indexOf(\".\", a)), 10);\n        }\n    }), L.Map.addInitHook(\"addHandler\", \"touchExtend\", L.Map.TouchExtend), L.Marker.Touch = L.Marker.extend({\n        _initInteraction: function() {\n            return this.addInteractiveTarget ? L.Marker.prototype._initInteraction.apply(this) : this._initInteractionLegacy();\n        },\n        _initInteractionLegacy: function() {\n            if (this.options.clickable) {\n                var t = this._icon, e = [\n                    \"dblclick\",\n                    \"mousedown\",\n                    \"mouseover\",\n                    \"mouseout\",\n                    \"contextmenu\",\n                    \"touchstart\",\n                    \"touchend\",\n                    \"touchmove\"\n                ];\n                this._detectIE ? e.concat([\n                    \"MSPointerDown\",\n                    \"MSPointerUp\",\n                    \"MSPointerMove\",\n                    \"MSPointerCancel\"\n                ]) : e.concat([\n                    \"touchcancel\"\n                ]), L.DomUtil.addClass(t, \"leaflet-clickable\"), L.DomEvent.on(t, \"click\", this._onMouseClick, this), L.DomEvent.on(t, \"keypress\", this._onKeyPress, this);\n                for(var i = 0; i < e.length; i++)L.DomEvent.on(t, e[i], this._fireMouseEvent, this);\n                L.Handler.MarkerDrag && (this.dragging = new L.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable());\n            }\n        },\n        _detectIE: function() {\n            var e = t.navigator.userAgent, i = e.indexOf(\"MSIE \");\n            if (i > 0) return parseInt(e.substring(i + 5, e.indexOf(\".\", i)), 10);\n            if (e.indexOf(\"Trident/\") > 0) {\n                var o = e.indexOf(\"rv:\");\n                return parseInt(e.substring(o + 3, e.indexOf(\".\", o)), 10);\n            }\n            var a = e.indexOf(\"Edge/\");\n            return a > 0 && parseInt(e.substring(a + 5, e.indexOf(\".\", a)), 10);\n        }\n    }), L.LatLngUtil = {\n        cloneLatLngs: function(t) {\n            for(var e = [], i = 0, o = t.length; i < o; i++)Array.isArray(t[i]) ? e.push(L.LatLngUtil.cloneLatLngs(t[i])) : e.push(this.cloneLatLng(t[i]));\n            return e;\n        },\n        cloneLatLng: function(t) {\n            return L.latLng(t.lat, t.lng);\n        }\n    }, function() {\n        var t = {\n            km: 2,\n            ha: 2,\n            m: 0,\n            mi: 2,\n            ac: 2,\n            yd: 0,\n            ft: 0,\n            nm: 2\n        };\n        L.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n            geodesicArea: function(t) {\n                var e, i, o = t.length, a = 0, n = Math.PI / 180;\n                if (o > 2) {\n                    for(var s = 0; s < o; s++)e = t[s], i = t[(s + 1) % o], a += (i.lng - e.lng) * n * (2 + Math.sin(e.lat * n) + Math.sin(i.lat * n));\n                    a = 6378137 * a * 6378137 / 2;\n                }\n                return Math.abs(a);\n            },\n            formattedNumber: function(t, e) {\n                var i = parseFloat(t).toFixed(e), o = L.drawLocal.format && L.drawLocal.format.numeric, a = o && o.delimiters, n = a && a.thousands, s = a && a.decimal;\n                if (n || s) {\n                    var r = i.split(\".\");\n                    i = n ? r[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1\" + n) : r[0], s = s || \".\", r.length > 1 && (i = i + s + r[1]);\n                }\n                return i;\n            },\n            readableArea: function(e, i, o) {\n                var a, n, o = L.Util.extend({}, t, o);\n                return i ? (n = [\n                    \"ha\",\n                    \"m\"\n                ], type = typeof i, \"string\" === type ? n = [\n                    i\n                ] : \"boolean\" !== type && (n = i), a = e >= 1e6 && -1 !== n.indexOf(\"km\") ? L.GeometryUtil.formattedNumber(1e-6 * e, o.km) + \" km\\xb2\" : e >= 1e4 && -1 !== n.indexOf(\"ha\") ? L.GeometryUtil.formattedNumber(1e-4 * e, o.ha) + \" ha\" : L.GeometryUtil.formattedNumber(e, o.m) + \" m\\xb2\") : (e /= .836127, a = e >= 3097600 ? L.GeometryUtil.formattedNumber(e / 3097600, o.mi) + \" mi\\xb2\" : e >= 4840 ? L.GeometryUtil.formattedNumber(e / 4840, o.ac) + \" acres\" : L.GeometryUtil.formattedNumber(e, o.yd) + \" yd\\xb2\"), a;\n            },\n            readableDistance: function(e, i, o, a, n) {\n                var s, n = L.Util.extend({}, t, n);\n                switch(i ? \"string\" == typeof i ? i : \"metric\" : o ? \"feet\" : a ? \"nauticalMile\" : \"yards\"){\n                    case \"metric\":\n                        s = e > 1e3 ? L.GeometryUtil.formattedNumber(e / 1e3, n.km) + \" km\" : L.GeometryUtil.formattedNumber(e, n.m) + \" m\";\n                        break;\n                    case \"feet\":\n                        e *= 3.28083, s = L.GeometryUtil.formattedNumber(e, n.ft) + \" ft\";\n                        break;\n                    case \"nauticalMile\":\n                        e *= .53996, s = L.GeometryUtil.formattedNumber(e / 1e3, n.nm) + \" nm\";\n                        break;\n                    case \"yards\":\n                    default:\n                        e *= 1.09361, s = e > 1760 ? L.GeometryUtil.formattedNumber(e / 1760, n.mi) + \" miles\" : L.GeometryUtil.formattedNumber(e, n.yd) + \" yd\";\n                }\n                return s;\n            },\n            isVersion07x: function() {\n                var t = L.version.split(\".\");\n                return 0 === parseInt(t[0], 10) && 7 === parseInt(t[1], 10);\n            }\n        });\n    }(), L.Util.extend(L.LineUtil, {\n        segmentsIntersect: function(t, e, i, o) {\n            return this._checkCounterclockwise(t, i, o) !== this._checkCounterclockwise(e, i, o) && this._checkCounterclockwise(t, e, i) !== this._checkCounterclockwise(t, e, o);\n        },\n        _checkCounterclockwise: function(t, e, i) {\n            return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x);\n        }\n    }), L.Polyline.include({\n        intersects: function() {\n            var t, e, i, o = this._getProjectedPoints(), a = o ? o.length : 0;\n            if (this._tooFewPointsForIntersection()) return !1;\n            for(t = a - 1; t >= 3; t--)if (e = o[t - 1], i = o[t], this._lineSegmentsIntersectsRange(e, i, t - 2)) return !0;\n            return !1;\n        },\n        newLatLngIntersects: function(t, e) {\n            return !!this._map && this.newPointIntersects(this._map.latLngToLayerPoint(t), e);\n        },\n        newPointIntersects: function(t, e) {\n            var i = this._getProjectedPoints(), o = i ? i.length : 0, a = i ? i[o - 1] : null, n = o - 2;\n            return !this._tooFewPointsForIntersection(1) && this._lineSegmentsIntersectsRange(a, t, n, e ? 1 : 0);\n        },\n        _tooFewPointsForIntersection: function(t) {\n            var e = this._getProjectedPoints(), i = e ? e.length : 0;\n            return i += t || 0, !e || i <= 3;\n        },\n        _lineSegmentsIntersectsRange: function(t, e, i, o) {\n            var a, n, s = this._getProjectedPoints();\n            o = o || 0;\n            for(var r = i; r > o; r--)if (a = s[r - 1], n = s[r], L.LineUtil.segmentsIntersect(t, e, a, n)) return !0;\n            return !1;\n        },\n        _getProjectedPoints: function() {\n            if (!this._defaultShape) return this._originalPoints;\n            for(var t = [], e = this._defaultShape(), i = 0; i < e.length; i++)t.push(this._map.latLngToLayerPoint(e[i]));\n            return t;\n        }\n    }), L.Polygon.include({\n        intersects: function() {\n            var t, e, i, o, a = this._getProjectedPoints();\n            return !this._tooFewPointsForIntersection() && (!!L.Polyline.prototype.intersects.call(this) || (t = a.length, e = a[0], i = a[t - 1], o = t - 2, this._lineSegmentsIntersectsRange(i, e, o, 1)));\n        }\n    }), L.Control.Draw = L.Control.extend({\n        options: {\n            position: \"topleft\",\n            draw: {},\n            edit: !1\n        },\n        initialize: function(t) {\n            if (L.version < \"0.7\") throw new Error(\"Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/\");\n            L.Control.prototype.initialize.call(this, t);\n            var e;\n            this._toolbars = {}, L.DrawToolbar && this.options.draw && (e = new L.DrawToolbar(this.options.draw), this._toolbars[L.DrawToolbar.TYPE] = e, this._toolbars[L.DrawToolbar.TYPE].on(\"enable\", this._toolbarEnabled, this)), L.EditToolbar && this.options.edit && (e = new L.EditToolbar(this.options.edit), this._toolbars[L.EditToolbar.TYPE] = e, this._toolbars[L.EditToolbar.TYPE].on(\"enable\", this._toolbarEnabled, this)), L.toolbar = this;\n        },\n        onAdd: function(t) {\n            var e, i = L.DomUtil.create(\"div\", \"leaflet-draw\"), o = !1;\n            for(var a in this._toolbars)this._toolbars.hasOwnProperty(a) && (e = this._toolbars[a].addToolbar(t)) && (o || (L.DomUtil.hasClass(e, \"leaflet-draw-toolbar-top\") || L.DomUtil.addClass(e.childNodes[0], \"leaflet-draw-toolbar-top\"), o = !0), i.appendChild(e));\n            return i;\n        },\n        onRemove: function() {\n            for(var t in this._toolbars)this._toolbars.hasOwnProperty(t) && this._toolbars[t].removeToolbar();\n        },\n        setDrawingOptions: function(t) {\n            for(var e in this._toolbars)this._toolbars[e] instanceof L.DrawToolbar && this._toolbars[e].setOptions(t);\n        },\n        _toolbarEnabled: function(t) {\n            var e = t.target;\n            for(var i in this._toolbars)this._toolbars[i] !== e && this._toolbars[i].disable();\n        }\n    }), L.Map.mergeOptions({\n        drawControlTooltips: !0,\n        drawControl: !1\n    }), L.Map.addInitHook(function() {\n        this.options.drawControl && (this.drawControl = new L.Control.Draw, this.addControl(this.drawControl));\n    }), L.Toolbar = L.Class.extend({\n        initialize: function(t) {\n            L.setOptions(this, t), this._modes = {}, this._actionButtons = [], this._activeMode = null;\n            var e = L.version.split(\".\");\n            1 === parseInt(e[0], 10) && parseInt(e[1], 10) >= 2 ? L.Toolbar.include(L.Evented.prototype) : L.Toolbar.include(L.Mixin.Events);\n        },\n        enabled: function() {\n            return null !== this._activeMode;\n        },\n        disable: function() {\n            this.enabled() && this._activeMode.handler.disable();\n        },\n        addToolbar: function(t) {\n            var e, i = L.DomUtil.create(\"div\", \"leaflet-draw-section\"), o = 0, a = this._toolbarClass || \"\", n = this.getModeHandlers(t);\n            for(this._toolbarContainer = L.DomUtil.create(\"div\", \"leaflet-draw-toolbar leaflet-bar\"), this._map = t, e = 0; e < n.length; e++)n[e].enabled && this._initModeHandler(n[e].handler, this._toolbarContainer, o++, a, n[e].title);\n            if (o) return this._lastButtonIndex = --o, this._actionsContainer = L.DomUtil.create(\"ul\", \"leaflet-draw-actions\"), i.appendChild(this._toolbarContainer), i.appendChild(this._actionsContainer), i;\n        },\n        removeToolbar: function() {\n            for(var t in this._modes)this._modes.hasOwnProperty(t) && (this._disposeButton(this._modes[t].button, this._modes[t].handler.enable, this._modes[t].handler), this._modes[t].handler.disable(), this._modes[t].handler.off(\"enabled\", this._handlerActivated, this).off(\"disabled\", this._handlerDeactivated, this));\n            this._modes = {};\n            for(var e = 0, i = this._actionButtons.length; e < i; e++)this._disposeButton(this._actionButtons[e].button, this._actionButtons[e].callback, this);\n            this._actionButtons = [], this._actionsContainer = null;\n        },\n        _initModeHandler: function(t, e, i, o, a) {\n            var n = t.type;\n            this._modes[n] = {}, this._modes[n].handler = t, this._modes[n].button = this._createButton({\n                type: n,\n                title: a,\n                className: o + \"-\" + n,\n                container: e,\n                callback: this._modes[n].handler.enable,\n                context: this._modes[n].handler\n            }), this._modes[n].buttonIndex = i, this._modes[n].handler.on(\"enabled\", this._handlerActivated, this).on(\"disabled\", this._handlerDeactivated, this);\n        },\n        _detectIOS: function() {\n            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !t.MSStream;\n        },\n        _createButton: function(t) {\n            var e = L.DomUtil.create(\"a\", t.className || \"\", t.container), i = L.DomUtil.create(\"span\", \"sr-only\", t.container);\n            e.href = \"#\", e.appendChild(i), t.title && (e.title = t.title, i.innerHTML = t.title), t.text && (e.innerHTML = t.text, i.innerHTML = t.text);\n            var o = this._detectIOS() ? \"touchstart\" : \"click\";\n            return L.DomEvent.on(e, \"click\", L.DomEvent.stopPropagation).on(e, \"mousedown\", L.DomEvent.stopPropagation).on(e, \"dblclick\", L.DomEvent.stopPropagation).on(e, \"touchstart\", L.DomEvent.stopPropagation).on(e, \"click\", L.DomEvent.preventDefault).on(e, o, t.callback, t.context), e;\n        },\n        _disposeButton: function(t, e) {\n            var i = this._detectIOS() ? \"touchstart\" : \"click\";\n            L.DomEvent.off(t, \"click\", L.DomEvent.stopPropagation).off(t, \"mousedown\", L.DomEvent.stopPropagation).off(t, \"dblclick\", L.DomEvent.stopPropagation).off(t, \"touchstart\", L.DomEvent.stopPropagation).off(t, \"click\", L.DomEvent.preventDefault).off(t, i, e);\n        },\n        _handlerActivated: function(t) {\n            this.disable(), this._activeMode = this._modes[t.handler], L.DomUtil.addClass(this._activeMode.button, \"leaflet-draw-toolbar-button-enabled\"), this._showActionsToolbar(), this.fire(\"enable\");\n        },\n        _handlerDeactivated: function() {\n            this._hideActionsToolbar(), L.DomUtil.removeClass(this._activeMode.button, \"leaflet-draw-toolbar-button-enabled\"), this._activeMode = null, this.fire(\"disable\");\n        },\n        _createActions: function(t) {\n            var e, i, o, a, n = this._actionsContainer, s = this.getActions(t), r = s.length;\n            for(i = 0, o = this._actionButtons.length; i < o; i++)this._disposeButton(this._actionButtons[i].button, this._actionButtons[i].callback);\n            for(this._actionButtons = []; n.firstChild;)n.removeChild(n.firstChild);\n            for(var l = 0; l < r; l++)\"enabled\" in s[l] && !s[l].enabled || (e = L.DomUtil.create(\"li\", \"\", n), a = this._createButton({\n                title: s[l].title,\n                text: s[l].text,\n                container: e,\n                callback: s[l].callback,\n                context: s[l].context\n            }), this._actionButtons.push({\n                button: a,\n                callback: s[l].callback\n            }));\n        },\n        _showActionsToolbar: function() {\n            var t = this._activeMode.buttonIndex, e = this._lastButtonIndex, i = this._activeMode.button.offsetTop - 1;\n            this._createActions(this._activeMode.handler), this._actionsContainer.style.top = i + \"px\", 0 === t && (L.DomUtil.addClass(this._toolbarContainer, \"leaflet-draw-toolbar-notop\"), L.DomUtil.addClass(this._actionsContainer, \"leaflet-draw-actions-top\")), t === e && (L.DomUtil.addClass(this._toolbarContainer, \"leaflet-draw-toolbar-nobottom\"), L.DomUtil.addClass(this._actionsContainer, \"leaflet-draw-actions-bottom\")), this._actionsContainer.style.display = \"block\", this._map.fire(L.Draw.Event.TOOLBAROPENED);\n        },\n        _hideActionsToolbar: function() {\n            this._actionsContainer.style.display = \"none\", L.DomUtil.removeClass(this._toolbarContainer, \"leaflet-draw-toolbar-notop\"), L.DomUtil.removeClass(this._toolbarContainer, \"leaflet-draw-toolbar-nobottom\"), L.DomUtil.removeClass(this._actionsContainer, \"leaflet-draw-actions-top\"), L.DomUtil.removeClass(this._actionsContainer, \"leaflet-draw-actions-bottom\"), this._map.fire(L.Draw.Event.TOOLBARCLOSED);\n        }\n    }), L.Draw = L.Draw || {}, L.Draw.Tooltip = L.Class.extend({\n        initialize: function(t) {\n            this._map = t, this._popupPane = t._panes.popupPane, this._visible = !1, this._container = t.options.drawControlTooltips ? L.DomUtil.create(\"div\", \"leaflet-draw-tooltip\", this._popupPane) : null, this._singleLineLabel = !1, this._map.on(\"mouseout\", this._onMouseOut, this);\n        },\n        dispose: function() {\n            this._map.off(\"mouseout\", this._onMouseOut, this), this._container && (this._popupPane.removeChild(this._container), this._container = null);\n        },\n        updateContent: function(t) {\n            return this._container ? (t.subtext = t.subtext || \"\", 0 !== t.subtext.length || this._singleLineLabel ? t.subtext.length > 0 && this._singleLineLabel && (L.DomUtil.removeClass(this._container, \"leaflet-draw-tooltip-single\"), this._singleLineLabel = !1) : (L.DomUtil.addClass(this._container, \"leaflet-draw-tooltip-single\"), this._singleLineLabel = !0), this._container.innerHTML = (t.subtext.length > 0 ? '<span class=\"leaflet-draw-tooltip-subtext\">' + t.subtext + \"</span><br />\" : \"\") + \"<span>\" + t.text + \"</span>\", t.text || t.subtext ? (this._visible = !0, this._container.style.visibility = \"inherit\") : (this._visible = !1, this._container.style.visibility = \"hidden\"), this) : this;\n        },\n        updatePosition: function(t) {\n            var e = this._map.latLngToLayerPoint(t), i = this._container;\n            return this._container && (this._visible && (i.style.visibility = \"inherit\"), L.DomUtil.setPosition(i, e)), this;\n        },\n        showAsError: function() {\n            return this._container && L.DomUtil.addClass(this._container, \"leaflet-error-draw-tooltip\"), this;\n        },\n        removeError: function() {\n            return this._container && L.DomUtil.removeClass(this._container, \"leaflet-error-draw-tooltip\"), this;\n        },\n        _onMouseOut: function() {\n            this._container && (this._container.style.visibility = \"hidden\");\n        }\n    }), L.DrawToolbar = L.Toolbar.extend({\n        statics: {\n            TYPE: \"draw\"\n        },\n        options: {\n            polyline: {},\n            polygon: {},\n            rectangle: {},\n            circle: {},\n            marker: {},\n            circlemarker: {}\n        },\n        initialize: function(t) {\n            for(var e in this.options)this.options.hasOwnProperty(e) && t[e] && (t[e] = L.extend({}, this.options[e], t[e]));\n            this._toolbarClass = \"leaflet-draw-draw\", L.Toolbar.prototype.initialize.call(this, t);\n        },\n        getModeHandlers: function(t) {\n            return [\n                {\n                    enabled: this.options.polyline,\n                    handler: new L.Draw.Polyline(t, this.options.polyline),\n                    title: L.drawLocal.draw.toolbar.buttons.polyline\n                },\n                {\n                    enabled: this.options.polygon,\n                    handler: new L.Draw.Polygon(t, this.options.polygon),\n                    title: L.drawLocal.draw.toolbar.buttons.polygon\n                },\n                {\n                    enabled: this.options.rectangle,\n                    handler: new L.Draw.Rectangle(t, this.options.rectangle),\n                    title: L.drawLocal.draw.toolbar.buttons.rectangle\n                },\n                {\n                    enabled: this.options.circle,\n                    handler: new L.Draw.Circle(t, this.options.circle),\n                    title: L.drawLocal.draw.toolbar.buttons.circle\n                },\n                {\n                    enabled: this.options.marker,\n                    handler: new L.Draw.Marker(t, this.options.marker),\n                    title: L.drawLocal.draw.toolbar.buttons.marker\n                },\n                {\n                    enabled: this.options.circlemarker,\n                    handler: new L.Draw.CircleMarker(t, this.options.circlemarker),\n                    title: L.drawLocal.draw.toolbar.buttons.circlemarker\n                }\n            ];\n        },\n        getActions: function(t) {\n            return [\n                {\n                    enabled: t.completeShape,\n                    title: L.drawLocal.draw.toolbar.finish.title,\n                    text: L.drawLocal.draw.toolbar.finish.text,\n                    callback: t.completeShape,\n                    context: t\n                },\n                {\n                    enabled: t.deleteLastVertex,\n                    title: L.drawLocal.draw.toolbar.undo.title,\n                    text: L.drawLocal.draw.toolbar.undo.text,\n                    callback: t.deleteLastVertex,\n                    context: t\n                },\n                {\n                    title: L.drawLocal.draw.toolbar.actions.title,\n                    text: L.drawLocal.draw.toolbar.actions.text,\n                    callback: this.disable,\n                    context: this\n                }\n            ];\n        },\n        setOptions: function(t) {\n            L.setOptions(this, t);\n            for(var e in this._modes)this._modes.hasOwnProperty(e) && t.hasOwnProperty(e) && this._modes[e].handler.setOptions(t[e]);\n        }\n    }), L.EditToolbar = L.Toolbar.extend({\n        statics: {\n            TYPE: \"edit\"\n        },\n        options: {\n            edit: {\n                selectedPathOptions: {\n                    dashArray: \"10, 10\",\n                    fill: !0,\n                    fillColor: \"#fe57a1\",\n                    fillOpacity: .1,\n                    maintainColor: !1\n                }\n            },\n            remove: {},\n            poly: null,\n            featureGroup: null\n        },\n        initialize: function(t) {\n            t.edit && (void 0 === t.edit.selectedPathOptions && (t.edit.selectedPathOptions = this.options.edit.selectedPathOptions), t.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, t.edit.selectedPathOptions)), t.remove && (t.remove = L.extend({}, this.options.remove, t.remove)), t.poly && (t.poly = L.extend({}, this.options.poly, t.poly)), this._toolbarClass = \"leaflet-draw-edit\", L.Toolbar.prototype.initialize.call(this, t), this._selectedFeatureCount = 0;\n        },\n        getModeHandlers: function(t) {\n            var e = this.options.featureGroup;\n            return [\n                {\n                    enabled: this.options.edit,\n                    handler: new L.EditToolbar.Edit(t, {\n                        featureGroup: e,\n                        selectedPathOptions: this.options.edit.selectedPathOptions,\n                        poly: this.options.poly\n                    }),\n                    title: L.drawLocal.edit.toolbar.buttons.edit\n                },\n                {\n                    enabled: this.options.remove,\n                    handler: new L.EditToolbar.Delete(t, {\n                        featureGroup: e\n                    }),\n                    title: L.drawLocal.edit.toolbar.buttons.remove\n                }\n            ];\n        },\n        getActions: function(t) {\n            var e = [\n                {\n                    title: L.drawLocal.edit.toolbar.actions.save.title,\n                    text: L.drawLocal.edit.toolbar.actions.save.text,\n                    callback: this._save,\n                    context: this\n                },\n                {\n                    title: L.drawLocal.edit.toolbar.actions.cancel.title,\n                    text: L.drawLocal.edit.toolbar.actions.cancel.text,\n                    callback: this.disable,\n                    context: this\n                }\n            ];\n            return t.removeAllLayers && e.push({\n                title: L.drawLocal.edit.toolbar.actions.clearAll.title,\n                text: L.drawLocal.edit.toolbar.actions.clearAll.text,\n                callback: this._clearAllLayers,\n                context: this\n            }), e;\n        },\n        addToolbar: function(t) {\n            var e = L.Toolbar.prototype.addToolbar.call(this, t);\n            return this._checkDisabled(), this.options.featureGroup.on(\"layeradd layerremove\", this._checkDisabled, this), e;\n        },\n        removeToolbar: function() {\n            this.options.featureGroup.off(\"layeradd layerremove\", this._checkDisabled, this), L.Toolbar.prototype.removeToolbar.call(this);\n        },\n        disable: function() {\n            this.enabled() && (this._activeMode.handler.revertLayers(), L.Toolbar.prototype.disable.call(this));\n        },\n        _save: function() {\n            this._activeMode.handler.save(), this._activeMode && this._activeMode.handler.disable();\n        },\n        _clearAllLayers: function() {\n            this._activeMode.handler.removeAllLayers(), this._activeMode && this._activeMode.handler.disable();\n        },\n        _checkDisabled: function() {\n            var t, e = this.options.featureGroup, i = 0 !== e.getLayers().length;\n            this.options.edit && (t = this._modes[L.EditToolbar.Edit.TYPE].button, i ? L.DomUtil.removeClass(t, \"leaflet-disabled\") : L.DomUtil.addClass(t, \"leaflet-disabled\"), t.setAttribute(\"title\", i ? L.drawLocal.edit.toolbar.buttons.edit : L.drawLocal.edit.toolbar.buttons.editDisabled)), this.options.remove && (t = this._modes[L.EditToolbar.Delete.TYPE].button, i ? L.DomUtil.removeClass(t, \"leaflet-disabled\") : L.DomUtil.addClass(t, \"leaflet-disabled\"), t.setAttribute(\"title\", i ? L.drawLocal.edit.toolbar.buttons.remove : L.drawLocal.edit.toolbar.buttons.removeDisabled));\n        }\n    }), L.EditToolbar.Edit = L.Handler.extend({\n        statics: {\n            TYPE: \"edit\"\n        },\n        initialize: function(t, e) {\n            if (L.Handler.prototype.initialize.call(this, t), L.setOptions(this, e), this._featureGroup = e.featureGroup, !(this._featureGroup instanceof L.FeatureGroup)) throw new Error(\"options.featureGroup must be a L.FeatureGroup\");\n            this._uneditedLayerProps = {}, this.type = L.EditToolbar.Edit.TYPE;\n            var i = L.version.split(\".\");\n            1 === parseInt(i[0], 10) && parseInt(i[1], 10) >= 2 ? L.EditToolbar.Edit.include(L.Evented.prototype) : L.EditToolbar.Edit.include(L.Mixin.Events);\n        },\n        enable: function() {\n            !this._enabled && this._hasAvailableLayers() && (this.fire(\"enabled\", {\n                handler: this.type\n            }), this._map.fire(L.Draw.Event.EDITSTART, {\n                handler: this.type\n            }), L.Handler.prototype.enable.call(this), this._featureGroup.on(\"layeradd\", this._enableLayerEdit, this).on(\"layerremove\", this._disableLayerEdit, this));\n        },\n        disable: function() {\n            this._enabled && (this._featureGroup.off(\"layeradd\", this._enableLayerEdit, this).off(\"layerremove\", this._disableLayerEdit, this), L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.EDITSTOP, {\n                handler: this.type\n            }), this.fire(\"disabled\", {\n                handler: this.type\n            }));\n        },\n        addHooks: function() {\n            var t = this._map;\n            t && (t.getContainer().focus(), this._featureGroup.eachLayer(this._enableLayerEdit, this), this._tooltip = new L.Draw.Tooltip(this._map), this._tooltip.updateContent({\n                text: L.drawLocal.edit.handlers.edit.tooltip.text,\n                subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n            }), t._editTooltip = this._tooltip, this._updateTooltip(), this._map.on(\"mousemove\", this._onMouseMove, this).on(\"touchmove\", this._onMouseMove, this).on(\"MSPointerMove\", this._onMouseMove, this).on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this));\n        },\n        removeHooks: function() {\n            this._map && (this._featureGroup.eachLayer(this._disableLayerEdit, this), this._uneditedLayerProps = {}, this._tooltip.dispose(), this._tooltip = null, this._map.off(\"mousemove\", this._onMouseMove, this).off(\"touchmove\", this._onMouseMove, this).off(\"MSPointerMove\", this._onMouseMove, this).off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this));\n        },\n        revertLayers: function() {\n            this._featureGroup.eachLayer(function(t) {\n                this._revertLayer(t);\n            }, this);\n        },\n        save: function() {\n            var t = new L.LayerGroup;\n            this._featureGroup.eachLayer(function(e) {\n                e.edited && (t.addLayer(e), e.edited = !1);\n            }), this._map.fire(L.Draw.Event.EDITED, {\n                layers: t\n            });\n        },\n        _backupLayer: function(t) {\n            var e = L.Util.stamp(t);\n            this._uneditedLayerProps[e] || (t instanceof L.Polyline || t instanceof L.Polygon || t instanceof L.Rectangle ? this._uneditedLayerProps[e] = {\n                latlngs: L.LatLngUtil.cloneLatLngs(t.getLatLngs())\n            } : t instanceof L.Circle ? this._uneditedLayerProps[e] = {\n                latlng: L.LatLngUtil.cloneLatLng(t.getLatLng()),\n                radius: t.getRadius()\n            } : (t instanceof L.Marker || t instanceof L.CircleMarker) && (this._uneditedLayerProps[e] = {\n                latlng: L.LatLngUtil.cloneLatLng(t.getLatLng())\n            }));\n        },\n        _getTooltipText: function() {\n            return {\n                text: L.drawLocal.edit.handlers.edit.tooltip.text,\n                subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n            };\n        },\n        _updateTooltip: function() {\n            this._tooltip.updateContent(this._getTooltipText());\n        },\n        _revertLayer: function(t) {\n            var e = L.Util.stamp(t);\n            t.edited = !1, this._uneditedLayerProps.hasOwnProperty(e) && (t instanceof L.Polyline || t instanceof L.Polygon || t instanceof L.Rectangle ? t.setLatLngs(this._uneditedLayerProps[e].latlngs) : t instanceof L.Circle ? (t.setLatLng(this._uneditedLayerProps[e].latlng), t.setRadius(this._uneditedLayerProps[e].radius)) : (t instanceof L.Marker || t instanceof L.CircleMarker) && t.setLatLng(this._uneditedLayerProps[e].latlng), t.fire(\"revert-edited\", {\n                layer: t\n            }));\n        },\n        _enableLayerEdit: function(t) {\n            var e, i, o = t.layer || t.target || t;\n            this._backupLayer(o), this.options.poly && (i = L.Util.extend({}, this.options.poly), o.options.poly = i), this.options.selectedPathOptions && (e = L.Util.extend({}, this.options.selectedPathOptions), e.maintainColor && (e.color = o.options.color, e.fillColor = o.options.fillColor), o.options.original = L.extend({}, o.options), o.options.editing = e), o instanceof L.Marker ? (o.editing && o.editing.enable(), o.dragging.enable(), o.on(\"dragend\", this._onMarkerDragEnd).on(\"touchmove\", this._onTouchMove, this).on(\"MSPointerMove\", this._onTouchMove, this).on(\"touchend\", this._onMarkerDragEnd, this).on(\"MSPointerUp\", this._onMarkerDragEnd, this)) : o.editing.enable();\n        },\n        _disableLayerEdit: function(t) {\n            var e = t.layer || t.target || t;\n            e.edited = !1, e.editing && e.editing.disable(), delete e.options.editing, delete e.options.original, this._selectedPathOptions && (e instanceof L.Marker ? this._toggleMarkerHighlight(e) : (e.setStyle(e.options.previousOptions), delete e.options.previousOptions)), e instanceof L.Marker ? (e.dragging.disable(), e.off(\"dragend\", this._onMarkerDragEnd, this).off(\"touchmove\", this._onTouchMove, this).off(\"MSPointerMove\", this._onTouchMove, this).off(\"touchend\", this._onMarkerDragEnd, this).off(\"MSPointerUp\", this._onMarkerDragEnd, this)) : e.editing.disable();\n        },\n        _onMouseMove: function(t) {\n            this._tooltip.updatePosition(t.latlng);\n        },\n        _onMarkerDragEnd: function(t) {\n            var e = t.target;\n            e.edited = !0, this._map.fire(L.Draw.Event.EDITMOVE, {\n                layer: e\n            });\n        },\n        _onTouchMove: function(t) {\n            var e = t.originalEvent.changedTouches[0], i = this._map.mouseEventToLayerPoint(e), o = this._map.layerPointToLatLng(i);\n            t.target.setLatLng(o);\n        },\n        _hasAvailableLayers: function() {\n            return 0 !== this._featureGroup.getLayers().length;\n        }\n    }), L.EditToolbar.Delete = L.Handler.extend({\n        statics: {\n            TYPE: \"remove\"\n        },\n        initialize: function(t, e) {\n            if (L.Handler.prototype.initialize.call(this, t), L.Util.setOptions(this, e), this._deletableLayers = this.options.featureGroup, !(this._deletableLayers instanceof L.FeatureGroup)) throw new Error(\"options.featureGroup must be a L.FeatureGroup\");\n            this.type = L.EditToolbar.Delete.TYPE;\n            var i = L.version.split(\".\");\n            1 === parseInt(i[0], 10) && parseInt(i[1], 10) >= 2 ? L.EditToolbar.Delete.include(L.Evented.prototype) : L.EditToolbar.Delete.include(L.Mixin.Events);\n        },\n        enable: function() {\n            !this._enabled && this._hasAvailableLayers() && (this.fire(\"enabled\", {\n                handler: this.type\n            }), this._map.fire(L.Draw.Event.DELETESTART, {\n                handler: this.type\n            }), L.Handler.prototype.enable.call(this), this._deletableLayers.on(\"layeradd\", this._enableLayerDelete, this).on(\"layerremove\", this._disableLayerDelete, this));\n        },\n        disable: function() {\n            this._enabled && (this._deletableLayers.off(\"layeradd\", this._enableLayerDelete, this).off(\"layerremove\", this._disableLayerDelete, this), L.Handler.prototype.disable.call(this), this._map.fire(L.Draw.Event.DELETESTOP, {\n                handler: this.type\n            }), this.fire(\"disabled\", {\n                handler: this.type\n            }));\n        },\n        addHooks: function() {\n            var t = this._map;\n            t && (t.getContainer().focus(), this._deletableLayers.eachLayer(this._enableLayerDelete, this), this._deletedLayers = new L.LayerGroup, this._tooltip = new L.Draw.Tooltip(this._map), this._tooltip.updateContent({\n                text: L.drawLocal.edit.handlers.remove.tooltip.text\n            }), this._map.on(\"mousemove\", this._onMouseMove, this));\n        },\n        removeHooks: function() {\n            this._map && (this._deletableLayers.eachLayer(this._disableLayerDelete, this), this._deletedLayers = null, this._tooltip.dispose(), this._tooltip = null, this._map.off(\"mousemove\", this._onMouseMove, this));\n        },\n        revertLayers: function() {\n            this._deletedLayers.eachLayer(function(t) {\n                this._deletableLayers.addLayer(t), t.fire(\"revert-deleted\", {\n                    layer: t\n                });\n            }, this);\n        },\n        save: function() {\n            this._map.fire(L.Draw.Event.DELETED, {\n                layers: this._deletedLayers\n            });\n        },\n        removeAllLayers: function() {\n            this._deletableLayers.eachLayer(function(t) {\n                this._removeLayer({\n                    layer: t\n                });\n            }, this), this.save();\n        },\n        _enableLayerDelete: function(t) {\n            (t.layer || t.target || t).on(\"click\", this._removeLayer, this);\n        },\n        _disableLayerDelete: function(t) {\n            var e = t.layer || t.target || t;\n            e.off(\"click\", this._removeLayer, this), this._deletedLayers.removeLayer(e);\n        },\n        _removeLayer: function(t) {\n            var e = t.layer || t.target || t;\n            this._deletableLayers.removeLayer(e), this._deletedLayers.addLayer(e), e.fire(\"deleted\");\n        },\n        _onMouseMove: function(t) {\n            this._tooltip.updatePosition(t.latlng);\n        },\n        _hasAvailableLayers: function() {\n            return 0 !== this._deletableLayers.getLayers().length;\n        }\n    });\n}(window, document);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZHJhdy9kaXN0L2xlYWZsZXQuZHJhdy5qcz9lODEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gTGVhZmxldC5kcmF3IDEuMC40LCBhIHBsdWdpbiB0aGF0IGFkZHMgZHJhd2luZyBhbmQgZWRpdGluZyB0b29scyB0byBMZWFmbGV0IHBvd2VyZWQgbWFwcy5cbiAoYykgMjAxMi0yMDE3LCBKYWNvYiBUb3llLCBKb24gV2VzdCwgU21hcnRyYWssIExlYWZsZXRcblxuIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQuZHJhd1xuIGh0dHA6Ly9sZWFmbGV0anMuY29tXG4gKi9cbiFmdW5jdGlvbih0LGUsaSl7ZnVuY3Rpb24gbyh0LGUpe2Zvcig7KHQ9dC5wYXJlbnRFbGVtZW50KSYmIXQuY2xhc3NMaXN0LmNvbnRhaW5zKGUpOyk7cmV0dXJuIHR9TC5kcmF3VmVyc2lvbj1cIjEuMC40XCIsTC5EcmF3PXt9LEwuZHJhd0xvY2FsPXtkcmF3Ont0b29sYmFyOnthY3Rpb25zOnt0aXRsZTpcIkNhbmNlbCBkcmF3aW5nXCIsdGV4dDpcIkNhbmNlbFwifSxmaW5pc2g6e3RpdGxlOlwiRmluaXNoIGRyYXdpbmdcIix0ZXh0OlwiRmluaXNoXCJ9LHVuZG86e3RpdGxlOlwiRGVsZXRlIGxhc3QgcG9pbnQgZHJhd25cIix0ZXh0OlwiRGVsZXRlIGxhc3QgcG9pbnRcIn0sYnV0dG9uczp7cG9seWxpbmU6XCJEcmF3IGEgcG9seWxpbmVcIixwb2x5Z29uOlwiRHJhdyBhIHBvbHlnb25cIixyZWN0YW5nbGU6XCJEcmF3IGEgcmVjdGFuZ2xlXCIsY2lyY2xlOlwiRHJhdyBhIGNpcmNsZVwiLG1hcmtlcjpcIkRyYXcgYSBtYXJrZXJcIixjaXJjbGVtYXJrZXI6XCJEcmF3IGEgY2lyY2xlbWFya2VyXCJ9fSxoYW5kbGVyczp7Y2lyY2xlOnt0b29sdGlwOntzdGFydDpcIkNsaWNrIGFuZCBkcmFnIHRvIGRyYXcgY2lyY2xlLlwifSxyYWRpdXM6XCJSYWRpdXNcIn0sY2lyY2xlbWFya2VyOnt0b29sdGlwOntzdGFydDpcIkNsaWNrIG1hcCB0byBwbGFjZSBjaXJjbGUgbWFya2VyLlwifX0sbWFya2VyOnt0b29sdGlwOntzdGFydDpcIkNsaWNrIG1hcCB0byBwbGFjZSBtYXJrZXIuXCJ9fSxwb2x5Z29uOnt0b29sdGlwOntzdGFydDpcIkNsaWNrIHRvIHN0YXJ0IGRyYXdpbmcgc2hhcGUuXCIsY29udDpcIkNsaWNrIHRvIGNvbnRpbnVlIGRyYXdpbmcgc2hhcGUuXCIsZW5kOlwiQ2xpY2sgZmlyc3QgcG9pbnQgdG8gY2xvc2UgdGhpcyBzaGFwZS5cIn19LHBvbHlsaW5lOntlcnJvcjpcIjxzdHJvbmc+RXJyb3I6PC9zdHJvbmc+IHNoYXBlIGVkZ2VzIGNhbm5vdCBjcm9zcyFcIix0b29sdGlwOntzdGFydDpcIkNsaWNrIHRvIHN0YXJ0IGRyYXdpbmcgbGluZS5cIixjb250OlwiQ2xpY2sgdG8gY29udGludWUgZHJhd2luZyBsaW5lLlwiLGVuZDpcIkNsaWNrIGxhc3QgcG9pbnQgdG8gZmluaXNoIGxpbmUuXCJ9fSxyZWN0YW5nbGU6e3Rvb2x0aXA6e3N0YXJ0OlwiQ2xpY2sgYW5kIGRyYWcgdG8gZHJhdyByZWN0YW5nbGUuXCJ9fSxzaW1wbGVzaGFwZTp7dG9vbHRpcDp7ZW5kOlwiUmVsZWFzZSBtb3VzZSB0byBmaW5pc2ggZHJhd2luZy5cIn19fX0sZWRpdDp7dG9vbGJhcjp7YWN0aW9uczp7c2F2ZTp7dGl0bGU6XCJTYXZlIGNoYW5nZXNcIix0ZXh0OlwiU2F2ZVwifSxjYW5jZWw6e3RpdGxlOlwiQ2FuY2VsIGVkaXRpbmcsIGRpc2NhcmRzIGFsbCBjaGFuZ2VzXCIsdGV4dDpcIkNhbmNlbFwifSxjbGVhckFsbDp7dGl0bGU6XCJDbGVhciBhbGwgbGF5ZXJzXCIsdGV4dDpcIkNsZWFyIEFsbFwifX0sYnV0dG9uczp7ZWRpdDpcIkVkaXQgbGF5ZXJzXCIsZWRpdERpc2FibGVkOlwiTm8gbGF5ZXJzIHRvIGVkaXRcIixyZW1vdmU6XCJEZWxldGUgbGF5ZXJzXCIscmVtb3ZlRGlzYWJsZWQ6XCJObyBsYXllcnMgdG8gZGVsZXRlXCJ9fSxoYW5kbGVyczp7ZWRpdDp7dG9vbHRpcDp7dGV4dDpcIkRyYWcgaGFuZGxlcyBvciBtYXJrZXJzIHRvIGVkaXQgZmVhdHVyZXMuXCIsc3VidGV4dDpcIkNsaWNrIGNhbmNlbCB0byB1bmRvIGNoYW5nZXMuXCJ9fSxyZW1vdmU6e3Rvb2x0aXA6e3RleHQ6XCJDbGljayBvbiBhIGZlYXR1cmUgdG8gcmVtb3ZlLlwifX19fX0sTC5EcmF3LkV2ZW50PXt9LEwuRHJhdy5FdmVudC5DUkVBVEVEPVwiZHJhdzpjcmVhdGVkXCIsTC5EcmF3LkV2ZW50LkVESVRFRD1cImRyYXc6ZWRpdGVkXCIsTC5EcmF3LkV2ZW50LkRFTEVURUQ9XCJkcmF3OmRlbGV0ZWRcIixMLkRyYXcuRXZlbnQuRFJBV1NUQVJUPVwiZHJhdzpkcmF3c3RhcnRcIixMLkRyYXcuRXZlbnQuRFJBV1NUT1A9XCJkcmF3OmRyYXdzdG9wXCIsTC5EcmF3LkV2ZW50LkRSQVdWRVJURVg9XCJkcmF3OmRyYXd2ZXJ0ZXhcIixMLkRyYXcuRXZlbnQuRURJVFNUQVJUPVwiZHJhdzplZGl0c3RhcnRcIixMLkRyYXcuRXZlbnQuRURJVE1PVkU9XCJkcmF3OmVkaXRtb3ZlXCIsTC5EcmF3LkV2ZW50LkVESVRSRVNJWkU9XCJkcmF3OmVkaXRyZXNpemVcIixMLkRyYXcuRXZlbnQuRURJVFZFUlRFWD1cImRyYXc6ZWRpdHZlcnRleFwiLEwuRHJhdy5FdmVudC5FRElUU1RPUD1cImRyYXc6ZWRpdHN0b3BcIixMLkRyYXcuRXZlbnQuREVMRVRFU1RBUlQ9XCJkcmF3OmRlbGV0ZXN0YXJ0XCIsTC5EcmF3LkV2ZW50LkRFTEVURVNUT1A9XCJkcmF3OmRlbGV0ZXN0b3BcIixMLkRyYXcuRXZlbnQuVE9PTEJBUk9QRU5FRD1cImRyYXc6dG9vbGJhcm9wZW5lZFwiLEwuRHJhdy5FdmVudC5UT09MQkFSQ0xPU0VEPVwiZHJhdzp0b29sYmFyY2xvc2VkXCIsTC5EcmF3LkV2ZW50Lk1BUktFUkNPTlRFWFQ9XCJkcmF3Om1hcmtlcmNvbnRleHRcIixMLkRyYXc9TC5EcmF3fHx7fSxMLkRyYXcuRmVhdHVyZT1MLkhhbmRsZXIuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7dGhpcy5fbWFwPXQsdGhpcy5fY29udGFpbmVyPXQuX2NvbnRhaW5lcix0aGlzLl9vdmVybGF5UGFuZT10Ll9wYW5lcy5vdmVybGF5UGFuZSx0aGlzLl9wb3B1cFBhbmU9dC5fcGFuZXMucG9wdXBQYW5lLGUmJmUuc2hhcGVPcHRpb25zJiYoZS5zaGFwZU9wdGlvbnM9TC5VdGlsLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zLGUuc2hhcGVPcHRpb25zKSksTC5zZXRPcHRpb25zKHRoaXMsZSk7dmFyIGk9TC52ZXJzaW9uLnNwbGl0KFwiLlwiKTsxPT09cGFyc2VJbnQoaVswXSwxMCkmJnBhcnNlSW50KGlbMV0sMTApPj0yP0wuRHJhdy5GZWF0dXJlLmluY2x1ZGUoTC5FdmVudGVkLnByb3RvdHlwZSk6TC5EcmF3LkZlYXR1cmUuaW5jbHVkZShMLk1peGluLkV2ZW50cyl9LGVuYWJsZTpmdW5jdGlvbigpe3RoaXMuX2VuYWJsZWR8fChMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpLHRoaXMuZmlyZShcImVuYWJsZWRcIix7aGFuZGxlcjp0aGlzLnR5cGV9KSx0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRFJBV1NUQVJULHtsYXllclR5cGU6dGhpcy50eXBlfSkpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dGhpcy5fZW5hYmxlZCYmKEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5EUkFXU1RPUCx7bGF5ZXJUeXBlOnRoaXMudHlwZX0pLHRoaXMuZmlyZShcImRpc2FibGVkXCIse2hhbmRsZXI6dGhpcy50eXBlfSkpfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcDt0JiYoTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCksdC5nZXRDb250YWluZXIoKS5mb2N1cygpLHRoaXMuX3Rvb2x0aXA9bmV3IEwuRHJhdy5Ub29sdGlwKHRoaXMuX21hcCksTC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsXCJrZXl1cFwiLHRoaXMuX2NhbmNlbERyYXdpbmcsdGhpcykpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX21hcCYmKEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCksdGhpcy5fdG9vbHRpcC5kaXNwb3NlKCksdGhpcy5fdG9vbHRpcD1udWxsLEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcImtleXVwXCIsdGhpcy5fY2FuY2VsRHJhd2luZyx0aGlzKSl9LHNldE9wdGlvbnM6ZnVuY3Rpb24odCl7TC5zZXRPcHRpb25zKHRoaXMsdCl9LF9maXJlQ3JlYXRlZEV2ZW50OmZ1bmN0aW9uKHQpe3RoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5DUkVBVEVELHtsYXllcjp0LGxheWVyVHlwZTp0aGlzLnR5cGV9KX0sX2NhbmNlbERyYXdpbmc6ZnVuY3Rpb24odCl7Mjc9PT10LmtleUNvZGUmJih0aGlzLl9tYXAuZmlyZShcImRyYXc6Y2FuY2VsZWRcIix7bGF5ZXJUeXBlOnRoaXMudHlwZX0pLHRoaXMuZGlzYWJsZSgpKX19KSxMLkRyYXcuUG9seWxpbmU9TC5EcmF3LkZlYXR1cmUuZXh0ZW5kKHtzdGF0aWNzOntUWVBFOlwicG9seWxpbmVcIn0sUG9seTpMLlBvbHlsaW5lLG9wdGlvbnM6e2FsbG93SW50ZXJzZWN0aW9uOiEwLHJlcGVhdE1vZGU6ITEsZHJhd0Vycm9yOntjb2xvcjpcIiNiMDBiMDBcIix0aW1lb3V0OjI1MDB9LGljb246bmV3IEwuRGl2SWNvbih7aWNvblNpemU6bmV3IEwuUG9pbnQoOCw4KSxjbGFzc05hbWU6XCJsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uXCJ9KSx0b3VjaEljb246bmV3IEwuRGl2SWNvbih7aWNvblNpemU6bmV3IEwuUG9pbnQoMjAsMjApLGNsYXNzTmFtZTpcImxlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC10b3VjaC1pY29uXCJ9KSxndWlkZWxpbmVEaXN0YW5jZToyMCxtYXhHdWlkZUxpbmVMZW5ndGg6NGUzLHNoYXBlT3B0aW9uczp7c3Ryb2tlOiEwLGNvbG9yOlwiIzMzODhmZlwiLHdlaWdodDo0LG9wYWNpdHk6LjUsZmlsbDohMSxjbGlja2FibGU6ITB9LG1ldHJpYzohMCxmZWV0OiEwLG5hdXRpYzohMSxzaG93TGVuZ3RoOiEwLHpJbmRleE9mZnNldDoyZTMsZmFjdG9yOjEsbWF4UG9pbnRzOjB9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxlKXtMLkJyb3dzZXIudG91Y2gmJih0aGlzLm9wdGlvbnMuaWNvbj10aGlzLm9wdGlvbnMudG91Y2hJY29uKSx0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2U9TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS5lcnJvcixlJiZlLmRyYXdFcnJvciYmKGUuZHJhd0Vycm9yPUwuVXRpbC5leHRlbmQoe30sdGhpcy5vcHRpb25zLmRyYXdFcnJvcixlLmRyYXdFcnJvcikpLHRoaXMudHlwZT1MLkRyYXcuUG9seWxpbmUuVFlQRSxMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdCxlKX0sYWRkSG9va3M6ZnVuY3Rpb24oKXtMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuYWRkSG9va3MuY2FsbCh0aGlzKSx0aGlzLl9tYXAmJih0aGlzLl9tYXJrZXJzPVtdLHRoaXMuX21hcmtlckdyb3VwPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKSx0aGlzLl9wb2x5PW5ldyBMLlBvbHlsaW5lKFtdLHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpLHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKSx0aGlzLl9tb3VzZU1hcmtlcnx8KHRoaXMuX21vdXNlTWFya2VyPUwubWFya2VyKHRoaXMuX21hcC5nZXRDZW50ZXIoKSx7aWNvbjpMLmRpdkljb24oe2NsYXNzTmFtZTpcImxlYWZsZXQtbW91c2UtbWFya2VyXCIsaWNvbkFuY2hvcjpbMjAsMjBdLGljb25TaXplOls0MCw0MF19KSxvcGFjaXR5OjAsekluZGV4T2Zmc2V0OnRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXR9KSksdGhpcy5fbW91c2VNYXJrZXIub24oXCJtb3VzZW91dFwiLHRoaXMuX29uTW91c2VPdXQsdGhpcykub24oXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vbihcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpLm9uKFwibW91c2V1cFwiLHRoaXMuX29uTW91c2VVcCx0aGlzKS5hZGRUbyh0aGlzLl9tYXApLHRoaXMuX21hcC5vbihcIm1vdXNldXBcIix0aGlzLl9vbk1vdXNlVXAsdGhpcykub24oXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vbihcInpvb21sZXZlbHNjaGFuZ2VcIix0aGlzLl9vblpvb21FbmQsdGhpcykub24oXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Ub3VjaCx0aGlzKS5vbihcInpvb21lbmRcIix0aGlzLl9vblpvb21FbmQsdGhpcykpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe0wuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5yZW1vdmVIb29rcy5jYWxsKHRoaXMpLHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpLHRoaXMuX2NsZWFuVXBTaGFwZSgpLHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXJHcm91cCksZGVsZXRlIHRoaXMuX21hcmtlckdyb3VwLGRlbGV0ZSB0aGlzLl9tYXJrZXJzLHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9wb2x5KSxkZWxldGUgdGhpcy5fcG9seSx0aGlzLl9tb3VzZU1hcmtlci5vZmYoXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93bix0aGlzKS5vZmYoXCJtb3VzZW91dFwiLHRoaXMuX29uTW91c2VPdXQsdGhpcykub2ZmKFwibW91c2V1cFwiLHRoaXMuX29uTW91c2VVcCx0aGlzKS5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKSx0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbW91c2VNYXJrZXIpLGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcix0aGlzLl9jbGVhckd1aWRlcygpLHRoaXMuX21hcC5vZmYoXCJtb3VzZXVwXCIsdGhpcy5fb25Nb3VzZVVwLHRoaXMpLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLm9mZihcInpvb21sZXZlbHNjaGFuZ2VcIix0aGlzLl9vblpvb21FbmQsdGhpcykub2ZmKFwiem9vbWVuZFwiLHRoaXMuX29uWm9vbUVuZCx0aGlzKS5vZmYoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Ub3VjaCx0aGlzKS5vZmYoXCJjbGlja1wiLHRoaXMuX29uVG91Y2gsdGhpcyl9LGRlbGV0ZUxhc3RWZXJ0ZXg6ZnVuY3Rpb24oKXtpZighKHRoaXMuX21hcmtlcnMubGVuZ3RoPD0xKSl7dmFyIHQ9dGhpcy5fbWFya2Vycy5wb3AoKSxlPXRoaXMuX3BvbHksaT1lLmdldExhdExuZ3MoKSxvPWkuc3BsaWNlKC0xLDEpWzBdO3RoaXMuX3BvbHkuc2V0TGF0TG5ncyhpKSx0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcih0KSxlLmdldExhdExuZ3MoKS5sZW5ndGg8MiYmdGhpcy5fbWFwLnJlbW92ZUxheWVyKGUpLHRoaXMuX3ZlcnRleENoYW5nZWQobywhMSl9fSxhZGRWZXJ0ZXg6ZnVuY3Rpb24odCl7aWYodGhpcy5fbWFya2Vycy5sZW5ndGg+PTImJiF0aGlzLm9wdGlvbnMuYWxsb3dJbnRlcnNlY3Rpb24mJnRoaXMuX3BvbHkubmV3TGF0TG5nSW50ZXJzZWN0cyh0KSlyZXR1cm4gdm9pZCB0aGlzLl9zaG93RXJyb3JUb29sdGlwKCk7dGhpcy5fZXJyb3JTaG93biYmdGhpcy5faGlkZUVycm9yVG9vbHRpcCgpLHRoaXMuX21hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIodCkpLHRoaXMuX3BvbHkuYWRkTGF0TG5nKHQpLDI9PT10aGlzLl9wb2x5LmdldExhdExuZ3MoKS5sZW5ndGgmJnRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9wb2x5KSx0aGlzLl92ZXJ0ZXhDaGFuZ2VkKHQsITApfSxjb21wbGV0ZVNoYXBlOmZ1bmN0aW9uKCl7dGhpcy5fbWFya2Vycy5sZW5ndGg8PTF8fCF0aGlzLl9zaGFwZUlzVmFsaWQoKXx8KHRoaXMuX2ZpcmVDcmVhdGVkRXZlbnQoKSx0aGlzLmRpc2FibGUoKSx0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSYmdGhpcy5lbmFibGUoKSl9LF9maW5pc2hTaGFwZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3BvbHkuX2RlZmF1bHRTaGFwZT90aGlzLl9wb2x5Ll9kZWZhdWx0U2hhcGUoKTp0aGlzLl9wb2x5LmdldExhdExuZ3MoKSxlPXRoaXMuX3BvbHkubmV3TGF0TG5nSW50ZXJzZWN0cyh0W3QubGVuZ3RoLTFdKTtpZighdGhpcy5vcHRpb25zLmFsbG93SW50ZXJzZWN0aW9uJiZlfHwhdGhpcy5fc2hhcGVJc1ZhbGlkKCkpcmV0dXJuIHZvaWQgdGhpcy5fc2hvd0Vycm9yVG9vbHRpcCgpO3RoaXMuX2ZpcmVDcmVhdGVkRXZlbnQoKSx0aGlzLmRpc2FibGUoKSx0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSYmdGhpcy5lbmFibGUoKX0sX3NoYXBlSXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiEwfSxfb25ab29tRW5kOmZ1bmN0aW9uKCl7bnVsbCE9PXRoaXMuX21hcmtlcnMmJnRoaXMuX3VwZGF0ZUd1aWRlKCl9LF9vbk1vdXNlTW92ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0Lm9yaWdpbmFsRXZlbnQpLGk9dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhlKTt0aGlzLl9jdXJyZW50TGF0TG5nPWksdGhpcy5fdXBkYXRlVG9vbHRpcChpKSx0aGlzLl91cGRhdGVHdWlkZShlKSx0aGlzLl9tb3VzZU1hcmtlci5zZXRMYXRMbmcoaSksTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCh0Lm9yaWdpbmFsRXZlbnQpfSxfdmVydGV4Q2hhbmdlZDpmdW5jdGlvbih0LGUpe3RoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5EUkFXVkVSVEVYLHtsYXllcnM6dGhpcy5fbWFya2VyR3JvdXB9KSx0aGlzLl91cGRhdGVGaW5pc2hIYW5kbGVyKCksdGhpcy5fdXBkYXRlUnVubmluZ01lYXN1cmUodCxlKSx0aGlzLl9jbGVhckd1aWRlcygpLHRoaXMuX3VwZGF0ZVRvb2x0aXAoKX0sX29uTW91c2VEb3duOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLl9jbGlja0hhbmRsZWQmJiF0aGlzLl90b3VjaEhhbmRsZWQmJiF0aGlzLl9kaXNhYmxlTWFya2Vycyl7dGhpcy5fb25Nb3VzZU1vdmUodCksdGhpcy5fY2xpY2tIYW5kbGVkPSEwLHRoaXMuX2Rpc2FibGVOZXdNYXJrZXJzKCk7dmFyIGU9dC5vcmlnaW5hbEV2ZW50LGk9ZS5jbGllbnRYLG89ZS5jbGllbnRZO3RoaXMuX3N0YXJ0UG9pbnQuY2FsbCh0aGlzLGksbyl9fSxfc3RhcnRQb2ludDpmdW5jdGlvbih0LGUpe3RoaXMuX21vdXNlRG93bk9yaWdpbj1MLnBvaW50KHQsZSl9LF9vbk1vdXNlVXA6ZnVuY3Rpb24odCl7dmFyIGU9dC5vcmlnaW5hbEV2ZW50LGk9ZS5jbGllbnRYLG89ZS5jbGllbnRZO3RoaXMuX2VuZFBvaW50LmNhbGwodGhpcyxpLG8sdCksdGhpcy5fY2xpY2tIYW5kbGVkPW51bGx9LF9lbmRQb2ludDpmdW5jdGlvbihlLGksbyl7aWYodGhpcy5fbW91c2VEb3duT3JpZ2luKXt2YXIgYT1MLnBvaW50KGUsaSkuZGlzdGFuY2VUbyh0aGlzLl9tb3VzZURvd25PcmlnaW4pLG49dGhpcy5fY2FsY3VsYXRlRmluaXNoRGlzdGFuY2Uoby5sYXRsbmcpO3RoaXMub3B0aW9ucy5tYXhQb2ludHM+MSYmdGhpcy5vcHRpb25zLm1heFBvaW50cz09dGhpcy5fbWFya2Vycy5sZW5ndGgrMT8odGhpcy5hZGRWZXJ0ZXgoby5sYXRsbmcpLHRoaXMuX2ZpbmlzaFNoYXBlKCkpOm48MTAmJkwuQnJvd3Nlci50b3VjaD90aGlzLl9maW5pc2hTaGFwZSgpOk1hdGguYWJzKGEpPDkqKHQuZGV2aWNlUGl4ZWxSYXRpb3x8MSkmJnRoaXMuYWRkVmVydGV4KG8ubGF0bG5nKSx0aGlzLl9lbmFibGVOZXdNYXJrZXJzKCl9dGhpcy5fbW91c2VEb3duT3JpZ2luPW51bGx9LF9vblRvdWNoOmZ1bmN0aW9uKHQpe3ZhciBlLGksbz10Lm9yaWdpbmFsRXZlbnQ7IW8udG91Y2hlc3x8IW8udG91Y2hlc1swXXx8dGhpcy5fY2xpY2tIYW5kbGVkfHx0aGlzLl90b3VjaEhhbmRsZWR8fHRoaXMuX2Rpc2FibGVNYXJrZXJzfHwoZT1vLnRvdWNoZXNbMF0uY2xpZW50WCxpPW8udG91Y2hlc1swXS5jbGllbnRZLHRoaXMuX2Rpc2FibGVOZXdNYXJrZXJzKCksdGhpcy5fdG91Y2hIYW5kbGVkPSEwLHRoaXMuX3N0YXJ0UG9pbnQuY2FsbCh0aGlzLGUsaSksdGhpcy5fZW5kUG9pbnQuY2FsbCh0aGlzLGUsaSx0KSx0aGlzLl90b3VjaEhhbmRsZWQ9bnVsbCksdGhpcy5fY2xpY2tIYW5kbGVkPW51bGx9LF9vbk1vdXNlT3V0OmZ1bmN0aW9uKCl7dGhpcy5fdG9vbHRpcCYmdGhpcy5fdG9vbHRpcC5fb25Nb3VzZU91dC5jYWxsKHRoaXMuX3Rvb2x0aXApfSxfY2FsY3VsYXRlRmluaXNoRGlzdGFuY2U6ZnVuY3Rpb24odCl7dmFyIGU7aWYodGhpcy5fbWFya2Vycy5sZW5ndGg+MCl7dmFyIGk7aWYodGhpcy50eXBlPT09TC5EcmF3LlBvbHlsaW5lLlRZUEUpaT10aGlzLl9tYXJrZXJzW3RoaXMuX21hcmtlcnMubGVuZ3RoLTFdO2Vsc2V7aWYodGhpcy50eXBlIT09TC5EcmF3LlBvbHlnb24uVFlQRSlyZXR1cm4gMS8wO2k9dGhpcy5fbWFya2Vyc1swXX12YXIgbz10aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChpLmdldExhdExuZygpKSxhPW5ldyBMLk1hcmtlcih0LHtpY29uOnRoaXMub3B0aW9ucy5pY29uLHpJbmRleE9mZnNldDoyKnRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXR9KSxuPXRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGEuZ2V0TGF0TG5nKCkpO2U9by5kaXN0YW5jZVRvKG4pfWVsc2UgZT0xLzA7cmV0dXJuIGV9LF91cGRhdGVGaW5pc2hIYW5kbGVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFya2Vycy5sZW5ndGg7dD4xJiZ0aGlzLl9tYXJrZXJzW3QtMV0ub24oXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHQ+MiYmdGhpcy5fbWFya2Vyc1t0LTJdLm9mZihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyl9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEwuTWFya2VyKHQse2ljb246dGhpcy5vcHRpb25zLmljb24sekluZGV4T2Zmc2V0OjIqdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldH0pO3JldHVybiB0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihlKSxlfSxfdXBkYXRlR3VpZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFya2Vycz90aGlzLl9tYXJrZXJzLmxlbmd0aDowO2U+MCYmKHQ9dHx8dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9jdXJyZW50TGF0TG5nKSx0aGlzLl9jbGVhckd1aWRlcygpLHRoaXMuX2RyYXdHdWlkZSh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX21hcmtlcnNbZS0xXS5nZXRMYXRMbmcoKSksdCkpfSxfdXBkYXRlVG9vbHRpcDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9nZXRUb29sdGlwVGV4dCgpO3QmJnRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24odCksdGhpcy5fZXJyb3JTaG93bnx8dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KGUpfSxfZHJhd0d1aWRlOmZ1bmN0aW9uKHQsZSl7dmFyIGksbyxhLG49TWF0aC5mbG9vcihNYXRoLnNxcnQoTWF0aC5wb3coZS54LXQueCwyKStNYXRoLnBvdyhlLnktdC55LDIpKSkscz10aGlzLm9wdGlvbnMuZ3VpZGVsaW5lRGlzdGFuY2Uscj10aGlzLm9wdGlvbnMubWF4R3VpZGVMaW5lTGVuZ3RoLGw9bj5yP24tcjpzO2Zvcih0aGlzLl9ndWlkZXNDb250YWluZXJ8fCh0aGlzLl9ndWlkZXNDb250YWluZXI9TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwibGVhZmxldC1kcmF3LWd1aWRlc1wiLHRoaXMuX292ZXJsYXlQYW5lKSk7bDxuO2wrPXRoaXMub3B0aW9ucy5ndWlkZWxpbmVEaXN0YW5jZSlpPWwvbixvPXt4Ok1hdGguZmxvb3IodC54KigxLWkpK2kqZS54KSx5Ok1hdGguZmxvb3IodC55KigxLWkpK2kqZS55KX0sYT1MLkRvbVV0aWwuY3JlYXRlKFwiZGl2XCIsXCJsZWFmbGV0LWRyYXctZ3VpZGUtZGFzaFwiLHRoaXMuX2d1aWRlc0NvbnRhaW5lciksYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy5fZXJyb3JTaG93bj90aGlzLm9wdGlvbnMuZHJhd0Vycm9yLmNvbG9yOnRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMuY29sb3IsTC5Eb21VdGlsLnNldFBvc2l0aW9uKGEsbyl9LF91cGRhdGVHdWlkZUNvbG9yOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX2d1aWRlc0NvbnRhaW5lcilmb3IodmFyIGU9MCxpPXRoaXMuX2d1aWRlc0NvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtlPGk7ZSsrKXRoaXMuX2d1aWRlc0NvbnRhaW5lci5jaGlsZE5vZGVzW2VdLnN0eWxlLmJhY2tncm91bmRDb2xvcj10fSxfY2xlYXJHdWlkZXM6ZnVuY3Rpb24oKXtpZih0aGlzLl9ndWlkZXNDb250YWluZXIpZm9yKDt0aGlzLl9ndWlkZXNDb250YWluZXIuZmlyc3RDaGlsZDspdGhpcy5fZ3VpZGVzQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2d1aWRlc0NvbnRhaW5lci5maXJzdENoaWxkKX0sX2dldFRvb2x0aXBUZXh0OmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXMub3B0aW9ucy5zaG93TGVuZ3RoO3JldHVybiAwPT09dGhpcy5fbWFya2Vycy5sZW5ndGg/dD17dGV4dDpMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLnRvb2x0aXAuc3RhcnR9OihlPWk/dGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKTpcIlwiLHQ9MT09PXRoaXMuX21hcmtlcnMubGVuZ3RoP3t0ZXh0OkwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucG9seWxpbmUudG9vbHRpcC5jb250LHN1YnRleHQ6ZX06e3RleHQ6TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLmVuZCxzdWJ0ZXh0OmV9KSx0fSxfdXBkYXRlUnVubmluZ01lYXN1cmU6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLGE9dGhpcy5fbWFya2Vycy5sZW5ndGg7MT09PXRoaXMuX21hcmtlcnMubGVuZ3RoP3RoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsPTA6KGk9YS0oZT8yOjEpLG89TC5HZW9tZXRyeVV0aWwuaXNWZXJzaW9uMDd4KCk/dC5kaXN0YW5jZVRvKHRoaXMuX21hcmtlcnNbaV0uZ2V0TGF0TG5nKCkpKih0aGlzLm9wdGlvbnMuZmFjdG9yfHwxKTp0aGlzLl9tYXAuZGlzdGFuY2UodCx0aGlzLl9tYXJrZXJzW2ldLmdldExhdExuZygpKSoodGhpcy5vcHRpb25zLmZhY3Rvcnx8MSksdGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwrPW8qKGU/MTotMSkpfSxfZ2V0TWVhc3VyZW1lbnRTdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuX2N1cnJlbnRMYXRMbmcsaT10aGlzLl9tYXJrZXJzW3RoaXMuX21hcmtlcnMubGVuZ3RoLTFdLmdldExhdExuZygpO3JldHVybiB0PUwuR2VvbWV0cnlVdGlsLmlzVmVyc2lvbjA3eCgpP2kmJmUmJmUuZGlzdGFuY2VUbz90aGlzLl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbCtlLmRpc3RhbmNlVG8oaSkqKHRoaXMub3B0aW9ucy5mYWN0b3J8fDEpOnRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsfHwwOmkmJmU/dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwrdGhpcy5fbWFwLmRpc3RhbmNlKGUsaSkqKHRoaXMub3B0aW9ucy5mYWN0b3J8fDEpOnRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsfHwwLEwuR2VvbWV0cnlVdGlsLnJlYWRhYmxlRGlzdGFuY2UodCx0aGlzLm9wdGlvbnMubWV0cmljLHRoaXMub3B0aW9ucy5mZWV0LHRoaXMub3B0aW9ucy5uYXV0aWMsdGhpcy5vcHRpb25zLnByZWNpc2lvbil9LF9zaG93RXJyb3JUb29sdGlwOmZ1bmN0aW9uKCl7dGhpcy5fZXJyb3JTaG93bj0hMCx0aGlzLl90b29sdGlwLnNob3dBc0Vycm9yKCkudXBkYXRlQ29udGVudCh7dGV4dDp0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2V9KSx0aGlzLl91cGRhdGVHdWlkZUNvbG9yKHRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3IpLHRoaXMuX3BvbHkuc2V0U3R5bGUoe2NvbG9yOnRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3J9KSx0aGlzLl9jbGVhckhpZGVFcnJvclRpbWVvdXQoKSx0aGlzLl9oaWRlRXJyb3JUaW1lb3V0PXNldFRpbWVvdXQoTC5VdGlsLmJpbmQodGhpcy5faGlkZUVycm9yVG9vbHRpcCx0aGlzKSx0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLnRpbWVvdXQpfSxfaGlkZUVycm9yVG9vbHRpcDpmdW5jdGlvbigpe3RoaXMuX2Vycm9yU2hvd249ITEsdGhpcy5fY2xlYXJIaWRlRXJyb3JUaW1lb3V0KCksdGhpcy5fdG9vbHRpcC5yZW1vdmVFcnJvcigpLnVwZGF0ZUNvbnRlbnQodGhpcy5fZ2V0VG9vbHRpcFRleHQoKSksdGhpcy5fdXBkYXRlR3VpZGVDb2xvcih0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zLmNvbG9yKSx0aGlzLl9wb2x5LnNldFN0eWxlKHtjb2xvcjp0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zLmNvbG9yfSl9LF9jbGVhckhpZGVFcnJvclRpbWVvdXQ6ZnVuY3Rpb24oKXt0aGlzLl9oaWRlRXJyb3JUaW1lb3V0JiYoY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVFcnJvclRpbWVvdXQpLHRoaXMuX2hpZGVFcnJvclRpbWVvdXQ9bnVsbCl9LF9kaXNhYmxlTmV3TWFya2VyczpmdW5jdGlvbigpe3RoaXMuX2Rpc2FibGVNYXJrZXJzPSEwfSxfZW5hYmxlTmV3TWFya2VyczpmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzLl9kaXNhYmxlTWFya2Vycz0hMX0uYmluZCh0aGlzKSw1MCl9LF9jbGVhblVwU2hhcGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXJrZXJzLmxlbmd0aD4xJiZ0aGlzLl9tYXJrZXJzW3RoaXMuX21hcmtlcnMubGVuZ3RoLTFdLm9mZihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyl9LF9maXJlQ3JlYXRlZEV2ZW50OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IHRoaXMuUG9seSh0aGlzLl9wb2x5LmdldExhdExuZ3MoKSx0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLHQpfX0pLEwuRHJhdy5Qb2x5Z29uPUwuRHJhdy5Qb2x5bGluZS5leHRlbmQoe3N0YXRpY3M6e1RZUEU6XCJwb2x5Z29uXCJ9LFBvbHk6TC5Qb2x5Z29uLG9wdGlvbnM6e3Nob3dBcmVhOiExLHNob3dMZW5ndGg6ITEsc2hhcGVPcHRpb25zOntzdHJva2U6ITAsY29sb3I6XCIjMzM4OGZmXCIsd2VpZ2h0OjQsb3BhY2l0eTouNSxmaWxsOiEwLGZpbGxDb2xvcjpudWxsLGZpbGxPcGFjaXR5Oi4yLGNsaWNrYWJsZTohMH0sbWV0cmljOiEwLGZlZXQ6ITAsbmF1dGljOiExLHByZWNpc2lvbjp7fX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe0wuRHJhdy5Qb2x5bGluZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdCxlKSx0aGlzLnR5cGU9TC5EcmF3LlBvbHlnb24uVFlQRX0sX3VwZGF0ZUZpbmlzaEhhbmRsZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXJrZXJzLmxlbmd0aDsxPT09dCYmdGhpcy5fbWFya2Vyc1swXS5vbihcImNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcyksdD4yJiYodGhpcy5fbWFya2Vyc1t0LTFdLm9uKFwiZGJsY2xpY2tcIix0aGlzLl9maW5pc2hTaGFwZSx0aGlzKSx0PjMmJnRoaXMuX21hcmtlcnNbdC0yXS5vZmYoXCJkYmxjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpKX0sX2dldFRvb2x0aXBUZXh0OmZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gMD09PXRoaXMuX21hcmtlcnMubGVuZ3RoP3Q9TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5Z29uLnRvb2x0aXAuc3RhcnQ6dGhpcy5fbWFya2Vycy5sZW5ndGg8Mz8odD1MLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5jb250LGU9dGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKSk6KHQ9TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5Z29uLnRvb2x0aXAuZW5kLGU9dGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKSkse3RleHQ6dCxzdWJ0ZXh0OmV9fSxfZ2V0TWVhc3VyZW1lbnRTdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9hcmVhLGU9XCJcIjtyZXR1cm4gdHx8dGhpcy5vcHRpb25zLnNob3dMZW5ndGg/KHRoaXMub3B0aW9ucy5zaG93TGVuZ3RoJiYoZT1MLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLl9nZXRNZWFzdXJlbWVudFN0cmluZy5jYWxsKHRoaXMpKSx0JiYoZSs9XCI8YnI+XCIrTC5HZW9tZXRyeVV0aWwucmVhZGFibGVBcmVhKHQsdGhpcy5vcHRpb25zLm1ldHJpYyx0aGlzLm9wdGlvbnMucHJlY2lzaW9uKSksZSk6bnVsbH0sX3NoYXBlSXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXJrZXJzLmxlbmd0aD49M30sX3ZlcnRleENoYW5nZWQ6ZnVuY3Rpb24odCxlKXt2YXIgaTshdGhpcy5vcHRpb25zLmFsbG93SW50ZXJzZWN0aW9uJiZ0aGlzLm9wdGlvbnMuc2hvd0FyZWEmJihpPXRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLHRoaXMuX2FyZWE9TC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKGkpKSxMLkRyYXcuUG9seWxpbmUucHJvdG90eXBlLl92ZXJ0ZXhDaGFuZ2VkLmNhbGwodGhpcyx0LGUpfSxfY2xlYW5VcFNoYXBlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFya2Vycy5sZW5ndGg7dD4wJiYodGhpcy5fbWFya2Vyc1swXS5vZmYoXCJjbGlja1wiLHRoaXMuX2ZpbmlzaFNoYXBlLHRoaXMpLHQ+MiYmdGhpcy5fbWFya2Vyc1t0LTFdLm9mZihcImRibGNsaWNrXCIsdGhpcy5fZmluaXNoU2hhcGUsdGhpcykpfX0pLEwuU2ltcGxlU2hhcGU9e30sTC5EcmF3LlNpbXBsZVNoYXBlPUwuRHJhdy5GZWF0dXJlLmV4dGVuZCh7b3B0aW9uczp7cmVwZWF0TW9kZTohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMuX2VuZExhYmVsVGV4dD1MLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnNpbXBsZXNoYXBlLnRvb2x0aXAuZW5kLEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyx0LGUpfSxhZGRIb29rczpmdW5jdGlvbigpe0wuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpLHRoaXMuX21hcCYmKHRoaXMuX21hcERyYWdnYWJsZT10aGlzLl9tYXAuZHJhZ2dpbmcuZW5hYmxlZCgpLHRoaXMuX21hcERyYWdnYWJsZSYmdGhpcy5fbWFwLmRyYWdnaW5nLmRpc2FibGUoKSx0aGlzLl9jb250YWluZXIuc3R5bGUuY3Vyc29yPVwiY3Jvc3NoYWlyXCIsdGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHt0ZXh0OnRoaXMuX2luaXRpYWxMYWJlbFRleHR9KSx0aGlzLl9tYXAub24oXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93bix0aGlzKS5vbihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLm9uKFwidG91Y2hzdGFydFwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpLm9uKFwidG91Y2htb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUsdGhpcyksZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQse3Bhc3NpdmU6ITF9KSl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLnJlbW92ZUhvb2tzLmNhbGwodGhpcyksdGhpcy5fbWFwJiYodGhpcy5fbWFwRHJhZ2dhYmxlJiZ0aGlzLl9tYXAuZHJhZ2dpbmcuZW5hYmxlKCksdGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvcj1cIlwiLHRoaXMuX21hcC5vZmYoXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93bix0aGlzKS5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vZmYoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Nb3VzZURvd24sdGhpcykub2ZmKFwidG91Y2htb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUsdGhpcyksTC5Eb21FdmVudC5vZmYoZSxcIm1vdXNldXBcIix0aGlzLl9vbk1vdXNlVXAsdGhpcyksTC5Eb21FdmVudC5vZmYoZSxcInRvdWNoZW5kXCIsdGhpcy5fb25Nb3VzZVVwLHRoaXMpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KSx0aGlzLl9zaGFwZSYmKHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9zaGFwZSksZGVsZXRlIHRoaXMuX3NoYXBlKSksdGhpcy5faXNEcmF3aW5nPSExfSxfZ2V0VG9vbHRpcFRleHQ6ZnVuY3Rpb24oKXtyZXR1cm57dGV4dDp0aGlzLl9lbmRMYWJlbFRleHR9fSxfb25Nb3VzZURvd246ZnVuY3Rpb24odCl7dGhpcy5faXNEcmF3aW5nPSEwLHRoaXMuX3N0YXJ0TGF0TG5nPXQubGF0bG5nLEwuRG9tRXZlbnQub24oZSxcIm1vdXNldXBcIix0aGlzLl9vbk1vdXNlVXAsdGhpcykub24oZSxcInRvdWNoZW5kXCIsdGhpcy5fb25Nb3VzZVVwLHRoaXMpLnByZXZlbnREZWZhdWx0KHQub3JpZ2luYWxFdmVudCl9LF9vbk1vdXNlTW92ZTpmdW5jdGlvbih0KXt2YXIgZT10LmxhdGxuZzt0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGUpLHRoaXMuX2lzRHJhd2luZyYmKHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKSx0aGlzLl9kcmF3U2hhcGUoZSkpfSxfb25Nb3VzZVVwOmZ1bmN0aW9uKCl7dGhpcy5fc2hhcGUmJnRoaXMuX2ZpcmVDcmVhdGVkRXZlbnQoKSx0aGlzLmRpc2FibGUoKSx0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSYmdGhpcy5lbmFibGUoKX19KSxMLkRyYXcuUmVjdGFuZ2xlPUwuRHJhdy5TaW1wbGVTaGFwZS5leHRlbmQoe3N0YXRpY3M6e1RZUEU6XCJyZWN0YW5nbGVcIn0sb3B0aW9uczp7c2hhcGVPcHRpb25zOntzdHJva2U6ITAsY29sb3I6XCIjMzM4OGZmXCIsd2VpZ2h0OjQsb3BhY2l0eTouNSxmaWxsOiEwLGZpbGxDb2xvcjpudWxsLGZpbGxPcGFjaXR5Oi4yLGNsaWNrYWJsZTohMH0sc2hvd0FyZWE6ITAsbWV0cmljOiEwfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7dGhpcy50eXBlPUwuRHJhdy5SZWN0YW5nbGUuVFlQRSx0aGlzLl9pbml0aWFsTGFiZWxUZXh0PUwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucmVjdGFuZ2xlLnRvb2x0aXAuc3RhcnQsTC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyx0LGUpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dGhpcy5fZW5hYmxlZCYmKHRoaXMuX2lzQ3VycmVudGx5VHdvQ2xpY2tEcmF3aW5nPSExLEwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpKX0sX29uTW91c2VVcDpmdW5jdGlvbih0KXtpZighdGhpcy5fc2hhcGUmJiF0aGlzLl9pc0N1cnJlbnRseVR3b0NsaWNrRHJhd2luZylyZXR1cm4gdm9pZCh0aGlzLl9pc0N1cnJlbnRseVR3b0NsaWNrRHJhd2luZz0hMCk7dGhpcy5faXNDdXJyZW50bHlUd29DbGlja0RyYXdpbmcmJiFvKHQudGFyZ2V0LFwibGVhZmxldC1wYW5lXCIpfHxMLkRyYXcuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9vbk1vdXNlVXAuY2FsbCh0aGlzKX0sX2RyYXdTaGFwZTpmdW5jdGlvbih0KXt0aGlzLl9zaGFwZT90aGlzLl9zaGFwZS5zZXRCb3VuZHMobmV3IEwuTGF0TG5nQm91bmRzKHRoaXMuX3N0YXJ0TGF0TG5nLHQpKToodGhpcy5fc2hhcGU9bmV3IEwuUmVjdGFuZ2xlKG5ldyBMLkxhdExuZ0JvdW5kcyh0aGlzLl9zdGFydExhdExuZyx0KSx0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKSx0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fc2hhcGUpKX0sX2ZpcmVDcmVhdGVkRXZlbnQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgTC5SZWN0YW5nbGUodGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCksdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fZmlyZUNyZWF0ZWRFdmVudC5jYWxsKHRoaXMsdCl9LF9nZXRUb29sdGlwVGV4dDpmdW5jdGlvbigpe3ZhciB0LGUsaSxvPUwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX2dldFRvb2x0aXBUZXh0LmNhbGwodGhpcyksYT10aGlzLl9zaGFwZSxuPXRoaXMub3B0aW9ucy5zaG93QXJlYTtyZXR1cm4gYSYmKHQ9dGhpcy5fc2hhcGUuX2RlZmF1bHRTaGFwZT90aGlzLl9zaGFwZS5fZGVmYXVsdFNoYXBlKCk6dGhpcy5fc2hhcGUuZ2V0TGF0TG5ncygpLGU9TC5HZW9tZXRyeVV0aWwuZ2VvZGVzaWNBcmVhKHQpLGk9bj9MLkdlb21ldHJ5VXRpbC5yZWFkYWJsZUFyZWEoZSx0aGlzLm9wdGlvbnMubWV0cmljKTpcIlwiKSx7dGV4dDpvLnRleHQsc3VidGV4dDppfX19KSxMLkRyYXcuTWFya2VyPUwuRHJhdy5GZWF0dXJlLmV4dGVuZCh7c3RhdGljczp7VFlQRTpcIm1hcmtlclwifSxvcHRpb25zOntpY29uOm5ldyBMLkljb24uRGVmYXVsdCxyZXBlYXRNb2RlOiExLHpJbmRleE9mZnNldDoyZTN9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxlKXt0aGlzLnR5cGU9TC5EcmF3Lk1hcmtlci5UWVBFLHRoaXMuX2luaXRpYWxMYWJlbFRleHQ9TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5tYXJrZXIudG9vbHRpcC5zdGFydCxMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdCxlKX0sYWRkSG9va3M6ZnVuY3Rpb24oKXtMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuYWRkSG9va3MuY2FsbCh0aGlzKSx0aGlzLl9tYXAmJih0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6dGhpcy5faW5pdGlhbExhYmVsVGV4dH0pLHRoaXMuX21vdXNlTWFya2VyfHwodGhpcy5fbW91c2VNYXJrZXI9TC5tYXJrZXIodGhpcy5fbWFwLmdldENlbnRlcigpLHtpY29uOkwuZGl2SWNvbih7Y2xhc3NOYW1lOlwibGVhZmxldC1tb3VzZS1tYXJrZXJcIixpY29uQW5jaG9yOlsyMCwyMF0saWNvblNpemU6WzQwLDQwXX0pLG9wYWNpdHk6MCx6SW5kZXhPZmZzZXQ6dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldH0pKSx0aGlzLl9tb3VzZU1hcmtlci5vbihcImNsaWNrXCIsdGhpcy5fb25DbGljayx0aGlzKS5hZGRUbyh0aGlzLl9tYXApLHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLHRoaXMuX21hcC5vbihcImNsaWNrXCIsdGhpcy5fb25Ub3VjaCx0aGlzKSl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLnJlbW92ZUhvb2tzLmNhbGwodGhpcyksdGhpcy5fbWFwJiYodGhpcy5fbWFwLm9mZihcImNsaWNrXCIsdGhpcy5fb25DbGljayx0aGlzKS5vZmYoXCJjbGlja1wiLHRoaXMuX29uVG91Y2gsdGhpcyksdGhpcy5fbWFya2VyJiYodGhpcy5fbWFya2VyLm9mZihcImNsaWNrXCIsdGhpcy5fb25DbGljayx0aGlzKSx0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyKSxkZWxldGUgdGhpcy5fbWFya2VyKSx0aGlzLl9tb3VzZU1hcmtlci5vZmYoXCJjbGlja1wiLHRoaXMuX29uQ2xpY2ssdGhpcyksdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21vdXNlTWFya2VyKSxkZWxldGUgdGhpcy5fbW91c2VNYXJrZXIsdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpKX0sX29uTW91c2VNb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlPXQubGF0bG5nO3RoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24oZSksdGhpcy5fbW91c2VNYXJrZXIuc2V0TGF0TG5nKGUpLHRoaXMuX21hcmtlcj8oZT10aGlzLl9tb3VzZU1hcmtlci5nZXRMYXRMbmcoKSx0aGlzLl9tYXJrZXIuc2V0TGF0TG5nKGUpKToodGhpcy5fbWFya2VyPXRoaXMuX2NyZWF0ZU1hcmtlcihlKSx0aGlzLl9tYXJrZXIub24oXCJjbGlja1wiLHRoaXMuX29uQ2xpY2ssdGhpcyksdGhpcy5fbWFwLm9uKFwiY2xpY2tcIix0aGlzLl9vbkNsaWNrLHRoaXMpLmFkZExheWVyKHRoaXMuX21hcmtlcikpfSxfY3JlYXRlTWFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTC5NYXJrZXIodCx7aWNvbjp0aGlzLm9wdGlvbnMuaWNvbix6SW5kZXhPZmZzZXQ6dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldH0pfSxfb25DbGljazpmdW5jdGlvbigpe3RoaXMuX2ZpcmVDcmVhdGVkRXZlbnQoKSx0aGlzLmRpc2FibGUoKSx0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSYmdGhpcy5lbmFibGUoKX0sX29uVG91Y2g6ZnVuY3Rpb24odCl7dGhpcy5fb25Nb3VzZU1vdmUodCksdGhpcy5fb25DbGljaygpfSxfZmlyZUNyZWF0ZWRFdmVudDpmdW5jdGlvbigpe3ZhciB0PW5ldyBMLk1hcmtlci5Ub3VjaCh0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCkse2ljb246dGhpcy5vcHRpb25zLmljb259KTtMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLHQpfX0pLEwuRHJhdy5DaXJjbGVNYXJrZXI9TC5EcmF3Lk1hcmtlci5leHRlbmQoe3N0YXRpY3M6e1RZUEU6XCJjaXJjbGVtYXJrZXJcIn0sb3B0aW9uczp7c3Ryb2tlOiEwLGNvbG9yOlwiIzMzODhmZlwiLHdlaWdodDo0LG9wYWNpdHk6LjUsZmlsbDohMCxmaWxsQ29sb3I6bnVsbCxmaWxsT3BhY2l0eTouMixjbGlja2FibGU6ITAsekluZGV4T2Zmc2V0OjJlM30saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMudHlwZT1MLkRyYXcuQ2lyY2xlTWFya2VyLlRZUEUsdGhpcy5faW5pdGlhbExhYmVsVGV4dD1MLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZW1hcmtlci50b29sdGlwLnN0YXJ0LEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyx0LGUpfSxfZmlyZUNyZWF0ZWRFdmVudDpmdW5jdGlvbigpe3ZhciB0PW5ldyBMLkNpcmNsZU1hcmtlcih0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCksdGhpcy5vcHRpb25zKTtMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLHQpfSxfY3JlYXRlTWFya2VyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTC5DaXJjbGVNYXJrZXIodCx0aGlzLm9wdGlvbnMpfX0pLEwuRHJhdy5DaXJjbGU9TC5EcmF3LlNpbXBsZVNoYXBlLmV4dGVuZCh7c3RhdGljczp7VFlQRTpcImNpcmNsZVwifSxvcHRpb25zOntzaGFwZU9wdGlvbnM6e3N0cm9rZTohMCxjb2xvcjpcIiMzMzg4ZmZcIix3ZWlnaHQ6NCxvcGFjaXR5Oi41LGZpbGw6ITAsZmlsbENvbG9yOm51bGwsZmlsbE9wYWNpdHk6LjIsY2xpY2thYmxlOiEwfSxzaG93UmFkaXVzOiEwLG1ldHJpYzohMCxmZWV0OiEwLG5hdXRpYzohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMudHlwZT1MLkRyYXcuQ2lyY2xlLlRZUEUsdGhpcy5faW5pdGlhbExhYmVsVGV4dD1MLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZS50b29sdGlwLnN0YXJ0LEwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdCxlKX0sX2RyYXdTaGFwZTpmdW5jdGlvbih0KXtpZihMLkdlb21ldHJ5VXRpbC5pc1ZlcnNpb24wN3goKSl2YXIgZT10aGlzLl9zdGFydExhdExuZy5kaXN0YW5jZVRvKHQpO2Vsc2UgdmFyIGU9dGhpcy5fbWFwLmRpc3RhbmNlKHRoaXMuX3N0YXJ0TGF0TG5nLHQpO3RoaXMuX3NoYXBlP3RoaXMuX3NoYXBlLnNldFJhZGl1cyhlKToodGhpcy5fc2hhcGU9bmV3IEwuQ2lyY2xlKHRoaXMuX3N0YXJ0TGF0TG5nLGUsdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyksdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3NoYXBlKSl9LF9maXJlQ3JlYXRlZEV2ZW50OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEwuQ2lyY2xlKHRoaXMuX3N0YXJ0TGF0TG5nLHRoaXMuX3NoYXBlLmdldFJhZGl1cygpLHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO0wuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLHQpfSxfb25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7dmFyIGUsaT10LmxhdGxuZyxvPXRoaXMub3B0aW9ucy5zaG93UmFkaXVzLGE9dGhpcy5vcHRpb25zLm1ldHJpYztpZih0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGkpLHRoaXMuX2lzRHJhd2luZyl7dGhpcy5fZHJhd1NoYXBlKGkpLGU9dGhpcy5fc2hhcGUuZ2V0UmFkaXVzKCkudG9GaXhlZCgxKTt2YXIgbj1cIlwiO28mJihuPUwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuY2lyY2xlLnJhZGl1cytcIjogXCIrTC5HZW9tZXRyeVV0aWwucmVhZGFibGVEaXN0YW5jZShlLGEsdGhpcy5vcHRpb25zLmZlZXQsdGhpcy5vcHRpb25zLm5hdXRpYykpLHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7dGV4dDp0aGlzLl9lbmRMYWJlbFRleHQsc3VidGV4dDpufSl9fX0pLEwuRWRpdD1MLkVkaXR8fHt9LEwuRWRpdC5NYXJrZXI9TC5IYW5kbGVyLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMuX21hcmtlcj10LEwuc2V0T3B0aW9ucyh0aGlzLGUpfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcmtlcjt0LmRyYWdnaW5nLmVuYWJsZSgpLHQub24oXCJkcmFnZW5kXCIsdGhpcy5fb25EcmFnRW5kLHQpLHRoaXMuX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCgpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcmtlcjt0LmRyYWdnaW5nLmRpc2FibGUoKSx0Lm9mZihcImRyYWdlbmRcIix0aGlzLl9vbkRyYWdFbmQsdCksdGhpcy5fdG9nZ2xlTWFya2VySGlnaGxpZ2h0KCl9LF9vbkRyYWdFbmQ6ZnVuY3Rpb24odCl7dmFyIGU9dC50YXJnZXQ7ZS5lZGl0ZWQ9ITAsdGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRNT1ZFLHtsYXllcjplfSl9LF90b2dnbGVNYXJrZXJIaWdobGlnaHQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXJrZXIuX2ljb247dCYmKHQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixMLkRvbVV0aWwuaGFzQ2xhc3ModCxcImxlYWZsZXQtZWRpdC1tYXJrZXItc2VsZWN0ZWRcIik/KEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0LFwibGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZFwiKSx0aGlzLl9vZmZzZXRNYXJrZXIodCwtNCkpOihMLkRvbVV0aWwuYWRkQ2xhc3ModCxcImxlYWZsZXQtZWRpdC1tYXJrZXItc2VsZWN0ZWRcIiksdGhpcy5fb2Zmc2V0TWFya2VyKHQsNCkpLHQuc3R5bGUuZGlzcGxheT1cIlwiKX0sX29mZnNldE1hcmtlcjpmdW5jdGlvbih0LGUpe3ZhciBpPXBhcnNlSW50KHQuc3R5bGUubWFyZ2luVG9wLDEwKS1lLG89cGFyc2VJbnQodC5zdHlsZS5tYXJnaW5MZWZ0LDEwKS1lO3Quc3R5bGUubWFyZ2luVG9wPWkrXCJweFwiLHQuc3R5bGUubWFyZ2luTGVmdD1vK1wicHhcIn19KSxMLk1hcmtlci5hZGRJbml0SG9vayhmdW5jdGlvbigpe0wuRWRpdC5NYXJrZXImJih0aGlzLmVkaXRpbmc9bmV3IEwuRWRpdC5NYXJrZXIodGhpcyksdGhpcy5vcHRpb25zLmVkaXRhYmxlJiZ0aGlzLmVkaXRpbmcuZW5hYmxlKCkpfSksTC5FZGl0PUwuRWRpdHx8e30sTC5FZGl0LlBvbHk9TC5IYW5kbGVyLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLmxhdGxuZ3M9W3QuX2xhdGxuZ3NdLHQuX2hvbGVzJiYodGhpcy5sYXRsbmdzPXRoaXMubGF0bG5ncy5jb25jYXQodC5faG9sZXMpKSx0aGlzLl9wb2x5PXQsdGhpcy5fcG9seS5vbihcInJldmVydC1lZGl0ZWRcIix0aGlzLl91cGRhdGVMYXRMbmdzLHRoaXMpfSxfZGVmYXVsdFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQ/TC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9wb2x5Ll9sYXRsbmdzKT90aGlzLl9wb2x5Ll9sYXRsbmdzOnRoaXMuX3BvbHkuX2xhdGxuZ3NbMF06dGhpcy5fcG9seS5fbGF0bG5nc30sX2VhY2hWZXJ0ZXhIYW5kbGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5fdmVydGljZXNIYW5kbGVycy5sZW5ndGg7ZSsrKXQodGhpcy5fdmVydGljZXNIYW5kbGVyc1tlXSl9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dGhpcy5faW5pdEhhbmRsZXJzKCksdGhpcy5fZWFjaFZlcnRleEhhbmRsZXIoZnVuY3Rpb24odCl7dC5hZGRIb29rcygpfSl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7dGhpcy5fZWFjaFZlcnRleEhhbmRsZXIoZnVuY3Rpb24odCl7dC5yZW1vdmVIb29rcygpfSl9LHVwZGF0ZU1hcmtlcnM6ZnVuY3Rpb24oKXt0aGlzLl9lYWNoVmVydGV4SGFuZGxlcihmdW5jdGlvbih0KXt0LnVwZGF0ZU1hcmtlcnMoKX0pfSxfaW5pdEhhbmRsZXJzOmZ1bmN0aW9uKCl7dGhpcy5fdmVydGljZXNIYW5kbGVycz1bXTtmb3IodmFyIHQ9MDt0PHRoaXMubGF0bG5ncy5sZW5ndGg7dCsrKXRoaXMuX3ZlcnRpY2VzSGFuZGxlcnMucHVzaChuZXcgTC5FZGl0LlBvbHlWZXJ0aWNlc0VkaXQodGhpcy5fcG9seSx0aGlzLmxhdGxuZ3NbdF0sdGhpcy5fcG9seS5vcHRpb25zLnBvbHkpKX0sX3VwZGF0ZUxhdExuZ3M6ZnVuY3Rpb24odCl7dGhpcy5sYXRsbmdzPVt0LmxheWVyLl9sYXRsbmdzXSx0LmxheWVyLl9ob2xlcyYmKHRoaXMubGF0bG5ncz10aGlzLmxhdGxuZ3MuY29uY2F0KHQubGF5ZXIuX2hvbGVzKSl9fSksTC5FZGl0LlBvbHlWZXJ0aWNlc0VkaXQ9TC5IYW5kbGVyLmV4dGVuZCh7b3B0aW9uczp7aWNvbjpuZXcgTC5EaXZJY29uKHtpY29uU2l6ZTpuZXcgTC5Qb2ludCg4LDgpLGNsYXNzTmFtZTpcImxlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb25cIn0pLHRvdWNoSWNvbjpuZXcgTC5EaXZJY29uKHtpY29uU2l6ZTpuZXcgTC5Qb2ludCgyMCwyMCksY2xhc3NOYW1lOlwibGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LXRvdWNoLWljb25cIn0pLGRyYXdFcnJvcjp7Y29sb3I6XCIjYjAwYjAwXCIsdGltZW91dDoxZTN9fSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSxpKXtMLkJyb3dzZXIudG91Y2gmJih0aGlzLm9wdGlvbnMuaWNvbj10aGlzLm9wdGlvbnMudG91Y2hJY29uKSx0aGlzLl9wb2x5PXQsaSYmaS5kcmF3RXJyb3ImJihpLmRyYXdFcnJvcj1MLlV0aWwuZXh0ZW5kKHt9LHRoaXMub3B0aW9ucy5kcmF3RXJyb3IsaS5kcmF3RXJyb3IpKSx0aGlzLl9sYXRsbmdzPWUsTC5zZXRPcHRpb25zKHRoaXMsaSl9LF9kZWZhdWx0U2hhcGU6ZnVuY3Rpb24oKXtyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdD9MLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpP3RoaXMuX2xhdGxuZ3M6dGhpcy5fbGF0bG5nc1swXTp0aGlzLl9sYXRsbmdzfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3BvbHksZT10Ll9wYXRoO3QgaW5zdGFuY2VvZiBMLlBvbHlnb258fCh0Lm9wdGlvbnMuZmlsbD0hMSx0Lm9wdGlvbnMuZWRpdGluZyYmKHQub3B0aW9ucy5lZGl0aW5nLmZpbGw9ITEpKSxlJiZ0Lm9wdGlvbnMuZWRpdGluZyYmdC5vcHRpb25zLmVkaXRpbmcuY2xhc3NOYW1lJiYodC5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZSYmdC5vcHRpb25zLm9yaWdpbmFsLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbih0KXtMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZSx0KX0pLHQub3B0aW9ucy5lZGl0aW5nLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbih0KXtMLkRvbVV0aWwuYWRkQ2xhc3MoZSx0KX0pKSx0LnNldFN0eWxlKHQub3B0aW9ucy5lZGl0aW5nKSx0aGlzLl9wb2x5Ll9tYXAmJih0aGlzLl9tYXA9dGhpcy5fcG9seS5fbWFwLHRoaXMuX21hcmtlckdyb3VwfHx0aGlzLl9pbml0TWFya2VycygpLHRoaXMuX3BvbHkuX21hcC5hZGRMYXllcih0aGlzLl9tYXJrZXJHcm91cCkpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3BvbHksZT10Ll9wYXRoO2UmJnQub3B0aW9ucy5lZGl0aW5nJiZ0Lm9wdGlvbnMuZWRpdGluZy5jbGFzc05hbWUmJih0Lm9wdGlvbnMuZWRpdGluZy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24odCl7TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGUsdCl9KSx0Lm9wdGlvbnMub3JpZ2luYWwuY2xhc3NOYW1lJiZ0Lm9wdGlvbnMub3JpZ2luYWwuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0wuRG9tVXRpbC5hZGRDbGFzcyhlLHQpfSkpLHQuc2V0U3R5bGUodC5vcHRpb25zLm9yaWdpbmFsKSx0Ll9tYXAmJih0Ll9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApLGRlbGV0ZSB0aGlzLl9tYXJrZXJHcm91cCxkZWxldGUgdGhpcy5fbWFya2Vycyl9LHVwZGF0ZU1hcmtlcnM6ZnVuY3Rpb24oKXt0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpLHRoaXMuX2luaXRNYXJrZXJzKCl9LF9pbml0TWFya2VyczpmdW5jdGlvbigpe3RoaXMuX21hcmtlckdyb3VwfHwodGhpcy5fbWFya2VyR3JvdXA9bmV3IEwuTGF5ZXJHcm91cCksdGhpcy5fbWFya2Vycz1bXTt2YXIgdCxlLGksbyxhPXRoaXMuX2RlZmF1bHRTaGFwZSgpO2Zvcih0PTAsaT1hLmxlbmd0aDt0PGk7dCsrKW89dGhpcy5fY3JlYXRlTWFya2VyKGFbdF0sdCksby5vbihcImNsaWNrXCIsdGhpcy5fb25NYXJrZXJDbGljayx0aGlzKSxvLm9uKFwiY29udGV4dG1lbnVcIix0aGlzLl9vbkNvbnRleHRNZW51LHRoaXMpLHRoaXMuX21hcmtlcnMucHVzaChvKTt2YXIgbixzO2Zvcih0PTAsZT1pLTE7dDxpO2U9dCsrKSgwIT09dHx8TC5Qb2x5Z29uJiZ0aGlzLl9wb2x5IGluc3RhbmNlb2YgTC5Qb2x5Z29uKSYmKG49dGhpcy5fbWFya2Vyc1tlXSxzPXRoaXMuX21hcmtlcnNbdF0sdGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKG4scyksdGhpcy5fdXBkYXRlUHJldk5leHQobixzKSl9LF9jcmVhdGVNYXJrZXI6ZnVuY3Rpb24odCxlKXt2YXIgaT1uZXcgTC5NYXJrZXIuVG91Y2godCx7ZHJhZ2dhYmxlOiEwLGljb246dGhpcy5vcHRpb25zLmljb259KTtyZXR1cm4gaS5fb3JpZ0xhdExuZz10LGkuX2luZGV4PWUsaS5vbihcImRyYWdzdGFydFwiLHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LHRoaXMpLm9uKFwiZHJhZ1wiLHRoaXMuX29uTWFya2VyRHJhZyx0aGlzKS5vbihcImRyYWdlbmRcIix0aGlzLl9maXJlRWRpdCx0aGlzKS5vbihcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLm9uKFwidG91Y2hlbmRcIix0aGlzLl9maXJlRWRpdCx0aGlzKS5vbihcIk1TUG9pbnRlck1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKS5vbihcIk1TUG9pbnRlclVwXCIsdGhpcy5fZmlyZUVkaXQsdGhpcyksdGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIoaSksaX0sX29uTWFya2VyRHJhZ1N0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fcG9seS5maXJlKFwiZWRpdHN0YXJ0XCIpfSxfc3BsaWNlTGF0TG5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RlZmF1bHRTaGFwZSgpLGU9W10uc3BsaWNlLmFwcGx5KHQsYXJndW1lbnRzKTtyZXR1cm4gdGhpcy5fcG9seS5fY29udmVydExhdExuZ3ModCwhMCksdGhpcy5fcG9seS5yZWRyYXcoKSxlfSxfcmVtb3ZlTWFya2VyOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX2luZGV4O3RoaXMuX21hcmtlckdyb3VwLnJlbW92ZUxheWVyKHQpLHRoaXMuX21hcmtlcnMuc3BsaWNlKGUsMSksdGhpcy5fc3BsaWNlTGF0TG5ncyhlLDEpLHRoaXMuX3VwZGF0ZUluZGV4ZXMoZSwtMSksdC5vZmYoXCJkcmFnc3RhcnRcIix0aGlzLl9vbk1hcmtlckRyYWdTdGFydCx0aGlzKS5vZmYoXCJkcmFnXCIsdGhpcy5fb25NYXJrZXJEcmFnLHRoaXMpLm9mZihcImRyYWdlbmRcIix0aGlzLl9maXJlRWRpdCx0aGlzKS5vZmYoXCJ0b3VjaG1vdmVcIix0aGlzLl9vbk1hcmtlckRyYWcsdGhpcykub2ZmKFwidG91Y2hlbmRcIix0aGlzLl9maXJlRWRpdCx0aGlzKS5vZmYoXCJjbGlja1wiLHRoaXMuX29uTWFya2VyQ2xpY2ssdGhpcykub2ZmKFwiTVNQb2ludGVyTW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLm9mZihcIk1TUG9pbnRlclVwXCIsdGhpcy5fZmlyZUVkaXQsdGhpcyl9LF9maXJlRWRpdDpmdW5jdGlvbigpe3RoaXMuX3BvbHkuZWRpdGVkPSEwLHRoaXMuX3BvbHkuZmlyZShcImVkaXRcIiksdGhpcy5fcG9seS5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRWRVJURVgse2xheWVyczp0aGlzLl9tYXJrZXJHcm91cCxwb2x5OnRoaXMuX3BvbHl9KX0sX29uTWFya2VyRHJhZzpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldCxpPXRoaXMuX3BvbHksbz1MLkxhdExuZ1V0aWwuY2xvbmVMYXRMbmcoZS5fb3JpZ0xhdExuZyk7aWYoTC5leHRlbmQoZS5fb3JpZ0xhdExuZyxlLl9sYXRsbmcpLGkub3B0aW9ucy5wb2x5KXt2YXIgYT1pLl9tYXAuX2VkaXRUb29sdGlwO2lmKCFpLm9wdGlvbnMucG9seS5hbGxvd0ludGVyc2VjdGlvbiYmaS5pbnRlcnNlY3RzKCkpe0wuZXh0ZW5kKGUuX29yaWdMYXRMbmcsbyksZS5zZXRMYXRMbmcobyk7dmFyIG49aS5vcHRpb25zLmNvbG9yO2kuc2V0U3R5bGUoe2NvbG9yOnRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3J9KSxhJiZhLnVwZGF0ZUNvbnRlbnQoe3RleHQ6TC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS5lcnJvcn0pLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLnNldFN0eWxlKHtjb2xvcjpufSksYSYmYS51cGRhdGVDb250ZW50KHt0ZXh0OkwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnRleHQsc3VidGV4dDpMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC5zdWJ0ZXh0fSl9LDFlMyl9fWUuX21pZGRsZUxlZnQmJmUuX21pZGRsZUxlZnQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhlLl9wcmV2LGUpKSxlLl9taWRkbGVSaWdodCYmZS5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhlLGUuX25leHQpKSx0aGlzLl9wb2x5Ll9ib3VuZHMuX3NvdXRoV2VzdD1MLmxhdExuZygxLzAsMS8wKSx0aGlzLl9wb2x5Ll9ib3VuZHMuX25vcnRoRWFzdD1MLmxhdExuZygtMS8wLC0xLzApO3ZhciBzPXRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpO3RoaXMuX3BvbHkuX2NvbnZlcnRMYXRMbmdzKHMsITApLHRoaXMuX3BvbHkucmVkcmF3KCksdGhpcy5fcG9seS5maXJlKFwiZWRpdGRyYWdcIil9LF9vbk1hcmtlckNsaWNrOmZ1bmN0aW9uKHQpe3ZhciBlPUwuUG9seWdvbiYmdGhpcy5fcG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbj80OjMsaT10LnRhcmdldDt0aGlzLl9kZWZhdWx0U2hhcGUoKS5sZW5ndGg8ZXx8KHRoaXMuX3JlbW92ZU1hcmtlcihpKSx0aGlzLl91cGRhdGVQcmV2TmV4dChpLl9wcmV2LGkuX25leHQpLGkuX21pZGRsZUxlZnQmJnRoaXMuX21hcmtlckdyb3VwLnJlbW92ZUxheWVyKGkuX21pZGRsZUxlZnQpLGkuX21pZGRsZVJpZ2h0JiZ0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihpLl9taWRkbGVSaWdodCksaS5fcHJldiYmaS5fbmV4dD90aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIoaS5fcHJldixpLl9uZXh0KTppLl9wcmV2P2kuX25leHR8fChpLl9wcmV2Ll9taWRkbGVSaWdodD1udWxsKTppLl9uZXh0Ll9taWRkbGVMZWZ0PW51bGwsdGhpcy5fZmlyZUVkaXQoKSl9LF9vbkNvbnRleHRNZW51OmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O3RoaXMuX3BvbHk7dGhpcy5fcG9seS5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50Lk1BUktFUkNPTlRFWFQse21hcmtlcjplLGxheWVyczp0aGlzLl9tYXJrZXJHcm91cCxwb2x5OnRoaXMuX3BvbHl9KSxMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbn0sX29uVG91Y2hNb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KHQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdKSxpPXRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoZSksbz10LnRhcmdldDtMLmV4dGVuZChvLl9vcmlnTGF0TG5nLGkpLG8uX21pZGRsZUxlZnQmJm8uX21pZGRsZUxlZnQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhvLl9wcmV2LG8pKSxvLl9taWRkbGVSaWdodCYmby5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhvLG8uX25leHQpKSx0aGlzLl9wb2x5LnJlZHJhdygpLHRoaXMudXBkYXRlTWFya2VycygpfSxfdXBkYXRlSW5kZXhlczpmdW5jdGlvbih0LGUpe3RoaXMuX21hcmtlckdyb3VwLmVhY2hMYXllcihmdW5jdGlvbihpKXtpLl9pbmRleD50JiYoaS5faW5kZXgrPWUpfSl9LF9jcmVhdGVNaWRkbGVNYXJrZXI6ZnVuY3Rpb24odCxlKXt2YXIgaSxvLGEsbj10aGlzLl9nZXRNaWRkbGVMYXRMbmcodCxlKSxzPXRoaXMuX2NyZWF0ZU1hcmtlcihuKTtzLnNldE9wYWNpdHkoLjYpLHQuX21pZGRsZVJpZ2h0PWUuX21pZGRsZUxlZnQ9cyxvPWZ1bmN0aW9uKCl7cy5vZmYoXCJ0b3VjaG1vdmVcIixvLHRoaXMpO3ZhciBhPWUuX2luZGV4O3MuX2luZGV4PWEscy5vZmYoXCJjbGlja1wiLGksdGhpcykub24oXCJjbGlja1wiLHRoaXMuX29uTWFya2VyQ2xpY2ssdGhpcyksbi5sYXQ9cy5nZXRMYXRMbmcoKS5sYXQsbi5sbmc9cy5nZXRMYXRMbmcoKS5sbmcsdGhpcy5fc3BsaWNlTGF0TG5ncyhhLDAsbiksdGhpcy5fbWFya2Vycy5zcGxpY2UoYSwwLHMpLHMuc2V0T3BhY2l0eSgxKSx0aGlzLl91cGRhdGVJbmRleGVzKGEsMSksZS5faW5kZXgrKyx0aGlzLl91cGRhdGVQcmV2TmV4dCh0LHMpLHRoaXMuX3VwZGF0ZVByZXZOZXh0KHMsZSksdGhpcy5fcG9seS5maXJlKFwiZWRpdHN0YXJ0XCIpfSxhPWZ1bmN0aW9uKCl7cy5vZmYoXCJkcmFnc3RhcnRcIixvLHRoaXMpLHMub2ZmKFwiZHJhZ2VuZFwiLGEsdGhpcykscy5vZmYoXCJ0b3VjaG1vdmVcIixvLHRoaXMpLHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcih0LHMpLHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihzLGUpfSxpPWZ1bmN0aW9uKCl7by5jYWxsKHRoaXMpLGEuY2FsbCh0aGlzKSx0aGlzLl9maXJlRWRpdCgpfSxzLm9uKFwiY2xpY2tcIixpLHRoaXMpLm9uKFwiZHJhZ3N0YXJ0XCIsbyx0aGlzKS5vbihcImRyYWdlbmRcIixhLHRoaXMpLm9uKFwidG91Y2htb3ZlXCIsbyx0aGlzKSx0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihzKX0sX3VwZGF0ZVByZXZOZXh0OmZ1bmN0aW9uKHQsZSl7dCYmKHQuX25leHQ9ZSksZSYmKGUuX3ByZXY9dCl9LF9nZXRNaWRkbGVMYXRMbmc6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLl9wb2x5Ll9tYXAsbz1pLnByb2plY3QodC5nZXRMYXRMbmcoKSksYT1pLnByb2plY3QoZS5nZXRMYXRMbmcoKSk7cmV0dXJuIGkudW5wcm9qZWN0KG8uX2FkZChhKS5fZGl2aWRlQnkoMikpfX0pLEwuUG9seWxpbmUuYWRkSW5pdEhvb2soZnVuY3Rpb24oKXt0aGlzLmVkaXRpbmd8fChMLkVkaXQuUG9seSYmKHRoaXMuZWRpdGluZz1uZXcgTC5FZGl0LlBvbHkodGhpcyksdGhpcy5vcHRpb25zLmVkaXRhYmxlJiZ0aGlzLmVkaXRpbmcuZW5hYmxlKCkpLHRoaXMub24oXCJhZGRcIixmdW5jdGlvbigpe3RoaXMuZWRpdGluZyYmdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSYmdGhpcy5lZGl0aW5nLmFkZEhvb2tzKCl9KSx0aGlzLm9uKFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt0aGlzLmVkaXRpbmcmJnRoaXMuZWRpdGluZy5lbmFibGVkKCkmJnRoaXMuZWRpdGluZy5yZW1vdmVIb29rcygpfSkpfSksTC5FZGl0PUwuRWRpdHx8e30sTC5FZGl0LlNpbXBsZVNoYXBlPUwuSGFuZGxlci5leHRlbmQoe29wdGlvbnM6e21vdmVJY29uOm5ldyBMLkRpdkljb24oe2ljb25TaXplOm5ldyBMLlBvaW50KDgsOCksY2xhc3NOYW1lOlwibGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LWVkaXQtbW92ZVwifSkscmVzaXplSWNvbjpuZXcgTC5EaXZJY29uKHtpY29uU2l6ZTpuZXcgTC5Qb2ludCg4LDgpLFxuY2xhc3NOYW1lOlwibGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbiBsZWFmbGV0LWVkaXQtcmVzaXplXCJ9KSx0b3VjaE1vdmVJY29uOm5ldyBMLkRpdkljb24oe2ljb25TaXplOm5ldyBMLlBvaW50KDIwLDIwKSxjbGFzc05hbWU6XCJsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uIGxlYWZsZXQtZWRpdC1tb3ZlIGxlYWZsZXQtdG91Y2gtaWNvblwifSksdG91Y2hSZXNpemVJY29uOm5ldyBMLkRpdkljb24oe2ljb25TaXplOm5ldyBMLlBvaW50KDIwLDIwKSxjbGFzc05hbWU6XCJsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uIGxlYWZsZXQtZWRpdC1yZXNpemUgbGVhZmxldC10b3VjaC1pY29uXCJ9KX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe0wuQnJvd3Nlci50b3VjaCYmKHRoaXMub3B0aW9ucy5tb3ZlSWNvbj10aGlzLm9wdGlvbnMudG91Y2hNb3ZlSWNvbix0aGlzLm9wdGlvbnMucmVzaXplSWNvbj10aGlzLm9wdGlvbnMudG91Y2hSZXNpemVJY29uKSx0aGlzLl9zaGFwZT10LEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsZSl9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fc2hhcGU7dGhpcy5fc2hhcGUuX21hcCYmKHRoaXMuX21hcD10aGlzLl9zaGFwZS5fbWFwLHQuc2V0U3R5bGUodC5vcHRpb25zLmVkaXRpbmcpLHQuX21hcCYmKHRoaXMuX21hcD10Ll9tYXAsdGhpcy5fbWFya2VyR3JvdXB8fHRoaXMuX2luaXRNYXJrZXJzKCksdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKSkpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3NoYXBlO2lmKHQuc2V0U3R5bGUodC5vcHRpb25zLm9yaWdpbmFsKSx0Ll9tYXApe3RoaXMuX3VuYmluZE1hcmtlcih0aGlzLl9tb3ZlTWFya2VyKTtmb3IodmFyIGU9MCxpPXRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoO2U8aTtlKyspdGhpcy5fdW5iaW5kTWFya2VyKHRoaXMuX3Jlc2l6ZU1hcmtlcnNbZV0pO3RoaXMuX3Jlc2l6ZU1hcmtlcnM9bnVsbCx0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApLGRlbGV0ZSB0aGlzLl9tYXJrZXJHcm91cH10aGlzLl9tYXA9bnVsbH0sdXBkYXRlTWFya2VyczpmdW5jdGlvbigpe3RoaXMuX21hcmtlckdyb3VwLmNsZWFyTGF5ZXJzKCksdGhpcy5faW5pdE1hcmtlcnMoKX0sX2luaXRNYXJrZXJzOmZ1bmN0aW9uKCl7dGhpcy5fbWFya2VyR3JvdXB8fCh0aGlzLl9tYXJrZXJHcm91cD1uZXcgTC5MYXllckdyb3VwKSx0aGlzLl9jcmVhdGVNb3ZlTWFya2VyKCksdGhpcy5fY3JlYXRlUmVzaXplTWFya2VyKCl9LF9jcmVhdGVNb3ZlTWFya2VyOmZ1bmN0aW9uKCl7fSxfY3JlYXRlUmVzaXplTWFya2VyOmZ1bmN0aW9uKCl7fSxfY3JlYXRlTWFya2VyOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bmV3IEwuTWFya2VyLlRvdWNoKHQse2RyYWdnYWJsZTohMCxpY29uOmUsekluZGV4T2Zmc2V0OjEwfSk7cmV0dXJuIHRoaXMuX2JpbmRNYXJrZXIoaSksdGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIoaSksaX0sX2JpbmRNYXJrZXI6ZnVuY3Rpb24odCl7dC5vbihcImRyYWdzdGFydFwiLHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LHRoaXMpLm9uKFwiZHJhZ1wiLHRoaXMuX29uTWFya2VyRHJhZyx0aGlzKS5vbihcImRyYWdlbmRcIix0aGlzLl9vbk1hcmtlckRyYWdFbmQsdGhpcykub24oXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Ub3VjaFN0YXJ0LHRoaXMpLm9uKFwidG91Y2htb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUsdGhpcykub24oXCJNU1BvaW50ZXJNb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUsdGhpcykub24oXCJ0b3VjaGVuZFwiLHRoaXMuX29uVG91Y2hFbmQsdGhpcykub24oXCJNU1BvaW50ZXJVcFwiLHRoaXMuX29uVG91Y2hFbmQsdGhpcyl9LF91bmJpbmRNYXJrZXI6ZnVuY3Rpb24odCl7dC5vZmYoXCJkcmFnc3RhcnRcIix0aGlzLl9vbk1hcmtlckRyYWdTdGFydCx0aGlzKS5vZmYoXCJkcmFnXCIsdGhpcy5fb25NYXJrZXJEcmFnLHRoaXMpLm9mZihcImRyYWdlbmRcIix0aGlzLl9vbk1hcmtlckRyYWdFbmQsdGhpcykub2ZmKFwidG91Y2hzdGFydFwiLHRoaXMuX29uVG91Y2hTdGFydCx0aGlzKS5vZmYoXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKS5vZmYoXCJNU1BvaW50ZXJNb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUsdGhpcykub2ZmKFwidG91Y2hlbmRcIix0aGlzLl9vblRvdWNoRW5kLHRoaXMpLm9mZihcIk1TUG9pbnRlclVwXCIsdGhpcy5fb25Ub3VjaEVuZCx0aGlzKX0sX29uTWFya2VyRHJhZ1N0YXJ0OmZ1bmN0aW9uKHQpe3QudGFyZ2V0LnNldE9wYWNpdHkoMCksdGhpcy5fc2hhcGUuZmlyZShcImVkaXRzdGFydFwiKX0sX2ZpcmVFZGl0OmZ1bmN0aW9uKCl7dGhpcy5fc2hhcGUuZWRpdGVkPSEwLHRoaXMuX3NoYXBlLmZpcmUoXCJlZGl0XCIpfSxfb25NYXJrZXJEcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0LGk9ZS5nZXRMYXRMbmcoKTtlPT09dGhpcy5fbW92ZU1hcmtlcj90aGlzLl9tb3ZlKGkpOnRoaXMuX3Jlc2l6ZShpKSx0aGlzLl9zaGFwZS5yZWRyYXcoKSx0aGlzLl9zaGFwZS5maXJlKFwiZWRpdGRyYWdcIil9LF9vbk1hcmtlckRyYWdFbmQ6ZnVuY3Rpb24odCl7dC50YXJnZXQuc2V0T3BhY2l0eSgxKSx0aGlzLl9maXJlRWRpdCgpfSxfb25Ub3VjaFN0YXJ0OmZ1bmN0aW9uKHQpe2lmKEwuRWRpdC5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX29uTWFya2VyRHJhZ1N0YXJ0LmNhbGwodGhpcyx0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9nZXRDb3JuZXJzKXt2YXIgZT10aGlzLl9nZXRDb3JuZXJzKCksaT10LnRhcmdldCxvPWkuX2Nvcm5lckluZGV4O2kuc2V0T3BhY2l0eSgwKSx0aGlzLl9vcHBvc2l0ZUNvcm5lcj1lWyhvKzIpJTRdLHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMCxvKX10aGlzLl9zaGFwZS5maXJlKFwiZWRpdHN0YXJ0XCIpfSxfb25Ub3VjaE1vdmU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0pLGk9dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhlKTtyZXR1cm4gdC50YXJnZXQ9PT10aGlzLl9tb3ZlTWFya2VyP3RoaXMuX21vdmUoaSk6dGhpcy5fcmVzaXplKGkpLHRoaXMuX3NoYXBlLnJlZHJhdygpLCExfSxfb25Ub3VjaEVuZDpmdW5jdGlvbih0KXt0LnRhcmdldC5zZXRPcGFjaXR5KDEpLHRoaXMudXBkYXRlTWFya2VycygpLHRoaXMuX2ZpcmVFZGl0KCl9LF9tb3ZlOmZ1bmN0aW9uKCl7fSxfcmVzaXplOmZ1bmN0aW9uKCl7fX0pLEwuRWRpdD1MLkVkaXR8fHt9LEwuRWRpdC5SZWN0YW5nbGU9TC5FZGl0LlNpbXBsZVNoYXBlLmV4dGVuZCh7X2NyZWF0ZU1vdmVNYXJrZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9zaGFwZS5nZXRCb3VuZHMoKSxlPXQuZ2V0Q2VudGVyKCk7dGhpcy5fbW92ZU1hcmtlcj10aGlzLl9jcmVhdGVNYXJrZXIoZSx0aGlzLm9wdGlvbnMubW92ZUljb24pfSxfY3JlYXRlUmVzaXplTWFya2VyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0Q29ybmVycygpO3RoaXMuX3Jlc2l6ZU1hcmtlcnM9W107Zm9yKHZhciBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKXRoaXMuX3Jlc2l6ZU1hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIodFtlXSx0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpLHRoaXMuX3Jlc2l6ZU1hcmtlcnNbZV0uX2Nvcm5lckluZGV4PWV9LF9vbk1hcmtlckRyYWdTdGFydDpmdW5jdGlvbih0KXtMLkVkaXQuU2ltcGxlU2hhcGUucHJvdG90eXBlLl9vbk1hcmtlckRyYWdTdGFydC5jYWxsKHRoaXMsdCk7dmFyIGU9dGhpcy5fZ2V0Q29ybmVycygpLGk9dC50YXJnZXQsbz1pLl9jb3JuZXJJbmRleDt0aGlzLl9vcHBvc2l0ZUNvcm5lcj1lWyhvKzIpJTRdLHRoaXMuX3RvZ2dsZUNvcm5lck1hcmtlcnMoMCxvKX0sX29uTWFya2VyRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZSxpLG89dC50YXJnZXQ7bz09PXRoaXMuX21vdmVNYXJrZXImJihlPXRoaXMuX3NoYXBlLmdldEJvdW5kcygpLGk9ZS5nZXRDZW50ZXIoKSxvLnNldExhdExuZyhpKSksdGhpcy5fdG9nZ2xlQ29ybmVyTWFya2VycygxKSx0aGlzLl9yZXBvc2l0aW9uQ29ybmVyTWFya2VycygpLEwuRWRpdC5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX29uTWFya2VyRHJhZ0VuZC5jYWxsKHRoaXMsdCl9LF9tb3ZlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPXRoaXMuX3NoYXBlLl9kZWZhdWx0U2hhcGU/dGhpcy5fc2hhcGUuX2RlZmF1bHRTaGFwZSgpOnRoaXMuX3NoYXBlLmdldExhdExuZ3MoKSxvPXRoaXMuX3NoYXBlLmdldEJvdW5kcygpLGE9by5nZXRDZW50ZXIoKSxuPVtdLHM9MCxyPWkubGVuZ3RoO3M8cjtzKyspZT1baVtzXS5sYXQtYS5sYXQsaVtzXS5sbmctYS5sbmddLG4ucHVzaChbdC5sYXQrZVswXSx0LmxuZytlWzFdXSk7dGhpcy5fc2hhcGUuc2V0TGF0TG5ncyhuKSx0aGlzLl9yZXBvc2l0aW9uQ29ybmVyTWFya2VycygpLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUTU9WRSx7bGF5ZXI6dGhpcy5fc2hhcGV9KX0sX3Jlc2l6ZTpmdW5jdGlvbih0KXt2YXIgZTt0aGlzLl9zaGFwZS5zZXRCb3VuZHMoTC5sYXRMbmdCb3VuZHModCx0aGlzLl9vcHBvc2l0ZUNvcm5lcikpLGU9dGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCksdGhpcy5fbW92ZU1hcmtlci5zZXRMYXRMbmcoZS5nZXRDZW50ZXIoKSksdGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRSRVNJWkUse2xheWVyOnRoaXMuX3NoYXBlfSl9LF9nZXRDb3JuZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCk7cmV0dXJuW3QuZ2V0Tm9ydGhXZXN0KCksdC5nZXROb3J0aEVhc3QoKSx0LmdldFNvdXRoRWFzdCgpLHQuZ2V0U291dGhXZXN0KCldfSxfdG9nZ2xlQ29ybmVyTWFya2VyczpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxpPXRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoO2U8aTtlKyspdGhpcy5fcmVzaXplTWFya2Vyc1tlXS5zZXRPcGFjaXR5KHQpfSxfcmVwb3NpdGlvbkNvcm5lck1hcmtlcnM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fZ2V0Q29ybmVycygpLGU9MCxpPXRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoO2U8aTtlKyspdGhpcy5fcmVzaXplTWFya2Vyc1tlXS5zZXRMYXRMbmcodFtlXSl9fSksTC5SZWN0YW5nbGUuYWRkSW5pdEhvb2soZnVuY3Rpb24oKXtMLkVkaXQuUmVjdGFuZ2xlJiYodGhpcy5lZGl0aW5nPW5ldyBMLkVkaXQuUmVjdGFuZ2xlKHRoaXMpLHRoaXMub3B0aW9ucy5lZGl0YWJsZSYmdGhpcy5lZGl0aW5nLmVuYWJsZSgpKX0pLEwuRWRpdD1MLkVkaXR8fHt9LEwuRWRpdC5DaXJjbGVNYXJrZXI9TC5FZGl0LlNpbXBsZVNoYXBlLmV4dGVuZCh7X2NyZWF0ZU1vdmVNYXJrZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9zaGFwZS5nZXRMYXRMbmcoKTt0aGlzLl9tb3ZlTWFya2VyPXRoaXMuX2NyZWF0ZU1hcmtlcih0LHRoaXMub3B0aW9ucy5tb3ZlSWNvbil9LF9jcmVhdGVSZXNpemVNYXJrZXI6ZnVuY3Rpb24oKXt0aGlzLl9yZXNpemVNYXJrZXJzPVtdfSxfbW92ZTpmdW5jdGlvbih0KXtpZih0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aCl7dmFyIGU9dGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQodCk7dGhpcy5fcmVzaXplTWFya2Vyc1swXS5zZXRMYXRMbmcoZSl9dGhpcy5fc2hhcGUuc2V0TGF0TG5nKHQpLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUTU9WRSx7bGF5ZXI6dGhpcy5fc2hhcGV9KX19KSxMLkNpcmNsZU1hcmtlci5hZGRJbml0SG9vayhmdW5jdGlvbigpe0wuRWRpdC5DaXJjbGVNYXJrZXImJih0aGlzLmVkaXRpbmc9bmV3IEwuRWRpdC5DaXJjbGVNYXJrZXIodGhpcyksdGhpcy5vcHRpb25zLmVkaXRhYmxlJiZ0aGlzLmVkaXRpbmcuZW5hYmxlKCkpLHRoaXMub24oXCJhZGRcIixmdW5jdGlvbigpe3RoaXMuZWRpdGluZyYmdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSYmdGhpcy5lZGl0aW5nLmFkZEhvb2tzKCl9KSx0aGlzLm9uKFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt0aGlzLmVkaXRpbmcmJnRoaXMuZWRpdGluZy5lbmFibGVkKCkmJnRoaXMuZWRpdGluZy5yZW1vdmVIb29rcygpfSl9KSxMLkVkaXQ9TC5FZGl0fHx7fSxMLkVkaXQuQ2lyY2xlPUwuRWRpdC5DaXJjbGVNYXJrZXIuZXh0ZW5kKHtfY3JlYXRlUmVzaXplTWFya2VyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fc2hhcGUuZ2V0TGF0TG5nKCksZT10aGlzLl9nZXRSZXNpemVNYXJrZXJQb2ludCh0KTt0aGlzLl9yZXNpemVNYXJrZXJzPVtdLHRoaXMuX3Jlc2l6ZU1hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIoZSx0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpfSxfZ2V0UmVzaXplTWFya2VyUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fc2hhcGUuX3JhZGl1cypNYXRoLmNvcyhNYXRoLlBJLzQpLGk9dGhpcy5fbWFwLnByb2plY3QodCk7cmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QoW2kueCtlLGkueS1lXSl9LF9yZXNpemU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbW92ZU1hcmtlci5nZXRMYXRMbmcoKTtMLkdlb21ldHJ5VXRpbC5pc1ZlcnNpb24wN3goKT9yYWRpdXM9ZS5kaXN0YW5jZVRvKHQpOnJhZGl1cz10aGlzLl9tYXAuZGlzdGFuY2UoZSx0KSx0aGlzLl9zaGFwZS5zZXRSYWRpdXMocmFkaXVzKSx0aGlzLl9tYXAuZWRpdFRvb2x0aXAmJnRoaXMuX21hcC5fZWRpdFRvb2x0aXAudXBkYXRlQ29udGVudCh7dGV4dDpMLmRyYXdMb2NhbC5lZGl0LmhhbmRsZXJzLmVkaXQudG9vbHRpcC5zdWJ0ZXh0K1wiPGJyIC8+XCIrTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxzdWJ0ZXh0OkwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuY2lyY2xlLnJhZGl1cytcIjogXCIrTC5HZW9tZXRyeVV0aWwucmVhZGFibGVEaXN0YW5jZShyYWRpdXMsITAsdGhpcy5vcHRpb25zLmZlZXQsdGhpcy5vcHRpb25zLm5hdXRpYyl9KSx0aGlzLl9zaGFwZS5zZXRSYWRpdXMocmFkaXVzKSx0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFJFU0laRSx7bGF5ZXI6dGhpcy5fc2hhcGV9KX19KSxMLkNpcmNsZS5hZGRJbml0SG9vayhmdW5jdGlvbigpe0wuRWRpdC5DaXJjbGUmJih0aGlzLmVkaXRpbmc9bmV3IEwuRWRpdC5DaXJjbGUodGhpcyksdGhpcy5vcHRpb25zLmVkaXRhYmxlJiZ0aGlzLmVkaXRpbmcuZW5hYmxlKCkpfSksTC5NYXAubWVyZ2VPcHRpb25zKHt0b3VjaEV4dGVuZDohMH0pLEwuTWFwLlRvdWNoRXh0ZW5kPUwuSGFuZGxlci5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbWFwPXQsdGhpcy5fY29udGFpbmVyPXQuX2NvbnRhaW5lcix0aGlzLl9wYW5lPXQuX3BhbmVzLm92ZXJsYXlQYW5lfSxhZGRIb29rczpmdW5jdGlvbigpe0wuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLFwidG91Y2hzdGFydFwiLHRoaXMuX29uVG91Y2hTdGFydCx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcInRvdWNoZW5kXCIsdGhpcy5fb25Ub3VjaEVuZCx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLHRoaXMuX2RldGVjdElFKCk/KEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLFwiTVNQb2ludGVyRG93blwiLHRoaXMuX29uVG91Y2hTdGFydCx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcIk1TUG9pbnRlclVwXCIsdGhpcy5fb25Ub3VjaEVuZCx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcIk1TUG9pbnRlck1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcIk1TUG9pbnRlckNhbmNlbFwiLHRoaXMuX29uVG91Y2hDYW5jZWwsdGhpcykpOihMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcInRvdWNoY2FuY2VsXCIsdGhpcy5fb25Ub3VjaENhbmNlbCx0aGlzKSxMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lcixcInRvdWNobGVhdmVcIix0aGlzLl9vblRvdWNoTGVhdmUsdGhpcykpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe0wuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vblRvdWNoU3RhcnQsdGhpcyksTC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLFwidG91Y2hlbmRcIix0aGlzLl9vblRvdWNoRW5kLHRoaXMpLEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLHRoaXMuX2RldGVjdElFKCk/KEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcIk1TUG9pbnRlckRvd25cIix0aGlzLl9vblRvdWNoU3RhcnQsdGhpcyksTC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLFwiTVNQb2ludGVyVXBcIix0aGlzLl9vblRvdWNoRW5kLHRoaXMpLEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcIk1TUG9pbnRlck1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKSxMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsXCJNU1BvaW50ZXJDYW5jZWxcIix0aGlzLl9vblRvdWNoQ2FuY2VsLHRoaXMpKTooTC5Eb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLFwidG91Y2hjYW5jZWxcIix0aGlzLl9vblRvdWNoQ2FuY2VsLHRoaXMpLEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcixcInRvdWNobGVhdmVcIix0aGlzLl9vblRvdWNoTGVhdmUsdGhpcykpfSxfdG91Y2hFdmVudDpmdW5jdGlvbih0LGUpe3ZhciBpPXt9O2lmKHZvaWQgMCE9PXQudG91Y2hlcyl7aWYoIXQudG91Y2hlcy5sZW5ndGgpcmV0dXJuO2k9dC50b3VjaGVzWzBdfWVsc2V7aWYoXCJ0b3VjaFwiIT09dC5wb2ludGVyVHlwZSlyZXR1cm47aWYoaT10LCF0aGlzLl9maWx0ZXJDbGljayh0KSlyZXR1cm59dmFyIG89dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGkpLGE9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoaSksbj10aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGEpO3RoaXMuX21hcC5maXJlKGUse2xhdGxuZzpuLGxheWVyUG9pbnQ6YSxjb250YWluZXJQb2ludDpvLHBhZ2VYOmkucGFnZVgscGFnZVk6aS5wYWdlWSxvcmlnaW5hbEV2ZW50OnR9KX0sX2ZpbHRlckNsaWNrOmZ1bmN0aW9uKHQpe3ZhciBlPXQudGltZVN0YW1wfHx0Lm9yaWdpbmFsRXZlbnQudGltZVN0YW1wLGk9TC5Eb21FdmVudC5fbGFzdENsaWNrJiZlLUwuRG9tRXZlbnQuX2xhc3RDbGljaztyZXR1cm4gaSYmaT4xMDAmJmk8NTAwfHx0LnRhcmdldC5fc2ltdWxhdGVkQ2xpY2smJiF0Ll9zaW11bGF0ZWQ/KEwuRG9tRXZlbnQuc3RvcCh0KSwhMSk6KEwuRG9tRXZlbnQuX2xhc3RDbGljaz1lLCEwKX0sX29uVG91Y2hTdGFydDpmdW5jdGlvbih0KXtpZih0aGlzLl9tYXAuX2xvYWRlZCl7dGhpcy5fdG91Y2hFdmVudCh0LFwidG91Y2hzdGFydFwiKX19LF9vblRvdWNoRW5kOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX21hcC5fbG9hZGVkKXt0aGlzLl90b3VjaEV2ZW50KHQsXCJ0b3VjaGVuZFwiKX19LF9vblRvdWNoQ2FuY2VsOmZ1bmN0aW9uKHQpe2lmKHRoaXMuX21hcC5fbG9hZGVkKXt2YXIgZT1cInRvdWNoY2FuY2VsXCI7dGhpcy5fZGV0ZWN0SUUoKSYmKGU9XCJwb2ludGVyY2FuY2VsXCIpLHRoaXMuX3RvdWNoRXZlbnQodCxlKX19LF9vblRvdWNoTGVhdmU6ZnVuY3Rpb24odCl7aWYodGhpcy5fbWFwLl9sb2FkZWQpe3RoaXMuX3RvdWNoRXZlbnQodCxcInRvdWNobGVhdmVcIil9fSxfb25Ub3VjaE1vdmU6ZnVuY3Rpb24odCl7aWYodGhpcy5fbWFwLl9sb2FkZWQpe3RoaXMuX3RvdWNoRXZlbnQodCxcInRvdWNobW92ZVwiKX19LF9kZXRlY3RJRTpmdW5jdGlvbigpe3ZhciBlPXQubmF2aWdhdG9yLnVzZXJBZ2VudCxpPWUuaW5kZXhPZihcIk1TSUUgXCIpO2lmKGk+MClyZXR1cm4gcGFyc2VJbnQoZS5zdWJzdHJpbmcoaSs1LGUuaW5kZXhPZihcIi5cIixpKSksMTApO2lmKGUuaW5kZXhPZihcIlRyaWRlbnQvXCIpPjApe3ZhciBvPWUuaW5kZXhPZihcInJ2OlwiKTtyZXR1cm4gcGFyc2VJbnQoZS5zdWJzdHJpbmcobyszLGUuaW5kZXhPZihcIi5cIixvKSksMTApfXZhciBhPWUuaW5kZXhPZihcIkVkZ2UvXCIpO3JldHVybiBhPjAmJnBhcnNlSW50KGUuc3Vic3RyaW5nKGErNSxlLmluZGV4T2YoXCIuXCIsYSkpLDEwKX19KSxMLk1hcC5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcInRvdWNoRXh0ZW5kXCIsTC5NYXAuVG91Y2hFeHRlbmQpLEwuTWFya2VyLlRvdWNoPUwuTWFya2VyLmV4dGVuZCh7X2luaXRJbnRlcmFjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0P0wuTWFya2VyLnByb3RvdHlwZS5faW5pdEludGVyYWN0aW9uLmFwcGx5KHRoaXMpOnRoaXMuX2luaXRJbnRlcmFjdGlvbkxlZ2FjeSgpfSxfaW5pdEludGVyYWN0aW9uTGVnYWN5OmZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmNsaWNrYWJsZSl7dmFyIHQ9dGhpcy5faWNvbixlPVtcImRibGNsaWNrXCIsXCJtb3VzZWRvd25cIixcIm1vdXNlb3ZlclwiLFwibW91c2VvdXRcIixcImNvbnRleHRtZW51XCIsXCJ0b3VjaHN0YXJ0XCIsXCJ0b3VjaGVuZFwiLFwidG91Y2htb3ZlXCJdO3RoaXMuX2RldGVjdElFP2UuY29uY2F0KFtcIk1TUG9pbnRlckRvd25cIixcIk1TUG9pbnRlclVwXCIsXCJNU1BvaW50ZXJNb3ZlXCIsXCJNU1BvaW50ZXJDYW5jZWxcIl0pOmUuY29uY2F0KFtcInRvdWNoY2FuY2VsXCJdKSxMLkRvbVV0aWwuYWRkQ2xhc3ModCxcImxlYWZsZXQtY2xpY2thYmxlXCIpLEwuRG9tRXZlbnQub24odCxcImNsaWNrXCIsdGhpcy5fb25Nb3VzZUNsaWNrLHRoaXMpLEwuRG9tRXZlbnQub24odCxcImtleXByZXNzXCIsdGhpcy5fb25LZXlQcmVzcyx0aGlzKTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKylMLkRvbUV2ZW50Lm9uKHQsZVtpXSx0aGlzLl9maXJlTW91c2VFdmVudCx0aGlzKTtMLkhhbmRsZXIuTWFya2VyRHJhZyYmKHRoaXMuZHJhZ2dpbmc9bmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpLHRoaXMub3B0aW9ucy5kcmFnZ2FibGUmJnRoaXMuZHJhZ2dpbmcuZW5hYmxlKCkpfX0sX2RldGVjdElFOmZ1bmN0aW9uKCl7dmFyIGU9dC5uYXZpZ2F0b3IudXNlckFnZW50LGk9ZS5pbmRleE9mKFwiTVNJRSBcIik7aWYoaT4wKXJldHVybiBwYXJzZUludChlLnN1YnN0cmluZyhpKzUsZS5pbmRleE9mKFwiLlwiLGkpKSwxMCk7aWYoZS5pbmRleE9mKFwiVHJpZGVudC9cIik+MCl7dmFyIG89ZS5pbmRleE9mKFwicnY6XCIpO3JldHVybiBwYXJzZUludChlLnN1YnN0cmluZyhvKzMsZS5pbmRleE9mKFwiLlwiLG8pKSwxMCl9dmFyIGE9ZS5pbmRleE9mKFwiRWRnZS9cIik7cmV0dXJuIGE+MCYmcGFyc2VJbnQoZS5zdWJzdHJpbmcoYSs1LGUuaW5kZXhPZihcIi5cIixhKSksMTApfX0pLEwuTGF0TG5nVXRpbD17Y2xvbmVMYXRMbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxpPTAsbz10Lmxlbmd0aDtpPG87aSsrKUFycmF5LmlzQXJyYXkodFtpXSk/ZS5wdXNoKEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZ3ModFtpXSkpOmUucHVzaCh0aGlzLmNsb25lTGF0TG5nKHRbaV0pKTtyZXR1cm4gZX0sY2xvbmVMYXRMbmc6ZnVuY3Rpb24odCl7cmV0dXJuIEwubGF0TG5nKHQubGF0LHQubG5nKX19LGZ1bmN0aW9uKCl7dmFyIHQ9e2ttOjIsaGE6MixtOjAsbWk6MixhYzoyLHlkOjAsZnQ6MCxubToyfTtMLkdlb21ldHJ5VXRpbD1MLmV4dGVuZChMLkdlb21ldHJ5VXRpbHx8e30se2dlb2Rlc2ljQXJlYTpmdW5jdGlvbih0KXt2YXIgZSxpLG89dC5sZW5ndGgsYT0wLG49TWF0aC5QSS8xODA7aWYobz4yKXtmb3IodmFyIHM9MDtzPG87cysrKWU9dFtzXSxpPXRbKHMrMSklb10sYSs9KGkubG5nLWUubG5nKSpuKigyK01hdGguc2luKGUubGF0Km4pK01hdGguc2luKGkubGF0Km4pKTthPTYzNzgxMzcqYSo2Mzc4MTM3LzJ9cmV0dXJuIE1hdGguYWJzKGEpfSxmb3JtYXR0ZWROdW1iZXI6ZnVuY3Rpb24odCxlKXt2YXIgaT1wYXJzZUZsb2F0KHQpLnRvRml4ZWQoZSksbz1MLmRyYXdMb2NhbC5mb3JtYXQmJkwuZHJhd0xvY2FsLmZvcm1hdC5udW1lcmljLGE9byYmby5kZWxpbWl0ZXJzLG49YSYmYS50aG91c2FuZHMscz1hJiZhLmRlY2ltYWw7aWYobnx8cyl7dmFyIHI9aS5zcGxpdChcIi5cIik7aT1uP3JbMF0ucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFwiJDFcIituKTpyWzBdLHM9c3x8XCIuXCIsci5sZW5ndGg+MSYmKGk9aStzK3JbMV0pfXJldHVybiBpfSxyZWFkYWJsZUFyZWE6ZnVuY3Rpb24oZSxpLG8pe3ZhciBhLG4sbz1MLlV0aWwuZXh0ZW5kKHt9LHQsbyk7cmV0dXJuIGk/KG49W1wiaGFcIixcIm1cIl0sdHlwZT10eXBlb2YgaSxcInN0cmluZ1wiPT09dHlwZT9uPVtpXTpcImJvb2xlYW5cIiE9PXR5cGUmJihuPWkpLGE9ZT49MWU2JiYtMSE9PW4uaW5kZXhPZihcImttXCIpP0wuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcigxZS02KmUsby5rbSkrXCIga23CslwiOmU+PTFlNCYmLTEhPT1uLmluZGV4T2YoXCJoYVwiKT9MLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoMWUtNCplLG8uaGEpK1wiIGhhXCI6TC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGUsby5tKStcIiBtwrJcIik6KGUvPS44MzYxMjcsYT1lPj0zMDk3NjAwP0wuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihlLzMwOTc2MDAsby5taSkrXCIgbWnCslwiOmU+PTQ4NDA/TC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGUvNDg0MCxvLmFjKStcIiBhY3Jlc1wiOkwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihlLG8ueWQpK1wiIHlkwrJcIiksYX0scmVhZGFibGVEaXN0YW5jZTpmdW5jdGlvbihlLGksbyxhLG4pe3ZhciBzLG49TC5VdGlsLmV4dGVuZCh7fSx0LG4pO3N3aXRjaChpP1wic3RyaW5nXCI9PXR5cGVvZiBpP2k6XCJtZXRyaWNcIjpvP1wiZmVldFwiOmE/XCJuYXV0aWNhbE1pbGVcIjpcInlhcmRzXCIpe2Nhc2VcIm1ldHJpY1wiOnM9ZT4xZTM/TC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGUvMWUzLG4ua20pK1wiIGttXCI6TC5HZW9tZXRyeVV0aWwuZm9ybWF0dGVkTnVtYmVyKGUsbi5tKStcIiBtXCI7YnJlYWs7Y2FzZVwiZmVldFwiOmUqPTMuMjgwODMscz1MLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZSxuLmZ0KStcIiBmdFwiO2JyZWFrO2Nhc2VcIm5hdXRpY2FsTWlsZVwiOmUqPS41Mzk5NixzPUwuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihlLzFlMyxuLm5tKStcIiBubVwiO2JyZWFrO2Nhc2VcInlhcmRzXCI6ZGVmYXVsdDplKj0xLjA5MzYxLHM9ZT4xNzYwP0wuR2VvbWV0cnlVdGlsLmZvcm1hdHRlZE51bWJlcihlLzE3NjAsbi5taSkrXCIgbWlsZXNcIjpMLkdlb21ldHJ5VXRpbC5mb3JtYXR0ZWROdW1iZXIoZSxuLnlkKStcIiB5ZFwifXJldHVybiBzfSxpc1ZlcnNpb24wN3g6ZnVuY3Rpb24oKXt2YXIgdD1MLnZlcnNpb24uc3BsaXQoXCIuXCIpO3JldHVybiAwPT09cGFyc2VJbnQodFswXSwxMCkmJjc9PT1wYXJzZUludCh0WzFdLDEwKX19KX0oKSxMLlV0aWwuZXh0ZW5kKEwuTGluZVV0aWwse3NlZ21lbnRzSW50ZXJzZWN0OmZ1bmN0aW9uKHQsZSxpLG8pe3JldHVybiB0aGlzLl9jaGVja0NvdW50ZXJjbG9ja3dpc2UodCxpLG8pIT09dGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKGUsaSxvKSYmdGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKHQsZSxpKSE9PXRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZSh0LGUsbyl9LF9jaGVja0NvdW50ZXJjbG9ja3dpc2U6ZnVuY3Rpb24odCxlLGkpe3JldHVybihpLnktdC55KSooZS54LXQueCk+KGUueS10LnkpKihpLngtdC54KX19KSxMLlBvbHlsaW5lLmluY2x1ZGUoe2ludGVyc2VjdHM6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbz10aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxhPW8/by5sZW5ndGg6MDtpZih0aGlzLl90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMTtmb3IodD1hLTE7dD49Mzt0LS0paWYoZT1vW3QtMV0saT1vW3RdLHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShlLGksdC0yKSlyZXR1cm4hMDtyZXR1cm4hMX0sbmV3TGF0TG5nSW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiEhdGhpcy5fbWFwJiZ0aGlzLm5ld1BvaW50SW50ZXJzZWN0cyh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHQpLGUpfSxuZXdQb2ludEludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxvPWk/aS5sZW5ndGg6MCxhPWk/aVtvLTFdOm51bGwsbj1vLTI7cmV0dXJuIXRoaXMuX3Rvb0Zld1BvaW50c0ZvckludGVyc2VjdGlvbigxKSYmdGhpcy5fbGluZVNlZ21lbnRzSW50ZXJzZWN0c1JhbmdlKGEsdCxuLGU/MTowKX0sX3Rvb0Zld1BvaW50c0ZvckludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKSxpPWU/ZS5sZW5ndGg6MDtyZXR1cm4gaSs9dHx8MCwhZXx8aTw9M30sX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZTpmdW5jdGlvbih0LGUsaSxvKXt2YXIgYSxuLHM9dGhpcy5fZ2V0UHJvamVjdGVkUG9pbnRzKCk7bz1vfHwwO2Zvcih2YXIgcj1pO3I+bztyLS0paWYoYT1zW3ItMV0sbj1zW3JdLEwuTGluZVV0aWwuc2VnbWVudHNJbnRlcnNlY3QodCxlLGEsbikpcmV0dXJuITA7cmV0dXJuITF9LF9nZXRQcm9qZWN0ZWRQb2ludHM6ZnVuY3Rpb24oKXtpZighdGhpcy5fZGVmYXVsdFNoYXBlKXJldHVybiB0aGlzLl9vcmlnaW5hbFBvaW50cztmb3IodmFyIHQ9W10sZT10aGlzLl9kZWZhdWx0U2hhcGUoKSxpPTA7aTxlLmxlbmd0aDtpKyspdC5wdXNoKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoZVtpXSkpO3JldHVybiB0fX0pLEwuUG9seWdvbi5pbmNsdWRlKHtpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7dmFyIHQsZSxpLG8sYT10aGlzLl9nZXRQcm9qZWN0ZWRQb2ludHMoKTtyZXR1cm4hdGhpcy5fdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uKCkmJighIUwuUG9seWxpbmUucHJvdG90eXBlLmludGVyc2VjdHMuY2FsbCh0aGlzKXx8KHQ9YS5sZW5ndGgsZT1hWzBdLGk9YVt0LTFdLG89dC0yLHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShpLGUsbywxKSkpfX0pLEwuQ29udHJvbC5EcmF3PUwuQ29udHJvbC5leHRlbmQoe29wdGlvbnM6e3Bvc2l0aW9uOlwidG9wbGVmdFwiLGRyYXc6e30sZWRpdDohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXtpZihMLnZlcnNpb248XCIwLjdcIil0aHJvdyBuZXcgRXJyb3IoXCJMZWFmbGV0LmRyYXcgMC4yLjMrIHJlcXVpcmVzIExlYWZsZXQgMC43LjArLiBEb3dubG9hZCBsYXRlc3QgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L1wiKTtMLkNvbnRyb2wucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLHQpO3ZhciBlO3RoaXMuX3Rvb2xiYXJzPXt9LEwuRHJhd1Rvb2xiYXImJnRoaXMub3B0aW9ucy5kcmF3JiYoZT1uZXcgTC5EcmF3VG9vbGJhcih0aGlzLm9wdGlvbnMuZHJhdyksdGhpcy5fdG9vbGJhcnNbTC5EcmF3VG9vbGJhci5UWVBFXT1lLHRoaXMuX3Rvb2xiYXJzW0wuRHJhd1Rvb2xiYXIuVFlQRV0ub24oXCJlbmFibGVcIix0aGlzLl90b29sYmFyRW5hYmxlZCx0aGlzKSksTC5FZGl0VG9vbGJhciYmdGhpcy5vcHRpb25zLmVkaXQmJihlPW5ldyBMLkVkaXRUb29sYmFyKHRoaXMub3B0aW9ucy5lZGl0KSx0aGlzLl90b29sYmFyc1tMLkVkaXRUb29sYmFyLlRZUEVdPWUsdGhpcy5fdG9vbGJhcnNbTC5FZGl0VG9vbGJhci5UWVBFXS5vbihcImVuYWJsZVwiLHRoaXMuX3Rvb2xiYXJFbmFibGVkLHRoaXMpKSxMLnRvb2xiYXI9dGhpc30sb25BZGQ6ZnVuY3Rpb24odCl7dmFyIGUsaT1MLkRvbVV0aWwuY3JlYXRlKFwiZGl2XCIsXCJsZWFmbGV0LWRyYXdcIiksbz0hMTtmb3IodmFyIGEgaW4gdGhpcy5fdG9vbGJhcnMpdGhpcy5fdG9vbGJhcnMuaGFzT3duUHJvcGVydHkoYSkmJihlPXRoaXMuX3Rvb2xiYXJzW2FdLmFkZFRvb2xiYXIodCkpJiYob3x8KEwuRG9tVXRpbC5oYXNDbGFzcyhlLFwibGVhZmxldC1kcmF3LXRvb2xiYXItdG9wXCIpfHxMLkRvbVV0aWwuYWRkQ2xhc3MoZS5jaGlsZE5vZGVzWzBdLFwibGVhZmxldC1kcmF3LXRvb2xiYXItdG9wXCIpLG89ITApLGkuYXBwZW5kQ2hpbGQoZSkpO3JldHVybiBpfSxvblJlbW92ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl90b29sYmFycyl0aGlzLl90b29sYmFycy5oYXNPd25Qcm9wZXJ0eSh0KSYmdGhpcy5fdG9vbGJhcnNbdF0ucmVtb3ZlVG9vbGJhcigpfSxzZXREcmF3aW5nT3B0aW9uczpmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdGhpcy5fdG9vbGJhcnMpdGhpcy5fdG9vbGJhcnNbZV1pbnN0YW5jZW9mIEwuRHJhd1Rvb2xiYXImJnRoaXMuX3Rvb2xiYXJzW2VdLnNldE9wdGlvbnModCl9LF90b29sYmFyRW5hYmxlZDpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtmb3IodmFyIGkgaW4gdGhpcy5fdG9vbGJhcnMpdGhpcy5fdG9vbGJhcnNbaV0hPT1lJiZ0aGlzLl90b29sYmFyc1tpXS5kaXNhYmxlKCl9fSksTC5NYXAubWVyZ2VPcHRpb25zKHtkcmF3Q29udHJvbFRvb2x0aXBzOiEwLGRyYXdDb250cm9sOiExfSksTC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuZHJhd0NvbnRyb2wmJih0aGlzLmRyYXdDb250cm9sPW5ldyBMLkNvbnRyb2wuRHJhdyx0aGlzLmFkZENvbnRyb2wodGhpcy5kcmF3Q29udHJvbCkpfSksTC5Ub29sYmFyPUwuQ2xhc3MuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe0wuc2V0T3B0aW9ucyh0aGlzLHQpLHRoaXMuX21vZGVzPXt9LHRoaXMuX2FjdGlvbkJ1dHRvbnM9W10sdGhpcy5fYWN0aXZlTW9kZT1udWxsO3ZhciBlPUwudmVyc2lvbi5zcGxpdChcIi5cIik7MT09PXBhcnNlSW50KGVbMF0sMTApJiZwYXJzZUludChlWzFdLDEwKT49Mj9MLlRvb2xiYXIuaW5jbHVkZShMLkV2ZW50ZWQucHJvdG90eXBlKTpMLlRvb2xiYXIuaW5jbHVkZShMLk1peGluLkV2ZW50cyl9LGVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuX2FjdGl2ZU1vZGV9LGRpc2FibGU6ZnVuY3Rpb24oKXt0aGlzLmVuYWJsZWQoKSYmdGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLmRpc2FibGUoKX0sYWRkVG9vbGJhcjpmdW5jdGlvbih0KXt2YXIgZSxpPUwuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIixcImxlYWZsZXQtZHJhdy1zZWN0aW9uXCIpLG89MCxhPXRoaXMuX3Rvb2xiYXJDbGFzc3x8XCJcIixuPXRoaXMuZ2V0TW9kZUhhbmRsZXJzKHQpO2Zvcih0aGlzLl90b29sYmFyQ29udGFpbmVyPUwuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIixcImxlYWZsZXQtZHJhdy10b29sYmFyIGxlYWZsZXQtYmFyXCIpLHRoaXMuX21hcD10LGU9MDtlPG4ubGVuZ3RoO2UrKyluW2VdLmVuYWJsZWQmJnRoaXMuX2luaXRNb2RlSGFuZGxlcihuW2VdLmhhbmRsZXIsdGhpcy5fdG9vbGJhckNvbnRhaW5lcixvKyssYSxuW2VdLnRpdGxlKTtpZihvKXJldHVybiB0aGlzLl9sYXN0QnV0dG9uSW5kZXg9LS1vLHRoaXMuX2FjdGlvbnNDb250YWluZXI9TC5Eb21VdGlsLmNyZWF0ZShcInVsXCIsXCJsZWFmbGV0LWRyYXctYWN0aW9uc1wiKSxpLmFwcGVuZENoaWxkKHRoaXMuX3Rvb2xiYXJDb250YWluZXIpLGkuYXBwZW5kQ2hpbGQodGhpcy5fYWN0aW9uc0NvbnRhaW5lciksaX0scmVtb3ZlVG9vbGJhcjpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9tb2Rlcyl0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eSh0KSYmKHRoaXMuX2Rpc3Bvc2VCdXR0b24odGhpcy5fbW9kZXNbdF0uYnV0dG9uLHRoaXMuX21vZGVzW3RdLmhhbmRsZXIuZW5hYmxlLHRoaXMuX21vZGVzW3RdLmhhbmRsZXIpLHRoaXMuX21vZGVzW3RdLmhhbmRsZXIuZGlzYWJsZSgpLHRoaXMuX21vZGVzW3RdLmhhbmRsZXIub2ZmKFwiZW5hYmxlZFwiLHRoaXMuX2hhbmRsZXJBY3RpdmF0ZWQsdGhpcykub2ZmKFwiZGlzYWJsZWRcIix0aGlzLl9oYW5kbGVyRGVhY3RpdmF0ZWQsdGhpcykpO3RoaXMuX21vZGVzPXt9O2Zvcih2YXIgZT0wLGk9dGhpcy5fYWN0aW9uQnV0dG9ucy5sZW5ndGg7ZTxpO2UrKyl0aGlzLl9kaXNwb3NlQnV0dG9uKHRoaXMuX2FjdGlvbkJ1dHRvbnNbZV0uYnV0dG9uLHRoaXMuX2FjdGlvbkJ1dHRvbnNbZV0uY2FsbGJhY2ssdGhpcyk7dGhpcy5fYWN0aW9uQnV0dG9ucz1bXSx0aGlzLl9hY3Rpb25zQ29udGFpbmVyPW51bGx9LF9pbml0TW9kZUhhbmRsZXI6ZnVuY3Rpb24odCxlLGksbyxhKXt2YXIgbj10LnR5cGU7dGhpcy5fbW9kZXNbbl09e30sdGhpcy5fbW9kZXNbbl0uaGFuZGxlcj10LHRoaXMuX21vZGVzW25dLmJ1dHRvbj10aGlzLl9jcmVhdGVCdXR0b24oe3R5cGU6bix0aXRsZTphLGNsYXNzTmFtZTpvK1wiLVwiK24sY29udGFpbmVyOmUsY2FsbGJhY2s6dGhpcy5fbW9kZXNbbl0uaGFuZGxlci5lbmFibGUsY29udGV4dDp0aGlzLl9tb2Rlc1tuXS5oYW5kbGVyfSksdGhpcy5fbW9kZXNbbl0uYnV0dG9uSW5kZXg9aSx0aGlzLl9tb2Rlc1tuXS5oYW5kbGVyLm9uKFwiZW5hYmxlZFwiLHRoaXMuX2hhbmRsZXJBY3RpdmF0ZWQsdGhpcykub24oXCJkaXNhYmxlZFwiLHRoaXMuX2hhbmRsZXJEZWFjdGl2YXRlZCx0aGlzKX0sX2RldGVjdElPUzpmdW5jdGlvbigpe3JldHVybi9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhdC5NU1N0cmVhbX0sX2NyZWF0ZUJ1dHRvbjpmdW5jdGlvbih0KXt2YXIgZT1MLkRvbVV0aWwuY3JlYXRlKFwiYVwiLHQuY2xhc3NOYW1lfHxcIlwiLHQuY29udGFpbmVyKSxpPUwuRG9tVXRpbC5jcmVhdGUoXCJzcGFuXCIsXCJzci1vbmx5XCIsdC5jb250YWluZXIpO2UuaHJlZj1cIiNcIixlLmFwcGVuZENoaWxkKGkpLHQudGl0bGUmJihlLnRpdGxlPXQudGl0bGUsaS5pbm5lckhUTUw9dC50aXRsZSksdC50ZXh0JiYoZS5pbm5lckhUTUw9dC50ZXh0LGkuaW5uZXJIVE1MPXQudGV4dCk7dmFyIG89dGhpcy5fZGV0ZWN0SU9TKCk/XCJ0b3VjaHN0YXJ0XCI6XCJjbGlja1wiO3JldHVybiBMLkRvbUV2ZW50Lm9uKGUsXCJjbGlja1wiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vbihlLFwibW91c2Vkb3duXCIsTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pLm9uKGUsXCJkYmxjbGlja1wiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vbihlLFwidG91Y2hzdGFydFwiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vbihlLFwiY2xpY2tcIixMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KS5vbihlLG8sdC5jYWxsYmFjayx0LmNvbnRleHQpLGV9LF9kaXNwb3NlQnV0dG9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5fZGV0ZWN0SU9TKCk/XCJ0b3VjaHN0YXJ0XCI6XCJjbGlja1wiO0wuRG9tRXZlbnQub2ZmKHQsXCJjbGlja1wiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vZmYodCxcIm1vdXNlZG93blwiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vZmYodCxcImRibGNsaWNrXCIsTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pLm9mZih0LFwidG91Y2hzdGFydFwiLEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKS5vZmYodCxcImNsaWNrXCIsTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCkub2ZmKHQsaSxlKX0sX2hhbmRsZXJBY3RpdmF0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlKCksdGhpcy5fYWN0aXZlTW9kZT10aGlzLl9tb2Rlc1t0LmhhbmRsZXJdLEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbixcImxlYWZsZXQtZHJhdy10b29sYmFyLWJ1dHRvbi1lbmFibGVkXCIpLHRoaXMuX3Nob3dBY3Rpb25zVG9vbGJhcigpLHRoaXMuZmlyZShcImVuYWJsZVwiKX0sX2hhbmRsZXJEZWFjdGl2YXRlZDpmdW5jdGlvbigpe3RoaXMuX2hpZGVBY3Rpb25zVG9vbGJhcigpLEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbixcImxlYWZsZXQtZHJhdy10b29sYmFyLWJ1dHRvbi1lbmFibGVkXCIpLHRoaXMuX2FjdGl2ZU1vZGU9bnVsbCx0aGlzLmZpcmUoXCJkaXNhYmxlXCIpfSxfY3JlYXRlQWN0aW9uczpmdW5jdGlvbih0KXt2YXIgZSxpLG8sYSxuPXRoaXMuX2FjdGlvbnNDb250YWluZXIscz10aGlzLmdldEFjdGlvbnModCkscj1zLmxlbmd0aDtmb3IoaT0wLG89dGhpcy5fYWN0aW9uQnV0dG9ucy5sZW5ndGg7aTxvO2krKyl0aGlzLl9kaXNwb3NlQnV0dG9uKHRoaXMuX2FjdGlvbkJ1dHRvbnNbaV0uYnV0dG9uLHRoaXMuX2FjdGlvbkJ1dHRvbnNbaV0uY2FsbGJhY2spO2Zvcih0aGlzLl9hY3Rpb25CdXR0b25zPVtdO24uZmlyc3RDaGlsZDspbi5yZW1vdmVDaGlsZChuLmZpcnN0Q2hpbGQpO2Zvcih2YXIgbD0wO2w8cjtsKyspXCJlbmFibGVkXCJpbiBzW2xdJiYhc1tsXS5lbmFibGVkfHwoZT1MLkRvbVV0aWwuY3JlYXRlKFwibGlcIixcIlwiLG4pLGE9dGhpcy5fY3JlYXRlQnV0dG9uKHt0aXRsZTpzW2xdLnRpdGxlLHRleHQ6c1tsXS50ZXh0LGNvbnRhaW5lcjplLGNhbGxiYWNrOnNbbF0uY2FsbGJhY2ssY29udGV4dDpzW2xdLmNvbnRleHR9KSx0aGlzLl9hY3Rpb25CdXR0b25zLnB1c2goe2J1dHRvbjphLGNhbGxiYWNrOnNbbF0uY2FsbGJhY2t9KSl9LF9zaG93QWN0aW9uc1Rvb2xiYXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbkluZGV4LGU9dGhpcy5fbGFzdEJ1dHRvbkluZGV4LGk9dGhpcy5fYWN0aXZlTW9kZS5idXR0b24ub2Zmc2V0VG9wLTE7dGhpcy5fY3JlYXRlQWN0aW9ucyh0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIpLHRoaXMuX2FjdGlvbnNDb250YWluZXIuc3R5bGUudG9wPWkrXCJweFwiLDA9PT10JiYoTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3Rvb2xiYXJDb250YWluZXIsXCJsZWFmbGV0LWRyYXctdG9vbGJhci1ub3RvcFwiKSxMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fYWN0aW9uc0NvbnRhaW5lcixcImxlYWZsZXQtZHJhdy1hY3Rpb25zLXRvcFwiKSksdD09PWUmJihMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbGJhckNvbnRhaW5lcixcImxlYWZsZXQtZHJhdy10b29sYmFyLW5vYm90dG9tXCIpLEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLFwibGVhZmxldC1kcmF3LWFjdGlvbnMtYm90dG9tXCIpKSx0aGlzLl9hY3Rpb25zQ29udGFpbmVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5UT09MQkFST1BFTkVEKX0sX2hpZGVBY3Rpb25zVG9vbGJhcjpmdW5jdGlvbigpe3RoaXMuX2FjdGlvbnNDb250YWluZXIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbGJhckNvbnRhaW5lcixcImxlYWZsZXQtZHJhdy10b29sYmFyLW5vdG9wXCIpLEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLFwibGVhZmxldC1kcmF3LXRvb2xiYXItbm9ib3R0b21cIiksTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FjdGlvbnNDb250YWluZXIsXCJsZWFmbGV0LWRyYXctYWN0aW9ucy10b3BcIiksTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FjdGlvbnNDb250YWluZXIsXCJsZWFmbGV0LWRyYXctYWN0aW9ucy1ib3R0b21cIiksdGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LlRPT0xCQVJDTE9TRUQpfX0pLEwuRHJhdz1MLkRyYXd8fHt9LEwuRHJhdy5Ub29sdGlwPUwuQ2xhc3MuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX3BvcHVwUGFuZT10Ll9wYW5lcy5wb3B1cFBhbmUsdGhpcy5fdmlzaWJsZT0hMSx0aGlzLl9jb250YWluZXI9dC5vcHRpb25zLmRyYXdDb250cm9sVG9vbHRpcHM/TC5Eb21VdGlsLmNyZWF0ZShcImRpdlwiLFwibGVhZmxldC1kcmF3LXRvb2x0aXBcIix0aGlzLl9wb3B1cFBhbmUpOm51bGwsdGhpcy5fc2luZ2xlTGluZUxhYmVsPSExLHRoaXMuX21hcC5vbihcIm1vdXNlb3V0XCIsdGhpcy5fb25Nb3VzZU91dCx0aGlzKX0sZGlzcG9zZTpmdW5jdGlvbigpe3RoaXMuX21hcC5vZmYoXCJtb3VzZW91dFwiLHRoaXMuX29uTW91c2VPdXQsdGhpcyksdGhpcy5fY29udGFpbmVyJiYodGhpcy5fcG9wdXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lciksdGhpcy5fY29udGFpbmVyPW51bGwpfSx1cGRhdGVDb250ZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb250YWluZXI/KHQuc3VidGV4dD10LnN1YnRleHR8fFwiXCIsMCE9PXQuc3VidGV4dC5sZW5ndGh8fHRoaXMuX3NpbmdsZUxpbmVMYWJlbD90LnN1YnRleHQubGVuZ3RoPjAmJnRoaXMuX3NpbmdsZUxpbmVMYWJlbCYmKEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWRyYXctdG9vbHRpcC1zaW5nbGVcIiksdGhpcy5fc2luZ2xlTGluZUxhYmVsPSExKTooTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtZHJhdy10b29sdGlwLXNpbmdsZVwiKSx0aGlzLl9zaW5nbGVMaW5lTGFiZWw9ITApLHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUw9KHQuc3VidGV4dC5sZW5ndGg+MD8nPHNwYW4gY2xhc3M9XCJsZWFmbGV0LWRyYXctdG9vbHRpcC1zdWJ0ZXh0XCI+Jyt0LnN1YnRleHQrXCI8L3NwYW4+PGJyIC8+XCI6XCJcIikrXCI8c3Bhbj5cIit0LnRleHQrXCI8L3NwYW4+XCIsdC50ZXh0fHx0LnN1YnRleHQ/KHRoaXMuX3Zpc2libGU9ITAsdGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9XCJpbmhlcml0XCIpOih0aGlzLl92aXNpYmxlPSExLHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIpLHRoaXMpOnRoaXN9LHVwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodCksaT10aGlzLl9jb250YWluZXI7cmV0dXJuIHRoaXMuX2NvbnRhaW5lciYmKHRoaXMuX3Zpc2libGUmJihpLnN0eWxlLnZpc2liaWxpdHk9XCJpbmhlcml0XCIpLEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpLGUpKSx0aGlzfSxzaG93QXNFcnJvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXImJkwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWVycm9yLWRyYXctdG9vbHRpcFwiKSx0aGlzfSxyZW1vdmVFcnJvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXImJkwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWVycm9yLWRyYXctdG9vbHRpcFwiKSx0aGlzfSxfb25Nb3VzZU91dDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lciYmKHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIpfX0pLEwuRHJhd1Rvb2xiYXI9TC5Ub29sYmFyLmV4dGVuZCh7c3RhdGljczp7VFlQRTpcImRyYXdcIn0sb3B0aW9uczp7cG9seWxpbmU6e30scG9seWdvbjp7fSxyZWN0YW5nbGU6e30sY2lyY2xlOnt9LG1hcmtlcjp7fSxjaXJjbGVtYXJrZXI6e319LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHRoaXMub3B0aW9ucyl0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoZSkmJnRbZV0mJih0W2VdPUwuZXh0ZW5kKHt9LHRoaXMub3B0aW9uc1tlXSx0W2VdKSk7dGhpcy5fdG9vbGJhckNsYXNzPVwibGVhZmxldC1kcmF3LWRyYXdcIixMLlRvb2xiYXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLHQpfSxnZXRNb2RlSGFuZGxlcnM6ZnVuY3Rpb24odCl7cmV0dXJuW3tlbmFibGVkOnRoaXMub3B0aW9ucy5wb2x5bGluZSxoYW5kbGVyOm5ldyBMLkRyYXcuUG9seWxpbmUodCx0aGlzLm9wdGlvbnMucG9seWxpbmUpLHRpdGxlOkwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnBvbHlsaW5lfSx7ZW5hYmxlZDp0aGlzLm9wdGlvbnMucG9seWdvbixoYW5kbGVyOm5ldyBMLkRyYXcuUG9seWdvbih0LHRoaXMub3B0aW9ucy5wb2x5Z29uKSx0aXRsZTpMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYnV0dG9ucy5wb2x5Z29ufSx7ZW5hYmxlZDp0aGlzLm9wdGlvbnMucmVjdGFuZ2xlLGhhbmRsZXI6bmV3IEwuRHJhdy5SZWN0YW5nbGUodCx0aGlzLm9wdGlvbnMucmVjdGFuZ2xlKSx0aXRsZTpMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYnV0dG9ucy5yZWN0YW5nbGV9LHtlbmFibGVkOnRoaXMub3B0aW9ucy5jaXJjbGUsaGFuZGxlcjpuZXcgTC5EcmF3LkNpcmNsZSh0LHRoaXMub3B0aW9ucy5jaXJjbGUpLHRpdGxlOkwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZX0se2VuYWJsZWQ6dGhpcy5vcHRpb25zLm1hcmtlcixoYW5kbGVyOm5ldyBMLkRyYXcuTWFya2VyKHQsdGhpcy5vcHRpb25zLm1hcmtlciksdGl0bGU6TC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmJ1dHRvbnMubWFya2VyfSx7ZW5hYmxlZDp0aGlzLm9wdGlvbnMuY2lyY2xlbWFya2VyLGhhbmRsZXI6bmV3IEwuRHJhdy5DaXJjbGVNYXJrZXIodCx0aGlzLm9wdGlvbnMuY2lyY2xlbWFya2VyKSx0aXRsZTpMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYnV0dG9ucy5jaXJjbGVtYXJrZXJ9XX0sZ2V0QWN0aW9uczpmdW5jdGlvbih0KXtyZXR1cm5be2VuYWJsZWQ6dC5jb21wbGV0ZVNoYXBlLHRpdGxlOkwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5maW5pc2gudGl0bGUsdGV4dDpMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuZmluaXNoLnRleHQsY2FsbGJhY2s6dC5jb21wbGV0ZVNoYXBlLGNvbnRleHQ6dH0se2VuYWJsZWQ6dC5kZWxldGVMYXN0VmVydGV4LHRpdGxlOkwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci51bmRvLnRpdGxlLHRleHQ6TC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLnVuZG8udGV4dCxjYWxsYmFjazp0LmRlbGV0ZUxhc3RWZXJ0ZXgsY29udGV4dDp0fSx7dGl0bGU6TC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmFjdGlvbnMudGl0bGUsdGV4dDpMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYWN0aW9ucy50ZXh0LGNhbGxiYWNrOnRoaXMuZGlzYWJsZSxjb250ZXh0OnRoaXN9XX0sc2V0T3B0aW9uczpmdW5jdGlvbih0KXtMLnNldE9wdGlvbnModGhpcyx0KTtmb3IodmFyIGUgaW4gdGhpcy5fbW9kZXMpdGhpcy5fbW9kZXMuaGFzT3duUHJvcGVydHkoZSkmJnQuaGFzT3duUHJvcGVydHkoZSkmJnRoaXMuX21vZGVzW2VdLmhhbmRsZXIuc2V0T3B0aW9ucyh0W2VdKX19KSxMLkVkaXRUb29sYmFyPUwuVG9vbGJhci5leHRlbmQoe3N0YXRpY3M6e1RZUEU6XCJlZGl0XCJ9LG9wdGlvbnM6e2VkaXQ6e3NlbGVjdGVkUGF0aE9wdGlvbnM6e2Rhc2hBcnJheTpcIjEwLCAxMFwiLGZpbGw6ITAsZmlsbENvbG9yOlwiI2ZlNTdhMVwiLGZpbGxPcGFjaXR5Oi4xLG1haW50YWluQ29sb3I6ITF9fSxyZW1vdmU6e30scG9seTpudWxsLGZlYXR1cmVHcm91cDpudWxsfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3QuZWRpdCYmKHZvaWQgMD09PXQuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zJiYodC5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnM9dGhpcy5vcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyksdC5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnM9TC5leHRlbmQoe30sdGhpcy5vcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyx0LmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucykpLHQucmVtb3ZlJiYodC5yZW1vdmU9TC5leHRlbmQoe30sdGhpcy5vcHRpb25zLnJlbW92ZSx0LnJlbW92ZSkpLHQucG9seSYmKHQucG9seT1MLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMucG9seSx0LnBvbHkpKSx0aGlzLl90b29sYmFyQ2xhc3M9XCJsZWFmbGV0LWRyYXctZWRpdFwiLEwuVG9vbGJhci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdCksdGhpcy5fc2VsZWN0ZWRGZWF0dXJlQ291bnQ9MH0sZ2V0TW9kZUhhbmRsZXJzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXA7cmV0dXJuW3tlbmFibGVkOnRoaXMub3B0aW9ucy5lZGl0LGhhbmRsZXI6bmV3IEwuRWRpdFRvb2xiYXIuRWRpdCh0LHtmZWF0dXJlR3JvdXA6ZSxzZWxlY3RlZFBhdGhPcHRpb25zOnRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnMscG9seTp0aGlzLm9wdGlvbnMucG9seX0pLHRpdGxlOkwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXR9LHtlbmFibGVkOnRoaXMub3B0aW9ucy5yZW1vdmUsaGFuZGxlcjpuZXcgTC5FZGl0VG9vbGJhci5EZWxldGUodCx7ZmVhdHVyZUdyb3VwOmV9KSx0aXRsZTpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmV9XX0sZ2V0QWN0aW9uczpmdW5jdGlvbih0KXt2YXIgZT1be3RpdGxlOkwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLnNhdmUudGl0bGUsdGV4dDpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5zYXZlLnRleHQsY2FsbGJhY2s6dGhpcy5fc2F2ZSxjb250ZXh0OnRoaXN9LHt0aXRsZTpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jYW5jZWwudGl0bGUsdGV4dDpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYWN0aW9ucy5jYW5jZWwudGV4dCxjYWxsYmFjazp0aGlzLmRpc2FibGUsY29udGV4dDp0aGlzfV07cmV0dXJuIHQucmVtb3ZlQWxsTGF5ZXJzJiZlLnB1c2goe3RpdGxlOkwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNsZWFyQWxsLnRpdGxlLHRleHQ6TC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmFjdGlvbnMuY2xlYXJBbGwudGV4dCxjYWxsYmFjazp0aGlzLl9jbGVhckFsbExheWVycyxjb250ZXh0OnRoaXN9KSxlfSxhZGRUb29sYmFyOmZ1bmN0aW9uKHQpe3ZhciBlPUwuVG9vbGJhci5wcm90b3R5cGUuYWRkVG9vbGJhci5jYWxsKHRoaXMsdCk7cmV0dXJuIHRoaXMuX2NoZWNrRGlzYWJsZWQoKSx0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLm9uKFwibGF5ZXJhZGQgbGF5ZXJyZW1vdmVcIix0aGlzLl9jaGVja0Rpc2FibGVkLHRoaXMpLGV9LHJlbW92ZVRvb2xiYXI6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLm9mZihcImxheWVyYWRkIGxheWVycmVtb3ZlXCIsdGhpcy5fY2hlY2tEaXNhYmxlZCx0aGlzKSxMLlRvb2xiYXIucHJvdG90eXBlLnJlbW92ZVRvb2xiYXIuY2FsbCh0aGlzKX0sZGlzYWJsZTpmdW5jdGlvbigpe3RoaXMuZW5hYmxlZCgpJiYodGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLnJldmVydExheWVycygpLEwuVG9vbGJhci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpKX0sX3NhdmU6ZnVuY3Rpb24oKXt0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuc2F2ZSgpLHRoaXMuX2FjdGl2ZU1vZGUmJnRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCl9LF9jbGVhckFsbExheWVyczpmdW5jdGlvbigpe3RoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5yZW1vdmVBbGxMYXllcnMoKSx0aGlzLl9hY3RpdmVNb2RlJiZ0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuZGlzYWJsZSgpfSxfY2hlY2tEaXNhYmxlZDpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5vcHRpb25zLmZlYXR1cmVHcm91cCxpPTAhPT1lLmdldExheWVycygpLmxlbmd0aDt0aGlzLm9wdGlvbnMuZWRpdCYmKHQ9dGhpcy5fbW9kZXNbTC5FZGl0VG9vbGJhci5FZGl0LlRZUEVdLmJ1dHRvbixpP0wuRG9tVXRpbC5yZW1vdmVDbGFzcyh0LFwibGVhZmxldC1kaXNhYmxlZFwiKTpMLkRvbVV0aWwuYWRkQ2xhc3ModCxcImxlYWZsZXQtZGlzYWJsZWRcIiksdC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLGk/TC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmJ1dHRvbnMuZWRpdDpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5lZGl0RGlzYWJsZWQpKSx0aGlzLm9wdGlvbnMucmVtb3ZlJiYodD10aGlzLl9tb2Rlc1tMLkVkaXRUb29sYmFyLkRlbGV0ZS5UWVBFXS5idXR0b24saT9MLkRvbVV0aWwucmVtb3ZlQ2xhc3ModCxcImxlYWZsZXQtZGlzYWJsZWRcIik6TC5Eb21VdGlsLmFkZENsYXNzKHQsXCJsZWFmbGV0LWRpc2FibGVkXCIpLHQuc2V0QXR0cmlidXRlKFwidGl0bGVcIixpP0wuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLnJlbW92ZTpMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVEaXNhYmxlZCkpfX0pLEwuRWRpdFRvb2xiYXIuRWRpdD1MLkhhbmRsZXIuZXh0ZW5kKHtzdGF0aWNzOntUWVBFOlwiZWRpdFwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7aWYoTC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyx0KSxMLnNldE9wdGlvbnModGhpcyxlKSx0aGlzLl9mZWF0dXJlR3JvdXA9ZS5mZWF0dXJlR3JvdXAsISh0aGlzLl9mZWF0dXJlR3JvdXAgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkpdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5mZWF0dXJlR3JvdXAgbXVzdCBiZSBhIEwuRmVhdHVyZUdyb3VwXCIpO3RoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcz17fSx0aGlzLnR5cGU9TC5FZGl0VG9vbGJhci5FZGl0LlRZUEU7dmFyIGk9TC52ZXJzaW9uLnNwbGl0KFwiLlwiKTsxPT09cGFyc2VJbnQoaVswXSwxMCkmJnBhcnNlSW50KGlbMV0sMTApPj0yP0wuRWRpdFRvb2xiYXIuRWRpdC5pbmNsdWRlKEwuRXZlbnRlZC5wcm90b3R5cGUpOkwuRWRpdFRvb2xiYXIuRWRpdC5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKX0sZW5hYmxlOmZ1bmN0aW9uKCl7IXRoaXMuX2VuYWJsZWQmJnRoaXMuX2hhc0F2YWlsYWJsZUxheWVycygpJiYodGhpcy5maXJlKFwiZW5hYmxlZFwiLHtoYW5kbGVyOnRoaXMudHlwZX0pLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5FRElUU1RBUlQse2hhbmRsZXI6dGhpcy50eXBlfSksTC5IYW5kbGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKSx0aGlzLl9mZWF0dXJlR3JvdXAub24oXCJsYXllcmFkZFwiLHRoaXMuX2VuYWJsZUxheWVyRWRpdCx0aGlzKS5vbihcImxheWVycmVtb3ZlXCIsdGhpcy5fZGlzYWJsZUxheWVyRWRpdCx0aGlzKSl9LGRpc2FibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkJiYodGhpcy5fZmVhdHVyZUdyb3VwLm9mZihcImxheWVyYWRkXCIsdGhpcy5fZW5hYmxlTGF5ZXJFZGl0LHRoaXMpLm9mZihcImxheWVycmVtb3ZlXCIsdGhpcy5fZGlzYWJsZUxheWVyRWRpdCx0aGlzKSxMLkhhbmRsZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKSx0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVFNUT1Ase2hhbmRsZXI6dGhpcy50eXBlfSksdGhpcy5maXJlKFwiZGlzYWJsZWRcIix7aGFuZGxlcjp0aGlzLnR5cGV9KSl9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwO3QmJih0LmdldENvbnRhaW5lcigpLmZvY3VzKCksdGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckVkaXQsdGhpcyksdGhpcy5fdG9vbHRpcD1uZXcgTC5EcmF3LlRvb2x0aXAodGhpcy5fbWFwKSx0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6TC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxzdWJ0ZXh0OkwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHR9KSx0Ll9lZGl0VG9vbHRpcD10aGlzLl90b29sdGlwLHRoaXMuX3VwZGF0ZVRvb2x0aXAoKSx0aGlzLl9tYXAub24oXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vbihcInRvdWNobW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLm9uKFwiTVNQb2ludGVyTW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLm9uKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLHRoaXMuX3VwZGF0ZVRvb2x0aXAsdGhpcykpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX21hcCYmKHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIodGhpcy5fZGlzYWJsZUxheWVyRWRpdCx0aGlzKSx0aGlzLl91bmVkaXRlZExheWVyUHJvcHM9e30sdGhpcy5fdG9vbHRpcC5kaXNwb3NlKCksdGhpcy5fdG9vbHRpcD1udWxsLHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vZmYoXCJ0b3VjaG1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSx0aGlzKS5vZmYoXCJNU1BvaW50ZXJNb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUsdGhpcykub2ZmKEwuRHJhdy5FdmVudC5FRElUVkVSVEVYLHRoaXMuX3VwZGF0ZVRvb2x0aXAsdGhpcykpfSxyZXZlcnRMYXllcnM6ZnVuY3Rpb24oKXt0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uKHQpe3RoaXMuX3JldmVydExheWVyKHQpfSx0aGlzKX0sc2F2ZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBMLkxheWVyR3JvdXA7dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcihmdW5jdGlvbihlKXtlLmVkaXRlZCYmKHQuYWRkTGF5ZXIoZSksZS5lZGl0ZWQ9ITEpfSksdGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkVESVRFRCx7bGF5ZXJzOnR9KX0sX2JhY2t1cExheWVyOmZ1bmN0aW9uKHQpe3ZhciBlPUwuVXRpbC5zdGFtcCh0KTt0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbZV18fCh0IGluc3RhbmNlb2YgTC5Qb2x5bGluZXx8dCBpbnN0YW5jZW9mIEwuUG9seWdvbnx8dCBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlP3RoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tlXT17bGF0bG5nczpMLkxhdExuZ1V0aWwuY2xvbmVMYXRMbmdzKHQuZ2V0TGF0TG5ncygpKX06dCBpbnN0YW5jZW9mIEwuQ2lyY2xlP3RoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tlXT17bGF0bG5nOkwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZyh0LmdldExhdExuZygpKSxyYWRpdXM6dC5nZXRSYWRpdXMoKX06KHQgaW5zdGFuY2VvZiBMLk1hcmtlcnx8dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyKSYmKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tlXT17bGF0bG5nOkwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZyh0LmdldExhdExuZygpKX0pKX0sX2dldFRvb2x0aXBUZXh0OmZ1bmN0aW9uKCl7cmV0dXJue3RleHQ6TC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxzdWJ0ZXh0OkwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdC50b29sdGlwLnN1YnRleHR9fSxfdXBkYXRlVG9vbHRpcDpmdW5jdGlvbigpe3RoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKX0sX3JldmVydExheWVyOmZ1bmN0aW9uKHQpe3ZhciBlPUwuVXRpbC5zdGFtcCh0KTt0LmVkaXRlZD0hMSx0aGlzLl91bmVkaXRlZExheWVyUHJvcHMuaGFzT3duUHJvcGVydHkoZSkmJih0IGluc3RhbmNlb2YgTC5Qb2x5bGluZXx8dCBpbnN0YW5jZW9mIEwuUG9seWdvbnx8dCBpbnN0YW5jZW9mIEwuUmVjdGFuZ2xlP3Quc2V0TGF0TG5ncyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbZV0ubGF0bG5ncyk6dCBpbnN0YW5jZW9mIEwuQ2lyY2xlPyh0LnNldExhdExuZyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbZV0ubGF0bG5nKSx0LnNldFJhZGl1cyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbZV0ucmFkaXVzKSk6KHQgaW5zdGFuY2VvZiBMLk1hcmtlcnx8dCBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyKSYmdC5zZXRMYXRMbmcodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2VdLmxhdGxuZyksdC5maXJlKFwicmV2ZXJ0LWVkaXRlZFwiLHtsYXllcjp0fSkpfSxfZW5hYmxlTGF5ZXJFZGl0OmZ1bmN0aW9uKHQpe3ZhciBlLGksbz10LmxheWVyfHx0LnRhcmdldHx8dDt0aGlzLl9iYWNrdXBMYXllcihvKSx0aGlzLm9wdGlvbnMucG9seSYmKGk9TC5VdGlsLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMucG9seSksby5vcHRpb25zLnBvbHk9aSksdGhpcy5vcHRpb25zLnNlbGVjdGVkUGF0aE9wdGlvbnMmJihlPUwuVXRpbC5leHRlbmQoe30sdGhpcy5vcHRpb25zLnNlbGVjdGVkUGF0aE9wdGlvbnMpLGUubWFpbnRhaW5Db2xvciYmKGUuY29sb3I9by5vcHRpb25zLmNvbG9yLGUuZmlsbENvbG9yPW8ub3B0aW9ucy5maWxsQ29sb3IpLG8ub3B0aW9ucy5vcmlnaW5hbD1MLmV4dGVuZCh7fSxvLm9wdGlvbnMpLG8ub3B0aW9ucy5lZGl0aW5nPWUpLG8gaW5zdGFuY2VvZiBMLk1hcmtlcj8oby5lZGl0aW5nJiZvLmVkaXRpbmcuZW5hYmxlKCksby5kcmFnZ2luZy5lbmFibGUoKSxvLm9uKFwiZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCkub24oXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKS5vbihcIk1TUG9pbnRlck1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKS5vbihcInRvdWNoZW5kXCIsdGhpcy5fb25NYXJrZXJEcmFnRW5kLHRoaXMpLm9uKFwiTVNQb2ludGVyVXBcIix0aGlzLl9vbk1hcmtlckRyYWdFbmQsdGhpcykpOm8uZWRpdGluZy5lbmFibGUoKX0sX2Rpc2FibGVMYXllckVkaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXllcnx8dC50YXJnZXR8fHQ7ZS5lZGl0ZWQ9ITEsZS5lZGl0aW5nJiZlLmVkaXRpbmcuZGlzYWJsZSgpLGRlbGV0ZSBlLm9wdGlvbnMuZWRpdGluZyxkZWxldGUgZS5vcHRpb25zLm9yaWdpbmFsLFxudGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucyYmKGUgaW5zdGFuY2VvZiBMLk1hcmtlcj90aGlzLl90b2dnbGVNYXJrZXJIaWdobGlnaHQoZSk6KGUuc2V0U3R5bGUoZS5vcHRpb25zLnByZXZpb3VzT3B0aW9ucyksZGVsZXRlIGUub3B0aW9ucy5wcmV2aW91c09wdGlvbnMpKSxlIGluc3RhbmNlb2YgTC5NYXJrZXI/KGUuZHJhZ2dpbmcuZGlzYWJsZSgpLGUub2ZmKFwiZHJhZ2VuZFwiLHRoaXMuX29uTWFya2VyRHJhZ0VuZCx0aGlzKS5vZmYoXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKS5vZmYoXCJNU1BvaW50ZXJNb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUsdGhpcykub2ZmKFwidG91Y2hlbmRcIix0aGlzLl9vbk1hcmtlckRyYWdFbmQsdGhpcykub2ZmKFwiTVNQb2ludGVyVXBcIix0aGlzLl9vbk1hcmtlckRyYWdFbmQsdGhpcykpOmUuZWRpdGluZy5kaXNhYmxlKCl9LF9vbk1vdXNlTW92ZTpmdW5jdGlvbih0KXt0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKHQubGF0bG5nKX0sX29uTWFya2VyRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZT10LnRhcmdldDtlLmVkaXRlZD0hMCx0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuRURJVE1PVkUse2xheWVyOmV9KX0sX29uVG91Y2hNb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlPXQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSxpPXRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLG89dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpKTt0LnRhcmdldC5zZXRMYXRMbmcobyl9LF9oYXNBdmFpbGFibGVMYXllcnM6ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMuX2ZlYXR1cmVHcm91cC5nZXRMYXllcnMoKS5sZW5ndGh9fSksTC5FZGl0VG9vbGJhci5EZWxldGU9TC5IYW5kbGVyLmV4dGVuZCh7c3RhdGljczp7VFlQRTpcInJlbW92ZVwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7aWYoTC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyx0KSxMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLGUpLHRoaXMuX2RlbGV0YWJsZUxheWVycz10aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLCEodGhpcy5fZGVsZXRhYmxlTGF5ZXJzIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApKXRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuZmVhdHVyZUdyb3VwIG11c3QgYmUgYSBMLkZlYXR1cmVHcm91cFwiKTt0aGlzLnR5cGU9TC5FZGl0VG9vbGJhci5EZWxldGUuVFlQRTt2YXIgaT1MLnZlcnNpb24uc3BsaXQoXCIuXCIpOzE9PT1wYXJzZUludChpWzBdLDEwKSYmcGFyc2VJbnQoaVsxXSwxMCk+PTI/TC5FZGl0VG9vbGJhci5EZWxldGUuaW5jbHVkZShMLkV2ZW50ZWQucHJvdG90eXBlKTpMLkVkaXRUb29sYmFyLkRlbGV0ZS5pbmNsdWRlKEwuTWl4aW4uRXZlbnRzKX0sZW5hYmxlOmZ1bmN0aW9uKCl7IXRoaXMuX2VuYWJsZWQmJnRoaXMuX2hhc0F2YWlsYWJsZUxheWVycygpJiYodGhpcy5maXJlKFwiZW5hYmxlZFwiLHtoYW5kbGVyOnRoaXMudHlwZX0pLHRoaXMuX21hcC5maXJlKEwuRHJhdy5FdmVudC5ERUxFVEVTVEFSVCx7aGFuZGxlcjp0aGlzLnR5cGV9KSxMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpLHRoaXMuX2RlbGV0YWJsZUxheWVycy5vbihcImxheWVyYWRkXCIsdGhpcy5fZW5hYmxlTGF5ZXJEZWxldGUsdGhpcykub24oXCJsYXllcnJlbW92ZVwiLHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSx0aGlzKSl9LGRpc2FibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkJiYodGhpcy5fZGVsZXRhYmxlTGF5ZXJzLm9mZihcImxheWVyYWRkXCIsdGhpcy5fZW5hYmxlTGF5ZXJEZWxldGUsdGhpcykub2ZmKFwibGF5ZXJyZW1vdmVcIix0aGlzLl9kaXNhYmxlTGF5ZXJEZWxldGUsdGhpcyksTC5IYW5kbGVyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyksdGhpcy5fbWFwLmZpcmUoTC5EcmF3LkV2ZW50LkRFTEVURVNUT1Ase2hhbmRsZXI6dGhpcy50eXBlfSksdGhpcy5maXJlKFwiZGlzYWJsZWRcIix7aGFuZGxlcjp0aGlzLnR5cGV9KSl9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwO3QmJih0LmdldENvbnRhaW5lcigpLmZvY3VzKCksdGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckRlbGV0ZSx0aGlzKSx0aGlzLl9kZWxldGVkTGF5ZXJzPW5ldyBMLkxheWVyR3JvdXAsdGhpcy5fdG9vbHRpcD1uZXcgTC5EcmF3LlRvb2x0aXAodGhpcy5fbWFwKSx0aGlzLl90b29sdGlwLnVwZGF0ZUNvbnRlbnQoe3RleHQ6TC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5yZW1vdmUudG9vbHRpcC50ZXh0fSksdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUsdGhpcykpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX21hcCYmKHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIodGhpcy5fZGlzYWJsZUxheWVyRGVsZXRlLHRoaXMpLHRoaXMuX2RlbGV0ZWRMYXllcnM9bnVsbCx0aGlzLl90b29sdGlwLmRpc3Bvc2UoKSx0aGlzLl90b29sdGlwPW51bGwsdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpKX0scmV2ZXJ0TGF5ZXJzOmZ1bmN0aW9uKCl7dGhpcy5fZGVsZXRlZExheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24odCl7dGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmFkZExheWVyKHQpLHQuZmlyZShcInJldmVydC1kZWxldGVkXCIse2xheWVyOnR9KX0sdGhpcyl9LHNhdmU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAuZmlyZShMLkRyYXcuRXZlbnQuREVMRVRFRCx7bGF5ZXJzOnRoaXMuX2RlbGV0ZWRMYXllcnN9KX0scmVtb3ZlQWxsTGF5ZXJzOmZ1bmN0aW9uKCl7dGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmVhY2hMYXllcihmdW5jdGlvbih0KXt0aGlzLl9yZW1vdmVMYXllcih7bGF5ZXI6dH0pfSx0aGlzKSx0aGlzLnNhdmUoKX0sX2VuYWJsZUxheWVyRGVsZXRlOmZ1bmN0aW9uKHQpeyh0LmxheWVyfHx0LnRhcmdldHx8dCkub24oXCJjbGlja1wiLHRoaXMuX3JlbW92ZUxheWVyLHRoaXMpfSxfZGlzYWJsZUxheWVyRGVsZXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXQubGF5ZXJ8fHQudGFyZ2V0fHx0O2Uub2ZmKFwiY2xpY2tcIix0aGlzLl9yZW1vdmVMYXllcix0aGlzKSx0aGlzLl9kZWxldGVkTGF5ZXJzLnJlbW92ZUxheWVyKGUpfSxfcmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXllcnx8dC50YXJnZXR8fHQ7dGhpcy5fZGVsZXRhYmxlTGF5ZXJzLnJlbW92ZUxheWVyKGUpLHRoaXMuX2RlbGV0ZWRMYXllcnMuYWRkTGF5ZXIoZSksZS5maXJlKFwiZGVsZXRlZFwiKX0sX29uTW91c2VNb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24odC5sYXRsbmcpfSxfaGFzQXZhaWxhYmxlTGF5ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLl9kZWxldGFibGVMYXllcnMuZ2V0TGF5ZXJzKCkubGVuZ3RofX0pfSh3aW5kb3csZG9jdW1lbnQpOyJdLCJuYW1lcyI6WyJ0IiwiZSIsImkiLCJvIiwicGFyZW50RWxlbWVudCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiTCIsImRyYXdWZXJzaW9uIiwiRHJhdyIsImRyYXdMb2NhbCIsImRyYXciLCJ0b29sYmFyIiwiYWN0aW9ucyIsInRpdGxlIiwidGV4dCIsImZpbmlzaCIsInVuZG8iLCJidXR0b25zIiwicG9seWxpbmUiLCJwb2x5Z29uIiwicmVjdGFuZ2xlIiwiY2lyY2xlIiwibWFya2VyIiwiY2lyY2xlbWFya2VyIiwiaGFuZGxlcnMiLCJ0b29sdGlwIiwic3RhcnQiLCJyYWRpdXMiLCJjb250IiwiZW5kIiwiZXJyb3IiLCJzaW1wbGVzaGFwZSIsImVkaXQiLCJzYXZlIiwiY2FuY2VsIiwiY2xlYXJBbGwiLCJlZGl0RGlzYWJsZWQiLCJyZW1vdmUiLCJyZW1vdmVEaXNhYmxlZCIsInN1YnRleHQiLCJFdmVudCIsIkNSRUFURUQiLCJFRElURUQiLCJERUxFVEVEIiwiRFJBV1NUQVJUIiwiRFJBV1NUT1AiLCJEUkFXVkVSVEVYIiwiRURJVFNUQVJUIiwiRURJVE1PVkUiLCJFRElUUkVTSVpFIiwiRURJVFZFUlRFWCIsIkVESVRTVE9QIiwiREVMRVRFU1RBUlQiLCJERUxFVEVTVE9QIiwiVE9PTEJBUk9QRU5FRCIsIlRPT0xCQVJDTE9TRUQiLCJNQVJLRVJDT05URVhUIiwiRmVhdHVyZSIsIkhhbmRsZXIiLCJleHRlbmQiLCJpbml0aWFsaXplIiwiX21hcCIsIl9jb250YWluZXIiLCJfb3ZlcmxheVBhbmUiLCJfcGFuZXMiLCJvdmVybGF5UGFuZSIsIl9wb3B1cFBhbmUiLCJwb3B1cFBhbmUiLCJzaGFwZU9wdGlvbnMiLCJVdGlsIiwib3B0aW9ucyIsInNldE9wdGlvbnMiLCJ2ZXJzaW9uIiwic3BsaXQiLCJwYXJzZUludCIsImluY2x1ZGUiLCJFdmVudGVkIiwicHJvdG90eXBlIiwiTWl4aW4iLCJFdmVudHMiLCJlbmFibGUiLCJfZW5hYmxlZCIsImNhbGwiLCJmaXJlIiwiaGFuZGxlciIsInR5cGUiLCJsYXllclR5cGUiLCJkaXNhYmxlIiwiYWRkSG9va3MiLCJEb21VdGlsIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJnZXRDb250YWluZXIiLCJmb2N1cyIsIl90b29sdGlwIiwiVG9vbHRpcCIsIkRvbUV2ZW50Iiwib24iLCJfY2FuY2VsRHJhd2luZyIsInJlbW92ZUhvb2tzIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsImRpc3Bvc2UiLCJvZmYiLCJfZmlyZUNyZWF0ZWRFdmVudCIsImxheWVyIiwia2V5Q29kZSIsIlBvbHlsaW5lIiwic3RhdGljcyIsIlRZUEUiLCJQb2x5IiwiYWxsb3dJbnRlcnNlY3Rpb24iLCJyZXBlYXRNb2RlIiwiZHJhd0Vycm9yIiwiY29sb3IiLCJ0aW1lb3V0IiwiaWNvbiIsIkRpdkljb24iLCJpY29uU2l6ZSIsIlBvaW50IiwiY2xhc3NOYW1lIiwidG91Y2hJY29uIiwiZ3VpZGVsaW5lRGlzdGFuY2UiLCJtYXhHdWlkZUxpbmVMZW5ndGgiLCJzdHJva2UiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwiZmlsbCIsImNsaWNrYWJsZSIsIm1ldHJpYyIsImZlZXQiLCJuYXV0aWMiLCJzaG93TGVuZ3RoIiwiekluZGV4T2Zmc2V0IiwiZmFjdG9yIiwibWF4UG9pbnRzIiwiQnJvd3NlciIsInRvdWNoIiwibWVzc2FnZSIsIl9tYXJrZXJzIiwiX21hcmtlckdyb3VwIiwiTGF5ZXJHcm91cCIsImFkZExheWVyIiwiX3BvbHkiLCJ1cGRhdGVDb250ZW50IiwiX2dldFRvb2x0aXBUZXh0IiwiX21vdXNlTWFya2VyIiwiZ2V0Q2VudGVyIiwiZGl2SWNvbiIsImljb25BbmNob3IiLCJfb25Nb3VzZU91dCIsIl9vbk1vdXNlTW92ZSIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlVXAiLCJhZGRUbyIsIl9vblpvb21FbmQiLCJfb25Ub3VjaCIsIl9jbGVhckhpZGVFcnJvclRpbWVvdXQiLCJfY2xlYW5VcFNoYXBlIiwicmVtb3ZlTGF5ZXIiLCJfY2xlYXJHdWlkZXMiLCJkZWxldGVMYXN0VmVydGV4IiwibGVuZ3RoIiwicG9wIiwiZ2V0TGF0TG5ncyIsInNwbGljZSIsInNldExhdExuZ3MiLCJfdmVydGV4Q2hhbmdlZCIsImFkZFZlcnRleCIsIm5ld0xhdExuZ0ludGVyc2VjdHMiLCJfc2hvd0Vycm9yVG9vbHRpcCIsIl9lcnJvclNob3duIiwiX2hpZGVFcnJvclRvb2x0aXAiLCJwdXNoIiwiX2NyZWF0ZU1hcmtlciIsImFkZExhdExuZyIsImNvbXBsZXRlU2hhcGUiLCJfc2hhcGVJc1ZhbGlkIiwiX2ZpbmlzaFNoYXBlIiwiX2RlZmF1bHRTaGFwZSIsIl91cGRhdGVHdWlkZSIsIm1vdXNlRXZlbnRUb0xheWVyUG9pbnQiLCJvcmlnaW5hbEV2ZW50IiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2N1cnJlbnRMYXRMbmciLCJfdXBkYXRlVG9vbHRpcCIsInNldExhdExuZyIsInByZXZlbnREZWZhdWx0IiwibGF5ZXJzIiwiX3VwZGF0ZUZpbmlzaEhhbmRsZXIiLCJfdXBkYXRlUnVubmluZ01lYXN1cmUiLCJfY2xpY2tIYW5kbGVkIiwiX3RvdWNoSGFuZGxlZCIsIl9kaXNhYmxlTWFya2VycyIsIl9kaXNhYmxlTmV3TWFya2VycyIsImNsaWVudFgiLCJjbGllbnRZIiwiX3N0YXJ0UG9pbnQiLCJfbW91c2VEb3duT3JpZ2luIiwicG9pbnQiLCJfZW5kUG9pbnQiLCJhIiwiZGlzdGFuY2VUbyIsIm4iLCJfY2FsY3VsYXRlRmluaXNoRGlzdGFuY2UiLCJsYXRsbmciLCJNYXRoIiwiYWJzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIl9lbmFibGVOZXdNYXJrZXJzIiwidG91Y2hlcyIsIlBvbHlnb24iLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiZ2V0TGF0TG5nIiwiTWFya2VyIiwibGF0TG5nVG9MYXllclBvaW50IiwiX2RyYXdHdWlkZSIsInVwZGF0ZVBvc2l0aW9uIiwiZmxvb3IiLCJzcXJ0IiwicG93IiwieCIsInkiLCJzIiwiciIsImwiLCJfZ3VpZGVzQ29udGFpbmVyIiwiY3JlYXRlIiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZXRQb3NpdGlvbiIsIl91cGRhdGVHdWlkZUNvbG9yIiwiY2hpbGROb2RlcyIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsIl9nZXRNZWFzdXJlbWVudFN0cmluZyIsIl9tZWFzdXJlbWVudFJ1bm5pbmdUb3RhbCIsIkdlb21ldHJ5VXRpbCIsImlzVmVyc2lvbjA3eCIsImRpc3RhbmNlIiwicmVhZGFibGVEaXN0YW5jZSIsInByZWNpc2lvbiIsInNob3dBc0Vycm9yIiwic2V0U3R5bGUiLCJfaGlkZUVycm9yVGltZW91dCIsInNldFRpbWVvdXQiLCJiaW5kIiwicmVtb3ZlRXJyb3IiLCJjbGVhclRpbWVvdXQiLCJzaG93QXJlYSIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiX2FyZWEiLCJyZWFkYWJsZUFyZWEiLCJnZW9kZXNpY0FyZWEiLCJTaW1wbGVTaGFwZSIsIl9lbmRMYWJlbFRleHQiLCJfbWFwRHJhZ2dhYmxlIiwiZHJhZ2dpbmciLCJlbmFibGVkIiwiY3Vyc29yIiwiX2luaXRpYWxMYWJlbFRleHQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc2hhcGUiLCJfaXNEcmF3aW5nIiwiX3N0YXJ0TGF0TG5nIiwiX2RyYXdTaGFwZSIsIlJlY3RhbmdsZSIsIl9pc0N1cnJlbnRseVR3b0NsaWNrRHJhd2luZyIsInRhcmdldCIsInNldEJvdW5kcyIsIkxhdExuZ0JvdW5kcyIsImdldEJvdW5kcyIsIkljb24iLCJEZWZhdWx0IiwiX29uQ2xpY2siLCJfbWFya2VyIiwiVG91Y2giLCJDaXJjbGVNYXJrZXIiLCJDaXJjbGUiLCJzaG93UmFkaXVzIiwic2V0UmFkaXVzIiwiZ2V0UmFkaXVzIiwidG9GaXhlZCIsIkVkaXQiLCJfb25EcmFnRW5kIiwiX3RvZ2dsZU1hcmtlckhpZ2hsaWdodCIsImVkaXRlZCIsIl9pY29uIiwiZGlzcGxheSIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJfb2Zmc2V0TWFya2VyIiwiYWRkQ2xhc3MiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiYWRkSW5pdEhvb2siLCJlZGl0aW5nIiwiZWRpdGFibGUiLCJsYXRsbmdzIiwiX2xhdGxuZ3MiLCJfaG9sZXMiLCJjb25jYXQiLCJfdXBkYXRlTGF0TG5ncyIsIl9mbGF0IiwiX2VhY2hWZXJ0ZXhIYW5kbGVyIiwiX3ZlcnRpY2VzSGFuZGxlcnMiLCJfaW5pdEhhbmRsZXJzIiwidXBkYXRlTWFya2VycyIsIlBvbHlWZXJ0aWNlc0VkaXQiLCJwb2x5IiwiX3BhdGgiLCJvcmlnaW5hbCIsImZvckVhY2giLCJfaW5pdE1hcmtlcnMiLCJjbGVhckxheWVycyIsIl9vbk1hcmtlckNsaWNrIiwiX29uQ29udGV4dE1lbnUiLCJfY3JlYXRlTWlkZGxlTWFya2VyIiwiX3VwZGF0ZVByZXZOZXh0IiwiZHJhZ2dhYmxlIiwiX29yaWdMYXRMbmciLCJfaW5kZXgiLCJfb25NYXJrZXJEcmFnU3RhcnQiLCJfb25NYXJrZXJEcmFnIiwiX2ZpcmVFZGl0IiwiX29uVG91Y2hNb3ZlIiwiX3NwbGljZUxhdExuZ3MiLCJhcHBseSIsImFyZ3VtZW50cyIsIl9jb252ZXJ0TGF0TG5ncyIsInJlZHJhdyIsIl9yZW1vdmVNYXJrZXIiLCJfdXBkYXRlSW5kZXhlcyIsIkxhdExuZ1V0aWwiLCJjbG9uZUxhdExuZyIsIl9sYXRsbmciLCJfZWRpdFRvb2x0aXAiLCJpbnRlcnNlY3RzIiwiX21pZGRsZUxlZnQiLCJfZ2V0TWlkZGxlTGF0TG5nIiwiX3ByZXYiLCJfbWlkZGxlUmlnaHQiLCJfbmV4dCIsIl9ib3VuZHMiLCJfc291dGhXZXN0IiwibGF0TG5nIiwiX25vcnRoRWFzdCIsInN0b3BQcm9wYWdhdGlvbiIsImVhY2hMYXllciIsInNldE9wYWNpdHkiLCJsYXQiLCJsbmciLCJwcm9qZWN0IiwidW5wcm9qZWN0IiwiX2FkZCIsIl9kaXZpZGVCeSIsIm1vdmVJY29uIiwicmVzaXplSWNvbiIsInRvdWNoTW92ZUljb24iLCJ0b3VjaFJlc2l6ZUljb24iLCJfdW5iaW5kTWFya2VyIiwiX21vdmVNYXJrZXIiLCJfcmVzaXplTWFya2VycyIsIl9jcmVhdGVNb3ZlTWFya2VyIiwiX2NyZWF0ZVJlc2l6ZU1hcmtlciIsIl9iaW5kTWFya2VyIiwiX29uTWFya2VyRHJhZ0VuZCIsIl9vblRvdWNoU3RhcnQiLCJfb25Ub3VjaEVuZCIsIl9tb3ZlIiwiX3Jlc2l6ZSIsIl9nZXRDb3JuZXJzIiwiX2Nvcm5lckluZGV4IiwiX29wcG9zaXRlQ29ybmVyIiwiX3RvZ2dsZUNvcm5lck1hcmtlcnMiLCJfcmVwb3NpdGlvbkNvcm5lck1hcmtlcnMiLCJsYXRMbmdCb3VuZHMiLCJnZXROb3J0aFdlc3QiLCJnZXROb3J0aEVhc3QiLCJnZXRTb3V0aEVhc3QiLCJnZXRTb3V0aFdlc3QiLCJfZ2V0UmVzaXplTWFya2VyUG9pbnQiLCJfcmFkaXVzIiwiY29zIiwiUEkiLCJlZGl0VG9vbHRpcCIsIk1hcCIsIm1lcmdlT3B0aW9ucyIsInRvdWNoRXh0ZW5kIiwiVG91Y2hFeHRlbmQiLCJfcGFuZSIsIl9kZXRlY3RJRSIsIl9vblRvdWNoQ2FuY2VsIiwiX29uVG91Y2hMZWF2ZSIsIl90b3VjaEV2ZW50IiwicG9pbnRlclR5cGUiLCJfZmlsdGVyQ2xpY2siLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJjb250YWluZXJQb2ludCIsInBhZ2VYIiwicGFnZVkiLCJ0aW1lU3RhbXAiLCJfbGFzdENsaWNrIiwiX3NpbXVsYXRlZENsaWNrIiwiX3NpbXVsYXRlZCIsInN0b3AiLCJfbG9hZGVkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsInN1YnN0cmluZyIsIl9pbml0SW50ZXJhY3Rpb24iLCJhZGRJbnRlcmFjdGl2ZVRhcmdldCIsIl9pbml0SW50ZXJhY3Rpb25MZWdhY3kiLCJfb25Nb3VzZUNsaWNrIiwiX29uS2V5UHJlc3MiLCJfZmlyZU1vdXNlRXZlbnQiLCJNYXJrZXJEcmFnIiwiY2xvbmVMYXRMbmdzIiwiQXJyYXkiLCJpc0FycmF5Iiwia20iLCJoYSIsIm0iLCJtaSIsImFjIiwieWQiLCJmdCIsIm5tIiwic2luIiwiZm9ybWF0dGVkTnVtYmVyIiwicGFyc2VGbG9hdCIsImZvcm1hdCIsIm51bWVyaWMiLCJkZWxpbWl0ZXJzIiwidGhvdXNhbmRzIiwiZGVjaW1hbCIsInJlcGxhY2UiLCJMaW5lVXRpbCIsInNlZ21lbnRzSW50ZXJzZWN0IiwiX2NoZWNrQ291bnRlcmNsb2Nrd2lzZSIsIl9nZXRQcm9qZWN0ZWRQb2ludHMiLCJfdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uIiwiX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZSIsIm5ld1BvaW50SW50ZXJzZWN0cyIsIl9vcmlnaW5hbFBvaW50cyIsIkNvbnRyb2wiLCJwb3NpdGlvbiIsIkVycm9yIiwiX3Rvb2xiYXJzIiwiRHJhd1Rvb2xiYXIiLCJfdG9vbGJhckVuYWJsZWQiLCJFZGl0VG9vbGJhciIsIm9uQWRkIiwiaGFzT3duUHJvcGVydHkiLCJhZGRUb29sYmFyIiwiYXBwZW5kQ2hpbGQiLCJvblJlbW92ZSIsInJlbW92ZVRvb2xiYXIiLCJzZXREcmF3aW5nT3B0aW9ucyIsImRyYXdDb250cm9sVG9vbHRpcHMiLCJkcmF3Q29udHJvbCIsImFkZENvbnRyb2wiLCJUb29sYmFyIiwiQ2xhc3MiLCJfbW9kZXMiLCJfYWN0aW9uQnV0dG9ucyIsIl9hY3RpdmVNb2RlIiwiX3Rvb2xiYXJDbGFzcyIsImdldE1vZGVIYW5kbGVycyIsIl90b29sYmFyQ29udGFpbmVyIiwiX2luaXRNb2RlSGFuZGxlciIsIl9sYXN0QnV0dG9uSW5kZXgiLCJfYWN0aW9uc0NvbnRhaW5lciIsIl9kaXNwb3NlQnV0dG9uIiwiYnV0dG9uIiwiX2hhbmRsZXJBY3RpdmF0ZWQiLCJfaGFuZGxlckRlYWN0aXZhdGVkIiwiY2FsbGJhY2siLCJfY3JlYXRlQnV0dG9uIiwiY29udGFpbmVyIiwiY29udGV4dCIsImJ1dHRvbkluZGV4IiwiX2RldGVjdElPUyIsInRlc3QiLCJNU1N0cmVhbSIsImhyZWYiLCJpbm5lckhUTUwiLCJfc2hvd0FjdGlvbnNUb29sYmFyIiwiX2hpZGVBY3Rpb25zVG9vbGJhciIsIl9jcmVhdGVBY3Rpb25zIiwiZ2V0QWN0aW9ucyIsIm9mZnNldFRvcCIsInRvcCIsIl92aXNpYmxlIiwiX3NpbmdsZUxpbmVMYWJlbCIsInZpc2liaWxpdHkiLCJzZWxlY3RlZFBhdGhPcHRpb25zIiwiZGFzaEFycmF5IiwibWFpbnRhaW5Db2xvciIsImZlYXR1cmVHcm91cCIsIl9zZWxlY3RlZEZlYXR1cmVDb3VudCIsIkRlbGV0ZSIsIl9zYXZlIiwicmVtb3ZlQWxsTGF5ZXJzIiwiX2NsZWFyQWxsTGF5ZXJzIiwiX2NoZWNrRGlzYWJsZWQiLCJyZXZlcnRMYXllcnMiLCJnZXRMYXllcnMiLCJzZXRBdHRyaWJ1dGUiLCJfZmVhdHVyZUdyb3VwIiwiRmVhdHVyZUdyb3VwIiwiX3VuZWRpdGVkTGF5ZXJQcm9wcyIsIl9oYXNBdmFpbGFibGVMYXllcnMiLCJfZW5hYmxlTGF5ZXJFZGl0IiwiX2Rpc2FibGVMYXllckVkaXQiLCJfcmV2ZXJ0TGF5ZXIiLCJfYmFja3VwTGF5ZXIiLCJzdGFtcCIsIl9zZWxlY3RlZFBhdGhPcHRpb25zIiwicHJldmlvdXNPcHRpb25zIiwiY2hhbmdlZFRvdWNoZXMiLCJfZGVsZXRhYmxlTGF5ZXJzIiwiX2VuYWJsZUxheWVyRGVsZXRlIiwiX2Rpc2FibGVMYXllckRlbGV0ZSIsIl9kZWxldGVkTGF5ZXJzIiwiX3JlbW92ZUxheWVyIiwid2luZG93IiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUNELENBQUMsU0FBU0EsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7SUFBRSxTQUFTQyxFQUFFSCxDQUFDLEVBQUNDLENBQUM7UUFBRSxNQUFLLEFBQUNELENBQUFBLElBQUVBLEVBQUVJLGFBQWEsQUFBRCxLQUFJ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LEVBQUV3RyxLQUFLLElBQUV4RyxFQUFFOFEsTUFBTSxJQUFFOVEsQ0FBQUEsRUFBR2lHLEVBQUUsQ0FBQyxTQUFRLElBQUksQ0FBQ2diLFlBQVksRUFBQyxJQUFJO1FBQUM7UUFBRUYscUJBQW9CLFNBQVMvZ0IsQ0FBQztZQUFFLElBQUlDLElBQUVELEVBQUV3RyxLQUFLLElBQUV4RyxFQUFFOFEsTUFBTSxJQUFFOVE7WUFBRUMsRUFBRXFHLEdBQUcsQ0FBQyxTQUFRLElBQUksQ0FBQzJhLFlBQVksRUFBQyxJQUFJLEdBQUUsSUFBSSxDQUFDRCxjQUFjLENBQUNsWCxXQUFXLENBQUM3SjtRQUFFO1FBQUVnaEIsY0FBYSxTQUFTamhCLENBQUM7WUFBRSxJQUFJQyxJQUFFRCxFQUFFd0csS0FBSyxJQUFFeEcsRUFBRThRLE1BQU0sSUFBRTlRO1lBQUUsSUFBSSxDQUFDNmdCLGdCQUFnQixDQUFDL1csV0FBVyxDQUFDN0osSUFBRyxJQUFJLENBQUMrZ0IsY0FBYyxDQUFDblksUUFBUSxDQUFDNUksSUFBR0EsRUFBRW1GLElBQUksQ0FBQztRQUFVO1FBQUVrRSxjQUFhLFNBQVN0SixDQUFDO1lBQUUsSUFBSSxDQUFDOEYsUUFBUSxDQUFDMEgsY0FBYyxDQUFDeE4sRUFBRTRNLE1BQU07UUFBQztRQUFFd1QscUJBQW9CO1lBQVcsT0FBTyxNQUFJLElBQUksQ0FBQ1MsZ0JBQWdCLENBQUNkLFNBQVMsR0FBRzlWLE1BQU07UUFBQTtJQUFDO0FBQUUsRUFBRWlYLFFBQU9DIiwiZmlsZSI6IihhcHAtcGFnZXMtYnJvd3NlcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    var version = \"1.9.4\";\n    /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */ // @function extend(dest: Object, src?: Object): Object\n    // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n    function extend(dest) {\n        var i, j, len, src;\n        for(j = 1, len = arguments.length; j < len; j++){\n            src = arguments[j];\n            for(i in src){\n                dest[i] = src[i];\n            }\n        }\n        return dest;\n    }\n    // @function create(proto: Object, properties?: Object): Object\n    // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n    var create$2 = Object.create || function() {\n        function F() {}\n        return function(proto) {\n            F.prototype = proto;\n            return new F();\n        };\n    }();\n    // @function bind(fn: Function, ): Function\n    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n    // Has a `L.bind()` shortcut.\n    function bind(fn, obj) {\n        var slice = Array.prototype.slice;\n        if (fn.bind) {\n            return fn.bind.apply(fn, slice.call(arguments, 1));\n        }\n        var args = slice.call(arguments, 2);\n        return function() {\n            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n        };\n    }\n    // @property lastId: Number\n    // Last unique ID used by [`stamp()`](#util-stamp)\n    var lastId = 0;\n    // @function stamp(obj: Object): Number\n    // Returns the unique ID of an object, assigning it one if it doesn't have it.\n    function stamp(obj) {\n        if (!(\"_leaflet_id\" in obj)) {\n            obj[\"_leaflet_id\"] = ++lastId;\n        }\n        return obj._leaflet_id;\n    }\n    // @function throttle(fn: Function, time: Number, context: Object): Function\n    // Returns a function which executes function `fn` with the given scope `context`\n    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n    // `fn` will be called no more than one time per given amount of `time`. The arguments\n    // received by the bound function will be any arguments passed when binding the\n    // function, followed by any arguments passed when invoking the bound function.\n    // Has an `L.throttle` shortcut.\n    function throttle(fn, time, context) {\n        var lock, args, wrapperFn, later;\n        later = function() {\n            // reset lock and call if queued\n            lock = false;\n            if (args) {\n                wrapperFn.apply(context, args);\n                args = false;\n            }\n        };\n        wrapperFn = function() {\n            if (lock) {\n                // called too soon, queue to call later\n                args = arguments;\n            } else {\n                // call and lock until later\n                fn.apply(context, arguments);\n                setTimeout(later, time);\n                lock = true;\n            }\n        };\n        return wrapperFn;\n    }\n    // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n    // Returns the number `num` modulo `range` in such a way so it lies within\n    // `range[0]` and `range[1]`. The returned value will be always smaller than\n    // `range[1]` unless `includeMax` is set to `true`.\n    function wrapNum(x, range, includeMax) {\n        var max = range[1], min = range[0], d = max - min;\n        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n    }\n    // @function falseFn(): Function\n    // Returns a function which always returns `false`.\n    function falseFn() {\n        return false;\n    }\n    // @function formatNum(num: Number, precision?: Number|false): Number\n    // Returns the number `num` rounded with specified `precision`.\n    // The default `precision` value is 6 decimal places.\n    // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n    function formatNum(num, precision) {\n        if (precision === false) {\n            return num;\n        }\n        var pow = Math.pow(10, precision === undefined ? 6 : precision);\n        return Math.round(num * pow) / pow;\n    }\n    // @function trim(str: String): String\n    // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n    function trim(str) {\n        return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    // @function splitWords(str: String): String[]\n    // Trims and splits the string on whitespace and returns the array of parts.\n    function splitWords(str) {\n        return trim(str).split(/\\s+/);\n    }\n    // @function setOptions(obj: Object, options: Object): Object\n    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n    function setOptions(obj, options) {\n        if (!Object.prototype.hasOwnProperty.call(obj, \"options\")) {\n            obj.options = obj.options ? create$2(obj.options) : {};\n        }\n        for(var i in options){\n            obj.options[i] = options[i];\n        }\n        return obj.options;\n    }\n    // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n    // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n    // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n    // be appended at the end. If `uppercase` is `true`, the parameter names will\n    // be uppercased (e.g. `'?A=foo&B=bar'`)\n    function getParamString(obj, existingUrl, uppercase) {\n        var params = [];\n        for(var i in obj){\n            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + \"=\" + encodeURIComponent(obj[i]));\n        }\n        return (!existingUrl || existingUrl.indexOf(\"?\") === -1 ? \"?\" : \"&\") + params.join(\"&\");\n    }\n    var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n    // @function template(str: String, data: Object): String\n    // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n    // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n    // `('Hello foo, bar')`. You can also specify functions instead of strings for\n    // data values  they will be evaluated passing `data` as an argument.\n    function template(str, data) {\n        return str.replace(templateRe, function(str, key) {\n            var value = data[key];\n            if (value === undefined) {\n                throw new Error(\"No value provided for variable \" + str);\n            } else if (typeof value === \"function\") {\n                value = value(data);\n            }\n            return value;\n        });\n    }\n    // @function isArray(obj): Boolean\n    // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n    var isArray = Array.isArray || function(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\n    };\n    // @function indexOf(array: Array, el: Object): Number\n    // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n    function indexOf(array, el) {\n        for(var i = 0; i < array.length; i++){\n            if (array[i] === el) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    // @property emptyImageUrl: String\n    // Data URI string containing a base64-encoded empty GIF image.\n    // Used as a hack to free memory from unused images on WebKit-powered\n    // mobile devices (by setting image `src` to this string).\n    var emptyImageUrl = \"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=\";\n    // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    function getPrefixed(name) {\n        return window[\"webkit\" + name] || window[\"moz\" + name] || window[\"ms\" + name];\n    }\n    var lastTime = 0;\n    // fallback for IE 7-8\n    function timeoutDefer(fn) {\n        var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));\n        lastTime = time + timeToCall;\n        return window.setTimeout(fn, timeToCall);\n    }\n    var requestFn = window.requestAnimationFrame || getPrefixed(\"RequestAnimationFrame\") || timeoutDefer;\n    var cancelFn = window.cancelAnimationFrame || getPrefixed(\"CancelAnimationFrame\") || getPrefixed(\"CancelRequestAnimationFrame\") || function(id) {\n        window.clearTimeout(id);\n    };\n    // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n    // `context` if given. When `immediate` is set, `fn` is called immediately if\n    // the browser doesn't have native support for\n    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n    function requestAnimFrame(fn, context, immediate) {\n        if (immediate && requestFn === timeoutDefer) {\n            fn.call(context);\n        } else {\n            return requestFn.call(window, bind(fn, context));\n        }\n    }\n    // @function cancelAnimFrame(id: Number): undefined\n    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n    function cancelAnimFrame(id) {\n        if (id) {\n            cancelFn.call(window, id);\n        }\n    }\n    var Util = {\n        __proto__: null,\n        extend: extend,\n        create: create$2,\n        bind: bind,\n        get lastId () {\n            return lastId;\n        },\n        stamp: stamp,\n        throttle: throttle,\n        wrapNum: wrapNum,\n        falseFn: falseFn,\n        formatNum: formatNum,\n        trim: trim,\n        splitWords: splitWords,\n        setOptions: setOptions,\n        getParamString: getParamString,\n        template: template,\n        isArray: isArray,\n        indexOf: indexOf,\n        emptyImageUrl: emptyImageUrl,\n        requestFn: requestFn,\n        cancelFn: cancelFn,\n        requestAnimFrame: requestAnimFrame,\n        cancelAnimFrame: cancelAnimFrame\n    };\n    // @class Class\n    // @aka L.Class\n    // @section\n    // @uninheritable\n    // Thanks to John Resig and Dean Edwards for inspiration!\n    function Class() {}\n    Class.extend = function(props) {\n        // @function extend(props: Object): Function\n        // [Extends the current class](#class-inheritance) given the properties to be included.\n        // Returns a Javascript function that is a class constructor (to be called with `new`).\n        var NewClass = function() {\n            setOptions(this);\n            // call the constructor\n            if (this.initialize) {\n                this.initialize.apply(this, arguments);\n            }\n            // call all constructor hooks\n            this.callInitHooks();\n        };\n        var parentProto = NewClass.__super__ = this.prototype;\n        var proto = create$2(parentProto);\n        proto.constructor = NewClass;\n        NewClass.prototype = proto;\n        // inherit parent's statics\n        for(var i in this){\n            if (Object.prototype.hasOwnProperty.call(this, i) && i !== \"prototype\" && i !== \"__super__\") {\n                NewClass[i] = this[i];\n            }\n        }\n        // mix static properties into the class\n        if (props.statics) {\n            extend(NewClass, props.statics);\n        }\n        // mix includes into the prototype\n        if (props.includes) {\n            checkDeprecatedMixinEvents(props.includes);\n            extend.apply(null, [\n                proto\n            ].concat(props.includes));\n        }\n        // mix given properties into the prototype\n        extend(proto, props);\n        delete proto.statics;\n        delete proto.includes;\n        // merge options\n        if (proto.options) {\n            proto.options = parentProto.options ? create$2(parentProto.options) : {};\n            extend(proto.options, props.options);\n        }\n        proto._initHooks = [];\n        // add method for calling all hooks\n        proto.callInitHooks = function() {\n            if (this._initHooksCalled) {\n                return;\n            }\n            if (parentProto.callInitHooks) {\n                parentProto.callInitHooks.call(this);\n            }\n            this._initHooksCalled = true;\n            for(var i = 0, len = proto._initHooks.length; i < len; i++){\n                proto._initHooks[i].call(this);\n            }\n        };\n        return NewClass;\n    };\n    // @function include(properties: Object): this\n    // [Includes a mixin](#class-includes) into the current class.\n    Class.include = function(props) {\n        var parentOptions = this.prototype.options;\n        extend(this.prototype, props);\n        if (props.options) {\n            this.prototype.options = parentOptions;\n            this.mergeOptions(props.options);\n        }\n        return this;\n    };\n    // @function mergeOptions(options: Object): this\n    // [Merges `options`](#class-options) into the defaults of the class.\n    Class.mergeOptions = function(options) {\n        extend(this.prototype.options, options);\n        return this;\n    };\n    // @function addInitHook(fn: Function): this\n    // Adds a [constructor hook](#class-constructor-hooks) to the class.\n    Class.addInitHook = function(fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        var init = typeof fn === \"function\" ? fn : function() {\n            this[fn].apply(this, args);\n        };\n        this.prototype._initHooks = this.prototype._initHooks || [];\n        this.prototype._initHooks.push(init);\n        return this;\n    };\n    function checkDeprecatedMixinEvents(includes) {\n        /* global L: true */ if (typeof L === \"undefined\" || !L || !L.Mixin) {\n            return;\n        }\n        includes = isArray(includes) ? includes : [\n            includes\n        ];\n        for(var i = 0; i < includes.length; i++){\n            if (includes[i] === L.Mixin.Events) {\n                console.warn(\"Deprecated include of L.Mixin.Events: \" + \"this property will be removed in future releases, \" + \"please inherit from L.Evented instead.\", new Error().stack);\n            }\n        }\n    }\n    /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */ var Events = {\n        /* @method on(type: String, fn: Function, context?: Object): this\r\n  \t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method on(eventMap: Object): this\r\n  \t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  \t */ on: function(types, fn, context) {\n            // types can be a map of types/handlers\n            if (typeof types === \"object\") {\n                for(var type in types){\n                    // we don't process space-separated events here for performance;\n                    // it's a hot path since Layer uses the on(obj) syntax\n                    this._on(type, types[type], fn);\n                }\n            } else {\n                // types can be a string of space-separated words\n                types = splitWords(types);\n                for(var i = 0, len = types.length; i < len; i++){\n                    this._on(types[i], fn, context);\n                }\n            }\n            return this;\n        },\n        /* @method off(type: String, fn?: Function, context?: Object): this\r\n  \t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off(eventMap: Object): this\r\n  \t * Removes a set of type/listener pairs.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off: this\r\n  \t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n  \t */ off: function(types, fn, context) {\n            if (!arguments.length) {\n                // clear all listeners if called without arguments\n                delete this._events;\n            } else if (typeof types === \"object\") {\n                for(var type in types){\n                    this._off(type, types[type], fn);\n                }\n            } else {\n                types = splitWords(types);\n                var removeAll = arguments.length === 1;\n                for(var i = 0, len = types.length; i < len; i++){\n                    if (removeAll) {\n                        this._off(types[i]);\n                    } else {\n                        this._off(types[i], fn, context);\n                    }\n                }\n            }\n            return this;\n        },\n        // attach listener (without syntactic sugar now)\n        _on: function(type, fn, context, _once) {\n            if (typeof fn !== \"function\") {\n                console.warn(\"wrong listener type: \" + typeof fn);\n                return;\n            }\n            // check if fn already there\n            if (this._listens(type, fn, context) !== false) {\n                return;\n            }\n            if (context === this) {\n                // Less memory footprint.\n                context = undefined;\n            }\n            var newListener = {\n                fn: fn,\n                ctx: context\n            };\n            if (_once) {\n                newListener.once = true;\n            }\n            this._events = this._events || {};\n            this._events[type] = this._events[type] || [];\n            this._events[type].push(newListener);\n        },\n        _off: function(type, fn, context) {\n            var listeners, i, len;\n            if (!this._events) {\n                return;\n            }\n            listeners = this._events[type];\n            if (!listeners) {\n                return;\n            }\n            if (arguments.length === 1) {\n                if (this._firingCount) {\n                    // Set all removed listeners to noop\n                    // so they are not called if remove happens in fire\n                    for(i = 0, len = listeners.length; i < len; i++){\n                        listeners[i].fn = falseFn;\n                    }\n                }\n                // clear all listeners for a type if function isn't specified\n                delete this._events[type];\n                return;\n            }\n            if (typeof fn !== \"function\") {\n                console.warn(\"wrong listener type: \" + typeof fn);\n                return;\n            }\n            // find fn and remove it\n            var index = this._listens(type, fn, context);\n            if (index !== false) {\n                var listener = listeners[index];\n                if (this._firingCount) {\n                    // set the removed listener to noop so that's not called if remove happens in fire\n                    listener.fn = falseFn;\n                    /* copy array in case events are being fired */ this._events[type] = listeners = listeners.slice();\n                }\n                listeners.splice(index, 1);\n            }\n        },\n        // @method fire(type: String, data?: Object, propagate?: Boolean): this\n        // Fires an event of the specified type. You can optionally provide a data\n        // object  the first argument of the listener function will contain its\n        // properties. The event can optionally be propagated to event parents.\n        fire: function(type, data, propagate) {\n            if (!this.listens(type, propagate)) {\n                return this;\n            }\n            var event = extend({}, data, {\n                type: type,\n                target: this,\n                sourceTarget: data && data.sourceTarget || this\n            });\n            if (this._events) {\n                var listeners = this._events[type];\n                if (listeners) {\n                    this._firingCount = this._firingCount + 1 || 1;\n                    for(var i = 0, len = listeners.length; i < len; i++){\n                        var l = listeners[i];\n                        // off overwrites l.fn, so we need to copy fn to a var\n                        var fn = l.fn;\n                        if (l.once) {\n                            this.off(type, fn, l.ctx);\n                        }\n                        fn.call(l.ctx || this, event);\n                    }\n                    this._firingCount--;\n                }\n            }\n            if (propagate) {\n                // propagate the event to parents (set with addEventParent)\n                this._propagateEvent(event);\n            }\n            return this;\n        },\n        // @method listens(type: String, propagate?: Boolean): Boolean\n        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n        // Returns `true` if a particular event type has any listeners attached to it.\n        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n        listens: function(type, fn, context, propagate) {\n            if (typeof type !== \"string\") {\n                console.warn('\"string\" type argument expected');\n            }\n            // we don't overwrite the input `fn` value, because we need to use it for propagation\n            var _fn = fn;\n            if (typeof fn !== \"function\") {\n                propagate = !!fn;\n                _fn = undefined;\n                context = undefined;\n            }\n            var listeners = this._events && this._events[type];\n            if (listeners && listeners.length) {\n                if (this._listens(type, _fn, context) !== false) {\n                    return true;\n                }\n            }\n            if (propagate) {\n                // also check parents for listeners if event propagates\n                for(var id in this._eventParents){\n                    if (this._eventParents[id].listens(type, fn, context, propagate)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        // returns the index (number) or false\n        _listens: function(type, fn, context) {\n            if (!this._events) {\n                return false;\n            }\n            var listeners = this._events[type] || [];\n            if (!fn) {\n                return !!listeners.length;\n            }\n            if (context === this) {\n                // Less memory footprint.\n                context = undefined;\n            }\n            for(var i = 0, len = listeners.length; i < len; i++){\n                if (listeners[i].fn === fn && listeners[i].ctx === context) {\n                    return i;\n                }\n            }\n            return false;\n        },\n        // @method once(): this\n        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\n        once: function(types, fn, context) {\n            // types can be a map of types/handlers\n            if (typeof types === \"object\") {\n                for(var type in types){\n                    // we don't process space-separated events here for performance;\n                    // it's a hot path since Layer uses the on(obj) syntax\n                    this._on(type, types[type], fn, true);\n                }\n            } else {\n                // types can be a string of space-separated words\n                types = splitWords(types);\n                for(var i = 0, len = types.length; i < len; i++){\n                    this._on(types[i], fn, context, true);\n                }\n            }\n            return this;\n        },\n        // @method addEventParent(obj: Evented): this\n        // Adds an event parent - an `Evented` that will receive propagated events\n        addEventParent: function(obj) {\n            this._eventParents = this._eventParents || {};\n            this._eventParents[stamp(obj)] = obj;\n            return this;\n        },\n        // @method removeEventParent(obj: Evented): this\n        // Removes an event parent, so it will stop receiving propagated events\n        removeEventParent: function(obj) {\n            if (this._eventParents) {\n                delete this._eventParents[stamp(obj)];\n            }\n            return this;\n        },\n        _propagateEvent: function(e) {\n            for(var id in this._eventParents){\n                this._eventParents[id].fire(e.type, extend({\n                    layer: e.target,\n                    propagatedFrom: e.target\n                }, e), true);\n            }\n        }\n    };\n    // aliases; we should ditch those eventually\n    // @method addEventListener(): this\n    // Alias to [`on()`](#evented-on)\n    Events.addEventListener = Events.on;\n    // @method removeEventListener(): this\n    // Alias to [`off()`](#evented-off)\n    // @method clearAllEventListeners(): this\n    // Alias to [`off()`](#evented-off)\n    Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n    // @method addOneTimeEventListener(): this\n    // Alias to [`once()`](#evented-once)\n    Events.addOneTimeEventListener = Events.once;\n    // @method fireEvent(): this\n    // Alias to [`fire()`](#evented-fire)\n    Events.fireEvent = Events.fire;\n    // @method hasEventListeners(): Boolean\n    // Alias to [`listens()`](#evented-listens)\n    Events.hasEventListeners = Events.listens;\n    var Evented = Class.extend(Events);\n    /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function Point(x, y, round) {\n        // @property x: Number; The `x` coordinate of the point\n        this.x = round ? Math.round(x) : x;\n        // @property y: Number; The `y` coordinate of the point\n        this.y = round ? Math.round(y) : y;\n    }\n    var trunc = Math.trunc || function(v) {\n        return v > 0 ? Math.floor(v) : Math.ceil(v);\n    };\n    Point.prototype = {\n        // @method clone(): Point\n        // Returns a copy of the current point.\n        clone: function() {\n            return new Point(this.x, this.y);\n        },\n        // @method add(otherPoint: Point): Point\n        // Returns the result of addition of the current and the given points.\n        add: function(point) {\n            // non-destructive, returns a new point\n            return this.clone()._add(toPoint(point));\n        },\n        _add: function(point) {\n            // destructive, used directly for performance in situations where it's safe to modify existing point\n            this.x += point.x;\n            this.y += point.y;\n            return this;\n        },\n        // @method subtract(otherPoint: Point): Point\n        // Returns the result of subtraction of the given point from the current.\n        subtract: function(point) {\n            return this.clone()._subtract(toPoint(point));\n        },\n        _subtract: function(point) {\n            this.x -= point.x;\n            this.y -= point.y;\n            return this;\n        },\n        // @method divideBy(num: Number): Point\n        // Returns the result of division of the current point by the given number.\n        divideBy: function(num) {\n            return this.clone()._divideBy(num);\n        },\n        _divideBy: function(num) {\n            this.x /= num;\n            this.y /= num;\n            return this;\n        },\n        // @method multiplyBy(num: Number): Point\n        // Returns the result of multiplication of the current point by the given number.\n        multiplyBy: function(num) {\n            return this.clone()._multiplyBy(num);\n        },\n        _multiplyBy: function(num) {\n            this.x *= num;\n            this.y *= num;\n            return this;\n        },\n        // @method scaleBy(scale: Point): Point\n        // Multiply each coordinate of the current point by each coordinate of\n        // `scale`. In linear algebra terms, multiply the point by the\n        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n        // defined by `scale`.\n        scaleBy: function(point) {\n            return new Point(this.x * point.x, this.y * point.y);\n        },\n        // @method unscaleBy(scale: Point): Point\n        // Inverse of `scaleBy`. Divide each coordinate of the current point by\n        // each coordinate of `scale`.\n        unscaleBy: function(point) {\n            return new Point(this.x / point.x, this.y / point.y);\n        },\n        // @method round(): Point\n        // Returns a copy of the current point with rounded coordinates.\n        round: function() {\n            return this.clone()._round();\n        },\n        _round: function() {\n            this.x = Math.round(this.x);\n            this.y = Math.round(this.y);\n            return this;\n        },\n        // @method floor(): Point\n        // Returns a copy of the current point with floored coordinates (rounded down).\n        floor: function() {\n            return this.clone()._floor();\n        },\n        _floor: function() {\n            this.x = Math.floor(this.x);\n            this.y = Math.floor(this.y);\n            return this;\n        },\n        // @method ceil(): Point\n        // Returns a copy of the current point with ceiled coordinates (rounded up).\n        ceil: function() {\n            return this.clone()._ceil();\n        },\n        _ceil: function() {\n            this.x = Math.ceil(this.x);\n            this.y = Math.ceil(this.y);\n            return this;\n        },\n        // @method trunc(): Point\n        // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n        trunc: function() {\n            return this.clone()._trunc();\n        },\n        _trunc: function() {\n            this.x = trunc(this.x);\n            this.y = trunc(this.y);\n            return this;\n        },\n        // @method distanceTo(otherPoint: Point): Number\n        // Returns the cartesian distance between the current and the given points.\n        distanceTo: function(point) {\n            point = toPoint(point);\n            var x = point.x - this.x, y = point.y - this.y;\n            return Math.sqrt(x * x + y * y);\n        },\n        // @method equals(otherPoint: Point): Boolean\n        // Returns `true` if the given point has the same coordinates.\n        equals: function(point) {\n            point = toPoint(point);\n            return point.x === this.x && point.y === this.y;\n        },\n        // @method contains(otherPoint: Point): Boolean\n        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n        contains: function(point) {\n            point = toPoint(point);\n            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n        },\n        // @method toString(): String\n        // Returns a string representation of the point for debugging purposes.\n        toString: function() {\n            return \"Point(\" + formatNum(this.x) + \", \" + formatNum(this.y) + \")\";\n        }\n    };\n    // @factory L.point(x: Number, y: Number, round?: Boolean)\n    // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n    // @alternative\n    // @factory L.point(coords: Number[])\n    // Expects an array of the form `[x, y]` instead.\n    // @alternative\n    // @factory L.point(coords: Object)\n    // Expects a plain object of the form `{x: Number, y: Number}` instead.\n    function toPoint(x, y, round) {\n        if (x instanceof Point) {\n            return x;\n        }\n        if (isArray(x)) {\n            return new Point(x[0], x[1]);\n        }\n        if (x === undefined || x === null) {\n            return x;\n        }\n        if (typeof x === \"object\" && \"x\" in x && \"y\" in x) {\n            return new Point(x.x, x.y);\n        }\n        return new Point(x, y, round);\n    }\n    /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function Bounds(a, b) {\n        if (!a) {\n            return;\n        }\n        var points = b ? [\n            a,\n            b\n        ] : a;\n        for(var i = 0, len = points.length; i < len; i++){\n            this.extend(points[i]);\n        }\n    }\n    Bounds.prototype = {\n        // @method extend(point: Point): this\n        // Extends the bounds to contain the given point.\n        // @alternative\n        // @method extend(otherBounds: Bounds): this\n        // Extend the bounds to contain the given bounds\n        extend: function(obj) {\n            var min2, max2;\n            if (!obj) {\n                return this;\n            }\n            if (obj instanceof Point || typeof obj[0] === \"number\" || \"x\" in obj) {\n                min2 = max2 = toPoint(obj);\n            } else {\n                obj = toBounds(obj);\n                min2 = obj.min;\n                max2 = obj.max;\n                if (!min2 || !max2) {\n                    return this;\n                }\n            }\n            // @property min: Point\n            // The top left corner of the rectangle.\n            // @property max: Point\n            // The bottom right corner of the rectangle.\n            if (!this.min && !this.max) {\n                this.min = min2.clone();\n                this.max = max2.clone();\n            } else {\n                this.min.x = Math.min(min2.x, this.min.x);\n                this.max.x = Math.max(max2.x, this.max.x);\n                this.min.y = Math.min(min2.y, this.min.y);\n                this.max.y = Math.max(max2.y, this.max.y);\n            }\n            return this;\n        },\n        // @method getCenter(round?: Boolean): Point\n        // Returns the center point of the bounds.\n        getCenter: function(round) {\n            return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n        },\n        // @method getBottomLeft(): Point\n        // Returns the bottom-left point of the bounds.\n        getBottomLeft: function() {\n            return toPoint(this.min.x, this.max.y);\n        },\n        // @method getTopRight(): Point\n        // Returns the top-right point of the bounds.\n        getTopRight: function() {\n            return toPoint(this.max.x, this.min.y);\n        },\n        // @method getTopLeft(): Point\n        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n        getTopLeft: function() {\n            return this.min; // left, top\n        },\n        // @method getBottomRight(): Point\n        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n        getBottomRight: function() {\n            return this.max; // right, bottom\n        },\n        // @method getSize(): Point\n        // Returns the size of the given bounds\n        getSize: function() {\n            return this.max.subtract(this.min);\n        },\n        // @method contains(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle contains the given one.\n        // @alternative\n        // @method contains(point: Point): Boolean\n        // Returns `true` if the rectangle contains the given point.\n        contains: function(obj) {\n            var min, max;\n            if (typeof obj[0] === \"number\" || obj instanceof Point) {\n                obj = toPoint(obj);\n            } else {\n                obj = toBounds(obj);\n            }\n            if (obj instanceof Bounds) {\n                min = obj.min;\n                max = obj.max;\n            } else {\n                min = max = obj;\n            }\n            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n        },\n        // @method intersects(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle intersects the given bounds. Two bounds\n        // intersect if they have at least one point in common.\n        intersects: function(bounds) {\n            bounds = toBounds(bounds);\n            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;\n            return xIntersects && yIntersects;\n        },\n        // @method overlaps(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n        // overlap if their intersection is an area.\n        overlaps: function(bounds) {\n            bounds = toBounds(bounds);\n            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;\n            return xOverlaps && yOverlaps;\n        },\n        // @method isValid(): Boolean\n        // Returns `true` if the bounds are properly initialized.\n        isValid: function() {\n            return !!(this.min && this.max);\n        },\n        // @method pad(bufferRatio: Number): Bounds\n        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n        // Negative values will retract the bounds.\n        pad: function(bufferRatio) {\n            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n            return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n        },\n        // @method equals(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle is equivalent to the given bounds.\n        equals: function(bounds) {\n            if (!bounds) {\n                return false;\n            }\n            bounds = toBounds(bounds);\n            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n        }\n    };\n    // @factory L.bounds(corner1: Point, corner2: Point)\n    // Creates a Bounds object from two corners coordinate pairs.\n    // @alternative\n    // @factory L.bounds(points: Point[])\n    // Creates a Bounds object from the given array of points.\n    function toBounds(a, b) {\n        if (!a || a instanceof Bounds) {\n            return a;\n        }\n        return new Bounds(a, b);\n    }\n    /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function LatLngBounds(corner1, corner2) {\n        if (!corner1) {\n            return;\n        }\n        var latlngs = corner2 ? [\n            corner1,\n            corner2\n        ] : corner1;\n        for(var i = 0, len = latlngs.length; i < len; i++){\n            this.extend(latlngs[i]);\n        }\n    }\n    LatLngBounds.prototype = {\n        // @method extend(latlng: LatLng): this\n        // Extend the bounds to contain the given point\n        // @alternative\n        // @method extend(otherBounds: LatLngBounds): this\n        // Extend the bounds to contain the given bounds\n        extend: function(obj) {\n            var sw = this._southWest, ne = this._northEast, sw2, ne2;\n            if (obj instanceof LatLng) {\n                sw2 = obj;\n                ne2 = obj;\n            } else if (obj instanceof LatLngBounds) {\n                sw2 = obj._southWest;\n                ne2 = obj._northEast;\n                if (!sw2 || !ne2) {\n                    return this;\n                }\n            } else {\n                return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n            }\n            if (!sw && !ne) {\n                this._southWest = new LatLng(sw2.lat, sw2.lng);\n                this._northEast = new LatLng(ne2.lat, ne2.lng);\n            } else {\n                sw.lat = Math.min(sw2.lat, sw.lat);\n                sw.lng = Math.min(sw2.lng, sw.lng);\n                ne.lat = Math.max(ne2.lat, ne.lat);\n                ne.lng = Math.max(ne2.lng, ne.lng);\n            }\n            return this;\n        },\n        // @method pad(bufferRatio: Number): LatLngBounds\n        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n        // Negative values will retract the bounds.\n        pad: function(bufferRatio) {\n            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n            return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n        },\n        // @method getCenter(): LatLng\n        // Returns the center point of the bounds.\n        getCenter: function() {\n            return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n        },\n        // @method getSouthWest(): LatLng\n        // Returns the south-west point of the bounds.\n        getSouthWest: function() {\n            return this._southWest;\n        },\n        // @method getNorthEast(): LatLng\n        // Returns the north-east point of the bounds.\n        getNorthEast: function() {\n            return this._northEast;\n        },\n        // @method getNorthWest(): LatLng\n        // Returns the north-west point of the bounds.\n        getNorthWest: function() {\n            return new LatLng(this.getNorth(), this.getWest());\n        },\n        // @method getSouthEast(): LatLng\n        // Returns the south-east point of the bounds.\n        getSouthEast: function() {\n            return new LatLng(this.getSouth(), this.getEast());\n        },\n        // @method getWest(): Number\n        // Returns the west longitude of the bounds\n        getWest: function() {\n            return this._southWest.lng;\n        },\n        // @method getSouth(): Number\n        // Returns the south latitude of the bounds\n        getSouth: function() {\n            return this._southWest.lat;\n        },\n        // @method getEast(): Number\n        // Returns the east longitude of the bounds\n        getEast: function() {\n            return this._northEast.lng;\n        },\n        // @method getNorth(): Number\n        // Returns the north latitude of the bounds\n        getNorth: function() {\n            return this._northEast.lat;\n        },\n        // @method contains(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle contains the given one.\n        // @alternative\n        // @method contains (latlng: LatLng): Boolean\n        // Returns `true` if the rectangle contains the given point.\n        contains: function(obj) {\n            if (typeof obj[0] === \"number\" || obj instanceof LatLng || \"lat\" in obj) {\n                obj = toLatLng(obj);\n            } else {\n                obj = toLatLngBounds(obj);\n            }\n            var sw = this._southWest, ne = this._northEast, sw2, ne2;\n            if (obj instanceof LatLngBounds) {\n                sw2 = obj.getSouthWest();\n                ne2 = obj.getNorthEast();\n            } else {\n                sw2 = ne2 = obj;\n            }\n            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n        },\n        // @method intersects(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n        intersects: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n            return latIntersects && lngIntersects;\n        },\n        // @method overlaps(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n        overlaps: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n            return latOverlaps && lngOverlaps;\n        },\n        // @method toBBoxString(): String\n        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n        toBBoxString: function() {\n            return [\n                this.getWest(),\n                this.getSouth(),\n                this.getEast(),\n                this.getNorth()\n            ].join(\",\");\n        },\n        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n        equals: function(bounds, maxMargin) {\n            if (!bounds) {\n                return false;\n            }\n            bounds = toLatLngBounds(bounds);\n            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n        },\n        // @method isValid(): Boolean\n        // Returns `true` if the bounds are properly initialized.\n        isValid: function() {\n            return !!(this._southWest && this._northEast);\n        }\n    };\n    // TODO International date line?\n    // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n    // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n    // @alternative\n    // @factory L.latLngBounds(latlngs: LatLng[])\n    // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n    function toLatLngBounds(a, b) {\n        if (a instanceof LatLngBounds) {\n            return a;\n        }\n        return new LatLngBounds(a, b);\n    }\n    /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function LatLng(lat, lng, alt) {\n        if (isNaN(lat) || isNaN(lng)) {\n            throw new Error(\"Invalid LatLng object: (\" + lat + \", \" + lng + \")\");\n        }\n        // @property lat: Number\n        // Latitude in degrees\n        this.lat = +lat;\n        // @property lng: Number\n        // Longitude in degrees\n        this.lng = +lng;\n        // @property alt: Number\n        // Altitude in meters (optional)\n        if (alt !== undefined) {\n            this.alt = +alt;\n        }\n    }\n    LatLng.prototype = {\n        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n        equals: function(obj, maxMargin) {\n            if (!obj) {\n                return false;\n            }\n            obj = toLatLng(obj);\n            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n            return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n        },\n        // @method toString(): String\n        // Returns a string representation of the point (for debugging purposes).\n        toString: function(precision) {\n            return \"LatLng(\" + formatNum(this.lat, precision) + \", \" + formatNum(this.lng, precision) + \")\";\n        },\n        // @method distanceTo(otherLatLng: LatLng): Number\n        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n        distanceTo: function(other) {\n            return Earth.distance(this, toLatLng(other));\n        },\n        // @method wrap(): LatLng\n        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n        wrap: function() {\n            return Earth.wrapLatLng(this);\n        },\n        // @method toBounds(sizeInMeters: Number): LatLngBounds\n        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n        toBounds: function(sizeInMeters) {\n            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n            return toLatLngBounds([\n                this.lat - latAccuracy,\n                this.lng - lngAccuracy\n            ], [\n                this.lat + latAccuracy,\n                this.lng + lngAccuracy\n            ]);\n        },\n        clone: function() {\n            return new LatLng(this.lat, this.lng, this.alt);\n        }\n    };\n    // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n    // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n    // @alternative\n    // @factory L.latLng(coords: Array): LatLng\n    // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n    // @alternative\n    // @factory L.latLng(coords: Object): LatLng\n    // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n    function toLatLng(a, b, c) {\n        if (a instanceof LatLng) {\n            return a;\n        }\n        if (isArray(a) && typeof a[0] !== \"object\") {\n            if (a.length === 3) {\n                return new LatLng(a[0], a[1], a[2]);\n            }\n            if (a.length === 2) {\n                return new LatLng(a[0], a[1]);\n            }\n            return null;\n        }\n        if (a === undefined || a === null) {\n            return a;\n        }\n        if (typeof a === \"object\" && \"lat\" in a) {\n            return new LatLng(a.lat, \"lng\" in a ? a.lng : a.lon, a.alt);\n        }\n        if (b === undefined) {\n            return null;\n        }\n        return new LatLng(a, b, c);\n    }\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */ var CRS = {\n        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n        // Projects geographical coordinates into pixel coordinates for a given zoom.\n        latLngToPoint: function(latlng, zoom) {\n            var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);\n            return this.transformation._transform(projectedPoint, scale);\n        },\n        // @method pointToLatLng(point: Point, zoom: Number): LatLng\n        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n        // zoom into geographical coordinates.\n        pointToLatLng: function(point, zoom) {\n            var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);\n            return this.projection.unproject(untransformedPoint);\n        },\n        // @method project(latlng: LatLng): Point\n        // Projects geographical coordinates into coordinates in units accepted for\n        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n        project: function(latlng) {\n            return this.projection.project(latlng);\n        },\n        // @method unproject(point: Point): LatLng\n        // Given a projected coordinate returns the corresponding LatLng.\n        // The inverse of `project`.\n        unproject: function(point) {\n            return this.projection.unproject(point);\n        },\n        // @method scale(zoom: Number): Number\n        // Returns the scale used when transforming projected coordinates into\n        // pixel coordinates for a particular zoom. For example, it returns\n        // `256 * 2^zoom` for Mercator-based CRS.\n        scale: function(zoom) {\n            return 256 * Math.pow(2, zoom);\n        },\n        // @method zoom(scale: Number): Number\n        // Inverse of `scale()`, returns the zoom level corresponding to a scale\n        // factor of `scale`.\n        zoom: function(scale) {\n            return Math.log(scale / 256) / Math.LN2;\n        },\n        // @method getProjectedBounds(zoom: Number): Bounds\n        // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n        getProjectedBounds: function(zoom) {\n            if (this.infinite) {\n                return null;\n            }\n            var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);\n            return new Bounds(min, max);\n        },\n        // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n        // Returns the distance between two geographical coordinates.\n        // @property code: String\n        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n        //\n        // @property wrapLng: Number[]\n        // An array of two numbers defining whether the longitude (horizontal) coordinate\n        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n        //\n        // @property wrapLat: Number[]\n        // Like `wrapLng`, but for the latitude (vertical) axis.\n        // wrapLng: [min, max],\n        // wrapLat: [min, max],\n        // @property infinite: Boolean\n        // If true, the coordinate space will be unbounded (infinite in both axes)\n        infinite: false,\n        // @method wrapLatLng(latlng: LatLng): LatLng\n        // Returns a `LatLng` where lat and lng has been wrapped according to the\n        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n        wrapLatLng: function(latlng) {\n            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;\n            return new LatLng(lat, lng, alt);\n        },\n        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n        // Returns a `LatLngBounds` with the same size as the given one, ensuring\n        // that its center is within the CRS's bounds.\n        // Only accepts actual `L.LatLngBounds` instances, not arrays.\n        wrapLatLngBounds: function(bounds) {\n            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;\n            if (latShift === 0 && lngShift === 0) {\n                return bounds;\n            }\n            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n            return new LatLngBounds(newSw, newNe);\n        }\n    };\n    /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */ var Earth = extend({}, CRS, {\n        wrapLng: [\n            -180,\n            180\n        ],\n        // Mean Earth Radius, as recommended for use by\n        // the International Union of Geodesy and Geophysics,\n        // see https://rosettacode.org/wiki/Haversine_formula\n        R: 6371000,\n        // distance between two geographical points using spherical law of cosines approximation\n        distance: function(latlng1, latlng2) {\n            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n            return this.R * c;\n        }\n    });\n    /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */ var earthRadius = 6378137;\n    var SphericalMercator = {\n        R: earthRadius,\n        MAX_LATITUDE: 85.0511287798,\n        project: function(latlng) {\n            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);\n            return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n        },\n        unproject: function(point) {\n            var d = 180 / Math.PI;\n            return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n        },\n        bounds: function() {\n            var d = earthRadius * Math.PI;\n            return new Bounds([\n                -d,\n                -d\n            ], [\n                d,\n                d\n            ]);\n        }()\n    };\n    /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */ // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n    // Creates a `Transformation` object with the given coefficients.\n    function Transformation(a, b, c, d) {\n        if (isArray(a)) {\n            // use array properties\n            this._a = a[0];\n            this._b = a[1];\n            this._c = a[2];\n            this._d = a[3];\n            return;\n        }\n        this._a = a;\n        this._b = b;\n        this._c = c;\n        this._d = d;\n    }\n    Transformation.prototype = {\n        // @method transform(point: Point, scale?: Number): Point\n        // Returns a transformed point, optionally multiplied by the given scale.\n        // Only accepts actual `L.Point` instances, not arrays.\n        transform: function(point, scale) {\n            return this._transform(point.clone(), scale);\n        },\n        // destructive transform (faster)\n        _transform: function(point, scale) {\n            scale = scale || 1;\n            point.x = scale * (this._a * point.x + this._b);\n            point.y = scale * (this._c * point.y + this._d);\n            return point;\n        },\n        // @method untransform(point: Point, scale?: Number): Point\n        // Returns the reverse transformation of the given point, optionally divided\n        // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n        untransform: function(point, scale) {\n            scale = scale || 1;\n            return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n        }\n    };\n    // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n    // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n    // Instantiates a Transformation object with the given coefficients.\n    // @alternative\n    // @factory L.transformation(coefficients: Array): Transformation\n    // Expects an coefficients array of the form\n    // `[a: Number, b: Number, c: Number, d: Number]`.\n    function toTransformation(a, b, c, d) {\n        return new Transformation(a, b, c, d);\n    }\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */ var EPSG3857 = extend({}, Earth, {\n        code: \"EPSG:3857\",\n        projection: SphericalMercator,\n        transformation: function() {\n            var scale = 0.5 / (Math.PI * SphericalMercator.R);\n            return toTransformation(scale, 0.5, -scale, 0.5);\n        }()\n    });\n    var EPSG900913 = extend({}, EPSG3857, {\n        code: \"EPSG:900913\"\n    });\n    // @namespace SVG; @section\n    // There are several static functions which can be called without instantiating L.SVG:\n    // @function create(name: String): SVGElement\n    // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n    // corresponding to the class name passed. For example, using 'line' will return\n    // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n    function svgCreate(name) {\n        return document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n    }\n    // @function pointsToPath(rings: Point[], closed: Boolean): String\n    // Generates a SVG path string for multiple rings, with each ring turning\n    // into \"M..L..L..\" instructions\n    function pointsToPath(rings, closed) {\n        var str = \"\", i, j, len, len2, points, p;\n        for(i = 0, len = rings.length; i < len; i++){\n            points = rings[i];\n            for(j = 0, len2 = points.length; j < len2; j++){\n                p = points[j];\n                str += (j ? \"L\" : \"M\") + p.x + \" \" + p.y;\n            }\n            // closes the ring for polygons; \"x\" is VML syntax\n            str += closed ? Browser.svg ? \"z\" : \"x\" : \"\";\n        }\n        // SVG complains about empty path strings\n        return str || \"M0 0\";\n    }\n    /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */ var style = document.documentElement.style;\n    // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n    var ie = \"ActiveXObject\" in window;\n    // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n    var ielt9 = ie && !document.addEventListener;\n    // @property edge: Boolean; `true` for the Edge web browser.\n    var edge = \"msLaunchUri\" in navigator && !(\"documentMode\" in document);\n    // @property webkit: Boolean;\n    // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n    var webkit = userAgentContains(\"webkit\");\n    // @property android: Boolean\n    // **Deprecated.** `true` for any browser running on an Android platform.\n    var android = userAgentContains(\"android\");\n    // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n    var android23 = userAgentContains(\"android 2\") || userAgentContains(\"android 3\");\n    /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */ var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n    // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n    var androidStock = android && userAgentContains(\"Google\") && webkitVer < 537 && !(\"AudioNode\" in window);\n    // @property opera: Boolean; `true` for the Opera browser\n    var opera = !!window.opera;\n    // @property chrome: Boolean; `true` for the Chrome browser.\n    var chrome = !edge && userAgentContains(\"chrome\");\n    // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n    var gecko = userAgentContains(\"gecko\") && !webkit && !opera && !ie;\n    // @property safari: Boolean; `true` for the Safari browser.\n    var safari = !chrome && userAgentContains(\"safari\");\n    var phantom = userAgentContains(\"phantom\");\n    // @property opera12: Boolean\n    // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n    var opera12 = \"OTransition\" in style;\n    // @property win: Boolean; `true` when the browser is running in a Windows platform\n    var win = navigator.platform.indexOf(\"Win\") === 0;\n    // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n    var ie3d = ie && \"transition\" in style;\n    // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n    var webkit3d = \"WebKitCSSMatrix\" in window && \"m11\" in new window.WebKitCSSMatrix() && !android23;\n    // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n    var gecko3d = \"MozPerspective\" in style;\n    // @property any3d: Boolean\n    // `true` for all browsers supporting CSS transforms.\n    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n    // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n    var mobile = typeof orientation !== \"undefined\" || userAgentContains(\"mobile\");\n    // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n    var mobileWebkit = mobile && webkit;\n    // @property mobileWebkit3d: Boolean\n    // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n    var mobileWebkit3d = mobile && webkit3d;\n    // @property msPointer: Boolean\n    // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n    var msPointer = !window.PointerEvent && window.MSPointerEvent;\n    // @property pointer: Boolean\n    // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n    var pointer = !!(window.PointerEvent || msPointer);\n    // @property touchNative: Boolean\n    // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n    // **This does not necessarily mean** that the browser is running in a computer with\n    // a touchscreen, it only means that the browser is capable of understanding\n    // touch events.\n    var touchNative = \"ontouchstart\" in window || !!window.TouchEvent;\n    // @property touch: Boolean\n    // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n    // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n    var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n    // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n    var mobileOpera = mobile && opera;\n    // @property mobileGecko: Boolean\n    // `true` for gecko-based browsers running in a mobile device.\n    var mobileGecko = mobile && gecko;\n    // @property retina: Boolean\n    // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n    // @property passiveEvents: Boolean\n    // `true` for browsers that support passive events.\n    var passiveEvents = function() {\n        var supportsPassiveOption = false;\n        try {\n            var opts = Object.defineProperty({}, \"passive\", {\n                get: function() {\n                    supportsPassiveOption = true;\n                }\n            });\n            window.addEventListener(\"testPassiveEventSupport\", falseFn, opts);\n            window.removeEventListener(\"testPassiveEventSupport\", falseFn, opts);\n        } catch (e) {\n        // Errors can safely be ignored since this is only a browser support test.\n        }\n        return supportsPassiveOption;\n    }();\n    // @property canvas: Boolean\n    // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n    var canvas$1 = function() {\n        return !!document.createElement(\"canvas\").getContext;\n    }();\n    // @property svg: Boolean\n    // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n    var svg$1 = !!(document.createElementNS && svgCreate(\"svg\").createSVGRect);\n    var inlineSvg = !!svg$1 && function() {\n        var div = document.createElement(\"div\");\n        div.innerHTML = \"<svg/>\";\n        return (div.firstChild && div.firstChild.namespaceURI) === \"http://www.w3.org/2000/svg\";\n    }();\n    // @property vml: Boolean\n    // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n    var vml = !svg$1 && function() {\n        try {\n            var div = document.createElement(\"div\");\n            div.innerHTML = '<v:shape adj=\"1\"/>';\n            var shape = div.firstChild;\n            shape.style.behavior = \"url(#default#VML)\";\n            return shape && typeof shape.adj === \"object\";\n        } catch (e) {\n            return false;\n        }\n    }();\n    // @property mac: Boolean; `true` when the browser is running in a Mac platform\n    var mac = navigator.platform.indexOf(\"Mac\") === 0;\n    // @property mac: Boolean; `true` when the browser is running in a Linux platform\n    var linux = navigator.platform.indexOf(\"Linux\") === 0;\n    function userAgentContains(str) {\n        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n    }\n    var Browser = {\n        ie: ie,\n        ielt9: ielt9,\n        edge: edge,\n        webkit: webkit,\n        android: android,\n        android23: android23,\n        androidStock: androidStock,\n        opera: opera,\n        chrome: chrome,\n        gecko: gecko,\n        safari: safari,\n        phantom: phantom,\n        opera12: opera12,\n        win: win,\n        ie3d: ie3d,\n        webkit3d: webkit3d,\n        gecko3d: gecko3d,\n        any3d: any3d,\n        mobile: mobile,\n        mobileWebkit: mobileWebkit,\n        mobileWebkit3d: mobileWebkit3d,\n        msPointer: msPointer,\n        pointer: pointer,\n        touch: touch,\n        touchNative: touchNative,\n        mobileOpera: mobileOpera,\n        mobileGecko: mobileGecko,\n        retina: retina,\n        passiveEvents: passiveEvents,\n        canvas: canvas$1,\n        svg: svg$1,\n        vml: vml,\n        inlineSvg: inlineSvg,\n        mac: mac,\n        linux: linux\n    };\n    /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */ var POINTER_DOWN = Browser.msPointer ? \"MSPointerDown\" : \"pointerdown\";\n    var POINTER_MOVE = Browser.msPointer ? \"MSPointerMove\" : \"pointermove\";\n    var POINTER_UP = Browser.msPointer ? \"MSPointerUp\" : \"pointerup\";\n    var POINTER_CANCEL = Browser.msPointer ? \"MSPointerCancel\" : \"pointercancel\";\n    var pEvent = {\n        touchstart: POINTER_DOWN,\n        touchmove: POINTER_MOVE,\n        touchend: POINTER_UP,\n        touchcancel: POINTER_CANCEL\n    };\n    var handle = {\n        touchstart: _onPointerStart,\n        touchmove: _handlePointer,\n        touchend: _handlePointer,\n        touchcancel: _handlePointer\n    };\n    var _pointers = {};\n    var _pointerDocListener = false;\n    // Provides a touch events wrapper for (ms)pointer events.\n    // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n    function addPointerListener(obj, type, handler) {\n        if (type === \"touchstart\") {\n            _addPointerDocListener();\n        }\n        if (!handle[type]) {\n            console.warn(\"wrong event specified:\", type);\n            return falseFn;\n        }\n        handler = handle[type].bind(this, handler);\n        obj.addEventListener(pEvent[type], handler, false);\n        return handler;\n    }\n    function removePointerListener(obj, type, handler) {\n        if (!pEvent[type]) {\n            console.warn(\"wrong event specified:\", type);\n            return;\n        }\n        obj.removeEventListener(pEvent[type], handler, false);\n    }\n    function _globalPointerDown(e) {\n        _pointers[e.pointerId] = e;\n    }\n    function _globalPointerMove(e) {\n        if (_pointers[e.pointerId]) {\n            _pointers[e.pointerId] = e;\n        }\n    }\n    function _globalPointerUp(e) {\n        delete _pointers[e.pointerId];\n    }\n    function _addPointerDocListener() {\n        // need to keep track of what pointers and how many are active to provide e.touches emulation\n        if (!_pointerDocListener) {\n            // we listen document as any drags that end by moving the touch off the screen get fired there\n            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n            document.addEventListener(POINTER_UP, _globalPointerUp, true);\n            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n            _pointerDocListener = true;\n        }\n    }\n    function _handlePointer(handler, e) {\n        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || \"mouse\")) {\n            return;\n        }\n        e.touches = [];\n        for(var i in _pointers){\n            e.touches.push(_pointers[i]);\n        }\n        e.changedTouches = [\n            e\n        ];\n        handler(e);\n    }\n    function _onPointerStart(handler, e) {\n        // IE10 specific: MsTouch needs preventDefault. See #2000\n        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n            preventDefault(e);\n        }\n        _handlePointer(handler, e);\n    }\n    /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */ function makeDblclick(event) {\n        // in modern browsers `type` cannot be just overridden:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n        var newEvent = {}, prop, i;\n        for(i in event){\n            prop = event[i];\n            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n        }\n        event = newEvent;\n        newEvent.type = \"dblclick\";\n        newEvent.detail = 2;\n        newEvent.isTrusted = false;\n        newEvent._simulated = true; // for debug purposes\n        return newEvent;\n    }\n    var delay = 200;\n    function addDoubleTapListener(obj, handler) {\n        // Most browsers handle double tap natively\n        obj.addEventListener(\"dblclick\", handler);\n        // On some platforms the browser doesn't fire native dblclicks for touch events.\n        // It seems that in all such cases `detail` property of `click` event is always `1`.\n        // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n        var last = 0, detail;\n        function simDblclick(e) {\n            if (e.detail !== 1) {\n                detail = e.detail; // keep in sync to avoid false dblclick in some cases\n                return;\n            }\n            if (e.pointerType === \"mouse\" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n                return;\n            }\n            // When clicking on an <input>, the browser generates a click on its\n            // <label> (and vice versa) triggering two clicks in quick succession.\n            // This ignores clicks on elements which are a label with a 'for'\n            // attribute (or children of such a label), but not children of\n            // a <input>.\n            var path = getPropagationPath(e);\n            if (path.some(function(el) {\n                return el instanceof HTMLLabelElement && el.attributes.for;\n            }) && !path.some(function(el) {\n                return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n            })) {\n                return;\n            }\n            var now = Date.now();\n            if (now - last <= delay) {\n                detail++;\n                if (detail === 2) {\n                    handler(makeDblclick(e));\n                }\n            } else {\n                detail = 1;\n            }\n            last = now;\n        }\n        obj.addEventListener(\"click\", simDblclick);\n        return {\n            dblclick: handler,\n            simDblclick: simDblclick\n        };\n    }\n    function removeDoubleTapListener(obj, handlers) {\n        obj.removeEventListener(\"dblclick\", handlers.dblclick);\n        obj.removeEventListener(\"click\", handlers.simDblclick);\n    }\n    /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */ // @property TRANSFORM: String\n    // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n    var TRANSFORM = testProp([\n        \"transform\",\n        \"webkitTransform\",\n        \"OTransform\",\n        \"MozTransform\",\n        \"msTransform\"\n    ]);\n    // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n    // the same for the transitionend event, in particular the Android 4.1 stock browser\n    // @property TRANSITION: String\n    // Vendor-prefixed transition style name.\n    var TRANSITION = testProp([\n        \"webkitTransition\",\n        \"transition\",\n        \"OTransition\",\n        \"MozTransition\",\n        \"msTransition\"\n    ]);\n    // @property TRANSITION_END: String\n    // Vendor-prefixed transitionend event name.\n    var TRANSITION_END = TRANSITION === \"webkitTransition\" || TRANSITION === \"OTransition\" ? TRANSITION + \"End\" : \"transitionend\";\n    // @function get(id: String|HTMLElement): HTMLElement\n    // Returns an element given its DOM id, or returns the element itself\n    // if it was passed directly.\n    function get(id) {\n        return typeof id === \"string\" ? document.getElementById(id) : id;\n    }\n    // @function getStyle(el: HTMLElement, styleAttrib: String): String\n    // Returns the value for a certain style attribute on an element,\n    // including computed values or values set through CSS.\n    function getStyle(el, style) {\n        var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n        if ((!value || value === \"auto\") && document.defaultView) {\n            var css = document.defaultView.getComputedStyle(el, null);\n            value = css ? css[style] : null;\n        }\n        return value === \"auto\" ? null : value;\n    }\n    // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n    // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n    function create$1(tagName, className, container) {\n        var el = document.createElement(tagName);\n        el.className = className || \"\";\n        if (container) {\n            container.appendChild(el);\n        }\n        return el;\n    }\n    // @function remove(el: HTMLElement)\n    // Removes `el` from its parent element\n    function remove(el) {\n        var parent = el.parentNode;\n        if (parent) {\n            parent.removeChild(el);\n        }\n    }\n    // @function empty(el: HTMLElement)\n    // Removes all of `el`'s children elements from `el`\n    function empty(el) {\n        while(el.firstChild){\n            el.removeChild(el.firstChild);\n        }\n    }\n    // @function toFront(el: HTMLElement)\n    // Makes `el` the last child of its parent, so it renders in front of the other children.\n    function toFront(el) {\n        var parent = el.parentNode;\n        if (parent && parent.lastChild !== el) {\n            parent.appendChild(el);\n        }\n    }\n    // @function toBack(el: HTMLElement)\n    // Makes `el` the first child of its parent, so it renders behind the other children.\n    function toBack(el) {\n        var parent = el.parentNode;\n        if (parent && parent.firstChild !== el) {\n            parent.insertBefore(el, parent.firstChild);\n        }\n    }\n    // @function hasClass(el: HTMLElement, name: String): Boolean\n    // Returns `true` if the element's class attribute contains `name`.\n    function hasClass(el, name) {\n        if (el.classList !== undefined) {\n            return el.classList.contains(name);\n        }\n        var className = getClass(el);\n        return className.length > 0 && new RegExp(\"(^|\\\\s)\" + name + \"(\\\\s|$)\").test(className);\n    }\n    // @function addClass(el: HTMLElement, name: String)\n    // Adds `name` to the element's class attribute.\n    function addClass(el, name) {\n        if (el.classList !== undefined) {\n            var classes = splitWords(name);\n            for(var i = 0, len = classes.length; i < len; i++){\n                el.classList.add(classes[i]);\n            }\n        } else if (!hasClass(el, name)) {\n            var className = getClass(el);\n            setClass(el, (className ? className + \" \" : \"\") + name);\n        }\n    }\n    // @function removeClass(el: HTMLElement, name: String)\n    // Removes `name` from the element's class attribute.\n    function removeClass(el, name) {\n        if (el.classList !== undefined) {\n            el.classList.remove(name);\n        } else {\n            setClass(el, trim((\" \" + getClass(el) + \" \").replace(\" \" + name + \" \", \" \")));\n        }\n    }\n    // @function setClass(el: HTMLElement, name: String)\n    // Sets the element's class.\n    function setClass(el, name) {\n        if (el.className.baseVal === undefined) {\n            el.className = name;\n        } else {\n            // in case of SVG element\n            el.className.baseVal = name;\n        }\n    }\n    // @function getClass(el: HTMLElement): String\n    // Returns the element's class.\n    function getClass(el) {\n        // Check if the element is an SVGElementInstance and use the correspondingElement instead\n        // (Required for linked SVG elements in IE11.)\n        if (el.correspondingElement) {\n            el = el.correspondingElement;\n        }\n        return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n    }\n    // @function setOpacity(el: HTMLElement, opacity: Number)\n    // Set the opacity of an element (including old IE support).\n    // `opacity` must be a number from `0` to `1`.\n    function setOpacity(el, value) {\n        if (\"opacity\" in el.style) {\n            el.style.opacity = value;\n        } else if (\"filter\" in el.style) {\n            _setOpacityIE(el, value);\n        }\n    }\n    function _setOpacityIE(el, value) {\n        var filter = false, filterName = \"DXImageTransform.Microsoft.Alpha\";\n        // filters collection throws an error if we try to retrieve a filter that doesn't exist\n        try {\n            filter = el.filters.item(filterName);\n        } catch (e) {\n            // don't set opacity to 1 if we haven't already set an opacity,\n            // it isn't needed and breaks transparent pngs.\n            if (value === 1) {\n                return;\n            }\n        }\n        value = Math.round(value * 100);\n        if (filter) {\n            filter.Enabled = value !== 100;\n            filter.Opacity = value;\n        } else {\n            el.style.filter += \" progid:\" + filterName + \"(opacity=\" + value + \")\";\n        }\n    }\n    // @function testProp(props: String[]): String|false\n    // Goes through the array of style names and returns the first name\n    // that is a valid style name for an element. If no such name is found,\n    // it returns false. Useful for vendor-prefixed styles like `transform`.\n    function testProp(props) {\n        var style = document.documentElement.style;\n        for(var i = 0; i < props.length; i++){\n            if (props[i] in style) {\n                return props[i];\n            }\n        }\n        return false;\n    }\n    // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n    // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n    // and optionally scaled by `scale`. Does not have an effect if the\n    // browser doesn't support 3D CSS transforms.\n    function setTransform(el, offset, scale) {\n        var pos = offset || new Point(0, 0);\n        el.style[TRANSFORM] = (Browser.ie3d ? \"translate(\" + pos.x + \"px,\" + pos.y + \"px)\" : \"translate3d(\" + pos.x + \"px,\" + pos.y + \"px,0)\") + (scale ? \" scale(\" + scale + \")\" : \"\");\n    }\n    // @function setPosition(el: HTMLElement, position: Point)\n    // Sets the position of `el` to coordinates specified by `position`,\n    // using CSS translate or top/left positioning depending on the browser\n    // (used by Leaflet internally to position its layers).\n    function setPosition(el, point) {\n        /*eslint-disable */ el._leaflet_pos = point;\n        /* eslint-enable */ if (Browser.any3d) {\n            setTransform(el, point);\n        } else {\n            el.style.left = point.x + \"px\";\n            el.style.top = point.y + \"px\";\n        }\n    }\n    // @function getPosition(el: HTMLElement): Point\n    // Returns the coordinates of an element previously positioned with setPosition.\n    function getPosition(el) {\n        // this method is only used for elements previously positioned using setPosition,\n        // so it's safe to cache the position for performance\n        return el._leaflet_pos || new Point(0, 0);\n    }\n    // @function disableTextSelection()\n    // Prevents the user from generating `selectstart` DOM events, usually generated\n    // when the user drags the mouse through a page with text. Used internally\n    // by Leaflet to override the behaviour of any click-and-drag interaction on\n    // the map. Affects drag interactions on the whole document.\n    // @function enableTextSelection()\n    // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n    var disableTextSelection;\n    var enableTextSelection;\n    var _userSelect;\n    if (\"onselectstart\" in document) {\n        disableTextSelection = function() {\n            on(window, \"selectstart\", preventDefault);\n        };\n        enableTextSelection = function() {\n            off(window, \"selectstart\", preventDefault);\n        };\n    } else {\n        var userSelectProperty = testProp([\n            \"userSelect\",\n            \"WebkitUserSelect\",\n            \"OUserSelect\",\n            \"MozUserSelect\",\n            \"msUserSelect\"\n        ]);\n        disableTextSelection = function() {\n            if (userSelectProperty) {\n                var style = document.documentElement.style;\n                _userSelect = style[userSelectProperty];\n                style[userSelectProperty] = \"none\";\n            }\n        };\n        enableTextSelection = function() {\n            if (userSelectProperty) {\n                document.documentElement.style[userSelectProperty] = _userSelect;\n                _userSelect = undefined;\n            }\n        };\n    }\n    // @function disableImageDrag()\n    // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n    // for `dragstart` DOM events, usually generated when the user drags an image.\n    function disableImageDrag() {\n        on(window, \"dragstart\", preventDefault);\n    }\n    // @function enableImageDrag()\n    // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n    function enableImageDrag() {\n        off(window, \"dragstart\", preventDefault);\n    }\n    var _outlineElement, _outlineStyle;\n    // @function preventOutline(el: HTMLElement)\n    // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n    // of the element `el` invisible. Used internally by Leaflet to prevent\n    // focusable elements from displaying an outline when the user performs a\n    // drag interaction on them.\n    function preventOutline(element) {\n        while(element.tabIndex === -1){\n            element = element.parentNode;\n        }\n        if (!element.style) {\n            return;\n        }\n        restoreOutline();\n        _outlineElement = element;\n        _outlineStyle = element.style.outlineStyle;\n        element.style.outlineStyle = \"none\";\n        on(window, \"keydown\", restoreOutline);\n    }\n    // @function restoreOutline()\n    // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n    function restoreOutline() {\n        if (!_outlineElement) {\n            return;\n        }\n        _outlineElement.style.outlineStyle = _outlineStyle;\n        _outlineElement = undefined;\n        _outlineStyle = undefined;\n        off(window, \"keydown\", restoreOutline);\n    }\n    // @function getSizedParentNode(el: HTMLElement): HTMLElement\n    // Finds the closest parent node which size (width and height) is not null.\n    function getSizedParentNode(element) {\n        do {\n            element = element.parentNode;\n        }while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n        return element;\n    }\n    // @function getScale(el: HTMLElement): Object\n    // Computes the CSS scale currently applied on the element.\n    // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n    // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n    function getScale(element) {\n        var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n        return {\n            x: rect.width / element.offsetWidth || 1,\n            y: rect.height / element.offsetHeight || 1,\n            boundingClientRect: rect\n        };\n    }\n    var DomUtil = {\n        __proto__: null,\n        TRANSFORM: TRANSFORM,\n        TRANSITION: TRANSITION,\n        TRANSITION_END: TRANSITION_END,\n        get: get,\n        getStyle: getStyle,\n        create: create$1,\n        remove: remove,\n        empty: empty,\n        toFront: toFront,\n        toBack: toBack,\n        hasClass: hasClass,\n        addClass: addClass,\n        removeClass: removeClass,\n        setClass: setClass,\n        getClass: getClass,\n        setOpacity: setOpacity,\n        testProp: testProp,\n        setTransform: setTransform,\n        setPosition: setPosition,\n        getPosition: getPosition,\n        get disableTextSelection () {\n            return disableTextSelection;\n        },\n        get enableTextSelection () {\n            return enableTextSelection;\n        },\n        disableImageDrag: disableImageDrag,\n        enableImageDrag: enableImageDrag,\n        preventOutline: preventOutline,\n        restoreOutline: restoreOutline,\n        getSizedParentNode: getSizedParentNode,\n        getScale: getScale\n    };\n    /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */ // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n    // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n    // Adds a listener function (`fn`) to a particular DOM event type of the\n    // element `el`. You can optionally specify the context of the listener\n    // (object the `this` keyword will point to). You can also pass several\n    // space-separated types (e.g. `'click dblclick'`).\n    // @alternative\n    // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n    // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n    function on(obj, types, fn, context) {\n        if (types && typeof types === \"object\") {\n            for(var type in types){\n                addOne(obj, type, types[type], fn);\n            }\n        } else {\n            types = splitWords(types);\n            for(var i = 0, len = types.length; i < len; i++){\n                addOne(obj, types[i], fn, context);\n            }\n        }\n        return this;\n    }\n    var eventsKey = \"_leaflet_events\";\n    // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n    // Removes a previously added listener function.\n    // Note that if you passed a custom context to on, you must pass the same\n    // context to `off` in order to remove the listener.\n    // @alternative\n    // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n    // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n    // @alternative\n    // @function off(el: HTMLElement, types: String): this\n    // Removes all previously added listeners of given types.\n    // @alternative\n    // @function off(el: HTMLElement): this\n    // Removes all previously added listeners from given HTMLElement\n    function off(obj, types, fn, context) {\n        if (arguments.length === 1) {\n            batchRemove(obj);\n            delete obj[eventsKey];\n        } else if (types && typeof types === \"object\") {\n            for(var type in types){\n                removeOne(obj, type, types[type], fn);\n            }\n        } else {\n            types = splitWords(types);\n            if (arguments.length === 2) {\n                batchRemove(obj, function(type) {\n                    return indexOf(types, type) !== -1;\n                });\n            } else {\n                for(var i = 0, len = types.length; i < len; i++){\n                    removeOne(obj, types[i], fn, context);\n                }\n            }\n        }\n        return this;\n    }\n    function batchRemove(obj, filterFn) {\n        for(var id in obj[eventsKey]){\n            var type = id.split(/\\d/)[0];\n            if (!filterFn || filterFn(type)) {\n                removeOne(obj, type, null, null, id);\n            }\n        }\n    }\n    var mouseSubst = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\",\n        wheel: !(\"onwheel\" in window) && \"mousewheel\"\n    };\n    function addOne(obj, type, fn, context) {\n        var id = type + stamp(fn) + (context ? \"_\" + stamp(context) : \"\");\n        if (obj[eventsKey] && obj[eventsKey][id]) {\n            return this;\n        }\n        var handler = function(e) {\n            return fn.call(context || obj, e || window.event);\n        };\n        var originalHandler = handler;\n        if (!Browser.touchNative && Browser.pointer && type.indexOf(\"touch\") === 0) {\n            // Needs DomEvent.Pointer.js\n            handler = addPointerListener(obj, type, handler);\n        } else if (Browser.touch && type === \"dblclick\") {\n            handler = addDoubleTapListener(obj, handler);\n        } else if (\"addEventListener\" in obj) {\n            if (type === \"touchstart\" || type === \"touchmove\" || type === \"wheel\" || type === \"mousewheel\") {\n                obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n                    passive: false\n                } : false);\n            } else if (type === \"mouseenter\" || type === \"mouseleave\") {\n                handler = function(e) {\n                    e = e || window.event;\n                    if (isExternalTarget(obj, e)) {\n                        originalHandler(e);\n                    }\n                };\n                obj.addEventListener(mouseSubst[type], handler, false);\n            } else {\n                obj.addEventListener(type, originalHandler, false);\n            }\n        } else {\n            obj.attachEvent(\"on\" + type, handler);\n        }\n        obj[eventsKey] = obj[eventsKey] || {};\n        obj[eventsKey][id] = handler;\n    }\n    function removeOne(obj, type, fn, context, id) {\n        id = id || type + stamp(fn) + (context ? \"_\" + stamp(context) : \"\");\n        var handler = obj[eventsKey] && obj[eventsKey][id];\n        if (!handler) {\n            return this;\n        }\n        if (!Browser.touchNative && Browser.pointer && type.indexOf(\"touch\") === 0) {\n            removePointerListener(obj, type, handler);\n        } else if (Browser.touch && type === \"dblclick\") {\n            removeDoubleTapListener(obj, handler);\n        } else if (\"removeEventListener\" in obj) {\n            obj.removeEventListener(mouseSubst[type] || type, handler, false);\n        } else {\n            obj.detachEvent(\"on\" + type, handler);\n        }\n        obj[eventsKey][id] = null;\n    }\n    // @function stopPropagation(ev: DOMEvent): this\n    // Stop the given event from propagation to parent elements. Used inside the listener functions:\n    // ```js\n    // L.DomEvent.on(div, 'click', function (ev) {\n    // \tL.DomEvent.stopPropagation(ev);\n    // });\n    // ```\n    function stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        } else if (e.originalEvent) {\n            e.originalEvent._stopped = true;\n        } else {\n            e.cancelBubble = true;\n        }\n        return this;\n    }\n    // @function disableScrollPropagation(el: HTMLElement): this\n    // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n    function disableScrollPropagation(el) {\n        addOne(el, \"wheel\", stopPropagation);\n        return this;\n    }\n    // @function disableClickPropagation(el: HTMLElement): this\n    // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n    // `'mousedown'` and `'touchstart'` events (plus browser variants).\n    function disableClickPropagation(el) {\n        on(el, \"mousedown touchstart dblclick contextmenu\", stopPropagation);\n        el[\"_leaflet_disable_click\"] = true;\n        return this;\n    }\n    // @function preventDefault(ev: DOMEvent): this\n    // Prevents the default action of the DOM Event `ev` from happening (such as\n    // following a link in the href of the a element, or doing a POST request\n    // with page reload when a `<form>` is submitted).\n    // Use it inside listener functions.\n    function preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n        return this;\n    }\n    // @function stop(ev: DOMEvent): this\n    // Does `stopPropagation` and `preventDefault` at the same time.\n    function stop(e) {\n        preventDefault(e);\n        stopPropagation(e);\n        return this;\n    }\n    // @function getPropagationPath(ev: DOMEvent): Array\n    // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n    // Returns an array containing the `HTMLElement`s that the given DOM event\n    // should propagate to (if not stopped).\n    function getPropagationPath(ev) {\n        if (ev.composedPath) {\n            return ev.composedPath();\n        }\n        var path = [];\n        var el = ev.target;\n        while(el){\n            path.push(el);\n            el = el.parentNode;\n        }\n        return path;\n    }\n    // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n    // Gets normalized mouse position from a DOM event relative to the\n    // `container` (border excluded) or to the whole page if not specified.\n    function getMousePosition(e, container) {\n        if (!container) {\n            return new Point(e.clientX, e.clientY);\n        }\n        var scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n        return new Point(// offset.left/top values are in page scale (like clientX/Y),\n        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n        (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n    }\n    //  except , Safari and\n    // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n    // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n    var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n    // @function getWheelDelta(ev: DOMEvent): Number\n    // Gets normalized wheel delta from a wheel DOM event, in vertical\n    // pixels scrolled (negative if scrolling down).\n    // Events from pointing devices without precise scrolling are mapped to\n    // a best guess of 60 pixels.\n    function getWheelDelta(e) {\n        return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;\n    }\n    // check if element really left/entered the event target (for mouseenter/mouseleave)\n    function isExternalTarget(el, e) {\n        var related = e.relatedTarget;\n        if (!related) {\n            return true;\n        }\n        try {\n            while(related && related !== el){\n                related = related.parentNode;\n            }\n        } catch (err) {\n            return false;\n        }\n        return related !== el;\n    }\n    var DomEvent = {\n        __proto__: null,\n        on: on,\n        off: off,\n        stopPropagation: stopPropagation,\n        disableScrollPropagation: disableScrollPropagation,\n        disableClickPropagation: disableClickPropagation,\n        preventDefault: preventDefault,\n        stop: stop,\n        getPropagationPath: getPropagationPath,\n        getMousePosition: getMousePosition,\n        getWheelDelta: getWheelDelta,\n        isExternalTarget: isExternalTarget,\n        addListener: on,\n        removeListener: off\n    };\n    /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */ var PosAnimation = Evented.extend({\n        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n        // Run an animation of a given element to a new position, optionally setting\n        // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n        // `0.5` by default).\n        run: function(el, newPos, duration, easeLinearity) {\n            this.stop();\n            this._el = el;\n            this._inProgress = true;\n            this._duration = duration || 0.25;\n            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n            this._startPos = getPosition(el);\n            this._offset = newPos.subtract(this._startPos);\n            this._startTime = +new Date();\n            // @event start: Event\n            // Fired when the animation starts\n            this.fire(\"start\");\n            this._animate();\n        },\n        // @method stop()\n        // Stops the animation (if currently running).\n        stop: function() {\n            if (!this._inProgress) {\n                return;\n            }\n            this._step(true);\n            this._complete();\n        },\n        _animate: function() {\n            // animation loop\n            this._animId = requestAnimFrame(this._animate, this);\n            this._step();\n        },\n        _step: function(round) {\n            var elapsed = +new Date() - this._startTime, duration = this._duration * 1000;\n            if (elapsed < duration) {\n                this._runFrame(this._easeOut(elapsed / duration), round);\n            } else {\n                this._runFrame(1);\n                this._complete();\n            }\n        },\n        _runFrame: function(progress, round) {\n            var pos = this._startPos.add(this._offset.multiplyBy(progress));\n            if (round) {\n                pos._round();\n            }\n            setPosition(this._el, pos);\n            // @event step: Event\n            // Fired continuously during the animation.\n            this.fire(\"step\");\n        },\n        _complete: function() {\n            cancelAnimFrame(this._animId);\n            this._inProgress = false;\n            // @event end: Event\n            // Fired when the animation ends.\n            this.fire(\"end\");\n        },\n        _easeOut: function(t) {\n            return 1 - Math.pow(1 - t, this._easeOutPower);\n        }\n    });\n    /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */ var Map = Evented.extend({\n        options: {\n            // @section Map State Options\n            // @option crs: CRS = L.CRS.EPSG3857\n            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n            // sure what it means.\n            crs: EPSG3857,\n            // @option center: LatLng = undefined\n            // Initial geographic center of the map\n            center: undefined,\n            // @option zoom: Number = undefined\n            // Initial map zoom level\n            zoom: undefined,\n            // @option minZoom: Number = *\n            // Minimum zoom level of the map.\n            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n            // the lowest of their `minZoom` options will be used instead.\n            minZoom: undefined,\n            // @option maxZoom: Number = *\n            // Maximum zoom level of the map.\n            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n            // the highest of their `maxZoom` options will be used instead.\n            maxZoom: undefined,\n            // @option layers: Layer[] = []\n            // Array of layers that will be added to the map initially\n            layers: [],\n            // @option maxBounds: LatLngBounds = null\n            // When this option is set, the map restricts the view to the given\n            // geographical bounds, bouncing the user back if the user tries to pan\n            // outside the view. To set the restriction dynamically, use\n            // [`setMaxBounds`](#map-setmaxbounds) method.\n            maxBounds: undefined,\n            // @option renderer: Renderer = *\n            // The default method for drawing vector layers on the map. `L.SVG`\n            // or `L.Canvas` by default depending on browser support.\n            renderer: undefined,\n            // @section Animation Options\n            // @option zoomAnimation: Boolean = true\n            // Whether the map zoom animation is enabled. By default it's enabled\n            // in all browsers that support CSS3 Transitions except Android.\n            zoomAnimation: true,\n            // @option zoomAnimationThreshold: Number = 4\n            // Won't animate zoom if the zoom difference exceeds this value.\n            zoomAnimationThreshold: 4,\n            // @option fadeAnimation: Boolean = true\n            // Whether the tile fade animation is enabled. By default it's enabled\n            // in all browsers that support CSS3 Transitions except Android.\n            fadeAnimation: true,\n            // @option markerZoomAnimation: Boolean = true\n            // Whether markers animate their zoom with the zoom animation, if disabled\n            // they will disappear for the length of the animation. By default it's\n            // enabled in all browsers that support CSS3 Transitions except Android.\n            markerZoomAnimation: true,\n            // @option transform3DLimit: Number = 2^23\n            // Defines the maximum size of a CSS translation transform. The default\n            // value should not be changed unless a web browser positions layers in\n            // the wrong place after doing a large `panBy`.\n            transform3DLimit: 8388608,\n            // @section Interaction Options\n            // @option zoomSnap: Number = 1\n            // Forces the map's zoom level to always be a multiple of this, particularly\n            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n            // By default, the zoom level snaps to the nearest integer; lower values\n            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n            zoomSnap: 1,\n            // @option zoomDelta: Number = 1\n            // Controls how much the map's zoom level will change after a\n            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n            zoomDelta: 1,\n            // @option trackResize: Boolean = true\n            // Whether the map automatically handles browser window resize to update itself.\n            trackResize: true\n        },\n        initialize: function(id, options) {\n            options = setOptions(this, options);\n            // Make sure to assign internal flags at the beginning,\n            // to avoid inconsistent state in some edge cases.\n            this._handlers = [];\n            this._layers = {};\n            this._zoomBoundLayers = {};\n            this._sizeChanged = true;\n            this._initContainer(id);\n            this._initLayout();\n            // hack for https://github.com/Leaflet/Leaflet/issues/1980\n            this._onResize = bind(this._onResize, this);\n            this._initEvents();\n            if (options.maxBounds) {\n                this.setMaxBounds(options.maxBounds);\n            }\n            if (options.zoom !== undefined) {\n                this._zoom = this._limitZoom(options.zoom);\n            }\n            if (options.center && options.zoom !== undefined) {\n                this.setView(toLatLng(options.center), options.zoom, {\n                    reset: true\n                });\n            }\n            this.callInitHooks();\n            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n            // zoom transitions run with the same duration for all layers, so if one of transitionend events\n            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n            if (this._zoomAnimated) {\n                this._createAnimProxy();\n                on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n            }\n            this._addLayers(this.options.layers);\n        },\n        // @section Methods for modifying map state\n        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n        // Sets the view of the map (geographical center and zoom) with the given\n        // animation options.\n        setView: function(center, zoom, options) {\n            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n            center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n            options = options || {};\n            this._stop();\n            if (this._loaded && !options.reset && options !== true) {\n                if (options.animate !== undefined) {\n                    options.zoom = extend({\n                        animate: options.animate\n                    }, options.zoom);\n                    options.pan = extend({\n                        animate: options.animate,\n                        duration: options.duration\n                    }, options.pan);\n                }\n                // try animating pan or zoom\n                var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n                if (moved) {\n                    // prevent resize handler call, the view will refresh after animation anyway\n                    clearTimeout(this._sizeTimer);\n                    return this;\n                }\n            }\n            // animation didn't start, just reset the map view\n            this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n            return this;\n        },\n        // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n        // Sets the zoom of the map.\n        setZoom: function(zoom, options) {\n            if (!this._loaded) {\n                this._zoom = zoom;\n                return this;\n            }\n            return this.setView(this.getCenter(), zoom, {\n                zoom: options\n            });\n        },\n        // @method zoomIn(delta?: Number, options?: Zoom options): this\n        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n        zoomIn: function(delta, options) {\n            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n            return this.setZoom(this._zoom + delta, options);\n        },\n        // @method zoomOut(delta?: Number, options?: Zoom options): this\n        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n        zoomOut: function(delta, options) {\n            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n            return this.setZoom(this._zoom - delta, options);\n        },\n        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n        // Zooms the map while keeping a specified geographical point on the map\n        // stationary (e.g. used internally for scroll zoom and double-click zoom).\n        // @alternative\n        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n        setZoomAround: function(latlng, zoom, options) {\n            var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n            return this.setView(newCenter, zoom, {\n                zoom: options\n            });\n        },\n        _getBoundsCenterZoom: function(bounds, options) {\n            options = options || {};\n            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [\n                0,\n                0\n            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [\n                0,\n                0\n            ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n            zoom = typeof options.maxZoom === \"number\" ? Math.min(options.maxZoom, zoom) : zoom;\n            if (zoom === Infinity) {\n                return {\n                    center: bounds.getCenter(),\n                    zoom: zoom\n                };\n            }\n            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n            return {\n                center: center,\n                zoom: zoom\n            };\n        },\n        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n        // Sets a map view that contains the given geographical bounds with the\n        // maximum zoom level possible.\n        fitBounds: function(bounds, options) {\n            bounds = toLatLngBounds(bounds);\n            if (!bounds.isValid()) {\n                throw new Error(\"Bounds are not valid.\");\n            }\n            var target = this._getBoundsCenterZoom(bounds, options);\n            return this.setView(target.center, target.zoom, options);\n        },\n        // @method fitWorld(options?: fitBounds options): this\n        // Sets a map view that mostly contains the whole world with the maximum\n        // zoom level possible.\n        fitWorld: function(options) {\n            return this.fitBounds([\n                [\n                    -90,\n                    -180\n                ],\n                [\n                    90,\n                    180\n                ]\n            ], options);\n        },\n        // @method panTo(latlng: LatLng, options?: Pan options): this\n        // Pans the map to a given center.\n        panTo: function(center, options) {\n            return this.setView(center, this._zoom, {\n                pan: options\n            });\n        },\n        // @method panBy(offset: Point, options?: Pan options): this\n        // Pans the map by a given number of pixels (animated).\n        panBy: function(offset, options) {\n            offset = toPoint(offset).round();\n            options = options || {};\n            if (!offset.x && !offset.y) {\n                return this.fire(\"moveend\");\n            }\n            // If we pan too far, Chrome gets issues with tiles\n            // and makes them disappear or appear in the wrong place (slightly offset) #2602\n            if (options.animate !== true && !this.getSize().contains(offset)) {\n                this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n                return this;\n            }\n            if (!this._panAnim) {\n                this._panAnim = new PosAnimation();\n                this._panAnim.on({\n                    \"step\": this._onPanTransitionStep,\n                    \"end\": this._onPanTransitionEnd\n                }, this);\n            }\n            // don't fire movestart if animating inertia\n            if (!options.noMoveStart) {\n                this.fire(\"movestart\");\n            }\n            // animate pan unless animate: false specified\n            if (options.animate !== false) {\n                addClass(this._mapPane, \"leaflet-pan-anim\");\n                var newPos = this._getMapPanePos().subtract(offset).round();\n                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n            } else {\n                this._rawPanBy(offset);\n                this.fire(\"move\").fire(\"moveend\");\n            }\n            return this;\n        },\n        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n        // Sets the view of the map (geographical center and zoom) performing a smooth\n        // pan-zoom animation.\n        flyTo: function(targetCenter, targetZoom, options) {\n            options = options || {};\n            if (options.animate === false || !Browser.any3d) {\n                return this.setView(targetCenter, targetZoom, options);\n            }\n            this._stop();\n            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;\n            targetCenter = toLatLng(targetCenter);\n            targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;\n            function r(i) {\n                var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;\n                // workaround for floating point precision bug when sq = 0, log = -Infinite,\n                // thus triggering an infinite loop in flyTo\n                var log = sq < 0.000000001 ? -18 : Math.log(sq);\n                return log;\n            }\n            function sinh(n) {\n                return (Math.exp(n) - Math.exp(-n)) / 2;\n            }\n            function cosh(n) {\n                return (Math.exp(n) + Math.exp(-n)) / 2;\n            }\n            function tanh(n) {\n                return sinh(n) / cosh(n);\n            }\n            var r0 = r(0);\n            function w(s) {\n                return w0 * (cosh(r0) / cosh(r0 + rho * s));\n            }\n            function u(s) {\n                return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n            }\n            function easeOut(t) {\n                return 1 - Math.pow(1 - t, 1.5);\n            }\n            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n            function frame() {\n                var t = (Date.now() - start) / duration, s = easeOut(t) * S;\n                if (t <= 1) {\n                    this._flyToFrame = requestAnimFrame(frame, this);\n                    this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n                        flyTo: true\n                    });\n                } else {\n                    this._move(targetCenter, targetZoom)._moveEnd(true);\n                }\n            }\n            this._moveStart(true, options.noMoveStart);\n            frame.call(this);\n            return this;\n        },\n        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n        flyToBounds: function(bounds, options) {\n            var target = this._getBoundsCenterZoom(bounds, options);\n            return this.flyTo(target.center, target.zoom, options);\n        },\n        // @method setMaxBounds(bounds: LatLngBounds): this\n        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n        setMaxBounds: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            if (this.listens(\"moveend\", this._panInsideMaxBounds)) {\n                this.off(\"moveend\", this._panInsideMaxBounds);\n            }\n            if (!bounds.isValid()) {\n                this.options.maxBounds = null;\n                return this;\n            }\n            this.options.maxBounds = bounds;\n            if (this._loaded) {\n                this._panInsideMaxBounds();\n            }\n            return this.on(\"moveend\", this._panInsideMaxBounds);\n        },\n        // @method setMinZoom(zoom: Number): this\n        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n        setMinZoom: function(zoom) {\n            var oldZoom = this.options.minZoom;\n            this.options.minZoom = zoom;\n            if (this._loaded && oldZoom !== zoom) {\n                this.fire(\"zoomlevelschange\");\n                if (this.getZoom() < this.options.minZoom) {\n                    return this.setZoom(zoom);\n                }\n            }\n            return this;\n        },\n        // @method setMaxZoom(zoom: Number): this\n        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n        setMaxZoom: function(zoom) {\n            var oldZoom = this.options.maxZoom;\n            this.options.maxZoom = zoom;\n            if (this._loaded && oldZoom !== zoom) {\n                this.fire(\"zoomlevelschange\");\n                if (this.getZoom() > this.options.maxZoom) {\n                    return this.setZoom(zoom);\n                }\n            }\n            return this;\n        },\n        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n        panInsideBounds: function(bounds, options) {\n            this._enforcingBounds = true;\n            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n            if (!center.equals(newCenter)) {\n                this.panTo(newCenter, options);\n            }\n            this._enforcingBounds = false;\n            return this;\n        },\n        // @method panInside(latlng: LatLng, options?: padding options): this\n        // Pans the map the minimum amount to make the `latlng` visible. Use\n        // padding options to fit the display to more restricted bounds.\n        // If `latlng` is already within the (optionally padded) display bounds,\n        // the map will not be panned.\n        panInside: function(latlng, options) {\n            options = options || {};\n            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [\n                0,\n                0\n            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [\n                0,\n                0\n            ]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([\n                pixelBounds.min.add(paddingTL),\n                pixelBounds.max.subtract(paddingBR)\n            ]), paddedSize = paddedBounds.getSize();\n            if (!paddedBounds.contains(pixelPoint)) {\n                this._enforcingBounds = true;\n                var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n                var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n                pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n                pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n                this.panTo(this.unproject(pixelCenter), options);\n                this._enforcingBounds = false;\n            }\n            return this;\n        },\n        // @method invalidateSize(options: Zoom/pan options): this\n        // Checks if the map container size changed and updates the map if so \n        // call it after you've changed the map size dynamically, also animating\n        // pan by default. If `options.pan` is `false`, panning will not occur.\n        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n        // that it doesn't happen often even if the method is called many\n        // times in a row.\n        // @alternative\n        // @method invalidateSize(animate: Boolean): this\n        // Checks if the map container size changed and updates the map if so \n        // call it after you've changed the map size dynamically, also animating\n        // pan by default.\n        invalidateSize: function(options) {\n            if (!this._loaded) {\n                return this;\n            }\n            options = extend({\n                animate: false,\n                pan: true\n            }, options === true ? {\n                animate: true\n            } : options);\n            var oldSize = this.getSize();\n            this._sizeChanged = true;\n            this._lastCenter = null;\n            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);\n            if (!offset.x && !offset.y) {\n                return this;\n            }\n            if (options.animate && options.pan) {\n                this.panBy(offset);\n            } else {\n                if (options.pan) {\n                    this._rawPanBy(offset);\n                }\n                this.fire(\"move\");\n                if (options.debounceMoveend) {\n                    clearTimeout(this._sizeTimer);\n                    this._sizeTimer = setTimeout(bind(this.fire, this, \"moveend\"), 200);\n                } else {\n                    this.fire(\"moveend\");\n                }\n            }\n            // @section Map state change events\n            // @event resize: ResizeEvent\n            // Fired when the map is resized.\n            return this.fire(\"resize\", {\n                oldSize: oldSize,\n                newSize: newSize\n            });\n        },\n        // @section Methods for modifying map state\n        // @method stop(): this\n        // Stops the currently running `panTo` or `flyTo` animation, if any.\n        stop: function() {\n            this.setZoom(this._limitZoom(this._zoom));\n            if (!this.options.zoomSnap) {\n                this.fire(\"viewreset\");\n            }\n            return this._stop();\n        },\n        // @section Geolocation methods\n        // @method locate(options?: Locate options): this\n        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n        // and optionally sets the map view to the user's location with respect to\n        // detection accuracy (or to the world view if geolocation failed).\n        // Note that, if your page doesn't use HTTPS, this method will fail in\n        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n        // See `Locate options` for more details.\n        locate: function(options) {\n            options = this._locateOptions = extend({\n                timeout: 10000,\n                watch: false\n            }, options);\n            if (!(\"geolocation\" in navigator)) {\n                this._handleGeolocationError({\n                    code: 0,\n                    message: \"Geolocation not supported.\"\n                });\n                return this;\n            }\n            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);\n            if (options.watch) {\n                this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n            } else {\n                navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n            }\n            return this;\n        },\n        // @method stopLocate(): this\n        // Stops watching location previously initiated by `map.locate({watch: true})`\n        // and aborts resetting the map view if map.locate was called with\n        // `{setView: true}`.\n        stopLocate: function() {\n            if (navigator.geolocation && navigator.geolocation.clearWatch) {\n                navigator.geolocation.clearWatch(this._locationWatchId);\n            }\n            if (this._locateOptions) {\n                this._locateOptions.setView = false;\n            }\n            return this;\n        },\n        _handleGeolocationError: function(error) {\n            if (!this._container._leaflet_id) {\n                return;\n            }\n            var c = error.code, message = error.message || (c === 1 ? \"permission denied\" : c === 2 ? \"position unavailable\" : \"timeout\");\n            if (this._locateOptions.setView && !this._loaded) {\n                this.fitWorld();\n            }\n            // @section Location events\n            // @event locationerror: ErrorEvent\n            // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n            this.fire(\"locationerror\", {\n                code: c,\n                message: \"Geolocation error: \" + message + \".\"\n            });\n        },\n        _handleGeolocationResponse: function(pos) {\n            if (!this._container._leaflet_id) {\n                return;\n            }\n            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;\n            if (options.setView) {\n                var zoom = this.getBoundsZoom(bounds);\n                this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n            }\n            var data = {\n                latlng: latlng,\n                bounds: bounds,\n                timestamp: pos.timestamp\n            };\n            for(var i in pos.coords){\n                if (typeof pos.coords[i] === \"number\") {\n                    data[i] = pos.coords[i];\n                }\n            }\n            // @event locationfound: LocationEvent\n            // Fired when geolocation (using the [`locate`](#map-locate) method)\n            // went successfully.\n            this.fire(\"locationfound\", data);\n        },\n        // TODO Appropriate docs section?\n        // @section Other Methods\n        // @method addHandler(name: String, HandlerClass: Function): this\n        // Adds a new `Handler` to the map, given its name and constructor function.\n        addHandler: function(name, HandlerClass) {\n            if (!HandlerClass) {\n                return this;\n            }\n            var handler = this[name] = new HandlerClass(this);\n            this._handlers.push(handler);\n            if (this.options[name]) {\n                handler.enable();\n            }\n            return this;\n        },\n        // @method remove(): this\n        // Destroys the map and clears all related event listeners.\n        remove: function() {\n            this._initEvents(true);\n            if (this.options.maxBounds) {\n                this.off(\"moveend\", this._panInsideMaxBounds);\n            }\n            if (this._containerId !== this._container._leaflet_id) {\n                throw new Error(\"Map container is being reused by another instance\");\n            }\n            try {\n                // throws error in IE6-8\n                delete this._container._leaflet_id;\n                delete this._containerId;\n            } catch (e) {\n                /*eslint-disable */ this._container._leaflet_id = undefined;\n                /* eslint-enable */ this._containerId = undefined;\n            }\n            if (this._locationWatchId !== undefined) {\n                this.stopLocate();\n            }\n            this._stop();\n            remove(this._mapPane);\n            if (this._clearControlPos) {\n                this._clearControlPos();\n            }\n            if (this._resizeRequest) {\n                cancelAnimFrame(this._resizeRequest);\n                this._resizeRequest = null;\n            }\n            this._clearHandlers();\n            if (this._loaded) {\n                // @section Map state change events\n                // @event unload: Event\n                // Fired when the map is destroyed with [remove](#map-remove) method.\n                this.fire(\"unload\");\n            }\n            var i;\n            for(i in this._layers){\n                this._layers[i].remove();\n            }\n            for(i in this._panes){\n                remove(this._panes[i]);\n            }\n            this._layers = [];\n            this._panes = [];\n            delete this._mapPane;\n            delete this._renderer;\n            return this;\n        },\n        // @section Other Methods\n        // @method createPane(name: String, container?: HTMLElement): HTMLElement\n        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n        // then returns it. The pane is created as a child of `container`, or\n        // as a child of the main map pane if not set.\n        createPane: function(name, container) {\n            var className = \"leaflet-pane\" + (name ? \" leaflet-\" + name.replace(\"Pane\", \"\") + \"-pane\" : \"\"), pane = create$1(\"div\", className, container || this._mapPane);\n            if (name) {\n                this._panes[name] = pane;\n            }\n            return pane;\n        },\n        // @section Methods for Getting Map State\n        // @method getCenter(): LatLng\n        // Returns the geographical center of the map view\n        getCenter: function() {\n            this._checkIfLoaded();\n            if (this._lastCenter && !this._moved()) {\n                return this._lastCenter.clone();\n            }\n            return this.layerPointToLatLng(this._getCenterLayerPoint());\n        },\n        // @method getZoom(): Number\n        // Returns the current zoom level of the map view\n        getZoom: function() {\n            return this._zoom;\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the geographical bounds visible in the current map view\n        getBounds: function() {\n            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());\n            return new LatLngBounds(sw, ne);\n        },\n        // @method getMinZoom(): Number\n        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n        getMinZoom: function() {\n            return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n        },\n        // @method getMaxZoom(): Number\n        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n        getMaxZoom: function() {\n            return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n        },\n        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n        // Returns the maximum zoom level on which the given bounds fit to the map\n        // view in its entirety. If `inside` (optional) is set to `true`, the method\n        // instead returns the minimum zoom level on which the map view fits into\n        // the given bounds in its entirety.\n        getBoundsZoom: function(bounds, inside, padding) {\n            bounds = toLatLngBounds(bounds);\n            padding = toPoint(padding || [\n                0,\n                0\n            ]);\n            var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n            zoom = this.getScaleZoom(scale, zoom);\n            if (snap) {\n                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n            }\n            return Math.max(min, Math.min(max, zoom));\n        },\n        // @method getSize(): Point\n        // Returns the current size of the map container (in pixels).\n        getSize: function() {\n            if (!this._size || this._sizeChanged) {\n                this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n                this._sizeChanged = false;\n            }\n            return this._size.clone();\n        },\n        // @method getPixelBounds(): Bounds\n        // Returns the bounds of the current map view in projected pixel\n        // coordinates (sometimes useful in layer and overlay implementations).\n        getPixelBounds: function(center, zoom) {\n            var topLeftPoint = this._getTopLeftPoint(center, zoom);\n            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n        },\n        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n        // the map pane? \"left point of the map layer\" can be confusing, specially\n        // since there can be negative offsets.\n        // @method getPixelOrigin(): Point\n        // Returns the projected pixel coordinates of the top left point of\n        // the map layer (useful in custom layer and overlay implementations).\n        getPixelOrigin: function() {\n            this._checkIfLoaded();\n            return this._pixelOrigin;\n        },\n        // @method getPixelWorldBounds(zoom?: Number): Bounds\n        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n        // If `zoom` is omitted, the map's current zoom level is used.\n        getPixelWorldBounds: function(zoom) {\n            return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n        },\n        // @section Other Methods\n        // @method getPane(pane: String|HTMLElement): HTMLElement\n        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n        getPane: function(pane) {\n            return typeof pane === \"string\" ? this._panes[pane] : pane;\n        },\n        // @method getPanes(): Object\n        // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n        // the panes as values.\n        getPanes: function() {\n            return this._panes;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTML element that contains the map.\n        getContainer: function() {\n            return this._container;\n        },\n        // @section Conversion Methods\n        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n        // Returns the scale factor to be applied to a map transition from zoom level\n        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n        getZoomScale: function(toZoom, fromZoom) {\n            // TODO replace with universal implementation after refactoring projections\n            var crs = this.options.crs;\n            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n            return crs.scale(toZoom) / crs.scale(fromZoom);\n        },\n        // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n        // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n        // level and everything is scaled by a factor of `scale`. Inverse of\n        // [`getZoomScale`](#map-getZoomScale).\n        getScaleZoom: function(scale, fromZoom) {\n            var crs = this.options.crs;\n            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n            var zoom = crs.zoom(scale * crs.scale(fromZoom));\n            return isNaN(zoom) ? Infinity : zoom;\n        },\n        // @method project(latlng: LatLng, zoom: Number): Point\n        // Projects a geographical coordinate `LatLng` according to the projection\n        // of the map's CRS, then scales it according to `zoom` and the CRS's\n        // `Transformation`. The result is pixel coordinate relative to\n        // the CRS origin.\n        project: function(latlng, zoom) {\n            zoom = zoom === undefined ? this._zoom : zoom;\n            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n        },\n        // @method unproject(point: Point, zoom: Number): LatLng\n        // Inverse of [`project`](#map-project).\n        unproject: function(point, zoom) {\n            zoom = zoom === undefined ? this._zoom : zoom;\n            return this.options.crs.pointToLatLng(toPoint(point), zoom);\n        },\n        // @method layerPointToLatLng(point: Point): LatLng\n        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n        // returns the corresponding geographical coordinate (for the current zoom level).\n        layerPointToLatLng: function(point) {\n            var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n            return this.unproject(projectedPoint);\n        },\n        // @method latLngToLayerPoint(latlng: LatLng): Point\n        // Given a geographical coordinate, returns the corresponding pixel coordinate\n        // relative to the [origin pixel](#map-getpixelorigin).\n        latLngToLayerPoint: function(latlng) {\n            var projectedPoint = this.project(toLatLng(latlng))._round();\n            return projectedPoint._subtract(this.getPixelOrigin());\n        },\n        // @method wrapLatLng(latlng: LatLng): LatLng\n        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n        // CRS's bounds.\n        // By default this means longitude is wrapped around the dateline so its\n        // value is between -180 and +180 degrees.\n        wrapLatLng: function(latlng) {\n            return this.options.crs.wrapLatLng(toLatLng(latlng));\n        },\n        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n        // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n        // its center is within the CRS's bounds.\n        // By default this means the center longitude is wrapped around the dateline so its\n        // value is between -180 and +180 degrees, and the majority of the bounds\n        // overlaps the CRS's bounds.\n        wrapLatLngBounds: function(latlng) {\n            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n        },\n        // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n        // Returns the distance between two geographical coordinates according to\n        // the map's CRS. By default this measures distance in meters.\n        distance: function(latlng1, latlng2) {\n            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n        },\n        // @method containerPointToLayerPoint(point: Point): Point\n        // Given a pixel coordinate relative to the map container, returns the corresponding\n        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n        containerPointToLayerPoint: function(point) {\n            return toPoint(point).subtract(this._getMapPanePos());\n        },\n        // @method layerPointToContainerPoint(point: Point): Point\n        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n        // returns the corresponding pixel coordinate relative to the map container.\n        layerPointToContainerPoint: function(point) {\n            return toPoint(point).add(this._getMapPanePos());\n        },\n        // @method containerPointToLatLng(point: Point): LatLng\n        // Given a pixel coordinate relative to the map container, returns\n        // the corresponding geographical coordinate (for the current zoom level).\n        containerPointToLatLng: function(point) {\n            var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n            return this.layerPointToLatLng(layerPoint);\n        },\n        // @method latLngToContainerPoint(latlng: LatLng): Point\n        // Given a geographical coordinate, returns the corresponding pixel coordinate\n        // relative to the map container.\n        latLngToContainerPoint: function(latlng) {\n            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n        },\n        // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n        // Given a MouseEvent object, returns the pixel coordinate relative to the\n        // map container where the event took place.\n        mouseEventToContainerPoint: function(e) {\n            return getMousePosition(e, this._container);\n        },\n        // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n        // Given a MouseEvent object, returns the pixel coordinate relative to\n        // the [origin pixel](#map-getpixelorigin) where the event took place.\n        mouseEventToLayerPoint: function(e) {\n            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n        },\n        // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n        // Given a MouseEvent object, returns geographical coordinate where the\n        // event took place.\n        mouseEventToLatLng: function(e) {\n            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n        },\n        // map initialization methods\n        _initContainer: function(id) {\n            var container = this._container = get(id);\n            if (!container) {\n                throw new Error(\"Map container not found.\");\n            } else if (container._leaflet_id) {\n                throw new Error(\"Map container is already initialized.\");\n            }\n            on(container, \"scroll\", this._onScroll, this);\n            this._containerId = stamp(container);\n        },\n        _initLayout: function() {\n            var container = this._container;\n            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n            addClass(container, \"leaflet-container\" + (Browser.touch ? \" leaflet-touch\" : \"\") + (Browser.retina ? \" leaflet-retina\" : \"\") + (Browser.ielt9 ? \" leaflet-oldie\" : \"\") + (Browser.safari ? \" leaflet-safari\" : \"\") + (this._fadeAnimated ? \" leaflet-fade-anim\" : \"\"));\n            var position = getStyle(container, \"position\");\n            if (position !== \"absolute\" && position !== \"relative\" && position !== \"fixed\" && position !== \"sticky\") {\n                container.style.position = \"relative\";\n            }\n            this._initPanes();\n            if (this._initControlPos) {\n                this._initControlPos();\n            }\n        },\n        _initPanes: function() {\n            var panes = this._panes = {};\n            this._paneRenderers = {};\n            // @section\n            //\n            // Panes are DOM elements used to control the ordering of layers on the map. You\n            // can access panes with [`map.getPane`](#map-getpane) or\n            // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n            // [`map.createPane`](#map-createpane) method.\n            //\n            // Every map has the following default panes that differ only in zIndex.\n            //\n            // @pane mapPane: HTMLElement = 'auto'\n            // Pane that contains all other map panes\n            this._mapPane = this.createPane(\"mapPane\", this._container);\n            setPosition(this._mapPane, new Point(0, 0));\n            // @pane tilePane: HTMLElement = 200\n            // Pane for `GridLayer`s and `TileLayer`s\n            this.createPane(\"tilePane\");\n            // @pane overlayPane: HTMLElement = 400\n            // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n            this.createPane(\"overlayPane\");\n            // @pane shadowPane: HTMLElement = 500\n            // Pane for overlay shadows (e.g. `Marker` shadows)\n            this.createPane(\"shadowPane\");\n            // @pane markerPane: HTMLElement = 600\n            // Pane for `Icon`s of `Marker`s\n            this.createPane(\"markerPane\");\n            // @pane tooltipPane: HTMLElement = 650\n            // Pane for `Tooltip`s.\n            this.createPane(\"tooltipPane\");\n            // @pane popupPane: HTMLElement = 700\n            // Pane for `Popup`s.\n            this.createPane(\"popupPane\");\n            if (!this.options.markerZoomAnimation) {\n                addClass(panes.markerPane, \"leaflet-zoom-hide\");\n                addClass(panes.shadowPane, \"leaflet-zoom-hide\");\n            }\n        },\n        // private methods that modify map state\n        // @section Map state change events\n        _resetView: function(center, zoom, noMoveStart) {\n            setPosition(this._mapPane, new Point(0, 0));\n            var loading = !this._loaded;\n            this._loaded = true;\n            zoom = this._limitZoom(zoom);\n            this.fire(\"viewprereset\");\n            var zoomChanged = this._zoom !== zoom;\n            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n            // @event viewreset: Event\n            // Fired when the map needs to redraw its content (this usually happens\n            // on map zoom or load). Very useful for creating custom overlays.\n            this.fire(\"viewreset\");\n            // @event load: Event\n            // Fired when the map is initialized (when its center and zoom are set\n            // for the first time).\n            if (loading) {\n                this.fire(\"load\");\n            }\n        },\n        _moveStart: function(zoomChanged, noMoveStart) {\n            // @event zoomstart: Event\n            // Fired when the map zoom is about to change (e.g. before zoom animation).\n            // @event movestart: Event\n            // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n            if (zoomChanged) {\n                this.fire(\"zoomstart\");\n            }\n            if (!noMoveStart) {\n                this.fire(\"movestart\");\n            }\n            return this;\n        },\n        _move: function(center, zoom, data, supressEvent) {\n            if (zoom === undefined) {\n                zoom = this._zoom;\n            }\n            var zoomChanged = this._zoom !== zoom;\n            this._zoom = zoom;\n            this._lastCenter = center;\n            this._pixelOrigin = this._getNewPixelOrigin(center);\n            if (!supressEvent) {\n                // @event zoom: Event\n                // Fired repeatedly during any change in zoom level,\n                // including zoom and fly animations.\n                if (zoomChanged || data && data.pinch) {\n                    this.fire(\"zoom\", data);\n                }\n                // @event move: Event\n                // Fired repeatedly during any movement of the map,\n                // including pan and fly animations.\n                this.fire(\"move\", data);\n            } else if (data && data.pinch) {\n                this.fire(\"zoom\", data);\n            }\n            return this;\n        },\n        _moveEnd: function(zoomChanged) {\n            // @event zoomend: Event\n            // Fired when the map zoom changed, after any animations.\n            if (zoomChanged) {\n                this.fire(\"zoomend\");\n            }\n            // @event moveend: Event\n            // Fired when the center of the map stops changing\n            // (e.g. user stopped dragging the map or after non-centered zoom).\n            return this.fire(\"moveend\");\n        },\n        _stop: function() {\n            cancelAnimFrame(this._flyToFrame);\n            if (this._panAnim) {\n                this._panAnim.stop();\n            }\n            return this;\n        },\n        _rawPanBy: function(offset) {\n            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n        },\n        _getZoomSpan: function() {\n            return this.getMaxZoom() - this.getMinZoom();\n        },\n        _panInsideMaxBounds: function() {\n            if (!this._enforcingBounds) {\n                this.panInsideBounds(this.options.maxBounds);\n            }\n        },\n        _checkIfLoaded: function() {\n            if (!this._loaded) {\n                throw new Error(\"Set map center and zoom first.\");\n            }\n        },\n        // DOM event handling\n        // @section Interaction events\n        _initEvents: function(remove) {\n            this._targets = {};\n            this._targets[stamp(this._container)] = this;\n            var onOff = remove ? off : on;\n            // @event click: MouseEvent\n            // Fired when the user clicks (or taps) the map.\n            // @event dblclick: MouseEvent\n            // Fired when the user double-clicks (or double-taps) the map.\n            // @event mousedown: MouseEvent\n            // Fired when the user pushes the mouse button on the map.\n            // @event mouseup: MouseEvent\n            // Fired when the user releases the mouse button on the map.\n            // @event mouseover: MouseEvent\n            // Fired when the mouse enters the map.\n            // @event mouseout: MouseEvent\n            // Fired when the mouse leaves the map.\n            // @event mousemove: MouseEvent\n            // Fired while the mouse moves over the map.\n            // @event contextmenu: MouseEvent\n            // Fired when the user pushes the right mouse button on the map, prevents\n            // default browser context menu from showing if there are listeners on\n            // this event. Also fired on mobile when the user holds a single touch\n            // for a second (also called long press).\n            // @event keypress: KeyboardEvent\n            // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n            // @event keydown: KeyboardEvent\n            // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n            // the `keydown` event is fired for keys that produce a character value and for keys\n            // that do not produce a character value.\n            // @event keyup: KeyboardEvent\n            // Fired when the user releases a key from the keyboard while the map is focused.\n            onOff(this._container, \"click dblclick mousedown mouseup \" + \"mouseover mouseout mousemove contextmenu keypress keydown keyup\", this._handleDOMEvent, this);\n            if (this.options.trackResize) {\n                onOff(window, \"resize\", this._onResize, this);\n            }\n            if (Browser.any3d && this.options.transform3DLimit) {\n                (remove ? this.off : this.on).call(this, \"moveend\", this._onMoveEnd);\n            }\n        },\n        _onResize: function() {\n            cancelAnimFrame(this._resizeRequest);\n            this._resizeRequest = requestAnimFrame(function() {\n                this.invalidateSize({\n                    debounceMoveend: true\n                });\n            }, this);\n        },\n        _onScroll: function() {\n            this._container.scrollTop = 0;\n            this._container.scrollLeft = 0;\n        },\n        _onMoveEnd: function() {\n            var pos = this._getMapPanePos();\n            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n                // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n                this._resetView(this.getCenter(), this.getZoom());\n            }\n        },\n        _findEventTargets: function(e, type) {\n            var targets = [], target, isHover = type === \"mouseout\" || type === \"mouseover\", src = e.target || e.srcElement, dragging = false;\n            while(src){\n                target = this._targets[stamp(src)];\n                if (target && (type === \"click\" || type === \"preclick\") && this._draggableMoved(target)) {\n                    // Prevent firing click after you just dragged an object.\n                    dragging = true;\n                    break;\n                }\n                if (target && target.listens(type, true)) {\n                    if (isHover && !isExternalTarget(src, e)) {\n                        break;\n                    }\n                    targets.push(target);\n                    if (isHover) {\n                        break;\n                    }\n                }\n                if (src === this._container) {\n                    break;\n                }\n                src = src.parentNode;\n            }\n            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n                targets = [\n                    this\n                ];\n            }\n            return targets;\n        },\n        _isClickDisabled: function(el) {\n            while(el && el !== this._container){\n                if (el[\"_leaflet_disable_click\"]) {\n                    return true;\n                }\n                el = el.parentNode;\n            }\n        },\n        _handleDOMEvent: function(e) {\n            var el = e.target || e.srcElement;\n            if (!this._loaded || el[\"_leaflet_disable_events\"] || e.type === \"click\" && this._isClickDisabled(el)) {\n                return;\n            }\n            var type = e.type;\n            if (type === \"mousedown\") {\n                // prevents outline when clicking on keyboard-focusable element\n                preventOutline(el);\n            }\n            this._fireDOMEvent(e, type);\n        },\n        _mouseEvents: [\n            \"click\",\n            \"dblclick\",\n            \"mouseover\",\n            \"mouseout\",\n            \"contextmenu\"\n        ],\n        _fireDOMEvent: function(e, type, canvasTargets) {\n            if (e.type === \"click\") {\n                // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n                // @event preclick: MouseEvent\n                // Fired before mouse click on the map (sometimes useful when you\n                // want something to happen on click before any existing click\n                // handlers start running).\n                var synth = extend({}, e);\n                synth.type = \"preclick\";\n                this._fireDOMEvent(synth, synth.type, canvasTargets);\n            }\n            // Find the layer the event is propagating from and its parents.\n            var targets = this._findEventTargets(e, type);\n            if (canvasTargets) {\n                var filtered = []; // pick only targets with listeners\n                for(var i = 0; i < canvasTargets.length; i++){\n                    if (canvasTargets[i].listens(type, true)) {\n                        filtered.push(canvasTargets[i]);\n                    }\n                }\n                targets = filtered.concat(targets);\n            }\n            if (!targets.length) {\n                return;\n            }\n            if (type === \"contextmenu\") {\n                preventDefault(e);\n            }\n            var target = targets[0];\n            var data = {\n                originalEvent: e\n            };\n            if (e.type !== \"keypress\" && e.type !== \"keydown\" && e.type !== \"keyup\") {\n                var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n                data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n                data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n                data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n            }\n            for(i = 0; i < targets.length; i++){\n                targets[i].fire(type, data, true);\n                if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n                    return;\n                }\n            }\n        },\n        _draggableMoved: function(obj) {\n            obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n        },\n        _clearHandlers: function() {\n            for(var i = 0, len = this._handlers.length; i < len; i++){\n                this._handlers[i].disable();\n            }\n        },\n        // @section Other Methods\n        // @method whenReady(fn: Function, context?: Object): this\n        // Runs the given function `fn` when the map gets initialized with\n        // a view (center and zoom) and at least one layer, or immediately\n        // if it's already initialized, optionally passing a function context.\n        whenReady: function(callback, context) {\n            if (this._loaded) {\n                callback.call(context || this, {\n                    target: this\n                });\n            } else {\n                this.on(\"load\", callback, context);\n            }\n            return this;\n        },\n        // private methods for getting map state\n        _getMapPanePos: function() {\n            return getPosition(this._mapPane) || new Point(0, 0);\n        },\n        _moved: function() {\n            var pos = this._getMapPanePos();\n            return pos && !pos.equals([\n                0,\n                0\n            ]);\n        },\n        _getTopLeftPoint: function(center, zoom) {\n            var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n            return pixelOrigin.subtract(this._getMapPanePos());\n        },\n        _getNewPixelOrigin: function(center, zoom) {\n            var viewHalf = this.getSize()._divideBy(2);\n            return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n        },\n        _latLngToNewLayerPoint: function(latlng, zoom, center) {\n            var topLeft = this._getNewPixelOrigin(center, zoom);\n            return this.project(latlng, zoom)._subtract(topLeft);\n        },\n        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom, center) {\n            var topLeft = this._getNewPixelOrigin(center, zoom);\n            return toBounds([\n                this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\n            ]);\n        },\n        // layer point of the current center\n        _getCenterLayerPoint: function() {\n            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n        },\n        // offset of the specified place to the current center in pixels\n        _getCenterOffset: function(latlng) {\n            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n        },\n        // adjust center for view to get inside bounds\n        _limitCenter: function(center, zoom, bounds) {\n            if (!bounds) {\n                return center;\n            }\n            var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n            // If offset is less than a pixel, ignore.\n            // This prevents unstable projections from getting into\n            // an infinite loop of tiny offsets.\n            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n                return center;\n            }\n            return this.unproject(centerPoint.add(offset), zoom);\n        },\n        // adjust offset for view to get inside bounds\n        _limitOffset: function(offset, bounds) {\n            if (!bounds) {\n                return offset;\n            }\n            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n            return offset.add(this._getBoundsOffset(newBounds, bounds));\n        },\n        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n        _getBoundsOffset: function(pxBounds, maxBounds, zoom) {\n            var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);\n            return new Point(dx, dy);\n        },\n        _rebound: function(left, right) {\n            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n        },\n        _limitZoom: function(zoom) {\n            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;\n            if (snap) {\n                zoom = Math.round(zoom / snap) * snap;\n            }\n            return Math.max(min, Math.min(max, zoom));\n        },\n        _onPanTransitionStep: function() {\n            this.fire(\"move\");\n        },\n        _onPanTransitionEnd: function() {\n            removeClass(this._mapPane, \"leaflet-pan-anim\");\n            this.fire(\"moveend\");\n        },\n        _tryAnimatedPan: function(center, options) {\n            // difference between the new and current centers in pixels\n            var offset = this._getCenterOffset(center)._trunc();\n            // don't animate too far unless animate: true specified in options\n            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n                return false;\n            }\n            this.panBy(offset, options);\n            return true;\n        },\n        _createAnimProxy: function() {\n            var proxy = this._proxy = create$1(\"div\", \"leaflet-proxy leaflet-zoom-animated\");\n            this._panes.mapPane.appendChild(proxy);\n            this.on(\"zoomanim\", function(e) {\n                var prop = TRANSFORM, transform = this._proxy.style[prop];\n                setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n                // workaround for case when transform is the same and so transitionend event is not fired\n                if (transform === this._proxy.style[prop] && this._animatingZoom) {\n                    this._onZoomTransitionEnd();\n                }\n            }, this);\n            this.on(\"load moveend\", this._animMoveEnd, this);\n            this._on(\"unload\", this._destroyAnimProxy, this);\n        },\n        _destroyAnimProxy: function() {\n            remove(this._proxy);\n            this.off(\"load moveend\", this._animMoveEnd, this);\n            delete this._proxy;\n        },\n        _animMoveEnd: function() {\n            var c = this.getCenter(), z = this.getZoom();\n            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n        },\n        _catchTransitionEnd: function(e) {\n            if (this._animatingZoom && e.propertyName.indexOf(\"transform\") >= 0) {\n                this._onZoomTransitionEnd();\n            }\n        },\n        _nothingToAnimate: function() {\n            return !this._container.getElementsByClassName(\"leaflet-zoom-animated\").length;\n        },\n        _tryAnimatedZoom: function(center, zoom, options) {\n            if (this._animatingZoom) {\n                return true;\n            }\n            options = options || {};\n            // don't animate if disabled, not supported or zoom difference is too large\n            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n                return false;\n            }\n            // offset is the pixel coords of the zoom origin relative to the current center\n            var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n            // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n            if (options.animate !== true && !this.getSize().contains(offset)) {\n                return false;\n            }\n            requestAnimFrame(function() {\n                this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n            }, this);\n            return true;\n        },\n        _animateZoom: function(center, zoom, startAnim, noUpdate) {\n            if (!this._mapPane) {\n                return;\n            }\n            if (startAnim) {\n                this._animatingZoom = true;\n                // remember what center/zoom to set after animation\n                this._animateToCenter = center;\n                this._animateToZoom = zoom;\n                addClass(this._mapPane, \"leaflet-zoom-anim\");\n            }\n            // @section Other Events\n            // @event zoomanim: ZoomAnimEvent\n            // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n            this.fire(\"zoomanim\", {\n                center: center,\n                zoom: zoom,\n                noUpdate: noUpdate\n            });\n            if (!this._tempFireZoomEvent) {\n                this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n            }\n            this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n            // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n            setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n        },\n        _onZoomTransitionEnd: function() {\n            if (!this._animatingZoom) {\n                return;\n            }\n            if (this._mapPane) {\n                removeClass(this._mapPane, \"leaflet-zoom-anim\");\n            }\n            this._animatingZoom = false;\n            this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n            if (this._tempFireZoomEvent) {\n                this.fire(\"zoom\");\n            }\n            delete this._tempFireZoomEvent;\n            this.fire(\"move\");\n            this._moveEnd(true);\n        }\n    });\n    // @section\n    // @factory L.map(id: String, options?: Map options)\n    // Instantiates a map object given the DOM ID of a `<div>` element\n    // and optionally an object literal with `Map options`.\n    //\n    // @alternative\n    // @factory L.map(el: HTMLElement, options?: Map options)\n    // Instantiates a map object given an instance of a `<div>` HTML element\n    // and optionally an object literal with `Map options`.\n    function createMap(id, options) {\n        return new Map(id, options);\n    }\n    /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */ var Control = Class.extend({\n        // @section\n        // @aka Control Options\n        options: {\n            // @option position: String = 'topright'\n            // The position of the control (one of the map corners). Possible values are `'topleft'`,\n            // `'topright'`, `'bottomleft'` or `'bottomright'`\n            position: \"topright\"\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        /* @section\r\n  \t * Classes extending L.Control will inherit the following methods:\r\n  \t *\r\n  \t * @method getPosition: string\r\n  \t * Returns the position of the control.\r\n  \t */ getPosition: function() {\n            return this.options.position;\n        },\n        // @method setPosition(position: string): this\n        // Sets the position of the control.\n        setPosition: function(position) {\n            var map = this._map;\n            if (map) {\n                map.removeControl(this);\n            }\n            this.options.position = position;\n            if (map) {\n                map.addControl(this);\n            }\n            return this;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTMLElement that contains the control.\n        getContainer: function() {\n            return this._container;\n        },\n        // @method addTo(map: Map): this\n        // Adds the control to the given map.\n        addTo: function(map) {\n            this.remove();\n            this._map = map;\n            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];\n            addClass(container, \"leaflet-control\");\n            if (pos.indexOf(\"bottom\") !== -1) {\n                corner.insertBefore(container, corner.firstChild);\n            } else {\n                corner.appendChild(container);\n            }\n            this._map.on(\"unload\", this.remove, this);\n            return this;\n        },\n        // @method remove: this\n        // Removes the control from the map it is currently active on.\n        remove: function() {\n            if (!this._map) {\n                return this;\n            }\n            remove(this._container);\n            if (this.onRemove) {\n                this.onRemove(this._map);\n            }\n            this._map.off(\"unload\", this.remove, this);\n            this._map = null;\n            return this;\n        },\n        _refocusOnMap: function(e) {\n            // if map exists and event is not a keyboard event\n            if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n                this._map.getContainer().focus();\n            }\n        }\n    });\n    var control = function(options) {\n        return new Control(options);\n    };\n    /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */ /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */ Map.include({\n        // @method addControl(control: Control): this\n        // Adds the given control to the map\n        addControl: function(control) {\n            control.addTo(this);\n            return this;\n        },\n        // @method removeControl(control: Control): this\n        // Removes the given control from the map\n        removeControl: function(control) {\n            control.remove();\n            return this;\n        },\n        _initControlPos: function() {\n            var corners = this._controlCorners = {}, l = \"leaflet-\", container = this._controlContainer = create$1(\"div\", l + \"control-container\", this._container);\n            function createCorner(vSide, hSide) {\n                var className = l + vSide + \" \" + l + hSide;\n                corners[vSide + hSide] = create$1(\"div\", className, container);\n            }\n            createCorner(\"top\", \"left\");\n            createCorner(\"top\", \"right\");\n            createCorner(\"bottom\", \"left\");\n            createCorner(\"bottom\", \"right\");\n        },\n        _clearControlPos: function() {\n            for(var i in this._controlCorners){\n                remove(this._controlCorners[i]);\n            }\n            remove(this._controlContainer);\n            delete this._controlCorners;\n            delete this._controlContainer;\n        }\n    });\n    /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */ var Layers = Control.extend({\n        // @section\n        // @aka Control.Layers options\n        options: {\n            // @option collapsed: Boolean = true\n            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n            collapsed: true,\n            position: \"topright\",\n            // @option autoZIndex: Boolean = true\n            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n            autoZIndex: true,\n            // @option hideSingleBase: Boolean = false\n            // If `true`, the base layers in the control will be hidden when there is only one.\n            hideSingleBase: false,\n            // @option sortLayers: Boolean = false\n            // Whether to sort the layers. When `false`, layers will keep the order\n            // in which they were added to the control.\n            sortLayers: false,\n            // @option sortFunction: Function = *\n            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n            // that will be used for sorting the layers, when `sortLayers` is `true`.\n            // The function receives both the `L.Layer` instances and their names, as in\n            // `sortFunction(layerA, layerB, nameA, nameB)`.\n            // By default, it sorts layers alphabetically by their name.\n            sortFunction: function(layerA, layerB, nameA, nameB) {\n                return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n            }\n        },\n        initialize: function(baseLayers, overlays, options) {\n            setOptions(this, options);\n            this._layerControlInputs = [];\n            this._layers = [];\n            this._lastZIndex = 0;\n            this._handlingClick = false;\n            this._preventClick = false;\n            for(var i in baseLayers){\n                this._addLayer(baseLayers[i], i);\n            }\n            for(i in overlays){\n                this._addLayer(overlays[i], i, true);\n            }\n        },\n        onAdd: function(map) {\n            this._initLayout();\n            this._update();\n            this._map = map;\n            map.on(\"zoomend\", this._checkDisabledLayers, this);\n            for(var i = 0; i < this._layers.length; i++){\n                this._layers[i].layer.on(\"add remove\", this._onLayerChange, this);\n            }\n            return this._container;\n        },\n        addTo: function(map) {\n            Control.prototype.addTo.call(this, map);\n            // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n            return this._expandIfNotCollapsed();\n        },\n        onRemove: function() {\n            this._map.off(\"zoomend\", this._checkDisabledLayers, this);\n            for(var i = 0; i < this._layers.length; i++){\n                this._layers[i].layer.off(\"add remove\", this._onLayerChange, this);\n            }\n        },\n        // @method addBaseLayer(layer: Layer, name: String): this\n        // Adds a base layer (radio button entry) with the given name to the control.\n        addBaseLayer: function(layer, name) {\n            this._addLayer(layer, name);\n            return this._map ? this._update() : this;\n        },\n        // @method addOverlay(layer: Layer, name: String): this\n        // Adds an overlay (checkbox entry) with the given name to the control.\n        addOverlay: function(layer, name) {\n            this._addLayer(layer, name, true);\n            return this._map ? this._update() : this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Remove the given layer from the control.\n        removeLayer: function(layer) {\n            layer.off(\"add remove\", this._onLayerChange, this);\n            var obj = this._getLayer(stamp(layer));\n            if (obj) {\n                this._layers.splice(this._layers.indexOf(obj), 1);\n            }\n            return this._map ? this._update() : this;\n        },\n        // @method expand(): this\n        // Expand the control container if collapsed.\n        expand: function() {\n            addClass(this._container, \"leaflet-control-layers-expanded\");\n            this._section.style.height = null;\n            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n            if (acceptableHeight < this._section.clientHeight) {\n                addClass(this._section, \"leaflet-control-layers-scrollbar\");\n                this._section.style.height = acceptableHeight + \"px\";\n            } else {\n                removeClass(this._section, \"leaflet-control-layers-scrollbar\");\n            }\n            this._checkDisabledLayers();\n            return this;\n        },\n        // @method collapse(): this\n        // Collapse the control container if expanded.\n        collapse: function() {\n            removeClass(this._container, \"leaflet-control-layers-expanded\");\n            return this;\n        },\n        _initLayout: function() {\n            var className = \"leaflet-control-layers\", container = this._container = create$1(\"div\", className), collapsed = this.options.collapsed;\n            // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n            container.setAttribute(\"aria-haspopup\", true);\n            disableClickPropagation(container);\n            disableScrollPropagation(container);\n            var section = this._section = create$1(\"section\", className + \"-list\");\n            if (collapsed) {\n                this._map.on(\"click\", this.collapse, this);\n                on(container, {\n                    mouseenter: this._expandSafely,\n                    mouseleave: this.collapse\n                }, this);\n            }\n            var link = this._layersLink = create$1(\"a\", className + \"-toggle\", container);\n            link.href = \"#\";\n            link.title = \"Layers\";\n            link.setAttribute(\"role\", \"button\");\n            on(link, {\n                keydown: function(e) {\n                    if (e.keyCode === 13) {\n                        this._expandSafely();\n                    }\n                },\n                // Certain screen readers intercept the key event and instead send a click event\n                click: function(e) {\n                    preventDefault(e);\n                    this._expandSafely();\n                }\n            }, this);\n            if (!collapsed) {\n                this.expand();\n            }\n            this._baseLayersList = create$1(\"div\", className + \"-base\", section);\n            this._separator = create$1(\"div\", className + \"-separator\", section);\n            this._overlaysList = create$1(\"div\", className + \"-overlays\", section);\n            container.appendChild(section);\n        },\n        _getLayer: function(id) {\n            for(var i = 0; i < this._layers.length; i++){\n                if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n                    return this._layers[i];\n                }\n            }\n        },\n        _addLayer: function(layer, name, overlay) {\n            if (this._map) {\n                layer.on(\"add remove\", this._onLayerChange, this);\n            }\n            this._layers.push({\n                layer: layer,\n                name: name,\n                overlay: overlay\n            });\n            if (this.options.sortLayers) {\n                this._layers.sort(bind(function(a, b) {\n                    return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n                }, this));\n            }\n            if (this.options.autoZIndex && layer.setZIndex) {\n                this._lastZIndex++;\n                layer.setZIndex(this._lastZIndex);\n            }\n            this._expandIfNotCollapsed();\n        },\n        _update: function() {\n            if (!this._container) {\n                return this;\n            }\n            empty(this._baseLayersList);\n            empty(this._overlaysList);\n            this._layerControlInputs = [];\n            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\n            for(i = 0; i < this._layers.length; i++){\n                obj = this._layers[i];\n                this._addItem(obj);\n                overlaysPresent = overlaysPresent || obj.overlay;\n                baseLayersPresent = baseLayersPresent || !obj.overlay;\n                baseLayersCount += !obj.overlay ? 1 : 0;\n            }\n            // Hide base layers section if there's only one layer.\n            if (this.options.hideSingleBase) {\n                baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n                this._baseLayersList.style.display = baseLayersPresent ? \"\" : \"none\";\n            }\n            this._separator.style.display = overlaysPresent && baseLayersPresent ? \"\" : \"none\";\n            return this;\n        },\n        _onLayerChange: function(e) {\n            if (!this._handlingClick) {\n                this._update();\n            }\n            var obj = this._getLayer(stamp(e.target));\n            // @namespace Map\n            // @section Layer events\n            // @event baselayerchange: LayersControlEvent\n            // Fired when the base layer is changed through the [layers control](#control-layers).\n            // @event overlayadd: LayersControlEvent\n            // Fired when an overlay is selected through the [layers control](#control-layers).\n            // @event overlayremove: LayersControlEvent\n            // Fired when an overlay is deselected through the [layers control](#control-layers).\n            // @namespace Control.Layers\n            var type = obj.overlay ? e.type === \"add\" ? \"overlayadd\" : \"overlayremove\" : e.type === \"add\" ? \"baselayerchange\" : null;\n            if (type) {\n                this._map.fire(type, obj);\n            }\n        },\n        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n        _createRadioElement: function(name, checked) {\n            var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : \"\") + \"/>\";\n            var radioFragment = document.createElement(\"div\");\n            radioFragment.innerHTML = radioHtml;\n            return radioFragment.firstChild;\n        },\n        _addItem: function(obj) {\n            var label = document.createElement(\"label\"), checked = this._map.hasLayer(obj.layer), input;\n            if (obj.overlay) {\n                input = document.createElement(\"input\");\n                input.type = \"checkbox\";\n                input.className = \"leaflet-control-layers-selector\";\n                input.defaultChecked = checked;\n            } else {\n                input = this._createRadioElement(\"leaflet-base-layers_\" + stamp(this), checked);\n            }\n            this._layerControlInputs.push(input);\n            input.layerId = stamp(obj.layer);\n            on(input, \"click\", this._onInputClick, this);\n            var name = document.createElement(\"span\");\n            name.innerHTML = \" \" + obj.name;\n            // Helps from preventing layer control flicker when checkboxes are disabled\n            // https://github.com/Leaflet/Leaflet/issues/2771\n            var holder = document.createElement(\"span\");\n            label.appendChild(holder);\n            holder.appendChild(input);\n            holder.appendChild(name);\n            var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n            container.appendChild(label);\n            this._checkDisabledLayers();\n            return label;\n        },\n        _onInputClick: function() {\n            // expanding the control on mobile with a click can cause adding a layer - we don't want this\n            if (this._preventClick) {\n                return;\n            }\n            var inputs = this._layerControlInputs, input, layer;\n            var addedLayers = [], removedLayers = [];\n            this._handlingClick = true;\n            for(var i = inputs.length - 1; i >= 0; i--){\n                input = inputs[i];\n                layer = this._getLayer(input.layerId).layer;\n                if (input.checked) {\n                    addedLayers.push(layer);\n                } else if (!input.checked) {\n                    removedLayers.push(layer);\n                }\n            }\n            // Bugfix issue 2318: Should remove all old layers before readding new ones\n            for(i = 0; i < removedLayers.length; i++){\n                if (this._map.hasLayer(removedLayers[i])) {\n                    this._map.removeLayer(removedLayers[i]);\n                }\n            }\n            for(i = 0; i < addedLayers.length; i++){\n                if (!this._map.hasLayer(addedLayers[i])) {\n                    this._map.addLayer(addedLayers[i]);\n                }\n            }\n            this._handlingClick = false;\n            this._refocusOnMap();\n        },\n        _checkDisabledLayers: function() {\n            var inputs = this._layerControlInputs, input, layer, zoom = this._map.getZoom();\n            for(var i = inputs.length - 1; i >= 0; i--){\n                input = inputs[i];\n                layer = this._getLayer(input.layerId).layer;\n                input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n            }\n        },\n        _expandIfNotCollapsed: function() {\n            if (this._map && !this.options.collapsed) {\n                this.expand();\n            }\n            return this;\n        },\n        _expandSafely: function() {\n            var section = this._section;\n            this._preventClick = true;\n            on(section, \"click\", preventDefault);\n            this.expand();\n            var that = this;\n            setTimeout(function() {\n                off(section, \"click\", preventDefault);\n                that._preventClick = false;\n            });\n        }\n    });\n    // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n    // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n    var layers = function(baseLayers, overlays, options) {\n        return new Layers(baseLayers, overlays, options);\n    };\n    /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */ var Zoom = Control.extend({\n        // @section\n        // @aka Control.Zoom options\n        options: {\n            position: \"topleft\",\n            // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n            // The text set on the 'zoom in' button.\n            zoomInText: '<span aria-hidden=\"true\">+</span>',\n            // @option zoomInTitle: String = 'Zoom in'\n            // The title set on the 'zoom in' button.\n            zoomInTitle: \"Zoom in\",\n            // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n            // The text set on the 'zoom out' button.\n            zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n            // @option zoomOutTitle: String = 'Zoom out'\n            // The title set on the 'zoom out' button.\n            zoomOutTitle: \"Zoom out\"\n        },\n        onAdd: function(map) {\n            var zoomName = \"leaflet-control-zoom\", container = create$1(\"div\", zoomName + \" leaflet-bar\"), options = this.options;\n            this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + \"-in\", container, this._zoomIn);\n            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + \"-out\", container, this._zoomOut);\n            this._updateDisabled();\n            map.on(\"zoomend zoomlevelschange\", this._updateDisabled, this);\n            return container;\n        },\n        onRemove: function(map) {\n            map.off(\"zoomend zoomlevelschange\", this._updateDisabled, this);\n        },\n        disable: function() {\n            this._disabled = true;\n            this._updateDisabled();\n            return this;\n        },\n        enable: function() {\n            this._disabled = false;\n            this._updateDisabled();\n            return this;\n        },\n        _zoomIn: function(e) {\n            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n                this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n            }\n        },\n        _zoomOut: function(e) {\n            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n                this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n            }\n        },\n        _createButton: function(html, title, className, container, fn) {\n            var link = create$1(\"a\", className, container);\n            link.innerHTML = html;\n            link.href = \"#\";\n            link.title = title;\n            /*\r\n  \t\t * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n  \t\t */ link.setAttribute(\"role\", \"button\");\n            link.setAttribute(\"aria-label\", title);\n            disableClickPropagation(link);\n            on(link, \"click\", stop);\n            on(link, \"click\", fn, this);\n            on(link, \"click\", this._refocusOnMap, this);\n            return link;\n        },\n        _updateDisabled: function() {\n            var map = this._map, className = \"leaflet-disabled\";\n            removeClass(this._zoomInButton, className);\n            removeClass(this._zoomOutButton, className);\n            this._zoomInButton.setAttribute(\"aria-disabled\", \"false\");\n            this._zoomOutButton.setAttribute(\"aria-disabled\", \"false\");\n            if (this._disabled || map._zoom === map.getMinZoom()) {\n                addClass(this._zoomOutButton, className);\n                this._zoomOutButton.setAttribute(\"aria-disabled\", \"true\");\n            }\n            if (this._disabled || map._zoom === map.getMaxZoom()) {\n                addClass(this._zoomInButton, className);\n                this._zoomInButton.setAttribute(\"aria-disabled\", \"true\");\n            }\n        }\n    });\n    // @namespace Map\n    // @section Control options\n    // @option zoomControl: Boolean = true\n    // Whether a [zoom control](#control-zoom) is added to the map by default.\n    Map.mergeOptions({\n        zoomControl: true\n    });\n    Map.addInitHook(function() {\n        if (this.options.zoomControl) {\n            // @section Controls\n            // @property zoomControl: Control.Zoom\n            // The default zoom control (only available if the\n            // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n            this.zoomControl = new Zoom();\n            this.addControl(this.zoomControl);\n        }\n    });\n    // @namespace Control.Zoom\n    // @factory L.control.zoom(options: Control.Zoom options)\n    // Creates a zoom control\n    var zoom = function(options) {\n        return new Zoom(options);\n    };\n    /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */ var Scale = Control.extend({\n        // @section\n        // @aka Control.Scale options\n        options: {\n            position: \"bottomleft\",\n            // @option maxWidth: Number = 100\n            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n            maxWidth: 100,\n            // @option metric: Boolean = True\n            // Whether to show the metric scale line (m/km).\n            metric: true,\n            // @option imperial: Boolean = True\n            // Whether to show the imperial scale line (mi/ft).\n            imperial: true\n        },\n        onAdd: function(map) {\n            var className = \"leaflet-control-scale\", container = create$1(\"div\", className), options = this.options;\n            this._addScales(options, className + \"-line\", container);\n            map.on(options.updateWhenIdle ? \"moveend\" : \"move\", this._update, this);\n            map.whenReady(this._update, this);\n            return container;\n        },\n        onRemove: function(map) {\n            map.off(this.options.updateWhenIdle ? \"moveend\" : \"move\", this._update, this);\n        },\n        _addScales: function(options, className, container) {\n            if (options.metric) {\n                this._mScale = create$1(\"div\", className, container);\n            }\n            if (options.imperial) {\n                this._iScale = create$1(\"div\", className, container);\n            }\n        },\n        _update: function() {\n            var map = this._map, y = map.getSize().y / 2;\n            var maxMeters = map.distance(map.containerPointToLatLng([\n                0,\n                y\n            ]), map.containerPointToLatLng([\n                this.options.maxWidth,\n                y\n            ]));\n            this._updateScales(maxMeters);\n        },\n        _updateScales: function(maxMeters) {\n            if (this.options.metric && maxMeters) {\n                this._updateMetric(maxMeters);\n            }\n            if (this.options.imperial && maxMeters) {\n                this._updateImperial(maxMeters);\n            }\n        },\n        _updateMetric: function(maxMeters) {\n            var meters = this._getRoundNum(maxMeters), label = meters < 1000 ? meters + \" m\" : meters / 1000 + \" km\";\n            this._updateScale(this._mScale, label, meters / maxMeters);\n        },\n        _updateImperial: function(maxMeters) {\n            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;\n            if (maxFeet > 5280) {\n                maxMiles = maxFeet / 5280;\n                miles = this._getRoundNum(maxMiles);\n                this._updateScale(this._iScale, miles + \" mi\", miles / maxMiles);\n            } else {\n                feet = this._getRoundNum(maxFeet);\n                this._updateScale(this._iScale, feet + \" ft\", feet / maxFeet);\n            }\n        },\n        _updateScale: function(scale, text, ratio) {\n            scale.style.width = Math.round(this.options.maxWidth * ratio) + \"px\";\n            scale.innerHTML = text;\n        },\n        _getRoundNum: function(num) {\n            var pow10 = Math.pow(10, (Math.floor(num) + \"\").length - 1), d = num / pow10;\n            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n            return pow10 * d;\n        }\n    });\n    // @factory L.control.scale(options?: Control.Scale options)\n    // Creates an scale control with the given options.\n    var scale = function(options) {\n        return new Scale(options);\n    };\n    var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n    /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */ var Attribution = Control.extend({\n        // @section\n        // @aka Control.Attribution options\n        options: {\n            position: \"bottomright\",\n            // @option prefix: String|false = 'Leaflet'\n            // The HTML text shown before the attributions. Pass `false` to disable.\n            prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + \" \" : \"\") + \"Leaflet</a>\"\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n            this._attributions = {};\n        },\n        onAdd: function(map) {\n            map.attributionControl = this;\n            this._container = create$1(\"div\", \"leaflet-control-attribution\");\n            disableClickPropagation(this._container);\n            // TODO ugly, refactor\n            for(var i in map._layers){\n                if (map._layers[i].getAttribution) {\n                    this.addAttribution(map._layers[i].getAttribution());\n                }\n            }\n            this._update();\n            map.on(\"layeradd\", this._addAttribution, this);\n            return this._container;\n        },\n        onRemove: function(map) {\n            map.off(\"layeradd\", this._addAttribution, this);\n        },\n        _addAttribution: function(ev) {\n            if (ev.layer.getAttribution) {\n                this.addAttribution(ev.layer.getAttribution());\n                ev.layer.once(\"remove\", function() {\n                    this.removeAttribution(ev.layer.getAttribution());\n                }, this);\n            }\n        },\n        // @method setPrefix(prefix: String|false): this\n        // The HTML text shown before the attributions. Pass `false` to disable.\n        setPrefix: function(prefix) {\n            this.options.prefix = prefix;\n            this._update();\n            return this;\n        },\n        // @method addAttribution(text: String): this\n        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n        addAttribution: function(text) {\n            if (!text) {\n                return this;\n            }\n            if (!this._attributions[text]) {\n                this._attributions[text] = 0;\n            }\n            this._attributions[text]++;\n            this._update();\n            return this;\n        },\n        // @method removeAttribution(text: String): this\n        // Removes an attribution text.\n        removeAttribution: function(text) {\n            if (!text) {\n                return this;\n            }\n            if (this._attributions[text]) {\n                this._attributions[text]--;\n                this._update();\n            }\n            return this;\n        },\n        _update: function() {\n            if (!this._map) {\n                return;\n            }\n            var attribs = [];\n            for(var i in this._attributions){\n                if (this._attributions[i]) {\n                    attribs.push(i);\n                }\n            }\n            var prefixAndAttribs = [];\n            if (this.options.prefix) {\n                prefixAndAttribs.push(this.options.prefix);\n            }\n            if (attribs.length) {\n                prefixAndAttribs.push(attribs.join(\", \"));\n            }\n            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n        }\n    });\n    // @namespace Map\n    // @section Control options\n    // @option attributionControl: Boolean = true\n    // Whether a [attribution control](#control-attribution) is added to the map by default.\n    Map.mergeOptions({\n        attributionControl: true\n    });\n    Map.addInitHook(function() {\n        if (this.options.attributionControl) {\n            new Attribution().addTo(this);\n        }\n    });\n    // @namespace Control.Attribution\n    // @factory L.control.attribution(options: Control.Attribution options)\n    // Creates an attribution control.\n    var attribution = function(options) {\n        return new Attribution(options);\n    };\n    Control.Layers = Layers;\n    Control.Zoom = Zoom;\n    Control.Scale = Scale;\n    Control.Attribution = Attribution;\n    control.layers = layers;\n    control.zoom = zoom;\n    control.scale = scale;\n    control.attribution = attribution;\n    /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */ // @class Handler\n    // @aka L.Handler\n    // Abstract class for map interaction handlers\n    var Handler = Class.extend({\n        initialize: function(map) {\n            this._map = map;\n        },\n        // @method enable(): this\n        // Enables the handler\n        enable: function() {\n            if (this._enabled) {\n                return this;\n            }\n            this._enabled = true;\n            this.addHooks();\n            return this;\n        },\n        // @method disable(): this\n        // Disables the handler\n        disable: function() {\n            if (!this._enabled) {\n                return this;\n            }\n            this._enabled = false;\n            this.removeHooks();\n            return this;\n        },\n        // @method enabled(): Boolean\n        // Returns `true` if the handler is enabled\n        enabled: function() {\n            return !!this._enabled;\n        }\n    });\n    // @section There is static function which can be called without instantiating L.Handler:\n    // @function addTo(map: Map, name: String): this\n    // Adds a new Handler to the given map with the given name.\n    Handler.addTo = function(map, name) {\n        map.addHandler(name, this);\n        return this;\n    };\n    var Mixin = {\n        Events: Events\n    };\n    /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */ var START = Browser.touch ? \"touchstart mousedown\" : \"mousedown\";\n    var Draggable = Evented.extend({\n        options: {\n            // @section\n            // @aka Draggable options\n            // @option clickTolerance: Number = 3\n            // The max number of pixels a user can shift the mouse pointer during a click\n            // for it to be considered a valid click (as opposed to a mouse drag).\n            clickTolerance: 3\n        },\n        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n        initialize: function(element, dragStartTarget, preventOutline, options) {\n            setOptions(this, options);\n            this._element = element;\n            this._dragStartTarget = dragStartTarget || element;\n            this._preventOutline = preventOutline;\n        },\n        // @method enable()\n        // Enables the dragging ability\n        enable: function() {\n            if (this._enabled) {\n                return;\n            }\n            on(this._dragStartTarget, START, this._onDown, this);\n            this._enabled = true;\n        },\n        // @method disable()\n        // Disables the dragging ability\n        disable: function() {\n            if (!this._enabled) {\n                return;\n            }\n            // If we're currently dragging this draggable,\n            // disabling it counts as first ending the drag.\n            if (Draggable._dragging === this) {\n                this.finishDrag(true);\n            }\n            off(this._dragStartTarget, START, this._onDown, this);\n            this._enabled = false;\n            this._moved = false;\n        },\n        _onDown: function(e) {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            this._moved = false;\n            if (hasClass(this._element, \"leaflet-zoom-anim\")) {\n                return;\n            }\n            if (e.touches && e.touches.length !== 1) {\n                // Finish dragging to avoid conflict with touchZoom\n                if (Draggable._dragging === this) {\n                    this.finishDrag();\n                }\n                return;\n            }\n            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n                return;\n            }\n            Draggable._dragging = this; // Prevent dragging multiple objects at once.\n            if (this._preventOutline) {\n                preventOutline(this._element);\n            }\n            disableImageDrag();\n            disableTextSelection();\n            if (this._moving) {\n                return;\n            }\n            // @event down: Event\n            // Fired when a drag is about to start.\n            this.fire(\"down\");\n            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);\n            this._startPoint = new Point(first.clientX, first.clientY);\n            this._startPos = getPosition(this._element);\n            // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n            this._parentScale = getScale(sizedParent);\n            var mouseevent = e.type === \"mousedown\";\n            on(document, mouseevent ? \"mousemove\" : \"touchmove\", this._onMove, this);\n            on(document, mouseevent ? \"mouseup\" : \"touchend touchcancel\", this._onUp, this);\n        },\n        _onMove: function(e) {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            if (e.touches && e.touches.length > 1) {\n                this._moved = true;\n                return;\n            }\n            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n            if (!offset.x && !offset.y) {\n                return;\n            }\n            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n                return;\n            }\n            // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n            // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n            // and we can use the cached value for the scale.\n            offset.x /= this._parentScale.x;\n            offset.y /= this._parentScale.y;\n            preventDefault(e);\n            if (!this._moved) {\n                // @event dragstart: Event\n                // Fired when a drag starts\n                this.fire(\"dragstart\");\n                this._moved = true;\n                addClass(document.body, \"leaflet-dragging\");\n                this._lastTarget = e.target || e.srcElement;\n                // IE and Edge do not give the <use> element, so fetch it\n                // if necessary\n                if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n                    this._lastTarget = this._lastTarget.correspondingUseElement;\n                }\n                addClass(this._lastTarget, \"leaflet-drag-target\");\n            }\n            this._newPos = this._startPos.add(offset);\n            this._moving = true;\n            this._lastEvent = e;\n            this._updatePosition();\n        },\n        _updatePosition: function() {\n            var e = {\n                originalEvent: this._lastEvent\n            };\n            // @event predrag: Event\n            // Fired continuously during dragging *before* each corresponding\n            // update of the element's position.\n            this.fire(\"predrag\", e);\n            setPosition(this._element, this._newPos);\n            // @event drag: Event\n            // Fired continuously during dragging.\n            this.fire(\"drag\", e);\n        },\n        _onUp: function() {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            this.finishDrag();\n        },\n        finishDrag: function(noInertia) {\n            removeClass(document.body, \"leaflet-dragging\");\n            if (this._lastTarget) {\n                removeClass(this._lastTarget, \"leaflet-drag-target\");\n                this._lastTarget = null;\n            }\n            off(document, \"mousemove touchmove\", this._onMove, this);\n            off(document, \"mouseup touchend touchcancel\", this._onUp, this);\n            enableImageDrag();\n            enableTextSelection();\n            var fireDragend = this._moved && this._moving;\n            this._moving = false;\n            Draggable._dragging = false;\n            if (fireDragend) {\n                // @event dragend: DragEndEvent\n                // Fired when the drag ends.\n                this.fire(\"dragend\", {\n                    noInertia: noInertia,\n                    distance: this._newPos.distanceTo(this._startPos)\n                });\n            }\n        }\n    });\n    /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */ /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */ function clipPolygon(points, bounds, round) {\n        var clippedPoints, edges = [\n            1,\n            4,\n            2,\n            8\n        ], i, j, k, a, b, len, edge, p;\n        for(i = 0, len = points.length; i < len; i++){\n            points[i]._code = _getBitCode(points[i], bounds);\n        }\n        // for each edge (left, bottom, right, top)\n        for(k = 0; k < 4; k++){\n            edge = edges[k];\n            clippedPoints = [];\n            for(i = 0, len = points.length, j = len - 1; i < len; j = i++){\n                a = points[i];\n                b = points[j];\n                // if a is inside the clip window\n                if (!(a._code & edge)) {\n                    // if b is outside the clip window (a->b goes out of screen)\n                    if (b._code & edge) {\n                        p = _getEdgeIntersection(b, a, edge, bounds, round);\n                        p._code = _getBitCode(p, bounds);\n                        clippedPoints.push(p);\n                    }\n                    clippedPoints.push(a);\n                // else if b is inside the clip window (a->b enters the screen)\n                } else if (!(b._code & edge)) {\n                    p = _getEdgeIntersection(b, a, edge, bounds, round);\n                    p._code = _getBitCode(p, bounds);\n                    clippedPoints.push(p);\n                }\n            }\n            points = clippedPoints;\n        }\n        return points;\n    }\n    /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */ function polygonCenter(latlngs, crs) {\n        var i, j, p1, p2, f, area, x, y, center;\n        if (!latlngs || latlngs.length === 0) {\n            throw new Error(\"latlngs not passed\");\n        }\n        if (!isFlat(latlngs)) {\n            console.warn(\"latlngs are not flat! Only the first ring will be used\");\n            latlngs = latlngs[0];\n        }\n        var centroidLatLng = toLatLng([\n            0,\n            0\n        ]);\n        var bounds = toLatLngBounds(latlngs);\n        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n        // tests showed that below 1700 rounding errors are happening\n        if (areaBounds < 1700) {\n            // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n            centroidLatLng = centroid(latlngs);\n        }\n        var len = latlngs.length;\n        var points = [];\n        for(i = 0; i < len; i++){\n            var latlng = toLatLng(latlngs[i]);\n            points.push(crs.project(toLatLng([\n                latlng.lat - centroidLatLng.lat,\n                latlng.lng - centroidLatLng.lng\n            ])));\n        }\n        area = x = y = 0;\n        // polygon centroid algorithm;\n        for(i = 0, j = len - 1; i < len; j = i++){\n            p1 = points[i];\n            p2 = points[j];\n            f = p1.y * p2.x - p2.y * p1.x;\n            x += (p1.x + p2.x) * f;\n            y += (p1.y + p2.y) * f;\n            area += f * 3;\n        }\n        if (area === 0) {\n            // Polygon is so small that all points are on same pixel.\n            center = points[0];\n        } else {\n            center = [\n                x / area,\n                y / area\n            ];\n        }\n        var latlngCenter = crs.unproject(toPoint(center));\n        return toLatLng([\n            latlngCenter.lat + centroidLatLng.lat,\n            latlngCenter.lng + centroidLatLng.lng\n        ]);\n    }\n    /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */ function centroid(coords) {\n        var latSum = 0;\n        var lngSum = 0;\n        var len = 0;\n        for(var i = 0; i < coords.length; i++){\n            var latlng = toLatLng(coords[i]);\n            latSum += latlng.lat;\n            lngSum += latlng.lng;\n            len++;\n        }\n        return toLatLng([\n            latSum / len,\n            lngSum / len\n        ]);\n    }\n    var PolyUtil = {\n        __proto__: null,\n        clipPolygon: clipPolygon,\n        polygonCenter: polygonCenter,\n        centroid: centroid\n    };\n    /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */ // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n    // Improves rendering performance dramatically by lessening the number of points to draw.\n    // @function simplify(points: Point[], tolerance: Number): Point[]\n    // Dramatically reduces the number of points in a polyline while retaining\n    // its shape and returns a new array of simplified points, using the\n    // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n    // Used for a huge performance boost when processing/displaying Leaflet polylines for\n    // each zoom level and also reducing visual noise. tolerance affects the amount of\n    // simplification (lesser value means higher quality but slower and with more points).\n    // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n    function simplify(points, tolerance) {\n        if (!tolerance || !points.length) {\n            return points.slice();\n        }\n        var sqTolerance = tolerance * tolerance;\n        // stage 1: vertex reduction\n        points = _reducePoints(points, sqTolerance);\n        // stage 2: Douglas-Peucker simplification\n        points = _simplifyDP(points, sqTolerance);\n        return points;\n    }\n    // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n    // Returns the distance between point `p` and segment `p1` to `p2`.\n    function pointToSegmentDistance(p, p1, p2) {\n        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n    }\n    // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n    // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n    function closestPointOnSegment(p, p1, p2) {\n        return _sqClosestPointOnSegment(p, p1, p2);\n    }\n    // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n    function _simplifyDP(points, sqTolerance) {\n        var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + \"\" ? Uint8Array : Array, markers = new ArrayConstructor(len);\n        markers[0] = markers[len - 1] = 1;\n        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n        var i, newPoints = [];\n        for(i = 0; i < len; i++){\n            if (markers[i]) {\n                newPoints.push(points[i]);\n            }\n        }\n        return newPoints;\n    }\n    function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n        var maxSqDist = 0, index, i, sqDist;\n        for(i = first + 1; i <= last - 1; i++){\n            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n        if (maxSqDist > sqTolerance) {\n            markers[index] = 1;\n            _simplifyDPStep(points, markers, sqTolerance, first, index);\n            _simplifyDPStep(points, markers, sqTolerance, index, last);\n        }\n    }\n    // reduce points that are too close to each other to a single point\n    function _reducePoints(points, sqTolerance) {\n        var reducedPoints = [\n            points[0]\n        ];\n        for(var i = 1, prev = 0, len = points.length; i < len; i++){\n            if (_sqDist(points[i], points[prev]) > sqTolerance) {\n                reducedPoints.push(points[i]);\n                prev = i;\n            }\n        }\n        if (prev < len - 1) {\n            reducedPoints.push(points[len - 1]);\n        }\n        return reducedPoints;\n    }\n    var _lastCode;\n    // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n    // Clips the segment a to b by rectangular bounds with the\n    // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n    // (modifying the segment points directly!). Used by Leaflet to only show polyline\n    // points that are on the screen or near, increasing performance.\n    function clipSegment(a, b, bounds, useLastCode, round) {\n        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;\n        // save 2nd code to avoid calculating it on the next segment\n        _lastCode = codeB;\n        while(true){\n            // if a,b is inside the clip window (trivial accept)\n            if (!(codeA | codeB)) {\n                return [\n                    a,\n                    b\n                ];\n            }\n            // if a,b is outside the clip window (trivial reject)\n            if (codeA & codeB) {\n                return false;\n            }\n            // other cases\n            codeOut = codeA || codeB;\n            p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n            newCode = _getBitCode(p, bounds);\n            if (codeOut === codeA) {\n                a = p;\n                codeA = newCode;\n            } else {\n                b = p;\n                codeB = newCode;\n            }\n        }\n    }\n    function _getEdgeIntersection(a, b, code, bounds, round) {\n        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;\n        if (code & 8) {\n            x = a.x + dx * (max.y - a.y) / dy;\n            y = max.y;\n        } else if (code & 4) {\n            x = a.x + dx * (min.y - a.y) / dy;\n            y = min.y;\n        } else if (code & 2) {\n            x = max.x;\n            y = a.y + dy * (max.x - a.x) / dx;\n        } else if (code & 1) {\n            x = min.x;\n            y = a.y + dy * (min.x - a.x) / dx;\n        }\n        return new Point(x, y, round);\n    }\n    function _getBitCode(p, bounds) {\n        var code = 0;\n        if (p.x < bounds.min.x) {\n            code |= 1;\n        } else if (p.x > bounds.max.x) {\n            code |= 2;\n        }\n        if (p.y < bounds.min.y) {\n            code |= 4;\n        } else if (p.y > bounds.max.y) {\n            code |= 8;\n        }\n        return code;\n    }\n    // square distance (to avoid unnecessary Math.sqrt calls)\n    function _sqDist(p1, p2) {\n        var dx = p2.x - p1.x, dy = p2.y - p1.y;\n        return dx * dx + dy * dy;\n    }\n    // return closest point on segment or distance to that point\n    function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;\n        if (dot > 0) {\n            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n            if (t > 1) {\n                x = p2.x;\n                y = p2.y;\n            } else if (t > 0) {\n                x += dx * t;\n                y += dy * t;\n            }\n        }\n        dx = p.x - x;\n        dy = p.y - y;\n        return sqDist ? dx * dx + dy * dy : new Point(x, y);\n    }\n    // @function isFlat(latlngs: LatLng[]): Boolean\n    // Returns true if `latlngs` is a flat array, false is nested.\n    function isFlat(latlngs) {\n        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== \"object\" && typeof latlngs[0][0] !== \"undefined\";\n    }\n    function _flat(latlngs) {\n        console.warn(\"Deprecated use of _flat, please use L.LineUtil.isFlat instead.\");\n        return isFlat(latlngs);\n    }\n    /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */ function polylineCenter(latlngs, crs) {\n        var i, halfDist, segDist, dist, p1, p2, ratio, center;\n        if (!latlngs || latlngs.length === 0) {\n            throw new Error(\"latlngs not passed\");\n        }\n        if (!isFlat(latlngs)) {\n            console.warn(\"latlngs are not flat! Only the first ring will be used\");\n            latlngs = latlngs[0];\n        }\n        var centroidLatLng = toLatLng([\n            0,\n            0\n        ]);\n        var bounds = toLatLngBounds(latlngs);\n        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n        // tests showed that below 1700 rounding errors are happening\n        if (areaBounds < 1700) {\n            // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n            centroidLatLng = centroid(latlngs);\n        }\n        var len = latlngs.length;\n        var points = [];\n        for(i = 0; i < len; i++){\n            var latlng = toLatLng(latlngs[i]);\n            points.push(crs.project(toLatLng([\n                latlng.lat - centroidLatLng.lat,\n                latlng.lng - centroidLatLng.lng\n            ])));\n        }\n        for(i = 0, halfDist = 0; i < len - 1; i++){\n            halfDist += points[i].distanceTo(points[i + 1]) / 2;\n        }\n        // The line is so small in the current view that all points are on the same pixel.\n        if (halfDist === 0) {\n            center = points[0];\n        } else {\n            for(i = 0, dist = 0; i < len - 1; i++){\n                p1 = points[i];\n                p2 = points[i + 1];\n                segDist = p1.distanceTo(p2);\n                dist += segDist;\n                if (dist > halfDist) {\n                    ratio = (dist - halfDist) / segDist;\n                    center = [\n                        p2.x - ratio * (p2.x - p1.x),\n                        p2.y - ratio * (p2.y - p1.y)\n                    ];\n                    break;\n                }\n            }\n        }\n        var latlngCenter = crs.unproject(toPoint(center));\n        return toLatLng([\n            latlngCenter.lat + centroidLatLng.lat,\n            latlngCenter.lng + centroidLatLng.lng\n        ]);\n    }\n    var LineUtil = {\n        __proto__: null,\n        simplify: simplify,\n        pointToSegmentDistance: pointToSegmentDistance,\n        closestPointOnSegment: closestPointOnSegment,\n        clipSegment: clipSegment,\n        _getEdgeIntersection: _getEdgeIntersection,\n        _getBitCode: _getBitCode,\n        _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n        isFlat: isFlat,\n        _flat: _flat,\n        polylineCenter: polylineCenter\n    };\n    /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */ var LonLat = {\n        project: function(latlng) {\n            return new Point(latlng.lng, latlng.lat);\n        },\n        unproject: function(point) {\n            return new LatLng(point.y, point.x);\n        },\n        bounds: new Bounds([\n            -180,\n            -90\n        ], [\n            180,\n            90\n        ])\n    };\n    /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */ var Mercator = {\n        R: 6378137,\n        R_MINOR: 6356752.314245179,\n        bounds: new Bounds([\n            -20037508.34279,\n            -15496570.73972\n        ], [\n            20037508.34279,\n            18764656.23138\n        ]),\n        project: function(latlng) {\n            var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);\n            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n            y = -r * Math.log(Math.max(ts, 1E-10));\n            return new Point(latlng.lng * d * r, y);\n        },\n        unproject: function(point) {\n            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);\n            for(var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++){\n                con = e * Math.sin(phi);\n                con = Math.pow((1 - con) / (1 + con), e / 2);\n                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n                phi += dphi;\n            }\n            return new LatLng(phi * d, point.x * d / r);\n        }\n    };\n    /*\n   * @class Projection\n\n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n\n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n\n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n\n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n\n   * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n\n   */ var index = {\n        __proto__: null,\n        LonLat: LonLat,\n        Mercator: Mercator,\n        SphericalMercator: SphericalMercator\n    };\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */ var EPSG3395 = extend({}, Earth, {\n        code: \"EPSG:3395\",\n        projection: Mercator,\n        transformation: function() {\n            var scale = 0.5 / (Math.PI * Mercator.R);\n            return toTransformation(scale, 0.5, -scale, 0.5);\n        }()\n    });\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */ var EPSG4326 = extend({}, Earth, {\n        code: \"EPSG:4326\",\n        projection: LonLat,\n        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n    });\n    /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */ var Simple = extend({}, CRS, {\n        projection: LonLat,\n        transformation: toTransformation(1, 0, -1, 0),\n        scale: function(zoom) {\n            return Math.pow(2, zoom);\n        },\n        zoom: function(scale) {\n            return Math.log(scale) / Math.LN2;\n        },\n        distance: function(latlng1, latlng2) {\n            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        infinite: true\n    });\n    CRS.Earth = Earth;\n    CRS.EPSG3395 = EPSG3395;\n    CRS.EPSG3857 = EPSG3857;\n    CRS.EPSG900913 = EPSG900913;\n    CRS.EPSG4326 = EPSG4326;\n    CRS.Simple = Simple;\n    /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */ var Layer = Evented.extend({\n        // Classes extending `L.Layer` will inherit the following options:\n        options: {\n            // @option pane: String = 'overlayPane'\n            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n            pane: \"overlayPane\",\n            // @option attribution: String = null\n            // String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n            attribution: null,\n            bubblingMouseEvents: true\n        },\n        /* @section\n  \t * Classes extending `L.Layer` will inherit the following methods:\n  \t *\n  \t * @method addTo(map: Map|LayerGroup): this\n  \t * Adds the layer to the given map or layer group.\n  \t */ addTo: function(map) {\n            map.addLayer(this);\n            return this;\n        },\n        // @method remove: this\n        // Removes the layer from the map it is currently active on.\n        remove: function() {\n            return this.removeFrom(this._map || this._mapToAdd);\n        },\n        // @method removeFrom(map: Map): this\n        // Removes the layer from the given map\n        //\n        // @alternative\n        // @method removeFrom(group: LayerGroup): this\n        // Removes the layer from the given `LayerGroup`\n        removeFrom: function(obj) {\n            if (obj) {\n                obj.removeLayer(this);\n            }\n            return this;\n        },\n        // @method getPane(name? : String): HTMLElement\n        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n        getPane: function(name) {\n            return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n        },\n        addInteractiveTarget: function(targetEl) {\n            this._map._targets[stamp(targetEl)] = this;\n            return this;\n        },\n        removeInteractiveTarget: function(targetEl) {\n            delete this._map._targets[stamp(targetEl)];\n            return this;\n        },\n        // @method getAttribution: String\n        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n        getAttribution: function() {\n            return this.options.attribution;\n        },\n        _layerAdd: function(e) {\n            var map = e.target;\n            // check in case layer gets added and then removed before the map is ready\n            if (!map.hasLayer(this)) {\n                return;\n            }\n            this._map = map;\n            this._zoomAnimated = map._zoomAnimated;\n            if (this.getEvents) {\n                var events = this.getEvents();\n                map.on(events, this);\n                this.once(\"remove\", function() {\n                    map.off(events, this);\n                }, this);\n            }\n            this.onAdd(map);\n            this.fire(\"add\");\n            map.fire(\"layeradd\", {\n                layer: this\n            });\n        }\n    });\n    /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */ /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */ Map.include({\n        // @method addLayer(layer: Layer): this\n        // Adds the given layer to the map\n        addLayer: function(layer) {\n            if (!layer._layerAdd) {\n                throw new Error(\"The provided object is not a Layer.\");\n            }\n            var id = stamp(layer);\n            if (this._layers[id]) {\n                return this;\n            }\n            this._layers[id] = layer;\n            layer._mapToAdd = this;\n            if (layer.beforeAdd) {\n                layer.beforeAdd(this);\n            }\n            this.whenReady(layer._layerAdd, layer);\n            return this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Removes the given layer from the map.\n        removeLayer: function(layer) {\n            var id = stamp(layer);\n            if (!this._layers[id]) {\n                return this;\n            }\n            if (this._loaded) {\n                layer.onRemove(this);\n            }\n            delete this._layers[id];\n            if (this._loaded) {\n                this.fire(\"layerremove\", {\n                    layer: layer\n                });\n                layer.fire(\"remove\");\n            }\n            layer._map = layer._mapToAdd = null;\n            return this;\n        },\n        // @method hasLayer(layer: Layer): Boolean\n        // Returns `true` if the given layer is currently added to the map\n        hasLayer: function(layer) {\n            return stamp(layer) in this._layers;\n        },\n        /* @method eachLayer(fn: Function, context?: Object): this\n  \t * Iterates over the layers of the map, optionally specifying context of the iterator function.\n  \t * ```\n  \t * map.eachLayer(function(layer){\n  \t *     layer.bindPopup('Hello');\n  \t * });\n  \t * ```\n  \t */ eachLayer: function(method, context) {\n            for(var i in this._layers){\n                method.call(context, this._layers[i]);\n            }\n            return this;\n        },\n        _addLayers: function(layers) {\n            layers = layers ? isArray(layers) ? layers : [\n                layers\n            ] : [];\n            for(var i = 0, len = layers.length; i < len; i++){\n                this.addLayer(layers[i]);\n            }\n        },\n        _addZoomLimit: function(layer) {\n            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n                this._zoomBoundLayers[stamp(layer)] = layer;\n                this._updateZoomLevels();\n            }\n        },\n        _removeZoomLimit: function(layer) {\n            var id = stamp(layer);\n            if (this._zoomBoundLayers[id]) {\n                delete this._zoomBoundLayers[id];\n                this._updateZoomLevels();\n            }\n        },\n        _updateZoomLevels: function() {\n            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();\n            for(var i in this._zoomBoundLayers){\n                var options = this._zoomBoundLayers[i].options;\n                minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n                maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n            }\n            this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n            this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n            // @section Map state change events\n            // @event zoomlevelschange: Event\n            // Fired when the number of zoomlevels on the map is changed due\n            // to adding or removing a layer.\n            if (oldZoomSpan !== this._getZoomSpan()) {\n                this.fire(\"zoomlevelschange\");\n            }\n            if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n                this.setZoom(this._layersMaxZoom);\n            }\n            if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n                this.setZoom(this._layersMinZoom);\n            }\n        }\n    });\n    /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */ var LayerGroup = Layer.extend({\n        initialize: function(layers, options) {\n            setOptions(this, options);\n            this._layers = {};\n            var i, len;\n            if (layers) {\n                for(i = 0, len = layers.length; i < len; i++){\n                    this.addLayer(layers[i]);\n                }\n            }\n        },\n        // @method addLayer(layer: Layer): this\n        // Adds the given layer to the group.\n        addLayer: function(layer) {\n            var id = this.getLayerId(layer);\n            this._layers[id] = layer;\n            if (this._map) {\n                this._map.addLayer(layer);\n            }\n            return this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Removes the given layer from the group.\n        // @alternative\n        // @method removeLayer(id: Number): this\n        // Removes the layer with the given internal ID from the group.\n        removeLayer: function(layer) {\n            var id = layer in this._layers ? layer : this.getLayerId(layer);\n            if (this._map && this._layers[id]) {\n                this._map.removeLayer(this._layers[id]);\n            }\n            delete this._layers[id];\n            return this;\n        },\n        // @method hasLayer(layer: Layer): Boolean\n        // Returns `true` if the given layer is currently added to the group.\n        // @alternative\n        // @method hasLayer(id: Number): Boolean\n        // Returns `true` if the given internal ID is currently added to the group.\n        hasLayer: function(layer) {\n            var layerId = typeof layer === \"number\" ? layer : this.getLayerId(layer);\n            return layerId in this._layers;\n        },\n        // @method clearLayers(): this\n        // Removes all the layers from the group.\n        clearLayers: function() {\n            return this.eachLayer(this.removeLayer, this);\n        },\n        // @method invoke(methodName: String, ): this\n        // Calls `methodName` on every layer contained in this group, passing any\n        // additional parameters. Has no effect if the layers contained do not\n        // implement `methodName`.\n        invoke: function(methodName) {\n            var args = Array.prototype.slice.call(arguments, 1), i, layer;\n            for(i in this._layers){\n                layer = this._layers[i];\n                if (layer[methodName]) {\n                    layer[methodName].apply(layer, args);\n                }\n            }\n            return this;\n        },\n        onAdd: function(map) {\n            this.eachLayer(map.addLayer, map);\n        },\n        onRemove: function(map) {\n            this.eachLayer(map.removeLayer, map);\n        },\n        // @method eachLayer(fn: Function, context?: Object): this\n        // Iterates over the layers of the group, optionally specifying context of the iterator function.\n        // ```js\n        // group.eachLayer(function (layer) {\n        // \tlayer.bindPopup('Hello');\n        // });\n        // ```\n        eachLayer: function(method, context) {\n            for(var i in this._layers){\n                method.call(context, this._layers[i]);\n            }\n            return this;\n        },\n        // @method getLayer(id: Number): Layer\n        // Returns the layer with the given internal ID.\n        getLayer: function(id) {\n            return this._layers[id];\n        },\n        // @method getLayers(): Layer[]\n        // Returns an array of all the layers added to the group.\n        getLayers: function() {\n            var layers = [];\n            this.eachLayer(layers.push, layers);\n            return layers;\n        },\n        // @method setZIndex(zIndex: Number): this\n        // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n        setZIndex: function(zIndex) {\n            return this.invoke(\"setZIndex\", zIndex);\n        },\n        // @method getLayerId(layer: Layer): Number\n        // Returns the internal ID for a layer\n        getLayerId: function(layer) {\n            return stamp(layer);\n        }\n    });\n    // @factory L.layerGroup(layers?: Layer[], options?: Object)\n    // Create a layer group, optionally given an initial set of layers and an `options` object.\n    var layerGroup = function(layers, options) {\n        return new LayerGroup(layers, options);\n    };\n    /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */ var FeatureGroup = LayerGroup.extend({\n        addLayer: function(layer) {\n            if (this.hasLayer(layer)) {\n                return this;\n            }\n            layer.addEventParent(this);\n            LayerGroup.prototype.addLayer.call(this, layer);\n            // @event layeradd: LayerEvent\n            // Fired when a layer is added to this `FeatureGroup`\n            return this.fire(\"layeradd\", {\n                layer: layer\n            });\n        },\n        removeLayer: function(layer) {\n            if (!this.hasLayer(layer)) {\n                return this;\n            }\n            if (layer in this._layers) {\n                layer = this._layers[layer];\n            }\n            layer.removeEventParent(this);\n            LayerGroup.prototype.removeLayer.call(this, layer);\n            // @event layerremove: LayerEvent\n            // Fired when a layer is removed from this `FeatureGroup`\n            return this.fire(\"layerremove\", {\n                layer: layer\n            });\n        },\n        // @method setStyle(style: Path options): this\n        // Sets the given path options to each layer of the group that has a `setStyle` method.\n        setStyle: function(style) {\n            return this.invoke(\"setStyle\", style);\n        },\n        // @method bringToFront(): this\n        // Brings the layer group to the top of all other layers\n        bringToFront: function() {\n            return this.invoke(\"bringToFront\");\n        },\n        // @method bringToBack(): this\n        // Brings the layer group to the back of all other layers\n        bringToBack: function() {\n            return this.invoke(\"bringToBack\");\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n        getBounds: function() {\n            var bounds = new LatLngBounds();\n            for(var id in this._layers){\n                var layer = this._layers[id];\n                bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n            }\n            return bounds;\n        }\n    });\n    // @factory L.featureGroup(layers?: Layer[], options?: Object)\n    // Create a feature group, optionally given an initial set of layers and an `options` object.\n    var featureGroup = function(layers, options) {\n        return new FeatureGroup(layers, options);\n    };\n    /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */ var Icon = Class.extend({\n        /* @section\r\n  \t * @aka Icon options\r\n  \t *\r\n  \t * @option iconUrl: String = null\r\n  \t * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n  \t *\r\n  \t * @option iconRetinaUrl: String = null\r\n  \t * The URL to a retina sized version of the icon image (absolute or relative to your\r\n  \t * script path). Used for Retina screen devices.\r\n  \t *\r\n  \t * @option iconSize: Point = null\r\n  \t * Size of the icon image in pixels.\r\n  \t *\r\n  \t * @option iconAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n  \t * will be aligned so that this point is at the marker's geographical location. Centered\r\n  \t * by default if size is specified, also can be set in CSS with negative margins.\r\n  \t *\r\n  \t * @option popupAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option tooltipAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option shadowUrl: String = null\r\n  \t * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n  \t *\r\n  \t * @option shadowRetinaUrl: String = null\r\n  \t *\r\n  \t * @option shadowSize: Point = null\r\n  \t * Size of the shadow image in pixels.\r\n  \t *\r\n  \t * @option shadowAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n  \t * as iconAnchor if not specified).\r\n  \t *\r\n  \t * @option className: String = ''\r\n  \t * A custom class name to assign to both icon and shadow images. Empty by default.\r\n  \t */ options: {\n            popupAnchor: [\n                0,\n                0\n            ],\n            tooltipAnchor: [\n                0,\n                0\n            ],\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n        // Called internally when the icon has to be shown, returns a `<img>` HTML element\n        // styled according to the options.\n        createIcon: function(oldIcon) {\n            return this._createIcon(\"icon\", oldIcon);\n        },\n        // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n        // As `createIcon`, but for the shadow beneath it.\n        createShadow: function(oldIcon) {\n            return this._createIcon(\"shadow\", oldIcon);\n        },\n        _createIcon: function(name, oldIcon) {\n            var src = this._getIconUrl(name);\n            if (!src) {\n                if (name === \"icon\") {\n                    throw new Error(\"iconUrl not set in Icon options (see the docs).\");\n                }\n                return null;\n            }\n            var img = this._createImg(src, oldIcon && oldIcon.tagName === \"IMG\" ? oldIcon : null);\n            this._setIconStyles(img, name);\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                img.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            return img;\n        },\n        _setIconStyles: function(img, name) {\n            var options = this.options;\n            var sizeOption = options[name + \"Size\"];\n            if (typeof sizeOption === \"number\") {\n                sizeOption = [\n                    sizeOption,\n                    sizeOption\n                ];\n            }\n            var size = toPoint(sizeOption), anchor = toPoint(name === \"shadow\" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n            img.className = \"leaflet-marker-\" + name + \" \" + (options.className || \"\");\n            if (anchor) {\n                img.style.marginLeft = -anchor.x + \"px\";\n                img.style.marginTop = -anchor.y + \"px\";\n            }\n            if (size) {\n                img.style.width = size.x + \"px\";\n                img.style.height = size.y + \"px\";\n            }\n        },\n        _createImg: function(src, el) {\n            el = el || document.createElement(\"img\");\n            el.src = src;\n            return el;\n        },\n        _getIconUrl: function(name) {\n            return Browser.retina && this.options[name + \"RetinaUrl\"] || this.options[name + \"Url\"];\n        }\n    });\n    // @factory L.icon(options: Icon options)\n    // Creates an icon instance with the given options.\n    function icon(options) {\n        return new Icon(options);\n    }\n    /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */ var IconDefault = Icon.extend({\n        options: {\n            iconUrl: \"marker-icon.png\",\n            iconRetinaUrl: \"marker-icon-2x.png\",\n            shadowUrl: \"marker-shadow.png\",\n            iconSize: [\n                25,\n                41\n            ],\n            iconAnchor: [\n                12,\n                41\n            ],\n            popupAnchor: [\n                1,\n                -34\n            ],\n            tooltipAnchor: [\n                16,\n                -28\n            ],\n            shadowSize: [\n                41,\n                41\n            ]\n        },\n        _getIconUrl: function(name) {\n            if (typeof IconDefault.imagePath !== \"string\") {\n                IconDefault.imagePath = this._detectIconPath();\n            }\n            // @option imagePath: String\n            // `Icon.Default` will try to auto-detect the location of the\n            // blue icon images. If you are placing these images in a non-standard\n            // way, set this option to point to the right path.\n            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n        },\n        _stripUrl: function(path) {\n            var strip = function(str, re, idx) {\n                var match = re.exec(str);\n                return match && match[idx];\n            };\n            path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n            return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n        },\n        _detectIconPath: function() {\n            var el = create$1(\"div\", \"leaflet-default-icon-path\", document.body);\n            var path = getStyle(el, \"background-image\") || getStyle(el, \"backgroundImage\"); // IE8\n            document.body.removeChild(el);\n            path = this._stripUrl(path);\n            if (path) {\n                return path;\n            }\n            var link = document.querySelector('link[href$=\"leaflet.css\"]');\n            if (!link) {\n                return \"\";\n            }\n            return link.href.substring(0, link.href.length - \"leaflet.css\".length - 1);\n        }\n    });\n    /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */ /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */ var MarkerDrag = Handler.extend({\n        initialize: function(marker) {\n            this._marker = marker;\n        },\n        addHooks: function() {\n            var icon = this._marker._icon;\n            if (!this._draggable) {\n                this._draggable = new Draggable(icon, icon, true);\n            }\n            this._draggable.on({\n                dragstart: this._onDragStart,\n                predrag: this._onPreDrag,\n                drag: this._onDrag,\n                dragend: this._onDragEnd\n            }, this).enable();\n            addClass(icon, \"leaflet-marker-draggable\");\n        },\n        removeHooks: function() {\n            this._draggable.off({\n                dragstart: this._onDragStart,\n                predrag: this._onPreDrag,\n                drag: this._onDrag,\n                dragend: this._onDragEnd\n            }, this).disable();\n            if (this._marker._icon) {\n                removeClass(this._marker._icon, \"leaflet-marker-draggable\");\n            }\n        },\n        moved: function() {\n            return this._draggable && this._draggable._moved;\n        },\n        _adjustPan: function(e) {\n            var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();\n            var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n            if (!panBounds.contains(iconPos)) {\n                // Compute incremental movement\n                var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n                map.panBy(movement, {\n                    animate: false\n                });\n                this._draggable._newPos._add(movement);\n                this._draggable._startPos._add(movement);\n                setPosition(marker._icon, this._draggable._newPos);\n                this._onDrag(e);\n                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n            }\n        },\n        _onDragStart: function() {\n            // @section Dragging events\n            // @event dragstart: Event\n            // Fired when the user starts dragging the marker.\n            // @event movestart: Event\n            // Fired when the marker starts moving (because of dragging).\n            this._oldLatLng = this._marker.getLatLng();\n            // When using ES6 imports it could not be set when `Popup` was not imported as well\n            this._marker.closePopup && this._marker.closePopup();\n            this._marker.fire(\"movestart\").fire(\"dragstart\");\n        },\n        _onPreDrag: function(e) {\n            if (this._marker.options.autoPan) {\n                cancelAnimFrame(this._panRequest);\n                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n            }\n        },\n        _onDrag: function(e) {\n            var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);\n            // update shadow position\n            if (shadow) {\n                setPosition(shadow, iconPos);\n            }\n            marker._latlng = latlng;\n            e.latlng = latlng;\n            e.oldLatLng = this._oldLatLng;\n            // @event drag: Event\n            // Fired repeatedly while the user drags the marker.\n            marker.fire(\"move\", e).fire(\"drag\", e);\n        },\n        _onDragEnd: function(e) {\n            // @event dragend: DragEndEvent\n            // Fired when the user stops dragging the marker.\n            cancelAnimFrame(this._panRequest);\n            // @event moveend: Event\n            // Fired when the marker stops moving (because of dragging).\n            delete this._oldLatLng;\n            this._marker.fire(\"moveend\").fire(\"dragend\", e);\n        }\n    });\n    /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */ var Marker = Layer.extend({\n        // @section\n        // @aka Marker options\n        options: {\n            // @option icon: Icon = *\n            // Icon instance to use for rendering the marker.\n            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n            // If not specified, a common instance of `L.Icon.Default` is used.\n            icon: new IconDefault(),\n            // Option inherited from \"Interactive layer\" abstract class\n            interactive: true,\n            // @option keyboard: Boolean = true\n            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n            keyboard: true,\n            // @option title: String = ''\n            // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n            title: \"\",\n            // @option alt: String = 'Marker'\n            // Text for the `alt` attribute of the icon image.\n            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n            alt: \"Marker\",\n            // @option zIndexOffset: Number = 0\n            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n            zIndexOffset: 0,\n            // @option opacity: Number = 1.0\n            // The opacity of the marker.\n            opacity: 1,\n            // @option riseOnHover: Boolean = false\n            // If `true`, the marker will get on top of others when you hover the mouse over it.\n            riseOnHover: false,\n            // @option riseOffset: Number = 250\n            // The z-index offset used for the `riseOnHover` feature.\n            riseOffset: 250,\n            // @option pane: String = 'markerPane'\n            // `Map pane` where the markers icon will be added.\n            pane: \"markerPane\",\n            // @option shadowPane: String = 'shadowPane'\n            // `Map pane` where the markers shadow will be added.\n            shadowPane: \"shadowPane\",\n            // @option bubblingMouseEvents: Boolean = false\n            // When `true`, a mouse event on this marker will trigger the same event on the map\n            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n            bubblingMouseEvents: false,\n            // @option autoPanOnFocus: Boolean = true\n            // When `true`, the map will pan whenever the marker is focused (via\n            // e.g. pressing `tab` on the keyboard) to ensure the marker is\n            // visible within the map's bounds\n            autoPanOnFocus: true,\n            // @section Draggable marker options\n            // @option draggable: Boolean = false\n            // Whether the marker is draggable with mouse/touch or not.\n            draggable: false,\n            // @option autoPan: Boolean = false\n            // Whether to pan the map when dragging this marker near its edge or not.\n            autoPan: false,\n            // @option autoPanPadding: Point = Point(50, 50)\n            // Distance (in pixels to the left/right and to the top/bottom) of the\n            // map edge to start panning the map.\n            autoPanPadding: [\n                50,\n                50\n            ],\n            // @option autoPanSpeed: Number = 10\n            // Number of pixels the map should pan by.\n            autoPanSpeed: 10\n        },\n        /* @section\r\n  \t *\r\n  \t * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n  \t */ initialize: function(latlng, options) {\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n        },\n        onAdd: function(map) {\n            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n            if (this._zoomAnimated) {\n                map.on(\"zoomanim\", this._animateZoom, this);\n            }\n            this._initIcon();\n            this.update();\n        },\n        onRemove: function(map) {\n            if (this.dragging && this.dragging.enabled()) {\n                this.options.draggable = true;\n                this.dragging.removeHooks();\n            }\n            delete this.dragging;\n            if (this._zoomAnimated) {\n                map.off(\"zoomanim\", this._animateZoom, this);\n            }\n            this._removeIcon();\n            this._removeShadow();\n        },\n        getEvents: function() {\n            return {\n                zoom: this.update,\n                viewreset: this.update\n            };\n        },\n        // @method getLatLng: LatLng\n        // Returns the current geographical position of the marker.\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setLatLng(latlng: LatLng): this\n        // Changes the marker position to the given point.\n        setLatLng: function(latlng) {\n            var oldLatLng = this._latlng;\n            this._latlng = toLatLng(latlng);\n            this.update();\n            // @event move: Event\n            // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n            return this.fire(\"move\", {\n                oldLatLng: oldLatLng,\n                latlng: this._latlng\n            });\n        },\n        // @method setZIndexOffset(offset: Number): this\n        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n        setZIndexOffset: function(offset) {\n            this.options.zIndexOffset = offset;\n            return this.update();\n        },\n        // @method getIcon: Icon\n        // Returns the current icon used by the marker\n        getIcon: function() {\n            return this.options.icon;\n        },\n        // @method setIcon(icon: Icon): this\n        // Changes the marker icon.\n        setIcon: function(icon) {\n            this.options.icon = icon;\n            if (this._map) {\n                this._initIcon();\n                this.update();\n            }\n            if (this._popup) {\n                this.bindPopup(this._popup, this._popup.options);\n            }\n            return this;\n        },\n        getElement: function() {\n            return this._icon;\n        },\n        update: function() {\n            if (this._icon && this._map) {\n                var pos = this._map.latLngToLayerPoint(this._latlng).round();\n                this._setPos(pos);\n            }\n            return this;\n        },\n        _initIcon: function() {\n            var options = this.options, classToAdd = \"leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\");\n            var icon = options.icon.createIcon(this._icon), addIcon = false;\n            // if we're not reusing the icon, remove the old one and init new one\n            if (icon !== this._icon) {\n                if (this._icon) {\n                    this._removeIcon();\n                }\n                addIcon = true;\n                if (options.title) {\n                    icon.title = options.title;\n                }\n                if (icon.tagName === \"IMG\") {\n                    icon.alt = options.alt || \"\";\n                }\n            }\n            addClass(icon, classToAdd);\n            if (options.keyboard) {\n                icon.tabIndex = \"0\";\n                icon.setAttribute(\"role\", \"button\");\n            }\n            this._icon = icon;\n            if (options.riseOnHover) {\n                this.on({\n                    mouseover: this._bringToFront,\n                    mouseout: this._resetZIndex\n                });\n            }\n            if (this.options.autoPanOnFocus) {\n                on(icon, \"focus\", this._panOnFocus, this);\n            }\n            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;\n            if (newShadow !== this._shadow) {\n                this._removeShadow();\n                addShadow = true;\n            }\n            if (newShadow) {\n                addClass(newShadow, classToAdd);\n                newShadow.alt = \"\";\n            }\n            this._shadow = newShadow;\n            if (options.opacity < 1) {\n                this._updateOpacity();\n            }\n            if (addIcon) {\n                this.getPane().appendChild(this._icon);\n            }\n            this._initInteraction();\n            if (newShadow && addShadow) {\n                this.getPane(options.shadowPane).appendChild(this._shadow);\n            }\n        },\n        _removeIcon: function() {\n            if (this.options.riseOnHover) {\n                this.off({\n                    mouseover: this._bringToFront,\n                    mouseout: this._resetZIndex\n                });\n            }\n            if (this.options.autoPanOnFocus) {\n                off(this._icon, \"focus\", this._panOnFocus, this);\n            }\n            remove(this._icon);\n            this.removeInteractiveTarget(this._icon);\n            this._icon = null;\n        },\n        _removeShadow: function() {\n            if (this._shadow) {\n                remove(this._shadow);\n            }\n            this._shadow = null;\n        },\n        _setPos: function(pos) {\n            if (this._icon) {\n                setPosition(this._icon, pos);\n            }\n            if (this._shadow) {\n                setPosition(this._shadow, pos);\n            }\n            this._zIndex = pos.y + this.options.zIndexOffset;\n            this._resetZIndex();\n        },\n        _updateZIndex: function(offset) {\n            if (this._icon) {\n                this._icon.style.zIndex = this._zIndex + offset;\n            }\n        },\n        _animateZoom: function(opt) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n            this._setPos(pos);\n        },\n        _initInteraction: function() {\n            if (!this.options.interactive) {\n                return;\n            }\n            addClass(this._icon, \"leaflet-interactive\");\n            this.addInteractiveTarget(this._icon);\n            if (MarkerDrag) {\n                var draggable = this.options.draggable;\n                if (this.dragging) {\n                    draggable = this.dragging.enabled();\n                    this.dragging.disable();\n                }\n                this.dragging = new MarkerDrag(this);\n                if (draggable) {\n                    this.dragging.enable();\n                }\n            }\n        },\n        // @method setOpacity(opacity: Number): this\n        // Changes the opacity of the marker.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._map) {\n                this._updateOpacity();\n            }\n            return this;\n        },\n        _updateOpacity: function() {\n            var opacity = this.options.opacity;\n            if (this._icon) {\n                setOpacity(this._icon, opacity);\n            }\n            if (this._shadow) {\n                setOpacity(this._shadow, opacity);\n            }\n        },\n        _bringToFront: function() {\n            this._updateZIndex(this.options.riseOffset);\n        },\n        _resetZIndex: function() {\n            this._updateZIndex(0);\n        },\n        _panOnFocus: function() {\n            var map = this._map;\n            if (!map) {\n                return;\n            }\n            var iconOpts = this.options.icon.options;\n            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n            map.panInside(this._latlng, {\n                paddingTopLeft: anchor,\n                paddingBottomRight: size.subtract(anchor)\n            });\n        },\n        _getPopupAnchor: function() {\n            return this.options.icon.options.popupAnchor;\n        },\n        _getTooltipAnchor: function() {\n            return this.options.icon.options.tooltipAnchor;\n        }\n    });\n    // factory L.marker(latlng: LatLng, options? : Marker options)\n    // @factory L.marker(latlng: LatLng, options? : Marker options)\n    // Instantiates a Marker object given a geographical point and optionally an options object.\n    function marker(latlng, options) {\n        return new Marker(latlng, options);\n    }\n    /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */ var Path = Layer.extend({\n        // @section\n        // @aka Path options\n        options: {\n            // @option stroke: Boolean = true\n            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n            stroke: true,\n            // @option color: String = '#3388ff'\n            // Stroke color\n            color: \"#3388ff\",\n            // @option weight: Number = 3\n            // Stroke width in pixels\n            weight: 3,\n            // @option opacity: Number = 1.0\n            // Stroke opacity\n            opacity: 1,\n            // @option lineCap: String= 'round'\n            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n            lineCap: \"round\",\n            // @option lineJoin: String = 'round'\n            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n            lineJoin: \"round\",\n            // @option dashArray: String = null\n            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n            dashArray: null,\n            // @option dashOffset: String = null\n            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n            dashOffset: null,\n            // @option fill: Boolean = depends\n            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n            fill: false,\n            // @option fillColor: String = *\n            // Fill color. Defaults to the value of the [`color`](#path-color) option\n            fillColor: null,\n            // @option fillOpacity: Number = 0.2\n            // Fill opacity.\n            fillOpacity: 0.2,\n            // @option fillRule: String = 'evenodd'\n            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n            fillRule: \"evenodd\",\n            // className: '',\n            // Option inherited from \"Interactive layer\" abstract class\n            interactive: true,\n            // @option bubblingMouseEvents: Boolean = true\n            // When `true`, a mouse event on this path will trigger the same event on the map\n            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n            bubblingMouseEvents: true\n        },\n        beforeAdd: function(map) {\n            // Renderer is set here because we need to call renderer.getEvents\n            // before this.getEvents.\n            this._renderer = map.getRenderer(this);\n        },\n        onAdd: function() {\n            this._renderer._initPath(this);\n            this._reset();\n            this._renderer._addPath(this);\n        },\n        onRemove: function() {\n            this._renderer._removePath(this);\n        },\n        // @method redraw(): this\n        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n        redraw: function() {\n            if (this._map) {\n                this._renderer._updatePath(this);\n            }\n            return this;\n        },\n        // @method setStyle(style: Path options): this\n        // Changes the appearance of a Path based on the options in the `Path options` object.\n        setStyle: function(style) {\n            setOptions(this, style);\n            if (this._renderer) {\n                this._renderer._updateStyle(this);\n                if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, \"weight\")) {\n                    this._updateBounds();\n                }\n            }\n            return this;\n        },\n        // @method bringToFront(): this\n        // Brings the layer to the top of all path layers.\n        bringToFront: function() {\n            if (this._renderer) {\n                this._renderer._bringToFront(this);\n            }\n            return this;\n        },\n        // @method bringToBack(): this\n        // Brings the layer to the bottom of all path layers.\n        bringToBack: function() {\n            if (this._renderer) {\n                this._renderer._bringToBack(this);\n            }\n            return this;\n        },\n        getElement: function() {\n            return this._path;\n        },\n        _reset: function() {\n            // defined in child classes\n            this._project();\n            this._update();\n        },\n        _clickTolerance: function() {\n            // used when doing hit detection for Canvas layers\n            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n        }\n    });\n    /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */ var CircleMarker = Path.extend({\n        // @section\n        // @aka CircleMarker options\n        options: {\n            fill: true,\n            // @option radius: Number = 10\n            // Radius of the circle marker, in pixels\n            radius: 10\n        },\n        initialize: function(latlng, options) {\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n            this._radius = this.options.radius;\n        },\n        // @method setLatLng(latLng: LatLng): this\n        // Sets the position of a circle marker to a new location.\n        setLatLng: function(latlng) {\n            var oldLatLng = this._latlng;\n            this._latlng = toLatLng(latlng);\n            this.redraw();\n            // @event move: Event\n            // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n            return this.fire(\"move\", {\n                oldLatLng: oldLatLng,\n                latlng: this._latlng\n            });\n        },\n        // @method getLatLng(): LatLng\n        // Returns the current geographical position of the circle marker\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setRadius(radius: Number): this\n        // Sets the radius of a circle marker. Units are in pixels.\n        setRadius: function(radius) {\n            this.options.radius = this._radius = radius;\n            return this.redraw();\n        },\n        // @method getRadius(): Number\n        // Returns the current radius of the circle\n        getRadius: function() {\n            return this._radius;\n        },\n        setStyle: function(options) {\n            var radius = options && options.radius || this._radius;\n            Path.prototype.setStyle.call(this, options);\n            this.setRadius(radius);\n            return this;\n        },\n        _project: function() {\n            this._point = this._map.latLngToLayerPoint(this._latlng);\n            this._updateBounds();\n        },\n        _updateBounds: function() {\n            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [\n                r + w,\n                r2 + w\n            ];\n            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n        },\n        _update: function() {\n            if (this._map) {\n                this._updatePath();\n            }\n        },\n        _updatePath: function() {\n            this._renderer._updateCircle(this);\n        },\n        _empty: function() {\n            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p) {\n            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n        }\n    });\n    // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n    // Instantiates a circle marker object given a geographical point, and an optional options object.\n    function circleMarker(latlng, options) {\n        return new CircleMarker(latlng, options);\n    }\n    /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */ var Circle = CircleMarker.extend({\n        initialize: function(latlng, options, legacyOptions) {\n            if (typeof options === \"number\") {\n                // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n                options = extend({}, legacyOptions, {\n                    radius: options\n                });\n            }\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n            if (isNaN(this.options.radius)) {\n                throw new Error(\"Circle radius cannot be NaN\");\n            }\n            // @section\n            // @aka Circle options\n            // @option radius: Number; Radius of the circle, in meters.\n            this._mRadius = this.options.radius;\n        },\n        // @method setRadius(radius: Number): this\n        // Sets the radius of a circle. Units are in meters.\n        setRadius: function(radius) {\n            this._mRadius = radius;\n            return this.redraw();\n        },\n        // @method getRadius(): Number\n        // Returns the current radius of a circle. Units are in meters.\n        getRadius: function() {\n            return this._mRadius;\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the `LatLngBounds` of the path.\n        getBounds: function() {\n            var half = [\n                this._radius,\n                this._radiusY || this._radius\n            ];\n            return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n        },\n        setStyle: Path.prototype.setStyle,\n        _project: function() {\n            var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;\n            if (crs.distance === Earth.distance) {\n                var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([\n                    lat + latR,\n                    lng\n                ]), bottom = map.project([\n                    lat - latR,\n                    lng\n                ]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n                if (isNaN(lngR) || lngR === 0) {\n                    lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n                }\n                this._point = p.subtract(map.getPixelOrigin());\n                this._radius = isNaN(lngR) ? 0 : p.x - map.project([\n                    lat2,\n                    lng - lngR\n                ]).x;\n                this._radiusY = p.y - top.y;\n            } else {\n                var latlng2 = crs.unproject(crs.project(this._latlng).subtract([\n                    this._mRadius,\n                    0\n                ]));\n                this._point = map.latLngToLayerPoint(this._latlng);\n                this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n            }\n            this._updateBounds();\n        }\n    });\n    // @factory L.circle(latlng: LatLng, options?: Circle options)\n    // Instantiates a circle object given a geographical point, and an options object\n    // which contains the circle radius.\n    // @alternative\n    // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n    // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n    // Do not use in new applications or plugins.\n    function circle(latlng, options, legacyOptions) {\n        return new Circle(latlng, options, legacyOptions);\n    }\n    /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */ var Polyline = Path.extend({\n        // @section\n        // @aka Polyline options\n        options: {\n            // @option smoothFactor: Number = 1.0\n            // How much to simplify the polyline on each zoom level. More means\n            // better performance and smoother look, and less means more accurate representation.\n            smoothFactor: 1.0,\n            // @option noClip: Boolean = false\n            // Disable polyline clipping.\n            noClip: false\n        },\n        initialize: function(latlngs, options) {\n            setOptions(this, options);\n            this._setLatLngs(latlngs);\n        },\n        // @method getLatLngs(): LatLng[]\n        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n        getLatLngs: function() {\n            return this._latlngs;\n        },\n        // @method setLatLngs(latlngs: LatLng[]): this\n        // Replaces all the points in the polyline with the given array of geographical points.\n        setLatLngs: function(latlngs) {\n            this._setLatLngs(latlngs);\n            return this.redraw();\n        },\n        // @method isEmpty(): Boolean\n        // Returns `true` if the Polyline has no LatLngs.\n        isEmpty: function() {\n            return !this._latlngs.length;\n        },\n        // @method closestLayerPoint(p: Point): Point\n        // Returns the point closest to `p` on the Polyline.\n        closestLayerPoint: function(p) {\n            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;\n            for(var j = 0, jLen = this._parts.length; j < jLen; j++){\n                var points = this._parts[j];\n                for(var i = 1, len = points.length; i < len; i++){\n                    p1 = points[i - 1];\n                    p2 = points[i];\n                    var sqDist = closest(p, p1, p2, true);\n                    if (sqDist < minDistance) {\n                        minDistance = sqDist;\n                        minPoint = closest(p, p1, p2);\n                    }\n                }\n            }\n            if (minPoint) {\n                minPoint.distance = Math.sqrt(minDistance);\n            }\n            return minPoint;\n        },\n        // @method getCenter(): LatLng\n        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n        getCenter: function() {\n            // throws error when not yet added to map as this center calculation requires projected coordinates\n            if (!this._map) {\n                throw new Error(\"Must add layer to map before using getCenter()\");\n            }\n            return polylineCenter(this._defaultShape(), this._map.options.crs);\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the `LatLngBounds` of the path.\n        getBounds: function() {\n            return this._bounds;\n        },\n        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n        // Adds a given point to the polyline. By default, adds to the first ring of\n        // the polyline in case of a multi-polyline, but can be overridden by passing\n        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n        addLatLng: function(latlng, latlngs) {\n            latlngs = latlngs || this._defaultShape();\n            latlng = toLatLng(latlng);\n            latlngs.push(latlng);\n            this._bounds.extend(latlng);\n            return this.redraw();\n        },\n        _setLatLngs: function(latlngs) {\n            this._bounds = new LatLngBounds();\n            this._latlngs = this._convertLatLngs(latlngs);\n        },\n        _defaultShape: function() {\n            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n        },\n        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n        _convertLatLngs: function(latlngs) {\n            var result = [], flat = isFlat(latlngs);\n            for(var i = 0, len = latlngs.length; i < len; i++){\n                if (flat) {\n                    result[i] = toLatLng(latlngs[i]);\n                    this._bounds.extend(result[i]);\n                } else {\n                    result[i] = this._convertLatLngs(latlngs[i]);\n                }\n            }\n            return result;\n        },\n        _project: function() {\n            var pxBounds = new Bounds();\n            this._rings = [];\n            this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n            if (this._bounds.isValid() && pxBounds.isValid()) {\n                this._rawPxBounds = pxBounds;\n                this._updateBounds();\n            }\n        },\n        _updateBounds: function() {\n            var w = this._clickTolerance(), p = new Point(w, w);\n            if (!this._rawPxBounds) {\n                return;\n            }\n            this._pxBounds = new Bounds([\n                this._rawPxBounds.min.subtract(p),\n                this._rawPxBounds.max.add(p)\n            ]);\n        },\n        // recursively turns latlngs into a set of rings with projected coordinates\n        _projectLatlngs: function(latlngs, result, projectedBounds) {\n            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;\n            if (flat) {\n                ring = [];\n                for(i = 0; i < len; i++){\n                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n                    projectedBounds.extend(ring[i]);\n                }\n                result.push(ring);\n            } else {\n                for(i = 0; i < len; i++){\n                    this._projectLatlngs(latlngs[i], result, projectedBounds);\n                }\n            }\n        },\n        // clip polyline by renderer bounds so that we have less to render for performance\n        _clipPoints: function() {\n            var bounds = this._renderer._bounds;\n            this._parts = [];\n            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n                return;\n            }\n            if (this.options.noClip) {\n                this._parts = this._rings;\n                return;\n            }\n            var parts = this._parts, i, j, k, len, len2, segment, points;\n            for(i = 0, k = 0, len = this._rings.length; i < len; i++){\n                points = this._rings[i];\n                for(j = 0, len2 = points.length; j < len2 - 1; j++){\n                    segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n                    if (!segment) {\n                        continue;\n                    }\n                    parts[k] = parts[k] || [];\n                    parts[k].push(segment[0]);\n                    // if segment goes out of screen, or it's the last one, it's the end of the line part\n                    if (segment[1] !== points[j + 1] || j === len2 - 2) {\n                        parts[k].push(segment[1]);\n                        k++;\n                    }\n                }\n            }\n        },\n        // simplify each clipped part of the polyline for performance\n        _simplifyPoints: function() {\n            var parts = this._parts, tolerance = this.options.smoothFactor;\n            for(var i = 0, len = parts.length; i < len; i++){\n                parts[i] = simplify(parts[i], tolerance);\n            }\n        },\n        _update: function() {\n            if (!this._map) {\n                return;\n            }\n            this._clipPoints();\n            this._simplifyPoints();\n            this._updatePath();\n        },\n        _updatePath: function() {\n            this._renderer._updatePoly(this);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p, closed) {\n            var i, j, k, len, len2, part, w = this._clickTolerance();\n            if (!this._pxBounds || !this._pxBounds.contains(p)) {\n                return false;\n            }\n            // hit detection for polylines\n            for(i = 0, len = this._parts.length; i < len; i++){\n                part = this._parts[i];\n                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){\n                    if (!closed && j === 0) {\n                        continue;\n                    }\n                    if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n    // Instantiates a polyline object given an array of geographical points and\n    // optionally an options object. You can create a `Polyline` object with\n    // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n    // of geographic points.\n    function polyline(latlngs, options) {\n        return new Polyline(latlngs, options);\n    }\n    // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n    Polyline._flat = _flat;\n    /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */ var Polygon = Polyline.extend({\n        options: {\n            fill: true\n        },\n        isEmpty: function() {\n            return !this._latlngs.length || !this._latlngs[0].length;\n        },\n        // @method getCenter(): LatLng\n        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n        getCenter: function() {\n            // throws error when not yet added to map as this center calculation requires projected coordinates\n            if (!this._map) {\n                throw new Error(\"Must add layer to map before using getCenter()\");\n            }\n            return polygonCenter(this._defaultShape(), this._map.options.crs);\n        },\n        _convertLatLngs: function(latlngs) {\n            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;\n            // remove last point if it equals first one\n            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n                result.pop();\n            }\n            return result;\n        },\n        _setLatLngs: function(latlngs) {\n            Polyline.prototype._setLatLngs.call(this, latlngs);\n            if (isFlat(this._latlngs)) {\n                this._latlngs = [\n                    this._latlngs\n                ];\n            }\n        },\n        _defaultShape: function() {\n            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n        },\n        _clipPoints: function() {\n            // polygons need a different clipping algorithm so we redefine that\n            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);\n            // increase clip padding by stroke width to avoid stroke on clip edges\n            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n            this._parts = [];\n            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n                return;\n            }\n            if (this.options.noClip) {\n                this._parts = this._rings;\n                return;\n            }\n            for(var i = 0, len = this._rings.length, clipped; i < len; i++){\n                clipped = clipPolygon(this._rings[i], bounds, true);\n                if (clipped.length) {\n                    this._parts.push(clipped);\n                }\n            }\n        },\n        _updatePath: function() {\n            this._renderer._updatePoly(this, true);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p) {\n            var inside = false, part, p1, p2, i, j, k, len, len2;\n            if (!this._pxBounds || !this._pxBounds.contains(p)) {\n                return false;\n            }\n            // ray casting algorithm for detecting if point is in polygon\n            for(i = 0, len = this._parts.length; i < len; i++){\n                part = this._parts[i];\n                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){\n                    p1 = part[j];\n                    p2 = part[k];\n                    if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n                        inside = !inside;\n                    }\n                }\n            }\n            // also check if it's on polygon stroke\n            return inside || Polyline.prototype._containsPoint.call(this, p, true);\n        }\n    });\n    // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n    function polygon(latlngs, options) {\n        return new Polygon(latlngs, options);\n    }\n    /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */ var GeoJSON = FeatureGroup.extend({\n        /* @section\r\n  \t * @aka GeoJSON options\r\n  \t *\r\n  \t * @option pointToLayer: Function = *\r\n  \t * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n  \t * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n  \t * The default is to spawn a default `Marker`:\r\n  \t * ```js\r\n  \t * function(geoJsonPoint, latlng) {\r\n  \t * \treturn L.marker(latlng);\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option style: Function = *\r\n  \t * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n  \t * called internally when data is added.\r\n  \t * The default value is to not override any defaults:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn {}\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option onEachFeature: Function = *\r\n  \t * A `Function` that will be called once for each created `Feature`, after it has\r\n  \t * been created and styled. Useful for attaching events and popups to features.\r\n  \t * The default is to do nothing with the newly created layers:\r\n  \t * ```js\r\n  \t * function (feature, layer) {}\r\n  \t * ```\r\n  \t *\r\n  \t * @option filter: Function = *\r\n  \t * A `Function` that will be used to decide whether to include a feature or not.\r\n  \t * The default is to include all features:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn true;\r\n  \t * }\r\n  \t * ```\r\n  \t * Note: dynamically changing the `filter` option will have effect only on newly\r\n  \t * added data. It will _not_ re-evaluate already included features.\r\n  \t *\r\n  \t * @option coordsToLatLng: Function = *\r\n  \t * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n  \t * The default is the `coordsToLatLng` static method.\r\n  \t *\r\n  \t * @option markersInheritOptions: Boolean = false\r\n  \t * Whether default Markers for \"Point\" type Features inherit from group options.\r\n  \t */ initialize: function(geojson, options) {\n            setOptions(this, options);\n            this._layers = {};\n            if (geojson) {\n                this.addData(geojson);\n            }\n        },\n        // @method addData( <GeoJSON> data ): this\n        // Adds a GeoJSON object to the layer.\n        addData: function(geojson) {\n            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;\n            if (features) {\n                for(i = 0, len = features.length; i < len; i++){\n                    // only add this if geometry or geometries are set and not null\n                    feature = features[i];\n                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n                        this.addData(feature);\n                    }\n                }\n                return this;\n            }\n            var options = this.options;\n            if (options.filter && !options.filter(geojson)) {\n                return this;\n            }\n            var layer = geometryToLayer(geojson, options);\n            if (!layer) {\n                return this;\n            }\n            layer.feature = asFeature(geojson);\n            layer.defaultOptions = layer.options;\n            this.resetStyle(layer);\n            if (options.onEachFeature) {\n                options.onEachFeature(geojson, layer);\n            }\n            return this.addLayer(layer);\n        },\n        // @method resetStyle( <Path> layer? ): this\n        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n        // If `layer` is omitted, the style of all features in the current layer is reset.\n        resetStyle: function(layer) {\n            if (layer === undefined) {\n                return this.eachLayer(this.resetStyle, this);\n            }\n            // reset any custom styles\n            layer.options = extend({}, layer.defaultOptions);\n            this._setLayerStyle(layer, this.options.style);\n            return this;\n        },\n        // @method setStyle( <Function> style ): this\n        // Changes styles of GeoJSON vector layers with the given style function.\n        setStyle: function(style) {\n            return this.eachLayer(function(layer) {\n                this._setLayerStyle(layer, style);\n            }, this);\n        },\n        _setLayerStyle: function(layer, style) {\n            if (layer.setStyle) {\n                if (typeof style === \"function\") {\n                    style = style(layer.feature);\n                }\n                layer.setStyle(style);\n            }\n        }\n    });\n    // @section\n    // There are several static functions which can be called without instantiating L.GeoJSON:\n    // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n    // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n    // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n    // functions if provided as options.\n    function geometryToLayer(geojson, options) {\n        var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;\n        if (!coords && !geometry) {\n            return null;\n        }\n        switch(geometry.type){\n            case \"Point\":\n                latlng = _coordsToLatLng(coords);\n                return _pointToLayer(pointToLayer, geojson, latlng, options);\n            case \"MultiPoint\":\n                for(i = 0, len = coords.length; i < len; i++){\n                    latlng = _coordsToLatLng(coords[i]);\n                    layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n                }\n                return new FeatureGroup(layers);\n            case \"LineString\":\n            case \"MultiLineString\":\n                latlngs = coordsToLatLngs(coords, geometry.type === \"LineString\" ? 0 : 1, _coordsToLatLng);\n                return new Polyline(latlngs, options);\n            case \"Polygon\":\n            case \"MultiPolygon\":\n                latlngs = coordsToLatLngs(coords, geometry.type === \"Polygon\" ? 1 : 2, _coordsToLatLng);\n                return new Polygon(latlngs, options);\n            case \"GeometryCollection\":\n                for(i = 0, len = geometry.geometries.length; i < len; i++){\n                    var geoLayer = geometryToLayer({\n                        geometry: geometry.geometries[i],\n                        type: \"Feature\",\n                        properties: geojson.properties\n                    }, options);\n                    if (geoLayer) {\n                        layers.push(geoLayer);\n                    }\n                }\n                return new FeatureGroup(layers);\n            case \"FeatureCollection\":\n                for(i = 0, len = geometry.features.length; i < len; i++){\n                    var featureLayer = geometryToLayer(geometry.features[i], options);\n                    if (featureLayer) {\n                        layers.push(featureLayer);\n                    }\n                }\n                return new FeatureGroup(layers);\n            default:\n                throw new Error(\"Invalid GeoJSON object.\");\n        }\n    }\n    function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n    }\n    // @function coordsToLatLng(coords: Array): LatLng\n    // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n    // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n    function coordsToLatLng(coords) {\n        return new LatLng(coords[1], coords[0], coords[2]);\n    }\n    // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n    // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n    // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n    // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n        var latlngs = [];\n        for(var i = 0, len = coords.length, latlng; i < len; i++){\n            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n            latlngs.push(latlng);\n        }\n        return latlngs;\n    }\n    // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n    // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n    function latLngToCoords(latlng, precision) {\n        latlng = toLatLng(latlng);\n        return latlng.alt !== undefined ? [\n            formatNum(latlng.lng, precision),\n            formatNum(latlng.lat, precision),\n            formatNum(latlng.alt, precision)\n        ] : [\n            formatNum(latlng.lng, precision),\n            formatNum(latlng.lat, precision)\n        ];\n    }\n    // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n    // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n    // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n        var coords = [];\n        for(var i = 0, len = latlngs.length; i < len; i++){\n            // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n        }\n        if (!levelsDeep && closed && coords.length > 0) {\n            coords.push(coords[0].slice());\n        }\n        return coords;\n    }\n    function getFeature(layer, newGeometry) {\n        return layer.feature ? extend({}, layer.feature, {\n            geometry: newGeometry\n        }) : asFeature(newGeometry);\n    }\n    // @function asFeature(geojson: Object): Object\n    // Normalize GeoJSON geometries/features into GeoJSON features.\n    function asFeature(geojson) {\n        if (geojson.type === \"Feature\" || geojson.type === \"FeatureCollection\") {\n            return geojson;\n        }\n        return {\n            type: \"Feature\",\n            properties: {},\n            geometry: geojson\n        };\n    }\n    var PointToGeoJSON = {\n        toGeoJSON: function(precision) {\n            return getFeature(this, {\n                type: \"Point\",\n                coordinates: latLngToCoords(this.getLatLng(), precision)\n            });\n        }\n    };\n    // @namespace Marker\n    // @section Other methods\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n    Marker.include(PointToGeoJSON);\n    // @namespace CircleMarker\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n    Circle.include(PointToGeoJSON);\n    CircleMarker.include(PointToGeoJSON);\n    // @namespace Polyline\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n    Polyline.include({\n        toGeoJSON: function(precision) {\n            var multi = !isFlat(this._latlngs);\n            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n            return getFeature(this, {\n                type: (multi ? \"Multi\" : \"\") + \"LineString\",\n                coordinates: coords\n            });\n        }\n    });\n    // @namespace Polygon\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n    Polygon.include({\n        toGeoJSON: function(precision) {\n            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);\n            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n            if (!holes) {\n                coords = [\n                    coords\n                ];\n            }\n            return getFeature(this, {\n                type: (multi ? \"Multi\" : \"\") + \"Polygon\",\n                coordinates: coords\n            });\n        }\n    });\n    // @namespace LayerGroup\n    LayerGroup.include({\n        toMultiPoint: function(precision) {\n            var coords = [];\n            this.eachLayer(function(layer) {\n                coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n            });\n            return getFeature(this, {\n                type: \"MultiPoint\",\n                coordinates: coords\n            });\n        },\n        // @method toGeoJSON(precision?: Number|false): Object\n        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n        toGeoJSON: function(precision) {\n            var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n            if (type === \"MultiPoint\") {\n                return this.toMultiPoint(precision);\n            }\n            var isGeometryCollection = type === \"GeometryCollection\", jsons = [];\n            this.eachLayer(function(layer) {\n                if (layer.toGeoJSON) {\n                    var json = layer.toGeoJSON(precision);\n                    if (isGeometryCollection) {\n                        jsons.push(json.geometry);\n                    } else {\n                        var feature = asFeature(json);\n                        // Squash nested feature collections\n                        if (feature.type === \"FeatureCollection\") {\n                            jsons.push.apply(jsons, feature.features);\n                        } else {\n                            jsons.push(feature);\n                        }\n                    }\n                }\n            });\n            if (isGeometryCollection) {\n                return getFeature(this, {\n                    geometries: jsons,\n                    type: \"GeometryCollection\"\n                });\n            }\n            return {\n                type: \"FeatureCollection\",\n                features: jsons\n            };\n        }\n    });\n    // @namespace GeoJSON\n    // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n    // Creates a GeoJSON layer. Optionally accepts an object in\n    // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n    // (you can alternatively add it later with `addData` method) and an `options` object.\n    function geoJSON(geojson, options) {\n        return new GeoJSON(geojson, options);\n    }\n    // Backward compatibility.\n    var geoJson = geoJSON;\n    /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */ var ImageOverlay = Layer.extend({\n        // @section\n        // @aka ImageOverlay options\n        options: {\n            // @option opacity: Number = 1.0\n            // The opacity of the image overlay.\n            opacity: 1,\n            // @option alt: String = ''\n            // Text for the `alt` attribute of the image (useful for accessibility).\n            alt: \"\",\n            // @option interactive: Boolean = false\n            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n            interactive: false,\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the image.\n            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false,\n            // @option errorOverlayUrl: String = ''\n            // URL to the overlay image to show in place of the overlay that failed to load.\n            errorOverlayUrl: \"\",\n            // @option zIndex: Number = 1\n            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n            zIndex: 1,\n            // @option className: String = ''\n            // A custom class name to assign to the image. Empty by default.\n            className: \"\"\n        },\n        initialize: function(url, bounds, options) {\n            this._url = url;\n            this._bounds = toLatLngBounds(bounds);\n            setOptions(this, options);\n        },\n        onAdd: function() {\n            if (!this._image) {\n                this._initImage();\n                if (this.options.opacity < 1) {\n                    this._updateOpacity();\n                }\n            }\n            if (this.options.interactive) {\n                addClass(this._image, \"leaflet-interactive\");\n                this.addInteractiveTarget(this._image);\n            }\n            this.getPane().appendChild(this._image);\n            this._reset();\n        },\n        onRemove: function() {\n            remove(this._image);\n            if (this.options.interactive) {\n                this.removeInteractiveTarget(this._image);\n            }\n        },\n        // @method setOpacity(opacity: Number): this\n        // Sets the opacity of the overlay.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._image) {\n                this._updateOpacity();\n            }\n            return this;\n        },\n        setStyle: function(styleOpts) {\n            if (styleOpts.opacity) {\n                this.setOpacity(styleOpts.opacity);\n            }\n            return this;\n        },\n        // @method bringToFront(): this\n        // Brings the layer to the top of all overlays.\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._image);\n            }\n            return this;\n        },\n        // @method bringToBack(): this\n        // Brings the layer to the bottom of all overlays.\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._image);\n            }\n            return this;\n        },\n        // @method setUrl(url: String): this\n        // Changes the URL of the image.\n        setUrl: function(url) {\n            this._url = url;\n            if (this._image) {\n                this._image.src = url;\n            }\n            return this;\n        },\n        // @method setBounds(bounds: LatLngBounds): this\n        // Update the bounds that this ImageOverlay covers\n        setBounds: function(bounds) {\n            this._bounds = toLatLngBounds(bounds);\n            if (this._map) {\n                this._reset();\n            }\n            return this;\n        },\n        getEvents: function() {\n            var events = {\n                zoom: this._reset,\n                viewreset: this._reset\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @method setZIndex(value: Number): this\n        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n        setZIndex: function(value) {\n            this.options.zIndex = value;\n            this._updateZIndex();\n            return this;\n        },\n        // @method getBounds(): LatLngBounds\n        // Get the bounds that this ImageOverlay covers\n        getBounds: function() {\n            return this._bounds;\n        },\n        // @method getElement(): HTMLElement\n        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n        // used by this overlay.\n        getElement: function() {\n            return this._image;\n        },\n        _initImage: function() {\n            var wasElementSupplied = this._url.tagName === \"IMG\";\n            var img = this._image = wasElementSupplied ? this._url : create$1(\"img\");\n            addClass(img, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(img, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(img, this.options.className);\n            }\n            img.onselectstart = falseFn;\n            img.onmousemove = falseFn;\n            // @event load: Event\n            // Fired when the ImageOverlay layer has loaded its image\n            img.onload = bind(this.fire, this, \"load\");\n            img.onerror = bind(this._overlayOnError, this, \"error\");\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                img.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            if (this.options.zIndex) {\n                this._updateZIndex();\n            }\n            if (wasElementSupplied) {\n                this._url = img.src;\n                return;\n            }\n            img.src = this._url;\n            img.alt = this.options.alt;\n        },\n        _animateZoom: function(e) {\n            var scale = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n            setTransform(this._image, offset, scale);\n        },\n        _reset: function() {\n            var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();\n            setPosition(image, bounds.min);\n            image.style.width = size.x + \"px\";\n            image.style.height = size.y + \"px\";\n        },\n        _updateOpacity: function() {\n            setOpacity(this._image, this.options.opacity);\n        },\n        _updateZIndex: function() {\n            if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n                this._image.style.zIndex = this.options.zIndex;\n            }\n        },\n        _overlayOnError: function() {\n            // @event error: Event\n            // Fired when the ImageOverlay layer fails to load its image\n            this.fire(\"error\");\n            var errorUrl = this.options.errorOverlayUrl;\n            if (errorUrl && this._url !== errorUrl) {\n                this._url = errorUrl;\n                this._image.src = errorUrl;\n            }\n        },\n        // @method getCenter(): LatLng\n        // Returns the center of the ImageOverlay.\n        getCenter: function() {\n            return this._bounds.getCenter();\n        }\n    });\n    // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n    // Instantiates an image overlay object given the URL of the image and the\n    // geographical bounds it is tied to.\n    var imageOverlay = function(url, bounds, options) {\n        return new ImageOverlay(url, bounds, options);\n    };\n    /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */ var VideoOverlay = ImageOverlay.extend({\n        // @section\n        // @aka VideoOverlay options\n        options: {\n            // @option autoplay: Boolean = true\n            // Whether the video starts playing automatically when loaded.\n            // On some browsers autoplay will only work with `muted: true`\n            autoplay: true,\n            // @option loop: Boolean = true\n            // Whether the video will loop back to the beginning when played.\n            loop: true,\n            // @option keepAspectRatio: Boolean = true\n            // Whether the video will save aspect ratio after the projection.\n            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n            keepAspectRatio: true,\n            // @option muted: Boolean = false\n            // Whether the video starts on mute when loaded.\n            muted: false,\n            // @option playsInline: Boolean = true\n            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n            playsInline: true\n        },\n        _initImage: function() {\n            var wasElementSupplied = this._url.tagName === \"VIDEO\";\n            var vid = this._image = wasElementSupplied ? this._url : create$1(\"video\");\n            addClass(vid, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(vid, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(vid, this.options.className);\n            }\n            vid.onselectstart = falseFn;\n            vid.onmousemove = falseFn;\n            // @event load: Event\n            // Fired when the video has finished loading the first frame\n            vid.onloadeddata = bind(this.fire, this, \"load\");\n            if (wasElementSupplied) {\n                var sourceElements = vid.getElementsByTagName(\"source\");\n                var sources = [];\n                for(var j = 0; j < sourceElements.length; j++){\n                    sources.push(sourceElements[j].src);\n                }\n                this._url = sourceElements.length > 0 ? sources : [\n                    vid.src\n                ];\n                return;\n            }\n            if (!isArray(this._url)) {\n                this._url = [\n                    this._url\n                ];\n            }\n            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, \"objectFit\")) {\n                vid.style[\"objectFit\"] = \"fill\";\n            }\n            vid.autoplay = !!this.options.autoplay;\n            vid.loop = !!this.options.loop;\n            vid.muted = !!this.options.muted;\n            vid.playsInline = !!this.options.playsInline;\n            for(var i = 0; i < this._url.length; i++){\n                var source = create$1(\"source\");\n                source.src = this._url[i];\n                vid.appendChild(source);\n            }\n        }\n    });\n    // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n    // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n    // geographical bounds it is tied to.\n    function videoOverlay(video, bounds, options) {\n        return new VideoOverlay(video, bounds, options);\n    }\n    /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */ var SVGOverlay = ImageOverlay.extend({\n        _initImage: function() {\n            var el = this._image = this._url;\n            addClass(el, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(el, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(el, this.options.className);\n            }\n            el.onselectstart = falseFn;\n            el.onmousemove = falseFn;\n        }\n    });\n    // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n    // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n    // A viewBox attribute is required on the SVG element to zoom in and out properly.\n    function svgOverlay(el, bounds, options) {\n        return new SVGOverlay(el, bounds, options);\n    }\n    /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */ // @namespace DivOverlay\n    var DivOverlay = Layer.extend({\n        // @section\n        // @aka DivOverlay options\n        options: {\n            // @option interactive: Boolean = false\n            // If true, the popup/tooltip will listen to the mouse events.\n            interactive: false,\n            // @option offset: Point = Point(0, 0)\n            // The offset of the overlay position.\n            offset: [\n                0,\n                0\n            ],\n            // @option className: String = ''\n            // A custom CSS class name to assign to the overlay.\n            className: \"\",\n            // @option pane: String = undefined\n            // `Map pane` where the overlay will be added.\n            pane: undefined,\n            // @option content: String|HTMLElement|Function = ''\n            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n            content: \"\"\n        },\n        initialize: function(options, source) {\n            if (options && (options instanceof LatLng || isArray(options))) {\n                this._latlng = toLatLng(options);\n                setOptions(this, source);\n            } else {\n                setOptions(this, options);\n                this._source = source;\n            }\n            if (this.options.content) {\n                this._content = this.options.content;\n            }\n        },\n        // @method openOn(map: Map): this\n        // Adds the overlay to the map.\n        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n        openOn: function(map) {\n            map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n            if (!map.hasLayer(this)) {\n                map.addLayer(this);\n            }\n            return this;\n        },\n        // @method close(): this\n        // Closes the overlay.\n        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n        // and `layer.closePopup()`/`.closeTooltip()`.\n        close: function() {\n            if (this._map) {\n                this._map.removeLayer(this);\n            }\n            return this;\n        },\n        // @method toggle(layer?: Layer): this\n        // Opens or closes the overlay bound to layer depending on its current state.\n        // Argument may be omitted only for overlay bound to layer.\n        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n        toggle: function(layer) {\n            if (this._map) {\n                this.close();\n            } else {\n                if (arguments.length) {\n                    this._source = layer;\n                } else {\n                    layer = this._source;\n                }\n                this._prepareOpen();\n                // open the overlay on the map\n                this.openOn(layer._map);\n            }\n            return this;\n        },\n        onAdd: function(map) {\n            this._zoomAnimated = map._zoomAnimated;\n            if (!this._container) {\n                this._initLayout();\n            }\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 0);\n            }\n            clearTimeout(this._removeTimeout);\n            this.getPane().appendChild(this._container);\n            this.update();\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 1);\n            }\n            this.bringToFront();\n            if (this.options.interactive) {\n                addClass(this._container, \"leaflet-interactive\");\n                this.addInteractiveTarget(this._container);\n            }\n        },\n        onRemove: function(map) {\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 0);\n                this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n            } else {\n                remove(this._container);\n            }\n            if (this.options.interactive) {\n                removeClass(this._container, \"leaflet-interactive\");\n                this.removeInteractiveTarget(this._container);\n            }\n        },\n        // @namespace DivOverlay\n        // @method getLatLng: LatLng\n        // Returns the geographical point of the overlay.\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setLatLng(latlng: LatLng): this\n        // Sets the geographical point where the overlay will open.\n        setLatLng: function(latlng) {\n            this._latlng = toLatLng(latlng);\n            if (this._map) {\n                this._updatePosition();\n                this._adjustPan();\n            }\n            return this;\n        },\n        // @method getContent: String|HTMLElement\n        // Returns the content of the overlay.\n        getContent: function() {\n            return this._content;\n        },\n        // @method setContent(htmlContent: String|HTMLElement|Function): this\n        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n        // The function should return a `String` or `HTMLElement` to be used in the overlay.\n        setContent: function(content) {\n            this._content = content;\n            this.update();\n            return this;\n        },\n        // @method getElement: String|HTMLElement\n        // Returns the HTML container of the overlay.\n        getElement: function() {\n            return this._container;\n        },\n        // @method update: null\n        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n        update: function() {\n            if (!this._map) {\n                return;\n            }\n            this._container.style.visibility = \"hidden\";\n            this._updateContent();\n            this._updateLayout();\n            this._updatePosition();\n            this._container.style.visibility = \"\";\n            this._adjustPan();\n        },\n        getEvents: function() {\n            var events = {\n                zoom: this._updatePosition,\n                viewreset: this._updatePosition\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @method isOpen: Boolean\n        // Returns `true` when the overlay is visible on the map.\n        isOpen: function() {\n            return !!this._map && this._map.hasLayer(this);\n        },\n        // @method bringToFront: this\n        // Brings this overlay in front of other overlays (in the same map pane).\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._container);\n            }\n            return this;\n        },\n        // @method bringToBack: this\n        // Brings this overlay to the back of other overlays (in the same map pane).\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._container);\n            }\n            return this;\n        },\n        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n        _prepareOpen: function(latlng) {\n            var source = this._source;\n            if (!source._map) {\n                return false;\n            }\n            if (source instanceof FeatureGroup) {\n                source = null;\n                var layers = this._source._layers;\n                for(var id in layers){\n                    if (layers[id]._map) {\n                        source = layers[id];\n                        break;\n                    }\n                }\n                if (!source) {\n                    return false;\n                } // Unable to get source layer.\n                // set overlay source to this layer\n                this._source = source;\n            }\n            if (!latlng) {\n                if (source.getCenter) {\n                    latlng = source.getCenter();\n                } else if (source.getLatLng) {\n                    latlng = source.getLatLng();\n                } else if (source.getBounds) {\n                    latlng = source.getBounds().getCenter();\n                } else {\n                    throw new Error(\"Unable to get source layer LatLng.\");\n                }\n            }\n            this.setLatLng(latlng);\n            if (this._map) {\n                // update the overlay (content, layout, etc...)\n                this.update();\n            }\n            return true;\n        },\n        _updateContent: function() {\n            if (!this._content) {\n                return;\n            }\n            var node = this._contentNode;\n            var content = typeof this._content === \"function\" ? this._content(this._source || this) : this._content;\n            if (typeof content === \"string\") {\n                node.innerHTML = content;\n            } else {\n                while(node.hasChildNodes()){\n                    node.removeChild(node.firstChild);\n                }\n                node.appendChild(content);\n            }\n            // @namespace DivOverlay\n            // @section DivOverlay events\n            // @event contentupdate: Event\n            // Fired when the content of the overlay is updated\n            this.fire(\"contentupdate\");\n        },\n        _updatePosition: function() {\n            if (!this._map) {\n                return;\n            }\n            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();\n            if (this._zoomAnimated) {\n                setPosition(this._container, pos.add(anchor));\n            } else {\n                offset = offset.add(pos).add(anchor);\n            }\n            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n            // bottom position the overlay in case the height of the overlay changes (images loading etc)\n            this._container.style.bottom = bottom + \"px\";\n            this._container.style.left = left + \"px\";\n        },\n        _getAnchor: function() {\n            return [\n                0,\n                0\n            ];\n        }\n    });\n    Map.include({\n        _initOverlay: function(OverlayClass, content, latlng, options) {\n            var overlay = content;\n            if (!(overlay instanceof OverlayClass)) {\n                overlay = new OverlayClass(options).setContent(content);\n            }\n            if (latlng) {\n                overlay.setLatLng(latlng);\n            }\n            return overlay;\n        }\n    });\n    Layer.include({\n        _initOverlay: function(OverlayClass, old, content, options) {\n            var overlay = content;\n            if (overlay instanceof OverlayClass) {\n                setOptions(overlay, options);\n                overlay._source = this;\n            } else {\n                overlay = old && !options ? old : new OverlayClass(options, this);\n                overlay.setContent(content);\n            }\n            return overlay;\n        }\n    });\n    /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */ // @namespace Popup\n    var Popup = DivOverlay.extend({\n        // @section\n        // @aka Popup options\n        options: {\n            // @option pane: String = 'popupPane'\n            // `Map pane` where the popup will be added.\n            pane: \"popupPane\",\n            // @option offset: Point = Point(0, 7)\n            // The offset of the popup position.\n            offset: [\n                0,\n                7\n            ],\n            // @option maxWidth: Number = 300\n            // Max width of the popup, in pixels.\n            maxWidth: 300,\n            // @option minWidth: Number = 50\n            // Min width of the popup, in pixels.\n            minWidth: 50,\n            // @option maxHeight: Number = null\n            // If set, creates a scrollable container of the given height\n            // inside a popup if its content exceeds it.\n            // The scrollable container can be styled using the\n            // `leaflet-popup-scrolled` CSS class selector.\n            maxHeight: null,\n            // @option autoPan: Boolean = true\n            // Set it to `false` if you don't want the map to do panning animation\n            // to fit the opened popup.\n            autoPan: true,\n            // @option autoPanPaddingTopLeft: Point = null\n            // The margin between the popup and the top left corner of the map\n            // view after autopanning was performed.\n            autoPanPaddingTopLeft: null,\n            // @option autoPanPaddingBottomRight: Point = null\n            // The margin between the popup and the bottom right corner of the map\n            // view after autopanning was performed.\n            autoPanPaddingBottomRight: null,\n            // @option autoPanPadding: Point = Point(5, 5)\n            // Equivalent of setting both top left and bottom right autopan padding to the same value.\n            autoPanPadding: [\n                5,\n                5\n            ],\n            // @option keepInView: Boolean = false\n            // Set it to `true` if you want to prevent users from panning the popup\n            // off of the screen while it is open.\n            keepInView: false,\n            // @option closeButton: Boolean = true\n            // Controls the presence of a close button in the popup.\n            closeButton: true,\n            // @option autoClose: Boolean = true\n            // Set it to `false` if you want to override the default behavior of\n            // the popup closing when another popup is opened.\n            autoClose: true,\n            // @option closeOnEscapeKey: Boolean = true\n            // Set it to `false` if you want to override the default behavior of\n            // the ESC key for closing of the popup.\n            closeOnEscapeKey: true,\n            // @option closeOnClick: Boolean = *\n            // Set it if you want to override the default behavior of the popup closing when user clicks\n            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n            // @option className: String = ''\n            // A custom CSS class name to assign to the popup.\n            className: \"\"\n        },\n        // @namespace Popup\n        // @method openOn(map: Map): this\n        // Alternative to `map.openPopup(popup)`.\n        // Adds the popup to the map and closes the previous one.\n        openOn: function(map) {\n            map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n            if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n                map.removeLayer(map._popup);\n            }\n            map._popup = this;\n            return DivOverlay.prototype.openOn.call(this, map);\n        },\n        onAdd: function(map) {\n            DivOverlay.prototype.onAdd.call(this, map);\n            // @namespace Map\n            // @section Popup events\n            // @event popupopen: PopupEvent\n            // Fired when a popup is opened in the map\n            map.fire(\"popupopen\", {\n                popup: this\n            });\n            if (this._source) {\n                // @namespace Layer\n                // @section Popup events\n                // @event popupopen: PopupEvent\n                // Fired when a popup bound to this layer is opened\n                this._source.fire(\"popupopen\", {\n                    popup: this\n                }, true);\n                // For non-path layers, we toggle the popup when clicking\n                // again the layer, so prevent the map to reopen it.\n                if (!(this._source instanceof Path)) {\n                    this._source.on(\"preclick\", stopPropagation);\n                }\n            }\n        },\n        onRemove: function(map) {\n            DivOverlay.prototype.onRemove.call(this, map);\n            // @namespace Map\n            // @section Popup events\n            // @event popupclose: PopupEvent\n            // Fired when a popup in the map is closed\n            map.fire(\"popupclose\", {\n                popup: this\n            });\n            if (this._source) {\n                // @namespace Layer\n                // @section Popup events\n                // @event popupclose: PopupEvent\n                // Fired when a popup bound to this layer is closed\n                this._source.fire(\"popupclose\", {\n                    popup: this\n                }, true);\n                if (!(this._source instanceof Path)) {\n                    this._source.off(\"preclick\", stopPropagation);\n                }\n            }\n        },\n        getEvents: function() {\n            var events = DivOverlay.prototype.getEvents.call(this);\n            if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n                events.preclick = this.close;\n            }\n            if (this.options.keepInView) {\n                events.moveend = this._adjustPan;\n            }\n            return events;\n        },\n        _initLayout: function() {\n            var prefix = \"leaflet-popup\", container = this._container = create$1(\"div\", prefix + \" \" + (this.options.className || \"\") + \" leaflet-zoom-animated\");\n            var wrapper = this._wrapper = create$1(\"div\", prefix + \"-content-wrapper\", container);\n            this._contentNode = create$1(\"div\", prefix + \"-content\", wrapper);\n            disableClickPropagation(container);\n            disableScrollPropagation(this._contentNode);\n            on(container, \"contextmenu\", stopPropagation);\n            this._tipContainer = create$1(\"div\", prefix + \"-tip-container\", container);\n            this._tip = create$1(\"div\", prefix + \"-tip\", this._tipContainer);\n            if (this.options.closeButton) {\n                var closeButton = this._closeButton = create$1(\"a\", prefix + \"-close-button\", container);\n                closeButton.setAttribute(\"role\", \"button\"); // overrides the implicit role=link of <a> elements #7399\n                closeButton.setAttribute(\"aria-label\", \"Close popup\");\n                closeButton.href = \"#close\";\n                closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n                on(closeButton, \"click\", function(ev) {\n                    preventDefault(ev);\n                    this.close();\n                }, this);\n            }\n        },\n        _updateLayout: function() {\n            var container = this._contentNode, style = container.style;\n            style.width = \"\";\n            style.whiteSpace = \"nowrap\";\n            var width = container.offsetWidth;\n            width = Math.min(width, this.options.maxWidth);\n            width = Math.max(width, this.options.minWidth);\n            style.width = width + 1 + \"px\";\n            style.whiteSpace = \"\";\n            style.height = \"\";\n            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = \"leaflet-popup-scrolled\";\n            if (maxHeight && height > maxHeight) {\n                style.height = maxHeight + \"px\";\n                addClass(container, scrolledClass);\n            } else {\n                removeClass(container, scrolledClass);\n            }\n            this._containerWidth = this._container.offsetWidth;\n        },\n        _animateZoom: function(e) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();\n            setPosition(this._container, pos.add(anchor));\n        },\n        _adjustPan: function() {\n            if (!this.options.autoPan) {\n                return;\n            }\n            if (this._map._panAnim) {\n                this._map._panAnim.stop();\n            }\n            // We can endlessly recurse if keepInView is set and the view resets.\n            // Let's guard against that by exiting early if we're responding to our own autopan.\n            if (this._autopanning) {\n                this._autopanning = false;\n                return;\n            }\n            var map = this._map, marginBottom = parseInt(getStyle(this._container, \"marginBottom\"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n            layerPos._add(getPosition(this._container));\n            var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;\n            if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n                dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n            }\n            if (containerPos.x - dx - paddingTL.x < 0) {\n                dx = containerPos.x - paddingTL.x;\n            }\n            if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n                dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n            }\n            if (containerPos.y - dy - paddingTL.y < 0) {\n                dy = containerPos.y - paddingTL.y;\n            }\n            // @namespace Map\n            // @section Popup events\n            // @event autopanstart: Event\n            // Fired when the map starts autopanning when opening a popup.\n            if (dx || dy) {\n                // Track that we're autopanning, as this function will be re-ran on moveend\n                if (this.options.keepInView) {\n                    this._autopanning = true;\n                }\n                map.fire(\"autopanstart\").panBy([\n                    dx,\n                    dy\n                ]);\n            }\n        },\n        _getAnchor: function() {\n            // Where should we anchor the popup on the source layer?\n            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [\n                0,\n                0\n            ]);\n        }\n    });\n    // @namespace Popup\n    // @factory L.popup(options?: Popup options, source?: Layer)\n    // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n    // @alternative\n    // @factory L.popup(latlng: LatLng, options?: Popup options)\n    // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n    var popup = function(options, source) {\n        return new Popup(options, source);\n    };\n    /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */ Map.mergeOptions({\n        closePopupOnClick: true\n    });\n    // @namespace Map\n    // @section Methods for Layers and Controls\n    Map.include({\n        // @method openPopup(popup: Popup): this\n        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n        // @alternative\n        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n        // Creates a popup with the specified content and options and opens it in the given point on a map.\n        openPopup: function(popup, latlng, options) {\n            this._initOverlay(Popup, popup, latlng, options).openOn(this);\n            return this;\n        },\n        // @method closePopup(popup?: Popup): this\n        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n        closePopup: function(popup) {\n            popup = arguments.length ? popup : this._popup;\n            if (popup) {\n                popup.close();\n            }\n            return this;\n        }\n    });\n    /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */ // @section Popup methods\n    Layer.include({\n        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n        // Binds a popup to the layer with the passed `content` and sets up the\n        // necessary event listeners. If a `Function` is passed it will receive\n        // the layer as the first argument and should return a `String` or `HTMLElement`.\n        bindPopup: function(content, options) {\n            this._popup = this._initOverlay(Popup, this._popup, content, options);\n            if (!this._popupHandlersAdded) {\n                this.on({\n                    click: this._openPopup,\n                    keypress: this._onKeyPress,\n                    remove: this.closePopup,\n                    move: this._movePopup\n                });\n                this._popupHandlersAdded = true;\n            }\n            return this;\n        },\n        // @method unbindPopup(): this\n        // Removes the popup previously bound with `bindPopup`.\n        unbindPopup: function() {\n            if (this._popup) {\n                this.off({\n                    click: this._openPopup,\n                    keypress: this._onKeyPress,\n                    remove: this.closePopup,\n                    move: this._movePopup\n                });\n                this._popupHandlersAdded = false;\n                this._popup = null;\n            }\n            return this;\n        },\n        // @method openPopup(latlng?: LatLng): this\n        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n        openPopup: function(latlng) {\n            if (this._popup) {\n                if (!(this instanceof FeatureGroup)) {\n                    this._popup._source = this;\n                }\n                if (this._popup._prepareOpen(latlng || this._latlng)) {\n                    // open the popup on the map\n                    this._popup.openOn(this._map);\n                }\n            }\n            return this;\n        },\n        // @method closePopup(): this\n        // Closes the popup bound to this layer if it is open.\n        closePopup: function() {\n            if (this._popup) {\n                this._popup.close();\n            }\n            return this;\n        },\n        // @method togglePopup(): this\n        // Opens or closes the popup bound to this layer depending on its current state.\n        togglePopup: function() {\n            if (this._popup) {\n                this._popup.toggle(this);\n            }\n            return this;\n        },\n        // @method isPopupOpen(): boolean\n        // Returns `true` if the popup bound to this layer is currently open.\n        isPopupOpen: function() {\n            return this._popup ? this._popup.isOpen() : false;\n        },\n        // @method setPopupContent(content: String|HTMLElement|Popup): this\n        // Sets the content of the popup bound to this layer.\n        setPopupContent: function(content) {\n            if (this._popup) {\n                this._popup.setContent(content);\n            }\n            return this;\n        },\n        // @method getPopup(): Popup\n        // Returns the popup bound to this layer.\n        getPopup: function() {\n            return this._popup;\n        },\n        _openPopup: function(e) {\n            if (!this._popup || !this._map) {\n                return;\n            }\n            // prevent map click\n            stop(e);\n            var target = e.layer || e.target;\n            if (this._popup._source === target && !(target instanceof Path)) {\n                // treat it like a marker and figure out\n                // if we should toggle it open/closed\n                if (this._map.hasLayer(this._popup)) {\n                    this.closePopup();\n                } else {\n                    this.openPopup(e.latlng);\n                }\n                return;\n            }\n            this._popup._source = target;\n            this.openPopup(e.latlng);\n        },\n        _movePopup: function(e) {\n            this._popup.setLatLng(e.latlng);\n        },\n        _onKeyPress: function(e) {\n            if (e.originalEvent.keyCode === 13) {\n                this._openPopup(e);\n            }\n        }\n    });\n    /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */ // @namespace Tooltip\n    var Tooltip = DivOverlay.extend({\n        // @section\n        // @aka Tooltip options\n        options: {\n            // @option pane: String = 'tooltipPane'\n            // `Map pane` where the tooltip will be added.\n            pane: \"tooltipPane\",\n            // @option offset: Point = Point(0, 0)\n            // Optional offset of the tooltip position.\n            offset: [\n                0,\n                0\n            ],\n            // @option direction: String = 'auto'\n            // Direction where to open the tooltip. Possible values are: `right`, `left`,\n            // `top`, `bottom`, `center`, `auto`.\n            // `auto` will dynamically switch between `right` and `left` according to the tooltip\n            // position on the map.\n            direction: \"auto\",\n            // @option permanent: Boolean = false\n            // Whether to open the tooltip permanently or only on mouseover.\n            permanent: false,\n            // @option sticky: Boolean = false\n            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n            sticky: false,\n            // @option opacity: Number = 0.9\n            // Tooltip container opacity.\n            opacity: 0.9\n        },\n        onAdd: function(map) {\n            DivOverlay.prototype.onAdd.call(this, map);\n            this.setOpacity(this.options.opacity);\n            // @namespace Map\n            // @section Tooltip events\n            // @event tooltipopen: TooltipEvent\n            // Fired when a tooltip is opened in the map.\n            map.fire(\"tooltipopen\", {\n                tooltip: this\n            });\n            if (this._source) {\n                this.addEventParent(this._source);\n                // @namespace Layer\n                // @section Tooltip events\n                // @event tooltipopen: TooltipEvent\n                // Fired when a tooltip bound to this layer is opened.\n                this._source.fire(\"tooltipopen\", {\n                    tooltip: this\n                }, true);\n            }\n        },\n        onRemove: function(map) {\n            DivOverlay.prototype.onRemove.call(this, map);\n            // @namespace Map\n            // @section Tooltip events\n            // @event tooltipclose: TooltipEvent\n            // Fired when a tooltip in the map is closed.\n            map.fire(\"tooltipclose\", {\n                tooltip: this\n            });\n            if (this._source) {\n                this.removeEventParent(this._source);\n                // @namespace Layer\n                // @section Tooltip events\n                // @event tooltipclose: TooltipEvent\n                // Fired when a tooltip bound to this layer is closed.\n                this._source.fire(\"tooltipclose\", {\n                    tooltip: this\n                }, true);\n            }\n        },\n        getEvents: function() {\n            var events = DivOverlay.prototype.getEvents.call(this);\n            if (!this.options.permanent) {\n                events.preclick = this.close;\n            }\n            return events;\n        },\n        _initLayout: function() {\n            var prefix = \"leaflet-tooltip\", className = prefix + \" \" + (this.options.className || \"\") + \" leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\");\n            this._contentNode = this._container = create$1(\"div\", className);\n            this._container.setAttribute(\"role\", \"tooltip\");\n            this._container.setAttribute(\"id\", \"leaflet-tooltip-\" + stamp(this));\n        },\n        _updateLayout: function() {},\n        _adjustPan: function() {},\n        _setPosition: function(pos) {\n            var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();\n            if (direction === \"top\") {\n                subX = tooltipWidth / 2;\n                subY = tooltipHeight;\n            } else if (direction === \"bottom\") {\n                subX = tooltipWidth / 2;\n                subY = 0;\n            } else if (direction === \"center\") {\n                subX = tooltipWidth / 2;\n                subY = tooltipHeight / 2;\n            } else if (direction === \"right\") {\n                subX = 0;\n                subY = tooltipHeight / 2;\n            } else if (direction === \"left\") {\n                subX = tooltipWidth;\n                subY = tooltipHeight / 2;\n            } else if (tooltipPoint.x < centerPoint.x) {\n                direction = \"right\";\n                subX = 0;\n                subY = tooltipHeight / 2;\n            } else {\n                direction = \"left\";\n                subX = tooltipWidth + (offset.x + anchor.x) * 2;\n                subY = tooltipHeight / 2;\n            }\n            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n            removeClass(container, \"leaflet-tooltip-right\");\n            removeClass(container, \"leaflet-tooltip-left\");\n            removeClass(container, \"leaflet-tooltip-top\");\n            removeClass(container, \"leaflet-tooltip-bottom\");\n            addClass(container, \"leaflet-tooltip-\" + direction);\n            setPosition(container, pos);\n        },\n        _updatePosition: function() {\n            var pos = this._map.latLngToLayerPoint(this._latlng);\n            this._setPosition(pos);\n        },\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._container) {\n                setOpacity(this._container, opacity);\n            }\n        },\n        _animateZoom: function(e) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n            this._setPosition(pos);\n        },\n        _getAnchor: function() {\n            // Where should we anchor the tooltip on the source layer?\n            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [\n                0,\n                0\n            ]);\n        }\n    });\n    // @namespace Tooltip\n    // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n    // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n    // @alternative\n    // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n    // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n    var tooltip = function(options, source) {\n        return new Tooltip(options, source);\n    };\n    // @namespace Map\n    // @section Methods for Layers and Controls\n    Map.include({\n        // @method openTooltip(tooltip: Tooltip): this\n        // Opens the specified tooltip.\n        // @alternative\n        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n        // Creates a tooltip with the specified content and options and open it.\n        openTooltip: function(tooltip, latlng, options) {\n            this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n            return this;\n        },\n        // @method closeTooltip(tooltip: Tooltip): this\n        // Closes the tooltip given as parameter.\n        closeTooltip: function(tooltip) {\n            tooltip.close();\n            return this;\n        }\n    });\n    /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */ // @section Tooltip methods\n    Layer.include({\n        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n        // Binds a tooltip to the layer with the passed `content` and sets up the\n        // necessary event listeners. If a `Function` is passed it will receive\n        // the layer as the first argument and should return a `String` or `HTMLElement`.\n        bindTooltip: function(content, options) {\n            if (this._tooltip && this.isTooltipOpen()) {\n                this.unbindTooltip();\n            }\n            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n            this._initTooltipInteractions();\n            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n                this.openTooltip();\n            }\n            return this;\n        },\n        // @method unbindTooltip(): this\n        // Removes the tooltip previously bound with `bindTooltip`.\n        unbindTooltip: function() {\n            if (this._tooltip) {\n                this._initTooltipInteractions(true);\n                this.closeTooltip();\n                this._tooltip = null;\n            }\n            return this;\n        },\n        _initTooltipInteractions: function(remove) {\n            if (!remove && this._tooltipHandlersAdded) {\n                return;\n            }\n            var onOff = remove ? \"off\" : \"on\", events = {\n                remove: this.closeTooltip,\n                move: this._moveTooltip\n            };\n            if (!this._tooltip.options.permanent) {\n                events.mouseover = this._openTooltip;\n                events.mouseout = this.closeTooltip;\n                events.click = this._openTooltip;\n                if (this._map) {\n                    this._addFocusListeners();\n                } else {\n                    events.add = this._addFocusListeners;\n                }\n            } else {\n                events.add = this._openTooltip;\n            }\n            if (this._tooltip.options.sticky) {\n                events.mousemove = this._moveTooltip;\n            }\n            this[onOff](events);\n            this._tooltipHandlersAdded = !remove;\n        },\n        // @method openTooltip(latlng?: LatLng): this\n        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n        openTooltip: function(latlng) {\n            if (this._tooltip) {\n                if (!(this instanceof FeatureGroup)) {\n                    this._tooltip._source = this;\n                }\n                if (this._tooltip._prepareOpen(latlng)) {\n                    // open the tooltip on the map\n                    this._tooltip.openOn(this._map);\n                    if (this.getElement) {\n                        this._setAriaDescribedByOnLayer(this);\n                    } else if (this.eachLayer) {\n                        this.eachLayer(this._setAriaDescribedByOnLayer, this);\n                    }\n                }\n            }\n            return this;\n        },\n        // @method closeTooltip(): this\n        // Closes the tooltip bound to this layer if it is open.\n        closeTooltip: function() {\n            if (this._tooltip) {\n                return this._tooltip.close();\n            }\n        },\n        // @method toggleTooltip(): this\n        // Opens or closes the tooltip bound to this layer depending on its current state.\n        toggleTooltip: function() {\n            if (this._tooltip) {\n                this._tooltip.toggle(this);\n            }\n            return this;\n        },\n        // @method isTooltipOpen(): boolean\n        // Returns `true` if the tooltip bound to this layer is currently open.\n        isTooltipOpen: function() {\n            return this._tooltip.isOpen();\n        },\n        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n        // Sets the content of the tooltip bound to this layer.\n        setTooltipContent: function(content) {\n            if (this._tooltip) {\n                this._tooltip.setContent(content);\n            }\n            return this;\n        },\n        // @method getTooltip(): Tooltip\n        // Returns the tooltip bound to this layer.\n        getTooltip: function() {\n            return this._tooltip;\n        },\n        _addFocusListeners: function() {\n            if (this.getElement) {\n                this._addFocusListenersOnLayer(this);\n            } else if (this.eachLayer) {\n                this.eachLayer(this._addFocusListenersOnLayer, this);\n            }\n        },\n        _addFocusListenersOnLayer: function(layer) {\n            var el = typeof layer.getElement === \"function\" && layer.getElement();\n            if (el) {\n                on(el, \"focus\", function() {\n                    this._tooltip._source = layer;\n                    this.openTooltip();\n                }, this);\n                on(el, \"blur\", this.closeTooltip, this);\n            }\n        },\n        _setAriaDescribedByOnLayer: function(layer) {\n            var el = typeof layer.getElement === \"function\" && layer.getElement();\n            if (el) {\n                el.setAttribute(\"aria-describedby\", this._tooltip._container.id);\n            }\n        },\n        _openTooltip: function(e) {\n            if (!this._tooltip || !this._map) {\n                return;\n            }\n            // If the map is moving, we will show the tooltip after it's done.\n            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n                this._openOnceFlag = true;\n                var that = this;\n                this._map.once(\"moveend\", function() {\n                    that._openOnceFlag = false;\n                    that._openTooltip(e);\n                });\n                return;\n            }\n            this._tooltip._source = e.layer || e.target;\n            this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n        },\n        _moveTooltip: function(e) {\n            var latlng = e.latlng, containerPoint, layerPoint;\n            if (this._tooltip.options.sticky && e.originalEvent) {\n                containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n                layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n                latlng = this._map.layerPointToLatLng(layerPoint);\n            }\n            this._tooltip.setLatLng(latlng);\n        }\n    });\n    /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */ var DivIcon = Icon.extend({\n        options: {\n            // @section\n            // @aka DivIcon options\n            iconSize: [\n                12,\n                12\n            ],\n            // iconAnchor: (Point),\n            // popupAnchor: (Point),\n            // @option html: String|HTMLElement = ''\n            // Custom HTML code to put inside the div element, empty by default. Alternatively,\n            // an instance of `HTMLElement`.\n            html: false,\n            // @option bgPos: Point = [0, 0]\n            // Optional relative position of the background, in pixels\n            bgPos: null,\n            className: \"leaflet-div-icon\"\n        },\n        createIcon: function(oldIcon) {\n            var div = oldIcon && oldIcon.tagName === \"DIV\" ? oldIcon : document.createElement(\"div\"), options = this.options;\n            if (options.html instanceof Element) {\n                empty(div);\n                div.appendChild(options.html);\n            } else {\n                div.innerHTML = options.html !== false ? options.html : \"\";\n            }\n            if (options.bgPos) {\n                var bgPos = toPoint(options.bgPos);\n                div.style.backgroundPosition = -bgPos.x + \"px \" + -bgPos.y + \"px\";\n            }\n            this._setIconStyles(div, \"icon\");\n            return div;\n        },\n        createShadow: function() {\n            return null;\n        }\n    });\n    // @factory L.divIcon(options: DivIcon options)\n    // Creates a `DivIcon` instance with the given options.\n    function divIcon(options) {\n        return new DivIcon(options);\n    }\n    Icon.Default = IconDefault;\n    /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */ var GridLayer = Layer.extend({\n        // @section\n        // @aka GridLayer options\n        options: {\n            // @option tileSize: Number|Point = 256\n            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n            tileSize: 256,\n            // @option opacity: Number = 1.0\n            // Opacity of the tiles. Can be used in the `createTile()` function.\n            opacity: 1,\n            // @option updateWhenIdle: Boolean = (depends)\n            // Load new tiles only when panning ends.\n            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n            updateWhenIdle: Browser.mobile,\n            // @option updateWhenZooming: Boolean = true\n            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n            updateWhenZooming: true,\n            // @option updateInterval: Number = 200\n            // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n            updateInterval: 200,\n            // @option zIndex: Number = 1\n            // The explicit zIndex of the tile layer.\n            zIndex: 1,\n            // @option bounds: LatLngBounds = undefined\n            // If set, tiles will only be loaded inside the set `LatLngBounds`.\n            bounds: null,\n            // @option minZoom: Number = 0\n            // The minimum zoom level down to which this layer will be displayed (inclusive).\n            minZoom: 0,\n            // @option maxZoom: Number = undefined\n            // The maximum zoom level up to which this layer will be displayed (inclusive).\n            maxZoom: undefined,\n            // @option maxNativeZoom: Number = undefined\n            // Maximum zoom number the tile source has available. If it is specified,\n            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n            // from `maxNativeZoom` level and auto-scaled.\n            maxNativeZoom: undefined,\n            // @option minNativeZoom: Number = undefined\n            // Minimum zoom number the tile source has available. If it is specified,\n            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n            // from `minNativeZoom` level and auto-scaled.\n            minNativeZoom: undefined,\n            // @option noWrap: Boolean = false\n            // Whether the layer is wrapped around the antimeridian. If `true`, the\n            // GridLayer will only be displayed once at low zoom levels. Has no\n            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n            // tiles outside the CRS limits.\n            noWrap: false,\n            // @option pane: String = 'tilePane'\n            // `Map pane` where the grid layer will be added.\n            pane: \"tilePane\",\n            // @option className: String = ''\n            // A custom class name to assign to the tile layer. Empty by default.\n            className: \"\",\n            // @option keepBuffer: Number = 2\n            // When panning the map, keep this many rows and columns of tiles before unloading them.\n            keepBuffer: 2\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        onAdd: function() {\n            this._initContainer();\n            this._levels = {};\n            this._tiles = {};\n            this._resetView(); // implicit _update() call\n        },\n        beforeAdd: function(map) {\n            map._addZoomLimit(this);\n        },\n        onRemove: function(map) {\n            this._removeAllTiles();\n            remove(this._container);\n            map._removeZoomLimit(this);\n            this._container = null;\n            this._tileZoom = undefined;\n        },\n        // @method bringToFront: this\n        // Brings the tile layer to the top of all tile layers.\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._container);\n                this._setAutoZIndex(Math.max);\n            }\n            return this;\n        },\n        // @method bringToBack: this\n        // Brings the tile layer to the bottom of all tile layers.\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._container);\n                this._setAutoZIndex(Math.min);\n            }\n            return this;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTML element that contains the tiles for this layer.\n        getContainer: function() {\n            return this._container;\n        },\n        // @method setOpacity(opacity: Number): this\n        // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            this._updateOpacity();\n            return this;\n        },\n        // @method setZIndex(zIndex: Number): this\n        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n        setZIndex: function(zIndex) {\n            this.options.zIndex = zIndex;\n            this._updateZIndex();\n            return this;\n        },\n        // @method isLoading: Boolean\n        // Returns `true` if any tile in the grid layer has not finished loading.\n        isLoading: function() {\n            return this._loading;\n        },\n        // @method redraw: this\n        // Causes the layer to clear all the tiles and request them again.\n        redraw: function() {\n            if (this._map) {\n                this._removeAllTiles();\n                var tileZoom = this._clampZoom(this._map.getZoom());\n                if (tileZoom !== this._tileZoom) {\n                    this._tileZoom = tileZoom;\n                    this._updateLevels();\n                }\n                this._update();\n            }\n            return this;\n        },\n        getEvents: function() {\n            var events = {\n                viewprereset: this._invalidateAll,\n                viewreset: this._resetView,\n                zoom: this._resetView,\n                moveend: this._onMoveEnd\n            };\n            if (!this.options.updateWhenIdle) {\n                // update tiles on move, but not more often than once per given interval\n                if (!this._onMove) {\n                    this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n                }\n                events.move = this._onMove;\n            }\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @section Extension methods\n        // Layers extending `GridLayer` shall reimplement the following method.\n        // @method createTile(coords: Object, done?: Function): HTMLElement\n        // Called only internally, must be overridden by classes extending `GridLayer`.\n        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n        // is specified, it must be called when the tile has finished loading and drawing.\n        createTile: function() {\n            return document.createElement(\"div\");\n        },\n        // @section\n        // @method getTileSize: Point\n        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n        getTileSize: function() {\n            var s = this.options.tileSize;\n            return s instanceof Point ? s : new Point(s, s);\n        },\n        _updateZIndex: function() {\n            if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n                this._container.style.zIndex = this.options.zIndex;\n            }\n        },\n        _setAutoZIndex: function(compare) {\n            // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n            var layers = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n            for(var i = 0, len = layers.length, zIndex; i < len; i++){\n                zIndex = layers[i].style.zIndex;\n                if (layers[i] !== this._container && zIndex) {\n                    edgeZIndex = compare(edgeZIndex, +zIndex);\n                }\n            }\n            if (isFinite(edgeZIndex)) {\n                this.options.zIndex = edgeZIndex + compare(-1, 1);\n                this._updateZIndex();\n            }\n        },\n        _updateOpacity: function() {\n            if (!this._map) {\n                return;\n            }\n            // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n            if (Browser.ielt9) {\n                return;\n            }\n            setOpacity(this._container, this.options.opacity);\n            var now = +new Date(), nextFrame = false, willPrune = false;\n            for(var key in this._tiles){\n                var tile = this._tiles[key];\n                if (!tile.current || !tile.loaded) {\n                    continue;\n                }\n                var fade = Math.min(1, (now - tile.loaded) / 200);\n                setOpacity(tile.el, fade);\n                if (fade < 1) {\n                    nextFrame = true;\n                } else {\n                    if (tile.active) {\n                        willPrune = true;\n                    } else {\n                        this._onOpaqueTile(tile);\n                    }\n                    tile.active = true;\n                }\n            }\n            if (willPrune && !this._noPrune) {\n                this._pruneTiles();\n            }\n            if (nextFrame) {\n                cancelAnimFrame(this._fadeFrame);\n                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n            }\n        },\n        _onOpaqueTile: falseFn,\n        _initContainer: function() {\n            if (this._container) {\n                return;\n            }\n            this._container = create$1(\"div\", \"leaflet-layer \" + (this.options.className || \"\"));\n            this._updateZIndex();\n            if (this.options.opacity < 1) {\n                this._updateOpacity();\n            }\n            this.getPane().appendChild(this._container);\n        },\n        _updateLevels: function() {\n            var zoom = this._tileZoom, maxZoom = this.options.maxZoom;\n            if (zoom === undefined) {\n                return undefined;\n            }\n            for(var z in this._levels){\n                z = Number(z);\n                if (this._levels[z].el.children.length || z === zoom) {\n                    this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n                    this._onUpdateLevel(z);\n                } else {\n                    remove(this._levels[z].el);\n                    this._removeTilesAtZoom(z);\n                    this._onRemoveLevel(z);\n                    delete this._levels[z];\n                }\n            }\n            var level = this._levels[zoom], map = this._map;\n            if (!level) {\n                level = this._levels[zoom] = {};\n                level.el = create$1(\"div\", \"leaflet-tile-container leaflet-zoom-animated\", this._container);\n                level.el.style.zIndex = maxZoom;\n                level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n                level.zoom = zoom;\n                this._setZoomTransform(level, map.getCenter(), map.getZoom());\n                // force the browser to consider the newly added element for transition\n                falseFn(level.el.offsetWidth);\n                this._onCreateLevel(level);\n            }\n            this._level = level;\n            return level;\n        },\n        _onUpdateLevel: falseFn,\n        _onRemoveLevel: falseFn,\n        _onCreateLevel: falseFn,\n        _pruneTiles: function() {\n            if (!this._map) {\n                return;\n            }\n            var key, tile;\n            var zoom = this._map.getZoom();\n            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n                this._removeAllTiles();\n                return;\n            }\n            for(key in this._tiles){\n                tile = this._tiles[key];\n                tile.retain = tile.current;\n            }\n            for(key in this._tiles){\n                tile = this._tiles[key];\n                if (tile.current && !tile.active) {\n                    var coords = tile.coords;\n                    if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n                        this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n                    }\n                }\n            }\n            for(key in this._tiles){\n                if (!this._tiles[key].retain) {\n                    this._removeTile(key);\n                }\n            }\n        },\n        _removeTilesAtZoom: function(zoom) {\n            for(var key in this._tiles){\n                if (this._tiles[key].coords.z !== zoom) {\n                    continue;\n                }\n                this._removeTile(key);\n            }\n        },\n        _removeAllTiles: function() {\n            for(var key in this._tiles){\n                this._removeTile(key);\n            }\n        },\n        _invalidateAll: function() {\n            for(var z in this._levels){\n                remove(this._levels[z].el);\n                this._onRemoveLevel(Number(z));\n                delete this._levels[z];\n            }\n            this._removeAllTiles();\n            this._tileZoom = undefined;\n        },\n        _retainParent: function(x, y, z, minZoom) {\n            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);\n            coords2.z = +z2;\n            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];\n            if (tile && tile.active) {\n                tile.retain = true;\n                return true;\n            } else if (tile && tile.loaded) {\n                tile.retain = true;\n            }\n            if (z2 > minZoom) {\n                return this._retainParent(x2, y2, z2, minZoom);\n            }\n            return false;\n        },\n        _retainChildren: function(x, y, z, maxZoom) {\n            for(var i = 2 * x; i < 2 * x + 2; i++){\n                for(var j = 2 * y; j < 2 * y + 2; j++){\n                    var coords = new Point(i, j);\n                    coords.z = z + 1;\n                    var key = this._tileCoordsToKey(coords), tile = this._tiles[key];\n                    if (tile && tile.active) {\n                        tile.retain = true;\n                        continue;\n                    } else if (tile && tile.loaded) {\n                        tile.retain = true;\n                    }\n                    if (z + 1 < maxZoom) {\n                        this._retainChildren(i, j, z + 1, maxZoom);\n                    }\n                }\n            }\n        },\n        _resetView: function(e) {\n            var animating = e && (e.pinch || e.flyTo);\n            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n        },\n        _animateZoom: function(e) {\n            this._setView(e.center, e.zoom, true, e.noUpdate);\n        },\n        _clampZoom: function(zoom) {\n            var options = this.options;\n            if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n                return options.minNativeZoom;\n            }\n            if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n                return options.maxNativeZoom;\n            }\n            return zoom;\n        },\n        _setView: function(center, zoom, noPrune, noUpdate) {\n            var tileZoom = Math.round(zoom);\n            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n                tileZoom = undefined;\n            } else {\n                tileZoom = this._clampZoom(tileZoom);\n            }\n            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n            if (!noUpdate || tileZoomChanged) {\n                this._tileZoom = tileZoom;\n                if (this._abortLoading) {\n                    this._abortLoading();\n                }\n                this._updateLevels();\n                this._resetGrid();\n                if (tileZoom !== undefined) {\n                    this._update(center);\n                }\n                if (!noPrune) {\n                    this._pruneTiles();\n                }\n                // Flag to prevent _updateOpacity from pruning tiles during\n                // a zoom anim or a pinch gesture\n                this._noPrune = !!noPrune;\n            }\n            this._setZoomTransforms(center, zoom);\n        },\n        _setZoomTransforms: function(center, zoom) {\n            for(var i in this._levels){\n                this._setZoomTransform(this._levels[i], center, zoom);\n            }\n        },\n        _setZoomTransform: function(level, center, zoom) {\n            var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n            if (Browser.any3d) {\n                setTransform(level.el, translate, scale);\n            } else {\n                setPosition(level.el, translate);\n            }\n        },\n        _resetGrid: function() {\n            var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;\n            var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n            if (bounds) {\n                this._globalTileRange = this._pxBoundsToTileRange(bounds);\n            }\n            this._wrapX = crs.wrapLng && !this.options.noWrap && [\n                Math.floor(map.project([\n                    0,\n                    crs.wrapLng[0]\n                ], tileZoom).x / tileSize.x),\n                Math.ceil(map.project([\n                    0,\n                    crs.wrapLng[1]\n                ], tileZoom).x / tileSize.y)\n            ];\n            this._wrapY = crs.wrapLat && !this.options.noWrap && [\n                Math.floor(map.project([\n                    crs.wrapLat[0],\n                    0\n                ], tileZoom).y / tileSize.x),\n                Math.ceil(map.project([\n                    crs.wrapLat[1],\n                    0\n                ], tileZoom).y / tileSize.y)\n            ];\n        },\n        _onMoveEnd: function() {\n            if (!this._map || this._map._animatingZoom) {\n                return;\n            }\n            this._update();\n        },\n        _getTiledPixelBounds: function(center) {\n            var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale * 2);\n            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n        },\n        // Private method to load tiles in the grid's active zoom level according to map bounds\n        _update: function(center) {\n            var map = this._map;\n            if (!map) {\n                return;\n            }\n            var zoom = this._clampZoom(map.getZoom());\n            if (center === undefined) {\n                center = map.getCenter();\n            }\n            if (this._tileZoom === undefined) {\n                return;\n            } // if out of minzoom/maxzoom\n            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([\n                margin,\n                -margin\n            ]), tileRange.getTopRight().add([\n                margin,\n                -margin\n            ]));\n            // Sanity check: panic if the tile range contains Infinity somewhere.\n            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n                throw new Error(\"Attempted to load an infinite number of tiles\");\n            }\n            for(var key in this._tiles){\n                var c = this._tiles[key].coords;\n                if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n                    this._tiles[key].current = false;\n                }\n            }\n            // _update just loads more tiles. If the tile zoom level differs too much\n            // from the map's, let _setView reset levels and prune old tiles.\n            if (Math.abs(zoom - this._tileZoom) > 1) {\n                this._setView(center, zoom);\n                return;\n            }\n            // create a queue of coordinates to load tiles from\n            for(var j = tileRange.min.y; j <= tileRange.max.y; j++){\n                for(var i = tileRange.min.x; i <= tileRange.max.x; i++){\n                    var coords = new Point(i, j);\n                    coords.z = this._tileZoom;\n                    if (!this._isValidTile(coords)) {\n                        continue;\n                    }\n                    var tile = this._tiles[this._tileCoordsToKey(coords)];\n                    if (tile) {\n                        tile.current = true;\n                    } else {\n                        queue.push(coords);\n                    }\n                }\n            }\n            // sort tile queue to load tiles in order of their distance to center\n            queue.sort(function(a, b) {\n                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n            });\n            if (queue.length !== 0) {\n                // if it's the first batch of tiles to load\n                if (!this._loading) {\n                    this._loading = true;\n                    // @event loading: Event\n                    // Fired when the grid layer starts loading tiles.\n                    this.fire(\"loading\");\n                }\n                // create DOM fragment to append tiles in one batch\n                var fragment = document.createDocumentFragment();\n                for(i = 0; i < queue.length; i++){\n                    this._addTile(queue[i], fragment);\n                }\n                this._level.el.appendChild(fragment);\n            }\n        },\n        _isValidTile: function(coords) {\n            var crs = this._map.options.crs;\n            if (!crs.infinite) {\n                // don't load tile if it's out of bounds and not wrapped\n                var bounds = this._globalTileRange;\n                if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n                    return false;\n                }\n            }\n            if (!this.options.bounds) {\n                return true;\n            }\n            // don't load tile if it doesn't intersect the bounds in options\n            var tileBounds = this._tileCoordsToBounds(coords);\n            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n        },\n        _keyToBounds: function(key) {\n            return this._tileCoordsToBounds(this._keyToTileCoords(key));\n        },\n        _tileCoordsToNwSe: function(coords) {\n            var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);\n            return [\n                nw,\n                se\n            ];\n        },\n        // converts tile coordinates to its geographical bounds\n        _tileCoordsToBounds: function(coords) {\n            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);\n            if (!this.options.noWrap) {\n                bounds = this._map.wrapLatLngBounds(bounds);\n            }\n            return bounds;\n        },\n        // converts tile coordinates to key for the tile cache\n        _tileCoordsToKey: function(coords) {\n            return coords.x + \":\" + coords.y + \":\" + coords.z;\n        },\n        // converts tile cache key to coordinates\n        _keyToTileCoords: function(key) {\n            var k = key.split(\":\"), coords = new Point(+k[0], +k[1]);\n            coords.z = +k[2];\n            return coords;\n        },\n        _removeTile: function(key) {\n            var tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            remove(tile.el);\n            delete this._tiles[key];\n            // @event tileunload: TileEvent\n            // Fired when a tile is removed (e.g. when a tile goes off the screen).\n            this.fire(\"tileunload\", {\n                tile: tile.el,\n                coords: this._keyToTileCoords(key)\n            });\n        },\n        _initTile: function(tile) {\n            addClass(tile, \"leaflet-tile\");\n            var tileSize = this.getTileSize();\n            tile.style.width = tileSize.x + \"px\";\n            tile.style.height = tileSize.y + \"px\";\n            tile.onselectstart = falseFn;\n            tile.onmousemove = falseFn;\n            // update opacity on tiles in IE7-8 because of filter inheritance problems\n            if (Browser.ielt9 && this.options.opacity < 1) {\n                setOpacity(tile, this.options.opacity);\n            }\n        },\n        _addTile: function(coords, container) {\n            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);\n            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n            this._initTile(tile);\n            // if createTile is defined with a second argument (\"done\" callback),\n            // we know that tile is async and will be ready later; otherwise\n            if (this.createTile.length < 2) {\n                // mark tile as ready, but delay one frame for opacity animation to happen\n                requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n            }\n            setPosition(tile, tilePos);\n            // save tile in cache\n            this._tiles[key] = {\n                el: tile,\n                coords: coords,\n                current: true\n            };\n            container.appendChild(tile);\n            // @event tileloadstart: TileEvent\n            // Fired when a tile is requested and starts loading.\n            this.fire(\"tileloadstart\", {\n                tile: tile,\n                coords: coords\n            });\n        },\n        _tileReady: function(coords, err, tile) {\n            if (err) {\n                // @event tileerror: TileErrorEvent\n                // Fired when there is an error loading a tile.\n                this.fire(\"tileerror\", {\n                    error: err,\n                    tile: tile,\n                    coords: coords\n                });\n            }\n            var key = this._tileCoordsToKey(coords);\n            tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            tile.loaded = +new Date();\n            if (this._map._fadeAnimated) {\n                setOpacity(tile.el, 0);\n                cancelAnimFrame(this._fadeFrame);\n                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n            } else {\n                tile.active = true;\n                this._pruneTiles();\n            }\n            if (!err) {\n                addClass(tile.el, \"leaflet-tile-loaded\");\n                // @event tileload: TileEvent\n                // Fired when a tile loads.\n                this.fire(\"tileload\", {\n                    tile: tile.el,\n                    coords: coords\n                });\n            }\n            if (this._noTilesToLoad()) {\n                this._loading = false;\n                // @event load: Event\n                // Fired when the grid layer loaded all visible tiles.\n                this.fire(\"load\");\n                if (Browser.ielt9 || !this._map._fadeAnimated) {\n                    requestAnimFrame(this._pruneTiles, this);\n                } else {\n                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n                    // to trigger a pruning.\n                    setTimeout(bind(this._pruneTiles, this), 250);\n                }\n            }\n        },\n        _getTilePos: function(coords) {\n            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n        },\n        _wrapCoords: function(coords) {\n            var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n            newCoords.z = coords.z;\n            return newCoords;\n        },\n        _pxBoundsToTileRange: function(bounds) {\n            var tileSize = this.getTileSize();\n            return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([\n                1,\n                1\n            ]));\n        },\n        _noTilesToLoad: function() {\n            for(var key in this._tiles){\n                if (!this._tiles[key].loaded) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    });\n    // @factory L.gridLayer(options?: GridLayer options)\n    // Creates a new instance of GridLayer with the supplied options.\n    function gridLayer(options) {\n        return new GridLayer(options);\n    }\n    /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */ var TileLayer = GridLayer.extend({\n        // @section\n        // @aka TileLayer options\n        options: {\n            // @option minZoom: Number = 0\n            // The minimum zoom level down to which this layer will be displayed (inclusive).\n            minZoom: 0,\n            // @option maxZoom: Number = 18\n            // The maximum zoom level up to which this layer will be displayed (inclusive).\n            maxZoom: 18,\n            // @option subdomains: String|String[] = 'abc'\n            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n            subdomains: \"abc\",\n            // @option errorTileUrl: String = ''\n            // URL to the tile image to show in place of the tile that failed to load.\n            errorTileUrl: \"\",\n            // @option zoomOffset: Number = 0\n            // The zoom number used in tile URLs will be offset with this value.\n            zoomOffset: 0,\n            // @option tms: Boolean = false\n            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n            tms: false,\n            // @option zoomReverse: Boolean = false\n            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n            zoomReverse: false,\n            // @option detectRetina: Boolean = false\n            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n            detectRetina: false,\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false,\n            // @option referrerPolicy: Boolean|String = false\n            // Whether the referrerPolicy attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n            // (e.g. to validate an API token).\n            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n            referrerPolicy: false\n        },\n        initialize: function(url, options) {\n            this._url = url;\n            options = setOptions(this, options);\n            // detecting retina displays, adjusting tileSize and zoom levels\n            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n                options.tileSize = Math.floor(options.tileSize / 2);\n                if (!options.zoomReverse) {\n                    options.zoomOffset++;\n                    options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n                } else {\n                    options.zoomOffset--;\n                    options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n                }\n                options.minZoom = Math.max(0, options.minZoom);\n            } else if (!options.zoomReverse) {\n                // make sure maxZoom is gte minZoom\n                options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n            } else {\n                // make sure minZoom is lte maxZoom\n                options.minZoom = Math.min(options.maxZoom, options.minZoom);\n            }\n            if (typeof options.subdomains === \"string\") {\n                options.subdomains = options.subdomains.split(\"\");\n            }\n            this.on(\"tileunload\", this._onTileRemove);\n        },\n        // @method setUrl(url: String, noRedraw?: Boolean): this\n        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n        // If the URL does not change, the layer will not be redrawn unless\n        // the noRedraw parameter is set to false.\n        setUrl: function(url, noRedraw) {\n            if (this._url === url && noRedraw === undefined) {\n                noRedraw = true;\n            }\n            this._url = url;\n            if (!noRedraw) {\n                this.redraw();\n            }\n            return this;\n        },\n        // @method createTile(coords: Object, done?: Function): HTMLElement\n        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n        // callback is called when the tile has been loaded.\n        createTile: function(coords, done) {\n            var tile = document.createElement(\"img\");\n            on(tile, \"load\", bind(this._tileOnLoad, this, done, tile));\n            on(tile, \"error\", bind(this._tileOnError, this, done, tile));\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                tile.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            // for this new option we follow the documented behavior\n            // more closely by only setting the property when string\n            if (typeof this.options.referrerPolicy === \"string\") {\n                tile.referrerPolicy = this.options.referrerPolicy;\n            }\n            // The alt attribute is set to the empty string,\n            // allowing screen readers to ignore the decorative image tiles.\n            // https://www.w3.org/WAI/tutorials/images/decorative/\n            // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n            tile.alt = \"\";\n            tile.src = this.getTileUrl(coords);\n            return tile;\n        },\n        // @section Extension methods\n        // @uninheritable\n        // Layers extending `TileLayer` might reimplement the following method.\n        // @method getTileUrl(coords: Object): String\n        // Called only internally, returns the URL for a tile given its coordinates.\n        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n        getTileUrl: function(coords) {\n            var data = {\n                r: Browser.retina ? \"@2x\" : \"\",\n                s: this._getSubdomain(coords),\n                x: coords.x,\n                y: coords.y,\n                z: this._getZoomForUrl()\n            };\n            if (this._map && !this._map.options.crs.infinite) {\n                var invertedY = this._globalTileRange.max.y - coords.y;\n                if (this.options.tms) {\n                    data[\"y\"] = invertedY;\n                }\n                data[\"-y\"] = invertedY;\n            }\n            return template(this._url, extend(data, this.options));\n        },\n        _tileOnLoad: function(done, tile) {\n            // For https://github.com/Leaflet/Leaflet/issues/3332\n            if (Browser.ielt9) {\n                setTimeout(bind(done, this, null, tile), 0);\n            } else {\n                done(null, tile);\n            }\n        },\n        _tileOnError: function(done, tile, e) {\n            var errorUrl = this.options.errorTileUrl;\n            if (errorUrl && tile.getAttribute(\"src\") !== errorUrl) {\n                tile.src = errorUrl;\n            }\n            done(e, tile);\n        },\n        _onTileRemove: function(e) {\n            e.tile.onload = null;\n        },\n        _getZoomForUrl: function() {\n            var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;\n            if (zoomReverse) {\n                zoom = maxZoom - zoom;\n            }\n            return zoom + zoomOffset;\n        },\n        _getSubdomain: function(tilePoint) {\n            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n            return this.options.subdomains[index];\n        },\n        // stops loading all tiles in the background layer\n        _abortLoading: function() {\n            var i, tile;\n            for(i in this._tiles){\n                if (this._tiles[i].coords.z !== this._tileZoom) {\n                    tile = this._tiles[i].el;\n                    tile.onload = falseFn;\n                    tile.onerror = falseFn;\n                    if (!tile.complete) {\n                        tile.src = emptyImageUrl;\n                        var coords = this._tiles[i].coords;\n                        remove(tile);\n                        delete this._tiles[i];\n                        // @event tileabort: TileEvent\n                        // Fired when a tile was loading but is now not wanted.\n                        this.fire(\"tileabort\", {\n                            tile: tile,\n                            coords: coords\n                        });\n                    }\n                }\n            }\n        },\n        _removeTile: function(key) {\n            var tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            // Cancels any pending http requests associated with the tile\n            tile.el.setAttribute(\"src\", emptyImageUrl);\n            return GridLayer.prototype._removeTile.call(this, key);\n        },\n        _tileReady: function(coords, err, tile) {\n            if (!this._map || tile && tile.getAttribute(\"src\") === emptyImageUrl) {\n                return;\n            }\n            return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n        }\n    });\n    // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n    // Instantiates a tile layer object given a `URL template` and optionally an options object.\n    function tileLayer(url, options) {\n        return new TileLayer(url, options);\n    }\n    /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */ var TileLayerWMS = TileLayer.extend({\n        // @section\n        // @aka TileLayer.WMS options\n        // If any custom options not documented here are used, they will be sent to the\n        // WMS server as extra parameters in each request URL. This can be useful for\n        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n        defaultWmsParams: {\n            service: \"WMS\",\n            request: \"GetMap\",\n            // @option layers: String = ''\n            // **(required)** Comma-separated list of WMS layers to show.\n            layers: \"\",\n            // @option styles: String = ''\n            // Comma-separated list of WMS styles.\n            styles: \"\",\n            // @option format: String = 'image/jpeg'\n            // WMS image format (use `'image/png'` for layers with transparency).\n            format: \"image/jpeg\",\n            // @option transparent: Boolean = false\n            // If `true`, the WMS service will return images with transparency.\n            transparent: false,\n            // @option version: String = '1.1.1'\n            // Version of the WMS service to use\n            version: \"1.1.1\"\n        },\n        options: {\n            // @option crs: CRS = null\n            // Coordinate Reference System to use for the WMS requests, defaults to\n            // map CRS. Don't change this if you're not sure what it means.\n            crs: null,\n            // @option uppercase: Boolean = false\n            // If `true`, WMS request parameter keys will be uppercase.\n            uppercase: false\n        },\n        initialize: function(url, options) {\n            this._url = url;\n            var wmsParams = extend({}, this.defaultWmsParams);\n            // all keys that are not TileLayer options go to WMS params\n            for(var i in options){\n                if (!(i in this.options)) {\n                    wmsParams[i] = options[i];\n                }\n            }\n            options = setOptions(this, options);\n            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n            var tileSize = this.getTileSize();\n            wmsParams.width = tileSize.x * realRetina;\n            wmsParams.height = tileSize.y * realRetina;\n            this.wmsParams = wmsParams;\n        },\n        onAdd: function(map) {\n            this._crs = this.options.crs || map.options.crs;\n            this._wmsVersion = parseFloat(this.wmsParams.version);\n            var projectionKey = this._wmsVersion >= 1.3 ? \"crs\" : \"srs\";\n            this.wmsParams[projectionKey] = this._crs.code;\n            TileLayer.prototype.onAdd.call(this, map);\n        },\n        getTileUrl: function(coords) {\n            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [\n                min.y,\n                min.x,\n                max.y,\n                max.x\n            ] : [\n                min.x,\n                min.y,\n                max.x,\n                max.y\n            ]).join(\",\"), url = TileLayer.prototype.getTileUrl.call(this, coords);\n            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? \"&BBOX=\" : \"&bbox=\") + bbox;\n        },\n        // @method setParams(params: Object, noRedraw?: Boolean): this\n        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n        setParams: function(params, noRedraw) {\n            extend(this.wmsParams, params);\n            if (!noRedraw) {\n                this.redraw();\n            }\n            return this;\n        }\n    });\n    // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n    // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n    function tileLayerWMS(url, options) {\n        return new TileLayerWMS(url, options);\n    }\n    TileLayer.WMS = TileLayerWMS;\n    tileLayer.wms = tileLayerWMS;\n    /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */ var Renderer = Layer.extend({\n        // @section\n        // @aka Renderer options\n        options: {\n            // @option padding: Number = 0.1\n            // How much to extend the clip area around the map view (relative to its size)\n            // e.g. 0.1 would be 10% of map view in each direction\n            padding: 0.1\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n            stamp(this);\n            this._layers = this._layers || {};\n        },\n        onAdd: function() {\n            if (!this._container) {\n                this._initContainer(); // defined by renderer implementations\n                // always keep transform-origin as 0 0\n                addClass(this._container, \"leaflet-zoom-animated\");\n            }\n            this.getPane().appendChild(this._container);\n            this._update();\n            this.on(\"update\", this._updatePaths, this);\n        },\n        onRemove: function() {\n            this.off(\"update\", this._updatePaths, this);\n            this._destroyContainer();\n        },\n        getEvents: function() {\n            var events = {\n                viewreset: this._reset,\n                zoom: this._onZoom,\n                moveend: this._update,\n                zoomend: this._onZoomEnd\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._onAnimZoom;\n            }\n            return events;\n        },\n        _onAnimZoom: function(ev) {\n            this._updateTransform(ev.center, ev.zoom);\n        },\n        _onZoom: function() {\n            this._updateTransform(this._map.getCenter(), this._map.getZoom());\n        },\n        _updateTransform: function(center, zoom) {\n            var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom), topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n            if (Browser.any3d) {\n                setTransform(this._container, topLeftOffset, scale);\n            } else {\n                setPosition(this._container, topLeftOffset);\n            }\n        },\n        _reset: function() {\n            this._update();\n            this._updateTransform(this._center, this._zoom);\n            for(var id in this._layers){\n                this._layers[id]._reset();\n            }\n        },\n        _onZoomEnd: function() {\n            for(var id in this._layers){\n                this._layers[id]._project();\n            }\n        },\n        _updatePaths: function() {\n            for(var id in this._layers){\n                this._layers[id]._update();\n            }\n        },\n        _update: function() {\n            // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n            // Subclasses are responsible of firing the 'update' event.\n            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n            this._center = this._map.getCenter();\n            this._zoom = this._map.getZoom();\n        }\n    });\n    /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */ var Canvas = Renderer.extend({\n        // @section\n        // @aka Canvas options\n        options: {\n            // @option tolerance: Number = 0\n            // How much to extend the click tolerance around a path/object on the map.\n            tolerance: 0\n        },\n        getEvents: function() {\n            var events = Renderer.prototype.getEvents.call(this);\n            events.viewprereset = this._onViewPreReset;\n            return events;\n        },\n        _onViewPreReset: function() {\n            // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n            this._postponeUpdatePaths = true;\n        },\n        onAdd: function() {\n            Renderer.prototype.onAdd.call(this);\n            // Redraw vectors since canvas is cleared upon removal,\n            // in case of removing the renderer itself from the map.\n            this._draw();\n        },\n        _initContainer: function() {\n            var container = this._container = document.createElement(\"canvas\");\n            on(container, \"mousemove\", this._onMouseMove, this);\n            on(container, \"click dblclick mousedown mouseup contextmenu\", this._onClick, this);\n            on(container, \"mouseout\", this._handleMouseOut, this);\n            container[\"_leaflet_disable_events\"] = true;\n            this._ctx = container.getContext(\"2d\");\n        },\n        _destroyContainer: function() {\n            cancelAnimFrame(this._redrawRequest);\n            delete this._ctx;\n            remove(this._container);\n            off(this._container);\n            delete this._container;\n        },\n        _updatePaths: function() {\n            if (this._postponeUpdatePaths) {\n                return;\n            }\n            var layer;\n            this._redrawBounds = null;\n            for(var id in this._layers){\n                layer = this._layers[id];\n                layer._update();\n            }\n            this._redraw();\n        },\n        _update: function() {\n            if (this._map._animatingZoom && this._bounds) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;\n            setPosition(container, b.min);\n            // set canvas size (also clearing it); use double size on retina\n            container.width = m * size.x;\n            container.height = m * size.y;\n            container.style.width = size.x + \"px\";\n            container.style.height = size.y + \"px\";\n            if (Browser.retina) {\n                this._ctx.scale(2, 2);\n            }\n            // translate so we use the same path coordinates after canvas element moves\n            this._ctx.translate(-b.min.x, -b.min.y);\n            // Tell paths to redraw themselves\n            this.fire(\"update\");\n        },\n        _reset: function() {\n            Renderer.prototype._reset.call(this);\n            if (this._postponeUpdatePaths) {\n                this._postponeUpdatePaths = false;\n                this._updatePaths();\n            }\n        },\n        _initPath: function(layer) {\n            this._updateDashArray(layer);\n            this._layers[stamp(layer)] = layer;\n            var order = layer._order = {\n                layer: layer,\n                prev: this._drawLast,\n                next: null\n            };\n            if (this._drawLast) {\n                this._drawLast.next = order;\n            }\n            this._drawLast = order;\n            this._drawFirst = this._drawFirst || this._drawLast;\n        },\n        _addPath: function(layer) {\n            this._requestRedraw(layer);\n        },\n        _removePath: function(layer) {\n            var order = layer._order;\n            var next = order.next;\n            var prev = order.prev;\n            if (next) {\n                next.prev = prev;\n            } else {\n                this._drawLast = prev;\n            }\n            if (prev) {\n                prev.next = next;\n            } else {\n                this._drawFirst = next;\n            }\n            delete layer._order;\n            delete this._layers[stamp(layer)];\n            this._requestRedraw(layer);\n        },\n        _updatePath: function(layer) {\n            // Redraw the union of the layer's old pixel\n            // bounds and the new pixel bounds.\n            this._extendRedrawBounds(layer);\n            layer._project();\n            layer._update();\n            // The redraw will extend the redraw bounds\n            // with the new pixel bounds.\n            this._requestRedraw(layer);\n        },\n        _updateStyle: function(layer) {\n            this._updateDashArray(layer);\n            this._requestRedraw(layer);\n        },\n        _updateDashArray: function(layer) {\n            if (typeof layer.options.dashArray === \"string\") {\n                var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;\n                for(i = 0; i < parts.length; i++){\n                    dashValue = Number(parts[i]);\n                    // Ignore dash array containing invalid lengths\n                    if (isNaN(dashValue)) {\n                        return;\n                    }\n                    dashArray.push(dashValue);\n                }\n                layer.options._dashArray = dashArray;\n            } else {\n                layer.options._dashArray = layer.options.dashArray;\n            }\n        },\n        _requestRedraw: function(layer) {\n            if (!this._map) {\n                return;\n            }\n            this._extendRedrawBounds(layer);\n            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n        },\n        _extendRedrawBounds: function(layer) {\n            if (layer._pxBounds) {\n                var padding = (layer.options.weight || 0) + 1;\n                this._redrawBounds = this._redrawBounds || new Bounds();\n                this._redrawBounds.extend(layer._pxBounds.min.subtract([\n                    padding,\n                    padding\n                ]));\n                this._redrawBounds.extend(layer._pxBounds.max.add([\n                    padding,\n                    padding\n                ]));\n            }\n        },\n        _redraw: function() {\n            this._redrawRequest = null;\n            if (this._redrawBounds) {\n                this._redrawBounds.min._floor();\n                this._redrawBounds.max._ceil();\n            }\n            this._clear(); // clear layers in redraw bounds\n            this._draw(); // draw layers\n            this._redrawBounds = null;\n        },\n        _clear: function() {\n            var bounds = this._redrawBounds;\n            if (bounds) {\n                var size = bounds.getSize();\n                this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n            } else {\n                this._ctx.save();\n                this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n                this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n                this._ctx.restore();\n            }\n        },\n        _draw: function() {\n            var layer, bounds = this._redrawBounds;\n            this._ctx.save();\n            if (bounds) {\n                var size = bounds.getSize();\n                this._ctx.beginPath();\n                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n                this._ctx.clip();\n            }\n            this._drawing = true;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n                    layer._updatePath();\n                }\n            }\n            this._drawing = false;\n            this._ctx.restore(); // Restore state before clipping.\n        },\n        _updatePoly: function(layer, closed) {\n            if (!this._drawing) {\n                return;\n            }\n            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;\n            if (!len) {\n                return;\n            }\n            ctx.beginPath();\n            for(i = 0; i < len; i++){\n                for(j = 0, len2 = parts[i].length; j < len2; j++){\n                    p = parts[i][j];\n                    ctx[j ? \"lineTo\" : \"moveTo\"](p.x, p.y);\n                }\n                if (closed) {\n                    ctx.closePath();\n                }\n            }\n            this._fillStroke(ctx, layer);\n        // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n        },\n        _updateCircle: function(layer) {\n            if (!this._drawing || layer._empty()) {\n                return;\n            }\n            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n            if (s !== 1) {\n                ctx.save();\n                ctx.scale(1, s);\n            }\n            ctx.beginPath();\n            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n            if (s !== 1) {\n                ctx.restore();\n            }\n            this._fillStroke(ctx, layer);\n        },\n        _fillStroke: function(ctx, layer) {\n            var options = layer.options;\n            if (options.fill) {\n                ctx.globalAlpha = options.fillOpacity;\n                ctx.fillStyle = options.fillColor || options.color;\n                ctx.fill(options.fillRule || \"evenodd\");\n            }\n            if (options.stroke && options.weight !== 0) {\n                if (ctx.setLineDash) {\n                    ctx.setLineDash(layer.options && layer.options._dashArray || []);\n                }\n                ctx.globalAlpha = options.opacity;\n                ctx.lineWidth = options.weight;\n                ctx.strokeStyle = options.color;\n                ctx.lineCap = options.lineCap;\n                ctx.lineJoin = options.lineJoin;\n                ctx.stroke();\n            }\n        },\n        // Canvas obviously doesn't have mouse events for individual drawn objects,\n        // so we emulate that by calculating what's under the mouse on mousemove/click manually\n        _onClick: function(e) {\n            var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (layer.options.interactive && layer._containsPoint(point)) {\n                    if (!(e.type === \"click\" || e.type === \"preclick\") || !this._map._draggableMoved(layer)) {\n                        clickedLayer = layer;\n                    }\n                }\n            }\n            this._fireEvent(clickedLayer ? [\n                clickedLayer\n            ] : false, e);\n        },\n        _onMouseMove: function(e) {\n            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n                return;\n            }\n            var point = this._map.mouseEventToLayerPoint(e);\n            this._handleMouseHover(e, point);\n        },\n        _handleMouseOut: function(e) {\n            var layer = this._hoveredLayer;\n            if (layer) {\n                // if we're leaving the layer, fire mouseout\n                removeClass(this._container, \"leaflet-interactive\");\n                this._fireEvent([\n                    layer\n                ], e, \"mouseout\");\n                this._hoveredLayer = null;\n                this._mouseHoverThrottled = false;\n            }\n        },\n        _handleMouseHover: function(e, point) {\n            if (this._mouseHoverThrottled) {\n                return;\n            }\n            var layer, candidateHoveredLayer;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (layer.options.interactive && layer._containsPoint(point)) {\n                    candidateHoveredLayer = layer;\n                }\n            }\n            if (candidateHoveredLayer !== this._hoveredLayer) {\n                this._handleMouseOut(e);\n                if (candidateHoveredLayer) {\n                    addClass(this._container, \"leaflet-interactive\"); // change cursor\n                    this._fireEvent([\n                        candidateHoveredLayer\n                    ], e, \"mouseover\");\n                    this._hoveredLayer = candidateHoveredLayer;\n                }\n            }\n            this._fireEvent(this._hoveredLayer ? [\n                this._hoveredLayer\n            ] : false, e);\n            this._mouseHoverThrottled = true;\n            setTimeout(bind(function() {\n                this._mouseHoverThrottled = false;\n            }, this), 32);\n        },\n        _fireEvent: function(layers, e, type) {\n            this._map._fireDOMEvent(e, type || e.type, layers);\n        },\n        _bringToFront: function(layer) {\n            var order = layer._order;\n            if (!order) {\n                return;\n            }\n            var next = order.next;\n            var prev = order.prev;\n            if (next) {\n                next.prev = prev;\n            } else {\n                // Already last\n                return;\n            }\n            if (prev) {\n                prev.next = next;\n            } else if (next) {\n                // Update first entry unless this is the\n                // single entry\n                this._drawFirst = next;\n            }\n            order.prev = this._drawLast;\n            this._drawLast.next = order;\n            order.next = null;\n            this._drawLast = order;\n            this._requestRedraw(layer);\n        },\n        _bringToBack: function(layer) {\n            var order = layer._order;\n            if (!order) {\n                return;\n            }\n            var next = order.next;\n            var prev = order.prev;\n            if (prev) {\n                prev.next = next;\n            } else {\n                // Already first\n                return;\n            }\n            if (next) {\n                next.prev = prev;\n            } else if (prev) {\n                // Update last entry unless this is the\n                // single entry\n                this._drawLast = prev;\n            }\n            order.prev = null;\n            order.next = this._drawFirst;\n            this._drawFirst.prev = order;\n            this._drawFirst = order;\n            this._requestRedraw(layer);\n        }\n    });\n    // @factory L.canvas(options?: Renderer options)\n    // Creates a Canvas renderer with the given options.\n    function canvas(options) {\n        return Browser.canvas ? new Canvas(options) : null;\n    }\n    /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */ var vmlCreate = function() {\n        try {\n            document.namespaces.add(\"lvml\", \"urn:schemas-microsoft-com:vml\");\n            return function(name) {\n                return document.createElement(\"<lvml:\" + name + ' class=\"lvml\">');\n            };\n        } catch (e) {\n        // Do not return fn from catch block so `e` can be garbage collected\n        // See https://github.com/Leaflet/Leaflet/pull/7279\n        }\n        return function(name) {\n            return document.createElement(\"<\" + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n        };\n    }();\n    /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */ // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n    var vmlMixin = {\n        _initContainer: function() {\n            this._container = create$1(\"div\", \"leaflet-vml-container\");\n        },\n        _update: function() {\n            if (this._map._animatingZoom) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            this.fire(\"update\");\n        },\n        _initPath: function(layer) {\n            var container = layer._container = vmlCreate(\"shape\");\n            addClass(container, \"leaflet-vml-shape \" + (this.options.className || \"\"));\n            container.coordsize = \"1 1\";\n            layer._path = vmlCreate(\"path\");\n            container.appendChild(layer._path);\n            this._updateStyle(layer);\n            this._layers[stamp(layer)] = layer;\n        },\n        _addPath: function(layer) {\n            var container = layer._container;\n            this._container.appendChild(container);\n            if (layer.options.interactive) {\n                layer.addInteractiveTarget(container);\n            }\n        },\n        _removePath: function(layer) {\n            var container = layer._container;\n            remove(container);\n            layer.removeInteractiveTarget(container);\n            delete this._layers[stamp(layer)];\n        },\n        _updateStyle: function(layer) {\n            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;\n            container.stroked = !!options.stroke;\n            container.filled = !!options.fill;\n            if (options.stroke) {\n                if (!stroke) {\n                    stroke = layer._stroke = vmlCreate(\"stroke\");\n                }\n                container.appendChild(stroke);\n                stroke.weight = options.weight + \"px\";\n                stroke.color = options.color;\n                stroke.opacity = options.opacity;\n                if (options.dashArray) {\n                    stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(\" \") : options.dashArray.replace(/( *, *)/g, \" \");\n                } else {\n                    stroke.dashStyle = \"\";\n                }\n                stroke.endcap = options.lineCap.replace(\"butt\", \"flat\");\n                stroke.joinstyle = options.lineJoin;\n            } else if (stroke) {\n                container.removeChild(stroke);\n                layer._stroke = null;\n            }\n            if (options.fill) {\n                if (!fill) {\n                    fill = layer._fill = vmlCreate(\"fill\");\n                }\n                container.appendChild(fill);\n                fill.color = options.fillColor || options.color;\n                fill.opacity = options.fillOpacity;\n            } else if (fill) {\n                container.removeChild(fill);\n                layer._fill = null;\n            }\n        },\n        _updateCircle: function(layer) {\n            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);\n            this._setPath(layer, layer._empty() ? \"M0 0\" : \"AL \" + p.x + \",\" + p.y + \" \" + r + \",\" + r2 + \" 0,\" + 65535 * 360);\n        },\n        _setPath: function(layer, path) {\n            layer._path.v = path;\n        },\n        _bringToFront: function(layer) {\n            toFront(layer._container);\n        },\n        _bringToBack: function(layer) {\n            toBack(layer._container);\n        }\n    };\n    var create = Browser.vml ? vmlCreate : svgCreate;\n    /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */ var SVG = Renderer.extend({\n        _initContainer: function() {\n            this._container = create(\"svg\");\n            // makes it possible to click through svg root; we'll reset it back in individual paths\n            this._container.setAttribute(\"pointer-events\", \"none\");\n            this._rootGroup = create(\"g\");\n            this._container.appendChild(this._rootGroup);\n        },\n        _destroyContainer: function() {\n            remove(this._container);\n            off(this._container);\n            delete this._container;\n            delete this._rootGroup;\n            delete this._svgSize;\n        },\n        _update: function() {\n            if (this._map._animatingZoom && this._bounds) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            var b = this._bounds, size = b.getSize(), container = this._container;\n            // set size of svg-container if changed\n            if (!this._svgSize || !this._svgSize.equals(size)) {\n                this._svgSize = size;\n                container.setAttribute(\"width\", size.x);\n                container.setAttribute(\"height\", size.y);\n            }\n            // movement: update container viewBox so that we don't have to change coordinates of individual layers\n            setPosition(container, b.min);\n            container.setAttribute(\"viewBox\", [\n                b.min.x,\n                b.min.y,\n                size.x,\n                size.y\n            ].join(\" \"));\n            this.fire(\"update\");\n        },\n        // methods below are called by vector layers implementations\n        _initPath: function(layer) {\n            var path = layer._path = create(\"path\");\n            // @namespace Path\n            // @option className: String = null\n            // Custom class name set on an element. Only for SVG renderer.\n            if (layer.options.className) {\n                addClass(path, layer.options.className);\n            }\n            if (layer.options.interactive) {\n                addClass(path, \"leaflet-interactive\");\n            }\n            this._updateStyle(layer);\n            this._layers[stamp(layer)] = layer;\n        },\n        _addPath: function(layer) {\n            if (!this._rootGroup) {\n                this._initContainer();\n            }\n            this._rootGroup.appendChild(layer._path);\n            layer.addInteractiveTarget(layer._path);\n        },\n        _removePath: function(layer) {\n            remove(layer._path);\n            layer.removeInteractiveTarget(layer._path);\n            delete this._layers[stamp(layer)];\n        },\n        _updatePath: function(layer) {\n            layer._project();\n            layer._update();\n        },\n        _updateStyle: function(layer) {\n            var path = layer._path, options = layer.options;\n            if (!path) {\n                return;\n            }\n            if (options.stroke) {\n                path.setAttribute(\"stroke\", options.color);\n                path.setAttribute(\"stroke-opacity\", options.opacity);\n                path.setAttribute(\"stroke-width\", options.weight);\n                path.setAttribute(\"stroke-linecap\", options.lineCap);\n                path.setAttribute(\"stroke-linejoin\", options.lineJoin);\n                if (options.dashArray) {\n                    path.setAttribute(\"stroke-dasharray\", options.dashArray);\n                } else {\n                    path.removeAttribute(\"stroke-dasharray\");\n                }\n                if (options.dashOffset) {\n                    path.setAttribute(\"stroke-dashoffset\", options.dashOffset);\n                } else {\n                    path.removeAttribute(\"stroke-dashoffset\");\n                }\n            } else {\n                path.setAttribute(\"stroke\", \"none\");\n            }\n            if (options.fill) {\n                path.setAttribute(\"fill\", options.fillColor || options.color);\n                path.setAttribute(\"fill-opacity\", options.fillOpacity);\n                path.setAttribute(\"fill-rule\", options.fillRule || \"evenodd\");\n            } else {\n                path.setAttribute(\"fill\", \"none\");\n            }\n        },\n        _updatePoly: function(layer, closed) {\n            this._setPath(layer, pointsToPath(layer._parts, closed));\n        },\n        _updateCircle: function(layer) {\n            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = \"a\" + r + \",\" + r2 + \" 0 1,0 \";\n            // drawing a circle with two half-arcs\n            var d = layer._empty() ? \"M0 0\" : \"M\" + (p.x - r) + \",\" + p.y + arc + r * 2 + \",0 \" + arc + -r * 2 + \",0 \";\n            this._setPath(layer, d);\n        },\n        _setPath: function(layer, path) {\n            layer._path.setAttribute(\"d\", path);\n        },\n        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n        _bringToFront: function(layer) {\n            toFront(layer._path);\n        },\n        _bringToBack: function(layer) {\n            toBack(layer._path);\n        }\n    });\n    if (Browser.vml) {\n        SVG.include(vmlMixin);\n    }\n    // @namespace SVG\n    // @factory L.svg(options?: Renderer options)\n    // Creates a SVG renderer with the given options.\n    function svg(options) {\n        return Browser.svg || Browser.vml ? new SVG(options) : null;\n    }\n    Map.include({\n        // @namespace Map; @method getRenderer(layer: Path): Renderer\n        // Returns the instance of `Renderer` that should be used to render the given\n        // `Path`. It will ensure that the `renderer` options of the map and paths\n        // are respected, and that the renderers do exist on the map.\n        getRenderer: function(layer) {\n            // @namespace Path; @option renderer: Renderer\n            // Use this specific instance of `Renderer` for this path. Takes\n            // precedence over the map's [default renderer](#map-renderer).\n            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n            if (!renderer) {\n                renderer = this._renderer = this._createRenderer();\n            }\n            if (!this.hasLayer(renderer)) {\n                this.addLayer(renderer);\n            }\n            return renderer;\n        },\n        _getPaneRenderer: function(name) {\n            if (name === \"overlayPane\" || name === undefined) {\n                return false;\n            }\n            var renderer = this._paneRenderers[name];\n            if (renderer === undefined) {\n                renderer = this._createRenderer({\n                    pane: name\n                });\n                this._paneRenderers[name] = renderer;\n            }\n            return renderer;\n        },\n        _createRenderer: function(options) {\n            // @namespace Map; @option preferCanvas: Boolean = false\n            // Whether `Path`s should be rendered on a `Canvas` renderer.\n            // By default, all `Path`s are rendered in a `SVG` renderer.\n            return this.options.preferCanvas && canvas(options) || svg(options);\n        }\n    });\n    /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */ /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */ var Rectangle = Polygon.extend({\n        initialize: function(latLngBounds, options) {\n            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n        },\n        // @method setBounds(latLngBounds: LatLngBounds): this\n        // Redraws the rectangle with the passed bounds.\n        setBounds: function(latLngBounds) {\n            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n        },\n        _boundsToLatLngs: function(latLngBounds) {\n            latLngBounds = toLatLngBounds(latLngBounds);\n            return [\n                latLngBounds.getSouthWest(),\n                latLngBounds.getNorthWest(),\n                latLngBounds.getNorthEast(),\n                latLngBounds.getSouthEast()\n            ];\n        }\n    });\n    // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n    function rectangle(latLngBounds, options) {\n        return new Rectangle(latLngBounds, options);\n    }\n    SVG.create = create;\n    SVG.pointsToPath = pointsToPath;\n    GeoJSON.geometryToLayer = geometryToLayer;\n    GeoJSON.coordsToLatLng = coordsToLatLng;\n    GeoJSON.coordsToLatLngs = coordsToLatLngs;\n    GeoJSON.latLngToCoords = latLngToCoords;\n    GeoJSON.latLngsToCoords = latLngsToCoords;\n    GeoJSON.getFeature = getFeature;\n    GeoJSON.asFeature = asFeature;\n    /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option boxZoom: Boolean = true\n        // Whether the map can be zoomed to a rectangular area specified by\n        // dragging the mouse while pressing the shift key.\n        boxZoom: true\n    });\n    var BoxZoom = Handler.extend({\n        initialize: function(map) {\n            this._map = map;\n            this._container = map._container;\n            this._pane = map._panes.overlayPane;\n            this._resetStateTimeout = 0;\n            map.on(\"unload\", this._destroy, this);\n        },\n        addHooks: function() {\n            on(this._container, \"mousedown\", this._onMouseDown, this);\n        },\n        removeHooks: function() {\n            off(this._container, \"mousedown\", this._onMouseDown, this);\n        },\n        moved: function() {\n            return this._moved;\n        },\n        _destroy: function() {\n            remove(this._pane);\n            delete this._pane;\n        },\n        _resetState: function() {\n            this._resetStateTimeout = 0;\n            this._moved = false;\n        },\n        _clearDeferredResetState: function() {\n            if (this._resetStateTimeout !== 0) {\n                clearTimeout(this._resetStateTimeout);\n                this._resetStateTimeout = 0;\n            }\n        },\n        _onMouseDown: function(e) {\n            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n                return false;\n            }\n            // Clear the deferred resetState if it hasn't executed yet, otherwise it\n            // will interrupt the interaction and orphan a box element in the container.\n            this._clearDeferredResetState();\n            this._resetState();\n            disableTextSelection();\n            disableImageDrag();\n            this._startPoint = this._map.mouseEventToContainerPoint(e);\n            on(document, {\n                contextmenu: stop,\n                mousemove: this._onMouseMove,\n                mouseup: this._onMouseUp,\n                keydown: this._onKeyDown\n            }, this);\n        },\n        _onMouseMove: function(e) {\n            if (!this._moved) {\n                this._moved = true;\n                this._box = create$1(\"div\", \"leaflet-zoom-box\", this._container);\n                addClass(this._container, \"leaflet-crosshair\");\n                this._map.fire(\"boxzoomstart\");\n            }\n            this._point = this._map.mouseEventToContainerPoint(e);\n            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();\n            setPosition(this._box, bounds.min);\n            this._box.style.width = size.x + \"px\";\n            this._box.style.height = size.y + \"px\";\n        },\n        _finish: function() {\n            if (this._moved) {\n                remove(this._box);\n                removeClass(this._container, \"leaflet-crosshair\");\n            }\n            enableTextSelection();\n            enableImageDrag();\n            off(document, {\n                contextmenu: stop,\n                mousemove: this._onMouseMove,\n                mouseup: this._onMouseUp,\n                keydown: this._onKeyDown\n            }, this);\n        },\n        _onMouseUp: function(e) {\n            if (e.which !== 1 && e.button !== 1) {\n                return;\n            }\n            this._finish();\n            if (!this._moved) {\n                return;\n            }\n            // Postpone to next JS tick so internal click event handling\n            // still see it as \"moved\".\n            this._clearDeferredResetState();\n            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n            var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n            this._map.fitBounds(bounds).fire(\"boxzoomend\", {\n                boxZoomBounds: bounds\n            });\n        },\n        _onKeyDown: function(e) {\n            if (e.keyCode === 27) {\n                this._finish();\n                this._clearDeferredResetState();\n                this._resetState();\n            }\n        }\n    });\n    // @section Handlers\n    // @property boxZoom: Handler\n    // Box (shift-drag with mouse) zoom handler.\n    Map.addInitHook(\"addHandler\", \"boxZoom\", BoxZoom);\n    /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option doubleClickZoom: Boolean|String = true\n        // Whether the map can be zoomed in by double clicking on it and\n        // zoomed out by double clicking while holding shift. If passed\n        // `'center'`, double-click zoom will zoom to the center of the\n        //  view regardless of where the mouse was.\n        doubleClickZoom: true\n    });\n    var DoubleClickZoom = Handler.extend({\n        addHooks: function() {\n            this._map.on(\"dblclick\", this._onDoubleClick, this);\n        },\n        removeHooks: function() {\n            this._map.off(\"dblclick\", this._onDoubleClick, this);\n        },\n        _onDoubleClick: function(e) {\n            var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n            if (map.options.doubleClickZoom === \"center\") {\n                map.setZoom(zoom);\n            } else {\n                map.setZoomAround(e.containerPoint, zoom);\n            }\n        }\n    });\n    // @section Handlers\n    //\n    // Map properties include interaction handlers that allow you to control\n    // interaction behavior in runtime, enabling or disabling certain features such\n    // as dragging or touch zoom (see `Handler` methods). For example:\n    //\n    // ```js\n    // map.doubleClickZoom.disable();\n    // ```\n    //\n    // @property doubleClickZoom: Handler\n    // Double click zoom handler.\n    Map.addInitHook(\"addHandler\", \"doubleClickZoom\", DoubleClickZoom);\n    /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option dragging: Boolean = true\n        // Whether the map is draggable with mouse/touch or not.\n        dragging: true,\n        // @section Panning Inertia Options\n        // @option inertia: Boolean = *\n        // If enabled, panning of the map will have an inertia effect where\n        // the map builds momentum while dragging and continues moving in\n        // the same direction for some time. Feels especially nice on touch\n        // devices. Enabled by default.\n        inertia: true,\n        // @option inertiaDeceleration: Number = 3000\n        // The rate with which the inertial movement slows down, in pixels/second.\n        inertiaDeceleration: 3400,\n        // @option inertiaMaxSpeed: Number = Infinity\n        // Max speed of the inertial movement, in pixels/second.\n        inertiaMaxSpeed: Infinity,\n        // @option easeLinearity: Number = 0.2\n        easeLinearity: 0.2,\n        // TODO refactor, move to CRS\n        // @option worldCopyJump: Boolean = false\n        // With this option enabled, the map tracks when you pan to another \"copy\"\n        // of the world and seamlessly jumps to the original one so that all overlays\n        // like markers and vector layers are still visible.\n        worldCopyJump: false,\n        // @option maxBoundsViscosity: Number = 0.0\n        // If `maxBounds` is set, this option will control how solid the bounds\n        // are when dragging the map around. The default value of `0.0` allows the\n        // user to drag outside the bounds at normal speed, higher values will\n        // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n        // solid, preventing the user from dragging outside the bounds.\n        maxBoundsViscosity: 0.0\n    });\n    var Drag = Handler.extend({\n        addHooks: function() {\n            if (!this._draggable) {\n                var map = this._map;\n                this._draggable = new Draggable(map._mapPane, map._container);\n                this._draggable.on({\n                    dragstart: this._onDragStart,\n                    drag: this._onDrag,\n                    dragend: this._onDragEnd\n                }, this);\n                this._draggable.on(\"predrag\", this._onPreDragLimit, this);\n                if (map.options.worldCopyJump) {\n                    this._draggable.on(\"predrag\", this._onPreDragWrap, this);\n                    map.on(\"zoomend\", this._onZoomEnd, this);\n                    map.whenReady(this._onZoomEnd, this);\n                }\n            }\n            addClass(this._map._container, \"leaflet-grab leaflet-touch-drag\");\n            this._draggable.enable();\n            this._positions = [];\n            this._times = [];\n        },\n        removeHooks: function() {\n            removeClass(this._map._container, \"leaflet-grab\");\n            removeClass(this._map._container, \"leaflet-touch-drag\");\n            this._draggable.disable();\n        },\n        moved: function() {\n            return this._draggable && this._draggable._moved;\n        },\n        moving: function() {\n            return this._draggable && this._draggable._moving;\n        },\n        _onDragStart: function() {\n            var map = this._map;\n            map._stop();\n            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n                var bounds = toLatLngBounds(this._map.options.maxBounds);\n                this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n                this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n            } else {\n                this._offsetLimit = null;\n            }\n            map.fire(\"movestart\").fire(\"dragstart\");\n            if (map.options.inertia) {\n                this._positions = [];\n                this._times = [];\n            }\n        },\n        _onDrag: function(e) {\n            if (this._map.options.inertia) {\n                var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n                this._positions.push(pos);\n                this._times.push(time);\n                this._prunePositions(time);\n            }\n            this._map.fire(\"move\", e).fire(\"drag\", e);\n        },\n        _prunePositions: function(time) {\n            while(this._positions.length > 1 && time - this._times[0] > 50){\n                this._positions.shift();\n                this._times.shift();\n            }\n        },\n        _onZoomEnd: function() {\n            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([\n                0,\n                0\n            ]);\n            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n        },\n        _viscousLimit: function(value, threshold) {\n            return value - (value - threshold) * this._viscosity;\n        },\n        _onPreDragLimit: function() {\n            if (!this._viscosity || !this._offsetLimit) {\n                return;\n            }\n            var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n            var limit = this._offsetLimit;\n            if (offset.x < limit.min.x) {\n                offset.x = this._viscousLimit(offset.x, limit.min.x);\n            }\n            if (offset.y < limit.min.y) {\n                offset.y = this._viscousLimit(offset.y, limit.min.y);\n            }\n            if (offset.x > limit.max.x) {\n                offset.x = this._viscousLimit(offset.x, limit.max.x);\n            }\n            if (offset.y > limit.max.y) {\n                offset.y = this._viscousLimit(offset.y, limit.max.y);\n            }\n            this._draggable._newPos = this._draggable._startPos.add(offset);\n        },\n        _onPreDragWrap: function() {\n            // TODO refactor to be able to adjust map pane position after zoom\n            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n            this._draggable._absPos = this._draggable._newPos.clone();\n            this._draggable._newPos.x = newX;\n        },\n        _onDragEnd: function(e) {\n            var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n            map.fire(\"dragend\", e);\n            if (noInertia) {\n                map.fire(\"moveend\");\n            } else {\n                this._prunePositions(+new Date());\n                var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1000, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([\n                    0,\n                    0\n                ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n                if (!offset.x && !offset.y) {\n                    map.fire(\"moveend\");\n                } else {\n                    offset = map._limitOffset(offset, map.options.maxBounds);\n                    requestAnimFrame(function() {\n                        map.panBy(offset, {\n                            duration: decelerationDuration,\n                            easeLinearity: ease,\n                            noMoveStart: true,\n                            animate: true\n                        });\n                    });\n                }\n            }\n        }\n    });\n    // @section Handlers\n    // @property dragging: Handler\n    // Map dragging handler (by both mouse and touch).\n    Map.addInitHook(\"addHandler\", \"dragging\", Drag);\n    /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */ // @namespace Map\n    // @section Keyboard Navigation Options\n    Map.mergeOptions({\n        // @option keyboard: Boolean = true\n        // Makes the map focusable and allows users to navigate the map with keyboard\n        // arrows and `+`/`-` keys.\n        keyboard: true,\n        // @option keyboardPanDelta: Number = 80\n        // Amount of pixels to pan when pressing an arrow key.\n        keyboardPanDelta: 80\n    });\n    var Keyboard = Handler.extend({\n        keyCodes: {\n            left: [\n                37\n            ],\n            right: [\n                39\n            ],\n            down: [\n                40\n            ],\n            up: [\n                38\n            ],\n            zoomIn: [\n                187,\n                107,\n                61,\n                171\n            ],\n            zoomOut: [\n                189,\n                109,\n                54,\n                173\n            ]\n        },\n        initialize: function(map) {\n            this._map = map;\n            this._setPanDelta(map.options.keyboardPanDelta);\n            this._setZoomDelta(map.options.zoomDelta);\n        },\n        addHooks: function() {\n            var container = this._map._container;\n            // make the container focusable by tabbing\n            if (container.tabIndex <= 0) {\n                container.tabIndex = \"0\";\n            }\n            on(container, {\n                focus: this._onFocus,\n                blur: this._onBlur,\n                mousedown: this._onMouseDown\n            }, this);\n            this._map.on({\n                focus: this._addHooks,\n                blur: this._removeHooks\n            }, this);\n        },\n        removeHooks: function() {\n            this._removeHooks();\n            off(this._map._container, {\n                focus: this._onFocus,\n                blur: this._onBlur,\n                mousedown: this._onMouseDown\n            }, this);\n            this._map.off({\n                focus: this._addHooks,\n                blur: this._removeHooks\n            }, this);\n        },\n        _onMouseDown: function() {\n            if (this._focused) {\n                return;\n            }\n            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;\n            this._map._container.focus();\n            window.scrollTo(left, top);\n        },\n        _onFocus: function() {\n            this._focused = true;\n            this._map.fire(\"focus\");\n        },\n        _onBlur: function() {\n            this._focused = false;\n            this._map.fire(\"blur\");\n        },\n        _setPanDelta: function(panDelta) {\n            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;\n            for(i = 0, len = codes.left.length; i < len; i++){\n                keys[codes.left[i]] = [\n                    -1 * panDelta,\n                    0\n                ];\n            }\n            for(i = 0, len = codes.right.length; i < len; i++){\n                keys[codes.right[i]] = [\n                    panDelta,\n                    0\n                ];\n            }\n            for(i = 0, len = codes.down.length; i < len; i++){\n                keys[codes.down[i]] = [\n                    0,\n                    panDelta\n                ];\n            }\n            for(i = 0, len = codes.up.length; i < len; i++){\n                keys[codes.up[i]] = [\n                    0,\n                    -1 * panDelta\n                ];\n            }\n        },\n        _setZoomDelta: function(zoomDelta) {\n            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;\n            for(i = 0, len = codes.zoomIn.length; i < len; i++){\n                keys[codes.zoomIn[i]] = zoomDelta;\n            }\n            for(i = 0, len = codes.zoomOut.length; i < len; i++){\n                keys[codes.zoomOut[i]] = -zoomDelta;\n            }\n        },\n        _addHooks: function() {\n            on(document, \"keydown\", this._onKeyDown, this);\n        },\n        _removeHooks: function() {\n            off(document, \"keydown\", this._onKeyDown, this);\n        },\n        _onKeyDown: function(e) {\n            if (e.altKey || e.ctrlKey || e.metaKey) {\n                return;\n            }\n            var key = e.keyCode, map = this._map, offset;\n            if (key in this._panKeys) {\n                if (!map._panAnim || !map._panAnim._inProgress) {\n                    offset = this._panKeys[key];\n                    if (e.shiftKey) {\n                        offset = toPoint(offset).multiplyBy(3);\n                    }\n                    if (map.options.maxBounds) {\n                        offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n                    }\n                    if (map.options.worldCopyJump) {\n                        var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n                        map.panTo(newLatLng);\n                    } else {\n                        map.panBy(offset);\n                    }\n                }\n            } else if (key in this._zoomKeys) {\n                map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n            } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n                map.closePopup();\n            } else {\n                return;\n            }\n            stop(e);\n        }\n    });\n    // @section Handlers\n    // @section Handlers\n    // @property keyboard: Handler\n    // Keyboard navigation handler.\n    Map.addInitHook(\"addHandler\", \"keyboard\", Keyboard);\n    /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Mouse wheel options\n        // @option scrollWheelZoom: Boolean|String = true\n        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n        // it will zoom to the center of the view regardless of where the mouse was.\n        scrollWheelZoom: true,\n        // @option wheelDebounceTime: Number = 40\n        // Limits the rate at which a wheel can fire (in milliseconds). By default\n        // user can't zoom via wheel more often than once per 40 ms.\n        wheelDebounceTime: 40,\n        // @option wheelPxPerZoomLevel: Number = 60\n        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n        // mean a change of one full zoom level. Smaller values will make wheel-zooming\n        // faster (and vice versa).\n        wheelPxPerZoomLevel: 60\n    });\n    var ScrollWheelZoom = Handler.extend({\n        addHooks: function() {\n            on(this._map._container, \"wheel\", this._onWheelScroll, this);\n            this._delta = 0;\n        },\n        removeHooks: function() {\n            off(this._map._container, \"wheel\", this._onWheelScroll, this);\n        },\n        _onWheelScroll: function(e) {\n            var delta = getWheelDelta(e);\n            var debounce = this._map.options.wheelDebounceTime;\n            this._delta += delta;\n            this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n            if (!this._startTime) {\n                this._startTime = +new Date();\n            }\n            var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n            clearTimeout(this._timer);\n            this._timer = setTimeout(bind(this._performZoom, this), left);\n            stop(e);\n        },\n        _performZoom: function() {\n            var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;\n            map._stop(); // stop panning and fly animations if any\n            // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n            this._delta = 0;\n            this._startTime = null;\n            if (!delta) {\n                return;\n            }\n            if (map.options.scrollWheelZoom === \"center\") {\n                map.setZoom(zoom + delta);\n            } else {\n                map.setZoomAround(this._lastMousePos, zoom + delta);\n            }\n        }\n    });\n    // @section Handlers\n    // @property scrollWheelZoom: Handler\n    // Scroll wheel zoom handler.\n    Map.addInitHook(\"addHandler\", \"scrollWheelZoom\", ScrollWheelZoom);\n    /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */ var tapHoldDelay = 600;\n    // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Touch interaction options\n        // @option tapHold: Boolean\n        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n        // @option tapTolerance: Number = 15\n        // The max number of pixels a user can shift his finger during touch\n        // for it to be considered a valid tap.\n        tapTolerance: 15\n    });\n    var TapHold = Handler.extend({\n        addHooks: function() {\n            on(this._map._container, \"touchstart\", this._onDown, this);\n        },\n        removeHooks: function() {\n            off(this._map._container, \"touchstart\", this._onDown, this);\n        },\n        _onDown: function(e) {\n            clearTimeout(this._holdTimeout);\n            if (e.touches.length !== 1) {\n                return;\n            }\n            var first = e.touches[0];\n            this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n            this._holdTimeout = setTimeout(bind(function() {\n                this._cancel();\n                if (!this._isTapValid()) {\n                    return;\n                }\n                // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n                on(document, \"touchend\", preventDefault);\n                on(document, \"touchend touchcancel\", this._cancelClickPrevent);\n                this._simulateEvent(\"contextmenu\", first);\n            }, this), tapHoldDelay);\n            on(document, \"touchend touchcancel contextmenu\", this._cancel, this);\n            on(document, \"touchmove\", this._onMove, this);\n        },\n        _cancelClickPrevent: function cancelClickPrevent() {\n            off(document, \"touchend\", preventDefault);\n            off(document, \"touchend touchcancel\", cancelClickPrevent);\n        },\n        _cancel: function() {\n            clearTimeout(this._holdTimeout);\n            off(document, \"touchend touchcancel contextmenu\", this._cancel, this);\n            off(document, \"touchmove\", this._onMove, this);\n        },\n        _onMove: function(e) {\n            var first = e.touches[0];\n            this._newPos = new Point(first.clientX, first.clientY);\n        },\n        _isTapValid: function() {\n            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n        },\n        _simulateEvent: function(type, e) {\n            var simulatedEvent = new MouseEvent(type, {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                // detail: 1,\n                screenX: e.screenX,\n                screenY: e.screenY,\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            simulatedEvent._simulated = true;\n            e.target.dispatchEvent(simulatedEvent);\n        }\n    });\n    // @section Handlers\n    // @property tapHold: Handler\n    // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n    Map.addInitHook(\"addHandler\", \"tapHold\", TapHold);\n    /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Touch interaction options\n        // @option touchZoom: Boolean|String = *\n        // Whether the map can be zoomed by touch-dragging with two fingers. If\n        // passed `'center'`, it will zoom to the center of the view regardless of\n        // where the touch events (fingers) were. Enabled for touch-capable web\n        // browsers.\n        touchZoom: Browser.touch,\n        // @option bounceAtZoomLimits: Boolean = true\n        // Set it to false if you don't want the map to zoom beyond min/max zoom\n        // and then bounce back when pinch-zooming.\n        bounceAtZoomLimits: true\n    });\n    var TouchZoom = Handler.extend({\n        addHooks: function() {\n            addClass(this._map._container, \"leaflet-touch-zoom\");\n            on(this._map._container, \"touchstart\", this._onTouchStart, this);\n        },\n        removeHooks: function() {\n            removeClass(this._map._container, \"leaflet-touch-zoom\");\n            off(this._map._container, \"touchstart\", this._onTouchStart, this);\n        },\n        _onTouchStart: function(e) {\n            var map = this._map;\n            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n                return;\n            }\n            var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);\n            this._centerPoint = map.getSize()._divideBy(2);\n            this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n            if (map.options.touchZoom !== \"center\") {\n                this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n            }\n            this._startDist = p1.distanceTo(p2);\n            this._startZoom = map.getZoom();\n            this._moved = false;\n            this._zooming = true;\n            map._stop();\n            on(document, \"touchmove\", this._onTouchMove, this);\n            on(document, \"touchend touchcancel\", this._onTouchEnd, this);\n            preventDefault(e);\n        },\n        _onTouchMove: function(e) {\n            if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n                return;\n            }\n            var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;\n            this._zoom = map.getScaleZoom(scale, this._startZoom);\n            if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n                this._zoom = map._limitZoom(this._zoom);\n            }\n            if (map.options.touchZoom === \"center\") {\n                this._center = this._startLatLng;\n                if (scale === 1) {\n                    return;\n                }\n            } else {\n                // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n                var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n                if (scale === 1 && delta.x === 0 && delta.y === 0) {\n                    return;\n                }\n                this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n            }\n            if (!this._moved) {\n                map._moveStart(true, false);\n                this._moved = true;\n            }\n            cancelAnimFrame(this._animRequest);\n            var moveFn = bind(map._move, map, this._center, this._zoom, {\n                pinch: true,\n                round: false\n            }, undefined);\n            this._animRequest = requestAnimFrame(moveFn, this, true);\n            preventDefault(e);\n        },\n        _onTouchEnd: function() {\n            if (!this._moved || !this._zooming) {\n                this._zooming = false;\n                return;\n            }\n            this._zooming = false;\n            cancelAnimFrame(this._animRequest);\n            off(document, \"touchmove\", this._onTouchMove, this);\n            off(document, \"touchend touchcancel\", this._onTouchEnd, this);\n            // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n            if (this._map.options.zoomAnimation) {\n                this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n            } else {\n                this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n            }\n        }\n    });\n    // @section Handlers\n    // @property touchZoom: Handler\n    // Touch zoom handler.\n    Map.addInitHook(\"addHandler\", \"touchZoom\", TouchZoom);\n    Map.BoxZoom = BoxZoom;\n    Map.DoubleClickZoom = DoubleClickZoom;\n    Map.Drag = Drag;\n    Map.Keyboard = Keyboard;\n    Map.ScrollWheelZoom = ScrollWheelZoom;\n    Map.TapHold = TapHold;\n    Map.TouchZoom = TouchZoom;\n    exports1.Bounds = Bounds;\n    exports1.Browser = Browser;\n    exports1.CRS = CRS;\n    exports1.Canvas = Canvas;\n    exports1.Circle = Circle;\n    exports1.CircleMarker = CircleMarker;\n    exports1.Class = Class;\n    exports1.Control = Control;\n    exports1.DivIcon = DivIcon;\n    exports1.DivOverlay = DivOverlay;\n    exports1.DomEvent = DomEvent;\n    exports1.DomUtil = DomUtil;\n    exports1.Draggable = Draggable;\n    exports1.Evented = Evented;\n    exports1.FeatureGroup = FeatureGroup;\n    exports1.GeoJSON = GeoJSON;\n    exports1.GridLayer = GridLayer;\n    exports1.Handler = Handler;\n    exports1.Icon = Icon;\n    exports1.ImageOverlay = ImageOverlay;\n    exports1.LatLng = LatLng;\n    exports1.LatLngBounds = LatLngBounds;\n    exports1.Layer = Layer;\n    exports1.LayerGroup = LayerGroup;\n    exports1.LineUtil = LineUtil;\n    exports1.Map = Map;\n    exports1.Marker = Marker;\n    exports1.Mixin = Mixin;\n    exports1.Path = Path;\n    exports1.Point = Point;\n    exports1.PolyUtil = PolyUtil;\n    exports1.Polygon = Polygon;\n    exports1.Polyline = Polyline;\n    exports1.Popup = Popup;\n    exports1.PosAnimation = PosAnimation;\n    exports1.Projection = index;\n    exports1.Rectangle = Rectangle;\n    exports1.Renderer = Renderer;\n    exports1.SVG = SVG;\n    exports1.SVGOverlay = SVGOverlay;\n    exports1.TileLayer = TileLayer;\n    exports1.Tooltip = Tooltip;\n    exports1.Transformation = Transformation;\n    exports1.Util = Util;\n    exports1.VideoOverlay = VideoOverlay;\n    exports1.bind = bind;\n    exports1.bounds = toBounds;\n    exports1.canvas = canvas;\n    exports1.circle = circle;\n    exports1.circleMarker = circleMarker;\n    exports1.control = control;\n    exports1.divIcon = divIcon;\n    exports1.extend = extend;\n    exports1.featureGroup = featureGroup;\n    exports1.geoJSON = geoJSON;\n    exports1.geoJson = geoJson;\n    exports1.gridLayer = gridLayer;\n    exports1.icon = icon;\n    exports1.imageOverlay = imageOverlay;\n    exports1.latLng = toLatLng;\n    exports1.latLngBounds = toLatLngBounds;\n    exports1.layerGroup = layerGroup;\n    exports1.map = createMap;\n    exports1.marker = marker;\n    exports1.point = toPoint;\n    exports1.polygon = polygon;\n    exports1.polyline = polyline;\n    exports1.popup = popup;\n    exports1.rectangle = rectangle;\n    exports1.setOptions = setOptions;\n    exports1.stamp = stamp;\n    exports1.svg = svg;\n    exports1.svgOverlay = svgOverlay;\n    exports1.tileLayer = tileLayer;\n    exports1.tooltip = tooltip;\n    exports1.transformation = toTransformation;\n    exports1.version = version;\n    exports1.videoOverlay = videoOverlay;\n    var oldL = window.L;\n    exports1.noConflict = function() {\n        window.L = oldL;\n        return this;\n    };\n    // Always export us to window global (see #2364)\n    window.L = exports1;\n}); //# sourceMappingURL=leaflet-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUEsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNBLFFBQVFDLFdBQ3ZFLENBQ3VHO0FBQ3pHLEdBQUcsSUFBSSxFQUFHLFNBQVVBLFFBQU87SUFBSTtJQUU3QixJQUFJTyxVQUFVO0lBRWQ7Ozs7R0FJQyxHQUVELHVEQUF1RDtJQUN2RCx5SUFBeUk7SUFDekksU0FBU0MsT0FBT0MsSUFBSTtRQUNuQixJQUFJQyxHQUFHQyxHQUFHQyxLQUFLQztRQUVmLElBQUtGLElBQUksR0FBR0MsTUFBTUUsVUFBVUMsTUFBTSxFQUFFSixJQUFJQyxLQUFLRCxJQUFLO1lBQ2pERSxNQUFNQyxTQUFTLENBQUNILEVBQUU7WUFDbEIsSUFBS0QsS0FBS0csSUFBSztnQkFDZEosSUFBSSxDQUFDQyxFQUFFLEdBQUdHLEdBQUcsQ0FBQ0gsRUFBRTtZQUNqQjtRQUNEO1FBQ0EsT0FBT0Q7SUFDUjtJQUVBLCtEQUErRDtJQUMvRCx1SUFBdUk7SUFDdkksSUFBSU8sV0FBV0MsT0FBT0MsTUFBTSxJQUFJO1FBQy9CLFNBQVNDLEtBQUs7UUFDZCxPQUFPLFNBQVVDLEtBQUs7WUFDckJELEVBQUVFLFNBQVMsR0FBR0Q7WUFDZCxPQUFPLElBQUlEO1FBQ1o7SUFDRDtJQUVBLDRDQUE0QztJQUM1QyxrTEFBa0w7SUFDbEwsNkJBQTZCO0lBQzdCLFNBQVNHLEtBQUtDLEVBQUUsRUFBRUMsR0FBRztRQUNwQixJQUFJQyxRQUFRQyxNQUFNTCxTQUFTLENBQUNJLEtBQUs7UUFFakMsSUFBSUYsR0FBR0QsSUFBSSxFQUFFO1lBQ1osT0FBT0MsR0FBR0QsSUFBSSxDQUFDSyxLQUFLLENBQUNKLElBQUlFLE1BQU1HLElBQUksQ0FBQ2QsV0FBVztRQUNoRDtRQUVBLElBQUllLE9BQU9KLE1BQU1HLElBQUksQ0FBQ2QsV0FB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TSxHQUFHQTtJQUNqQi9vQyxTQUFROEssS0FBSyxHQUFHRTtJQUNoQmhMLFNBQVFreUMsT0FBTyxHQUFHQTtJQUNsQmx5QyxTQUFROHhDLFFBQVEsR0FBR0E7SUFDbkI5eEMsU0FBUSs0QyxLQUFLLEdBQUdBO0lBQ2hCLzRDLFNBQVFpcUQsU0FBUyxHQUFHQTtJQUNwQmpxRCxTQUFRNkQsVUFBVSxHQUFHQTtJQUNyQjdELFNBQVFnQyxLQUFLLEdBQUdBO0lBQ2hCaEMsU0FBUXFVLEdBQUcsR0FBR0E7SUFDZHJVLFNBQVE0MkMsVUFBVSxHQUFHQTtJQUNyQjUyQyxTQUFRbWtELFNBQVMsR0FBR0E7SUFDcEJua0QsU0FBUWk3QyxPQUFPLEdBQUdBO0lBQ2xCajdDLFNBQVErUSxjQUFjLEdBQUd5QztJQUN6QnhULFNBQVFPLE9BQU8sR0FBR0E7SUFDbEJQLFNBQVF5MkMsWUFBWSxHQUFHQTtJQUV2QixJQUFJbWIsT0FBT3RzRCxPQUFPa0MsQ0FBQztJQUNuQnhILFNBQVE2eEQsVUFBVSxHQUFHO1FBQ3BCdnNELE9BQU9rQyxDQUFDLEdBQUdvcUQ7UUFDWCxPQUFPLElBQUk7SUFDWjtJQUNBLGdEQUFnRDtJQUNoRHRzRCxPQUFPa0MsQ0FBQyxHQUFHeEg7QUFFYixJQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzP2FmNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuOS40LCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHBzOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAyMyBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5sZWFmbGV0ID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjEuOS40XCI7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG4gIFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuICBcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gIFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcbiAgXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuICBcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZGVzdDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG4gIHZhciBjcmVhdGUkMiA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuICBcdGZ1bmN0aW9uIEYoKSB7fVxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG4gIFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuICBcdH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuICAvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG4gIFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICBcdGlmIChmbi5iaW5kKSB7XHJcbiAgXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbiAgLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuICB2YXIgbGFzdElkID0gMDtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbiAgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcbiAgXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuICBcdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4gIC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4gIC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbiAgLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4gIC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuICAvLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcbiAgXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuICBcdFx0bG9jayA9IGZhbHNlO1xyXG4gIFx0XHRpZiAoYXJncykge1xyXG4gIFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICBcdFx0XHRhcmdzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobG9jaykge1xyXG4gIFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG4gIFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuICBcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gIFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG4gIFx0XHRcdGxvY2sgPSB0cnVlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiB3cmFwcGVyRm47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbiAgLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4gIC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gIGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuICBcdHZhciBtYXggPSByYW5nZVsxXSxcclxuICBcdCAgICBtaW4gPSByYW5nZVswXSxcclxuICBcdCAgICBkID0gbWF4IC0gbWluO1xyXG4gIFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuICBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbiAgLy8gVGhlIGRlZmF1bHQgYHByZWNpc2lvbmAgdmFsdWUgaXMgNiBkZWNpbWFsIHBsYWNlcy5cclxuICAvLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuICBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBwcmVjaXNpb24pIHtcclxuICBcdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuICBcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuICBcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuICAvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbiAgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuICBcdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuICBcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG4gIFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlJDIob2JqLm9wdGlvbnMpIDoge307XHJcbiAgXHR9XHJcbiAgXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4gIC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuICAvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbiAgLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuICAvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcbiAgXHR2YXIgcGFyYW1zID0gW107XHJcbiAgXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG4gIFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuICB9XHJcblxyXG4gIHZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4gIC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4gIC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbiAgLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbiAgLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbiAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcbiAgXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHZhbHVlO1xyXG4gIFx0fSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbiAgLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbiAgLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbiAgLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG4gIHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuICAvLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG4gIFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbiAgfVxyXG5cclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuICAvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbiAgZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcbiAgXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG4gIFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcbiAgXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gIFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuICB9XHJcblxyXG4gIHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbiAgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcbiAgXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuICAvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4gIC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuICAvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbiAgLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcbiAgXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcbiAgXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuICAvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuICBcdGlmIChpZCkge1xyXG4gIFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG4gIFx0fVxyXG4gIH1cblxuICB2YXIgVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBiaW5kOiBiaW5kLFxuICAgIGdldCBsYXN0SWQgKCkgeyByZXR1cm4gbGFzdElkOyB9LFxuICAgIHN0YW1wOiBzdGFtcCxcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgd3JhcE51bTogd3JhcE51bSxcbiAgICBmYWxzZUZuOiBmYWxzZUZuLFxuICAgIGZvcm1hdE51bTogZm9ybWF0TnVtLFxuICAgIHRyaW06IHRyaW0sXG4gICAgc3BsaXRXb3Jkczogc3BsaXRXb3JkcyxcbiAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuICAgIGdldFBhcmFtU3RyaW5nOiBnZXRQYXJhbVN0cmluZyxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG4gICAgcmVxdWVzdEZuOiByZXF1ZXN0Rm4sXG4gICAgY2FuY2VsRm46IGNhbmNlbEZuLFxuICAgIHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG4gICAgY2FuY2VsQW5pbUZyYW1lOiBjYW5jZWxBbmltRnJhbWVcbiAgfTtcblxuICAvLyBAY2xhc3MgQ2xhc3NcclxuICAvLyBAYWthIEwuQ2xhc3NcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuICAvLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbiAgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcbiAgXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIFx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuICBcdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcyk7XHJcblxyXG4gIFx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG4gIFx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcbiAgXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcbiAgXHR2YXIgcHJvdG8gPSBjcmVhdGUkMihwYXJlbnRQcm90byk7XHJcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuICBcdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuICBcdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG4gIFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcbiAgXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuICBcdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuICBcdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcbiAgXHRcdGV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcbiAgXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuICBcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuICBcdGRlbGV0ZSBwcm90by5zdGF0aWNzO1xyXG4gIFx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuICBcdC8vIG1lcmdlIG9wdGlvbnNcclxuICBcdGlmIChwcm90by5vcHRpb25zKSB7XHJcbiAgXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gY3JlYXRlJDIocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuICBcdFx0ZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG5cclxuICBcdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcbiAgXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG4gIFx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG4gIFx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiBOZXdDbGFzcztcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbiAgQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gIFx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbiAgXHRpZiAocHJvcHMub3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuICBcdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuICBDbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuICAvLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG4gIENsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuICBcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICBcdH07XHJcblxyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcbiAgXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG4gIFx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuICBcdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0aW5jbHVkZXMgPSBpc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcbiAgXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuICBcdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBFdmVudGVkXHJcbiAgICogQGFrYSBMLkV2ZW50ZWRcclxuICAgKiBAaW5oZXJpdHMgQ2xhc3NcclxuICAgKlxyXG4gICAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAgICogfSApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gICAqXHJcbiAgICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBFdmVudHMgPSB7XHJcbiAgXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIFx0ICovXHJcbiAgXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG4gIFx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG4gIFx0ICovXHJcbiAgXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gIFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0dmFyIHJlbW92ZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRpZiAocmVtb3ZlQWxsKSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSk7XHJcbiAgXHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuICBcdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBfb25jZSkge1xyXG4gIFx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuICBcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuICBcdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcbiAgXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuICBcdFx0aWYgKF9vbmNlKSB7XHJcbiAgXHRcdFx0bmV3TGlzdGVuZXIub25jZSA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuICBcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG4gIFx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChuZXdMaXN0ZW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHR2YXIgbGlzdGVuZXJzLFxyXG4gIFx0XHQgICAgaSxcclxuICBcdFx0ICAgIGxlbjtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyAvLyByZW1vdmUgYWxsXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcbiAgXHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3BcclxuICBcdFx0XHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IGZhbHNlRm47XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuICBcdFx0dmFyIGluZGV4ID0gdGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdGlmIChpbmRleCAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHR2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaW5kZXhdO1xyXG4gIFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG4gIFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0bGlzdGVuZXIuZm4gPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcbiAgXHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBkYXRhXHJcbiAgXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG4gIFx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuICBcdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGV2ZW50ID0gZXh0ZW5kKHt9LCBkYXRhLCB7XHJcbiAgXHRcdFx0dHlwZTogdHlwZSxcclxuICBcdFx0XHR0YXJnZXQ6IHRoaXMsXHJcbiAgXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcbiAgXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG4gIFx0XHRcdFx0XHQvLyBvZmYgb3ZlcndyaXRlcyBsLmZuLCBzbyB3ZSBuZWVkIHRvIGNvcHkgZm4gdG8gYSB2YXJcclxuICBcdFx0XHRcdFx0dmFyIGZuID0gbC5mbjtcclxuICBcdFx0XHRcdFx0aWYgKGwub25jZSkge1xyXG4gIFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIGZuLCBsLmN0eCk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdFx0Zm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcbiAgXHRcdFx0XHR9XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG4gIFx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuICBcdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCdcInN0cmluZ1wiIHR5cGUgYXJndW1lbnQgZXhwZWN0ZWQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbnB1dCBgZm5gIHZhbHVlLCBiZWNhdXNlIHdlIG5lZWQgdG8gdXNlIGl0IGZvciBwcm9wYWdhdGlvblxyXG4gIFx0XHR2YXIgX2ZuID0gZm47XHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRwcm9wYWdhdGUgPSAhIWZuO1xyXG4gIFx0XHRcdF9mbiA9IHVuZGVmaW5lZDtcclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgX2ZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRcdHJldHVybiB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBpbmRleCAobnVtYmVyKSBvciBmYWxzZVxyXG4gIFx0X2xpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuICBcdFx0aWYgKCFmbikge1xyXG4gIFx0XHRcdHJldHVybiAhIWxpc3RlbmVycy5sZW5ndGg7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gaTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuICBcdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG4gIFx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG4gIFx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4sIHRydWUpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0LCB0cnVlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcbiAgXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXSA9IG9iajtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuICBcdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIGV4dGVuZCh7XHJcbiAgXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcbiAgXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuICBcdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuICAvLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG4gIEV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuICAvLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4gIC8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuICBFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG4gIEV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuICAvLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG4gIEV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbiAgLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG4gIEV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuICB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFBvaW50XHJcbiAgICogQGFrYSBMLlBvaW50XHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAgICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcbiAgXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcbiAgXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcbiAgXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcbiAgXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcbiAgXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG4gIH07XHJcblxyXG4gIFBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcbiAgXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuICBcdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcbiAgXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcbiAgXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dGhpcy54IC09IHBvaW50Lng7XHJcbiAgXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggLz0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgLz0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gIFx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHRoaXMueCAqPSBudW07XHJcbiAgXHRcdHRoaXMueSAqPSBudW07XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuICBcdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcbiAgXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG4gIFx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG4gIFx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG4gIFx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcbiAgXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcbiAgXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcbiAgXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuICBcdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG4gIFx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcbiAgXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcbiAgXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG4gIFx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4gIC8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbiAgLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4gIC8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbiAgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG4gIFx0XHRyZXR1cm4geDtcclxuICBcdH1cclxuICBcdGlmIChpc0FycmF5KHgpKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEJvdW5kc1xyXG4gICAqIEBha2EgTC5Cb3VuZHNcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gICAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gICAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuICBcdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBCb3VuZHMucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBtaW4yLCBtYXgyO1xyXG4gIFx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuICBcdFx0XHRtaW4yID0gbWF4MiA9IHRvUG9pbnQob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG4gIFx0XHRcdG1pbjIgPSBvYmoubWluO1xyXG4gIFx0XHRcdG1heDIgPSBvYmoubWF4O1xyXG5cclxuICBcdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuICBcdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gIFx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG4gIFx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gIFx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG4gIFx0XHRcdHRoaXMubWluID0gbWluMi5jbG9uZSgpO1xyXG4gIFx0XHRcdHRoaXMubWF4ID0gbWF4Mi5jbG9uZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihtaW4yLngsIHRoaXMubWluLngpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChtYXgyLngsIHRoaXMubWF4LngpO1xyXG4gIFx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChtYXgyLnksIHRoaXMubWF4LnkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcbiAgXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG4gIFx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBtaW4sIG1heDtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG4gIFx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcbiAgXHRcdFx0bWluID0gb2JqLm1pbjtcclxuICBcdFx0XHRtYXggPSBvYmoubWF4O1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcbiAgXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG4gIFx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuICBcdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcbiAgXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG4gIFx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcbiAgXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG4gIFx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG4gIFx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuICBcdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuICBcdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0bWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKG1pbi54IC0gbWF4LngpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG4gIFx0XHRyZXR1cm4gdG9Cb3VuZHMoXHJcbiAgXHRcdFx0dG9Qb2ludChtaW4ueCAtIGhlaWdodEJ1ZmZlciwgbWluLnkgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLm1pbi5lcXVhbHMoYm91bmRzLmdldFRvcExlZnQoKSkgJiZcclxuICBcdFx0XHR0aGlzLm1heC5lcXVhbHMoYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkpO1xyXG4gIFx0fSxcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbiAgLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gICAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICAgKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICAgKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAuZml0Qm91bmRzKFtcclxuICAgKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gICAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICAgKiBdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuICBcdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0XHRzdzIgPSBvYmo7XHJcbiAgXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuICBcdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcbiAgXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcbiAgXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuICBcdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcbiAgXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuICBcdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG4gIFx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcbiAgXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuICBcdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuICBcdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuICBcdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuICBcdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcbiAgXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG4gIFx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuICBcdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuICBcdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcbiAgXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcbiAgXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuICBcdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG4gIGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuICBcdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbiAgfVxuXG4gIC8qIEBjbGFzcyBMYXRMbmdcclxuICAgKiBAYWthIEwuTGF0TG5nXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICAgKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICAgKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICAgKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuICBcdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcbiAgXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcbiAgXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcbiAgXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG4gIFx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuICBcdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBMYXRMbmcucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG4gIFx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG4gIFx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcbiAgXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG4gIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVycy8yYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcbiAgXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG4gIFx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuICBcdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbiAgLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuICBmdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdGlmIChpc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuICBcdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuICBcdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuICBcdH1cclxuICBcdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZyhhLCBiLCBjKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gICAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gICAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAgICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICAgKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGF0aWFsX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICAgKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAgICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAgICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBDUlMgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG4gIFx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG4gIFx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuICBcdC8vIFRoZSBpbnZlcnNlIG9mIGBsYXRMbmdUb1BvaW50YC4gUHJvamVjdHMgcGl4ZWwgY29vcmRpbmF0ZXMgb24gYSBnaXZlblxyXG4gIFx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuICBcdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG4gIFx0Ly8gdGhpcyBDUlMgKGUuZy4gbWV0ZXJzIGZvciBFUFNHOjM4NTcsIGZvciBwYXNzaW5nIGl0IHRvIFdNUyBzZXJ2aWNlcykuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcbiAgXHQvLyBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBwYXJ0aWN1bGFyIHpvb20uIEZvciBleGFtcGxlLCBpdCByZXR1cm5zXHJcbiAgXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG4gIFx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIEludmVyc2Ugb2YgYHNjYWxlKClgLCByZXR1cm5zIHRoZSB6b29tIGxldmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzY2FsZVxyXG4gIFx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICBcdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIHByb2plY3Rpb24ncyBib3VuZHMgc2NhbGVkIGFuZCB0cmFuc2Zvcm1lZCBmb3IgdGhlIHByb3ZpZGVkIGB6b29tYC5cclxuICBcdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuICBcdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG4gIFx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcbiAgXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuICBcdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcbiAgXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuICBcdC8vXHJcbiAgXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuICBcdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG4gIFx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuICBcdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcbiAgXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG4gIFx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gd3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuICBcdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IHdyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcbiAgXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG4gIFx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdCb3VuZHNgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMud3JhcExhdExuZyhjZW50ZXIpLFxyXG4gIFx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuICBcdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG4gIFx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcclxuICBcdFx0XHRyZXR1cm4gYm91bmRzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuICBcdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG4gIFx0XHQgICAgbmV3TmUgPSBuZXcgTGF0TG5nKG5lLmxhdCAtIGxhdFNoaWZ0LCBuZS5sbmcgLSBsbmdTaGlmdCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG4gIFx0fVxyXG4gIH07XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBDUlNcbiAgICogQGNycyBMLkNSUy5FYXJ0aFxuICAgKlxuICAgKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICAgKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICAgKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogbWV0ZXJzLlxuICAgKi9cblxuICB2YXIgRWFydGggPSBleHRlbmQoe30sIENSUywge1xuICBcdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG4gIFx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcbiAgXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuICBcdC8vIHNlZSBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4gIFx0UjogNjM3MTAwMCxcblxuICBcdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcbiAgXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG4gIFx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuICBcdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG4gIFx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG4gIFx0XHRyZXR1cm4gdGhpcy5SICogYztcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gICAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICAgKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuICB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG4gIFx0UjogZWFydGhSYWRpdXMsXHJcbiAgXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuICBcdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG4gIFx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG4gIFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG4gIFx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcbiAgXHR9KSgpXHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gICAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICAgKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAgICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICAgKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gICAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAgICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0aWYgKGlzQXJyYXkoYSkpIHtcclxuICBcdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuICBcdFx0dGhpcy5fYSA9IGFbMF07XHJcbiAgXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG4gIFx0XHR0aGlzLl9jID0gYVsyXTtcclxuICBcdFx0dGhpcy5fZCA9IGFbM107XHJcbiAgXHRcdHJldHVybjtcclxuICBcdH1cclxuICBcdHRoaXMuX2EgPSBhO1xyXG4gIFx0dGhpcy5fYiA9IGI7XHJcbiAgXHR0aGlzLl9jID0gYztcclxuICBcdHRoaXMuX2QgPSBkO1xyXG4gIH1cclxuXHJcbiAgVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcbiAgXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuICBcdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuICBcdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcbiAgXHRcdHJldHVybiBwb2ludDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuICBcdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcbiAgXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuICAvLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4gIC8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG4gIGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICAgKlxyXG4gICAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gICAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gICAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICAgKi9cclxuXHJcbiAgdmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcbiAgXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xyXG5cclxuICB2YXIgRVBTRzkwMDkxMyA9IGV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuICBcdGNvZGU6ICdFUFNHOjkwMDkxMydcclxuICB9KTtcblxuICAvLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbiAgLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4gIC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbiAgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcbiAgXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xuICB9XG5cbiAgLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4gIC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbiAgLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuICBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuICBcdHZhciBzdHIgPSAnJyxcbiAgXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuICBcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgXHRcdFx0cCA9IHBvaW50c1tqXTtcbiAgXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuICBcdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcbiAgXHR9XG5cbiAgXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuICBcdHJldHVybiBzdHIgfHwgJ00wIDAnO1xuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICAgKiBAYWthIEwuQnJvd3NlclxyXG4gICAqXHJcbiAgICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICAgKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG4gIHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuICB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbiAgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuICAvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuICB2YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4gIC8vICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuICB2YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuICB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbiAgLyogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzk2MTI2NiBmb3IgZGV0YWlscyBvbiBkZXRlY3Rpbmcgc3RvY2sgQW5kcm9pZCAqL1xyXG4gIHZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbiAgdmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG4gIHZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuICAvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuICB2YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG4gIHZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbiAgdmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxuICB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuICB2YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbiAgdmFyIHdpbiA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA9PT0gMDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbiAgdmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbiAgdmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbiAgLy8gKipUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4qKiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbiAgLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4gIC8vIHRvdWNoIGV2ZW50cy5cclxuICB2YXIgdG91Y2hOYXRpdmUgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgISF3aW5kb3cuVG91Y2hFdmVudDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBlaXRoZXIgW3RvdWNoXSgjYnJvd3Nlci10b3VjaCkgb3IgW3BvaW50ZXJdKCNicm93c2VyLXBvaW50ZXIpIGV2ZW50cy5cclxuICAvLyBOb3RlOiBwb2ludGVyIGV2ZW50cyB3aWxsIGJlIHByZWZlcnJlZCAoaWYgYXZhaWxhYmxlKSwgYW5kIHByb2Nlc3NlZCBmb3IgYWxsIGB0b3VjaCpgIGxpc3RlbmVycy5cclxuICB2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuIG9yIG9uIGFueSBzY3JlZW4gd2hlbiBicm93c2VyJ3MgZGlzcGxheSB6b29tIGlzIG1vcmUgdGhhbiAxMDAlLlxyXG4gIHZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbiAgdmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIFx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG4gIFx0dHJ5IHtcclxuICBcdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG4gIFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuICBcdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9KTtcclxuICBcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgZmFsc2VGbiwgb3B0cyk7XHJcbiAgXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxuICB9KCkpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuICB2YXIgY2FudmFzJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gIFx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcclxuICB9KCkpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cclxuICB2YXIgc3ZnJDEgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbiAgdmFyIGlubGluZVN2ZyA9ICEhc3ZnJDEgJiYgKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdGRpdi5pbm5lckhUTUwgPSAnPHN2Zy8+JztcclxuICBcdHJldHVybiAoZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuICB9KSgpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG4gIHZhciB2bWwgPSAhc3ZnJDEgJiYgKGZ1bmN0aW9uICgpIHtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG4gIFx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuICBcdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuICBcdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHR9XHJcbiAgfSgpKTtcclxuXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxuICB2YXIgbWFjID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID09PSAwO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTGludXggcGxhdGZvcm1cclxuICB2YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbiAgZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIHZhciBCcm93c2VyID0ge1xyXG4gIFx0aWU6IGllLFxyXG4gIFx0aWVsdDk6IGllbHQ5LFxyXG4gIFx0ZWRnZTogZWRnZSxcclxuICBcdHdlYmtpdDogd2Via2l0LFxyXG4gIFx0YW5kcm9pZDogYW5kcm9pZCxcclxuICBcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG4gIFx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcbiAgXHRvcGVyYTogb3BlcmEsXHJcbiAgXHRjaHJvbWU6IGNocm9tZSxcclxuICBcdGdlY2tvOiBnZWNrbyxcclxuICBcdHNhZmFyaTogc2FmYXJpLFxyXG4gIFx0cGhhbnRvbTogcGhhbnRvbSxcclxuICBcdG9wZXJhMTI6IG9wZXJhMTIsXHJcbiAgXHR3aW46IHdpbixcclxuICBcdGllM2Q6IGllM2QsXHJcbiAgXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcbiAgXHRnZWNrbzNkOiBnZWNrbzNkLFxyXG4gIFx0YW55M2Q6IGFueTNkLFxyXG4gIFx0bW9iaWxlOiBtb2JpbGUsXHJcbiAgXHRtb2JpbGVXZWJraXQ6IG1vYmlsZVdlYmtpdCxcclxuICBcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcclxuICBcdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG4gIFx0cG9pbnRlcjogcG9pbnRlcixcclxuICBcdHRvdWNoOiB0b3VjaCxcclxuICBcdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuICBcdG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcclxuICBcdG1vYmlsZUdlY2tvOiBtb2JpbGVHZWNrbyxcclxuICBcdHJldGluYTogcmV0aW5hLFxyXG4gIFx0cGFzc2l2ZUV2ZW50czogcGFzc2l2ZUV2ZW50cyxcclxuICBcdGNhbnZhczogY2FudmFzJDEsXHJcbiAgXHRzdmc6IHN2ZyQxLFxyXG4gIFx0dm1sOiB2bWwsXHJcbiAgXHRpbmxpbmVTdmc6IGlubGluZVN2ZyxcclxuICBcdG1hYzogbWFjLFxyXG4gIFx0bGludXg6IGxpbnV4XHJcbiAgfTtcblxuICAvKlxuICAgKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICAgKi9cblxuICB2YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbiAgdmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG4gIHZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbiAgdmFyIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcbiAgdmFyIHBFdmVudCA9IHtcbiAgXHR0b3VjaHN0YXJ0ICA6IFBPSU5URVJfRE9XTixcbiAgXHR0b3VjaG1vdmUgICA6IFBPSU5URVJfTU9WRSxcbiAgXHR0b3VjaGVuZCAgICA6IFBPSU5URVJfVVAsXG4gIFx0dG91Y2hjYW5jZWwgOiBQT0lOVEVSX0NBTkNFTFxuICB9O1xuICB2YXIgaGFuZGxlID0ge1xuICBcdHRvdWNoc3RhcnQgIDogX29uUG9pbnRlclN0YXJ0LFxuICBcdHRvdWNobW92ZSAgIDogX2hhbmRsZVBvaW50ZXIsXG4gIFx0dG91Y2hlbmQgICAgOiBfaGFuZGxlUG9pbnRlcixcbiAgXHR0b3VjaGNhbmNlbCA6IF9oYW5kbGVQb2ludGVyXG4gIH07XG4gIHZhciBfcG9pbnRlcnMgPSB7fTtcbiAgdmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuICAvLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4gIC8vIHJlZiBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG4gIGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcbiAgXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gIFx0XHRfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCk7XG4gIFx0fVxuICBcdGlmICghaGFuZGxlW3R5cGVdKSB7XG4gIFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcbiAgXHRcdHJldHVybiBmYWxzZUZuO1xuICBcdH1cbiAgXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIFx0cmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG4gIFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuICBcdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG4gIFx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcbiAgXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG4gIFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG4gIFx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG4gIFx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG4gIFx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG4gIFx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG4gIFx0ZS50b3VjaGVzID0gW107XG4gIFx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcbiAgXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG4gIFx0fVxuICBcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cbiAgXHRoYW5kbGVyKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcbiAgXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcbiAgXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9XG4gIFx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG4gIH1cblxuICAvKlxyXG4gICAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICAgKlxyXG4gICAqIE5vdGU6IGN1cnJlbnRseSBtb3N0IGJyb3dzZXJzIGZpcmUgbmF0aXZlIGRibGNsaWNrLCB3aXRoIG9ubHkgYSBmZXcgZXhjZXB0aW9uc1xyXG4gICAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBtYWtlRGJsY2xpY2soZXZlbnQpIHtcclxuICBcdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG4gIFx0dmFyIG5ld0V2ZW50ID0ge30sXHJcbiAgXHQgICAgcHJvcCwgaTtcclxuICBcdGZvciAoaSBpbiBldmVudCkge1xyXG4gIFx0XHRwcm9wID0gZXZlbnRbaV07XHJcbiAgXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuICBcdH1cclxuICBcdGV2ZW50ID0gbmV3RXZlbnQ7XHJcbiAgXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuICBcdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcbiAgXHRuZXdFdmVudC5pc1RydXN0ZWQgPSBmYWxzZTtcclxuICBcdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuICBcdHJldHVybiBuZXdFdmVudDtcclxuICB9XHJcblxyXG4gIHZhciBkZWxheSA9IDIwMDtcclxuICBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpIHtcclxuICBcdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuICBcdC8vIE9uIHNvbWUgcGxhdGZvcm1zIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSBuYXRpdmUgZGJsY2xpY2tzIGZvciB0b3VjaCBldmVudHMuXHJcbiAgXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuICBcdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcbiAgXHR2YXIgbGFzdCA9IDAsXHJcbiAgXHQgICAgZGV0YWlsO1xyXG4gIFx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG4gIFx0XHRpZiAoZS5kZXRhaWwgIT09IDEpIHtcclxuICBcdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcbiAgXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIFdoZW4gY2xpY2tpbmcgb24gYW4gPGlucHV0PiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGEgY2xpY2sgb24gaXRzXHJcbiAgXHRcdC8vIDxsYWJlbD4gKGFuZCB2aWNlIHZlcnNhKSB0cmlnZ2VyaW5nIHR3byBjbGlja3MgaW4gcXVpY2sgc3VjY2Vzc2lvbi5cclxuICBcdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuICBcdFx0Ly8gYXR0cmlidXRlIChvciBjaGlsZHJlbiBvZiBzdWNoIGEgbGFiZWwpLCBidXQgbm90IGNoaWxkcmVuIG9mXHJcbiAgXHRcdC8vIGEgPGlucHV0Pi5cclxuICBcdFx0dmFyIHBhdGggPSBnZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcbiAgXHRcdGlmIChwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTExhYmVsRWxlbWVudCAmJiBlbC5hdHRyaWJ1dGVzLmZvcjtcclxuICBcdFx0fSkgJiZcclxuICBcdFx0XHQhcGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIChcclxuICBcdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcbiAgXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnRcclxuICBcdFx0XHRcdCk7XHJcbiAgXHRcdFx0fSlcclxuICBcdFx0KSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICBcdFx0aWYgKG5vdyAtIGxhc3QgPD0gZGVsYXkpIHtcclxuICBcdFx0XHRkZXRhaWwrKztcclxuICBcdFx0XHRpZiAoZGV0YWlsID09PSAyKSB7XHJcbiAgXHRcdFx0XHRoYW5kbGVyKG1ha2VEYmxjbGljayhlKSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGRldGFpbCA9IDE7XHJcbiAgXHRcdH1cclxuICBcdFx0bGFzdCA9IG5vdztcclxuICBcdH1cclxuXHJcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0ZGJsY2xpY2s6IGhhbmRsZXIsXHJcbiAgXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcnMpIHtcclxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXJzLmRibGNsaWNrKTtcclxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICAgKlxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICAgKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKlxyXG4gICAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICAgKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAgICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbiAgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG4gIFx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuICAvLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbiAgLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG4gIHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcbiAgXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG4gIHZhciBUUkFOU0lUSU9OX0VORCA9XHJcbiAgXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbiAgLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuICBmdW5jdGlvbiBnZXQoaWQpIHtcclxuICBcdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuICAvLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbiAgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcbiAgXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcbiAgXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG4gIFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcbiAgXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuICBmdW5jdGlvbiBjcmVhdGUkMSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG4gIFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICBcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcbiAgXHRpZiAoY29udGFpbmVyKSB7XHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZWw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuICBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCkge1xyXG4gIFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbiAgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuICBcdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcbiAgXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbiAgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcbiAgXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbiAgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcbiAgXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG4gIFx0fVxyXG4gIFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuICBcdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHR2YXIgY2xhc3NlcyA9IHNwbGl0V29yZHMobmFtZSk7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcbiAgXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRzZXRDbGFzcyhlbCwgdHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbiAgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcbiAgXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuICAvLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuICBcdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcbiAgXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcbiAgXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuICBcdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuICBcdH1cclxuICBcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuICAvLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuICAvLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbiAgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuICBcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuICBcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG4gIFx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG4gIFx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG4gIFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG4gIFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuICBcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gIFx0dHJ5IHtcclxuICBcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuICBcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuICBcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG4gIFx0fVxyXG5cclxuICBcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG4gIFx0aWYgKGZpbHRlcikge1xyXG4gIFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuICBcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbiAgLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4gIC8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbiAgLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbiAgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuICBcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG4gIFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4gIC8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4gIC8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG4gIGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG4gIFx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG4gIFx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcbiAgXHRcdChCcm93c2VyLmllM2QgP1xyXG4gIFx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuICBcdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuICBcdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbiAgLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuICAvLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4gIC8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuICBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcbiAgXHQvKmVzbGludC1kaXNhYmxlICovXHJcbiAgXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuICBcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG4gIFx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuICBcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcbiAgXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuICBcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG4gIFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbiAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuICAvLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbiAgLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBfdXNlclNlbGVjdDtcclxuICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0fTtcclxuICB9IGVsc2Uge1xyXG4gIFx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG4gIFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICBcdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcbiAgXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuICBcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICBcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4gIC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuICAvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuICBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b24od2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIHZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbiAgLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4gIC8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbiAgLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4gIC8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuICBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcbiAgXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuICBcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICBcdH1cclxuICBcdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuICBcdHJlc3RvcmVPdXRsaW5lKCk7XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlO1xyXG4gIFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcbiAgXHRvbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG4gIGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG4gIFx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gX291dGxpbmVTdHlsZTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICBcdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgXHRvZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuICBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG4gIFx0ZG8ge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcbiAgXHRyZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuICAvLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4gIC8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG4gIGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuICBcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG4gIFx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcbiAgXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG4gIFx0fTtcclxuICB9XG5cbiAgdmFyIERvbVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFRSQU5TRk9STTogVFJBTlNGT1JNLFxuICAgIFRSQU5TSVRJT046IFRSQU5TSVRJT04sXG4gICAgVFJBTlNJVElPTl9FTkQ6IFRSQU5TSVRJT05fRU5ELFxuICAgIGdldDogZ2V0LFxuICAgIGdldFN0eWxlOiBnZXRTdHlsZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICB0b0Zyb250OiB0b0Zyb250LFxuICAgIHRvQmFjazogdG9CYWNrLFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgIHNldENsYXNzOiBzZXRDbGFzcyxcbiAgICBnZXRDbGFzczogZ2V0Q2xhc3MsXG4gICAgc2V0T3BhY2l0eTogc2V0T3BhY2l0eSxcbiAgICB0ZXN0UHJvcDogdGVzdFByb3AsXG4gICAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG4gICAgc2V0UG9zaXRpb246IHNldFBvc2l0aW9uLFxuICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcbiAgICBnZXQgZGlzYWJsZVRleHRTZWxlY3Rpb24gKCkgeyByZXR1cm4gZGlzYWJsZVRleHRTZWxlY3Rpb247IH0sXG4gICAgZ2V0IGVuYWJsZVRleHRTZWxlY3Rpb24gKCkgeyByZXR1cm4gZW5hYmxlVGV4dFNlbGVjdGlvbjsgfSxcbiAgICBkaXNhYmxlSW1hZ2VEcmFnOiBkaXNhYmxlSW1hZ2VEcmFnLFxuICAgIGVuYWJsZUltYWdlRHJhZzogZW5hYmxlSW1hZ2VEcmFnLFxuICAgIHByZXZlbnRPdXRsaW5lOiBwcmV2ZW50T3V0bGluZSxcbiAgICByZXN0b3JlT3V0bGluZTogcmVzdG9yZU91dGxpbmUsXG4gICAgZ2V0U2l6ZWRQYXJlbnROb2RlOiBnZXRTaXplZFBhcmVudE5vZGUsXG4gICAgZ2V0U2NhbGU6IGdldFNjYWxlXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICovXHJcblxyXG4gIC8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4gIC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbiAgLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbiAgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0fVxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuICAvLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbiAgLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nKTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIG9mIGdpdmVuIHR5cGVzLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBmcm9tIGdpdmVuIEhUTUxFbGVtZW50XHJcbiAgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICBcdFx0YmF0Y2hSZW1vdmUob2JqKTtcclxuICBcdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cclxuICBcdH0gZWxzZSBpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0fVxyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gIFx0XHRcdGJhdGNoUmVtb3ZlKG9iaiwgZnVuY3Rpb24gKHR5cGUpIHtcclxuICBcdFx0XHRcdHJldHVybiBpbmRleE9mKHR5cGVzLCB0eXBlKSAhPT0gLTE7XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmF0Y2hSZW1vdmUob2JqLCBmaWx0ZXJGbikge1xyXG4gIFx0Zm9yICh2YXIgaWQgaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuICBcdFx0dmFyIHR5cGUgPSBpZC5zcGxpdCgvXFxkLylbMF07XHJcbiAgXHRcdGlmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4odHlwZSkpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCBudWxsLCBudWxsLCBpZCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XHJcblxyXG4gIHZhciBtb3VzZVN1YnN0ID0ge1xyXG4gIFx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcbiAgXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG4gIFx0d2hlZWw6ICEoJ29ud2hlZWwnIGluIHdpbmRvdykgJiYgJ21vdXNld2hlZWwnXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdHZhciBpZCA9IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuICBcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICBcdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcbiAgXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuICBcdFx0aGFuZGxlciA9IGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuICBcdFx0aGFuZGxlciA9IGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xyXG4gIFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG4gIFx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG4gIFx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fTtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9yaWdpbmFsSGFuZGxlciwgZmFsc2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG4gIFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0LCBpZCkge1xyXG4gIFx0aWQgPSBpZCB8fCB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuICBcdHZhciBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuICBcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcbiAgXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuICBcdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcbiAgXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4gIC8vIGBgYGpzXHJcbiAgLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gIC8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4gIC8vIH0pO1xyXG4gIC8vIGBgYFxyXG4gIGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG4gIFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG4gIFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnd2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcbiAgXHRhZGRPbmUoZWwsICd3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkYmxjbGljaydgLCBgJ2NvbnRleHRtZW51J2AsXHJcbiAgLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcbiAgXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrIGNvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10gPSB0cnVlO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuICAvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbiAgLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuICAvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcbiAgXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gIFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgZnVuY3Rpb24gc3RvcChlKSB7XHJcbiAgXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldjogRE9NRXZlbnQpOiBBcnJheVxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtgRXZlbnQuY29tcG9zZWRQYXRoKClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvY29tcG9zZWRQYXRoKS5cclxuICAvLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGBIVE1MRWxlbWVudGBzIHRoYXQgdGhlIGdpdmVuIERPTSBldmVudFxyXG4gIC8vIHNob3VsZCBwcm9wYWdhdGUgdG8gKGlmIG5vdCBzdG9wcGVkKS5cclxuICBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXYpIHtcclxuICBcdGlmIChldi5jb21wb3NlZFBhdGgpIHtcclxuICBcdFx0cmV0dXJuIGV2LmNvbXBvc2VkUGF0aCgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBwYXRoID0gW107XHJcbiAgXHR2YXIgZWwgPSBldi50YXJnZXQ7XHJcblxyXG4gIFx0d2hpbGUgKGVsKSB7XHJcbiAgXHRcdHBhdGgucHVzaChlbCk7XHJcbiAgXHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdH1cclxuICBcdHJldHVybiBwYXRoO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4gIC8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4gIC8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuICBcdGlmICghY29udGFpbmVyKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcbiAgXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuICBcdHJldHVybiBuZXcgUG9pbnQoXHJcbiAgXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuICBcdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcbiAgXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcbiAgXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcbiAgXHQpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vICBleGNlcHQgLCBTYWZhcmkgYW5kXHJcbiAgLy8gV2UgbmVlZCBkb3VibGUgdGhlIHNjcm9sbCBwaXhlbHMgKHNlZSAjNzQwMyBhbmQgIzQ1MzgpIGZvciBhbGwgQnJvd3NlcnNcclxuICAvLyBleGNlcHQgT1NYIChNYWMpIC0+IDN4LCBDaHJvbWUgcnVubmluZyBvbiBMaW51eCAxeFxyXG5cclxuICB2YXIgd2hlZWxQeEZhY3RvciA9XHJcbiAgXHQoQnJvd3Nlci5saW51eCAmJiBCcm93c2VyLmNocm9tZSkgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcbiAgXHRCcm93c2VyLm1hYyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMyA6XHJcbiAgXHR3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDAgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG4gIC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4gIC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4gIC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4gIC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbiAgLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuICBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuICBcdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG4gIFx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG4gIFx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuICBcdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcbiAgXHQgICAgICAgMDtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG4gIGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcbiAgXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcbiAgXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgXHR0cnkge1xyXG4gIFx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcbiAgXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSBjYXRjaCAoZXJyKSB7XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH1cclxuICBcdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG4gIH1cblxuICB2YXIgRG9tRXZlbnQgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICBzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcbiAgICBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbixcbiAgICBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjogZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24sXG4gICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuICAgIHN0b3A6IHN0b3AsXG4gICAgZ2V0UHJvcGFnYXRpb25QYXRoOiBnZXRQcm9wYWdhdGlvblBhdGgsXG4gICAgZ2V0TW91c2VQb3NpdGlvbjogZ2V0TW91c2VQb3NpdGlvbixcbiAgICBnZXRXaGVlbERlbHRhOiBnZXRXaGVlbERlbHRhLFxuICAgIGlzRXh0ZXJuYWxUYXJnZXQ6IGlzRXh0ZXJuYWxUYXJnZXQsXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIHJlbW92ZUxpc3RlbmVyOiBvZmZcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gICAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogbXlQb3NpdGlvbk1hcmtlci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICAgKiBcdHBvcy55IC09IDI1O1xuICAgKiBcdHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICAgKlxuICAgKiBcdGZ4Lm9uY2UoJ2VuZCcsZnVuY3Rpb24oKSB7XG4gICAqIFx0XHRwb3MueSArPSAyNTtcbiAgICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gICAqIFx0fSk7XG4gICAqXG4gICAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAgICogfSk7XG4gICAqXG4gICAqIGBgYFxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICAgKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKi9cblxuICB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG4gIFx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcbiAgXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG4gIFx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG4gIFx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuICBcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuICBcdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG4gIFx0XHR0aGlzLnN0b3AoKTtcblxuICBcdFx0dGhpcy5fZWwgPSBlbDtcbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuICBcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuICBcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcbiAgXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICBcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG4gIFx0XHR0aGlzLl9hbmltYXRlKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc3RvcCgpXG4gIFx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fc3RlcCh0cnVlKTtcbiAgXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBhbmltYXRpb24gbG9vcFxuICBcdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgXHRcdHRoaXMuX3N0ZXAoKTtcbiAgXHR9LFxuXG4gIFx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuICBcdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuICBcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG4gIFx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG4gIFx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuICBcdFx0aWYgKHJvdW5kKSB7XG4gIFx0XHRcdHBvcy5fcm91bmQoKTtcbiAgXHRcdH1cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuICBcdH0sXG5cbiAgXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG4gIFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuICBcdH0sXG5cbiAgXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuICBcdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG4gIFx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuICBcdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuICBcdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG4gIFx0XHRsYXllcnM6IFtdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuICBcdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG4gIFx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG4gIFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuICBcdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG4gIFx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcbiAgXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG4gIFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG4gIFx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG4gIFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG4gIFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG4gIFx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG4gIFx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG4gIFx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG4gIFx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcbiAgXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG4gIFx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcbiAgXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHR6b29tU25hcDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuICBcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuICBcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuICBcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG4gIFx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG4gIFx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuICBcdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuICBcdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG4gIFx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG4gIFx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuICBcdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuICBcdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcbiAgXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuICBcdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG4gIFx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnBhbiA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuICBcdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG4gIFx0XHRcdGlmIChtb3ZlZCkge1xyXG4gIFx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcbiAgXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuICBcdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuICBcdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuICBcdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG4gIFx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuICBcdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuICBcdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuICBcdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG4gIFx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuICBcdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcbiAgXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG4gIFx0XHRcdHJldHVybiB7XHJcbiAgXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0XHR9O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuICBcdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcbiAgXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuICBcdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuICBcdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG4gIFx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuICBcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcbiAgXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuICBcdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuICBcdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuICBcdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG4gIFx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuICBcdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuICBcdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG4gIFx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuICBcdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuICBcdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG4gIFx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG4gIFx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcbiAgXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuICBcdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG4gIFx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuICBcdFx0ICAgIHJobyA9IDEuNDIsXHJcbiAgXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gcihpKSB7XHJcbiAgXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuICBcdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuICBcdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG4gIFx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuICBcdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcbiAgXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuICBcdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG4gIFx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG4gIFx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcbiAgXHRcdFx0cmV0dXJuIGxvZztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gIFx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcbiAgXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG4gIFx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuICBcdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcbiAgXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcbiAgXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcbiAgXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcbiAgXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG4gIFx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG4gIFx0XHRcdGlmICh0IDw9IDEpIHtcclxuICBcdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcbiAgXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG4gIFx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG4gIFx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcbiAgXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhpc1xyXG4gIFx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG4gIFx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG4gIFx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG4gIFx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG4gIFx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuICBcdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMubGlzdGVucygnbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcykpIHtcclxuICBcdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG4gIFx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuICBcdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG4gIFx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuICBcdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG4gIFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG4gIFx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG4gIFx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IHBhZGRpbmcgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcbiAgXHQvLyBwYWRkaW5nIG9wdGlvbnMgdG8gZml0IHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMuXHJcbiAgXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuICBcdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG4gIFx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuICBcdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKSxcclxuICBcdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuICBcdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuICBcdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG4gIFx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcbiAgXHRcdFx0dmFyIG9mZnNldCA9IHBhZGRlZEJvdW5kcy5leHRlbmQocGl4ZWxQb2ludCkuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRlZFNpemUpO1xyXG4gIFx0XHRcdHBpeGVsQ2VudGVyLnggKz0gY2VudGVyT2Zmc2V0LnggPCAwID8gLW9mZnNldC54IDogb2Zmc2V0Lng7XHJcbiAgXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuICBcdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KHBpeGVsQ2VudGVyKSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuICBcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG4gIFx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuICBcdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG4gIFx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuICBcdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuICBcdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcbiAgXHRcdFx0cGFuOiB0cnVlXHJcbiAgXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcbiAgXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG4gIFx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG4gIFx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcbiAgXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuICBcdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG4gIFx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcbiAgXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG4gIFx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG4gIFx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG4gIFx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG4gIFx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuICBcdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuICBcdFx0XHR3YXRjaDogZmFsc2VcclxuICBcdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG4gIFx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcbiAgXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG4gIFx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuICBcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuICBcdFx0XHRcdGNvZGU6IDAsXHJcbiAgXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvblJlc3BvbnNlID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuICBcdFx0ICAgIG9uRXJyb3IgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG4gIFx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuICBcdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG4gIFx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcbiAgXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuICBcdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG4gIFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuICBcdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcbiAgXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcbiAgXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcbiAgXHRcdFx0Y29kZTogYyxcclxuICBcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG4gIFx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcbiAgXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuICBcdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG4gIFx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcbiAgXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcbiAgXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuICBcdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcbiAgXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcbiAgXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gIFx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG4gIFx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuICBcdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7IHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dHJ5IHtcclxuICBcdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuICBcdFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG4gIFx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG4gIFx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcbiAgXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcbiAgXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG4gIFx0XHQgICAgcGFuZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcbiAgXHRcdGlmIChuYW1lKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyLmNsb25lKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcbiAgXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuICBcdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcbiAgXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcbiAgXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcbiAgXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuICBcdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuICBcdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG4gIFx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcbiAgXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG4gIFx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG4gIFx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG4gIFx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG4gIFx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcbiAgXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuICBcdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuICBcdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG4gIFx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcbiAgXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG4gIFx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG4gIFx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG4gIFx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcbiAgXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG4gIFx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG4gIFx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcbiAgXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcbiAgXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuICBcdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcbiAgXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuICBcdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcbiAgXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuICBcdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG4gIFx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG4gIFx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuICBcdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuICBcdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG4gIFx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuICBcdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcbiAgXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG4gIFx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG4gIFx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuICBcdFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gc3RhbXAoY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcbiAgXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG4gIFx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG4gIFx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG4gIFx0XHR2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuICBcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG4gIFx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcbiAgXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcbiAgXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG4gIFx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG4gIFx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG4gIFx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuICBcdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG4gIFx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuICBcdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub01vdmVTdGFydCkge1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuICBcdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG4gIFx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG4gIFx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuICBcdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcbiAgXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcbiAgXHRcdHRoaXNcclxuICBcdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpXHJcbiAgXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuICBcdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuICBcdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG4gIFx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG4gIFx0XHRpZiAobG9hZGluZykge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcbiAgXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhLCBzdXByZXNzRXZlbnQpIHtcclxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG4gIFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuICBcdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuICBcdFx0aWYgKCFzdXByZXNzRXZlbnQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcbiAgXHRcdFx0Ly8gaW5jbHVkaW5nIHpvb20gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcbiAgXHRcdFx0Ly8gaW5jbHVkaW5nIHBhbiBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuICBcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG4gIFx0XHQvLyAoZS5nLiB1c2VyIHN0b3BwZWQgZHJhZ2dpbmcgdGhlIG1hcCBvciBhZnRlciBub24tY2VudGVyZWQgem9vbSkuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG4gIFx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcbiAgXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcbiAgXHRcdHRoaXMuX3RhcmdldHNbc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuICBcdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gb2ZmIDogb247XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG4gIFx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcbiAgXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuICBcdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG4gIFx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuICBcdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG4gIFx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuICBcdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG4gIFx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuICBcdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG4gIFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZShcclxuICBcdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcbiAgXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuICBcdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcbiAgXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwczovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG4gIFx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG4gIFx0XHQgICAgdGFyZ2V0LFxyXG4gIFx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcbiAgXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcbiAgXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICBcdFx0d2hpbGUgKHNyYykge1xyXG4gIFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbc3RhbXAoc3JjKV07XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcbiAgXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuICBcdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuICBcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICBcdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIHRoaXMubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRhcmdldHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pc0NsaWNrRGlzYWJsZWQ6IGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHR3aGlsZSAoZWwgJiYgZWwgIT09IHRoaXMuX2NvbnRhaW5lcikge1xyXG4gIFx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgXHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIGVsID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xyXG4gIFx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKGVsKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG4gIFx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIGNhbnZhc1RhcmdldHMpIHtcclxuXHJcbiAgXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuICBcdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuICBcdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG4gIFx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG4gIFx0XHRcdHZhciBzeW50aCA9IGV4dGVuZCh7fSwgZSk7XHJcbiAgXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcbiAgXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG4gIFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG4gIFx0XHRpZiAoY2FudmFzVGFyZ2V0cykge1xyXG4gIFx0XHRcdHZhciBmaWx0ZXJlZCA9IFtdOyAvLyBwaWNrIG9ubHkgdGFyZ2V0cyB3aXRoIGxpc3RlbmVyc1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdFx0aWYgKGNhbnZhc1RhcmdldHNbaV0ubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGNhbnZhc1RhcmdldHNbaV0pO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHR0YXJnZXRzID0gZmlsdGVyZWQuY29uY2F0KHRhcmdldHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuICBcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcbiAgXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcclxuICBcdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG4gIFx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG4gIFx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcbiAgXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG4gIFx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuICBcdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG4gIFx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcbiAgXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuICBcdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuICBcdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG4gIFx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIGdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcbiAgXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuICBcdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcbiAgXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG4gIFx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG4gIFx0XHRdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcbiAgXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcbiAgXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG4gIFx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG4gIFx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuICBcdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG4gIFx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuICBcdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSA8PSAxICYmIE1hdGguYWJzKG9mZnNldC55KSA8PSAxKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG4gIFx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuICBcdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcbiAgXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuICBcdFx0ICAgICksXHJcbiAgXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcbiAgXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG4gIFx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG4gIFx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuICBcdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuICBcdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcbiAgXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcbiAgXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gIFx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuICBcdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG4gIFx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0dmFyIHByb3AgPSBUUkFOU0ZPUk0sXHJcbiAgXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG4gIFx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcbiAgXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9wcm94eSk7XHJcbiAgXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuICBcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG4gIFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG4gIFx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHR0aGlzXHJcbiAgXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQgfHwgZmFsc2UpXHJcbiAgXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChzdGFydEFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuICBcdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuICBcdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuICBcdFx0XHR6b29tOiB6b29tLFxyXG4gIFx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLl90ZW1wRmlyZVpvb21FdmVudCA9IHRoaXMuX3pvb20gIT09IHRoaXMuX2FuaW1hdGVUb1pvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuICBcdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG4gIFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0ZGVsZXRlIHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50O1xyXG5cclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4gIC8vXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sXHJcbiAgICogQGFrYSBMLkNvbnRyb2xcclxuICAgKiBAaW5oZXJpdHMgQ2xhc3NcclxuICAgKlxyXG4gICAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAgICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAgICovXHJcblxyXG4gIHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wgT3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcbiAgXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcbiAgXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuICBcdCAqXHJcbiAgXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuICBcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0ICovXHJcbiAgXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuICBcdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG4gIFx0XHRpZiAobWFwKSB7XHJcbiAgXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMucmVtb3ZlKCk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcbiAgXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcbiAgXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcbiAgXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcbiAgXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG4gIFx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG4gIFx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbiAgfTtcclxuXHJcbiAgLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICAgKiBAdW5pbmhlcml0YWJsZVxyXG4gICAqXHJcbiAgICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gICAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICAgKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAgICovXHJcblxyXG4gIC8qIEBuYW1lc3BhY2UgTWFwXHJcbiAgICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gICAqL1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcbiAgXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG4gIFx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICBcdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcbiAgXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG4gIFx0XHQgICAgICAgICAgICBjcmVhdGUkMSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcbiAgXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcbiAgXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gICAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAgICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAgICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIHZhciBvdmVybGF5cyA9IHtcclxuICAgKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICAgKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XHJcbiAgICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gICAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuICBcdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuICBcdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG4gIFx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG4gIFx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcbiAgXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG4gIFx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG4gIFx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcbiAgXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuICBcdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG4gIFx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuICBcdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcbiAgXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuICBcdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChsYXllcikpO1xyXG4gIFx0XHRpZiAob2JqKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuICBcdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG4gIFx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuICBcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG4gIFx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG4gIFx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuICBcdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuICBcdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcclxuICBcdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG4gIFx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcbiAgXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuICBcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gY3JlYXRlJDEoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcbiAgXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRcdG9uKGNvbnRhaW5lciwge1xyXG4gIFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5fZXhwYW5kU2FmZWx5LFxyXG4gIFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuICBcdFx0b24obGluaywge1xyXG4gIFx0XHRcdGtleWRvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9LFxyXG4gIFx0XHRcdC8vIENlcnRhaW4gc2NyZWVuIHJlYWRlcnMgaW50ZXJjZXB0IHRoZSBrZXkgZXZlbnQgYW5kIGluc3RlYWQgc2VuZCBhIGNsaWNrIGV2ZW50XHJcbiAgXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuICBcdFx0XHRsYXllcjogbGF5ZXIsXHJcbiAgXHRcdFx0bmFtZTogbmFtZSxcclxuICBcdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG4gIFx0XHRcdH0sIHRoaXMpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuICBcdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuICBcdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcbiAgXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcbiAgXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG4gIFx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcbiAgXHRcdGlmICh0eXBlKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcbiAgXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuICBcdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG4gIFx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuICBcdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG4gIFx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG4gIFx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG4gIFx0XHQgICAgaW5wdXQ7XHJcblxyXG4gIFx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuICBcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcbiAgXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG4gIFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcbiAgXHRcdGlucHV0LmxheWVySWQgPSBzdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuICBcdFx0b24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICBcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcbiAgXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcbiAgXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG4gIFx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIGxhYmVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG4gIFx0XHRpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG4gIFx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuICBcdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG4gIFx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuICBcdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuICBcdFx0ICAgIGlucHV0LFxyXG4gIFx0XHQgICAgbGF5ZXIsXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICBcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG4gIFx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcbiAgXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZFNhZmVseTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcbiAgXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XHJcbiAgXHRcdG9uKHNlY3Rpb24sICdjbGljaycsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG4gIFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRvZmYoc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdHRoYXQuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG4gIHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gICAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqL1xyXG5cclxuICB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPidcclxuICBcdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG4gIFx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG4gIFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuICBcdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcbiAgXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuICBcdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG4gIFx0XHR2YXIgbGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG4gIFx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuICBcdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuICBcdFx0LypcclxuICBcdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuICBcdFx0ICovXHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBzdG9wKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxpbms7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcbiAgXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbiAgLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdHpvb21Db250cm9sOiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcbiAgXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcbiAgXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcbiAgXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG4gIFx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuICBcdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuICB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICAgKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxuICAgKlxuICAgKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG4gIFx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cbiAgXHRcdG1heFdpZHRoOiAxMDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG4gIFx0XHRtZXRyaWM6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cbiAgXHRcdGltcGVyaWFsOiB0cnVlXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpLFxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG4gIFx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuICBcdFx0cmV0dXJuIGNvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcbiAgXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuICBcdFx0XHR0aGlzLl9tU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcbiAgXHRcdFx0dGhpcy5faVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuICBcdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcbiAgXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcbiAgXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuICBcdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuICBcdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuICBcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcbiAgXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cbiAgXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuICBcdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuICBcdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcbiAgXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuICBcdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcbiAgXHR9LFxuXG4gIFx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG4gIFx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcbiAgXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cbiAgXHRcdGQgPSBkID49IDEwID8gMTAgOlxuICBcdFx0ICAgIGQgPj0gNSA/IDUgOlxuICBcdFx0ICAgIGQgPj0gMyA/IDMgOlxuICBcdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG4gIFx0XHRyZXR1cm4gcG93MTAgKiBkO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZ3xmYWxzZSA9ICdMZWFmbGV0J1xyXG4gIFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG4gIFx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0bWFwLm9uKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkQXR0cmlidXRpb246IGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdGV2LmxheWVyLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcbiAgXHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG4gIFx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuICBcdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcbiAgXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuICBcdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG4gIFx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcbiAgXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+fDwvc3Bhbj4gJyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbiAgLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG4gIFx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbiAgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbiAgfTtcblxuICBDb250cm9sLkxheWVycyA9IExheWVycztcbiAgQ29udHJvbC5ab29tID0gWm9vbTtcbiAgQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuICBDb250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbiAgY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG4gIGNvbnRyb2wuem9vbSA9IHpvb207XG4gIGNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbiAgY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG4gIC8qXG4gIFx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3RcbiAgXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiAgKi9cblxuICAvLyBAY2xhc3MgSGFuZGxlclxuICAvLyBAYWthIEwuSGFuZGxlclxuICAvLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbiAgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuICBcdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5hZGRIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuICBcdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG4gIFx0fVxuXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuICBcdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuICBcdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuICAvLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbiAgLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIERyYWdnYWJsZVxyXG4gICAqIEBha2EgTC5EcmFnZ2FibGVcclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gICAqXHJcbiAgICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gICAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICAgKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBTVEFSVCA9IEJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcblxyXG4gIHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvblxyXG4gIFx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuICBcdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuICBcdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG4gIFx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG4gIFx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcbiAgXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRvbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcbiAgXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcbiAgXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG4gIFx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0b2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuICBcdFx0aWYgKGhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcbiAgXHRcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG4gIFx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcbiAgXHRcdFx0cHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcclxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcclxuICBcdFx0ICAgIHNpemVkUGFyZW50ID0gZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuICBcdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBnZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG4gIFx0XHR2YXIgbW91c2VldmVudCA9IGUudHlwZSA9PT0gJ21vdXNlZG93bic7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b24oZG9jdW1lbnQsIG1vdXNlZXZlbnQgPyAnbW91c2V1cCcgOiAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuICBcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuICBcdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG4gIFx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcbiAgXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuICBcdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuICBcdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG4gIFx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cclxuICBcdFx0XHRhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG4gIFx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG4gIFx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG4gIFx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcbiAgXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG4gIFx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuICBcdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuICBcdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZXVwIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRlbmFibGVJbWFnZURyYWcoKTtcclxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICBcdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuICBcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG4gIFx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG4gIFx0XHRcdFx0bm9JbmVydGlhOiBub0luZXJ0aWEsXHJcbiAgXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gICAqL1xyXG5cclxuICAvKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gICAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAgICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICAgKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAgICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcbiAgXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuICBcdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuICBcdCAgICBpLCBqLCBrLFxyXG4gIFx0ICAgIGEsIGIsXHJcbiAgXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG4gIFx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG4gIFx0XHRlZGdlID0gZWRnZXNba107XHJcbiAgXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcbiAgXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuICBcdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuICBcdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuICBcdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG4gIFx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcbiAgXHRcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcbiAgXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcbiAgXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG4gIFx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHBvaW50cztcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gICAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWdvbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG4gIFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyO1xyXG5cclxuICBcdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmICghaXNGbGF0KGxhdGxuZ3MpKSB7XHJcbiAgXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG4gIFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG4gIFx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuICBcdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuICBcdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG4gIFx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuICBcdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcbiAgXHR2YXIgcG9pbnRzID0gW107XHJcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG4gIFx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0YXJlYSA9IHggPSB5ID0gMDtcclxuXHJcbiAgXHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTtcclxuICBcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcbiAgXHRcdHAxID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRwMiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xyXG4gIFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xyXG4gIFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xyXG4gIFx0XHRhcmVhICs9IGYgKiAzO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChhcmVhID09PSAwKSB7XHJcbiAgXHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxyXG4gIFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG4gIFx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbiAgfVxyXG5cclxuICAvKiBAZnVuY3Rpb24gY2VudHJvaWQobGF0bG5nczogTGF0TG5nW10pOiBMYXRMbmdcclxuICAgKiBSZXR1cm5zIHRoZSAnY2VudGVyIG9mIG1hc3MnIG9mIHRoZSBwYXNzZWQgTGF0TG5ncy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjZW50cm9pZChjb29yZHMpIHtcclxuICBcdHZhciBsYXRTdW0gPSAwO1xyXG4gIFx0dmFyIGxuZ1N1bSA9IDA7XHJcbiAgXHR2YXIgbGVuID0gMDtcclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhjb29yZHNbaV0pO1xyXG4gIFx0XHRsYXRTdW0gKz0gbGF0bG5nLmxhdDtcclxuICBcdFx0bG5nU3VtICs9IGxhdGxuZy5sbmc7XHJcbiAgXHRcdGxlbisrO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRvTGF0TG5nKFtsYXRTdW0gLyBsZW4sIGxuZ1N1bSAvIGxlbl0pO1xyXG4gIH1cblxuICB2YXIgUG9seVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNsaXBQb2x5Z29uOiBjbGlwUG9seWdvbixcbiAgICBwb2x5Z29uQ2VudGVyOiBwb2x5Z29uQ2VudGVyLFxuICAgIGNlbnRyb2lkOiBjZW50cm9pZFxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gICAqXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gICAqL1xyXG5cclxuICAvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuICAvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuICAvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4gIC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbiAgLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4gIC8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuICAvLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbiAgLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuICAvLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwczovL21vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzLykuXHJcbiAgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuICBcdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcbiAgXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuICBcdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuICBcdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcbiAgXHRyZXR1cm4gcG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG4gIGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG4gIFx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmFtZXItRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG4gIGZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcbiAgXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuICBcdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG4gIFx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuICBcdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG4gIFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuICBcdHZhciBpLFxyXG4gIFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG4gIFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG4gIFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcbiAgXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuICBcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcbiAgXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcbiAgXHRcdFx0aW5kZXggPSBpO1xyXG4gIFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuICBcdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuICBmdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuICBcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuICBcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0XHRwcmV2ID0gaTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcbiAgXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbiAgfVxyXG5cclxuICB2YXIgX2xhc3RDb2RlO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuICAvLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbiAgLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4gIC8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuICAvLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG4gIGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcbiAgXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcbiAgXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuICBcdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuICBcdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuICBcdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcbiAgXHR3aGlsZSAodHJ1ZSkge1xyXG4gIFx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcbiAgXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuICBcdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIG90aGVyIGNhc2VzXHJcbiAgXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuICBcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG4gIFx0XHRcdGEgPSBwO1xyXG4gIFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRiID0gcDtcclxuICBcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuICBcdHZhciBkeCA9IGIueCAtIGEueCxcclxuICBcdCAgICBkeSA9IGIueSAtIGEueSxcclxuICBcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcbiAgXHQgICAgeCwgeTtcclxuXHJcbiAgXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcbiAgXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuICBcdFx0eSA9IG1heC55O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcbiAgXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuICBcdFx0eSA9IG1pbi55O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuICBcdFx0eCA9IG1heC54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcbiAgXHRcdHggPSBtaW4ueDtcclxuICBcdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcbiAgXHR2YXIgY29kZSA9IDA7XHJcblxyXG4gIFx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcbiAgXHRcdGNvZGUgfD0gMTtcclxuICBcdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcbiAgXHRcdGNvZGUgfD0gMjtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHRjb2RlIHw9IDQ7XHJcbiAgXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuICBcdFx0Y29kZSB8PSA4O1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbiAgZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuICBcdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG4gIFx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcbiAgXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuICBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuICBcdHZhciB4ID0gcDEueCxcclxuICBcdCAgICB5ID0gcDEueSxcclxuICBcdCAgICBkeCA9IHAyLnggLSB4LFxyXG4gIFx0ICAgIGR5ID0gcDIueSAtIHksXHJcbiAgXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcbiAgXHQgICAgdDtcclxuXHJcbiAgXHRpZiAoZG90ID4gMCkge1xyXG4gIFx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuICBcdFx0aWYgKHQgPiAxKSB7XHJcbiAgXHRcdFx0eCA9IHAyLng7XHJcbiAgXHRcdFx0eSA9IHAyLnk7XHJcbiAgXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuICBcdFx0XHR4ICs9IGR4ICogdDtcclxuICBcdFx0XHR5ICs9IGR5ICogdDtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdGR4ID0gcC54IC0geDtcclxuICBcdGR5ID0gcC55IC0geTtcclxuXHJcbiAgXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuICAvLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG4gIGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcbiAgXHRyZXR1cm4gIWlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG4gIFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG4gIFx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlsaW5lLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG4gIFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLCBjZW50ZXI7XHJcblxyXG4gIFx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuICBcdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuICBcdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcbiAgXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcbiAgXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG4gIFx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG4gIFx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcbiAgXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG4gIFx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuICBcdHZhciBwb2ludHMgPSBbXTtcclxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcbiAgXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuICBcdH1cclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuICBcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuICBcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG4gIFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuICBcdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcbiAgXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xyXG5cclxuICBcdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcbiAgXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcclxuICBcdFx0XHRcdGNlbnRlciA9IFtcclxuICBcdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuICBcdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxyXG4gIFx0XHRcdFx0XTtcclxuICBcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcbiAgXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxuICB9XG5cbiAgdmFyIExpbmVVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzaW1wbGlmeTogc2ltcGxpZnksXG4gICAgcG9pbnRUb1NlZ21lbnREaXN0YW5jZTogcG9pbnRUb1NlZ21lbnREaXN0YW5jZSxcbiAgICBjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBjbGlwU2VnbWVudDogY2xpcFNlZ21lbnQsXG4gICAgX2dldEVkZ2VJbnRlcnNlY3Rpb246IF9nZXRFZGdlSW50ZXJzZWN0aW9uLFxuICAgIF9nZXRCaXRDb2RlOiBfZ2V0Qml0Q29kZSxcbiAgICBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBpc0ZsYXQ6IGlzRmxhdCxcbiAgICBfZmxhdDogX2ZsYXQsXG4gICAgcG9seWxpbmVDZW50ZXI6IHBvbHlsaW5lQ2VudGVyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAc2VjdGlvblxyXG4gICAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAgICpcclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAgICpcclxuICAgKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICAgKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gICAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAgICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIExvbkxhdCA9IHtcclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICAgKlxyXG4gICAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWVyY2F0b3IgPSB7XHJcbiAgXHRSOiA2Mzc4MTM3LFxyXG4gIFx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG4gIFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuICBcdFx0ICAgIHIgPSB0aGlzLlIsXHJcbiAgXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcbiAgXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG4gIFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuICBcdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcbiAgXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcbiAgXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcbiAgXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcbiAgXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcbiAgXHRcdFx0cGhpICs9IGRwaGk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcbiAgXHR9XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gICAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gICAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICAgKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAgICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICAgKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICAgKi9cblxuICB2YXIgaW5kZXggPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIExvbkxhdDogTG9uTGF0LFxuICAgIE1lcmNhdG9yOiBNZXJjYXRvcixcbiAgICBTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3JcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gICAqXHJcbiAgICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgKi9cclxuICB2YXIgRVBTRzMzOTUgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuICBcdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuICBcdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG4gIFx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcbiAgXHR9KCkpXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICAgKlxyXG4gICAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICAgKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gICAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICAgKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAgICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG4gIFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxuICB9KTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIENSU1xuICAgKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICAgKlxuICAgKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAgICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICAgKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAgICovXG5cbiAgdmFyIFNpbXBsZSA9IGV4dGVuZCh7fSwgQ1JTLCB7XG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcbiAgXHR9LFxuXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuICBcdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuICBcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFx0fSxcblxuICBcdGluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIENSUy5FYXJ0aCA9IEVhcnRoO1xuICBDUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbiAgQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG4gIENSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbiAgQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG4gIENSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbiAgLypcbiAgICogQGNsYXNzIExheWVyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIEBha2EgTC5MYXllclxuICAgKiBAYWthIElMYXllclxuICAgKlxuICAgKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICAgKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIucmVtb3ZlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnQgYWRkOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAgICpcbiAgICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICAgKi9cblxuXG4gIHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuICBcdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuICBcdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG4gIFx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHQvKiBAc2VjdGlvblxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICBcdCAqXG4gIFx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuICBcdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG4gIFx0ICovXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG4gIFx0Ly9cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG4gIFx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuICBcdFx0aWYgKG9iaikge1xuICBcdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuICBcdH0sXG5cbiAgXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gIFx0XHR0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tzdGFtcCh0YXJnZXRFbCldO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuICBcdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG4gIFx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gIFx0fSxcblxuICBcdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuICBcdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuICBcdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG4gIFx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuICBcdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuICBcdFx0XHR9LCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vbkFkZChtYXApO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuICBcdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG4gIFx0fVxuICB9KTtcblxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICAgKiBAdW5pbmhlcml0YWJsZVxuICAgKlxuICAgKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gICAqXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFwXG4gICAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAqXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgICovXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG4gIFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG4gIFx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG4gIFx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG4gIFx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuICBcdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcbiAgXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG4gIFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG4gIFx0fSxcblxuICBcdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcbiAgXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICBcdCAqIGBgYFxuICBcdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuICBcdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG4gIFx0ICogfSk7XG4gIFx0ICogYGBgXG4gIFx0ICovXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgXHRcdGxheWVycyA9IGxheWVycyA/IChpc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG4gIFx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuICBcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG4gIFx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuICBcdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG4gIFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG4gIFx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cbiAgXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gICAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICAgKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICAgKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gICAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gICAqIFx0LmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdHZhciBpLCBsZW47XHJcblxyXG4gIFx0XHRpZiAobGF5ZXJzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuICBcdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcbiAgXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcbiAgXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG4gIFx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gIFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgXHRcdCAgICBpLCBsYXllcjtcclxuXHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcbiAgXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcbiAgXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuICBcdC8vIGBgYGpzXHJcbiAgXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuICBcdC8vIH0pO1xyXG4gIFx0Ly8gYGBgXHJcbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcbiAgXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuICBcdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICAgKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAgICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICAgKlxyXG4gICAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAgICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAgICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gICAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gICAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICAgKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAgICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBib3VuZHM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBJY29uXHJcbiAgICogQGFrYSBMLkljb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICAgKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICAgKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICAgKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gICAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICAgKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICAgKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICAgKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICAgKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAgICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuICBcdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcbiAgXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcbiAgXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcbiAgXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0ICovXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG4gIFx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcbiAgXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcbiAgXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKCFzcmMpIHtcclxuICBcdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGltZztcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG4gIFx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuICBcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG4gIFx0XHRpZiAoYW5jaG9yKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChzaXplKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuICBcdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICBcdFx0ZWwuc3JjID0gc3JjO1xyXG4gIFx0XHRyZXR1cm4gZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAgICogQGFrYSBMLkljb24uRGVmYXVsdFxuICAgKiBAc2VjdGlvblxuICAgKlxuICAgKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICAgKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAgICogcmVsZWFzZXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gICAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICAgKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gICAqL1xuXG4gIHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuICBcdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG4gIFx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuICBcdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuICBcdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuICBcdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuICBcdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG4gIFx0fSxcblxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG4gIFx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcbiAgXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcbiAgXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuICBcdH0sXG5cbiAgXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcbiAgXHRcdHZhciBzdHJpcCA9IGZ1bmN0aW9uIChzdHIsIHJlLCBpZHgpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcbiAgXHRcdH07XG4gIFx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG4gIFx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcbiAgXHR9LFxuXG4gIFx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG4gIFx0XHR2YXIgcGF0aCA9IGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG4gIFx0XHQgICAgICAgICAgIGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuICBcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gIFx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG4gIFx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuICBcdFx0dmFyIGxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibGVhZmxldC5jc3NcIl0nKTtcbiAgXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cbiAgXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFya2VyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gICAqXG4gICAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAgKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAgICovXG5cbiAgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuICBcdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG4gIFx0XHRhZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcbiAgXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcbiAgXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG4gIFx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cbiAgXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG4gIFx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcbiAgXHRcdCk7XG5cbiAgXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG4gIFx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcbiAgXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuICBcdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG4gIFx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cbiAgXHRcdFx0c2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG4gIFx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuICBcdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG4gIFx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuICBcdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG4gIFx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG4gIFx0XHRpZiAoc2hhZG93KSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG4gIFx0XHRtYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIE1hcmtlclxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqIEBha2EgTC5NYXJrZXJcclxuICAgKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuICBcdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG4gIFx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuICBcdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG4gIFx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0dGl0bGU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcbiAgXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG4gIFx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcbiAgXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcbiAgXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcbiAgXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG4gIFx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuICBcdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcbiAgXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuICBcdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG4gIFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG4gIFx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG4gIFx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcbiAgXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcbiAgXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG4gIFx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKlxyXG4gIFx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuICBcdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcbiAgXHR9LFxyXG5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gIFx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcbiAgXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcbiAgXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG4gIFx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuICBcdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICBcdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuICBcdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcbiAgXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuICBcdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG4gIFx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuICBcdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG5cclxuICBcdFx0aWYgKGFkZEljb24pIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuICBcdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuICBcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcbiAgXHRcdFx0b2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5faWNvbik7XHJcbiAgXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG4gIFx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuICBcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0YWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHRpZiAoTWFya2VyRHJhZykge1xyXG4gIFx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG4gIFx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuICBcdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuICBcdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHRvUG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogdG9Qb2ludCgwLCAwKTtcclxuICBcdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyB0b1BvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogdG9Qb2ludCgwLCAwKTtcclxuXHJcbiAgXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcbiAgXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuICBcdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuICB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUGF0aCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdHN0cm9rZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG4gIFx0XHQvLyBTdHJva2UgY29sb3JcbiAgXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cbiAgXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG4gIFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIFx0XHR3ZWlnaHQ6IDMsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaEFycmF5OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdGZpbGw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuICBcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuICBcdFx0ZmlsbENvbG9yOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRcdC8vIEZpbGwgb3BhY2l0eS5cbiAgXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cbiAgXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cbiAgXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuICBcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuICBcdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG4gIFx0XHR0aGlzLl9yZXNldCgpO1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcbiAgXHRcdHRoaXMuX3Byb2plY3QoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcbiAgXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZU1hcmtlclxuICAgKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAgICovXG5cbiAgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuICBcdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcbiAgXHRcdHJhZGl1czogMTBcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMucmVkcmF3KCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuICBcdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuICBcdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuICBcdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG4gIFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVcbiAgICogQGFrYSBMLkNpcmNsZVxuICAgKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICAgKlxuICAgKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gIFx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuICBcdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG4gIFx0XHR9XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuICBcdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcbiAgXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuICBcdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcbiAgXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuICBcdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcbiAgXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcbiAgXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG4gIFx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuICBcdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuICBcdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG4gIFx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4gIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4gIC8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuICBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBQb2x5bGluZVxuICAgKiBAYWthIEwuUG9seWxpbmVcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdFszNC4wNCwgLTExOC4yXVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gICAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICAgKiBcdFtbNDAuNzgsIC03My45MV0sXG4gICAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAgICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcbiAgXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cbiAgXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuICBcdFx0bm9DbGlwOiBmYWxzZVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuICBcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cbiAgXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuICBcdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuICBcdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cbiAgXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcbiAgXHRcdCAgICBjbG9zZXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICBcdFx0ICAgIHAxLCBwMjtcblxuICBcdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG4gIFx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG4gIFx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cbiAgXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gIFx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcbiAgXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0aWYgKG1pblBvaW50KSB7XG4gIFx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBtaW5Qb2ludDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBwb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2ZcbiAgXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuICBcdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cbiAgXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuICBcdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuICBcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuICBcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHQgICAgZmxhdCA9IGlzRmxhdChsYXRsbmdzKTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX3JpbmdzID0gW107XG4gIFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG4gIFx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcbiAgXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG4gIFx0XHRdKTtcbiAgXHR9LFxuXG4gIFx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcbiAgXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcbiAgXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcbiAgXHRcdCAgICBpLCByaW5nO1xuXG4gIFx0XHRpZiAoZmxhdCkge1xuICBcdFx0XHRyaW5nID0gW107XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuICBcdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcbiAgXHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuICBcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cbiAgXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG4gIFx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG4gIFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuICBcdFx0XHRcdFx0aysrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG4gIFx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcbiAgXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcbiAgXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG4gIFx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRpZiAocG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbiAgLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4gIC8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuICBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cbiAgUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWdvblxuICAgKiBAYWthIEwuUG9seWdvblxuICAgKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAgICpcbiAgICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gICAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogXTtcbiAgICogYGBgXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAgICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogICBdLFxuICAgKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAgICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICAgKiAgIF1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWVcbiAgXHR9LFxuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIFBvbHlnb24uXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHBvbHlnb25DZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG4gIFx0fSxcblxuICBcdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG4gIFx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuICBcdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuICBcdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcbiAgXHRcdFx0cmVzdWx0LnBvcCgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcbiAgXHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcbiAgXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuICBcdH0sXG5cbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcbiAgXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG4gIFx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGNsaXBwZWQgPSBjbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcbiAgXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcbiAgXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBhcnRbal07XG4gIFx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG4gIFx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuICBcdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcbiAgXHR9XG5cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBHZW9KU09OXHJcbiAgICogQGFrYSBMLkdlb0pTT05cclxuICAgKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAgICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gICAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAgICogXHR9XHJcbiAgICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICAgKiB9KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuICBcdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcbiAgXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG4gIFx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHt9XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcbiAgXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHRydWU7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcbiAgXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuICBcdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdGlmIChnZW9qc29uKSB7XHJcbiAgXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuICBcdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcbiAgXHRcdHZhciBmZWF0dXJlcyA9IGlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuICBcdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcbiAgXHRcdGlmIChmZWF0dXJlcykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuICBcdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuICBcdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghbGF5ZXIpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuICBcdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG4gIFx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG4gIFx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuICBcdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuICBcdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuICBcdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcbiAgXHRcdGxheWVyLm9wdGlvbnMgPSBleHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuICBcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuICBcdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcbiAgXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4gIC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4gIC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuICBcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuICBcdCAgICBsYXllcnMgPSBbXSxcclxuICBcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG4gIFx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuICBcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcbiAgXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcblxyXG4gIFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcbiAgXHRjYXNlICdQb2ludCc6XHJcbiAgXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG4gIFx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG4gIFx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG4gIFx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ1BvbHlnb24nOlxyXG4gIFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHZhciBnZW9MYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcbiAgXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuICBcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG4gIFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0XHRpZiAoZ2VvTGF5ZXIpIHtcclxuICBcdFx0XHRcdGxheWVycy5wdXNoKGdlb0xheWVyKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGZlYXR1cmVMYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9tZXRyeS5mZWF0dXJlc1tpXSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRcdGlmIChmZWF0dXJlTGF5ZXIpIHtcclxuICBcdFx0XHRcdGxheWVycy5wdXNoKGZlYXR1cmVMYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0ZGVmYXVsdDpcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG4gIFx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuICBcdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbiAgLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbiAgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbiAgLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4gIC8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuICAvLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcbiAgXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuICBcdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcbiAgXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBsYXRsbmdzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG4gIFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4sIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbiAgLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuICAvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG4gIFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdC8vIENoZWNrIGZvciBmbGF0IGFycmF5cyByZXF1aXJlZCB0byBlbnN1cmUgdW5iYWxhbmNlZCBhcnJheXMgYXJlIGNvcnJlY3RseSBjb252ZXJ0ZWQgaW4gcmVjdXJzaW9uXHJcbiAgXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG4gIFx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBpc0ZsYXQobGF0bG5nc1tpXSkgPyAwIDogbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcbiAgXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xyXG4gIFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0uc2xpY2UoKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvb3JkcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcbiAgXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcbiAgXHRcdGV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuICBcdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbiAgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuICBcdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuICBcdFx0cmV0dXJuIGdlb2pzb247XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuICBcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICB2YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdQb2ludCcsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuICAvLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG4gIE1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG4gIENpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuICBDaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuICBQb2x5bGluZS5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgbXVsdGkgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuICBQb2x5Z29uLmluY2x1ZGUoe1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHZhciBob2xlcyA9ICFpc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcbiAgXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG4gIFx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRpZiAoIWhvbGVzKSB7XHJcbiAgXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuICBMYXllckdyb3VwLmluY2x1ZGUoe1xyXG4gIFx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIFx0Ly8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcbiAgXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcbiAgXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG4gIFx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuICBcdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG4gIFx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG4gIFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcbiAgXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG4gIFx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuICBcdFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuICBcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICBcdFx0XHRmZWF0dXJlczoganNvbnNcclxuICBcdFx0fTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbiAgLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuICAvLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuICAvLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAgICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBpbWFnZVVybCA9ICdodHRwczovL21hcHMubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAgICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICAgKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG4gIFx0XHRvcGFjaXR5OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG4gIFx0XHRhbHQ6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcbiAgXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGltYWdlLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcbiAgXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG4gIFx0XHR6SW5kZXg6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuICBcdFx0dGhpcy5fcmVzZXQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG4gIFx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuICBcdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvQmFjayh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuICBcdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuICBcdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuICBcdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ2ltZycpO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcbiAgXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuICBcdFx0aW1nLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuICBcdFx0aW1nLm9ubG9hZCA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG4gIFx0XHRpbWcub25lcnJvciA9IGJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuICBcdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuICBcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuICBcdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuICBcdFx0c2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuICBcdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuICBcdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0c2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcbiAgXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIEltYWdlT3ZlcmxheS5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzLmdldENlbnRlcigpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG4gIHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gICAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICAgKlxyXG4gICAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAgICogSFRNTDUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAgICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gICAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG4gIFx0XHQvLyBPbiBzb21lIGJyb3dzZXJzIGF1dG9wbGF5IHdpbGwgb25seSB3b3JrIHdpdGggYG11dGVkOiB0cnVlYFxyXG4gIFx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuICBcdFx0bG9vcDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG4gIFx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBTZWUgW2Jyb3dzZXIgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXQpXHJcbiAgXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbXV0ZWQ6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgb24gbXV0ZSB3aGVuIGxvYWRlZC5cclxuICBcdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwbGF5c0lubGluZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gTW9iaWxlIGJyb3dzZXJzIHdpbGwgcGxheSB0aGUgdmlkZW8gcmlnaHQgd2hlcmUgaXQgaXMgaW5zdGVhZCBvZiBvcGVuIGl0IHVwIGluIGZ1bGxzY3JlZW4gbW9kZS5cclxuICBcdFx0cGxheXNJbmxpbmU6IHRydWVcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcbiAgXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCd2aWRlbycpO1xyXG5cclxuICBcdFx0YWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKHZpZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcbiAgXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuICBcdFx0dmlkLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuICBcdFx0dmlkLm9ubG9hZGVkZGF0YSA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuICBcdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG4gIFx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuICBcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuX3VybCA9IChzb3VyY2VFbGVtZW50cy5sZW5ndGggPiAwKSA/IHNvdXJjZXMgOiBbdmlkLnNyY107XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aWQuc3R5bGUsICdvYmplY3RGaXQnKSkge1xyXG4gIFx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcbiAgXHRcdH1cclxuICBcdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcbiAgXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuICBcdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcbiAgXHRcdHZpZC5wbGF5c0lubGluZSA9ICEhdGhpcy5vcHRpb25zLnBsYXlzSW5saW5lO1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHZhciBzb3VyY2UgPSBjcmVhdGUkMSgnc291cmNlJyk7XHJcbiAgXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuICBcdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuICAvLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG4gIGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFNWR092ZXJsYXlcbiAgICogQGFrYSBMLlNWR092ZXJsYXlcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICAgKlxuICAgKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICAgKlxuICAgKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICAgKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gICAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gICAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICAgKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsID0gdGhpcy5faW1hZ2UgPSB0aGlzLl91cmw7XG5cbiAgXHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cblxuICBcdFx0ZWwub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gIFx0XHRlbC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG4gIFx0fVxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbiAgLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG4gIGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIERpdk92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gICAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gb3ZlcmxheXMgbGlrZSBwbHVnaW5zLlxyXG4gICAqL1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuICB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgcG9wdXAvdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgbW91c2UgZXZlbnRzLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG4gIFx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBvc2l0aW9uLlxyXG4gIFx0XHRvZmZzZXQ6IFswLCAwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIG92ZXJsYXkuXHJcbiAgXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuICBcdFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5IHdoaWxlIGluaXRpYWxpemluZy4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlXHJcbiAgXHRcdC8vIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjb250ZW50OiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcbiAgXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IGlzQXJyYXkob3B0aW9ucykpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcbiAgXHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRlbnQgPSB0aGlzLm9wdGlvbnMuY29udGVudDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcbiAgXHRcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAuY2xvc2VQb3B1cChwb3B1cClgL2AuY2xvc2VUb29sdGlwKHRvb2x0aXApYFxyXG4gIFx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG4gIFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgb3ZlcmxheSBib3VuZCB0byBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuICBcdHRvZ2dsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLmNsb3NlKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGhpcy5fcHJlcGFyZU9wZW4oKTtcclxuXHJcbiAgXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcbiAgXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG4gIFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuICBcdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcbiAgXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuICBcdFx0XHRzb3VyY2UgPSBudWxsO1xyXG4gIFx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiBsYXllcnMpIHtcclxuICBcdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuICBcdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICghc291cmNlKSB7IHJldHVybiBmYWxzZTsgfSAvLyBVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllci5cclxuXHJcbiAgXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghbGF0bG5nKSB7XHJcbiAgXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRCb3VuZHMpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuICBcdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICBcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBjb250ZW50dXBkYXRlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuICBcdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuICBcdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuICBcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBvdmVybGF5IGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbMCwgMF07XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIGNvbnRlbnQsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcbiAgXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF0bG5nKSB7XHJcbiAgXHRcdFx0b3ZlcmxheS5zZXRMYXRMbmcobGF0bG5nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIExheWVyLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBvbGQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG4gIFx0XHRcdHNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0b3ZlcmxheS5fc291cmNlID0gdGhpcztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb3B1cFxyXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAgICogQGFrYSBMLlBvcHVwXHJcbiAgICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gICAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gICAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICAgKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gICAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gICAqIFx0Lm9wZW5PbihtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqIG9yXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9wdXAgPSBMLnBvcHVwKGxhdGxuZywge2NvbnRlbnQ6ICc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdwb3B1cFBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcbiAgXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcbiAgXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcbiAgXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuICBcdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG4gIFx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG4gIFx0XHQvLyBUaGUgc2Nyb2xsYWJsZSBjb250YWluZXIgY2FuIGJlIHN0eWxlZCB1c2luZyB0aGVcclxuICBcdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuICBcdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcbiAgXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG4gIFx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG4gIFx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG4gIFx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcbiAgXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuICBcdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG4gIFx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG4gIFx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcbiAgXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAgXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG4gIFx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcbiAgXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcbiAgXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsYXNzTmFtZTogJydcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG4gIFx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblxyXG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuICBcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobWFwLl9wb3B1cCk7XHJcbiAgXHRcdH1cclxuICBcdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG4gIFx0XHRyZXR1cm4gRGl2T3ZlcmxheS5wcm90b3R5cGUub3Blbk9uLmNhbGwodGhpcywgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcbiAgXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuICBcdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuICBcdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcbiAgXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcbiAgXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG4gIFx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsXHJcbiAgXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuICBcdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuICBcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG4gIFx0XHRvbihjb250YWluZXIsICdjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG4gIFx0XHR0aGlzLl90aXBDb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy5fdGlwID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuICBcdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IGNyZWF0ZSQxKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTsgLy8gb3ZlcnJpZGVzIHRoZSBpbXBsaWNpdCByb2xlPWxpbmsgb2YgPGE+IGVsZW1lbnRzICM3Mzk5XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mIzIxNTs8L3NwYW4+JztcclxuXHJcbiAgXHRcdFx0b24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRcdFx0cHJldmVudERlZmF1bHQoZXYpO1xyXG4gIFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG4gIFx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG4gIFx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG4gIFx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG4gIFx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcbiAgXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG4gIFx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuICBcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuICBcdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG4gIFx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuICBcdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcbiAgXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuICBcdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuICBcdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG4gIFx0XHRcdGFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuICBcdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcbiAgXHRcdC8vIExldCdzIGd1YXJkIGFnYWluc3QgdGhhdCBieSBleGl0aW5nIGVhcmx5IGlmIHdlJ3JlIHJlc3BvbmRpbmcgdG8gb3VyIG93biBhdXRvcGFuLlxyXG4gIFx0XHRpZiAodGhpcy5fYXV0b3Bhbm5pbmcpIHtcclxuICBcdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuICBcdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcbiAgXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG4gIFx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG4gIFx0XHRsYXllclBvcy5fYWRkKGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcbiAgXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgZHggPSAwLFxyXG4gIFx0XHQgICAgZHkgPSAwO1xyXG5cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG4gIFx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcbiAgXHRcdGlmIChkeCB8fCBkeSkge1xyXG4gIFx0XHRcdC8vIFRyYWNrIHRoYXQgd2UncmUgYXV0b3Bhbm5pbmcsIGFzIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZS1yYW4gb24gbW92ZWVuZFxyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG4gIFx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0bWFwXHJcbiAgXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG4gIFx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxyXG4gIHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuICBcdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICAgKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gICAqL1xyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gIFx0XHRwb3B1cCA9IGFyZ3VtZW50cy5sZW5ndGggPyBwb3B1cCA6IHRoaXMuX3BvcHVwO1xyXG4gIFx0XHRpZiAocG9wdXApIHtcclxuICBcdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cclxuXHJcbiAgLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG4gIExheWVyLmluY2x1ZGUoe1xyXG5cclxuICBcdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG4gIFx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5vbih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuICBcdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG4gIFx0XHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG4gIFx0XHRcdFx0dGhpcy5fcG9wdXAub3Blbk9uKHRoaXMuX21hcCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcbiAgXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLmNsb3NlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuICBcdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnRvZ2dsZSh0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuICBcdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcbiAgXHRcdHN0b3AoZSk7XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0Ly8gdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG4gIFx0XHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0YXJnZXQ7XHJcbiAgXHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuICBcdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgVG9vbHRpcFxuICAgKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICAgKiBAYWthIEwuVG9vbHRpcFxuICAgKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHRvb2x0aXAgdG8gbWFya2VyOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRUb29sdGlwYCBtZXRob2QuXG4gICAqXG4gICAqIEEgdG9vbHRpcCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcCgpXG4gICAqIFx0LnNldExhdExuZyhsYXRsbmcpXG4gICAqIFx0LnNldENvbnRlbnQoJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJylcbiAgICogXHQuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqIG9yXG4gICAqIGBgYGpzXG4gICAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKGxhdGxuZywge2NvbnRlbnQ6ICdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLid9KVxuICAgKiBcdC5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICpcbiAgICpcbiAgICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gICAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICAgKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAgICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAgICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAgICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICAgKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAgICovXG5cblxuICAvLyBAbmFtZXNwYWNlIFRvb2x0aXBcbiAgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG4gIFx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuICBcdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXG5cbiAgXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcbiAgXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG4gIFx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG4gIFx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG4gIFx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuICBcdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cbiAgXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cbiAgXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cbiAgXHRcdHN0aWNreTogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG4gIFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuICBcdFx0b3BhY2l0eTogMC45XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gIFx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cbiAgXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgXHRcdFx0dGhpcy5hZGRFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG4gIFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cbiAgXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcbiAgXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2xlYWZsZXQtdG9vbHRpcC0nICsgc3RhbXAodGhpcykpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHR2YXIgc3ViWCwgc3ViWSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcbiAgXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcbiAgXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuICBcdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG4gIFx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSAwO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuICBcdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fVxuXG4gIFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIC8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC50b29sdGlwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXG4gIHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICBcdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xuICB9O1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgTWFwLmluY2x1ZGUoe1xuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcbiAgXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gIFx0XHR0b29sdGlwLmNsb3NlKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBMYXllclxuICAgKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICAgKlxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICAgKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIC8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuICBMYXllci5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG4gIFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG4gIFx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG4gIFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cbiAgXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcbiAgXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gIFx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcbiAgXHRcdCAgICBldmVudHMgPSB7XG4gIFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG4gIFx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG4gIFx0XHQgICAgfTtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuICBcdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuICBcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHR9XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuICBcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG4gIFx0XHR9XG4gIFx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuICBcdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cbiAgXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxhdGxuZykge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcbiAgXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSB0aGlzO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG4gIFx0XHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG4gIFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5vcGVuT24odGhpcy5fbWFwKTtcblxuICBcdFx0XHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIodGhpcyk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuICBcdFx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciwgdGhpcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuICBcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG4gIFx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5jbG9zZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl90b29sdGlwLnRvZ2dsZSh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG4gIFx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuICBcdH0sXG5cbiAgXHRfYWRkRm9jdXNMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcbiAgXHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyKHRoaXMpO1xuICBcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuICBcdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIsIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcbiAgXHRcdGlmIChlbCkge1xuICBcdFx0XHRvbihlbCwgJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuICBcdFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdFx0fSwgdGhpcyk7XG4gIFx0XHRcdG9uKGVsLCAnYmx1cicsIHRoaXMuY2xvc2VUb29sdGlwLCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuICBcdFx0aWYgKGVsKSB7XG4gIFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuXG4gIFx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiB0aGUgbWFwIGlzIG1vdmluZywgd2Ugd2lsbCBzaG93IHRoZSB0b29sdGlwIGFmdGVyIGl0J3MgZG9uZS5cbiAgXHRcdGlmICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpICYmICF0aGlzLl9vcGVuT25jZUZsYWcpIHtcbiAgXHRcdFx0dGhpcy5fb3Blbk9uY2VGbGFnID0gdHJ1ZTtcbiAgXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuICBcdFx0XHR0aGlzLl9tYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR0aGF0Ll9vcGVuT25jZUZsYWcgPSBmYWxzZTtcbiAgXHRcdFx0XHR0aGF0Ll9vcGVuVG9vbHRpcChlKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuICBcdFx0dGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuICBcdH0sXG5cbiAgXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG4gIFx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG4gIFx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuICBcdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBEaXZJY29uXG4gICAqIEBha2EgTC5EaXZJY29uXG4gICAqIEBpbmhlcml0cyBJY29uXG4gICAqXG4gICAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gICAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICAgKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICAgKlxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICAgKi9cblxuICB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAc2VjdGlvblxuICBcdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcbiAgXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cbiAgXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG4gIFx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuICBcdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuICBcdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcbiAgXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG4gIFx0XHRodG1sOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cbiAgXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcbiAgXHRcdGJnUG9zOiBudWxsLFxuXG4gIFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuICBcdH0sXG5cbiAgXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuICBcdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gIFx0XHRcdGVtcHR5KGRpdik7XG4gIFx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcbiAgXHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcbiAgXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cbiAgXHRcdHJldHVybiBkaXY7XG4gIFx0fSxcblxuICBcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbiAgfVxuXG4gIEljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5HcmlkTGF5ZXJcbiAgICpcbiAgICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICAgKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gICAqXG4gICAqXG4gICAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAgICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gICAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gICAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICAgKiAgICAgICAgIHZhciBlcnJvcjtcbiAgICpcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICAgKiAgICAgICAgIH0sIDEwMDApO1xuICAgKlxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uXG4gICAqL1xuXG5cbiAgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcbiAgXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cbiAgXHRcdHRpbGVTaXplOiAyNTYsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuICBcdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cbiAgXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG4gIFx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuICBcdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cbiAgXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuICBcdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuICBcdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cbiAgXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG4gIFx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuICBcdFx0ekluZGV4OiAxLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG4gIFx0XHRib3VuZHM6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG4gIFx0XHRtaW5ab29tOiAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuICBcdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcbiAgXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cbiAgXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcbiAgXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cbiAgXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcbiAgXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cbiAgXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG4gIFx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuICBcdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cbiAgXHRcdG5vV3JhcDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG4gIFx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cbiAgXHRcdGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuICBcdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuICBcdFx0a2VlcEJ1ZmZlcjogMlxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuICBcdFx0dGhpcy5fbGV2ZWxzID0ge307XG4gIFx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG4gIFx0XHR0aGlzLl9yZXNldFZpZXcoKTsgLy8gaW1wbGljaXQgX3VwZGF0ZSgpIGNhbGxcbiAgXHR9LFxuXG4gIFx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gIFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuICBcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG4gIFx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcbiAgXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cbiAgXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpO1xuICBcdFx0XHRpZiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKSB7XG4gIFx0XHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSB7XG4gIFx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdHpvb206IHRoaXMuX3Jlc2V0VmlldyxcbiAgXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuICBcdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcbiAgXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcbiAgXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSB0aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuICBcdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG4gIFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuICBcdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cbiAgXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcbiAgXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cbiAgXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gIFx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuICBcdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG4gIFx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuICBcdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuICBcdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuICBcdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG4gIFx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG4gIFx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuICBcdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cbiAgXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcbiAgXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcbiAgXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuICBcdFx0XHRpZiAoZmFkZSA8IDEpIHtcbiAgXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuICBcdFx0aWYgKG5leHRGcmFtZSkge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcbiAgXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uT3BhcXVlVGlsZTogZmFsc2VGbixcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcbiAgXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIFx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHR6ID0gTnVtYmVyKHopO1xuICBcdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG4gIFx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG4gIFx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcbiAgXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuICBcdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0aWYgKCFsZXZlbCkge1xuICBcdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG4gIFx0XHRcdGxldmVsLmVsID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cbiAgXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG4gIFx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG4gIFx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cbiAgXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cbiAgXHRcdFx0ZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cbiAgXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cbiAgXHRcdHJldHVybiBsZXZlbDtcbiAgXHR9LFxuXG4gIFx0X29uVXBkYXRlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfb25SZW1vdmVMZXZlbDogZmFsc2VGbixcblxuICBcdF9vbkNyZWF0ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGtleSwgdGlsZTtcblxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICBcdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuICBcdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3JkcztcbiAgXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuICBcdFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG4gIFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoTnVtYmVyKHopKTtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cbiAgXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuICBcdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG4gIFx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcbiAgXHRcdCAgICB6MiA9IHogLSAxLFxuICBcdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuICBcdFx0Y29vcmRzMi56ID0gK3oyO1xuXG4gIFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuICBcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gIFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuICBcdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcbiAgXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG4gIFx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuICBcdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdFx0XHRjb250aW51ZTtcblxuICBcdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICBcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuICBcdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcbiAgXHR9LFxuXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcbiAgXHR9LFxuXG4gIFx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gem9vbTtcbiAgXHR9LFxuXG4gIFx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG4gIFx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuICBcdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG4gIFx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cbiAgXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cbiAgXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuICBcdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG4gIFx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcbiAgXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cbiAgXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghbm9QcnVuZSkge1xuICBcdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG4gIFx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuICBcdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG4gIFx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG4gIFx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cbiAgXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG4gIFx0XHRcdHNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG4gIFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG4gIFx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcbiAgXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcbiAgXHRcdF07XG4gIFx0fSxcblxuICBcdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcbiAgXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcbiAgXHR9LFxuXG4gIFx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cbiAgXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cbiAgXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG4gIFx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG4gIFx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG4gIFx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcbiAgXHRcdCAgICBxdWV1ZSA9IFtdLFxuICBcdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuICBcdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG4gIFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuICBcdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG4gIFx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuICBcdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG4gIFx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuICBcdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cbiAgXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cbiAgXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG4gIFx0XHRcdFx0aWYgKHRpbGUpIHtcbiAgXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gIFx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICBcdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG4gIFx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICBcdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuICBcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG4gIFx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcbiAgXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG4gIFx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuICBcdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuICBcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuICBcdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuICBcdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG4gIFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG4gIFx0fSxcblxuICBcdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG4gIFx0fSxcblxuICBcdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICBcdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG4gIFx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcbiAgXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuICBcdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG4gIFx0XHRyZXR1cm4gW253LCBzZV07XG4gIFx0fSxcblxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG4gIFx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcbiAgXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBib3VuZHM7XG4gIFx0fSxcbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcbiAgXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuICBcdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG4gIFx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG4gIFx0XHRjb29yZHMueiA9ICtrWzJdO1xuICBcdFx0cmV0dXJuIGNvb3JkcztcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0cmVtb3ZlKHRpbGUuZWwpO1xuXG4gIFx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cbiAgXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcbiAgXHRcdFx0dGlsZTogdGlsZS5lbCxcbiAgXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcbiAgXHRcdGFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuICBcdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuICBcdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgXHRcdHRpbGUub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXG4gIFx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuICBcdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG4gIFx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcbiAgXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cbiAgXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG4gIFx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuICBcdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuICBcdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG4gIFx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG4gIFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRzZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuICBcdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG4gIFx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuICBcdFx0XHRlbDogdGlsZSxcbiAgXHRcdFx0Y29vcmRzOiBjb29yZHMsXG4gIFx0XHRcdGN1cnJlbnQ6IHRydWVcbiAgXHRcdH07XG5cbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcbiAgXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG4gIFx0XHRpZiAoZXJyKSB7XG4gIFx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG4gIFx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuICBcdFx0XHRcdGVycm9yOiBlcnIsXG4gIFx0XHRcdFx0dGlsZTogdGlsZSxcbiAgXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gIFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcbiAgXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWVycikge1xuICBcdFx0XHRhZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG4gIFx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuICBcdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcbiAgXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICBcdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG4gIFx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG4gIFx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICBcdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuICBcdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuICBcdFx0XHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcbiAgXHR9LFxuXG4gIFx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG4gIFx0XHRcdHRoaXMuX3dyYXBYID8gd3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG4gIFx0XHRcdHRoaXMuX3dyYXBZID8gd3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuICBcdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcbiAgXHRcdHJldHVybiBuZXdDb29yZHM7XG4gIFx0fSxcblxuICBcdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG4gIFx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG4gIFx0fSxcblxuICBcdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuICBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAgICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gICAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ30pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqICdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAgICpcclxuICAgKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuXHJcbiAgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG4gIFx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWluWm9vbTogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuICBcdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG4gIFx0XHRtYXhab29tOiAxOCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuICBcdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAgXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcbiAgXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuICBcdFx0em9vbU9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcbiAgXHRcdHRtczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG4gIFx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG4gIFx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByZWZlcnJlclBvbGljeTogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuICBcdFx0Ly8gVGhpcyBtYXkgYmUgbmVlZGVkIGlmIHlvdXIgbWFwJ3MgcmVuZGVyaW5nIGNvbnRleHQgaGFzIGEgc3RyaWN0IGRlZmF1bHQgYnV0IHlvdXIgdGlsZSBwcm92aWRlciBleHBlY3RzIGEgdmFsaWQgcmVmZXJyZXJcclxuICBcdFx0Ly8gKGUuZy4gdG8gdmFsaWRhdGUgYW4gQVBJIHRva2VuKS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0cmVmZXJyZXJQb2xpY3k6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG4gIFx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuICBcdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG4gIFx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG4gIFx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcbiAgXHRcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSAtIDEpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuICBcdFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tICsgMSk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG4gIFx0XHR9IGVsc2UgaWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIG1heFpvb20gaXMgZ3RlIG1pblpvb21cclxuICBcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIG1pblpvb20gaXMgbHRlIG1heFpvb21cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG4gIFx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG4gIFx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcbiAgXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcbiAgXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG4gIFx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG4gIFx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG4gIFx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuICBcdFx0b24odGlsZSwgJ2xvYWQnLCBiaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuICBcdFx0b24odGlsZSwgJ2Vycm9yJywgYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG4gIFx0XHQvLyBtb3JlIGNsb3NlbHkgYnkgb25seSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSB3aGVuIHN0cmluZ1xyXG4gIFx0XHRpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeSA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBUaGUgYWx0IGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlIGVtcHR5IHN0cmluZyxcclxuICBcdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG4gIFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvV0FJL3R1dG9yaWFscy9pbWFnZXMvZGVjb3JhdGl2ZS9cclxuICBcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwtYXJpYS8jZWwtaW1nLWVtcHR5LWFsdFxyXG4gIFx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuICBcdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aWxlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQHVuaW5oZXJpdGFibGVcclxuICBcdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG4gIFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcbiAgXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcbiAgXHRcdFx0eDogY29vcmRzLngsXHJcbiAgXHRcdFx0eTogY29vcmRzLnksXHJcbiAgXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcbiAgXHRcdH07XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG4gIFx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG4gIFx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG4gIFx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG4gIFx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRkb25lKGUsIHRpbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuICBcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG4gIFx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuICBcdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuICBcdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuICBcdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcbiAgXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpLCB0aWxlO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcbiAgXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG4gIFx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuICBcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG4gIFx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG4gIFx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcbiAgXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gQGV2ZW50IHRpbGVhYm9ydDogVGlsZUV2ZW50XHJcbiAgXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuICBcdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcbiAgXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcclxuICBcdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcbiAgXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gICAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gICAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gICAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gICAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICAgKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuICBcdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuICBcdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcbiAgXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cHM6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuICBcdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuICBcdFx0c2VydmljZTogJ1dNUycsXHJcbiAgXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuICBcdFx0bGF5ZXJzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG4gIFx0XHRzdHlsZXM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG4gIFx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuICBcdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG4gIFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuICBcdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcbiAgXHRcdHZlcnNpb246ICcxLjEuMSdcclxuICBcdH0sXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG4gIFx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG4gIFx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuICBcdFx0Y3JzOiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG4gIFx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG4gIFx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuICBcdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcclxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG4gIFx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuICBcdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuICBcdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuICBcdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG4gIFx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuICBcdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcbiAgXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuICBcdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuICBcdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcbiAgXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcbiAgXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuICBcdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuICBcdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiB1cmwgK1xyXG4gIFx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuICBcdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuICBcdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcbiAgXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbiAgdGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuICAvKlxuICAgKiBAY2xhc3MgUmVuZGVyZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5SZW5kZXJlclxuICAgKlxuICAgKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICAgKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICAgKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAgICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICAgKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gICAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcbiAgXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuICBcdFx0cGFkZGluZzogMC4xXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0c3RhbXAodGhpcyk7XG4gIFx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cbiAgXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcbiAgXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gIFx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuICBcdH0sXG5cbiAgXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG4gIFx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuICBcdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKGN1cnJlbnRDZW50ZXJQb2ludClcbiAgXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG4gIFx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICBcdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcbiAgXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcbiAgXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gIFx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDYW52YXNcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5DYW52YXNcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vY2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gICAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG4gIFx0XHR0b2xlcmFuY2U6IDBcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuICBcdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuICBcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuICBcdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuICBcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cbiAgXHRcdHRoaXMuX2RyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuICBcdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fY3R4O1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBsYXllcjtcbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICBcdFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG4gIFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG4gIFx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuICBcdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG4gIFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cbiAgXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuICBcdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuICBcdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG4gIFx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcbiAgXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxuICBcdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcbiAgXHRcdFx0bmV4dDogbnVsbFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcbiAgXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcbiAgXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuICBcdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcbiAgXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuICBcdFx0XHQgICAgZGFzaFZhbHVlLFxuICBcdFx0XHQgICAgaTtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcbiAgXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuICBcdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuICBcdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcbiAgXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG4gIFx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcbiAgXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG4gIFx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cbiAgXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuICBcdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuICBcdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuICBcdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmIChjbG9zZWQpIHtcbiAgXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuICBcdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHguc2F2ZSgpO1xuICBcdFx0XHRjdHguc2NhbGUoMSwgcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcbiAgXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuICBcdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcbiAgXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICBcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuICBcdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG4gIFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuICBcdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuICBcdFx0XHRjdHguc3Ryb2tlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuICBcdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG4gIFx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG4gIFx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG4gIFx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcbiAgXHR9LFxuXG5cbiAgXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG4gIFx0XHRpZiAobGF5ZXIpIHtcbiAgXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG4gIFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICBcdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG4gIFx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3JcbiAgXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcbiAgXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG4gIFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcbiAgXHRcdHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH0sIHRoaXMpLCAzMik7XG4gIFx0fSxcblxuICBcdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcbiAgXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuICBcdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICAgKi9cblxuXG4gIHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdHRyeSB7XG4gIFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gIFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcbiAgXHR9XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0fTtcbiAgfSkoKTtcblxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICpcbiAgICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICovXG5cbiAgLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbiAgdmFyIHZtbE1peGluID0ge1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuICBcdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG4gIFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHRyZW1vdmUoY29udGFpbmVyKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcbiAgXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuICBcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuICBcdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0aWYgKCFzdHJva2UpIHtcbiAgXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4JztcbiAgXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuICBcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICBcdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGlmICghZmlsbCkge1xuICBcdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcbiAgXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuU1ZHXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL3N2ZyksIFNWRyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAgICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAgICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICAgKiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG4gIFx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICBcdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG4gIFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG4gIFx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgXHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cbiAgXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcbiAgXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cbiAgXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG4gIFx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcbiAgXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcbiAgXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcbiAgXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuICBcdH0sXG5cbiAgXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9CYWNrKGxheWVyLl9wYXRoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIGlmIChCcm93c2VyLnZtbCkge1xuICBcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbiAgfVxuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHXG4gIC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG4gIFx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcbiAgXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG4gIFx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuICBcdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuICBcdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuICBcdFx0aWYgKCFyZW5kZXJlcikge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG4gIFx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG4gIFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAgICovXG5cbiAgLypcbiAgICogQGNsYXNzIFJlY3RhbmdsZVxuICAgKiBAYWthIEwuUmVjdGFuZ2xlXG4gICAqIEBpbmhlcml0cyBQb2x5Z29uXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICAgKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICAgKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKi9cblxuXG4gIHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuICBcdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG4gIFx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG4gIFx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcbiAgXHR9LFxuXG4gIFx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuICBcdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcbiAgXHRcdHJldHVybiBbXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuICBcdFx0XTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFNWRy5jcmVhdGUgPSBjcmVhdGU7XG4gIFNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbiAgR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG4gIEdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3JkcztcbiAgR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG4gIEdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG4gIEdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG4gIFx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG4gIFx0Ym94Wm9vbTogdHJ1ZVxuICB9KTtcblxuICB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmUodGhpcy5fcGFuZSk7XG4gIFx0XHRkZWxldGUgdGhpcy5fcGFuZTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG4gIFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuICBcdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0b24oZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cbiAgXHRcdFx0dGhpcy5fYm94ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuICBcdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cbiAgXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuICBcdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gIFx0fSxcblxuICBcdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fYm94KTtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcbiAgXHRcdH1cblxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdG9mZihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9maW5pc2goKTtcblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cbiAgXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuICBcdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuICBcdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gIFx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuICBcdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuICAvLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcbiAgXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcbiAgXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAgXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcbiAgXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy9cbiAgLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4gIC8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbiAgLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIGBgYGpzXG4gIC8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuICAvLyBgYGBcbiAgLy9cbiAgLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuICAvLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cbiAgXHRkcmFnZ2luZzogdHJ1ZSxcblxuICBcdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuICBcdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcbiAgXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuICBcdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcbiAgXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gIFx0aW5lcnRpYTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuICBcdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cbiAgXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuICBcdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG4gIFx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG4gIFx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cbiAgXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuICBcdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuICBcdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG4gIFx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuICBcdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG4gIFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuICBcdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG4gIFx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcbiAgXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG4gIFx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcbiAgXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cbiAgXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxuICB9KTtcblxuICB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHRcdH0sIHRoaXMpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcbiAgXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcbiAgXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcbiAgXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG4gIFx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcbiAgXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcbiAgXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG4gIFx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0bWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcbiAgXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuICBcdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuICBcdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cbiAgXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG4gIFx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcbiAgXHR9LFxuXG4gIFx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcbiAgXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cbiAgXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuICBcdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuICBcdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cbiAgXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcbiAgXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcbiAgXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcbiAgXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcbiAgXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG4gIFx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gIFx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG4gIFx0XHRpZiAobm9JbmVydGlhKSB7XG4gIFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuICBcdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuICBcdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuICBcdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuICBcdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuICBcdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuICBcdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG4gIFx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG4gIFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG4gIFx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcbiAgXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG4gIFx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cbiAgLypcbiAgICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG4gIFx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG4gIFx0a2V5Ym9hcmQ6IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG4gIFx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG4gIFx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbiAgfSk7XG5cbiAgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG4gIFx0a2V5Q29kZXM6IHtcbiAgXHRcdGxlZnQ6ICAgIFszN10sXG4gIFx0XHRyaWdodDogICBbMzldLFxuICBcdFx0ZG93bjogICAgWzQwXSxcbiAgXHRcdHVwOiAgICAgIFszOF0sXG4gIFx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuICBcdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cbiAgXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuICBcdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cbiAgXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuICBcdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG4gIFx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcbiAgXHRcdH1cblxuICBcdFx0b24oY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub24oe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9mZih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gIFx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIFx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuICBcdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuICBcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuICBcdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG4gIFx0fSxcblxuICBcdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuICBcdH0sXG5cbiAgXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvZmZzZXQ7XG5cbiAgXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuICBcdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuICBcdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KHRvUG9pbnQob2Zmc2V0KSwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuICBcdFx0XHRcdFx0dmFyIG5ld0xhdExuZyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobWFwLnByb2plY3QobWFwLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSkpO1xuICBcdFx0XHRcdFx0bWFwLnBhblRvKG5ld0xhdExuZyk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG4gIFx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0c3RvcChlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuICAvLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gTW91c2Ugd2hlZWwgb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuICBcdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cbiAgXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuICBcdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG4gIFx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG4gIFx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG4gIFx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuICBcdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcbiAgXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG4gIFx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG4gIFx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbiAgfSk7XG5cbiAgdmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSA9IDA7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBkZWx0YSA9IGdldFdoZWVsRGVsdGEoZSk7XG5cbiAgXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcbiAgXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcbiAgXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cbiAgXHRcdHN0b3AoZSk7XG4gIFx0fSxcblxuICBcdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuICBcdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cbiAgXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuICBcdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuICBcdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcbiAgXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cbiAgXHRcdHRoaXMuX2RlbHRhID0gMDtcbiAgXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4gIC8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuXG4gIC8qXG4gICAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAgICogd2hpY2ggb3RoZXJ3aXNlIGlzIG5vdCBmaXJlZCBieSBtb2JpbGUgU2FmYXJpLlxuICAgKi9cblxuICB2YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdGFwSG9sZDogQm9vbGVhblxuICBcdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cbiAgXHR0YXBIb2xkOiBCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIubW9iaWxlLFxuXG4gIFx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG4gIFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcbiAgXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cbiAgXHR0YXBUb2xlcmFuY2U6IDE1XG4gIH0pO1xuXG4gIHZhciBUYXBIb2xkID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuICBcdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG4gIFx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX2NhbmNlbCgpO1xuICBcdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuICBcdFx0XHQvLyBwcmV2ZW50IHNpbXVsYXRlZCBtb3VzZSBldmVudHMgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3RvdWNoLWV2ZW50cy8jbW91c2UtZXZlbnRzXG4gIFx0XHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gIFx0XHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuICBcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcbiAgXHRcdH0sIHRoaXMpLCB0YXBIb2xkRGVsYXkpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGNhbmNlbENsaWNrUHJldmVudCk7XG4gIFx0fSxcblxuICBcdF9jYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuICBcdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuICBcdH0sXG5cbiAgXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG4gIFx0fSxcblxuICBcdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICBcdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwge1xuICBcdFx0XHRidWJibGVzOiB0cnVlLFxuICBcdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuICBcdFx0XHR2aWV3OiB3aW5kb3csXG4gIFx0XHRcdC8vIGRldGFpbDogMSxcbiAgXHRcdFx0c2NyZWVuWDogZS5zY3JlZW5YLFxuICBcdFx0XHRzY3JlZW5ZOiBlLnNjcmVlblksXG4gIFx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcbiAgXHRcdFx0Y2xpZW50WTogZS5jbGllbnRZLFxuICBcdFx0XHQvLyBidXR0b246IDIsXG4gIFx0XHRcdC8vIGJ1dHRvbnM6IDJcbiAgXHRcdH0pO1xuXG4gIFx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblxuICBcdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgdGFwSG9sZDogSGFuZGxlclxuICAvLyBMb25nIHRhcCBoYW5kbGVyIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgKHVzZWZ1bCBpbiBtb2JpbGUgU2FmYXJpKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG4gIFx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2ZcbiAgXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuICBcdC8vIGJyb3dzZXJzLlxuICBcdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCxcblxuICBcdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuICBcdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cbiAgXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbiAgfSk7XG5cbiAgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuICBcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuICBcdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcbiAgXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG4gIFx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcbiAgXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuICBcdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cbiAgXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG4gIFx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG4gIFx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG4gIFx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuICBcdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcbiAgXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG4gIFx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG4gIFx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSk7XG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuICBcdFx0dmFyIG1vdmVGbiA9IGJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9LCB1bmRlZmluZWQpO1xuICBcdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuICBcdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuICBcdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4gIC8vIFRvdWNoIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG5cbiAgTWFwLkJveFpvb20gPSBCb3hab29tO1xuICBNYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuICBNYXAuRHJhZyA9IERyYWc7XG4gIE1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuICBNYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuICBNYXAuVGFwSG9sZCA9IFRhcEhvbGQ7XG4gIE1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbiAgZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHM7XG4gIGV4cG9ydHMuQnJvd3NlciA9IEJyb3dzZXI7XG4gIGV4cG9ydHMuQ1JTID0gQ1JTO1xuICBleHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbiAgZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG4gIGV4cG9ydHMuQ2lyY2xlTWFya2VyID0gQ2lyY2xlTWFya2VyO1xuICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XG4gIGV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2w7XG4gIGV4cG9ydHMuRGl2SWNvbiA9IERpdkljb247XG4gIGV4cG9ydHMuRGl2T3ZlcmxheSA9IERpdk92ZXJsYXk7XG4gIGV4cG9ydHMuRG9tRXZlbnQgPSBEb21FdmVudDtcbiAgZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcbiAgZXhwb3J0cy5EcmFnZ2FibGUgPSBEcmFnZ2FibGU7XG4gIGV4cG9ydHMuRXZlbnRlZCA9IEV2ZW50ZWQ7XG4gIGV4cG9ydHMuRmVhdHVyZUdyb3VwID0gRmVhdHVyZUdyb3VwO1xuICBleHBvcnRzLkdlb0pTT04gPSBHZW9KU09OO1xuICBleHBvcnRzLkdyaWRMYXllciA9IEdyaWRMYXllcjtcbiAgZXhwb3J0cy5IYW5kbGVyID0gSGFuZGxlcjtcbiAgZXhwb3J0cy5JY29uID0gSWNvbjtcbiAgZXhwb3J0cy5JbWFnZU92ZXJsYXkgPSBJbWFnZU92ZXJsYXk7XG4gIGV4cG9ydHMuTGF0TG5nID0gTGF0TG5nO1xuICBleHBvcnRzLkxhdExuZ0JvdW5kcyA9IExhdExuZ0JvdW5kcztcbiAgZXhwb3J0cy5MYXllciA9IExheWVyO1xuICBleHBvcnRzLkxheWVyR3JvdXAgPSBMYXllckdyb3VwO1xuICBleHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG4gIGV4cG9ydHMuTWFwID0gTWFwO1xuICBleHBvcnRzLk1hcmtlciA9IE1hcmtlcjtcbiAgZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuICBleHBvcnRzLlBhdGggPSBQYXRoO1xuICBleHBvcnRzLlBvaW50ID0gUG9pbnQ7XG4gIGV4cG9ydHMuUG9seVV0aWwgPSBQb2x5VXRpbDtcbiAgZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcbiAgZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuICBleHBvcnRzLlBvcHVwID0gUG9wdXA7XG4gIGV4cG9ydHMuUG9zQW5pbWF0aW9uID0gUG9zQW5pbWF0aW9uO1xuICBleHBvcnRzLlByb2plY3Rpb24gPSBpbmRleDtcbiAgZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4gIGV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgZXhwb3J0cy5TVkcgPSBTVkc7XG4gIGV4cG9ydHMuU1ZHT3ZlcmxheSA9IFNWR092ZXJsYXk7XG4gIGV4cG9ydHMuVGlsZUxheWVyID0gVGlsZUxheWVyO1xuICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuICBleHBvcnRzLlRyYW5zZm9ybWF0aW9uID0gVHJhbnNmb3JtYXRpb247XG4gIGV4cG9ydHMuVXRpbCA9IFV0aWw7XG4gIGV4cG9ydHMuVmlkZW9PdmVybGF5ID0gVmlkZW9PdmVybGF5O1xuICBleHBvcnRzLmJpbmQgPSBiaW5kO1xuICBleHBvcnRzLmJvdW5kcyA9IHRvQm91bmRzO1xuICBleHBvcnRzLmNhbnZhcyA9IGNhbnZhcztcbiAgZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XG4gIGV4cG9ydHMuY2lyY2xlTWFya2VyID0gY2lyY2xlTWFya2VyO1xuICBleHBvcnRzLmNvbnRyb2wgPSBjb250cm9sO1xuICBleHBvcnRzLmRpdkljb24gPSBkaXZJY29uO1xuICBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbiAgZXhwb3J0cy5mZWF0dXJlR3JvdXAgPSBmZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuZ2VvSlNPTiA9IGdlb0pTT047XG4gIGV4cG9ydHMuZ2VvSnNvbiA9IGdlb0pzb247XG4gIGV4cG9ydHMuZ3JpZExheWVyID0gZ3JpZExheWVyO1xuICBleHBvcnRzLmljb24gPSBpY29uO1xuICBleHBvcnRzLmltYWdlT3ZlcmxheSA9IGltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5sYXRMbmcgPSB0b0xhdExuZztcbiAgZXhwb3J0cy5sYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcztcbiAgZXhwb3J0cy5sYXllckdyb3VwID0gbGF5ZXJHcm91cDtcbiAgZXhwb3J0cy5tYXAgPSBjcmVhdGVNYXA7XG4gIGV4cG9ydHMubWFya2VyID0gbWFya2VyO1xuICBleHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcbiAgZXhwb3J0cy5wb2x5Z29uID0gcG9seWdvbjtcbiAgZXhwb3J0cy5wb2x5bGluZSA9IHBvbHlsaW5lO1xuICBleHBvcnRzLnBvcHVwID0gcG9wdXA7XG4gIGV4cG9ydHMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuICBleHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuICBleHBvcnRzLnN0YW1wID0gc3RhbXA7XG4gIGV4cG9ydHMuc3ZnID0gc3ZnO1xuICBleHBvcnRzLnN2Z092ZXJsYXkgPSBzdmdPdmVybGF5O1xuICBleHBvcnRzLnRpbGVMYXllciA9IHRpbGVMYXllcjtcbiAgZXhwb3J0cy50b29sdGlwID0gdG9vbHRpcDtcbiAgZXhwb3J0cy50cmFuc2Zvcm1hdGlvbiA9IHRvVHJhbnNmb3JtYXRpb247XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gIGV4cG9ydHMudmlkZW9PdmVybGF5ID0gdmlkZW9PdmVybGF5O1xuXG4gIHZhciBvbGRMID0gd2luZG93Lkw7XG4gIGV4cG9ydHMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICBcdHdpbmRvdy5MID0gb2xkTDtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfVxuICAvLyBBbHdheXMgZXhwb3J0IHVzIHRvIHdpbmRvdyBnbG9iYWwgKHNlZSAjMjM2NClcbiAgd2luZG93LkwgPSBleHBvcnRzO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LXNyYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwibGVhZmxldCIsInZlcnNpb24iLCJleHRlbmQiLCJkZXN0IiwiaSIsImoiLCJsZW4iLCJzcmMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjcmVhdGUkMiIsIk9iamVjdCIsImNyZWF0ZSIsIkYiLCJwcm90byIsInByb3RvdHlwZSIsImJpbmQiLCJmbiIsIm9iaiIsInNsaWNlIiwiQXJyYXkiLCJhcHBseSIsImNhbGwiLCJhcmdzIiwiY29uY2F0IiwibGFzdElkIiwic3RhbXAiLCJfbGVhZmxldF9pZCIsInRocm90dGxlIiwidGltZSIsImNvbnRleHQiLCJsb2NrIiwid3JhcHBlckZuIiwibGF0ZXIiLCJzZXRUaW1lb3V0Iiwid3JhcE51bSIsIngiLCJyYW5nZSIsImluY2x1ZGVNYXgiLCJtYXgiLCJtaW4iLCJkIiwiZmFsc2VGbiIsImZvcm1hdE51bSIsIm51bSIsInByZWNpc2lvbiIsInBvdyIsIk1hdGgiLCJ1bmRlZmluZWQiLCJyb3VuZCIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwic3BsaXRXb3JkcyIsInNwbGl0Iiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsImdldFBhcmFtU3RyaW5nIiwiZXhpc3RpbmdVcmwiLCJ1cHBlcmNhc2UiLCJwYXJhbXMiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9VcHBlckNhc2UiLCJpbmRleE9mIiwiam9pbiIsInRlbXBsYXRlUmUiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJrZXkiLCJ2YWx1ZSIsIkVycm9yIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiYXJyYXkiLCJlbCIsImVtcHR5SW1hZ2VVcmwiLCJnZXRQcmVmaXhlZCIsIm5hbWUiLCJ3aW5kb3ciLCJsYXN0VGltZSIsInRpbWVvdXREZWZlciIsIkRhdGUiLCJ0aW1lVG9DYWxsIiwicmVxdWVzdEZuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsRm4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdEFuaW1GcmFtZSIsImltbWVkaWF0ZSIsImNhbmNlbEFuaW1GcmFtZSIsIlV0aWwiLCJfX3Byb3RvX18iLCJDbGFzcyIsInByb3BzIiwiTmV3Q2xhc3MiLCJpbml0aWFsaXplIiwiY2FsbEluaXRIb29rcyIsInBhcmVudFByb3RvIiwiX19zdXBlcl9fIiwiY29uc3RydWN0b3IiLCJzdGF0aWNzIiwiaW5jbHVkZXMiLCJjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyIsIl9pbml0SG9va3MiLCJfaW5pdEhvb2tzQ2FsbGVkIiwiaW5jbHVkZSIsInBhcmVudE9wdGlvbnMiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJFdmVudHMiLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwib24iLCJ0eXBlcyIsInR5cGUiLCJfb24iLCJvZmYiLCJfZXZlbnRzIiwiX29mZiIsInJlbW92ZUFsbCIsIl9vbmNlIiwiX2xpc3RlbnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsIm9uY2UiLCJsaXN0ZW5lcnMiLCJfZmlyaW5nQ291bnQiLCJpbmRleCIsImxpc3RlbmVyIiwic3BsaWNlIiwiZmlyZSIsInByb3BhZ2F0ZSIsImxpc3RlbnMiLCJldmVudCIsInRhcmdldCIsInNvdXJjZVRhcmdldCIsImwiLCJfcHJvcGFnYXRlRXZlbnQiLCJfZm4iLCJfZXZlbnRQYXJlbnRzIiwiYWRkRXZlbnRQYXJlbnQiLCJyZW1vdmVFdmVudFBhcmVudCIsImUiLCJsYXllciIsInByb3BhZ2F0ZWRGcm9tIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJQb2ludCIsInkiLCJ0cnVuYyIsInYiLCJmbG9vciIsImNlaWwiLCJjbG9uZSIsImFkZCIsInBvaW50IiwiX2FkZCIsInRvUG9pbnQiLCJzdWJ0cmFjdCIsIl9zdWJ0cmFjdCIsImRpdmlkZUJ5IiwiX2RpdmlkZUJ5IiwibXVsdGlwbHlCeSIsIl9tdWx0aXBseUJ5Iiwic2NhbGVCeSIsInVuc2NhbGVCeSIsIl9yb3VuZCIsIl9mbG9vciIsIl9jZWlsIiwiX3RydW5jIiwiZGlzdGFuY2VUbyIsInNxcnQiLCJlcXVhbHMiLCJjb250YWlucyIsImFicyIsIkJvdW5kcyIsImEiLCJiIiwicG9pbnRzIiwibWluMiIsIm1heDIiLCJ0b0JvdW5kcyIsImdldENlbnRlciIsImdldEJvdHRvbUxlZnQiLCJnZXRUb3BSaWdodCIsImdldFRvcExlZnQiLCJnZXRCb3R0b21SaWdodCIsImdldFNpemUiLCJpbnRlcnNlY3RzIiwiYm91bmRzIiwieEludGVyc2VjdHMiLCJ5SW50ZXJzZWN0cyIsIm92ZXJsYXBzIiwieE92ZXJsYXBzIiwieU92ZXJsYXBzIiwiaXNWYWxpZCIsInBhZCIsImJ1ZmZlclJhdGlvIiwiaGVpZ2h0QnVmZmVyIiwid2lkdGhCdWZmZXIiLCJMYXRMbmdCb3VuZHMiLCJjb3JuZXIxIiwiY29ybmVyMiIsImxhdGxuZ3MiLCJzdyIsIl9zb3V0aFdlc3QiLCJuZSIsIl9ub3J0aEVhc3QiLCJzdzIiLCJuZTIiLCJMYXRMbmciLCJ0b0xhdExuZyIsInRvTGF0TG5nQm91bmRzIiwibGF0IiwibG5nIiwiZ2V0U291dGhXZXN0IiwiZ2V0Tm9ydGhFYXN0IiwiZ2V0Tm9ydGhXZXN0IiwiZ2V0Tm9ydGgiLCJnZXRXZXN0IiwiZ2V0U291dGhFYXN0IiwiZ2V0U291dGgiLCJnZXRFYXN0IiwibGF0SW50ZXJzZWN0cyIsImxuZ0ludGVyc2VjdHMiLCJsYXRPdmVybGFwcyIsImxuZ092ZXJsYXBzIiwidG9CQm94U3RyaW5nIiwibWF4TWFyZ2luIiwiYWx0IiwiaXNOYU4iLCJtYXJnaW4iLCJvdGhlciIsIkVhcnRoIiwiZGlzdGFuY2UiLCJ3cmFwIiwid3JhcExhdExuZyIsInNpemVJbk1ldGVycyIsImxhdEFjY3VyYWN5IiwibG5nQWNjdXJhY3kiLCJjb3MiLCJQSSIsImMiLCJsb24iLCJDUlMiLCJsYXRMbmdUb1BvaW50IiwibGF0bG5nIiwiem9vbSIsInByb2plY3RlZFBvaW50IiwicHJvamVjdGlvbiIsInByb2plY3QiLCJzY2FsZSIsInRyYW5zZm9ybWF0aW9uIiwiX3RyYW5zZm9ybSIsInBvaW50VG9MYXRMbmciLCJ1bnRyYW5zZm9ybWVkUG9pbnQiLCJ1bnRyYW5zZm9ybSIsInVucHJvamVjdCIsImxvZyIsIkxOMiIsImdldFByb2plY3RlZEJvdW5kcyIsImluZmluaXRlIiwicyIsInRyYW5zZm9ybSIsIndyYXBMbmciLCJ3cmFwTGF0Iiwid3JhcExhdExuZ0JvdW5kcyIsImNlbnRlciIsIm5ld0NlbnRlciIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwiUiIsImxhdGxuZzEiLCJsYXRsbmcyIiwicmFkIiwibGF0MSIsImxhdDIiLCJzaW5ETGF0Iiwic2luIiwic2luRExvbiIsImF0YW4yIiwiZWFydGhSYWRpdXMiLCJTcGhlcmljYWxNZXJjYXRvciIsIk1BWF9MQVRJVFVERSIsImF0YW4iLCJleHAiLCJUcmFuc2Zvcm1hdGlvbiIsIl9hIiwiX2IiLCJfYyIsIl9kIiwidG9UcmFuc2Zvcm1hdGlvbiIsIkVQU0czODU3IiwiY29kZSIsIkVQU0c5MDA5MTMiLCJzdmdDcmVhdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiY2xvc2VkIiwibGVuMiIsInAiLCJCcm93c2VyIiwic3ZnIiwic3R5bGUiLCJkb2N1bWVudEVsZW1lbnQiLCJpZSIsImllbHQ5IiwiZWRnZSIsIm5hdmlnYXRvciIsIndlYmtpdCIsInVzZXJBZ2VudENvbnRhaW5zIiwiYW5kcm9pZCIsImFuZHJvaWQyMyIsIndlYmtpdFZlciIsInBhcnNlSW50IiwiZXhlYyIsInVzZXJBZ2VudCIsImFuZHJvaWRTdG9jayIsIm9wZXJhIiwiY2hyb21lIiwiZ2Vja28iLCJzYWZhcmkiLCJwaGFudG9tIiwib3BlcmExMiIsIndpbiIsInBsYXRmb3JtIiwiaWUzZCIsIndlYmtpdDNkIiwiV2ViS2l0Q1NTTWF0cml4IiwiZ2Vja28zZCIsImFueTNkIiwiTF9ESVNBQkxFXzNEIiwibW9iaWxlIiwib3JpZW50YXRpb24iLCJtb2JpbGVXZWJraXQiLCJtb2JpbGVXZWJraXQzZCIsIm1zUG9pbnRlciIsIlBvaW50ZXJFdmVudCIsIk1TUG9pbnRlckV2ZW50IiwicG9pbnRlciIsInRvdWNoTmF0aXZlIiwiVG91Y2hFdmVudCIsInRvdWNoIiwiTF9OT19UT1VDSCIsIm1vYmlsZU9wZXJhIiwibW9iaWxlR2Vja28iLCJyZXRpbmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwicGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZU9wdGlvbiIsIm9wdHMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImNhbnZhcyQxIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJzdmckMSIsImNyZWF0ZVNWR1JlY3QiLCJpbmxpbmVTdmciLCJkaXYiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwibmFtZXNwYWNlVVJJIiwidm1sIiwic2hhcGUiLCJiZWhhdmlvciIsImFkaiIsIm1hYyIsImxpbnV4IiwidG9Mb3dlckNhc2UiLCJjYW52YXMiLCJQT0lOVEVSX0RPV04iLCJQT0lOVEVSX01PVkUiLCJQT0lOVEVSX1VQIiwiUE9JTlRFUl9DQU5DRUwiLCJwRXZlbnQiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJ0b3VjaGNhbmNlbCIsImhhbmRsZSIsIl9vblBvaW50ZXJTdGFydCIsIl9oYW5kbGVQb2ludGVyIiwiX3BvaW50ZXJzIiwiX3BvaW50ZXJEb2NMaXN0ZW5lciIsImFkZFBvaW50ZXJMaXN0ZW5lciIsImhhbmRsZXIiLCJfYWRkUG9pbnRlckRvY0xpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiX2dsb2JhbFBvaW50ZXJEb3duIiwicG9pbnRlcklkIiwiX2dsb2JhbFBvaW50ZXJNb3ZlIiwiX2dsb2JhbFBvaW50ZXJVcCIsInBvaW50ZXJUeXBlIiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsInByZXZlbnREZWZhdWx0IiwibWFrZURibGNsaWNrIiwibmV3RXZlbnQiLCJwcm9wIiwiZGV0YWlsIiwiaXNUcnVzdGVkIiwiX3NpbXVsYXRlZCIsImRlbGF5IiwiYWRkRG91YmxlVGFwTGlzdGVuZXIiLCJsYXN0Iiwic2ltRGJsY2xpY2siLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwicGF0aCIsImdldFByb3BhZ2F0aW9uUGF0aCIsInNvbWUiLCJIVE1MTGFiZWxFbGVtZW50IiwiYXR0cmlidXRlcyIsImZvciIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIm5vdyIsImRibGNsaWNrIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJoYW5kbGVycyIsIlRSQU5TRk9STSIsInRlc3RQcm9wIiwiVFJBTlNJVElPTiIsIlRSQU5TSVRJT05fRU5EIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNyZWF0ZSQxIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwicmVtb3ZlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW1wdHkiLCJ0b0Zyb250IiwibGFzdENoaWxkIiwidG9CYWNrIiwiaW5zZXJ0QmVmb3JlIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRDbGFzcyIsIlJlZ0V4cCIsInRlc3QiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJzZXRDbGFzcyIsInJlbW92ZUNsYXNzIiwiYmFzZVZhbCIsImNvcnJlc3BvbmRpbmdFbGVtZW50Iiwic2V0T3BhY2l0eSIsIm9wYWNpdHkiLCJfc2V0T3BhY2l0eUlFIiwiZmlsdGVyIiwiZmlsdGVyTmFtZSIsImZpbHRlcnMiLCJpdGVtIiwiRW5hYmxlZCIsIk9wYWNpdHkiLCJzZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJwb3MiLCJzZXRQb3NpdGlvbiIsIl9sZWFmbGV0X3BvcyIsImxlZnQiLCJ0b3AiLCJnZXRQb3NpdGlvbiIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsIl91c2VyU2VsZWN0IiwidXNlclNlbGVjdFByb3BlcnR5IiwiZGlzYWJsZUltYWdlRHJhZyIsImVuYWJsZUltYWdlRHJhZyIsIl9vdXRsaW5lRWxlbWVudCIsIl9vdXRsaW5lU3R5bGUiLCJwcmV2ZW50T3V0bGluZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsInJlc3RvcmVPdXRsaW5lIiwib3V0bGluZVN0eWxlIiwiZ2V0U2l6ZWRQYXJlbnROb2RlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJib2R5IiwiZ2V0U2NhbGUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJEb21VdGlsIiwiYWRkT25lIiwiZXZlbnRzS2V5IiwiYmF0Y2hSZW1vdmUiLCJyZW1vdmVPbmUiLCJmaWx0ZXJGbiIsIm1vdXNlU3Vic3QiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIndoZWVsIiwib3JpZ2luYWxIYW5kbGVyIiwicGFzc2l2ZSIsImlzRXh0ZXJuYWxUYXJnZXQiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ2luYWxFdmVudCIsIl9zdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24iLCJyZXR1cm5WYWx1ZSIsInN0b3AiLCJldiIsImNvbXBvc2VkUGF0aCIsImdldE1vdXNlUG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJ3aGVlbFB4RmFjdG9yIiwiZ2V0V2hlZWxEZWx0YSIsIndoZWVsRGVsdGFZIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwiZGVsdGFaIiwid2hlZWxEZWx0YSIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwiZXJyIiwiRG9tRXZlbnQiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiUG9zQW5pbWF0aW9uIiwicnVuIiwibmV3UG9zIiwiZHVyYXRpb24iLCJlYXNlTGluZWFyaXR5IiwiX2VsIiwiX2luUHJvZ3Jlc3MiLCJfZHVyYXRpb24iLCJfZWFzZU91dFBvd2VyIiwiX3N0YXJ0UG9zIiwiX29mZnNldCIsIl9zdGFydFRpbWUiLCJfYW5pbWF0ZSIsIl9zdGVwIiwiX2NvbXBsZXRlIiwiX2FuaW1JZCIsImVsYXBzZWQiLCJfcnVuRnJhbWUiLCJfZWFzZU91dCIsInByb2dyZXNzIiwidCIsIk1hcCIsImNycyIsIm1pblpvb20iLCJtYXhab29tIiwibGF5ZXJzIiwibWF4Qm91bmRzIiwicmVuZGVyZXIiLCJ6b29tQW5pbWF0aW9uIiwiem9vbUFuaW1hdGlvblRocmVzaG9sZCIsImZhZGVBbmltYXRpb24iLCJtYXJrZXJab29tQW5pbWF0aW9uIiwidHJhbnNmb3JtM0RMaW1pdCIsInpvb21TbmFwIiwiem9vbURlbHRhIiwidHJhY2tSZXNpemUiLCJfaGFuZGxlcnMiLCJfbGF5ZXJzIiwiX3pvb21Cb3VuZExheWVycyIsIl9zaXplQ2hhbmdlZCIsIl9pbml0Q29udGFpbmVyIiwiX2luaXRMYXlvdXQiLCJfb25SZXNpemUiLCJfaW5pdEV2ZW50cyIsInNldE1heEJvdW5kcyIsIl96b29tIiwiX2xpbWl0Wm9vbSIsInNldFZpZXciLCJyZXNldCIsIl96b29tQW5pbWF0ZWQiLCJfY3JlYXRlQW5pbVByb3h5IiwiX3Byb3h5IiwiX2NhdGNoVHJhbnNpdGlvbkVuZCIsIl9hZGRMYXllcnMiLCJfbGltaXRDZW50ZXIiLCJfc3RvcCIsIl9sb2FkZWQiLCJhbmltYXRlIiwicGFuIiwibW92ZWQiLCJfdHJ5QW5pbWF0ZWRab29tIiwiX3RyeUFuaW1hdGVkUGFuIiwiX3NpemVUaW1lciIsIl9yZXNldFZpZXciLCJub01vdmVTdGFydCIsInNldFpvb20iLCJ6b29tSW4iLCJkZWx0YSIsInpvb21PdXQiLCJzZXRab29tQXJvdW5kIiwiZ2V0Wm9vbVNjYWxlIiwidmlld0hhbGYiLCJjb250YWluZXJQb2ludCIsImxhdExuZ1RvQ29udGFpbmVyUG9pbnQiLCJjZW50ZXJPZmZzZXQiLCJjb250YWluZXJQb2ludFRvTGF0TG5nIiwiX2dldEJvdW5kc0NlbnRlclpvb20iLCJnZXRCb3VuZHMiLCJwYWRkaW5nVEwiLCJwYWRkaW5nVG9wTGVmdCIsInBhZGRpbmciLCJwYWRkaW5nQlIiLCJwYWRkaW5nQm90dG9tUmlnaHQiLCJnZXRCb3VuZHNab29tIiwiSW5maW5pdHkiLCJwYWRkaW5nT2Zmc2V0Iiwic3dQb2ludCIsIm5lUG9pbnQiLCJmaXRCb3VuZHMiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJnZXRab29tIiwiX3BhbkFuaW0iLCJfb25QYW5UcmFuc2l0aW9uU3RlcCIsIl9vblBhblRyYW5zaXRpb25FbmQiLCJfbWFwUGFuZSIsIl9nZXRNYXBQYW5lUG9zIiwiX3Jhd1BhbkJ5IiwiZmx5VG8iLCJ0YXJnZXRDZW50ZXIiLCJ0YXJnZXRab29tIiwiZnJvbSIsInRvIiwic2l6ZSIsInN0YXJ0Wm9vbSIsIncwIiwidzEiLCJ1MSIsInJobyIsInJobzIiLCJyIiwiczEiLCJzMiIsInQxIiwiYjEiLCJzcSIsInNpbmgiLCJuIiwiY29zaCIsInRhbmgiLCJyMCIsInciLCJ1IiwiZWFzZU91dCIsInN0YXJ0IiwiUyIsImZyYW1lIiwiX2ZseVRvRnJhbWUiLCJfbW92ZSIsImdldFNjYWxlWm9vbSIsIl9tb3ZlRW5kIiwiX21vdmVTdGFydCIsImZseVRvQm91bmRzIiwiX3Bhbkluc2lkZU1heEJvdW5kcyIsInNldE1pblpvb20iLCJvbGRab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJwYW5JbnNpZGUiLCJwaXhlbENlbnRlciIsInBpeGVsUG9pbnQiLCJwaXhlbEJvdW5kcyIsImdldFBpeGVsQm91bmRzIiwicGFkZGVkQm91bmRzIiwicGFkZGVkU2l6ZSIsImludmFsaWRhdGVTaXplIiwib2xkU2l6ZSIsIl9sYXN0Q2VudGVyIiwibmV3U2l6ZSIsIm9sZENlbnRlciIsImRlYm91bmNlTW92ZWVuZCIsImxvY2F0ZSIsIl9sb2NhdGVPcHRpb25zIiwidGltZW91dCIsIndhdGNoIiwiX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IiLCJtZXNzYWdlIiwib25SZXNwb25zZSIsIl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlIiwib25FcnJvciIsIl9sb2NhdGlvbldhdGNoSWQiLCJnZW9sb2NhdGlvbiIsIndhdGNoUG9zaXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJzdG9wTG9jYXRlIiwiY2xlYXJXYXRjaCIsImVycm9yIiwiX2NvbnRhaW5lciIsImNvb3JkcyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiYWNjdXJhY3kiLCJ0aW1lc3RhbXAiLCJhZGRIYW5kbGVyIiwiSGFuZGxlckNsYXNzIiwiZW5hYmxlIiwiX2NvbnRhaW5lcklkIiwiX2NsZWFyQ29udHJvbFBvcyIsIl9yZXNpemVSZXF1ZXN0IiwiX2NsZWFySGFuZGxlcnMiLCJfcGFuZXMiLCJfcmVuZGVyZXIiLCJjcmVhdGVQYW5lIiwicGFuZSIsIl9jaGVja0lmTG9hZGVkIiwiX21vdmVkIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2dldENlbnRlckxheWVyUG9pbnQiLCJnZXRNaW5ab29tIiwiX2xheWVyc01pblpvb20iLCJnZXRNYXhab29tIiwiX2xheWVyc01heFpvb20iLCJpbnNpZGUiLCJudyIsInNlIiwiYm91bmRzU2l6ZSIsInNuYXAiLCJzY2FsZXgiLCJzY2FsZXkiLCJfc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidG9wTGVmdFBvaW50IiwiX2dldFRvcExlZnRQb2ludCIsImdldFBpeGVsT3JpZ2luIiwiX3BpeGVsT3JpZ2luIiwiZ2V0UGl4ZWxXb3JsZEJvdW5kcyIsImdldFBhbmUiLCJnZXRQYW5lcyIsImdldENvbnRhaW5lciIsInRvWm9vbSIsImZyb21ab29tIiwibGF0TG5nVG9MYXllclBvaW50IiwiY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQiLCJsYXllclBvaW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXRMbmciLCJfb25TY3JvbGwiLCJfZmFkZUFuaW1hdGVkIiwicG9zaXRpb24iLCJfaW5pdFBhbmVzIiwiX2luaXRDb250cm9sUG9zIiwicGFuZXMiLCJfcGFuZVJlbmRlcmVycyIsIm1hcmtlclBhbmUiLCJzaGFkb3dQYW5lIiwibG9hZGluZyIsInpvb21DaGFuZ2VkIiwic3VwcmVzc0V2ZW50IiwiX2dldE5ld1BpeGVsT3JpZ2luIiwicGluY2giLCJfZ2V0Wm9vbVNwYW4iLCJfdGFyZ2V0cyIsIm9uT2ZmIiwiX2hhbmRsZURPTUV2ZW50IiwiX29uTW92ZUVuZCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJfZmluZEV2ZW50VGFyZ2V0cyIsInRhcmdldHMiLCJpc0hvdmVyIiwic3JjRWxlbWVudCIsImRyYWdnaW5nIiwiX2RyYWdnYWJsZU1vdmVkIiwiX2lzQ2xpY2tEaXNhYmxlZCIsIl9maXJlRE9NRXZlbnQiLCJfbW91c2VFdmVudHMiLCJjYW52YXNUYXJnZXRzIiwic3ludGgiLCJmaWx0ZXJlZCIsImlzTWFya2VyIiwiZ2V0TGF0TG5nIiwiX3JhZGl1cyIsImJ1YmJsaW5nTW91c2VFdmVudHMiLCJlbmFibGVkIiwiYm94Wm9vbSIsImRpc2FibGUiLCJ3aGVuUmVhZHkiLCJjYWxsYmFjayIsInBpeGVsT3JpZ2luIiwiX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCIsInRvcExlZnQiLCJfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyIsImxhdExuZ0JvdW5kcyIsIl9nZXRDZW50ZXJPZmZzZXQiLCJjZW50ZXJQb2ludCIsInZpZXdCb3VuZHMiLCJfZ2V0Qm91bmRzT2Zmc2V0IiwiX2xpbWl0T2Zmc2V0IiwibmV3Qm91bmRzIiwicHhCb3VuZHMiLCJwcm9qZWN0ZWRNYXhCb3VuZHMiLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJkeCIsIl9yZWJvdW5kIiwiZHkiLCJyaWdodCIsInByb3h5IiwibWFwUGFuZSIsIl9hbmltYXRpbmdab29tIiwiX29uWm9vbVRyYW5zaXRpb25FbmQiLCJfYW5pbU1vdmVFbmQiLCJfZGVzdHJveUFuaW1Qcm94eSIsInoiLCJwcm9wZXJ0eU5hbWUiLCJfbm90aGluZ1RvQW5pbWF0ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYW5pbWF0ZVpvb20iLCJzdGFydEFuaW0iLCJub1VwZGF0ZSIsIl9hbmltYXRlVG9DZW50ZXIiLCJfYW5pbWF0ZVRvWm9vbSIsIl90ZW1wRmlyZVpvb21FdmVudCIsImNyZWF0ZU1hcCIsIkNvbnRyb2wiLCJtYXAiLCJfbWFwIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJhZGRUbyIsIm9uQWRkIiwiY29ybmVyIiwiX2NvbnRyb2xDb3JuZXJzIiwib25SZW1vdmUiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiTGF5ZXJzIiwiY29sbGFwc2VkIiwiYXV0b1pJbmRleCIsImhpZGVTaW5nbGVCYXNlIiwic29ydExheWVycyIsInNvcnRGdW5jdGlvbiIsImxheWVyQSIsImxheWVyQiIsIm5hbWVBIiwibmFtZUIiLCJiYXNlTGF5ZXJzIiwib3ZlcmxheXMiLCJfbGF5ZXJDb250cm9sSW5wdXRzIiwiX2xhc3RaSW5kZXgiLCJfaGFuZGxpbmdDbGljayIsIl9wcmV2ZW50Q2xpY2siLCJfYWRkTGF5ZXIiLCJfdXBkYXRlIiwiX2NoZWNrRGlzYWJsZWRMYXllcnMiLCJfb25MYXllckNoYW5nZSIsIl9leHBhbmRJZk5vdENvbGxhcHNlZCIsImFkZEJhc2VMYXllciIsImFkZE92ZXJsYXkiLCJyZW1vdmVMYXllciIsIl9nZXRMYXllciIsImV4cGFuZCIsIl9zZWN0aW9uIiwiYWNjZXB0YWJsZUhlaWdodCIsIm9mZnNldFRvcCIsImNvbGxhcHNlIiwic2V0QXR0cmlidXRlIiwic2VjdGlvbiIsIl9leHBhbmRTYWZlbHkiLCJsaW5rIiwiX2xheWVyc0xpbmsiLCJocmVmIiwidGl0bGUiLCJrZXlkb3duIiwia2V5Q29kZSIsImNsaWNrIiwiX2Jhc2VMYXllcnNMaXN0IiwiX3NlcGFyYXRvciIsIl9vdmVybGF5c0xpc3QiLCJvdmVybGF5Iiwic29ydCIsInNldFpJbmRleCIsImJhc2VMYXllcnNQcmVzZW50Iiwib3ZlcmxheXNQcmVzZW50IiwiYmFzZUxheWVyc0NvdW50IiwiX2FkZEl0ZW0iLCJkaXNwbGF5IiwiX2NyZWF0ZVJhZGlvRWxlbWVudCIsImNoZWNrZWQiLCJyYWRpb0h0bWwiLCJyYWRpb0ZyYWdtZW50IiwibGFiZWwiLCJoYXNMYXllciIsImlucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJsYXllcklkIiwiX29uSW5wdXRDbGljayIsImhvbGRlciIsImlucHV0cyIsImFkZGVkTGF5ZXJzIiwicmVtb3ZlZExheWVycyIsImFkZExheWVyIiwiZGlzYWJsZWQiLCJ0aGF0IiwiWm9vbSIsInpvb21JblRleHQiLCJ6b29tSW5UaXRsZSIsInpvb21PdXRUZXh0Iiwiem9vbU91dFRpdGxlIiwiem9vbU5hbWUiLCJfem9vbUluQnV0dG9uIiwiX2NyZWF0ZUJ1dHRvbiIsIl96b29tSW4iLCJfem9vbU91dEJ1dHRvbiIsIl96b29tT3V0IiwiX3VwZGF0ZURpc2FibGVkIiwiX2Rpc2FibGVkIiwic2hpZnRLZXkiLCJodG1sIiwiem9vbUNvbnRyb2wiLCJTY2FsZSIsIm1heFdpZHRoIiwibWV0cmljIiwiaW1wZXJpYWwiLCJfYWRkU2NhbGVzIiwidXBkYXRlV2hlbklkbGUiLCJfbVNjYWxlIiwiX2lTY2FsZSIsIm1heE1ldGVycyIsIl91cGRhdGVTY2FsZXMiLCJfdXBkYXRlTWV0cmljIiwiX3VwZGF0ZUltcGVyaWFsIiwibWV0ZXJzIiwiX2dldFJvdW5kTnVtIiwiX3VwZGF0ZVNjYWxlIiwibWF4RmVldCIsIm1heE1pbGVzIiwibWlsZXMiLCJmZWV0IiwidGV4dCIsInJhdGlvIiwicG93MTAiLCJ1a3JhaW5pYW5GbGFnIiwiQXR0cmlidXRpb24iLCJwcmVmaXgiLCJfYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb25Db250cm9sIiwiZ2V0QXR0cmlidXRpb24iLCJhZGRBdHRyaWJ1dGlvbiIsIl9hZGRBdHRyaWJ1dGlvbiIsInJlbW92ZUF0dHJpYnV0aW9uIiwic2V0UHJlZml4IiwiYXR0cmlicyIsInByZWZpeEFuZEF0dHJpYnMiLCJhdHRyaWJ1dGlvbiIsIkhhbmRsZXIiLCJfZW5hYmxlZCIsImFkZEhvb2tzIiwicmVtb3ZlSG9va3MiLCJTVEFSVCIsIkRyYWdnYWJsZSIsImNsaWNrVG9sZXJhbmNlIiwiZHJhZ1N0YXJ0VGFyZ2V0IiwiX2VsZW1lbnQiLCJfZHJhZ1N0YXJ0VGFyZ2V0IiwiX3ByZXZlbnRPdXRsaW5lIiwiX29uRG93biIsIl9kcmFnZ2luZyIsImZpbmlzaERyYWciLCJ3aGljaCIsImJ1dHRvbiIsIl9tb3ZpbmciLCJmaXJzdCIsInNpemVkUGFyZW50IiwiX3N0YXJ0UG9pbnQiLCJfcGFyZW50U2NhbGUiLCJtb3VzZWV2ZW50IiwiX29uTW92ZSIsIl9vblVwIiwiX2xhc3RUYXJnZXQiLCJTVkdFbGVtZW50SW5zdGFuY2UiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIl9uZXdQb3MiLCJfbGFzdEV2ZW50IiwiX3VwZGF0ZVBvc2l0aW9uIiwibm9JbmVydGlhIiwiZmlyZURyYWdlbmQiLCJjbGlwUG9seWdvbiIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsImsiLCJfY29kZSIsIl9nZXRCaXRDb2RlIiwiX2dldEVkZ2VJbnRlcnNlY3Rpb24iLCJwb2x5Z29uQ2VudGVyIiwicDEiLCJwMiIsImYiLCJhcmVhIiwiaXNGbGF0IiwiY2VudHJvaWRMYXRMbmciLCJhcmVhQm91bmRzIiwiY2VudHJvaWQiLCJsYXRsbmdDZW50ZXIiLCJsYXRTdW0iLCJsbmdTdW0iLCJQb2x5VXRpbCIsInNpbXBsaWZ5IiwidG9sZXJhbmNlIiwic3FUb2xlcmFuY2UiLCJfcmVkdWNlUG9pbnRzIiwiX3NpbXBsaWZ5RFAiLCJwb2ludFRvU2VnbWVudERpc3RhbmNlIiwiX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50IiwiY2xvc2VzdFBvaW50T25TZWdtZW50IiwiQXJyYXlDb25zdHJ1Y3RvciIsIlVpbnQ4QXJyYXkiLCJtYXJrZXJzIiwiX3NpbXBsaWZ5RFBTdGVwIiwibmV3UG9pbnRzIiwibWF4U3FEaXN0Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwiY2xpcFNlZ21lbnQiLCJ1c2VMYXN0Q29kZSIsImNvZGVBIiwiY29kZUIiLCJjb2RlT3V0IiwibmV3Q29kZSIsImRvdCIsIl9mbGF0IiwicG9seWxpbmVDZW50ZXIiLCJoYWxmRGlzdCIsInNlZ0Rpc3QiLCJkaXN0IiwiTGluZVV0aWwiLCJMb25MYXQiLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJFUFNHMzM5NSIsIkVQU0c0MzI2IiwiU2ltcGxlIiwiTGF5ZXIiLCJyZW1vdmVGcm9tIiwiX21hcFRvQWRkIiwiYWRkSW50ZXJhY3RpdmVUYXJnZXQiLCJ0YXJnZXRFbCIsInJlbW92ZUludGVyYWN0aXZlVGFyZ2V0IiwiX2xheWVyQWRkIiwiZ2V0RXZlbnRzIiwiZXZlbnRzIiwiYmVmb3JlQWRkIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImludm9rZSIsIm1ldGhvZE5hbWUiLCJnZXRMYXllciIsImdldExheWVycyIsInpJbmRleCIsImxheWVyR3JvdXAiLCJGZWF0dXJlR3JvdXAiLCJzZXRTdHlsZSIsImJyaW5nVG9Gcm9udCIsImJyaW5nVG9CYWNrIiwiZmVhdHVyZUdyb3VwIiwiSWNvbiIsInBvcHVwQW5jaG9yIiwidG9vbHRpcEFuY2hvciIsImNyb3NzT3JpZ2luIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsImFuY2hvciIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiaWNvbiIsIkljb25EZWZhdWx0IiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsInNoYWRvd1NpemUiLCJpbWFnZVBhdGgiLCJfZGV0ZWN0SWNvblBhdGgiLCJfc3RyaXBVcmwiLCJzdHJpcCIsInJlIiwiaWR4IiwibWF0Y2giLCJxdWVyeVNlbGVjdG9yIiwic3Vic3RyaW5nIiwiTWFya2VyRHJhZyIsIm1hcmtlciIsIl9tYXJrZXIiLCJfaWNvbiIsIl9kcmFnZ2FibGUiLCJkcmFnc3RhcnQiLCJfb25EcmFnU3RhcnQiLCJwcmVkcmFnIiwiX29uUHJlRHJhZyIsImRyYWciLCJfb25EcmFnIiwiZHJhZ2VuZCIsIl9vbkRyYWdFbmQiLCJfYWRqdXN0UGFuIiwic3BlZWQiLCJhdXRvUGFuU3BlZWQiLCJhdXRvUGFuUGFkZGluZyIsImljb25Qb3MiLCJvcmlnaW4iLCJwYW5Cb3VuZHMiLCJtb3ZlbWVudCIsIl9wYW5SZXF1ZXN0IiwiX29sZExhdExuZyIsImNsb3NlUG9wdXAiLCJhdXRvUGFuIiwic2hhZG93IiwiX3NoYWRvdyIsIl9sYXRsbmciLCJvbGRMYXRMbmciLCJNYXJrZXIiLCJpbnRlcmFjdGl2ZSIsImtleWJvYXJkIiwiekluZGV4T2Zmc2V0IiwicmlzZU9uSG92ZXIiLCJyaXNlT2Zmc2V0IiwiYXV0b1Bhbk9uRm9jdXMiLCJkcmFnZ2FibGUiLCJfaW5pdEljb24iLCJ1cGRhdGUiLCJfcmVtb3ZlSWNvbiIsIl9yZW1vdmVTaGFkb3ciLCJ2aWV3cmVzZXQiLCJzZXRMYXRMbmciLCJzZXRaSW5kZXhPZmZzZXQiLCJnZXRJY29uIiwic2V0SWNvbiIsIl9wb3B1cCIsImJpbmRQb3B1cCIsImdldEVsZW1lbnQiLCJfc2V0UG9zIiwiY2xhc3NUb0FkZCIsImFkZEljb24iLCJtb3VzZW92ZXIiLCJfYnJpbmdUb0Zyb250IiwibW91c2VvdXQiLCJfcmVzZXRaSW5kZXgiLCJfcGFuT25Gb2N1cyIsIm5ld1NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiaWNvbk9wdHMiLCJfZ2V0UG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsIlBhdGgiLCJzdHJva2UiLCJjb2xvciIsIndlaWdodCIsImxpbmVDYXAiLCJsaW5lSm9pbiIsImRhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJmaWxsUnVsZSIsImdldFJlbmRlcmVyIiwiX2luaXRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBhdGgiLCJfcmVtb3ZlUGF0aCIsInJlZHJhdyIsIl91cGRhdGVQYXRoIiwiX3VwZGF0ZVN0eWxlIiwiX3VwZGF0ZUJvdW5kcyIsIl9icmluZ1RvQmFjayIsIl9wYXRoIiwiX3Byb2plY3QiLCJfY2xpY2tUb2xlcmFuY2UiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJzZXRSYWRpdXMiLCJnZXRSYWRpdXMiLCJfcG9pbnQiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9ib3VuZHMiLCJfY29udGFpbnNQb2ludCIsImNpcmNsZU1hcmtlciIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwiYm90dG9tIiwibG5nUiIsImFjb3MiLCJjaXJjbGUiLCJQb2x5bGluZSIsInNtb290aEZhY3RvciIsIm5vQ2xpcCIsIl9zZXRMYXRMbmdzIiwiZ2V0TGF0TG5ncyIsIl9sYXRsbmdzIiwic2V0TGF0TG5ncyIsImlzRW1wdHkiLCJjbG9zZXN0TGF5ZXJQb2ludCIsIm1pbkRpc3RhbmNlIiwibWluUG9pbnQiLCJjbG9zZXN0IiwiakxlbiIsIl9wYXJ0cyIsIl9kZWZhdWx0U2hhcGUiLCJhZGRMYXRMbmciLCJfY29udmVydExhdExuZ3MiLCJyZXN1bHQiLCJmbGF0IiwiX3JpbmdzIiwiX3Byb2plY3RMYXRsbmdzIiwiX3Jhd1B4Qm91bmRzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwicGFydHMiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJwYXJ0IiwicG9seWxpbmUiLCJQb2x5Z29uIiwicG9wIiwiY2xpcHBlZCIsInBvbHlnb24iLCJHZW9KU09OIiwiZ2VvanNvbiIsImFkZERhdGEiLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJnZW9tZXRyaWVzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImdlb21ldHJ5VG9MYXllciIsImFzRmVhdHVyZSIsImRlZmF1bHRPcHRpb25zIiwicmVzZXRTdHlsZSIsIm9uRWFjaEZlYXR1cmUiLCJfc2V0TGF5ZXJTdHlsZSIsInBvaW50VG9MYXllciIsIl9jb29yZHNUb0xhdExuZyIsImNvb3Jkc1RvTGF0TG5nIiwiX3BvaW50VG9MYXllciIsImNvb3Jkc1RvTGF0TG5ncyIsImdlb0xheWVyIiwicHJvcGVydGllcyIsImZlYXR1cmVMYXllciIsInBvaW50VG9MYXllckZuIiwibWFya2Vyc0luaGVyaXRPcHRpb25zIiwibGV2ZWxzRGVlcCIsImxhdExuZ1RvQ29vcmRzIiwibGF0TG5nc1RvQ29vcmRzIiwiZ2V0RmVhdHVyZSIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJnZW9KU09OIiwiZ2VvSnNvbiIsIkltYWdlT3ZlcmxheSIsImVycm9yT3ZlcmxheVVybCIsInVybCIsIl91cmwiLCJfaW1hZ2UiLCJfaW5pdEltYWdlIiwic3R5bGVPcHRzIiwic2V0VXJsIiwic2V0Qm91bmRzIiwiem9vbWFuaW0iLCJ3YXNFbGVtZW50U3VwcGxpZWQiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIlZpZGVvT3ZlcmxheSIsImF1dG9wbGF5IiwibG9vcCIsImtlZXBBc3BlY3RSYXRpbyIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJ2aWQiLCJvbmxvYWRlZGRhdGEiLCJzb3VyY2VFbGVtZW50cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic291cmNlcyIsInNvdXJjZSIsInZpZGVvT3ZlcmxheSIsInZpZGVvIiwiU1ZHT3ZlcmxheSIsInN2Z092ZXJsYXkiLCJEaXZPdmVybGF5IiwiY29udGVudCIsIl9zb3VyY2UiLCJfY29udGVudCIsIm9wZW5PbiIsImNsb3NlIiwidG9nZ2xlIiwiX3ByZXBhcmVPcGVuIiwiX3JlbW92ZVRpbWVvdXQiLCJnZXRDb250ZW50Iiwic2V0Q29udGVudCIsInZpc2liaWxpdHkiLCJfdXBkYXRlQ29udGVudCIsIl91cGRhdGVMYXlvdXQiLCJpc09wZW4iLCJub2RlIiwiX2NvbnRlbnROb2RlIiwiaGFzQ2hpbGROb2RlcyIsIl9nZXRBbmNob3IiLCJfY29udGFpbmVyQm90dG9tIiwiX2NvbnRhaW5lckxlZnQiLCJfY29udGFpbmVyV2lkdGgiLCJfaW5pdE92ZXJsYXkiLCJPdmVybGF5Q2xhc3MiLCJvbGQiLCJQb3B1cCIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwiYXV0b1BhblBhZGRpbmdUb3BMZWZ0IiwiYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCIsImtlZXBJblZpZXciLCJjbG9zZUJ1dHRvbiIsImF1dG9DbG9zZSIsImNsb3NlT25Fc2NhcGVLZXkiLCJwb3B1cCIsImNsb3NlT25DbGljayIsImNsb3NlUG9wdXBPbkNsaWNrIiwicHJlY2xpY2siLCJtb3ZlZW5kIiwid3JhcHBlciIsIl93cmFwcGVyIiwiX3RpcENvbnRhaW5lciIsIl90aXAiLCJfY2xvc2VCdXR0b24iLCJ3aGl0ZVNwYWNlIiwic2Nyb2xsZWRDbGFzcyIsIl9hdXRvcGFubmluZyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJvcGVuUG9wdXAiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiX29wZW5Qb3B1cCIsImtleXByZXNzIiwiX29uS2V5UHJlc3MiLCJtb3ZlIiwiX21vdmVQb3B1cCIsInVuYmluZFBvcHVwIiwidG9nZ2xlUG9wdXAiLCJpc1BvcHVwT3BlbiIsInNldFBvcHVwQ29udGVudCIsImdldFBvcHVwIiwiVG9vbHRpcCIsImRpcmVjdGlvbiIsInBlcm1hbmVudCIsInN0aWNreSIsInRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJzdWJYIiwic3ViWSIsInRvb2x0aXBQb2ludCIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJvcGVuVG9vbHRpcCIsImNsb3NlVG9vbHRpcCIsImJpbmRUb29sdGlwIiwiX3Rvb2x0aXAiLCJpc1Rvb2x0aXBPcGVuIiwidW5iaW5kVG9vbHRpcCIsIl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyIsIl90b29sdGlwSGFuZGxlcnNBZGRlZCIsIl9tb3ZlVG9vbHRpcCIsIl9vcGVuVG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVycyIsIm1vdXNlbW92ZSIsIl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyIiwidG9nZ2xlVG9vbHRpcCIsInNldFRvb2x0aXBDb250ZW50IiwiZ2V0VG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIiLCJtb3ZpbmciLCJfb3Blbk9uY2VGbGFnIiwiRGl2SWNvbiIsImJnUG9zIiwiRWxlbWVudCIsImJhY2tncm91bmRQb3NpdGlvbiIsImRpdkljb24iLCJEZWZhdWx0IiwiR3JpZExheWVyIiwidGlsZVNpemUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl90aWxlcyIsIl9yZW1vdmVBbGxUaWxlcyIsIl90aWxlWm9vbSIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ0aWxlWm9vbSIsIl9jbGFtcFpvb20iLCJfdXBkYXRlTGV2ZWxzIiwidmlld3ByZXJlc2V0IiwiX2ludmFsaWRhdGVBbGwiLCJjcmVhdGVUaWxlIiwiZ2V0VGlsZVNpemUiLCJjb21wYXJlIiwiY2hpbGRyZW4iLCJlZGdlWkluZGV4IiwiaXNGaW5pdGUiLCJuZXh0RnJhbWUiLCJ3aWxsUHJ1bmUiLCJ0aWxlIiwiY3VycmVudCIsImxvYWRlZCIsImZhZGUiLCJhY3RpdmUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJOdW1iZXIiLCJfb25VcGRhdGVMZXZlbCIsIl9yZW1vdmVUaWxlc0F0Wm9vbSIsIl9vblJlbW92ZUxldmVsIiwibGV2ZWwiLCJfc2V0Wm9vbVRyYW5zZm9ybSIsIl9vbkNyZWF0ZUxldmVsIiwiX2xldmVsIiwicmV0YWluIiwiX3JldGFpblBhcmVudCIsIl9yZXRhaW5DaGlsZHJlbiIsIl9yZW1vdmVUaWxlIiwieDIiLCJ5MiIsInoyIiwiY29vcmRzMiIsIl90aWxlQ29vcmRzVG9LZXkiLCJhbmltYXRpbmciLCJfc2V0VmlldyIsIm5vUHJ1bmUiLCJ0aWxlWm9vbUNoYW5nZWQiLCJfYWJvcnRMb2FkaW5nIiwiX3Jlc2V0R3JpZCIsIl9zZXRab29tVHJhbnNmb3JtcyIsInRyYW5zbGF0ZSIsIl90aWxlU2l6ZSIsIl9nbG9iYWxUaWxlUmFuZ2UiLCJfcHhCb3VuZHNUb1RpbGVSYW5nZSIsIl93cmFwWCIsIl93cmFwWSIsIl9nZXRUaWxlZFBpeGVsQm91bmRzIiwibWFwWm9vbSIsImhhbGZTaXplIiwidGlsZVJhbmdlIiwidGlsZUNlbnRlciIsInF1ZXVlIiwibm9QcnVuZVJhbmdlIiwiX2lzVmFsaWRUaWxlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiX2FkZFRpbGUiLCJ0aWxlQm91bmRzIiwiX3RpbGVDb29yZHNUb0JvdW5kcyIsIl9rZXlUb0JvdW5kcyIsIl9rZXlUb1RpbGVDb29yZHMiLCJfdGlsZUNvb3Jkc1RvTndTZSIsIm53UG9pbnQiLCJzZVBvaW50IiwiYnAiLCJfaW5pdFRpbGUiLCJ0aWxlUG9zIiwiX2dldFRpbGVQb3MiLCJfd3JhcENvb3JkcyIsIl90aWxlUmVhZHkiLCJfbm9UaWxlc1RvTG9hZCIsIm5ld0Nvb3JkcyIsImdyaWRMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJyZWZlcnJlclBvbGljeSIsIl9vblRpbGVSZW1vdmUiLCJub1JlZHJhdyIsImRvbmUiLCJfdGlsZU9uTG9hZCIsIl90aWxlT25FcnJvciIsImdldFRpbGVVcmwiLCJfZ2V0U3ViZG9tYWluIiwiX2dldFpvb21Gb3JVcmwiLCJpbnZlcnRlZFkiLCJnZXRBdHRyaWJ1dGUiLCJ0aWxlUG9pbnQiLCJjb21wbGV0ZSIsInRpbGVMYXllciIsIlRpbGVMYXllcldNUyIsImRlZmF1bHRXbXNQYXJhbXMiLCJzZXJ2aWNlIiwicmVxdWVzdCIsInN0eWxlcyIsImZvcm1hdCIsInRyYW5zcGFyZW50Iiwid21zUGFyYW1zIiwicmVhbFJldGluYSIsIl9jcnMiLCJfd21zVmVyc2lvbiIsInBhcnNlRmxvYXQiLCJwcm9qZWN0aW9uS2V5IiwiYmJveCIsInNldFBhcmFtcyIsInRpbGVMYXllcldNUyIsIldNUyIsIndtcyIsIlJlbmRlcmVyIiwiX3VwZGF0ZVBhdGhzIiwiX2Rlc3Ryb3lDb250YWluZXIiLCJfb25ab29tIiwiem9vbWVuZCIsIl9vblpvb21FbmQiLCJfb25BbmltWm9vbSIsIl91cGRhdGVUcmFuc2Zvcm0iLCJjdXJyZW50Q2VudGVyUG9pbnQiLCJfY2VudGVyIiwidG9wTGVmdE9mZnNldCIsIkNhbnZhcyIsIl9vblZpZXdQcmVSZXNldCIsIl9wb3N0cG9uZVVwZGF0ZVBhdGhzIiwiX2RyYXciLCJfb25Nb3VzZU1vdmUiLCJfb25DbGljayIsIl9oYW5kbGVNb3VzZU91dCIsIl9jdHgiLCJfcmVkcmF3UmVxdWVzdCIsIl9yZWRyYXdCb3VuZHMiLCJfcmVkcmF3IiwibSIsIl91cGRhdGVEYXNoQXJyYXkiLCJvcmRlciIsIl9vcmRlciIsIl9kcmF3TGFzdCIsIm5leHQiLCJfZHJhd0ZpcnN0IiwiX3JlcXVlc3RSZWRyYXciLCJfZXh0ZW5kUmVkcmF3Qm91bmRzIiwiZGFzaFZhbHVlIiwiX2Rhc2hBcnJheSIsIl9jbGVhciIsImNsZWFyUmVjdCIsInNhdmUiLCJyZXN0b3JlIiwiYmVnaW5QYXRoIiwiY2xpcCIsIl9kcmF3aW5nIiwiY2xvc2VQYXRoIiwiX2ZpbGxTdHJva2UiLCJhcmMiLCJnbG9iYWxBbHBoYSIsImZpbGxTdHlsZSIsInNldExpbmVEYXNoIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJjbGlja2VkTGF5ZXIiLCJfZmlyZUV2ZW50IiwiX2hhbmRsZU1vdXNlSG92ZXIiLCJfaG92ZXJlZExheWVyIiwiX21vdXNlSG92ZXJUaHJvdHRsZWQiLCJjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIiLCJ2bWxDcmVhdGUiLCJuYW1lc3BhY2VzIiwidm1sTWl4aW4iLCJjb29yZHNpemUiLCJfc3Ryb2tlIiwiX2ZpbGwiLCJzdHJva2VkIiwiZmlsbGVkIiwiZGFzaFN0eWxlIiwiZW5kY2FwIiwiam9pbnN0eWxlIiwiX3NldFBhdGgiLCJTVkciLCJfcm9vdEdyb3VwIiwiX3N2Z1NpemUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfZ2V0UGFuZVJlbmRlcmVyIiwiX2NyZWF0ZVJlbmRlcmVyIiwicHJlZmVyQ2FudmFzIiwiUmVjdGFuZ2xlIiwiX2JvdW5kc1RvTGF0TG5ncyIsInJlY3RhbmdsZSIsIkJveFpvb20iLCJfcGFuZSIsIm92ZXJsYXlQYW5lIiwiX3Jlc2V0U3RhdGVUaW1lb3V0IiwiX2Rlc3Ryb3kiLCJfb25Nb3VzZURvd24iLCJfcmVzZXRTdGF0ZSIsIl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSIsImNvbnRleHRtZW51IiwibW91c2V1cCIsIl9vbk1vdXNlVXAiLCJfb25LZXlEb3duIiwiX2JveCIsIl9maW5pc2giLCJib3hab29tQm91bmRzIiwiZG91YmxlQ2xpY2tab29tIiwiRG91YmxlQ2xpY2tab29tIiwiX29uRG91YmxlQ2xpY2siLCJpbmVydGlhIiwiaW5lcnRpYURlY2VsZXJhdGlvbiIsImluZXJ0aWFNYXhTcGVlZCIsIndvcmxkQ29weUp1bXAiLCJtYXhCb3VuZHNWaXNjb3NpdHkiLCJEcmFnIiwiX29uUHJlRHJhZ0xpbWl0IiwiX29uUHJlRHJhZ1dyYXAiLCJfcG9zaXRpb25zIiwiX3RpbWVzIiwiX29mZnNldExpbWl0IiwiX3Zpc2Nvc2l0eSIsIl9sYXN0VGltZSIsIl9sYXN0UG9zIiwiX2Fic1BvcyIsIl9wcnVuZVBvc2l0aW9ucyIsInNoaWZ0IiwicHhDZW50ZXIiLCJweFdvcmxkQ2VudGVyIiwiX2luaXRpYWxXb3JsZE9mZnNldCIsIl93b3JsZFdpZHRoIiwiX3Zpc2NvdXNMaW1pdCIsInRocmVzaG9sZCIsImxpbWl0Iiwid29ybGRXaWR0aCIsImhhbGZXaWR0aCIsIm5ld1gxIiwibmV3WDIiLCJuZXdYIiwiZWFzZSIsInNwZWVkVmVjdG9yIiwibGltaXRlZFNwZWVkIiwibGltaXRlZFNwZWVkVmVjdG9yIiwiZGVjZWxlcmF0aW9uRHVyYXRpb24iLCJrZXlib2FyZFBhbkRlbHRhIiwiS2V5Ym9hcmQiLCJrZXlDb2RlcyIsImRvd24iLCJ1cCIsIl9zZXRQYW5EZWx0YSIsIl9zZXRab29tRGVsdGEiLCJfb25Gb2N1cyIsImJsdXIiLCJfb25CbHVyIiwibW91c2Vkb3duIiwiX2FkZEhvb2tzIiwiX3JlbW92ZUhvb2tzIiwiX2ZvY3VzZWQiLCJkb2NFbCIsInNjcm9sbFRvIiwicGFuRGVsdGEiLCJrZXlzIiwiX3BhbktleXMiLCJjb2RlcyIsIl96b29tS2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwibmV3TGF0TG5nIiwic2Nyb2xsV2hlZWxab29tIiwid2hlZWxEZWJvdW5jZVRpbWUiLCJ3aGVlbFB4UGVyWm9vbUxldmVsIiwiU2Nyb2xsV2hlZWxab29tIiwiX29uV2hlZWxTY3JvbGwiLCJfZGVsdGEiLCJkZWJvdW5jZSIsIl9sYXN0TW91c2VQb3MiLCJfdGltZXIiLCJfcGVyZm9ybVpvb20iLCJkMiIsImQzIiwiZDQiLCJ0YXBIb2xkRGVsYXkiLCJ0YXBIb2xkIiwidGFwVG9sZXJhbmNlIiwiVGFwSG9sZCIsIl9ob2xkVGltZW91dCIsIl9jYW5jZWwiLCJfaXNUYXBWYWxpZCIsIl9jYW5jZWxDbGlja1ByZXZlbnQiLCJfc2ltdWxhdGVFdmVudCIsImNhbmNlbENsaWNrUHJldmVudCIsInNpbXVsYXRlZEV2ZW50IiwiTW91c2VFdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidmlldyIsImRpc3BhdGNoRXZlbnQiLCJ0b3VjaFpvb20iLCJib3VuY2VBdFpvb21MaW1pdHMiLCJUb3VjaFpvb20iLCJfb25Ub3VjaFN0YXJ0IiwiX3pvb21pbmciLCJfY2VudGVyUG9pbnQiLCJfc3RhcnRMYXRMbmciLCJfcGluY2hTdGFydExhdExuZyIsIl9zdGFydERpc3QiLCJfc3RhcnRab29tIiwiX29uVG91Y2hNb3ZlIiwiX29uVG91Y2hFbmQiLCJfYW5pbVJlcXVlc3QiLCJtb3ZlRm4iLCJQcm9qZWN0aW9uIiwibGF0TG5nIiwib2xkTCIsIm5vQ29uZmxpY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.css":
/*!*********************************************************!*\
  !*** ./node_modules/leaflet-draw/dist/leaflet.draw.css ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"75435a736dd0\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0LWRyYXcvZGlzdC9sZWFmbGV0LmRyYXcuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LmNzcz9mOGFmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzU0MzVhNzM2ZGQwXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"dd47593f6114\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3M/ZDU5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRkNDc1OTNmNjExNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon-2x.png":
/*!*************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon-2x.png ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/marker-icon-2x.93fdb12c.png\",\"height\":82,\"width\":50,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmarker-icon-2x.93fdb12c.png&w=5&q=70\",\"blurWidth\":5,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLTJ4LnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyw4TUFBOE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24tMngucG5nPzdiYzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL21hcmtlci1pY29uLTJ4LjkzZmRiMTJjLnBuZ1wiLFwiaGVpZ2h0XCI6ODIsXCJ3aWR0aFwiOjUwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm1hcmtlci1pY29uLTJ4LjkzZmRiMTJjLnBuZyZ3PTUmcT03MFwiLFwiYmx1cldpZHRoXCI6NSxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon-2x.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon.png":
/*!**********************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-icon.png ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/marker-icon.d577052a.png\",\"height\":41,\"width\":25,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmarker-icon.d577052a.png&w=5&q=70\",\"blurWidth\":5,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyx3TUFBd00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nPzkzODEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL21hcmtlci1pY29uLmQ1NzcwNTJhLnBuZ1wiLFwiaGVpZ2h0XCI6NDEsXCJ3aWR0aFwiOjI1LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm1hcmtlci1pY29uLmQ1NzcwNTJhLnBuZyZ3PTUmcT03MFwiLFwiYmx1cldpZHRoXCI6NSxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet/dist/images/marker-shadow.png":
/*!************************************************************!*\
  !*** ./node_modules/leaflet/dist/images/marker-shadow.png ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/marker-shadow.612e3b52.png\",\"height\":41,\"width\":41,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmarker-shadow.612e3b52.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1zaGFkb3cucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDRNQUE0TSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZz8yZjE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9tYXJrZXItc2hhZG93LjYxMmUzYjUyLnBuZ1wiLFwiaGVpZ2h0XCI6NDEsXCJ3aWR0aFwiOjQxLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm1hcmtlci1zaGFkb3cuNjEyZTNiNTIucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet/dist/images/marker-shadow.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/PolygonMap.tsx":
/*!***************************************!*\
  !*** ./src/components/PolygonMap.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PolygonMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/MapContainer.js\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/TileLayer.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet_draw_dist_leaflet_draw_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leaflet-draw/dist/leaflet.draw.css */ \"(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.css\");\n/* harmony import */ var _lib_geo_areaCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/geo/areaCalculator */ \"(app-pages-browser)/./src/lib/geo/areaCalculator.ts\");\n/* harmony import */ var leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ \"(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon-2x.png\");\n/* harmony import */ var leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ \"(app-pages-browser)/./node_modules/leaflet/dist/images/marker-icon.png\");\n/* harmony import */ var leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ \"(app-pages-browser)/./node_modules/leaflet/dist/images/marker-shadow.png\");\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! leaflet-draw */ \"(app-pages-browser)/./node_modules/leaflet-draw/dist/leaflet.draw.js\");\n/* harmony import */ var leaflet_draw__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(leaflet_draw__WEBPACK_IMPORTED_MODULE_9__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// Fix Leaflet's default icon path issues\n\n\n\n// Import leaflet-draw side effects\n\n// Fix icons\ndelete (leaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon).Default.prototype._getIconUrl;\nleaflet__WEBPACK_IMPORTED_MODULE_2___default().Icon.Default.mergeOptions({\n    iconUrl: leaflet_dist_images_marker_icon_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"].src,\n    iconRetinaUrl: leaflet_dist_images_marker_icon_2x_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"].src,\n    shadowUrl: leaflet_dist_images_marker_shadow_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"].src\n});\nfunction MapController(param) {\n    let { onPolygonComplete, initialPolygon } = param;\n    _s();\n    const map = (0,react_leaflet__WEBPACK_IMPORTED_MODULE_10__.useMap)();\n    const drawnItemsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new (leaflet__WEBPACK_IMPORTED_MODULE_2___default().FeatureGroup)());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const drawnItems = drawnItemsRef.current;\n        map.addLayer(drawnItems);\n        // Add initial polygon if provided\n        if (initialPolygon && initialPolygon.length > 2) {\n            const polygon = leaflet__WEBPACK_IMPORTED_MODULE_2___default().polygon(initialPolygon, {\n                color: \"#1A4731\",\n                fillColor: \"#1A4731\",\n                fillOpacity: 0.25,\n                weight: 3\n            });\n            drawnItems.addLayer(polygon);\n            map.fitBounds(polygon.getBounds());\n        }\n        // Initialize Draw Control\n        const drawControl = new (leaflet__WEBPACK_IMPORTED_MODULE_2___default().Control).Draw({\n            draw: {\n                polygon: {\n                    allowIntersection: false,\n                    showArea: true,\n                    shapeOptions: {\n                        color: \"#1A4731\",\n                        fillColor: \"#1A4731\",\n                        fillOpacity: 0.25,\n                        weight: 3\n                    }\n                },\n                rectangle: false,\n                circle: false,\n                marker: false,\n                polyline: false,\n                circlemarker: false\n            },\n            edit: {\n                featureGroup: drawnItems,\n                remove: true,\n                edit: false // Simplified for this demo\n            }\n        });\n        map.addControl(drawControl);\n        // Event Handlers\n        map.on((leaflet__WEBPACK_IMPORTED_MODULE_2___default().Draw).Event.CREATED, (e)=>{\n            const layer = e.layer;\n            drawnItems.clearLayers(); // Only allow one polygon\n            drawnItems.addLayer(layer);\n            const latlngs = layer.getLatLngs()[0];\n            // Convert to array of {lat, lng} objects if needed, Leaflet usually returns LatLng objects\n            const coords = latlngs.map((ll)=>({\n                    lat: ll.lat,\n                    lng: ll.lng\n                }));\n            // Use the proper geo calculator with Turf.js\n            const polygon = (0,_lib_geo_areaCalculator__WEBPACK_IMPORTED_MODULE_5__.leafletLayerToGeoJSON)(layer);\n            const area10r = (0,_lib_geo_areaCalculator__WEBPACK_IMPORTED_MODULE_5__.calculatePolygonArea10r)(polygon);\n            onPolygonComplete(coords, area10r, polygon);\n        });\n        map.on((leaflet__WEBPACK_IMPORTED_MODULE_2___default().Draw).Event.DELETED, ()=>{\n            onPolygonComplete(null, 0, null);\n        });\n        return ()=>{\n            map.removeControl(drawControl);\n            map.removeLayer(drawnItems);\n            // clean up event listeners\n            map.off((leaflet__WEBPACK_IMPORTED_MODULE_2___default().Draw).Event.CREATED);\n            map.off((leaflet__WEBPACK_IMPORTED_MODULE_2___default().Draw).Event.DELETED);\n        };\n    }, [\n        map,\n        onPolygonComplete,\n        initialPolygon\n    ]);\n    return null;\n}\n_s(MapController, \"EQFLR9AsIoDy5V2W9qZoahcFQ9Y=\", false, function() {\n    return [\n        react_leaflet__WEBPACK_IMPORTED_MODULE_10__.useMap\n    ];\n});\n_c = MapController;\nfunction PolygonMap(props) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_11__.MapContainer, {\n        center: [\n            35.6812,\n            139.7671\n        ],\n        zoom: 15,\n        style: {\n            height: \"100%\",\n            width: \"100%\",\n            minHeight: \"400px\",\n            borderRadius: \"0.5rem\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_12__.TileLayer, {\n                attribution: '\\xa9 <a href=\"https://www.google.com/maps\">Google</a>',\n                url: \"https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}\" // Google Hybrid\n                ,\n                maxZoom: 20\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\yusuk\\\\Documents\\\\wwx\\\\Wayfinder AgriX\\\\v3-app\\\\src\\\\components\\\\PolygonMap.tsx\",\n                lineNumber: 120,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(MapController, {\n                ...props\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\yusuk\\\\Documents\\\\wwx\\\\Wayfinder AgriX\\\\v3-app\\\\src\\\\components\\\\PolygonMap.tsx\",\n                lineNumber: 125,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\yusuk\\\\Documents\\\\wwx\\\\Wayfinder AgriX\\\\v3-app\\\\src\\\\components\\\\PolygonMap.tsx\",\n        lineNumber: 115,\n        columnNumber: 9\n    }, this);\n}\n_c1 = PolygonMap;\nvar _c, _c1;\n$RefreshReg$(_c, \"MapController\");\n$RefreshReg$(_c1, \"PolygonMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1BvbHlnb25NYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDMEI7QUFDdEQ7QUFDVTtBQUNVO0FBQzhDO0FBRzFGLHlDQUF5QztBQUN5QjtBQUNMO0FBQ0k7QUFFakUsbUNBQW1DO0FBQ2I7QUFFdEIsWUFBWTtBQUNaLE9BQU8scURBQU8sQ0FBQ1ksT0FBTyxDQUFDQyxTQUFTLENBQVNDLFdBQVc7QUFDcERULG1EQUFNLENBQUNPLE9BQU8sQ0FBQ0csWUFBWSxDQUFDO0lBQ3hCQyxTQUFTUCwyRUFBVUEsQ0FBQ1EsR0FBRztJQUN2QkMsZUFBZVYsOEVBQVlBLENBQUNTLEdBQUc7SUFDL0JFLFdBQVdULDZFQUFZQSxDQUFDTyxHQUFHO0FBQy9CO0FBT0EsU0FBU0csY0FBYyxLQUFzRDtRQUF0RCxFQUFFQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFtQixHQUF0RDs7SUFDbkIsTUFBTUMsTUFBTW5CLHNEQUFNQTtJQUNsQixNQUFNb0IsZ0JBQWdCdkIsNkNBQU1BLENBQWlCLElBQUlJLDZEQUFjO0lBRS9ETCxnREFBU0EsQ0FBQztRQUNOLE1BQU0wQixhQUFhRixjQUFjRyxPQUFPO1FBQ3hDSixJQUFJSyxRQUFRLENBQUNGO1FBRWIsa0NBQWtDO1FBQ2xDLElBQUlKLGtCQUFrQkEsZUFBZU8sTUFBTSxHQUFHLEdBQUc7WUFDN0MsTUFBTUMsVUFBVXpCLHNEQUFTLENBQUNpQixnQkFBZ0I7Z0JBQ3RDUyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxhQUFhO2dCQUNiQyxRQUFRO1lBQ1o7WUFDQVIsV0FBV0UsUUFBUSxDQUFDRTtZQUNwQlAsSUFBSVksU0FBUyxDQUFDTCxRQUFRTSxTQUFTO1FBQ25DO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU1DLGNBQWMsSUFBSWhDLHdEQUFTLENBQUNrQyxJQUFJLENBQUM7WUFDbkNDLE1BQU07Z0JBQ0ZWLFNBQVM7b0JBQ0xXLG1CQUFtQjtvQkFDbkJDLFVBQVU7b0JBQ1ZDLGNBQWM7d0JBQ1ZaLE9BQU87d0JBQ1BDLFdBQVc7d0JBQ1hDLGFBQWE7d0JBQ2JDLFFBQVE7b0JBQ1o7Z0JBQ0o7Z0JBQ0FVLFdBQVc7Z0JBQ1hDLFFBQVE7Z0JBQ1JDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLGNBQWM7WUFDbEI7WUFDQUMsTUFBTTtnQkFDRkMsY0FBY3hCO2dCQUNkeUIsUUFBUTtnQkFDUkYsTUFBTSxNQUFNLDJCQUEyQjtZQUMzQztRQUNKO1FBRUExQixJQUFJNkIsVUFBVSxDQUFDZjtRQUVmLGlCQUFpQjtRQUNqQmQsSUFBSThCLEVBQUUsQ0FBQ2hELHFEQUFNLENBQUNpRCxLQUFLLENBQUNDLE9BQU8sRUFBRSxDQUFDQztZQUMxQixNQUFNQyxRQUFRRCxFQUFFQyxLQUFLO1lBQ3JCL0IsV0FBV2dDLFdBQVcsSUFBSSx5QkFBeUI7WUFDbkRoQyxXQUFXRSxRQUFRLENBQUM2QjtZQUVwQixNQUFNRSxVQUFVRixNQUFNRyxVQUFVLEVBQUUsQ0FBQyxFQUFFO1lBQ3JDLDJGQUEyRjtZQUMzRixNQUFNQyxTQUFTRixRQUFRcEMsR0FBRyxDQUFDdUMsQ0FBQUEsS0FBTztvQkFBRUMsS0FBS0QsR0FBR0MsR0FBRztvQkFBRUMsS0FBS0YsR0FBR0UsR0FBRztnQkFBQztZQUU3RCw2Q0FBNkM7WUFDN0MsTUFBTWxDLFVBQVV4Qiw4RUFBcUJBLENBQUNtRDtZQUN0QyxNQUFNUSxVQUFVMUQsZ0ZBQXVCQSxDQUFDdUI7WUFFeENULGtCQUFrQndDLFFBQVFJLFNBQVNuQztRQUN2QztRQUVBUCxJQUFJOEIsRUFBRSxDQUFDaEQscURBQU0sQ0FBQ2lELEtBQUssQ0FBQ1ksT0FBTyxFQUFFO1lBQ3pCN0Msa0JBQWtCLE1BQU0sR0FBRztRQUMvQjtRQUVBLE9BQU87WUFDSEUsSUFBSTRDLGFBQWEsQ0FBQzlCO1lBQ2xCZCxJQUFJNkMsV0FBVyxDQUFDMUM7WUFDaEIsMkJBQTJCO1lBQzNCSCxJQUFJOEMsR0FBRyxDQUFDaEUscURBQU0sQ0FBQ2lELEtBQUssQ0FBQ0MsT0FBTztZQUM1QmhDLElBQUk4QyxHQUFHLENBQUNoRSxxREFBTSxDQUFDaUQsS0FBSyxDQUFDWSxPQUFPO1FBQ2hDO0lBQ0osR0FBRztRQUFDM0M7UUFBS0Y7UUFBbUJDO0tBQWU7SUFFM0MsT0FBTztBQUNYO0dBL0VTRjs7UUFDT2hCLGtEQUFNQTs7O0tBRGJnQjtBQWlGTSxTQUFTa0QsV0FBV0MsS0FBc0I7SUFDckQscUJBQ0ksOERBQUNyRSx3REFBWUE7UUFDVHNFLFFBQVE7WUFBQztZQUFTO1NBQVM7UUFDM0JDLE1BQU07UUFDTkMsT0FBTztZQUFFQyxRQUFRO1lBQVFDLE9BQU87WUFBUUMsV0FBVztZQUFTQyxjQUFjO1FBQVM7OzBCQUVuRiw4REFBQzNFLHFEQUFTQTtnQkFDTjRFLGFBQVk7Z0JBQ1pDLEtBQUkscURBQXFELGdCQUFnQjs7Z0JBQ3pFQyxTQUFTOzs7Ozs7MEJBRWIsOERBQUM3RDtnQkFBZSxHQUFHbUQsS0FBSzs7Ozs7Ozs7Ozs7O0FBR3BDO01BZndCRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Qb2x5Z29uTWFwLnRzeD8yZjEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgTWFwQ29udGFpbmVyLCBUaWxlTGF5ZXIsIEZlYXR1cmVHcm91cCwgdXNlTWFwIH0gZnJvbSAncmVhY3QtbGVhZmxldCc7XHJcbmltcG9ydCBMIGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgJ2xlYWZsZXQvZGlzdC9sZWFmbGV0LmNzcyc7XHJcbmltcG9ydCAnbGVhZmxldC1kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LmNzcyc7XHJcbmltcG9ydCB7IGxlYWZsZXRMYXllclRvR2VvSlNPTiwgY2FsY3VsYXRlUG9seWdvbkFyZWExMHIgfSBmcm9tICdAL2xpYi9nZW8vYXJlYUNhbGN1bGF0b3InO1xyXG5pbXBvcnQgdHlwZSB7IFBvbHlnb24gfSBmcm9tICdnZW9qc29uJztcclxuXHJcbi8vIEZpeCBMZWFmbGV0J3MgZGVmYXVsdCBpY29uIHBhdGggaXNzdWVzXHJcbmltcG9ydCBtYXJrZXJJY29uMnggZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi0yeC5wbmcnO1xyXG5pbXBvcnQgbWFya2VySWNvbiBmcm9tICdsZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyc7XHJcbmltcG9ydCBtYXJrZXJTaGFkb3cgZnJvbSAnbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZyc7XHJcblxyXG4vLyBJbXBvcnQgbGVhZmxldC1kcmF3IHNpZGUgZWZmZWN0c1xyXG5pbXBvcnQgJ2xlYWZsZXQtZHJhdyc7XHJcblxyXG4vLyBGaXggaWNvbnNcclxuZGVsZXRlIChMLkljb24uRGVmYXVsdC5wcm90b3R5cGUgYXMgYW55KS5fZ2V0SWNvblVybDtcclxuTC5JY29uLkRlZmF1bHQubWVyZ2VPcHRpb25zKHtcclxuICAgIGljb25Vcmw6IG1hcmtlckljb24uc3JjLFxyXG4gICAgaWNvblJldGluYVVybDogbWFya2VySWNvbjJ4LnNyYyxcclxuICAgIHNoYWRvd1VybDogbWFya2VyU2hhZG93LnNyYyxcclxufSk7XHJcblxyXG5pbnRlcmZhY2UgUG9seWdvbk1hcFByb3BzIHtcclxuICAgIG9uUG9seWdvbkNvbXBsZXRlOiAoY29vcmRzOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9W10gfCBudWxsLCBhcmVhMTByOiBudW1iZXIsIHBvbHlnb246IFBvbHlnb24gfCBudWxsKSA9PiB2b2lkO1xyXG4gICAgaW5pdGlhbFBvbHlnb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9W107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE1hcENvbnRyb2xsZXIoeyBvblBvbHlnb25Db21wbGV0ZSwgaW5pdGlhbFBvbHlnb24gfTogUG9seWdvbk1hcFByb3BzKSB7XHJcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcclxuICAgIGNvbnN0IGRyYXduSXRlbXNSZWYgPSB1c2VSZWY8TC5GZWF0dXJlR3JvdXA+KG5ldyBMLkZlYXR1cmVHcm91cCgpKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRyYXduSXRlbXMgPSBkcmF3bkl0ZW1zUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgbWFwLmFkZExheWVyKGRyYXduSXRlbXMpO1xyXG5cclxuICAgICAgICAvLyBBZGQgaW5pdGlhbCBwb2x5Z29uIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKGluaXRpYWxQb2x5Z29uICYmIGluaXRpYWxQb2x5Z29uLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IEwucG9seWdvbihpbml0aWFsUG9seWdvbiwge1xyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMUE0NzMxJyxcclxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMxQTQ3MzEnLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMjUsXHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRyYXduSXRlbXMuYWRkTGF5ZXIocG9seWdvbik7XHJcbiAgICAgICAgICAgIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIERyYXcgQ29udHJvbFxyXG4gICAgICAgIGNvbnN0IGRyYXdDb250cm9sID0gbmV3IEwuQ29udHJvbC5EcmF3KHtcclxuICAgICAgICAgICAgZHJhdzoge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW50ZXJzZWN0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBzaG93QXJlYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZU9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMUE0NzMxJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzFBNDczMScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjI1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVjdGFuZ2xlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNpcmNsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9seWxpbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2lyY2xlbWFya2VyOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlZGl0OiB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlR3JvdXA6IGRyYXduSXRlbXMsXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlZGl0OiBmYWxzZSAvLyBTaW1wbGlmaWVkIGZvciB0aGlzIGRlbW9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBtYXAuYWRkQ29udHJvbChkcmF3Q29udHJvbCk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXHJcbiAgICAgICAgbWFwLm9uKEwuRHJhdy5FdmVudC5DUkVBVEVELCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gZS5sYXllcjtcclxuICAgICAgICAgICAgZHJhd25JdGVtcy5jbGVhckxheWVycygpOyAvLyBPbmx5IGFsbG93IG9uZSBwb2x5Z29uXHJcbiAgICAgICAgICAgIGRyYXduSXRlbXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGF0bG5ncyA9IGxheWVyLmdldExhdExuZ3MoKVswXSBhcyB7IGxhdDogbnVtYmVyLCBsbmc6IG51bWJlciB9W107XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgb2Yge2xhdCwgbG5nfSBvYmplY3RzIGlmIG5lZWRlZCwgTGVhZmxldCB1c3VhbGx5IHJldHVybnMgTGF0TG5nIG9iamVjdHNcclxuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gbGF0bG5ncy5tYXAobGwgPT4gKHsgbGF0OiBsbC5sYXQsIGxuZzogbGwubG5nIH0pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJvcGVyIGdlbyBjYWxjdWxhdG9yIHdpdGggVHVyZi5qc1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uID0gbGVhZmxldExheWVyVG9HZW9KU09OKGxheWVyKTtcclxuICAgICAgICAgICAgY29uc3QgYXJlYTEwciA9IGNhbGN1bGF0ZVBvbHlnb25BcmVhMTByKHBvbHlnb24pO1xyXG5cclxuICAgICAgICAgICAgb25Qb2x5Z29uQ29tcGxldGUoY29vcmRzLCBhcmVhMTByLCBwb2x5Z29uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWFwLm9uKEwuRHJhdy5FdmVudC5ERUxFVEVELCAoKSA9PiB7XHJcbiAgICAgICAgICAgIG9uUG9seWdvbkNvbXBsZXRlKG51bGwsIDAsIG51bGwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBtYXAucmVtb3ZlQ29udHJvbChkcmF3Q29udHJvbCk7XHJcbiAgICAgICAgICAgIG1hcC5yZW1vdmVMYXllcihkcmF3bkl0ZW1zKTtcclxuICAgICAgICAgICAgLy8gY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIG1hcC5vZmYoTC5EcmF3LkV2ZW50LkNSRUFURUQpO1xyXG4gICAgICAgICAgICBtYXAub2ZmKEwuRHJhdy5FdmVudC5ERUxFVEVEKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW21hcCwgb25Qb2x5Z29uQ29tcGxldGUsIGluaXRpYWxQb2x5Z29uXSk7XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBvbHlnb25NYXAocHJvcHM6IFBvbHlnb25NYXBQcm9wcykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TWFwQ29udGFpbmVyXHJcbiAgICAgICAgICAgIGNlbnRlcj17WzM1LjY4MTIsIDEzOS43NjcxXX0gLy8gVG9reW8gZGVmYXVsdFxyXG4gICAgICAgICAgICB6b29tPXsxNX1cclxuICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJScsIG1pbkhlaWdodDogJzQwMHB4JywgYm9yZGVyUmFkaXVzOiAnMC41cmVtJyB9fVxyXG4gICAgICAgID5cclxuICAgICAgICAgICAgPFRpbGVMYXllclxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRpb249JyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzXCI+R29vZ2xlPC9hPidcclxuICAgICAgICAgICAgICAgIHVybD1cImh0dHBzOi8vbXQxLmdvb2dsZS5jb20vdnQvbHlycz15Jng9e3h9Jnk9e3l9Jno9e3p9XCIgLy8gR29vZ2xlIEh5YnJpZFxyXG4gICAgICAgICAgICAgICAgbWF4Wm9vbT17MjB9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDxNYXBDb250cm9sbGVyIHsuLi5wcm9wc30gLz5cclxuICAgICAgICA8L01hcENvbnRhaW5lcj5cclxuICAgICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIk1hcENvbnRhaW5lciIsIlRpbGVMYXllciIsInVzZU1hcCIsIkwiLCJsZWFmbGV0TGF5ZXJUb0dlb0pTT04iLCJjYWxjdWxhdGVQb2x5Z29uQXJlYTEwciIsIm1hcmtlckljb24yeCIsIm1hcmtlckljb24iLCJtYXJrZXJTaGFkb3ciLCJJY29uIiwiRGVmYXVsdCIsInByb3RvdHlwZSIsIl9nZXRJY29uVXJsIiwibWVyZ2VPcHRpb25zIiwiaWNvblVybCIsInNyYyIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJNYXBDb250cm9sbGVyIiwib25Qb2x5Z29uQ29tcGxldGUiLCJpbml0aWFsUG9seWdvbiIsIm1hcCIsImRyYXduSXRlbXNSZWYiLCJGZWF0dXJlR3JvdXAiLCJkcmF3bkl0ZW1zIiwiY3VycmVudCIsImFkZExheWVyIiwibGVuZ3RoIiwicG9seWdvbiIsImNvbG9yIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJ3ZWlnaHQiLCJmaXRCb3VuZHMiLCJnZXRCb3VuZHMiLCJkcmF3Q29udHJvbCIsIkNvbnRyb2wiLCJEcmF3IiwiZHJhdyIsImFsbG93SW50ZXJzZWN0aW9uIiwic2hvd0FyZWEiLCJzaGFwZU9wdGlvbnMiLCJyZWN0YW5nbGUiLCJjaXJjbGUiLCJtYXJrZXIiLCJwb2x5bGluZSIsImNpcmNsZW1hcmtlciIsImVkaXQiLCJmZWF0dXJlR3JvdXAiLCJyZW1vdmUiLCJhZGRDb250cm9sIiwib24iLCJFdmVudCIsIkNSRUFURUQiLCJlIiwibGF5ZXIiLCJjbGVhckxheWVycyIsImxhdGxuZ3MiLCJnZXRMYXRMbmdzIiwiY29vcmRzIiwibGwiLCJsYXQiLCJsbmciLCJhcmVhMTByIiwiREVMRVRFRCIsInJlbW92ZUNvbnRyb2wiLCJyZW1vdmVMYXllciIsIm9mZiIsIlBvbHlnb25NYXAiLCJwcm9wcyIsImNlbnRlciIsInpvb20iLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwibWluSGVpZ2h0IiwiYm9yZGVyUmFkaXVzIiwiYXR0cmlidXRpb24iLCJ1cmwiLCJtYXhab29tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PolygonMap.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/attribution.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/attribution.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAttribution: function() { return /* binding */ useAttribution; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\nfunction useAttribution(map, attribution) {\n    _s();\n    const attributionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(attribution);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function updateAttribution() {\n        if (attribution !== attributionRef.current && map.attributionControl != null) {\n            if (attributionRef.current != null) {\n                map.attributionControl.removeAttribution(attributionRef.current);\n            }\n            if (attribution != null) {\n                map.attributionControl.addAttribution(attribution);\n            }\n        }\n        attributionRef.current = attribution;\n    }, [\n        map,\n        attribution\n    ]);\n}\n_s(useAttribution, \"jJ4oGECrVF83DZogTBCjzQ7H6Kc=\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9hdHRyaWJ1dGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7QUFDbkMsU0FBU0UsZUFBZUMsR0FBRyxFQUFFQyxXQUFXOztJQUMzQyxNQUFNQyxpQkFBaUJKLDZDQUFNQSxDQUFDRztJQUM5QkosZ0RBQVNBLENBQUMsU0FBU007UUFDZixJQUFJRixnQkFBZ0JDLGVBQWVFLE9BQU8sSUFBSUosSUFBSUssa0JBQWtCLElBQUksTUFBTTtZQUMxRSxJQUFJSCxlQUFlRSxPQUFPLElBQUksTUFBTTtnQkFDaENKLElBQUlLLGtCQUFrQixDQUFDQyxpQkFBaUIsQ0FBQ0osZUFBZUUsT0FBTztZQUNuRTtZQUNBLElBQUlILGVBQWUsTUFBTTtnQkFDckJELElBQUlLLGtCQUFrQixDQUFDRSxjQUFjLENBQUNOO1lBQzFDO1FBQ0o7UUFDQUMsZUFBZUUsT0FBTyxHQUFHSDtJQUM3QixHQUFHO1FBQ0NEO1FBQ0FDO0tBQ0g7QUFDTDtHQWhCZ0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9hdHRyaWJ1dGlvbi5qcz9iMzRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUF0dHJpYnV0aW9uKG1hcCwgYXR0cmlidXRpb24pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGlvblJlZiA9IHVzZVJlZihhdHRyaWJ1dGlvbik7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0aW9uKCkge1xuICAgICAgICBpZiAoYXR0cmlidXRpb24gIT09IGF0dHJpYnV0aW9uUmVmLmN1cnJlbnQgJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRpb25SZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihhdHRyaWJ1dGlvblJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbihhdHRyaWJ1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRpb25SZWYuY3VycmVudCA9IGF0dHJpYnV0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgbWFwLFxuICAgICAgICBhdHRyaWJ1dGlvblxuICAgIF0pO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUF0dHJpYnV0aW9uIiwibWFwIiwiYXR0cmlidXRpb24iLCJhdHRyaWJ1dGlvblJlZiIsInVwZGF0ZUF0dHJpYnV0aW9uIiwiY3VycmVudCIsImF0dHJpYnV0aW9uQ29udHJvbCIsInJlbW92ZUF0dHJpYnV0aW9uIiwiYWRkQXR0cmlidXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/attribution.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/component.js":
/*!***********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/component.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContainerComponent: function() { return /* binding */ createContainerComponent; },\n/* harmony export */   createDivOverlayComponent: function() { return /* binding */ createDivOverlayComponent; },\n/* harmony export */   createLeafComponent: function() { return /* binding */ createLeafComponent; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n\n\n\nfunction createContainerComponent(useElement) {\n    var _s = $RefreshSig$();\n    function ContainerComponent(props, forwardedRef) {\n        _s();\n        const { instance, context } = useElement(props).current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(forwardedRef, ()=>instance);\n        return props.children == null ? null : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_context_js__WEBPACK_IMPORTED_MODULE_2__.LeafletProvider, {\n            value: context\n        }, props.children);\n    }\n    _s(ContainerComponent, \"qaNnQaLSCg+DMBsa3c21l+k/MK4=\", false, function() {\n        return [\n            useElement\n        ];\n    });\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContainerComponent);\n}\nfunction createDivOverlayComponent(useElement) {\n    var _s = $RefreshSig$();\n    function OverlayComponent(props, forwardedRef) {\n        _s();\n        const [isOpen, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const { instance } = useElement(props, setOpen).current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(forwardedRef, ()=>instance);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function updateOverlay() {\n            if (isOpen) {\n                instance.update();\n            }\n        }, [\n            instance,\n            isOpen,\n            props.children\n        ]);\n        // @ts-ignore _contentNode missing in type definition\n        const contentNode = instance._contentNode;\n        return contentNode ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, contentNode) : null;\n    }\n    _s(OverlayComponent, \"aT5/ZDm2bl4/yi+hfcZFXcwyz9Q=\", false, function() {\n        return [\n            useElement\n        ];\n    });\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(OverlayComponent);\n}\nfunction createLeafComponent(useElement) {\n    var _s = $RefreshSig$();\n    function LeafComponent(props, forwardedRef) {\n        _s();\n        const { instance } = useElement(props).current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(forwardedRef, ()=>instance);\n        return null;\n    }\n    _s(LeafComponent, \"qaNnQaLSCg+DMBsa3c21l+k/MK4=\", false, function() {\n        return [\n            useElement\n        ];\n    });\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(LeafComponent);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9GO0FBQzNDO0FBQ007QUFDeEMsU0FBU08seUJBQXlCQyxVQUFVOztJQUMvQyxTQUFTQyxtQkFBbUJDLEtBQUssRUFBRUMsWUFBWTs7UUFDM0MsTUFBTSxFQUFFQyxRQUFRLEVBQUdDLE9BQU8sRUFBRyxHQUFHTCxXQUFXRSxPQUFPSSxPQUFPO1FBQ3pEWCwwREFBbUJBLENBQUNRLGNBQWMsSUFBSUM7UUFDdEMsT0FBT0YsTUFBTUssUUFBUSxJQUFJLE9BQU8sT0FBTyxXQUFXLEdBQUdmLGdEQUFtQixDQUFDTSx3REFBZUEsRUFBRTtZQUN0RlcsT0FBT0o7UUFDWCxHQUFHSCxNQUFNSyxRQUFRO0lBQ3JCO09BTlNOOztZQUMyQkQ7OztJQU1wQyxPQUFPLFdBQVcsR0FBR1AsaURBQVVBLENBQUNRO0FBQ3BDO0FBQ08sU0FBU1MsMEJBQTBCVixVQUFVOztJQUNoRCxTQUFTVyxpQkFBaUJULEtBQUssRUFBRUMsWUFBWTs7UUFDekMsTUFBTSxDQUFDUyxRQUFRQyxRQUFRLEdBQUdqQiwrQ0FBUUEsQ0FBQztRQUNuQyxNQUFNLEVBQUVRLFFBQVEsRUFBRyxHQUFHSixXQUFXRSxPQUFPVyxTQUFTUCxPQUFPO1FBQ3hEWCwwREFBbUJBLENBQUNRLGNBQWMsSUFBSUM7UUFDdENWLGdEQUFTQSxDQUFDLFNBQVNvQjtZQUNmLElBQUlGLFFBQVE7Z0JBQ1JSLFNBQVNXLE1BQU07WUFDbkI7UUFDSixHQUFHO1lBQ0NYO1lBQ0FRO1lBQ0FWLE1BQU1LLFFBQVE7U0FDakI7UUFDRCxxREFBcUQ7UUFDckQsTUFBTVMsY0FBY1osU0FBU2EsWUFBWTtRQUN6QyxPQUFPRCxjQUFjLFdBQVcsR0FBR25CLHVEQUFZQSxDQUFDSyxNQUFNSyxRQUFRLEVBQUVTLGVBQWU7SUFDbkY7T0FoQlNMOztZQUVpQlg7OztJQWUxQixPQUFPLFdBQVcsR0FBR1AsaURBQVVBLENBQUNrQjtBQUNwQztBQUNPLFNBQVNPLG9CQUFvQmxCLFVBQVU7O0lBQzFDLFNBQVNtQixjQUFjakIsS0FBSyxFQUFFQyxZQUFZOztRQUN0QyxNQUFNLEVBQUVDLFFBQVEsRUFBRyxHQUFHSixXQUFXRSxPQUFPSSxPQUFPO1FBQy9DWCwwREFBbUJBLENBQUNRLGNBQWMsSUFBSUM7UUFDdEMsT0FBTztJQUNYO09BSlNlOztZQUNpQm5COzs7SUFJMUIsT0FBTyxXQUFXLEdBQUdQLGlEQUFVQSxDQUFDMEI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1sZWFmbGV0L2NvcmUvbGliL2NvbXBvbmVudC5qcz9lYzRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IExlYWZsZXRQcm92aWRlciB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyQ29tcG9uZW50KHVzZUVsZW1lbnQpIHtcbiAgICBmdW5jdGlvbiBDb250YWluZXJDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlICwgY29udGV4dCAgfSA9IHVzZUVsZW1lbnQocHJvcHMpLmN1cnJlbnQ7XG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKT0+aW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCA/IG51bGwgOiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGVhZmxldFByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgICAgICB9LCBwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIGZvcndhcmRSZWYoQ29udGFpbmVyQ29tcG9uZW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaXZPdmVybGF5Q29tcG9uZW50KHVzZUVsZW1lbnQpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5Q29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgY29uc3QgW2lzT3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHsgaW5zdGFuY2UgIH0gPSB1c2VFbGVtZW50KHByb3BzLCBzZXRPcGVuKS5jdXJyZW50O1xuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCk9Pmluc3RhbmNlKTtcbiAgICAgICAgdXNlRWZmZWN0KGZ1bmN0aW9uIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgaXNPcGVuLFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgXSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgX2NvbnRlbnROb2RlIG1pc3NpbmcgaW4gdHlwZSBkZWZpbml0aW9uXG4gICAgICAgIGNvbnN0IGNvbnRlbnROb2RlID0gaW5zdGFuY2UuX2NvbnRlbnROb2RlO1xuICAgICAgICByZXR1cm4gY29udGVudE5vZGUgPyAvKiNfX1BVUkVfXyovIGNyZWF0ZVBvcnRhbChwcm9wcy5jaGlsZHJlbiwgY29udGVudE5vZGUpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gZm9yd2FyZFJlZihPdmVybGF5Q29tcG9uZW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWFmQ29tcG9uZW50KHVzZUVsZW1lbnQpIHtcbiAgICBmdW5jdGlvbiBMZWFmQ29tcG9uZW50KHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZSAgfSA9IHVzZUVsZW1lbnQocHJvcHMpLmN1cnJlbnQ7XG4gICAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKT0+aW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gZm9yd2FyZFJlZihMZWFmQ29tcG9uZW50KTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlU3RhdGUiLCJjcmVhdGVQb3J0YWwiLCJMZWFmbGV0UHJvdmlkZXIiLCJjcmVhdGVDb250YWluZXJDb21wb25lbnQiLCJ1c2VFbGVtZW50IiwiQ29udGFpbmVyQ29tcG9uZW50IiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJpbnN0YW5jZSIsImNvbnRleHQiLCJjdXJyZW50IiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwidmFsdWUiLCJjcmVhdGVEaXZPdmVybGF5Q29tcG9uZW50IiwiT3ZlcmxheUNvbXBvbmVudCIsImlzT3BlbiIsInNldE9wZW4iLCJ1cGRhdGVPdmVybGF5IiwidXBkYXRlIiwiY29udGVudE5vZGUiLCJfY29udGVudE5vZGUiLCJjcmVhdGVMZWFmQ29tcG9uZW50IiwiTGVhZkNvbXBvbmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/context.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT_VERSION: function() { return /* binding */ CONTEXT_VERSION; },\n/* harmony export */   LeafletContext: function() { return /* binding */ LeafletContext; },\n/* harmony export */   LeafletProvider: function() { return /* binding */ LeafletProvider; },\n/* harmony export */   createLeafletContext: function() { return /* binding */ createLeafletContext; },\n/* harmony export */   extendContext: function() { return /* binding */ extendContext; },\n/* harmony export */   useLeafletContext: function() { return /* binding */ useLeafletContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\nconst CONTEXT_VERSION = 1;\nfunction createLeafletContext(map) {\n    return Object.freeze({\n        __version: CONTEXT_VERSION,\n        map\n    });\n}\nfunction extendContext(source, extra) {\n    return Object.freeze({\n        ...source,\n        ...extra\n    });\n}\nconst LeafletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst LeafletProvider = LeafletContext.Provider;\nfunction useLeafletContext() {\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LeafletContext);\n    if (context == null) {\n        throw new Error(\"No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>\");\n    }\n    return context;\n}\n_s(useLeafletContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtEO0FBQzNDLE1BQU1FLGtCQUFrQixFQUFFO0FBQzFCLFNBQVNDLHFCQUFxQkMsR0FBRztJQUNwQyxPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFDakJDLFdBQVdMO1FBQ1hFO0lBQ0o7QUFDSjtBQUNPLFNBQVNJLGNBQWNDLE1BQU0sRUFBRUMsS0FBSztJQUN2QyxPQUFPTCxPQUFPQyxNQUFNLENBQUM7UUFDakIsR0FBR0csTUFBTTtRQUNULEdBQUdDLEtBQUs7SUFDWjtBQUNKO0FBQ08sTUFBTUMsK0JBQWlCWCxvREFBYUEsQ0FBQyxNQUFNO0FBQzNDLE1BQU1ZLGtCQUFrQkQsZUFBZUUsUUFBUSxDQUFDO0FBQ2hELFNBQVNDOztJQUNaLE1BQU1DLFVBQVVkLGlEQUFVQSxDQUFDVTtJQUMzQixJQUFJSSxXQUFXLE1BQU07UUFDakIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0Q7QUFDWDtHQU5nQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1sZWFmbGV0L2NvcmUvbGliL2NvbnRleHQuanM/ZThiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENPTlRFWFRfVkVSU0lPTiA9IDE7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGVhZmxldENvbnRleHQobWFwKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3ZlcnNpb246IENPTlRFWFRfVkVSU0lPTixcbiAgICAgICAgbWFwXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29udGV4dChzb3VyY2UsIGV4dHJhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5zb3VyY2UsXG4gICAgICAgIC4uLmV4dHJhXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgTGVhZmxldENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0IGNvbnN0IExlYWZsZXRQcm92aWRlciA9IExlYWZsZXRDb250ZXh0LlByb3ZpZGVyO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxlYWZsZXRDb250ZXh0KCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExlYWZsZXRDb250ZXh0KTtcbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGV4dCBwcm92aWRlZDogdXNlTGVhZmxldENvbnRleHQoKSBjYW4gb25seSBiZSB1c2VkIGluIGEgZGVzY2VuZGFudCBvZiA8TWFwQ29udGFpbmVyPicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsIkNPTlRFWFRfVkVSU0lPTiIsImNyZWF0ZUxlYWZsZXRDb250ZXh0IiwibWFwIiwiT2JqZWN0IiwiZnJlZXplIiwiX192ZXJzaW9uIiwiZXh0ZW5kQ29udGV4dCIsInNvdXJjZSIsImV4dHJhIiwiTGVhZmxldENvbnRleHQiLCJMZWFmbGV0UHJvdmlkZXIiLCJQcm92aWRlciIsInVzZUxlYWZsZXRDb250ZXh0IiwiY29udGV4dCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/control.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/control.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createControlHook: function() { return /* binding */ createControlHook; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n\n\nfunction createControlHook(useElement) {\n    var _s = $RefreshSig$();\n    return _s(function useLeafletControl(props) {\n        _s();\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext)();\n        const elementRef = useElement(props, context);\n        const { instance } = elementRef.current;\n        const positionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.position);\n        const { position } = props;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addControl() {\n            instance.addTo(context.map);\n            return function removeControl() {\n                instance.remove();\n            };\n        }, [\n            context.map,\n            instance\n        ]);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function updateControl() {\n            if (position != null && position !== positionRef.current) {\n                instance.setPosition(position);\n                positionRef.current = position;\n            }\n        }, [\n            instance,\n            position\n        ]);\n        return elementRef;\n    }, \"calSbgvJKD3ko9j5q8J/fsIm9kg=\", false, function() {\n        return [\n            _context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext,\n            useElement\n        ];\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9jb250cm9sLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQztBQUNPO0FBQzFDLFNBQVNHLGtCQUFrQkMsVUFBVTs7SUFDeEMsVUFBTyxTQUFTQyxrQkFBa0JDLEtBQUs7O1FBQ25DLE1BQU1DLFVBQVVMLDhEQUFpQkE7UUFDakMsTUFBTU0sYUFBYUosV0FBV0UsT0FBT0M7UUFDckMsTUFBTSxFQUFFRSxRQUFRLEVBQUcsR0FBR0QsV0FBV0UsT0FBTztRQUN4QyxNQUFNQyxjQUFjViw2Q0FBTUEsQ0FBQ0ssTUFBTU0sUUFBUTtRQUN6QyxNQUFNLEVBQUVBLFFBQVEsRUFBRyxHQUFHTjtRQUN0Qk4sZ0RBQVNBLENBQUMsU0FBU2E7WUFDZkosU0FBU0ssS0FBSyxDQUFDUCxRQUFRUSxHQUFHO1lBQzFCLE9BQU8sU0FBU0M7Z0JBQ1pQLFNBQVNRLE1BQU07WUFDbkI7UUFDSixHQUFHO1lBQ0NWLFFBQVFRLEdBQUc7WUFDWE47U0FDSDtRQUNEVCxnREFBU0EsQ0FBQyxTQUFTa0I7WUFDZixJQUFJTixZQUFZLFFBQVFBLGFBQWFELFlBQVlELE9BQU8sRUFBRTtnQkFDdERELFNBQVNVLFdBQVcsQ0FBQ1A7Z0JBQ3JCRCxZQUFZRCxPQUFPLEdBQUdFO1lBQzFCO1FBQ0osR0FBRztZQUNDSDtZQUNBRztTQUNIO1FBQ0QsT0FBT0o7SUFDWDs7WUF4Qm9CTiwwREFBaUJBO1lBQ2RFOzs7QUF3QjNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9jb250cm9sLmpzP2E5ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMZWFmbGV0Q29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udHJvbEhvb2sodXNlRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VMZWFmbGV0Q29udHJvbChwcm9wcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlTGVhZmxldENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IHVzZUVsZW1lbnQocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlICB9ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBwb3NpdGlvblJlZiA9IHVzZVJlZihwcm9wcy5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gIH0gPSBwcm9wcztcbiAgICAgICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZENvbnRyb2woKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5hZGRUbyhjb250ZXh0Lm1hcCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlQ29udHJvbCgpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIGNvbnRleHQubWFwLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgXSk7XG4gICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiB1cGRhdGVDb250cm9sKCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9IG51bGwgJiYgcG9zaXRpb24gIT09IHBvc2l0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25SZWYuY3VycmVudCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudFJlZjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUxlYWZsZXRDb250ZXh0IiwiY3JlYXRlQ29udHJvbEhvb2siLCJ1c2VFbGVtZW50IiwidXNlTGVhZmxldENvbnRyb2wiLCJwcm9wcyIsImNvbnRleHQiLCJlbGVtZW50UmVmIiwiaW5zdGFuY2UiLCJjdXJyZW50IiwicG9zaXRpb25SZWYiLCJwb3NpdGlvbiIsImFkZENvbnRyb2wiLCJhZGRUbyIsIm1hcCIsInJlbW92ZUNvbnRyb2wiLCJyZW1vdmUiLCJ1cGRhdGVDb250cm9sIiwic2V0UG9zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/control.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/div-overlay.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/div-overlay.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDivOverlayHook: function() { return /* binding */ createDivOverlayHook; }\n/* harmony export */ });\n/* harmony import */ var _attribution_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribution.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/attribution.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/events.js\");\n/* harmony import */ var _pane_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pane.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js\");\n\n\n\n\nfunction createDivOverlayHook(useElement, useLifecycle) {\n    var _s = $RefreshSig$();\n    return _s(function useDivOverlay(props, setOpen) {\n        _s();\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_0__.useLeafletContext)();\n        const elementRef = useElement((0,_pane_js__WEBPACK_IMPORTED_MODULE_1__.withPane)(props, context), context);\n        (0,_attribution_js__WEBPACK_IMPORTED_MODULE_2__.useAttribution)(context.map, props.attribution);\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.useEventHandlers)(elementRef.current, props.eventHandlers);\n        useLifecycle(elementRef.current, context, props, setOpen);\n        return elementRef;\n    }, \"bQUEIxYy60e9ghYbrMJYw/hge/Q=\", false, function() {\n        return [\n            _context_js__WEBPACK_IMPORTED_MODULE_0__.useLeafletContext,\n            useElement,\n            _attribution_js__WEBPACK_IMPORTED_MODULE_2__.useAttribution,\n            _events_js__WEBPACK_IMPORTED_MODULE_3__.useEventHandlers,\n            useLifecycle\n        ];\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9kaXYtb3ZlcmxheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRDtBQUNEO0FBQ0Y7QUFDVjtBQUM5QixTQUFTSSxxQkFBcUJDLFVBQVUsRUFBRUMsWUFBWTs7SUFDekQsVUFBTyxTQUFTQyxjQUFjQyxLQUFLLEVBQUVDLE9BQU87O1FBQ3hDLE1BQU1DLFVBQVVULDhEQUFpQkE7UUFDakMsTUFBTVUsYUFBYU4sV0FBV0Ysa0RBQVFBLENBQUNLLE9BQU9FLFVBQVVBO1FBQ3hEViwrREFBY0EsQ0FBQ1UsUUFBUUUsR0FBRyxFQUFFSixNQUFNSyxXQUFXO1FBQzdDWCw0REFBZ0JBLENBQUNTLFdBQVdHLE9BQU8sRUFBRU4sTUFBTU8sYUFBYTtRQUN4RFQsYUFBYUssV0FBV0csT0FBTyxFQUFFSixTQUFTRixPQUFPQztRQUNqRCxPQUFPRTtJQUNYOztZQU5vQlYsMERBQWlCQTtZQUNkSTtZQUNuQkwsMkRBQWNBO1lBQ2RFLHdEQUFnQkE7WUFDaEJJOzs7QUFHUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWxlYWZsZXQvY29yZS9saWIvZGl2LW92ZXJsYXkuanM/ODYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VBdHRyaWJ1dGlvbiB9IGZyb20gJy4vYXR0cmlidXRpb24uanMnO1xuaW1wb3J0IHsgdXNlTGVhZmxldENvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgdXNlRXZlbnRIYW5kbGVycyB9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7IHdpdGhQYW5lIH0gZnJvbSAnLi9wYW5lLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaXZPdmVybGF5SG9vayh1c2VFbGVtZW50LCB1c2VMaWZlY3ljbGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlRGl2T3ZlcmxheShwcm9wcywgc2V0T3Blbikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlTGVhZmxldENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IHVzZUVsZW1lbnQod2l0aFBhbmUocHJvcHMsIGNvbnRleHQpLCBjb250ZXh0KTtcbiAgICAgICAgdXNlQXR0cmlidXRpb24oY29udGV4dC5tYXAsIHByb3BzLmF0dHJpYnV0aW9uKTtcbiAgICAgICAgdXNlRXZlbnRIYW5kbGVycyhlbGVtZW50UmVmLmN1cnJlbnQsIHByb3BzLmV2ZW50SGFuZGxlcnMpO1xuICAgICAgICB1c2VMaWZlY3ljbGUoZWxlbWVudFJlZi5jdXJyZW50LCBjb250ZXh0LCBwcm9wcywgc2V0T3Blbik7XG4gICAgICAgIHJldHVybiBlbGVtZW50UmVmO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlQXR0cmlidXRpb24iLCJ1c2VMZWFmbGV0Q29udGV4dCIsInVzZUV2ZW50SGFuZGxlcnMiLCJ3aXRoUGFuZSIsImNyZWF0ZURpdk92ZXJsYXlIb29rIiwidXNlRWxlbWVudCIsInVzZUxpZmVjeWNsZSIsInVzZURpdk92ZXJsYXkiLCJwcm9wcyIsInNldE9wZW4iLCJjb250ZXh0IiwiZWxlbWVudFJlZiIsIm1hcCIsImF0dHJpYnV0aW9uIiwiY3VycmVudCIsImV2ZW50SGFuZGxlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/div-overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/element.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/element.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createElementHook: function() { return /* binding */ createElementHook; },\n/* harmony export */   createElementObject: function() { return /* binding */ createElementObject; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction createElementObject(instance, context, container) {\n    return Object.freeze({\n        instance,\n        context,\n        container\n    });\n}\nfunction createElementHook(createElement, updateElement) {\n    var _s = $RefreshSig$();\n    if (updateElement == null) {\n        var _s1 = $RefreshSig$();\n        return _s1(function useImmutableLeafletElement(props, context) {\n            _s1();\n            const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            if (!elementRef.current) elementRef.current = createElement(props, context);\n            return elementRef;\n        }, \"repxH4TU7XKbaREqsQL8GD4F8M4=\");\n    }\n    return _s(function useMutableLeafletElement(props, context) {\n        _s();\n        const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n        if (!elementRef.current) elementRef.current = createElement(props, context);\n        const propsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props);\n        const { instance } = elementRef.current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function updateElementProps() {\n            if (propsRef.current !== props) {\n                updateElement(instance, props, propsRef.current);\n                propsRef.current = props;\n            }\n        }, [\n            instance,\n            props,\n            context\n        ]);\n        return elementRef;\n    }, \"vwOAn98d0kvzauxXOKn3UUji09k=\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9lbGVtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQztBQUNuQyxTQUFTRSxvQkFBb0JDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxTQUFTO0lBQzVELE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUNqQko7UUFDQUM7UUFDQUM7SUFDSjtBQUNKO0FBQ08sU0FBU0csa0JBQWtCQyxhQUFhLEVBQUVDLGFBQWE7O0lBQzFELElBQUlBLGlCQUFpQixNQUFNOztRQUN2QixXQUFPLFNBQVNDLDJCQUEyQkMsS0FBSyxFQUFFUixPQUFPOztZQUNyRCxNQUFNUyxhQUFhWiw2Q0FBTUE7WUFDekIsSUFBSSxDQUFDWSxXQUFXQyxPQUFPLEVBQUVELFdBQVdDLE9BQU8sR0FBR0wsY0FBY0csT0FBT1I7WUFDbkUsT0FBT1M7UUFDWDtJQUNKO0lBQ0EsVUFBTyxTQUFTRSx5QkFBeUJILEtBQUssRUFBRVIsT0FBTzs7UUFDbkQsTUFBTVMsYUFBYVosNkNBQU1BO1FBQ3pCLElBQUksQ0FBQ1ksV0FBV0MsT0FBTyxFQUFFRCxXQUFXQyxPQUFPLEdBQUdMLGNBQWNHLE9BQU9SO1FBQ25FLE1BQU1ZLFdBQVdmLDZDQUFNQSxDQUFDVztRQUN4QixNQUFNLEVBQUVULFFBQVEsRUFBRyxHQUFHVSxXQUFXQyxPQUFPO1FBQ3hDZCxnREFBU0EsQ0FBQyxTQUFTaUI7WUFDZixJQUFJRCxTQUFTRixPQUFPLEtBQUtGLE9BQU87Z0JBQzVCRixjQUFjUCxVQUFVUyxPQUFPSSxTQUFTRixPQUFPO2dCQUMvQ0UsU0FBU0YsT0FBTyxHQUFHRjtZQUN2QjtRQUNKLEdBQUc7WUFDQ1Q7WUFDQVM7WUFDQVI7U0FDSDtRQUNELE9BQU9TO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWxlYWZsZXQvY29yZS9saWIvZWxlbWVudC5qcz81YmYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRPYmplY3QoaW5zdGFuY2UsIGNvbnRleHQsIGNvbnRhaW5lcikge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRhaW5lclxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRIb29rKGNyZWF0ZUVsZW1lbnQsIHVwZGF0ZUVsZW1lbnQpIHtcbiAgICBpZiAodXBkYXRlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1c2VJbW11dGFibGVMZWFmbGV0RWxlbWVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZigpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50UmVmLmN1cnJlbnQpIGVsZW1lbnRSZWYuY3VycmVudCA9IGNyZWF0ZUVsZW1lbnQocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRSZWY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1c2VNdXRhYmxlTGVhZmxldEVsZW1lbnQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZigpO1xuICAgICAgICBpZiAoIWVsZW1lbnRSZWYuY3VycmVudCkgZWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlRWxlbWVudChwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByb3BzUmVmID0gdXNlUmVmKHByb3BzKTtcbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZSAgfSA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgdXNlRWZmZWN0KGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRQcm9wcygpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1JlZi5jdXJyZW50ICE9PSBwcm9wcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoaW5zdGFuY2UsIHByb3BzLCBwcm9wc1JlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBwcm9wc1JlZi5jdXJyZW50ID0gcHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudFJlZjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnRPYmplY3QiLCJpbnN0YW5jZSIsImNvbnRleHQiLCJjb250YWluZXIiLCJPYmplY3QiLCJmcmVlemUiLCJjcmVhdGVFbGVtZW50SG9vayIsImNyZWF0ZUVsZW1lbnQiLCJ1cGRhdGVFbGVtZW50IiwidXNlSW1tdXRhYmxlTGVhZmxldEVsZW1lbnQiLCJwcm9wcyIsImVsZW1lbnRSZWYiLCJjdXJyZW50IiwidXNlTXV0YWJsZUxlYWZsZXRFbGVtZW50IiwicHJvcHNSZWYiLCJ1cGRhdGVFbGVtZW50UHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/element.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/events.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/events.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEventHandlers: function() { return /* binding */ useEventHandlers; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\nfunction useEventHandlers(element, eventHandlers) {\n    _s();\n    const eventHandlersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addEventHandlers() {\n        if (eventHandlers != null) {\n            element.instance.on(eventHandlers);\n        }\n        eventHandlersRef.current = eventHandlers;\n        return function removeEventHandlers() {\n            if (eventHandlersRef.current != null) {\n                element.instance.off(eventHandlersRef.current);\n            }\n            eventHandlersRef.current = null;\n        };\n    }, [\n        element,\n        eventHandlers\n    ]);\n}\n_s(useEventHandlers, \"EJJvZNgCLjvrQT1sEIzK5VCnBeQ=\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ25DLFNBQVNFLGlCQUFpQkMsT0FBTyxFQUFFQyxhQUFhOztJQUNuRCxNQUFNQyxtQkFBbUJKLDZDQUFNQTtJQUMvQkQsZ0RBQVNBLENBQUMsU0FBU007UUFDZixJQUFJRixpQkFBaUIsTUFBTTtZQUN2QkQsUUFBUUksUUFBUSxDQUFDQyxFQUFFLENBQUNKO1FBQ3hCO1FBQ0FDLGlCQUFpQkksT0FBTyxHQUFHTDtRQUMzQixPQUFPLFNBQVNNO1lBQ1osSUFBSUwsaUJBQWlCSSxPQUFPLElBQUksTUFBTTtnQkFDbENOLFFBQVFJLFFBQVEsQ0FBQ0ksR0FBRyxDQUFDTixpQkFBaUJJLE9BQU87WUFDakQ7WUFDQUosaUJBQWlCSSxPQUFPLEdBQUc7UUFDL0I7SUFDSixHQUFHO1FBQ0NOO1FBQ0FDO0tBQ0g7QUFDTDtHQWpCZ0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9ldmVudHMuanM/NjVmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50SGFuZGxlcnMpIHtcbiAgICBjb25zdCBldmVudEhhbmRsZXJzUmVmID0gdXNlUmVmKCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmIChldmVudEhhbmRsZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zdGFuY2Uub24oZXZlbnRIYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVyc1JlZi5jdXJyZW50ID0gZXZlbnRIYW5kbGVycztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyc1JlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmluc3RhbmNlLm9mZihldmVudEhhbmRsZXJzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnRIYW5kbGVyc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGV2ZW50SGFuZGxlcnNcbiAgICBdKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VFdmVudEhhbmRsZXJzIiwiZWxlbWVudCIsImV2ZW50SGFuZGxlcnMiLCJldmVudEhhbmRsZXJzUmVmIiwiYWRkRXZlbnRIYW5kbGVycyIsImluc3RhbmNlIiwib24iLCJjdXJyZW50IiwicmVtb3ZlRXZlbnRIYW5kbGVycyIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/generic.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/generic.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createControlComponent: function() { return /* binding */ createControlComponent; },\n/* harmony export */   createLayerComponent: function() { return /* binding */ createLayerComponent; },\n/* harmony export */   createOverlayComponent: function() { return /* binding */ createOverlayComponent; },\n/* harmony export */   createPathComponent: function() { return /* binding */ createPathComponent; },\n/* harmony export */   createTileLayerComponent: function() { return /* binding */ createTileLayerComponent; }\n/* harmony export */ });\n/* harmony import */ var _component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/component.js\");\n/* harmony import */ var _control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/control.js\");\n/* harmony import */ var _element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/element.js\");\n/* harmony import */ var _layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layer.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/layer.js\");\n/* harmony import */ var _div_overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./div-overlay.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/div-overlay.js\");\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/path.js\");\n\n\n\n\n\n\nfunction createControlComponent(createInstance) {\n    function createElement(props, context) {\n        return (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementObject)(createInstance(props), context);\n    }\n    const useElement = (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementHook)(createElement);\n    const useControl = (0,_control_js__WEBPACK_IMPORTED_MODULE_1__.createControlHook)(useElement);\n    return (0,_component_js__WEBPACK_IMPORTED_MODULE_2__.createLeafComponent)(useControl);\n}\nfunction createLayerComponent(createElement, updateElement) {\n    const useElement = (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementHook)(createElement, updateElement);\n    const useLayer = (0,_layer_js__WEBPACK_IMPORTED_MODULE_3__.createLayerHook)(useElement);\n    return (0,_component_js__WEBPACK_IMPORTED_MODULE_2__.createContainerComponent)(useLayer);\n}\nfunction createOverlayComponent(createElement, useLifecycle) {\n    const useElement = (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementHook)(createElement);\n    const useOverlay = (0,_div_overlay_js__WEBPACK_IMPORTED_MODULE_4__.createDivOverlayHook)(useElement, useLifecycle);\n    return (0,_component_js__WEBPACK_IMPORTED_MODULE_2__.createDivOverlayComponent)(useOverlay);\n}\nfunction createPathComponent(createElement, updateElement) {\n    const useElement = (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementHook)(createElement, updateElement);\n    const usePath = (0,_path_js__WEBPACK_IMPORTED_MODULE_5__.createPathHook)(useElement);\n    return (0,_component_js__WEBPACK_IMPORTED_MODULE_2__.createContainerComponent)(usePath);\n}\nfunction createTileLayerComponent(createElement, updateElement) {\n    const useElement = (0,_element_js__WEBPACK_IMPORTED_MODULE_0__.createElementHook)(createElement, updateElement);\n    const useLayer = (0,_layer_js__WEBPACK_IMPORTED_MODULE_3__.createLayerHook)(useElement);\n    return (0,_component_js__WEBPACK_IMPORTED_MODULE_2__.createLeafComponent)(useLayer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9nZW5lcmljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBHO0FBQ3pEO0FBQ3FCO0FBQ3pCO0FBQ1c7QUFDYjtBQUNwQyxTQUFTUyx1QkFBdUJDLGNBQWM7SUFDakQsU0FBU0MsY0FBY0MsS0FBSyxFQUFFQyxPQUFPO1FBQ2pDLE9BQU9SLGdFQUFtQkEsQ0FBQ0ssZUFBZUUsUUFBUUM7SUFDdEQ7SUFDQSxNQUFNQyxhQUFhViw4REFBaUJBLENBQUNPO0lBQ3JDLE1BQU1JLGFBQWFaLDhEQUFpQkEsQ0FBQ1c7SUFDckMsT0FBT1osa0VBQW1CQSxDQUFDYTtBQUMvQjtBQUNPLFNBQVNDLHFCQUFxQkwsYUFBYSxFQUFFTSxhQUFhO0lBQzdELE1BQU1ILGFBQWFWLDhEQUFpQkEsQ0FBQ08sZUFBZU07SUFDcEQsTUFBTUMsV0FBV1osMERBQWVBLENBQUNRO0lBQ2pDLE9BQU9kLHVFQUF3QkEsQ0FBQ2tCO0FBQ3BDO0FBQ08sU0FBU0MsdUJBQXVCUixhQUFhLEVBQUVTLFlBQVk7SUFDOUQsTUFBTU4sYUFBYVYsOERBQWlCQSxDQUFDTztJQUNyQyxNQUFNVSxhQUFhZCxxRUFBb0JBLENBQUNPLFlBQVlNO0lBQ3BELE9BQU9uQix3RUFBeUJBLENBQUNvQjtBQUNyQztBQUNPLFNBQVNDLG9CQUFvQlgsYUFBYSxFQUFFTSxhQUFhO0lBQzVELE1BQU1ILGFBQWFWLDhEQUFpQkEsQ0FBQ08sZUFBZU07SUFDcEQsTUFBTU0sVUFBVWYsd0RBQWNBLENBQUNNO0lBQy9CLE9BQU9kLHVFQUF3QkEsQ0FBQ3VCO0FBQ3BDO0FBQ08sU0FBU0MseUJBQXlCYixhQUFhLEVBQUVNLGFBQWE7SUFDakUsTUFBTUgsYUFBYVYsOERBQWlCQSxDQUFDTyxlQUFlTTtJQUNwRCxNQUFNQyxXQUFXWiwwREFBZUEsQ0FBQ1E7SUFDakMsT0FBT1osa0VBQW1CQSxDQUFDZ0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1sZWFmbGV0L2NvcmUvbGliL2dlbmVyaWMuanM/MDA3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250YWluZXJDb21wb25lbnQsIGNyZWF0ZURpdk92ZXJsYXlDb21wb25lbnQsIGNyZWF0ZUxlYWZDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDb250cm9sSG9vayB9IGZyb20gJy4vY29udHJvbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50SG9vaywgY3JlYXRlRWxlbWVudE9iamVjdCB9IGZyb20gJy4vZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMYXllckhvb2sgfSBmcm9tICcuL2xheWVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZURpdk92ZXJsYXlIb29rIH0gZnJvbSAnLi9kaXYtb3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoSG9vayB9IGZyb20gJy4vcGF0aC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udHJvbENvbXBvbmVudChjcmVhdGVJbnN0YW5jZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnRPYmplY3QoY3JlYXRlSW5zdGFuY2UocHJvcHMpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgdXNlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRIb29rKGNyZWF0ZUVsZW1lbnQpO1xuICAgIGNvbnN0IHVzZUNvbnRyb2wgPSBjcmVhdGVDb250cm9sSG9vayh1c2VFbGVtZW50KTtcbiAgICByZXR1cm4gY3JlYXRlTGVhZkNvbXBvbmVudCh1c2VDb250cm9sKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMYXllckNvbXBvbmVudChjcmVhdGVFbGVtZW50LCB1cGRhdGVFbGVtZW50KSB7XG4gICAgY29uc3QgdXNlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRIb29rKGNyZWF0ZUVsZW1lbnQsIHVwZGF0ZUVsZW1lbnQpO1xuICAgIGNvbnN0IHVzZUxheWVyID0gY3JlYXRlTGF5ZXJIb29rKHVzZUVsZW1lbnQpO1xuICAgIHJldHVybiBjcmVhdGVDb250YWluZXJDb21wb25lbnQodXNlTGF5ZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlDb21wb25lbnQoY3JlYXRlRWxlbWVudCwgdXNlTGlmZWN5Y2xlKSB7XG4gICAgY29uc3QgdXNlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRIb29rKGNyZWF0ZUVsZW1lbnQpO1xuICAgIGNvbnN0IHVzZU92ZXJsYXkgPSBjcmVhdGVEaXZPdmVybGF5SG9vayh1c2VFbGVtZW50LCB1c2VMaWZlY3ljbGUpO1xuICAgIHJldHVybiBjcmVhdGVEaXZPdmVybGF5Q29tcG9uZW50KHVzZU92ZXJsYXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBhdGhDb21wb25lbnQoY3JlYXRlRWxlbWVudCwgdXBkYXRlRWxlbWVudCkge1xuICAgIGNvbnN0IHVzZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50SG9vayhjcmVhdGVFbGVtZW50LCB1cGRhdGVFbGVtZW50KTtcbiAgICBjb25zdCB1c2VQYXRoID0gY3JlYXRlUGF0aEhvb2sodXNlRWxlbWVudCk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRhaW5lckNvbXBvbmVudCh1c2VQYXRoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaWxlTGF5ZXJDb21wb25lbnQoY3JlYXRlRWxlbWVudCwgdXBkYXRlRWxlbWVudCkge1xuICAgIGNvbnN0IHVzZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50SG9vayhjcmVhdGVFbGVtZW50LCB1cGRhdGVFbGVtZW50KTtcbiAgICBjb25zdCB1c2VMYXllciA9IGNyZWF0ZUxheWVySG9vayh1c2VFbGVtZW50KTtcbiAgICByZXR1cm4gY3JlYXRlTGVhZkNvbXBvbmVudCh1c2VMYXllcik7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGFpbmVyQ29tcG9uZW50IiwiY3JlYXRlRGl2T3ZlcmxheUNvbXBvbmVudCIsImNyZWF0ZUxlYWZDb21wb25lbnQiLCJjcmVhdGVDb250cm9sSG9vayIsImNyZWF0ZUVsZW1lbnRIb29rIiwiY3JlYXRlRWxlbWVudE9iamVjdCIsImNyZWF0ZUxheWVySG9vayIsImNyZWF0ZURpdk92ZXJsYXlIb29rIiwiY3JlYXRlUGF0aEhvb2siLCJjcmVhdGVDb250cm9sQ29tcG9uZW50IiwiY3JlYXRlSW5zdGFuY2UiLCJjcmVhdGVFbGVtZW50IiwicHJvcHMiLCJjb250ZXh0IiwidXNlRWxlbWVudCIsInVzZUNvbnRyb2wiLCJjcmVhdGVMYXllckNvbXBvbmVudCIsInVwZGF0ZUVsZW1lbnQiLCJ1c2VMYXllciIsImNyZWF0ZU92ZXJsYXlDb21wb25lbnQiLCJ1c2VMaWZlY3ljbGUiLCJ1c2VPdmVybGF5IiwiY3JlYXRlUGF0aENvbXBvbmVudCIsInVzZVBhdGgiLCJjcmVhdGVUaWxlTGF5ZXJDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/generic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/grid-layer.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/grid-layer.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateGridLayer: function() { return /* binding */ updateGridLayer; }\n/* harmony export */ });\nfunction updateGridLayer(layer, props, prevProps) {\n    const { opacity, zIndex } = props;\n    if (opacity != null && opacity !== prevProps.opacity) {\n        layer.setOpacity(opacity);\n    }\n    if (zIndex != null && zIndex !== prevProps.zIndex) {\n        layer.setZIndex(zIndex);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9ncmlkLWxheWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSxnQkFBZ0JDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxTQUFTO0lBQ25ELE1BQU0sRUFBRUMsT0FBTyxFQUFHQyxNQUFNLEVBQUcsR0FBR0g7SUFDOUIsSUFBSUUsV0FBVyxRQUFRQSxZQUFZRCxVQUFVQyxPQUFPLEVBQUU7UUFDbERILE1BQU1LLFVBQVUsQ0FBQ0Y7SUFDckI7SUFDQSxJQUFJQyxVQUFVLFFBQVFBLFdBQVdGLFVBQVVFLE1BQU0sRUFBRTtRQUMvQ0osTUFBTU0sU0FBUyxDQUFDRjtJQUNwQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9ncmlkLWxheWVyLmpzPzZkNjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUdyaWRMYXllcihsYXllciwgcHJvcHMsIHByZXZQcm9wcykge1xuICAgIGNvbnN0IHsgb3BhY2l0eSAsIHpJbmRleCAgfSA9IHByb3BzO1xuICAgIGlmIChvcGFjaXR5ICE9IG51bGwgJiYgb3BhY2l0eSAhPT0gcHJldlByb3BzLm9wYWNpdHkpIHtcbiAgICAgICAgbGF5ZXIuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICB9XG4gICAgaWYgKHpJbmRleCAhPSBudWxsICYmIHpJbmRleCAhPT0gcHJldlByb3BzLnpJbmRleCkge1xuICAgICAgICBsYXllci5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsidXBkYXRlR3JpZExheWVyIiwibGF5ZXIiLCJwcm9wcyIsInByZXZQcm9wcyIsIm9wYWNpdHkiLCJ6SW5kZXgiLCJzZXRPcGFjaXR5Iiwic2V0WkluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/grid-layer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/layer.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/layer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLayerHook: function() { return /* binding */ createLayerHook; },\n/* harmony export */   useLayerLifecycle: function() { return /* binding */ useLayerLifecycle; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _attribution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribution.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/attribution.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/events.js\");\n/* harmony import */ var _pane_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pane.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction useLayerLifecycle(element, context) {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addLayer() {\n        var _context_layerContainer;\n        const container = (_context_layerContainer = context.layerContainer) !== null && _context_layerContainer !== void 0 ? _context_layerContainer : context.map;\n        container.addLayer(element.instance);\n        return function removeLayer() {\n            var _context_layerContainer;\n            (_context_layerContainer = context.layerContainer) === null || _context_layerContainer === void 0 ? void 0 : _context_layerContainer.removeLayer(element.instance);\n            context.map.removeLayer(element.instance);\n        };\n    }, [\n        context,\n        element\n    ]);\n}\n_s(useLayerLifecycle, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction createLayerHook(useElement) {\n    var _s = $RefreshSig$();\n    return _s(function useLayer(props) {\n        _s();\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext)();\n        const elementRef = useElement((0,_pane_js__WEBPACK_IMPORTED_MODULE_2__.withPane)(props, context), context);\n        (0,_attribution_js__WEBPACK_IMPORTED_MODULE_3__.useAttribution)(context.map, props.attribution);\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.useEventHandlers)(elementRef.current, props.eventHandlers);\n        useLayerLifecycle(elementRef.current, context);\n        return elementRef;\n    }, \"eSiEUF7uoN1dnD/lTgoU302ET4A=\", false, function() {\n        return [\n            _context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext,\n            useElement,\n            _attribution_js__WEBPACK_IMPORTED_MODULE_3__.useAttribution,\n            _events_js__WEBPACK_IMPORTED_MODULE_4__.useEventHandlers,\n            useLayerLifecycle\n        ];\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9sYXllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNnQjtBQUNEO0FBQ0Y7QUFDVjtBQUM5QixTQUFTSyxrQkFBa0JDLE9BQU8sRUFBRUMsT0FBTzs7SUFDOUNQLGdEQUFTQSxDQUFDLFNBQVNRO1lBQ0dEO1FBQWxCLE1BQU1FLFlBQVlGLENBQUFBLDBCQUFBQSxRQUFRRyxjQUFjLGNBQXRCSCxxQ0FBQUEsMEJBQTBCQSxRQUFRSSxHQUFHO1FBQ3ZERixVQUFVRCxRQUFRLENBQUNGLFFBQVFNLFFBQVE7UUFDbkMsT0FBTyxTQUFTQztnQkFDWk47YUFBQUEsMEJBQUFBLFFBQVFHLGNBQWMsY0FBdEJILDhDQUFBQSx3QkFBd0JNLFdBQVcsQ0FBQ1AsUUFBUU0sUUFBUTtZQUNwREwsUUFBUUksR0FBRyxDQUFDRSxXQUFXLENBQUNQLFFBQVFNLFFBQVE7UUFDNUM7SUFDSixHQUFHO1FBQ0NMO1FBQ0FEO0tBQ0g7QUFDTDtHQVpnQkQ7QUFhVCxTQUFTUyxnQkFBZ0JDLFVBQVU7O0lBQ3RDLFVBQU8sU0FBU0MsU0FBU0MsS0FBSzs7UUFDMUIsTUFBTVYsVUFBVUwsOERBQWlCQTtRQUNqQyxNQUFNZ0IsYUFBYUgsV0FBV1gsa0RBQVFBLENBQUNhLE9BQU9WLFVBQVVBO1FBQ3hETiwrREFBY0EsQ0FBQ00sUUFBUUksR0FBRyxFQUFFTSxNQUFNRSxXQUFXO1FBQzdDaEIsNERBQWdCQSxDQUFDZSxXQUFXRSxPQUFPLEVBQUVILE1BQU1JLGFBQWE7UUFDeERoQixrQkFBa0JhLFdBQVdFLE9BQU8sRUFBRWI7UUFDdEMsT0FBT1c7SUFDWDs7WUFOb0JoQiwwREFBaUJBO1lBQ2RhO1lBQ25CZCwyREFBY0E7WUFDZEUsd0RBQWdCQTtZQUNoQkU7OztBQUdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9sYXllci5qcz8yMzhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUF0dHJpYnV0aW9uIH0gZnJvbSAnLi9hdHRyaWJ1dGlvbi5qcyc7XG5pbXBvcnQgeyB1c2VMZWFmbGV0Q29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyB1c2VFdmVudEhhbmRsZXJzIH0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHsgd2l0aFBhbmUgfSBmcm9tICcuL3BhbmUuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheWVyTGlmZWN5Y2xlKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gYWRkTGF5ZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRleHQubGF5ZXJDb250YWluZXIgPz8gY29udGV4dC5tYXA7XG4gICAgICAgIGNvbnRhaW5lci5hZGRMYXllcihlbGVtZW50Lmluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxheWVyKCkge1xuICAgICAgICAgICAgY29udGV4dC5sYXllckNvbnRhaW5lcj8ucmVtb3ZlTGF5ZXIoZWxlbWVudC5pbnN0YW5jZSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1hcC5yZW1vdmVMYXllcihlbGVtZW50Lmluc3RhbmNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGVsZW1lbnRcbiAgICBdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMYXllckhvb2sodXNlRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VMYXllcihwcm9wcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdXNlTGVhZmxldENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IHVzZUVsZW1lbnQod2l0aFBhbmUocHJvcHMsIGNvbnRleHQpLCBjb250ZXh0KTtcbiAgICAgICAgdXNlQXR0cmlidXRpb24oY29udGV4dC5tYXAsIHByb3BzLmF0dHJpYnV0aW9uKTtcbiAgICAgICAgdXNlRXZlbnRIYW5kbGVycyhlbGVtZW50UmVmLmN1cnJlbnQsIHByb3BzLmV2ZW50SGFuZGxlcnMpO1xuICAgICAgICB1c2VMYXllckxpZmVjeWNsZShlbGVtZW50UmVmLmN1cnJlbnQsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudFJlZjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZUF0dHJpYnV0aW9uIiwidXNlTGVhZmxldENvbnRleHQiLCJ1c2VFdmVudEhhbmRsZXJzIiwid2l0aFBhbmUiLCJ1c2VMYXllckxpZmVjeWNsZSIsImVsZW1lbnQiLCJjb250ZXh0IiwiYWRkTGF5ZXIiLCJjb250YWluZXIiLCJsYXllckNvbnRhaW5lciIsIm1hcCIsImluc3RhbmNlIiwicmVtb3ZlTGF5ZXIiLCJjcmVhdGVMYXllckhvb2siLCJ1c2VFbGVtZW50IiwidXNlTGF5ZXIiLCJwcm9wcyIsImVsZW1lbnRSZWYiLCJhdHRyaWJ1dGlvbiIsImN1cnJlbnQiLCJldmVudEhhbmRsZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/layer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/pane.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withPane: function() { return /* binding */ withPane; }\n/* harmony export */ });\nfunction withPane(props, context) {\n    var _props_pane;\n    const pane = (_props_pane = props.pane) !== null && _props_pane !== void 0 ? _props_pane : context.pane;\n    return pane ? {\n        ...props,\n        pane\n    } : props;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9wYW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSxTQUFTQyxLQUFLLEVBQUVDLE9BQU87UUFDdEJEO0lBQWIsTUFBTUUsT0FBT0YsQ0FBQUEsY0FBQUEsTUFBTUUsSUFBSSxjQUFWRix5QkFBQUEsY0FBY0MsUUFBUUMsSUFBSTtJQUN2QyxPQUFPQSxPQUFPO1FBQ1YsR0FBR0YsS0FBSztRQUNSRTtJQUNKLElBQUlGO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1sZWFmbGV0L2NvcmUvbGliL3BhbmUuanM/Y2E2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gd2l0aFBhbmUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYW5lID0gcHJvcHMucGFuZSA/PyBjb250ZXh0LnBhbmU7XG4gICAgcmV0dXJuIHBhbmUgPyB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBwYW5lXG4gICAgfSA6IHByb3BzO1xufVxuIl0sIm5hbWVzIjpbIndpdGhQYW5lIiwicHJvcHMiLCJjb250ZXh0IiwicGFuZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-leaflet/core/lib/path.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-leaflet/core/lib/path.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPathHook: function() { return /* binding */ createPathHook; },\n/* harmony export */   usePathOptions: function() { return /* binding */ usePathOptions; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/events.js\");\n/* harmony import */ var _layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layer.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/layer.js\");\n/* harmony import */ var _pane_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pane.js */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction usePathOptions(element, props) {\n    _s();\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function updatePathOptions() {\n        if (props.pathOptions !== optionsRef.current) {\n            var _props_pathOptions;\n            const options = (_props_pathOptions = props.pathOptions) !== null && _props_pathOptions !== void 0 ? _props_pathOptions : {};\n            element.instance.setStyle(options);\n            optionsRef.current = options;\n        }\n    }, [\n        element,\n        props\n    ]);\n}\n_s(usePathOptions, \"KPDgAyAUyS6eETy8HiKSeTjQP1Q=\");\nfunction createPathHook(useElement) {\n    var _s = $RefreshSig$();\n    return _s(function usePath(props) {\n        _s();\n        const context = (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext)();\n        const elementRef = useElement((0,_pane_js__WEBPACK_IMPORTED_MODULE_2__.withPane)(props, context), context);\n        (0,_events_js__WEBPACK_IMPORTED_MODULE_3__.useEventHandlers)(elementRef.current, props.eventHandlers);\n        (0,_layer_js__WEBPACK_IMPORTED_MODULE_4__.useLayerLifecycle)(elementRef.current, context);\n        usePathOptions(elementRef.current, props);\n        return elementRef;\n    }, \"dCjKCq/0m0zNGRuAY+tcZK4oTuQ=\", false, function() {\n        return [\n            _context_js__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext,\n            useElement,\n            _events_js__WEBPACK_IMPORTED_MODULE_3__.useEventHandlers,\n            _layer_js__WEBPACK_IMPORTED_MODULE_4__.useLayerLifecycle,\n            usePathOptions\n        ];\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9wYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ087QUFDRjtBQUNBO0FBQ1Y7QUFDOUIsU0FBU00sZUFBZUMsT0FBTyxFQUFFQyxLQUFLOztJQUN6QyxNQUFNQyxhQUFhUiw2Q0FBTUE7SUFDekJELGdEQUFTQSxDQUFDLFNBQVNVO1FBQ2YsSUFBSUYsTUFBTUcsV0FBVyxLQUFLRixXQUFXRyxPQUFPLEVBQUU7Z0JBQzFCSjtZQUFoQixNQUFNSyxVQUFVTCxDQUFBQSxxQkFBQUEsTUFBTUcsV0FBVyxjQUFqQkgsZ0NBQUFBLHFCQUFxQixDQUFDO1lBQ3RDRCxRQUFRTyxRQUFRLENBQUNDLFFBQVEsQ0FBQ0Y7WUFDMUJKLFdBQVdHLE9BQU8sR0FBR0M7UUFDekI7SUFDSixHQUFHO1FBQ0NOO1FBQ0FDO0tBQ0g7QUFDTDtHQVpnQkY7QUFhVCxTQUFTVSxlQUFlQyxVQUFVOztJQUNyQyxVQUFPLFNBQVNDLFFBQVFWLEtBQUs7O1FBQ3pCLE1BQU1XLFVBQVVqQiw4REFBaUJBO1FBQ2pDLE1BQU1rQixhQUFhSCxXQUFXWixrREFBUUEsQ0FBQ0csT0FBT1csVUFBVUE7UUFDeERoQiw0REFBZ0JBLENBQUNpQixXQUFXUixPQUFPLEVBQUVKLE1BQU1hLGFBQWE7UUFDeERqQiw0REFBaUJBLENBQUNnQixXQUFXUixPQUFPLEVBQUVPO1FBQ3RDYixlQUFlYyxXQUFXUixPQUFPLEVBQUVKO1FBQ25DLE9BQU9ZO0lBQ1g7O1lBTm9CbEIsMERBQWlCQTtZQUNkZTtZQUNuQmQsd0RBQWdCQTtZQUNoQkMsd0RBQWlCQTtZQUNqQkU7OztBQUdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtbGVhZmxldC9jb3JlL2xpYi9wYXRoLmpzPzkyZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMZWFmbGV0Q29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyB1c2VFdmVudEhhbmRsZXJzIH0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHsgdXNlTGF5ZXJMaWZlY3ljbGUgfSBmcm9tICcuL2xheWVyLmpzJztcbmltcG9ydCB7IHdpdGhQYW5lIH0gZnJvbSAnLi9wYW5lLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXRoT3B0aW9ucyhlbGVtZW50LCBwcm9wcykge1xuICAgIGNvbnN0IG9wdGlvbnNSZWYgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gdXBkYXRlUGF0aE9wdGlvbnMoKSB7XG4gICAgICAgIGlmIChwcm9wcy5wYXRoT3B0aW9ucyAhPT0gb3B0aW9uc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcHJvcHMucGF0aE9wdGlvbnMgPz8ge307XG4gICAgICAgICAgICBlbGVtZW50Lmluc3RhbmNlLnNldFN0eWxlKG9wdGlvbnMpO1xuICAgICAgICAgICAgb3B0aW9uc1JlZi5jdXJyZW50ID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgcHJvcHNcbiAgICBdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoSG9vayh1c2VFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVBhdGgocHJvcHMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHVzZUxlYWZsZXRDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VFbGVtZW50KHdpdGhQYW5lKHByb3BzLCBjb250ZXh0KSwgY29udGV4dCk7XG4gICAgICAgIHVzZUV2ZW50SGFuZGxlcnMoZWxlbWVudFJlZi5jdXJyZW50LCBwcm9wcy5ldmVudEhhbmRsZXJzKTtcbiAgICAgICAgdXNlTGF5ZXJMaWZlY3ljbGUoZWxlbWVudFJlZi5jdXJyZW50LCBjb250ZXh0KTtcbiAgICAgICAgdXNlUGF0aE9wdGlvbnMoZWxlbWVudFJlZi5jdXJyZW50LCBwcm9wcyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50UmVmO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlTGVhZmxldENvbnRleHQiLCJ1c2VFdmVudEhhbmRsZXJzIiwidXNlTGF5ZXJMaWZlY3ljbGUiLCJ3aXRoUGFuZSIsInVzZVBhdGhPcHRpb25zIiwiZWxlbWVudCIsInByb3BzIiwib3B0aW9uc1JlZiIsInVwZGF0ZVBhdGhPcHRpb25zIiwicGF0aE9wdGlvbnMiLCJjdXJyZW50Iiwib3B0aW9ucyIsImluc3RhbmNlIiwic2V0U3R5bGUiLCJjcmVhdGVQYXRoSG9vayIsInVzZUVsZW1lbnQiLCJ1c2VQYXRoIiwiY29udGV4dCIsImVsZW1lbnRSZWYiLCJldmVudEhhbmRsZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-leaflet/core/lib/path.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-leaflet/lib/MapContainer.js":
/*!********************************************************!*\
  !*** ./node_modules/react-leaflet/lib/MapContainer.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapContainer: function() { return /* binding */ MapContainer; }\n/* harmony export */ });\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\n\n\nfunction MapContainerComponent(param, forwardedRef) {\n    let { bounds, boundsOptions, center, children, className, id, placeholder, style, whenReady, zoom, ...options } = param;\n    _s();\n    const [props] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        className,\n        id,\n        style\n    });\n    const [context, setContext] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(forwardedRef, ()=>{\n        var _context_map;\n        return (_context_map = context === null || context === void 0 ? void 0 : context.map) !== null && _context_map !== void 0 ? _context_map : null;\n    }, [\n        context\n    ]);\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((node)=>{\n        if (node !== null && context === null) {\n            const map = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Map(node, options);\n            if (center != null && zoom != null) {\n                map.setView(center, zoom);\n            } else if (bounds != null) {\n                map.fitBounds(bounds, boundsOptions);\n            }\n            if (whenReady != null) {\n                map.whenReady(whenReady);\n            }\n            setContext((0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_2__.createLeafletContext)(map));\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            context === null || context === void 0 ? void 0 : context.map.remove();\n        };\n    }, [\n        context\n    ]);\n    const contents = context ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_react_leaflet_core__WEBPACK_IMPORTED_MODULE_2__.LeafletProvider, {\n        value: context\n    }, children) : placeholder !== null && placeholder !== void 0 ? placeholder : null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", _extends({}, props, {\n        ref: mapRef\n    }), contents);\n}\n_s(MapContainerComponent, \"xYdLTLSwDo0lURiF6ZRtrXXqRPc=\");\n_c = MapContainerComponent;\nconst MapContainer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(MapContainerComponent);\n_c1 = MapContainer;\nvar _c, _c1;\n$RefreshReg$(_c, \"MapContainerComponent\");\n$RefreshReg$(_c1, \"MapContainer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXBDb250YWluZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFTQTtJQUNMQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBU0MsTUFBTTtRQUN2QyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFJO1lBQ3JDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFJLElBQUlJLE9BQU9ELE9BQU87Z0JBQ2xCLElBQUlOLE9BQU9RLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ25ETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUM3QjtZQUNKO1FBQ0o7UUFDQSxPQUFPTDtJQUNYO0lBQ0EsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDaEM7QUFDNEU7QUFDaEM7QUFDcUQ7QUFDakcsU0FBU2tCLHNCQUFzQixLQUFxSCxFQUFFQyxZQUFZO1FBQW5JLEVBQUVDLE1BQU0sRUFBR0MsYUFBYSxFQUFHQyxNQUFNLEVBQUdDLFFBQVEsRUFBR0MsU0FBUyxFQUFHQyxFQUFFLEVBQUdDLFdBQVcsRUFBR0MsS0FBSyxFQUFHQyxTQUFTLEVBQUdDLElBQUksRUFBRyxHQUFHQyxTQUFTLEdBQXJIOztJQUMzQixNQUFNLENBQUNDLE1BQU0sR0FBR2QsK0NBQVFBLENBQUM7UUFDckJPO1FBQ0FDO1FBQ0FFO0lBQ0o7SUFDQSxNQUFNLENBQUNLLFNBQVNDLFdBQVcsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQ3ZDRCwwREFBbUJBLENBQUNHLGNBQWM7WUFBSWE7ZUFBQUEsQ0FBQUEsZUFBQUEsb0JBQUFBLDhCQUFBQSxRQUFTRSxHQUFHLGNBQVpGLDBCQUFBQSxlQUFnQjtJQUFHLEdBQUc7UUFDeERBO0tBQ0g7SUFDRCxNQUFNRyxTQUFTckIsa0RBQVdBLENBQUMsQ0FBQ3NCO1FBQ3hCLElBQUlBLFNBQVMsUUFBUUosWUFBWSxNQUFNO1lBQ25DLE1BQU1FLE1BQU0sSUFBSXZCLHdDQUFVQSxDQUFDeUIsTUFBTU47WUFDakMsSUFBSVIsVUFBVSxRQUFRTyxRQUFRLE1BQU07Z0JBQ2hDSyxJQUFJRyxPQUFPLENBQUNmLFFBQVFPO1lBQ3hCLE9BQU8sSUFBSVQsVUFBVSxNQUFNO2dCQUN2QmMsSUFBSUksU0FBUyxDQUFDbEIsUUFBUUM7WUFDMUI7WUFDQSxJQUFJTyxhQUFhLE1BQU07Z0JBQ25CTSxJQUFJTixTQUFTLENBQUNBO1lBQ2xCO1lBQ0FLLFdBQVd4Qix5RUFBb0JBLENBQUN5QjtRQUNwQztJQUNKLHVEQUF1RDtJQUN2RCxHQUFHLEVBQUU7SUFDTG5CLGdEQUFTQSxDQUFDO1FBQ04sT0FBTztZQUNIaUIsb0JBQUFBLDhCQUFBQSxRQUFTRSxHQUFHLENBQUNLLE1BQU07UUFDdkI7SUFDSixHQUFHO1FBQ0NQO0tBQ0g7SUFDRCxNQUFNUSxXQUFXUixVQUFVLFdBQVcsR0FBR3BCLGdEQUFtQixDQUFDSixnRUFBZUEsRUFBRTtRQUMxRWtDLE9BQU9WO0lBQ1gsR0FBR1QsWUFBWUcsd0JBQUFBLHlCQUFBQSxjQUFlO0lBQzlCLE9BQU8sV0FBVyxHQUFHZCxnREFBbUIsQ0FBQyxPQUFPakIsU0FBUyxDQUFDLEdBQUdvQyxPQUFPO1FBQ2hFWSxLQUFLUjtJQUNULElBQUlLO0FBQ1I7R0F0Q1N0QjtLQUFBQTtBQXVDRixNQUFNMEIsZUFBZSxXQUFXLEdBQUcvQixpREFBVUEsQ0FBQ0ssdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9NYXBDb250YWluZXIuanM/MTE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW1wb3J0IHsgTGVhZmxldFByb3ZpZGVyLCBjcmVhdGVMZWFmbGV0Q29udGV4dCB9IGZyb20gJ0ByZWFjdC1sZWFmbGV0L2NvcmUnO1xuaW1wb3J0IHsgTWFwIGFzIExlYWZsZXRNYXAgfSBmcm9tICdsZWFmbGV0JztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmZ1bmN0aW9uIE1hcENvbnRhaW5lckNvbXBvbmVudCh7IGJvdW5kcyAsIGJvdW5kc09wdGlvbnMgLCBjZW50ZXIgLCBjaGlsZHJlbiAsIGNsYXNzTmFtZSAsIGlkICwgcGxhY2Vob2xkZXIgLCBzdHlsZSAsIHdoZW5SZWFkeSAsIHpvb20gLCAuLi5vcHRpb25zIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IFtwcm9wc10gPSB1c2VTdGF0ZSh7XG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIHN0eWxlXG4gICAgfSk7XG4gICAgY29uc3QgW2NvbnRleHQsIHNldENvbnRleHRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpPT5jb250ZXh0Py5tYXAgPz8gbnVsbCwgW1xuICAgICAgICBjb250ZXh0XG4gICAgXSk7XG4gICAgY29uc3QgbWFwUmVmID0gdXNlQ2FsbGJhY2soKG5vZGUpPT57XG4gICAgICAgIGlmIChub2RlICE9PSBudWxsICYmIGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBMZWFmbGV0TWFwKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGNlbnRlciAhPSBudWxsICYmIHpvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXRWaWV3KGNlbnRlciwgem9vbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhib3VuZHMsIGJvdW5kc09wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdoZW5SZWFkeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWFwLndoZW5SZWFkeSh3aGVuUmVhZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q29udGV4dChjcmVhdGVMZWFmbGV0Q29udGV4dChtYXApKTtcbiAgICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgY29udGV4dD8ubWFwLnJlbW92ZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udGV4dFxuICAgIF0pO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gY29udGV4dCA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChMZWFmbGV0UHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBjaGlsZHJlbikgOiBwbGFjZWhvbGRlciA/PyBudWxsO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIHJlZjogbWFwUmVmXG4gICAgfSksIGNvbnRlbnRzKTtcbn1cbmV4cG9ydCBjb25zdCBNYXBDb250YWluZXIgPSAvKiNfX1BVUkVfXyovIGZvcndhcmRSZWYoTWFwQ29udGFpbmVyQ29tcG9uZW50KTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIkxlYWZsZXRQcm92aWRlciIsImNyZWF0ZUxlYWZsZXRDb250ZXh0IiwiTWFwIiwiTGVhZmxldE1hcCIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZVN0YXRlIiwiTWFwQ29udGFpbmVyQ29tcG9uZW50IiwiZm9yd2FyZGVkUmVmIiwiYm91bmRzIiwiYm91bmRzT3B0aW9ucyIsImNlbnRlciIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiaWQiLCJwbGFjZWhvbGRlciIsInN0eWxlIiwid2hlblJlYWR5Iiwiem9vbSIsIm9wdGlvbnMiLCJwcm9wcyIsImNvbnRleHQiLCJzZXRDb250ZXh0IiwibWFwIiwibWFwUmVmIiwibm9kZSIsInNldFZpZXciLCJmaXRCb3VuZHMiLCJyZW1vdmUiLCJjb250ZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJ2YWx1ZSIsInJlZiIsIk1hcENvbnRhaW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-leaflet/lib/MapContainer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-leaflet/lib/TileLayer.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-leaflet/lib/TileLayer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TileLayer: function() { return /* binding */ TileLayer; }\n/* harmony export */ });\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/generic.js\");\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/pane.js\");\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/element.js\");\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/grid-layer.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n\n\nconst TileLayer = (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__.createTileLayerComponent)(_c = function createTileLayer(param, context) {\n    let { url, ...options } = param;\n    const layer = new leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer(url, (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_2__.withPane)(options, context));\n    return (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_3__.createElementObject)(layer, context);\n}, function updateTileLayer(layer, props, prevProps) {\n    (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_4__.updateGridLayer)(layer, props, prevProps);\n    const { url } = props;\n    if (url != null && url !== prevProps.url) {\n        layer.setUrl(url);\n    }\n});\n_c1 = TileLayer;\nvar _c, _c1;\n$RefreshReg$(_c, \"TileLayer$createTileLayerComponent\");\n$RefreshReg$(_c1, \"TileLayer\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9UaWxlTGF5ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStHO0FBQ3ZEO0FBQ2pELE1BQU1JLFlBQVlILDZFQUF3QkEsTUFBQyxTQUFTSyxnQkFBZ0IsS0FBb0IsRUFBRUMsT0FBTztRQUE3QixFQUFFQyxHQUFHLEVBQUcsR0FBR0MsU0FBUyxHQUFwQjtJQUN2RSxNQUFNQyxRQUFRLElBQUlMLDhDQUFnQkEsQ0FBQ0csS0FBS0wsNkRBQVFBLENBQUNNLFNBQVNGO0lBQzFELE9BQU9QLHdFQUFtQkEsQ0FBQ1UsT0FBT0g7QUFDdEMsR0FBRyxTQUFTSSxnQkFBZ0JELEtBQUssRUFBRUUsS0FBSyxFQUFFQyxTQUFTO0lBQy9DWCxvRUFBZUEsQ0FBQ1EsT0FBT0UsT0FBT0M7SUFDOUIsTUFBTSxFQUFFTCxHQUFHLEVBQUcsR0FBR0k7SUFDakIsSUFBSUosT0FBTyxRQUFRQSxRQUFRSyxVQUFVTCxHQUFHLEVBQUU7UUFDdENFLE1BQU1JLE1BQU0sQ0FBQ047SUFDakI7QUFDSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9UaWxlTGF5ZXIuanM/OTU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50T2JqZWN0LCBjcmVhdGVUaWxlTGF5ZXJDb21wb25lbnQsIHVwZGF0ZUdyaWRMYXllciwgd2l0aFBhbmUgfSBmcm9tICdAcmVhY3QtbGVhZmxldC9jb3JlJztcbmltcG9ydCB7IFRpbGVMYXllciBhcyBMZWFmbGV0VGlsZUxheWVyIH0gZnJvbSAnbGVhZmxldCc7XG5leHBvcnQgY29uc3QgVGlsZUxheWVyID0gY3JlYXRlVGlsZUxheWVyQ29tcG9uZW50KGZ1bmN0aW9uIGNyZWF0ZVRpbGVMYXllcih7IHVybCAsIC4uLm9wdGlvbnMgfSwgY29udGV4dCkge1xuICAgIGNvbnN0IGxheWVyID0gbmV3IExlYWZsZXRUaWxlTGF5ZXIodXJsLCB3aXRoUGFuZShvcHRpb25zLCBjb250ZXh0KSk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnRPYmplY3QobGF5ZXIsIGNvbnRleHQpO1xufSwgZnVuY3Rpb24gdXBkYXRlVGlsZUxheWVyKGxheWVyLCBwcm9wcywgcHJldlByb3BzKSB7XG4gICAgdXBkYXRlR3JpZExheWVyKGxheWVyLCBwcm9wcywgcHJldlByb3BzKTtcbiAgICBjb25zdCB7IHVybCAgfSA9IHByb3BzO1xuICAgIGlmICh1cmwgIT0gbnVsbCAmJiB1cmwgIT09IHByZXZQcm9wcy51cmwpIHtcbiAgICAgICAgbGF5ZXIuc2V0VXJsKHVybCk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiY3JlYXRlRWxlbWVudE9iamVjdCIsImNyZWF0ZVRpbGVMYXllckNvbXBvbmVudCIsInVwZGF0ZUdyaWRMYXllciIsIndpdGhQYW5lIiwiVGlsZUxheWVyIiwiTGVhZmxldFRpbGVMYXllciIsImNyZWF0ZVRpbGVMYXllciIsImNvbnRleHQiLCJ1cmwiLCJvcHRpb25zIiwibGF5ZXIiLCJ1cGRhdGVUaWxlTGF5ZXIiLCJwcm9wcyIsInByZXZQcm9wcyIsInNldFVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-leaflet/lib/TileLayer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js":
/*!*************************************************!*\
  !*** ./node_modules/react-leaflet/lib/hooks.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMap: function() { return /* binding */ useMap; },\n/* harmony export */   useMapEvent: function() { return /* binding */ useMapEvent; },\n/* harmony export */   useMapEvents: function() { return /* binding */ useMapEvents; }\n/* harmony export */ });\n/* harmony import */ var _react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-leaflet/core */ \"(app-pages-browser)/./node_modules/@react-leaflet/core/lib/context.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\nfunction useMap() {\n    _s();\n    return (0,_react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext)().map;\n}\n_s(useMap, \"0bGQH5PBwF4jhOdj1ao7LMiqXEQ=\", false, function() {\n    return [\n        _react_leaflet_core__WEBPACK_IMPORTED_MODULE_1__.useLeafletContext\n    ];\n});\nfunction useMapEvent(type, handler) {\n    _s1();\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addMapEventHandler() {\n        // @ts-ignore event type\n        map.on(type, handler);\n        return function removeMapEventHandler() {\n            // @ts-ignore event type\n            map.off(type, handler);\n        };\n    }, [\n        map,\n        type,\n        handler\n    ]);\n    return map;\n}\n_s1(useMapEvent, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function() {\n    return [\n        useMap\n    ];\n});\nfunction useMapEvents(handlers) {\n    _s2();\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function addMapEventHandlers() {\n        map.on(handlers);\n        return function removeMapEventHandlers() {\n            map.off(handlers);\n        };\n    }, [\n        map,\n        handlers\n    ]);\n    return map;\n}\n_s2(useMapEvents, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function() {\n    return [\n        useMap\n    ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0L2xpYi9ob29rcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0Q7QUFDdEI7QUFDM0IsU0FBU0U7O0lBQ1osT0FBT0Ysc0VBQWlCQSxHQUFHRyxHQUFHO0FBQ2xDO0dBRmdCRDs7UUFDTEYsa0VBQWlCQTs7O0FBRXJCLFNBQVNJLFlBQVlDLElBQUksRUFBRUMsT0FBTzs7SUFDckMsTUFBTUgsTUFBTUQ7SUFDWkQsZ0RBQVNBLENBQUMsU0FBU007UUFDZix3QkFBd0I7UUFDeEJKLElBQUlLLEVBQUUsQ0FBQ0gsTUFBTUM7UUFDYixPQUFPLFNBQVNHO1lBQ1osd0JBQXdCO1lBQ3hCTixJQUFJTyxHQUFHLENBQUNMLE1BQU1DO1FBQ2xCO0lBQ0osR0FBRztRQUNDSDtRQUNBRTtRQUNBQztLQUNIO0lBQ0QsT0FBT0g7QUFDWDtJQWZnQkM7O1FBQ0FGOzs7QUFlVCxTQUFTUyxhQUFhQyxRQUFROztJQUNqQyxNQUFNVCxNQUFNRDtJQUNaRCxnREFBU0EsQ0FBQyxTQUFTWTtRQUNmVixJQUFJSyxFQUFFLENBQUNJO1FBQ1AsT0FBTyxTQUFTRTtZQUNaWCxJQUFJTyxHQUFHLENBQUNFO1FBQ1o7SUFDSixHQUFHO1FBQ0NUO1FBQ0FTO0tBQ0g7SUFDRCxPQUFPVDtBQUNYO0lBWmdCUTs7UUFDQVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxlYWZsZXQvbGliL2hvb2tzLmpzP2NjMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTGVhZmxldENvbnRleHQgfSBmcm9tICdAcmVhY3QtbGVhZmxldC9jb3JlJztcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXAoKSB7XG4gICAgcmV0dXJuIHVzZUxlYWZsZXRDb250ZXh0KCkubWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcEV2ZW50KHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gYWRkTWFwRXZlbnRIYW5kbGVyKCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIGV2ZW50IHR5cGVcbiAgICAgICAgbWFwLm9uKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTWFwRXZlbnRIYW5kbGVyKCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBldmVudCB0eXBlXG4gICAgICAgICAgICBtYXAub2ZmKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgbWFwLFxuICAgICAgICB0eXBlLFxuICAgICAgICBoYW5kbGVyXG4gICAgXSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYXBFdmVudHMoaGFuZGxlcnMpIHtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gYWRkTWFwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgbWFwLm9uKGhhbmRsZXJzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZU1hcEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICBtYXAub2ZmKGhhbmRsZXJzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcCxcbiAgICAgICAgaGFuZGxlcnNcbiAgICBdKTtcbiAgICByZXR1cm4gbWFwO1xufVxuIl0sIm5hbWVzIjpbInVzZUxlYWZsZXRDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlTWFwIiwibWFwIiwidXNlTWFwRXZlbnQiLCJ0eXBlIiwiaGFuZGxlciIsImFkZE1hcEV2ZW50SGFuZGxlciIsIm9uIiwicmVtb3ZlTWFwRXZlbnRIYW5kbGVyIiwib2ZmIiwidXNlTWFwRXZlbnRzIiwiaGFuZGxlcnMiLCJhZGRNYXBFdmVudEhhbmRsZXJzIiwicmVtb3ZlTWFwRXZlbnRIYW5kbGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js\n"));

/***/ })

}]);