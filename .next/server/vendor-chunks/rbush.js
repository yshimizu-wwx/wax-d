"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rbush";
exports.ids = ["vendor-chunks/rbush"];
exports.modules = {

/***/ "(ssr)/./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = rbush;\nmodule.exports[\"default\"] = rbush;\nvar quickselect = __webpack_require__(/*! quickselect */ \"(ssr)/./node_modules/quickselect/quickselect.js\");\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    if (format) {\n        this._initFormat(format);\n    }\n    this.clear();\n}\nrbush.prototype = {\n    all: function() {\n        return this._all(this.data, []);\n    },\n    search: function(bbox) {\n        var node = this.data, result = [], toBBox = this.toBBox;\n        if (!intersects(bbox, node)) return result;\n        var nodesToSearch = [], i, len, child, childBBox;\n        while(node){\n            for(i = 0, len = node.children.length; i < len; i++){\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n    collides: function(bbox) {\n        var node = this.data, toBBox = this.toBBox;\n        if (!intersects(bbox, node)) return false;\n        var nodesToSearch = [], i, len, child, childBBox;\n        while(node){\n            for(i = 0, len = node.children.length; i < len; i++){\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n        return false;\n    },\n    load: function(data) {\n        if (!(data && data.length)) return this;\n        if (data.length < this._minEntries) {\n            for(var i = 0, len = data.length; i < len; i++){\n                this.insert(data[i]);\n            }\n            return this;\n        }\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n        return this;\n    },\n    insert: function(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n    clear: function() {\n        this.data = createNode([]);\n        return this;\n    },\n    remove: function(item, equalsFn) {\n        if (!item) return this;\n        var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;\n        // depth-first iterative tree traversal\n        while(node || path.length){\n            if (!node) {\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n            if (node.leaf) {\n                index = findItem(item, node.children, equalsFn);\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n            if (!goingUp && !node.leaf && contains(node, bbox)) {\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n            } else if (parent) {\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n            } else node = null; // nothing found\n        }\n        return this;\n    },\n    toBBox: function(item) {\n        return item;\n    },\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n    toJSON: function() {\n        return this.data;\n    },\n    fromJSON: function(data) {\n        this.data = data;\n        return this;\n    },\n    _all: function(node, result) {\n        var nodesToSearch = [];\n        while(node){\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n    _build: function(items, left, right, height) {\n        var N = right - left + 1, M = this._maxEntries, node;\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n        // split the items into M mostly square tiles\n        var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;\n        multiSelect(items, left, right, N1, this.compareMinX);\n        for(i = left; i <= right; i += N1){\n            right2 = Math.min(i + N1 - 1, right);\n            multiSelect(items, i, right2, N2, this.compareMinY);\n            for(j = i; j <= right2; j += N2){\n                right3 = Math.min(j + N2 - 1, right2);\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n        calcBBox(node, this.toBBox);\n        return node;\n    },\n    _chooseSubtree: function(bbox, node, level, path) {\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n        while(true){\n            path.push(node);\n            if (node.leaf || path.length - 1 === level) break;\n            minArea = minEnlargement = Infinity;\n            for(i = 0, len = node.children.length; i < len; i++){\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n            node = targetNode || node.children[0];\n        }\n        return node;\n    },\n    _insert: function(item, level, isNode) {\n        var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n        // split on node overflow; propagate upwards if necessary\n        while(level >= 0){\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n    // split overflowed node into two\n    _split: function(insertPath, level) {\n        var node = insertPath[level], M = node.children.length, m = this._minEntries;\n        this._chooseSplitAxis(node, m, M);\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n    _splitRoot: function(node, newNode) {\n        // split root node\n        this.data = createNode([\n            node,\n            newNode\n        ]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n    _chooseSplitIndex: function(node, m, M) {\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n        minOverlap = minArea = Infinity;\n        for(i = m; i <= M - m; i++){\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n                minArea = area < minArea ? area : minArea;\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n        return index;\n    },\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function(node, m, M) {\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function(node, m, M, compare) {\n        node.children.sort(compare);\n        var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;\n        for(i = m; i < M - m; i++){\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n        for(i = M - m - 1; i >= m; i--){\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n        return margin;\n    },\n    _adjustParentBBoxes: function(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for(var i = level; i >= 0; i--){\n            extend(path[i], bbox);\n        }\n    },\n    _condense: function(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for(var i = path.length - 1, siblings; i >= 0; i--){\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n                } else this.clear();\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n    _initFormat: function(format) {\n        // data format (minX, minY, maxX, maxY accessors)\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n        var compareArr = [\n            \"return a\",\n            \" - b\",\n            \";\"\n        ];\n        this.compareMinX = new Function(\"a\", \"b\", compareArr.join(format[0]));\n        this.compareMinY = new Function(\"a\", \"b\", compareArr.join(format[1]));\n        this.toBBox = new Function(\"a\", \"return {minX: a\" + format[0] + \", minY: a\" + format[1] + \", maxX: a\" + format[2] + \", maxY: a\" + format[3] + \"};\");\n    }\n};\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n    for(var i = 0; i < items.length; i++){\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n    for(var i = k, child; i < p; i++){\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n    return destNode;\n}\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\nfunction compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n}\nfunction bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n}\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\nfunction intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [\n        left,\n        right\n    ], mid;\n    while(stack.length){\n        right = stack.pop();\n        left = stack.pop();\n        if (right - left <= n) continue;\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n        stack.push(left, mid, mid, right);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxFQUFFQyxLQUFLLEVBQUVnRSxDQUFDLEVBQUVwQixPQUFPO0lBQzdDLElBQUlxQixRQUFRO1FBQUNsRTtRQUFNQztLQUFNLEVBQ3JCa0U7SUFFSixNQUFPRCxNQUFNcEcsTUFBTSxDQUFFO1FBQ2pCbUMsUUFBUWlFLE1BQU1oRyxHQUFHO1FBQ2pCOEIsT0FBT2tFLE1BQU1oRyxHQUFHO1FBRWhCLElBQUkrQixRQUFRRCxRQUFRaUUsR0FBRztRQUV2QkUsTUFBTW5FLE9BQU94RCxLQUFLRyxJQUFJLENBQUMsQ0FBQ3NELFFBQVFELElBQUcsSUFBS2lFLElBQUksS0FBS0E7UUFDakQ5SCxZQUFZNkgsS0FBS0csS0FBS25FLE1BQU1DLE9BQU80QztRQUVuQ3FCLE1BQU1sRyxJQUFJLENBQUNnQyxNQUFNbUUsS0FBS0EsS0FBS2xFO0lBQy9CO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92My1hcHAvLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanM/M2ZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmJ1c2giLCJkZWZhdWx0IiwicXVpY2tzZWxlY3QiLCJyZXF1aXJlIiwibWF4RW50cmllcyIsImZvcm1hdCIsIl9tYXhFbnRyaWVzIiwiTWF0aCIsIm1heCIsIl9taW5FbnRyaWVzIiwiY2VpbCIsIl9pbml0Rm9ybWF0IiwiY2xlYXIiLCJwcm90b3R5cGUiLCJhbGwiLCJfYWxsIiwiZGF0YSIsInNlYXJjaCIsImJib3giLCJub2RlIiwicmVzdWx0IiwidG9CQm94IiwiaW50ZXJzZWN0cyIsIm5vZGVzVG9TZWFyY2giLCJpIiwibGVuIiwiY2hpbGQiLCJjaGlsZEJCb3giLCJjaGlsZHJlbiIsImxlbmd0aCIsImxlYWYiLCJwdXNoIiwiY29udGFpbnMiLCJwb3AiLCJjb2xsaWRlcyIsImxvYWQiLCJpbnNlcnQiLCJfYnVpbGQiLCJzbGljZSIsImhlaWdodCIsIl9zcGxpdFJvb3QiLCJ0bXBOb2RlIiwiX2luc2VydCIsIml0ZW0iLCJjcmVhdGVOb2RlIiwicmVtb3ZlIiwiZXF1YWxzRm4iLCJwYXRoIiwiaW5kZXhlcyIsInBhcmVudCIsImluZGV4IiwiZ29pbmdVcCIsImZpbmRJdGVtIiwic3BsaWNlIiwiX2NvbmRlbnNlIiwiY29tcGFyZU1pblgiLCJjb21wYXJlTm9kZU1pblgiLCJjb21wYXJlTWluWSIsImNvbXBhcmVOb2RlTWluWSIsInRvSlNPTiIsImZyb21KU09OIiwiYXBwbHkiLCJpdGVtcyIsImxlZnQiLCJyaWdodCIsIk4iLCJNIiwiY2FsY0JCb3giLCJsb2ciLCJwb3ciLCJOMiIsIk4xIiwic3FydCIsImoiLCJyaWdodDIiLCJyaWdodDMiLCJtdWx0aVNlbGVjdCIsIm1pbiIsIl9jaG9vc2VTdWJ0cmVlIiwibGV2ZWwiLCJ0YXJnZXROb2RlIiwiYXJlYSIsImVubGFyZ2VtZW50IiwibWluQXJlYSIsIm1pbkVubGFyZ2VtZW50IiwiSW5maW5pdHkiLCJiYm94QXJlYSIsImVubGFyZ2VkQXJlYSIsImlzTm9kZSIsImluc2VydFBhdGgiLCJleHRlbmQiLCJfc3BsaXQiLCJfYWRqdXN0UGFyZW50QkJveGVzIiwibSIsIl9jaG9vc2VTcGxpdEF4aXMiLCJzcGxpdEluZGV4IiwiX2Nob29zZVNwbGl0SW5kZXgiLCJuZXdOb2RlIiwiYmJveDEiLCJiYm94MiIsIm92ZXJsYXAiLCJtaW5PdmVybGFwIiwiZGlzdEJCb3giLCJpbnRlcnNlY3Rpb25BcmVhIiwieE1hcmdpbiIsIl9hbGxEaXN0TWFyZ2luIiwieU1hcmdpbiIsInNvcnQiLCJjb21wYXJlIiwibGVmdEJCb3giLCJyaWdodEJCb3giLCJtYXJnaW4iLCJiYm94TWFyZ2luIiwic2libGluZ3MiLCJpbmRleE9mIiwiY29tcGFyZUFyciIsIkZ1bmN0aW9uIiwiam9pbiIsImsiLCJwIiwiZGVzdE5vZGUiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiYSIsImIiLCJhcnIiLCJuIiwic3RhY2siLCJtaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rbush/index.js\n");

/***/ })

};
;