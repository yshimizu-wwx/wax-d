"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/turf-jsts";
exports.ids = ["vendor-chunks/turf-jsts"];
exports.modules = {

/***/ "(ssr)/./node_modules/turf-jsts/jsts.mjs":
/*!*****************************************!*\
  !*** ./node_modules/turf-jsts/jsts.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferOp: () => (/* binding */ BufferOp),\n/* harmony export */   GeoJSONReader: () => (/* binding */ GeoJSONReader),\n/* harmony export */   GeoJSONWriter: () => (/* binding */ GeoJSONWriter),\n/* harmony export */   OverlayOp: () => (/* binding */ OverlayOp),\n/* harmony export */   UnionOp: () => (/* binding */ UnionOp)\n/* harmony export */ });\n/* Polyfill service v3.13.0\n * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n *\n * - Array.prototype.fill, License: CC0 */ if (!(\"fill\" in Array.prototype)) {\n    Object.defineProperty(Array.prototype, \"fill\", {\n        configurable: true,\n        value: function fill(value) {\n            if (this === undefined || this === null) {\n                throw new TypeError(this + \" is not an object\");\n            }\n            var arrayLike = Object(this);\n            var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n            var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n            relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n            var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n            relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n            while(relativeStart < relativeEnd){\n                arrayLike[relativeStart] = value;\n                ++relativeStart;\n            }\n            return arrayLike;\n        },\n        writable: true\n    });\n}\n/**\n * Polyfill for IE support\n */ Number.isFinite = Number.isFinite || function(value) {\n    return typeof value === \"number\" && isFinite(value);\n};\nNumber.isInteger = Number.isInteger || function(val) {\n    return typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n};\nNumber.parseFloat = Number.parseFloat || parseFloat;\nNumber.isNaN = Number.isNaN || function(value) {\n    return value !== value // eslint-disable-line\n    ;\n};\n/**\n * Polyfill for IE support\n */ Math.trunc = Math.trunc || function(x) {\n    return x < 0 ? Math.ceil(x) : Math.floor(x);\n};\nvar NumberUtil = function NumberUtil() {};\nNumberUtil.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nNumberUtil.prototype.getClass = function getClass() {\n    return NumberUtil;\n};\nNumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance(x1, x2, tolerance) {\n    return Math.abs(x1 - x2) <= tolerance;\n};\nvar IllegalArgumentException = function(Error1) {\n    function IllegalArgumentException(message) {\n        Error1.call(this, message);\n        this.name = \"IllegalArgumentException\";\n        this.message = message;\n        this.stack = new Error1().stack;\n    }\n    if (Error1) IllegalArgumentException.__proto__ = Error1;\n    IllegalArgumentException.prototype = Object.create(Error1 && Error1.prototype);\n    IllegalArgumentException.prototype.constructor = IllegalArgumentException;\n    return IllegalArgumentException;\n}(Error);\nvar Double = function Double() {};\nvar staticAccessors$1 = {\n    MAX_VALUE: {\n        configurable: true\n    }\n};\nDouble.isNaN = function isNaN(n) {\n    return Number.isNaN(n);\n};\nDouble.doubleToLongBits = function doubleToLongBits(n) {\n    return n;\n};\nDouble.longBitsToDouble = function longBitsToDouble(n) {\n    return n;\n};\nDouble.isInfinite = function isInfinite(n) {\n    return !Number.isFinite(n);\n};\nstaticAccessors$1.MAX_VALUE.get = function() {\n    return Number.MAX_VALUE;\n};\nObject.defineProperties(Double, staticAccessors$1);\nvar Comparable = function Comparable() {};\nvar Clonable = function Clonable() {};\nvar Comparator = function Comparator() {};\nfunction Serializable() {}\n// import Assert from '../util/Assert'\nvar Coordinate = function Coordinate() {\n    this.x = null;\n    this.y = null;\n    this.z = null;\n    if (arguments.length === 0) {\n        this.x = 0.0;\n        this.y = 0.0;\n        this.z = Coordinate.NULL_ORDINATE;\n    } else if (arguments.length === 1) {\n        var c = arguments[0];\n        this.x = c.x;\n        this.y = c.y;\n        this.z = c.z;\n    } else if (arguments.length === 2) {\n        this.x = arguments[0];\n        this.y = arguments[1];\n        this.z = Coordinate.NULL_ORDINATE;\n    } else if (arguments.length === 3) {\n        this.x = arguments[0];\n        this.y = arguments[1];\n        this.z = arguments[2];\n    }\n};\nvar staticAccessors = {\n    DimensionalComparator: {\n        configurable: true\n    },\n    serialVersionUID: {\n        configurable: true\n    },\n    NULL_ORDINATE: {\n        configurable: true\n    },\n    X: {\n        configurable: true\n    },\n    Y: {\n        configurable: true\n    },\n    Z: {\n        configurable: true\n    }\n};\nCoordinate.prototype.setOrdinate = function setOrdinate(ordinateIndex, value) {\n    switch(ordinateIndex){\n        case Coordinate.X:\n            this.x = value;\n            break;\n        case Coordinate.Y:\n            this.y = value;\n            break;\n        case Coordinate.Z:\n            this.z = value;\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n    }\n};\nCoordinate.prototype.equals2D = function equals2D() {\n    if (arguments.length === 1) {\n        var other = arguments[0];\n        if (this.x !== other.x) {\n            return false;\n        }\n        if (this.y !== other.y) {\n            return false;\n        }\n        return true;\n    } else if (arguments.length === 2) {\n        var c = arguments[0];\n        var tolerance = arguments[1];\n        if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n            return false;\n        }\n        if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n            return false;\n        }\n        return true;\n    }\n};\nCoordinate.prototype.getOrdinate = function getOrdinate(ordinateIndex) {\n    switch(ordinateIndex){\n        case Coordinate.X:\n            return this.x;\n        case Coordinate.Y:\n            return this.y;\n        case Coordinate.Z:\n            return this.z;\n        default:\n    }\n    throw new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n};\nCoordinate.prototype.equals3D = function equals3D(other) {\n    return this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z)) && Double.isNaN(other.z);\n};\nCoordinate.prototype.equals = function equals(other) {\n    if (!(other instanceof Coordinate)) {\n        return false;\n    }\n    return this.equals2D(other);\n};\nCoordinate.prototype.equalInZ = function equalInZ(c, tolerance) {\n    return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n};\nCoordinate.prototype.compareTo = function compareTo(o) {\n    var other = o;\n    if (this.x < other.x) {\n        return -1;\n    }\n    if (this.x > other.x) {\n        return 1;\n    }\n    if (this.y < other.y) {\n        return -1;\n    }\n    if (this.y > other.y) {\n        return 1;\n    }\n    return 0;\n};\nCoordinate.prototype.clone = function clone() {\n// try {\n// var coord = null\n// return coord\n// } catch (e) {\n// if (e instanceof CloneNotSupportedException) {\n//   Assert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\")\n//   return null\n// } else throw e\n// } finally {}\n};\nCoordinate.prototype.copy = function copy() {\n    return new Coordinate(this);\n};\nCoordinate.prototype.toString = function toString() {\n    return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n};\nCoordinate.prototype.distance3D = function distance3D(c) {\n    var dx = this.x - c.x;\n    var dy = this.y - c.y;\n    var dz = this.z - c.z;\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n};\nCoordinate.prototype.distance = function distance(c) {\n    var dx = this.x - c.x;\n    var dy = this.y - c.y;\n    return Math.sqrt(dx * dx + dy * dy);\n};\nCoordinate.prototype.hashCode = function hashCode() {\n    var result = 17;\n    result = 37 * result + Coordinate.hashCode(this.x);\n    result = 37 * result + Coordinate.hashCode(this.y);\n    return result;\n};\nCoordinate.prototype.setCoordinate = function setCoordinate(other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.z = other.z;\n};\nCoordinate.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable,\n        Clonable,\n        Serializable\n    ];\n};\nCoordinate.prototype.getClass = function getClass() {\n    return Coordinate;\n};\nCoordinate.hashCode = function hashCode() {\n    if (arguments.length === 1) {\n        var x = arguments[0];\n        var f = Double.doubleToLongBits(x);\n        return Math.trunc((f ^ f) >>> 32);\n    }\n};\nstaticAccessors.DimensionalComparator.get = function() {\n    return DimensionalComparator;\n};\nstaticAccessors.serialVersionUID.get = function() {\n    return 6683108902428366910;\n};\nstaticAccessors.NULL_ORDINATE.get = function() {\n    return Double.NaN;\n};\nstaticAccessors.X.get = function() {\n    return 0;\n};\nstaticAccessors.Y.get = function() {\n    return 1;\n};\nstaticAccessors.Z.get = function() {\n    return 2;\n};\nObject.defineProperties(Coordinate, staticAccessors);\nvar DimensionalComparator = function DimensionalComparator(dimensionsToTest) {\n    this._dimensionsToTest = 2;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var dimensionsToTest$1 = arguments[0];\n        if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) {\n            throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n        }\n        this._dimensionsToTest = dimensionsToTest$1;\n    }\n};\nDimensionalComparator.prototype.compare = function compare(o1, o2) {\n    var c1 = o1;\n    var c2 = o2;\n    var compX = DimensionalComparator.compare(c1.x, c2.x);\n    if (compX !== 0) {\n        return compX;\n    }\n    var compY = DimensionalComparator.compare(c1.y, c2.y);\n    if (compY !== 0) {\n        return compY;\n    }\n    if (this._dimensionsToTest <= 2) {\n        return 0;\n    }\n    var compZ = DimensionalComparator.compare(c1.z, c2.z);\n    return compZ;\n};\nDimensionalComparator.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparator\n    ];\n};\nDimensionalComparator.prototype.getClass = function getClass() {\n    return DimensionalComparator;\n};\nDimensionalComparator.compare = function compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    if (Double.isNaN(a)) {\n        if (Double.isNaN(b)) {\n            return 0;\n        }\n        return -1;\n    }\n    if (Double.isNaN(b)) {\n        return 1;\n    }\n    return 0;\n};\n// import hasInterface from '../../../../hasInterface'\n// import CoordinateSequence from './CoordinateSequence'\nvar CoordinateSequenceFactory = function CoordinateSequenceFactory() {};\nCoordinateSequenceFactory.prototype.create = function create() {\n// if (arguments.length === 1) {\n// if (arguments[0] instanceof Array) {\n//   let coordinates = arguments[0]\n// } else if (hasInterface(arguments[0], CoordinateSequence)) {\n//   let coordSeq = arguments[0]\n// }\n// } else if (arguments.length === 2) {\n// let size = arguments[0]\n// let dimension = arguments[1]\n// }\n};\nCoordinateSequenceFactory.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCoordinateSequenceFactory.prototype.getClass = function getClass() {\n    return CoordinateSequenceFactory;\n};\nvar Location = function Location() {};\nvar staticAccessors$4 = {\n    INTERIOR: {\n        configurable: true\n    },\n    BOUNDARY: {\n        configurable: true\n    },\n    EXTERIOR: {\n        configurable: true\n    },\n    NONE: {\n        configurable: true\n    }\n};\nLocation.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLocation.prototype.getClass = function getClass() {\n    return Location;\n};\nLocation.toLocationSymbol = function toLocationSymbol(locationValue) {\n    switch(locationValue){\n        case Location.EXTERIOR:\n            return \"e\";\n        case Location.BOUNDARY:\n            return \"b\";\n        case Location.INTERIOR:\n            return \"i\";\n        case Location.NONE:\n            return \"-\";\n        default:\n    }\n    throw new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n};\nstaticAccessors$4.INTERIOR.get = function() {\n    return 0;\n};\nstaticAccessors$4.BOUNDARY.get = function() {\n    return 1;\n};\nstaticAccessors$4.EXTERIOR.get = function() {\n    return 2;\n};\nstaticAccessors$4.NONE.get = function() {\n    return -1;\n};\nObject.defineProperties(Location, staticAccessors$4);\nvar hasInterface = function(o, i) {\n    return o.interfaces_ && o.interfaces_().indexOf(i) > -1;\n};\nvar MathUtil = function MathUtil() {};\nvar staticAccessors$5 = {\n    LOG_10: {\n        configurable: true\n    }\n};\nMathUtil.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMathUtil.prototype.getClass = function getClass() {\n    return MathUtil;\n};\nMathUtil.log10 = function log10(x) {\n    var ln = Math.log(x);\n    if (Double.isInfinite(ln)) {\n        return ln;\n    }\n    if (Double.isNaN(ln)) {\n        return ln;\n    }\n    return ln / MathUtil.LOG_10;\n};\nMathUtil.min = function min(v1, v2, v3, v4) {\n    var min = v1;\n    if (v2 < min) {\n        min = v2;\n    }\n    if (v3 < min) {\n        min = v3;\n    }\n    if (v4 < min) {\n        min = v4;\n    }\n    return min;\n};\nMathUtil.clamp = function clamp() {\n    if (typeof arguments[2] === \"number\" && typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n        var x = arguments[0];\n        var min = arguments[1];\n        var max = arguments[2];\n        if (x < min) {\n            return min;\n        }\n        if (x > max) {\n            return max;\n        }\n        return x;\n    } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n        var x$1 = arguments[0];\n        var min$1 = arguments[1];\n        var max$1 = arguments[2];\n        if (x$1 < min$1) {\n            return min$1;\n        }\n        if (x$1 > max$1) {\n            return max$1;\n        }\n        return x$1;\n    }\n};\nMathUtil.wrap = function wrap(index, max) {\n    if (index < 0) {\n        return max - -index % max;\n    }\n    return index % max;\n};\nMathUtil.max = function max() {\n    if (arguments.length === 3) {\n        var v1 = arguments[0];\n        var v2 = arguments[1];\n        var v3 = arguments[2];\n        var max = v1;\n        if (v2 > max) {\n            max = v2;\n        }\n        if (v3 > max) {\n            max = v3;\n        }\n        return max;\n    } else if (arguments.length === 4) {\n        var v1$1 = arguments[0];\n        var v2$1 = arguments[1];\n        var v3$1 = arguments[2];\n        var v4 = arguments[3];\n        var max$1 = v1$1;\n        if (v2$1 > max$1) {\n            max$1 = v2$1;\n        }\n        if (v3$1 > max$1) {\n            max$1 = v3$1;\n        }\n        if (v4 > max$1) {\n            max$1 = v4;\n        }\n        return max$1;\n    }\n};\nMathUtil.average = function average(x1, x2) {\n    return (x1 + x2) / 2.0;\n};\nstaticAccessors$5.LOG_10.get = function() {\n    return Math.log(10);\n};\nObject.defineProperties(MathUtil, staticAccessors$5);\nvar StringBuffer = function StringBuffer(str) {\n    this.str = str;\n};\nStringBuffer.prototype.append = function append(e) {\n    this.str += e;\n};\nStringBuffer.prototype.setCharAt = function setCharAt(i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n};\nStringBuffer.prototype.toString = function toString(e) {\n    return this.str;\n};\nvar Integer = function Integer(value) {\n    this.value = value;\n};\nInteger.prototype.intValue = function intValue() {\n    return this.value;\n};\nInteger.prototype.compareTo = function compareTo(o) {\n    if (this.value < o) {\n        return -1;\n    }\n    if (this.value > o) {\n        return 1;\n    }\n    return 0;\n};\nInteger.isNaN = function isNaN(n) {\n    return Number.isNaN(n);\n};\nvar Character = function Character() {};\nCharacter.isWhitespace = function isWhitespace(c) {\n    return c <= 32 && c >= 0 || c === 127;\n};\nCharacter.toUpperCase = function toUpperCase(c) {\n    return c.toUpperCase();\n};\nvar DD = function DD() {\n    this._hi = 0.0;\n    this._lo = 0.0;\n    if (arguments.length === 0) {\n        this.init(0.0);\n    } else if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n            var x = arguments[0];\n            this.init(x);\n        } else if (arguments[0] instanceof DD) {\n            var dd = arguments[0];\n            this.init(dd);\n        } else if (typeof arguments[0] === \"string\") {\n            var str = arguments[0];\n            DD.call(this, DD.parse(str));\n        }\n    } else if (arguments.length === 2) {\n        var hi = arguments[0];\n        var lo = arguments[1];\n        this.init(hi, lo);\n    }\n};\nvar staticAccessors$7 = {\n    PI: {\n        configurable: true\n    },\n    TWO_PI: {\n        configurable: true\n    },\n    PI_2: {\n        configurable: true\n    },\n    E: {\n        configurable: true\n    },\n    NaN: {\n        configurable: true\n    },\n    EPS: {\n        configurable: true\n    },\n    SPLIT: {\n        configurable: true\n    },\n    MAX_PRINT_DIGITS: {\n        configurable: true\n    },\n    TEN: {\n        configurable: true\n    },\n    ONE: {\n        configurable: true\n    },\n    SCI_NOT_EXPONENT_CHAR: {\n        configurable: true\n    },\n    SCI_NOT_ZERO: {\n        configurable: true\n    }\n};\nDD.prototype.le = function le(y) {\n    return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo;\n};\nDD.prototype.extractSignificantDigits = function extractSignificantDigits(insertDecimalPoint, magnitude) {\n    var y = this.abs();\n    var mag = DD.magnitude(y._hi);\n    var scale = DD.TEN.pow(mag);\n    y = y.divide(scale);\n    if (y.gt(DD.TEN)) {\n        y = y.divide(DD.TEN);\n        mag += 1;\n    } else if (y.lt(DD.ONE)) {\n        y = y.multiply(DD.TEN);\n        mag -= 1;\n    }\n    var decimalPointPos = mag + 1;\n    var buf = new StringBuffer();\n    var numDigits = DD.MAX_PRINT_DIGITS - 1;\n    for(var i = 0; i <= numDigits; i++){\n        if (insertDecimalPoint && i === decimalPointPos) {\n            buf.append(\".\");\n        }\n        var digit = Math.trunc(y._hi);\n        if (digit < 0) {\n            break;\n        }\n        var rebiasBy10 = false;\n        var digitChar = 0;\n        if (digit > 9) {\n            rebiasBy10 = true;\n            digitChar = \"9\";\n        } else {\n            digitChar = \"0\" + digit;\n        }\n        buf.append(digitChar);\n        y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n        if (rebiasBy10) {\n            y.selfAdd(DD.TEN);\n        }\n        var continueExtractingDigits = true;\n        var remMag = DD.magnitude(y._hi);\n        if (remMag < 0 && Math.abs(remMag) >= numDigits - i) {\n            continueExtractingDigits = false;\n        }\n        if (!continueExtractingDigits) {\n            break;\n        }\n    }\n    magnitude[0] = mag;\n    return buf.toString();\n};\nDD.prototype.sqr = function sqr() {\n    return this.multiply(this);\n};\nDD.prototype.doubleValue = function doubleValue() {\n    return this._hi + this._lo;\n};\nDD.prototype.subtract = function subtract() {\n    if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        return this.add(y.negate());\n    } else if (typeof arguments[0] === \"number\") {\n        var y$1 = arguments[0];\n        return this.add(-y$1);\n    }\n};\nDD.prototype.equals = function equals() {\n    if (arguments.length === 1) {\n        var y = arguments[0];\n        return this._hi === y._hi && this._lo === y._lo;\n    }\n};\nDD.prototype.isZero = function isZero() {\n    return this._hi === 0.0 && this._lo === 0.0;\n};\nDD.prototype.selfSubtract = function selfSubtract() {\n    if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        if (this.isNaN()) {\n            return this;\n        }\n        return this.selfAdd(-y._hi, -y._lo);\n    } else if (typeof arguments[0] === \"number\") {\n        var y$1 = arguments[0];\n        if (this.isNaN()) {\n            return this;\n        }\n        return this.selfAdd(-y$1, 0.0);\n    }\n};\nDD.prototype.getSpecialNumberString = function getSpecialNumberString() {\n    if (this.isZero()) {\n        return \"0.0\";\n    }\n    if (this.isNaN()) {\n        return \"NaN \";\n    }\n    return null;\n};\nDD.prototype.min = function min(x) {\n    if (this.le(x)) {\n        return this;\n    } else {\n        return x;\n    }\n};\nDD.prototype.selfDivide = function selfDivide() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n            var y = arguments[0];\n            return this.selfDivide(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n            var y$1 = arguments[0];\n            return this.selfDivide(y$1, 0.0);\n        }\n    } else if (arguments.length === 2) {\n        var yhi = arguments[0];\n        var ylo = arguments[1];\n        var hc = null;\n        var tc = null;\n        var hy = null;\n        var ty = null;\n        var C = null;\n        var c = null;\n        var U = null;\n        var u = null;\n        C = this._hi / yhi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * yhi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - yhi;\n        U = C * yhi;\n        hy = u - hy;\n        ty = yhi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n        u = C + c;\n        this._hi = u;\n        this._lo = C - u + c;\n        return this;\n    }\n};\nDD.prototype.dump = function dump() {\n    return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n};\nDD.prototype.divide = function divide() {\n    if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        var hc = null;\n        var tc = null;\n        var hy = null;\n        var ty = null;\n        var C = null;\n        var c = null;\n        var U = null;\n        var u = null;\n        C = this._hi / y._hi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * y._hi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - y._hi;\n        U = C * y._hi;\n        hy = u - hy;\n        ty = y._hi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n        u = C + c;\n        var zhi = u;\n        var zlo = C - u + c;\n        return new DD(zhi, zlo);\n    } else if (typeof arguments[0] === \"number\") {\n        var y$1 = arguments[0];\n        if (Double.isNaN(y$1)) {\n            return DD.createNaN();\n        }\n        return DD.copy(this).selfDivide(y$1, 0.0);\n    }\n};\nDD.prototype.ge = function ge(y) {\n    return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo;\n};\nDD.prototype.pow = function pow(exp) {\n    if (exp === 0.0) {\n        return DD.valueOf(1.0);\n    }\n    var r = new DD(this);\n    var s = DD.valueOf(1.0);\n    var n = Math.abs(exp);\n    if (n > 1) {\n        while(n > 0){\n            if (n % 2 === 1) {\n                s.selfMultiply(r);\n            }\n            n /= 2;\n            if (n > 0) {\n                r = r.sqr();\n            }\n        }\n    } else {\n        s = r;\n    }\n    if (exp < 0) {\n        return s.reciprocal();\n    }\n    return s;\n};\nDD.prototype.ceil = function ceil() {\n    if (this.isNaN()) {\n        return DD.NaN;\n    }\n    var fhi = Math.ceil(this._hi);\n    var flo = 0.0;\n    if (fhi === this._hi) {\n        flo = Math.ceil(this._lo);\n    }\n    return new DD(fhi, flo);\n};\nDD.prototype.compareTo = function compareTo(o) {\n    var other = o;\n    if (this._hi < other._hi) {\n        return -1;\n    }\n    if (this._hi > other._hi) {\n        return 1;\n    }\n    if (this._lo < other._lo) {\n        return -1;\n    }\n    if (this._lo > other._lo) {\n        return 1;\n    }\n    return 0;\n};\nDD.prototype.rint = function rint() {\n    if (this.isNaN()) {\n        return this;\n    }\n    var plus5 = this.add(0.5);\n    return plus5.floor();\n};\nDD.prototype.setValue = function setValue() {\n    if (arguments[0] instanceof DD) {\n        var value = arguments[0];\n        this.init(value);\n        return this;\n    } else if (typeof arguments[0] === \"number\") {\n        var value$1 = arguments[0];\n        this.init(value$1);\n        return this;\n    }\n};\nDD.prototype.max = function max(x) {\n    if (this.ge(x)) {\n        return this;\n    } else {\n        return x;\n    }\n};\nDD.prototype.sqrt = function sqrt() {\n    if (this.isZero()) {\n        return DD.valueOf(0.0);\n    }\n    if (this.isNegative()) {\n        return DD.NaN;\n    }\n    var x = 1.0 / Math.sqrt(this._hi);\n    var ax = this._hi * x;\n    var axdd = DD.valueOf(ax);\n    var diffSq = this.subtract(axdd.sqr());\n    var d2 = diffSq._hi * (x * 0.5);\n    return axdd.add(d2);\n};\nDD.prototype.selfAdd = function selfAdd() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n            var y = arguments[0];\n            return this.selfAdd(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n            var y$1 = arguments[0];\n            var H = null;\n            var h = null;\n            var S = null;\n            var s = null;\n            var e = null;\n            var f = null;\n            S = this._hi + y$1;\n            e = S - this._hi;\n            s = S - e;\n            s = y$1 - e + (this._hi - s);\n            f = s + this._lo;\n            H = S + f;\n            h = f + (S - H);\n            this._hi = H + h;\n            this._lo = h + (H - this._hi);\n            return this;\n        }\n    } else if (arguments.length === 2) {\n        var yhi = arguments[0];\n        var ylo = arguments[1];\n        var H$1 = null;\n        var h$1 = null;\n        var T = null;\n        var t = null;\n        var S$1 = null;\n        var s$1 = null;\n        var e$1 = null;\n        var f$1 = null;\n        S$1 = this._hi + yhi;\n        T = this._lo + ylo;\n        e$1 = S$1 - this._hi;\n        f$1 = T - this._lo;\n        s$1 = S$1 - e$1;\n        t = T - f$1;\n        s$1 = yhi - e$1 + (this._hi - s$1);\n        t = ylo - f$1 + (this._lo - t);\n        e$1 = s$1 + T;\n        H$1 = S$1 + e$1;\n        h$1 = e$1 + (S$1 - H$1);\n        e$1 = t + h$1;\n        var zhi = H$1 + e$1;\n        var zlo = e$1 + (H$1 - zhi);\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n    }\n};\nDD.prototype.selfMultiply = function selfMultiply() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n            var y = arguments[0];\n            return this.selfMultiply(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n            var y$1 = arguments[0];\n            return this.selfMultiply(y$1, 0.0);\n        }\n    } else if (arguments.length === 2) {\n        var yhi = arguments[0];\n        var ylo = arguments[1];\n        var hx = null;\n        var tx = null;\n        var hy = null;\n        var ty = null;\n        var C = null;\n        var c = null;\n        C = DD.SPLIT * this._hi;\n        hx = C - this._hi;\n        c = DD.SPLIT * yhi;\n        hx = C - hx;\n        tx = this._hi - hx;\n        hy = c - yhi;\n        C = this._hi * yhi;\n        hy = c - hy;\n        ty = yhi - hy;\n        c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n        var zhi = C + c;\n        hx = C - zhi;\n        var zlo = c + hx;\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n    }\n};\nDD.prototype.selfSqr = function selfSqr() {\n    return this.selfMultiply(this);\n};\nDD.prototype.floor = function floor() {\n    if (this.isNaN()) {\n        return DD.NaN;\n    }\n    var fhi = Math.floor(this._hi);\n    var flo = 0.0;\n    if (fhi === this._hi) {\n        flo = Math.floor(this._lo);\n    }\n    return new DD(fhi, flo);\n};\nDD.prototype.negate = function negate() {\n    if (this.isNaN()) {\n        return this;\n    }\n    return new DD(-this._hi, -this._lo);\n};\nDD.prototype.clone = function clone() {\n// try {\n// return null\n// } catch (ex) {\n// if (ex instanceof CloneNotSupportedException) {\n//   return null\n// } else throw ex\n// } finally {}\n};\nDD.prototype.multiply = function multiply() {\n    if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        if (y.isNaN()) {\n            return DD.createNaN();\n        }\n        return DD.copy(this).selfMultiply(y);\n    } else if (typeof arguments[0] === \"number\") {\n        var y$1 = arguments[0];\n        if (Double.isNaN(y$1)) {\n            return DD.createNaN();\n        }\n        return DD.copy(this).selfMultiply(y$1, 0.0);\n    }\n};\nDD.prototype.isNaN = function isNaN() {\n    return Double.isNaN(this._hi);\n};\nDD.prototype.intValue = function intValue() {\n    return Math.trunc(this._hi);\n};\nDD.prototype.toString = function toString() {\n    var mag = DD.magnitude(this._hi);\n    if (mag >= -3 && mag <= 20) {\n        return this.toStandardNotation();\n    }\n    return this.toSciNotation();\n};\nDD.prototype.toStandardNotation = function toStandardNotation() {\n    var specialStr = this.getSpecialNumberString();\n    if (specialStr !== null) {\n        return specialStr;\n    }\n    var magnitude = new Array(1).fill(null);\n    var sigDigits = this.extractSignificantDigits(true, magnitude);\n    var decimalPointPos = magnitude[0] + 1;\n    var num = sigDigits;\n    if (sigDigits.charAt(0) === \".\") {\n        num = \"0\" + sigDigits;\n    } else if (decimalPointPos < 0) {\n        num = \"0.\" + DD.stringOfChar(\"0\", -decimalPointPos) + sigDigits;\n    } else if (sigDigits.indexOf(\".\") === -1) {\n        var numZeroes = decimalPointPos - sigDigits.length;\n        var zeroes = DD.stringOfChar(\"0\", numZeroes);\n        num = sigDigits + zeroes + \".0\";\n    }\n    if (this.isNegative()) {\n        return \"-\" + num;\n    }\n    return num;\n};\nDD.prototype.reciprocal = function reciprocal() {\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = 1.0 / this._hi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * this._hi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - this._hi;\n    U = C * this._hi;\n    hy = u - hy;\n    ty = this._hi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (1.0 - U - u - C * this._lo) / this._hi;\n    var zhi = C + c;\n    var zlo = C - zhi + c;\n    return new DD(zhi, zlo);\n};\nDD.prototype.toSciNotation = function toSciNotation() {\n    if (this.isZero()) {\n        return DD.SCI_NOT_ZERO;\n    }\n    var specialStr = this.getSpecialNumberString();\n    if (specialStr !== null) {\n        return specialStr;\n    }\n    var magnitude = new Array(1).fill(null);\n    var digits = this.extractSignificantDigits(false, magnitude);\n    var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n    if (digits.charAt(0) === \"0\") {\n        throw new Error(\"Found leading zero: \" + digits);\n    }\n    var trailingDigits = \"\";\n    if (digits.length > 1) {\n        trailingDigits = digits.substring(1);\n    }\n    var digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n    if (this.isNegative()) {\n        return \"-\" + digitsWithDecimal + expStr;\n    }\n    return digitsWithDecimal + expStr;\n};\nDD.prototype.abs = function abs() {\n    if (this.isNaN()) {\n        return DD.NaN;\n    }\n    if (this.isNegative()) {\n        return this.negate();\n    }\n    return new DD(this);\n};\nDD.prototype.isPositive = function isPositive() {\n    return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0;\n};\nDD.prototype.lt = function lt(y) {\n    return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo;\n};\nDD.prototype.add = function add() {\n    if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        return DD.copy(this).selfAdd(y);\n    } else if (typeof arguments[0] === \"number\") {\n        var y$1 = arguments[0];\n        return DD.copy(this).selfAdd(y$1);\n    }\n};\nDD.prototype.init = function init() {\n    if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n            var x = arguments[0];\n            this._hi = x;\n            this._lo = 0.0;\n        } else if (arguments[0] instanceof DD) {\n            var dd = arguments[0];\n            this._hi = dd._hi;\n            this._lo = dd._lo;\n        }\n    } else if (arguments.length === 2) {\n        var hi = arguments[0];\n        var lo = arguments[1];\n        this._hi = hi;\n        this._lo = lo;\n    }\n};\nDD.prototype.gt = function gt(y) {\n    return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo;\n};\nDD.prototype.isNegative = function isNegative() {\n    return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0;\n};\nDD.prototype.trunc = function trunc() {\n    if (this.isNaN()) {\n        return DD.NaN;\n    }\n    if (this.isPositive()) {\n        return this.floor();\n    } else {\n        return this.ceil();\n    }\n};\nDD.prototype.signum = function signum() {\n    if (this._hi > 0) {\n        return 1;\n    }\n    if (this._hi < 0) {\n        return -1;\n    }\n    if (this._lo > 0) {\n        return 1;\n    }\n    if (this._lo < 0) {\n        return -1;\n    }\n    return 0;\n};\nDD.prototype.interfaces_ = function interfaces_() {\n    return [\n        Serializable,\n        Comparable,\n        Clonable\n    ];\n};\nDD.prototype.getClass = function getClass() {\n    return DD;\n};\nDD.sqr = function sqr(x) {\n    return DD.valueOf(x).selfMultiply(x);\n};\nDD.valueOf = function valueOf() {\n    if (typeof arguments[0] === \"string\") {\n        var str = arguments[0];\n        return DD.parse(str);\n    } else if (typeof arguments[0] === \"number\") {\n        var x = arguments[0];\n        return new DD(x);\n    }\n};\nDD.sqrt = function sqrt(x) {\n    return DD.valueOf(x).sqrt();\n};\nDD.parse = function parse(str) {\n    var i = 0;\n    var strlen = str.length;\n    while(Character.isWhitespace(str.charAt(i))){\n        i++;\n    }\n    var isNegative = false;\n    if (i < strlen) {\n        var signCh = str.charAt(i);\n        if (signCh === \"-\" || signCh === \"+\") {\n            i++;\n            if (signCh === \"-\") {\n                isNegative = true;\n            }\n        }\n    }\n    var val = new DD();\n    var numDigits = 0;\n    var numBeforeDec = 0;\n    var exp = 0;\n    while(true){\n        if (i >= strlen) {\n            break;\n        }\n        var ch = str.charAt(i);\n        i++;\n        if (Character.isDigit(ch)) {\n            var d = ch - \"0\";\n            val.selfMultiply(DD.TEN);\n            val.selfAdd(d);\n            numDigits++;\n            continue;\n        }\n        if (ch === \".\") {\n            numBeforeDec = numDigits;\n            continue;\n        }\n        if (ch === \"e\" || ch === \"E\") {\n            var expStr = str.substring(i);\n            try {\n                exp = Integer.parseInt(expStr);\n            } catch (ex) {\n                if (ex instanceof Error) {\n                    throw new Error(\"Invalid exponent \" + expStr + \" in string \" + str);\n                } else {\n                    throw ex;\n                }\n            } finally{}\n            break;\n        }\n        throw new Error(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n    }\n    var val2 = val;\n    var numDecPlaces = numDigits - numBeforeDec - exp;\n    if (numDecPlaces === 0) {\n        val2 = val;\n    } else if (numDecPlaces > 0) {\n        var scale = DD.TEN.pow(numDecPlaces);\n        val2 = val.divide(scale);\n    } else if (numDecPlaces < 0) {\n        var scale$1 = DD.TEN.pow(-numDecPlaces);\n        val2 = val.multiply(scale$1);\n    }\n    if (isNegative) {\n        return val2.negate();\n    }\n    return val2;\n};\nDD.createNaN = function createNaN() {\n    return new DD(Double.NaN, Double.NaN);\n};\nDD.copy = function copy(dd) {\n    return new DD(dd);\n};\nDD.magnitude = function magnitude(x) {\n    var xAbs = Math.abs(x);\n    var xLog10 = Math.log(xAbs) / Math.log(10);\n    var xMag = Math.trunc(Math.floor(xLog10));\n    var xApprox = Math.pow(10, xMag);\n    if (xApprox * 10 <= xAbs) {\n        xMag += 1;\n    }\n    return xMag;\n};\nDD.stringOfChar = function stringOfChar(ch, len) {\n    var buf = new StringBuffer();\n    for(var i = 0; i < len; i++){\n        buf.append(ch);\n    }\n    return buf.toString();\n};\nstaticAccessors$7.PI.get = function() {\n    return new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\n};\nstaticAccessors$7.TWO_PI.get = function() {\n    return new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\n};\nstaticAccessors$7.PI_2.get = function() {\n    return new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\n};\nstaticAccessors$7.E.get = function() {\n    return new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\n};\nstaticAccessors$7.NaN.get = function() {\n    return new DD(Double.NaN, Double.NaN);\n};\nstaticAccessors$7.EPS.get = function() {\n    return 1.23259516440783e-32;\n};\nstaticAccessors$7.SPLIT.get = function() {\n    return 134217729.0;\n};\nstaticAccessors$7.MAX_PRINT_DIGITS.get = function() {\n    return 32;\n};\nstaticAccessors$7.TEN.get = function() {\n    return DD.valueOf(10.0);\n};\nstaticAccessors$7.ONE.get = function() {\n    return DD.valueOf(1.0);\n};\nstaticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function() {\n    return \"E\";\n};\nstaticAccessors$7.SCI_NOT_ZERO.get = function() {\n    return \"0.0E0\";\n};\nObject.defineProperties(DD, staticAccessors$7);\nvar CGAlgorithmsDD = function CGAlgorithmsDD() {};\nvar staticAccessors$6 = {\n    DP_SAFE_EPSILON: {\n        configurable: true\n    }\n};\nCGAlgorithmsDD.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCGAlgorithmsDD.prototype.getClass = function getClass() {\n    return CGAlgorithmsDD;\n};\nCGAlgorithmsDD.orientationIndex = function orientationIndex(p1, p2, q) {\n    var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n    if (index <= 1) {\n        return index;\n    }\n    var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n    var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n    var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n    var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n    return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n};\nCGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {\n    var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n    return det.signum();\n};\nCGAlgorithmsDD.intersection = function intersection(p1, p2, q1, q2) {\n    var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n    var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n    var denom = denom1.subtract(denom2);\n    var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n    var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n    var numx = numx1.subtract(numx2);\n    var fracP = numx.selfDivide(denom).doubleValue();\n    var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n    var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n    var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n    var numy = numy1.subtract(numy2);\n    var fracQ = numy.selfDivide(denom).doubleValue();\n    var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n    return new Coordinate(x, y);\n};\nCGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter(pa, pb, pc) {\n    var detsum = null;\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var det = detleft - detright;\n    if (detleft > 0.0) {\n        if (detright <= 0.0) {\n            return CGAlgorithmsDD.signum(det);\n        } else {\n            detsum = detleft + detright;\n        }\n    } else if (detleft < 0.0) {\n        if (detright >= 0.0) {\n            return CGAlgorithmsDD.signum(det);\n        } else {\n            detsum = -detleft - detright;\n        }\n    } else {\n        return CGAlgorithmsDD.signum(det);\n    }\n    var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return CGAlgorithmsDD.signum(det);\n    }\n    return 2;\n};\nCGAlgorithmsDD.signum = function signum(x) {\n    if (x > 0) {\n        return 1;\n    }\n    if (x < 0) {\n        return -1;\n    }\n    return 0;\n};\nstaticAccessors$6.DP_SAFE_EPSILON.get = function() {\n    return 1e-15;\n};\nObject.defineProperties(CGAlgorithmsDD, staticAccessors$6);\nvar CoordinateSequence = function CoordinateSequence() {};\nvar staticAccessors$8 = {\n    X: {\n        configurable: true\n    },\n    Y: {\n        configurable: true\n    },\n    Z: {\n        configurable: true\n    },\n    M: {\n        configurable: true\n    }\n};\nstaticAccessors$8.X.get = function() {\n    return 0;\n};\nstaticAccessors$8.Y.get = function() {\n    return 1;\n};\nstaticAccessors$8.Z.get = function() {\n    return 2;\n};\nstaticAccessors$8.M.get = function() {\n    return 3;\n};\nCoordinateSequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) {};\nCoordinateSequence.prototype.size = function size() {};\nCoordinateSequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) {};\nCoordinateSequence.prototype.getCoordinate = function getCoordinate() {};\nCoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {};\nCoordinateSequence.prototype.getDimension = function getDimension() {};\nCoordinateSequence.prototype.getX = function getX(index) {};\nCoordinateSequence.prototype.clone = function clone() {};\nCoordinateSequence.prototype.expandEnvelope = function expandEnvelope(env) {};\nCoordinateSequence.prototype.copy = function copy() {};\nCoordinateSequence.prototype.getY = function getY(index) {};\nCoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray() {};\nCoordinateSequence.prototype.interfaces_ = function interfaces_() {\n    return [\n        Clonable\n    ];\n};\nCoordinateSequence.prototype.getClass = function getClass() {\n    return CoordinateSequence;\n};\nObject.defineProperties(CoordinateSequence, staticAccessors$8);\nvar Exception = function Exception() {};\nvar NotRepresentableException = function(Exception$$1) {\n    function NotRepresentableException() {\n        Exception$$1.call(this, \"Projective point not representable on the Cartesian plane.\");\n    }\n    if (Exception$$1) NotRepresentableException.__proto__ = Exception$$1;\n    NotRepresentableException.prototype = Object.create(Exception$$1 && Exception$$1.prototype);\n    NotRepresentableException.prototype.constructor = NotRepresentableException;\n    NotRepresentableException.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    NotRepresentableException.prototype.getClass = function getClass() {\n        return NotRepresentableException;\n    };\n    return NotRepresentableException;\n}(Exception);\nvar System = function System() {};\nSystem.arraycopy = function arraycopy(src, srcPos, dest, destPos, len) {\n    var c = 0;\n    for(var i = srcPos; i < srcPos + len; i++){\n        dest[destPos + c] = src[i];\n        c++;\n    }\n};\nSystem.getProperty = function getProperty(name) {\n    return ({\n        \"line.separator\": \"\\n\"\n    })[name];\n};\nvar HCoordinate = function HCoordinate() {\n    this.x = null;\n    this.y = null;\n    this.w = null;\n    if (arguments.length === 0) {\n        this.x = 0.0;\n        this.y = 0.0;\n        this.w = 1.0;\n    } else if (arguments.length === 1) {\n        var p = arguments[0];\n        this.x = p.x;\n        this.y = p.y;\n        this.w = 1.0;\n    } else if (arguments.length === 2) {\n        if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n            var _x = arguments[0];\n            var _y = arguments[1];\n            this.x = _x;\n            this.y = _y;\n            this.w = 1.0;\n        } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n            var p1 = arguments[0];\n            var p2 = arguments[1];\n            this.x = p1.y * p2.w - p2.y * p1.w;\n            this.y = p2.x * p1.w - p1.x * p2.w;\n            this.w = p1.x * p2.y - p2.x * p1.y;\n        } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n            var p1$1 = arguments[0];\n            var p2$1 = arguments[1];\n            this.x = p1$1.y - p2$1.y;\n            this.y = p2$1.x - p1$1.x;\n            this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;\n        }\n    } else if (arguments.length === 3) {\n        var _x$1 = arguments[0];\n        var _y$1 = arguments[1];\n        var _w = arguments[2];\n        this.x = _x$1;\n        this.y = _y$1;\n        this.w = _w;\n    } else if (arguments.length === 4) {\n        var p1$2 = arguments[0];\n        var p2$2 = arguments[1];\n        var q1 = arguments[2];\n        var q2 = arguments[3];\n        var px = p1$2.y - p2$2.y;\n        var py = p2$2.x - p1$2.x;\n        var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;\n        var qx = q1.y - q2.y;\n        var qy = q2.x - q1.x;\n        var qw = q1.x * q2.y - q2.x * q1.y;\n        this.x = py * qw - qy * pw;\n        this.y = qx * pw - px * qw;\n        this.w = px * qy - qx * py;\n    }\n};\nHCoordinate.prototype.getY = function getY() {\n    var a = this.y / this.w;\n    if (Double.isNaN(a) || Double.isInfinite(a)) {\n        throw new NotRepresentableException();\n    }\n    return a;\n};\nHCoordinate.prototype.getX = function getX() {\n    var a = this.x / this.w;\n    if (Double.isNaN(a) || Double.isInfinite(a)) {\n        throw new NotRepresentableException();\n    }\n    return a;\n};\nHCoordinate.prototype.getCoordinate = function getCoordinate() {\n    var p = new Coordinate();\n    p.x = this.getX();\n    p.y = this.getY();\n    return p;\n};\nHCoordinate.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nHCoordinate.prototype.getClass = function getClass() {\n    return HCoordinate;\n};\nHCoordinate.intersection = function intersection(p1, p2, q1, q2) {\n    var px = p1.y - p2.y;\n    var py = p2.x - p1.x;\n    var pw = p1.x * p2.y - p2.x * p1.y;\n    var qx = q1.y - q2.y;\n    var qy = q2.x - q1.x;\n    var qw = q1.x * q2.y - q2.x * q1.y;\n    var x = py * qw - qy * pw;\n    var y = qx * pw - px * qw;\n    var w = px * qy - qx * py;\n    var xInt = x / w;\n    var yInt = y / w;\n    if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {\n        throw new NotRepresentableException();\n    }\n    return new Coordinate(xInt, yInt);\n};\nvar Envelope = function Envelope() {\n    this._minx = null;\n    this._maxx = null;\n    this._miny = null;\n    this._maxy = null;\n    if (arguments.length === 0) {\n        this.init();\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            this.init(p.x, p.x, p.y, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n            var env = arguments[0];\n            this.init(env);\n        }\n    } else if (arguments.length === 2) {\n        var p1 = arguments[0];\n        var p2 = arguments[1];\n        this.init(p1.x, p2.x, p1.y, p2.y);\n    } else if (arguments.length === 4) {\n        var x1 = arguments[0];\n        var x2 = arguments[1];\n        var y1 = arguments[2];\n        var y2 = arguments[3];\n        this.init(x1, x2, y1, y2);\n    }\n};\nvar staticAccessors$9 = {\n    serialVersionUID: {\n        configurable: true\n    }\n};\nEnvelope.prototype.getArea = function getArea() {\n    return this.getWidth() * this.getHeight();\n};\nEnvelope.prototype.equals = function equals(other) {\n    if (!(other instanceof Envelope)) {\n        return false;\n    }\n    var otherEnvelope = other;\n    if (this.isNull()) {\n        return otherEnvelope.isNull();\n    }\n    return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n};\nEnvelope.prototype.intersection = function intersection(env) {\n    if (this.isNull() || env.isNull() || !this.intersects(env)) {\n        return new Envelope();\n    }\n    var intMinX = this._minx > env._minx ? this._minx : env._minx;\n    var intMinY = this._miny > env._miny ? this._miny : env._miny;\n    var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n    var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n    return new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n};\nEnvelope.prototype.isNull = function isNull() {\n    return this._maxx < this._minx;\n};\nEnvelope.prototype.getMaxX = function getMaxX() {\n    return this._maxx;\n};\nEnvelope.prototype.covers = function covers() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            return this.covers(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n            var other = arguments[0];\n            if (this.isNull() || other.isNull()) {\n                return false;\n            }\n            return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n        }\n    } else if (arguments.length === 2) {\n        var x = arguments[0];\n        var y = arguments[1];\n        if (this.isNull()) {\n            return false;\n        }\n        return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n    }\n};\nEnvelope.prototype.intersects = function intersects() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n            var other = arguments[0];\n            if (this.isNull() || other.isNull()) {\n                return false;\n            }\n            return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n        } else if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            return this.intersects(p.x, p.y);\n        }\n    } else if (arguments.length === 2) {\n        var x = arguments[0];\n        var y = arguments[1];\n        if (this.isNull()) {\n            return false;\n        }\n        return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n    }\n};\nEnvelope.prototype.getMinY = function getMinY() {\n    return this._miny;\n};\nEnvelope.prototype.getMinX = function getMinX() {\n    return this._minx;\n};\nEnvelope.prototype.expandToInclude = function expandToInclude() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            this.expandToInclude(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n            var other = arguments[0];\n            if (other.isNull()) {\n                return null;\n            }\n            if (this.isNull()) {\n                this._minx = other.getMinX();\n                this._maxx = other.getMaxX();\n                this._miny = other.getMinY();\n                this._maxy = other.getMaxY();\n            } else {\n                if (other._minx < this._minx) {\n                    this._minx = other._minx;\n                }\n                if (other._maxx > this._maxx) {\n                    this._maxx = other._maxx;\n                }\n                if (other._miny < this._miny) {\n                    this._miny = other._miny;\n                }\n                if (other._maxy > this._maxy) {\n                    this._maxy = other._maxy;\n                }\n            }\n        }\n    } else if (arguments.length === 2) {\n        var x = arguments[0];\n        var y = arguments[1];\n        if (this.isNull()) {\n            this._minx = x;\n            this._maxx = x;\n            this._miny = y;\n            this._maxy = y;\n        } else {\n            if (x < this._minx) {\n                this._minx = x;\n            }\n            if (x > this._maxx) {\n                this._maxx = x;\n            }\n            if (y < this._miny) {\n                this._miny = y;\n            }\n            if (y > this._maxy) {\n                this._maxy = y;\n            }\n        }\n    }\n};\nEnvelope.prototype.minExtent = function minExtent() {\n    if (this.isNull()) {\n        return 0.0;\n    }\n    var w = this.getWidth();\n    var h = this.getHeight();\n    if (w < h) {\n        return w;\n    }\n    return h;\n};\nEnvelope.prototype.getWidth = function getWidth() {\n    if (this.isNull()) {\n        return 0;\n    }\n    return this._maxx - this._minx;\n};\nEnvelope.prototype.compareTo = function compareTo(o) {\n    var env = o;\n    if (this.isNull()) {\n        if (env.isNull()) {\n            return 0;\n        }\n        return -1;\n    } else {\n        if (env.isNull()) {\n            return 1;\n        }\n    }\n    if (this._minx < env._minx) {\n        return -1;\n    }\n    if (this._minx > env._minx) {\n        return 1;\n    }\n    if (this._miny < env._miny) {\n        return -1;\n    }\n    if (this._miny > env._miny) {\n        return 1;\n    }\n    if (this._maxx < env._maxx) {\n        return -1;\n    }\n    if (this._maxx > env._maxx) {\n        return 1;\n    }\n    if (this._maxy < env._maxy) {\n        return -1;\n    }\n    if (this._maxy > env._maxy) {\n        return 1;\n    }\n    return 0;\n};\nEnvelope.prototype.translate = function translate(transX, transY) {\n    if (this.isNull()) {\n        return null;\n    }\n    this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n};\nEnvelope.prototype.toString = function toString() {\n    return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n};\nEnvelope.prototype.setToNull = function setToNull() {\n    this._minx = 0;\n    this._maxx = -1;\n    this._miny = 0;\n    this._maxy = -1;\n};\nEnvelope.prototype.getHeight = function getHeight() {\n    if (this.isNull()) {\n        return 0;\n    }\n    return this._maxy - this._miny;\n};\nEnvelope.prototype.maxExtent = function maxExtent() {\n    if (this.isNull()) {\n        return 0.0;\n    }\n    var w = this.getWidth();\n    var h = this.getHeight();\n    if (w > h) {\n        return w;\n    }\n    return h;\n};\nEnvelope.prototype.expandBy = function expandBy() {\n    if (arguments.length === 1) {\n        var distance = arguments[0];\n        this.expandBy(distance, distance);\n    } else if (arguments.length === 2) {\n        var deltaX = arguments[0];\n        var deltaY = arguments[1];\n        if (this.isNull()) {\n            return null;\n        }\n        this._minx -= deltaX;\n        this._maxx += deltaX;\n        this._miny -= deltaY;\n        this._maxy += deltaY;\n        if (this._minx > this._maxx || this._miny > this._maxy) {\n            this.setToNull();\n        }\n    }\n};\nEnvelope.prototype.contains = function contains() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n            var other = arguments[0];\n            return this.covers(other);\n        } else if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            return this.covers(p);\n        }\n    } else if (arguments.length === 2) {\n        var x = arguments[0];\n        var y = arguments[1];\n        return this.covers(x, y);\n    }\n};\nEnvelope.prototype.centre = function centre() {\n    if (this.isNull()) {\n        return null;\n    }\n    return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n};\nEnvelope.prototype.init = function init() {\n    if (arguments.length === 0) {\n        this.setToNull();\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n            var p = arguments[0];\n            this.init(p.x, p.x, p.y, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n            var env = arguments[0];\n            this._minx = env._minx;\n            this._maxx = env._maxx;\n            this._miny = env._miny;\n            this._maxy = env._maxy;\n        }\n    } else if (arguments.length === 2) {\n        var p1 = arguments[0];\n        var p2 = arguments[1];\n        this.init(p1.x, p2.x, p1.y, p2.y);\n    } else if (arguments.length === 4) {\n        var x1 = arguments[0];\n        var x2 = arguments[1];\n        var y1 = arguments[2];\n        var y2 = arguments[3];\n        if (x1 < x2) {\n            this._minx = x1;\n            this._maxx = x2;\n        } else {\n            this._minx = x2;\n            this._maxx = x1;\n        }\n        if (y1 < y2) {\n            this._miny = y1;\n            this._maxy = y2;\n        } else {\n            this._miny = y2;\n            this._maxy = y1;\n        }\n    }\n};\nEnvelope.prototype.getMaxY = function getMaxY() {\n    return this._maxy;\n};\nEnvelope.prototype.distance = function distance(env) {\n    if (this.intersects(env)) {\n        return 0;\n    }\n    var dx = 0.0;\n    if (this._maxx < env._minx) {\n        dx = env._minx - this._maxx;\n    } else if (this._minx > env._maxx) {\n        dx = this._minx - env._maxx;\n    }\n    var dy = 0.0;\n    if (this._maxy < env._miny) {\n        dy = env._miny - this._maxy;\n    } else if (this._miny > env._maxy) {\n        dy = this._miny - env._maxy;\n    }\n    if (dx === 0.0) {\n        return dy;\n    }\n    if (dy === 0.0) {\n        return dx;\n    }\n    return Math.sqrt(dx * dx + dy * dy);\n};\nEnvelope.prototype.hashCode = function hashCode() {\n    var result = 17;\n    result = 37 * result + Coordinate.hashCode(this._minx);\n    result = 37 * result + Coordinate.hashCode(this._maxx);\n    result = 37 * result + Coordinate.hashCode(this._miny);\n    result = 37 * result + Coordinate.hashCode(this._maxy);\n    return result;\n};\nEnvelope.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable,\n        Serializable\n    ];\n};\nEnvelope.prototype.getClass = function getClass() {\n    return Envelope;\n};\nEnvelope.intersects = function intersects() {\n    if (arguments.length === 3) {\n        var p1 = arguments[0];\n        var p2 = arguments[1];\n        var q = arguments[2];\n        if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {\n            return true;\n        }\n        return false;\n    } else if (arguments.length === 4) {\n        var p1$1 = arguments[0];\n        var p2$1 = arguments[1];\n        var q1 = arguments[2];\n        var q2 = arguments[3];\n        var minq = Math.min(q1.x, q2.x);\n        var maxq = Math.max(q1.x, q2.x);\n        var minp = Math.min(p1$1.x, p2$1.x);\n        var maxp = Math.max(p1$1.x, p2$1.x);\n        if (minp > maxq) {\n            return false;\n        }\n        if (maxp < minq) {\n            return false;\n        }\n        minq = Math.min(q1.y, q2.y);\n        maxq = Math.max(q1.y, q2.y);\n        minp = Math.min(p1$1.y, p2$1.y);\n        maxp = Math.max(p1$1.y, p2$1.y);\n        if (minp > maxq) {\n            return false;\n        }\n        if (maxp < minq) {\n            return false;\n        }\n        return true;\n    }\n};\nstaticAccessors$9.serialVersionUID.get = function() {\n    return 5873921885273102420;\n};\nObject.defineProperties(Envelope, staticAccessors$9);\nvar regExes = {\n    \"typeStr\": /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    \"emptyTypeStr\": /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    \"spaces\": /\\s+/,\n    \"parenComma\": /\\)\\s*,\\s*\\(/,\n    \"doubleParenComma\": /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    \"trimParens\": /^\\s*\\(?(.*?)\\)?\\s*$/\n};\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */ /** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */ var WKTParser = function WKTParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n * and GEOMETRYCOLLECTION.\n *\n * @param {String} wkt A WKT string.\n * @return {Geometry} A geometry instance.\n * @private\n */ WKTParser.prototype.read = function read(wkt) {\n    var geometry, type, str;\n    wkt = wkt.replace(/[\\n\\r]/g, \" \");\n    var matches = regExes.typeStr.exec(wkt);\n    if (wkt.search(\"EMPTY\") !== -1) {\n        matches = regExes.emptyTypeStr.exec(wkt);\n        matches[2] = undefined;\n    }\n    if (matches) {\n        type = matches[1].toLowerCase();\n        str = matches[2];\n        if (parse$1[type]) {\n            geometry = parse$1[type].apply(this, [\n                str\n            ]);\n        }\n    }\n    if (geometry === undefined) {\n        throw new Error(\"Could not parse WKT \" + wkt);\n    }\n    return geometry;\n};\n/**\n * Serialize a geometry into a WKT string.\n *\n * @param {Geometry} geometry A feature or array of features.\n * @return {String} The WKT string representation of the input geometries.\n * @private\n */ WKTParser.prototype.write = function write(geometry) {\n    return this.extractGeometry(geometry);\n};\n/**\n * Entry point to construct the WKT for a single Geometry object.\n *\n * @param {Geometry} geometry\n * @return {String} A WKT string of representing the geometry.\n * @private\n */ WKTParser.prototype.extractGeometry = function extractGeometry(geometry) {\n    var type = geometry.getGeometryType().toLowerCase();\n    if (!extract$1[type]) {\n        return null;\n    }\n    var wktType = type.toUpperCase();\n    var data;\n    if (geometry.isEmpty()) {\n        data = wktType + \" EMPTY\";\n    } else {\n        data = wktType + \"(\" + extract$1[type].apply(this, [\n            geometry\n        ]) + \")\";\n    }\n    return data;\n};\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */ var extract$1 = {\n    coordinate: function coordinate(coordinate$1) {\n        return coordinate$1.x + \" \" + coordinate$1.y;\n    },\n    /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */ point: function point(point$1) {\n        return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0]);\n    },\n    /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */ multipoint: function multipoint(multipoint$1) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = multipoint$1._geometries.length; i < len; ++i){\n            array.push(\"(\" + extract$1.point.apply(this$1, [\n                multipoint$1._geometries[i]\n            ]) + \")\");\n        }\n        return array.join(\",\");\n    },\n    /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */ linestring: function linestring(linestring$1) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i){\n            array.push(extract$1.coordinate.apply(this$1, [\n                linestring$1._points._coordinates[i]\n            ]));\n        }\n        return array.join(\",\");\n    },\n    linearring: function linearring(linearring$1) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i){\n            array.push(extract$1.coordinate.apply(this$1, [\n                linearring$1._points._coordinates[i]\n            ]));\n        }\n        return array.join(\",\");\n    },\n    /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */ multilinestring: function multilinestring(multilinestring$1) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = multilinestring$1._geometries.length; i < len; ++i){\n            array.push(\"(\" + extract$1.linestring.apply(this$1, [\n                multilinestring$1._geometries[i]\n            ]) + \")\");\n        }\n        return array.join(\",\");\n    },\n    /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */ polygon: function polygon(polygon$1) {\n        var this$1 = this;\n        var array = [];\n        array.push(\"(\" + extract$1.linestring.apply(this, [\n            polygon$1._shell\n        ]) + \")\");\n        for(var i = 0, len = polygon$1._holes.length; i < len; ++i){\n            array.push(\"(\" + extract$1.linestring.apply(this$1, [\n                polygon$1._holes[i]\n            ]) + \")\");\n        }\n        return array.join(\",\");\n    },\n    /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */ multipolygon: function multipolygon(multipolygon$1) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = multipolygon$1._geometries.length; i < len; ++i){\n            array.push(\"(\" + extract$1.polygon.apply(this$1, [\n                multipolygon$1._geometries[i]\n            ]) + \")\");\n        }\n        return array.join(\",\");\n    },\n    /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */ geometrycollection: function geometrycollection(collection) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = collection._geometries.length; i < len; ++i){\n            array.push(this$1.extractGeometry(collection._geometries[i]));\n        }\n        return array.join(\",\");\n    }\n};\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */ var parse$1 = {\n    /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */ point: function point(str) {\n        if (str === undefined) {\n            return this.geometryFactory.createPoint();\n        }\n        var coords = str.trim().split(regExes.spaces);\n        return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    },\n    /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */ multipoint: function multipoint(str) {\n        var this$1 = this;\n        if (str === undefined) {\n            return this.geometryFactory.createMultiPoint();\n        }\n        var point;\n        var points = str.trim().split(\",\");\n        var components = [];\n        for(var i = 0, len = points.length; i < len; ++i){\n            point = points[i].replace(regExes.trimParens, \"$1\");\n            components.push(parse$1.point.apply(this$1, [\n                point\n            ]));\n        }\n        return this.geometryFactory.createMultiPoint(components);\n    },\n    /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */ linestring: function linestring(str) {\n        if (str === undefined) {\n            return this.geometryFactory.createLineString();\n        }\n        var points = str.trim().split(\",\");\n        var components = [];\n        var coords;\n        for(var i = 0, len = points.length; i < len; ++i){\n            coords = points[i].trim().split(regExes.spaces);\n            components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n        }\n        return this.geometryFactory.createLineString(components);\n    },\n    /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */ linearring: function linearring(str) {\n        if (str === undefined) {\n            return this.geometryFactory.createLinearRing();\n        }\n        var points = str.trim().split(\",\");\n        var components = [];\n        var coords;\n        for(var i = 0, len = points.length; i < len; ++i){\n            coords = points[i].trim().split(regExes.spaces);\n            components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n        }\n        return this.geometryFactory.createLinearRing(components);\n    },\n    /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */ multilinestring: function multilinestring(str) {\n        var this$1 = this;\n        if (str === undefined) {\n            return this.geometryFactory.createMultiLineString();\n        }\n        var line;\n        var lines = str.trim().split(regExes.parenComma);\n        var components = [];\n        for(var i = 0, len = lines.length; i < len; ++i){\n            line = lines[i].replace(regExes.trimParens, \"$1\");\n            components.push(parse$1.linestring.apply(this$1, [\n                line\n            ]));\n        }\n        return this.geometryFactory.createMultiLineString(components);\n    },\n    /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */ polygon: function polygon(str) {\n        var this$1 = this;\n        if (str === undefined) {\n            return this.geometryFactory.createPolygon();\n        }\n        var ring, linestring, linearring;\n        var rings = str.trim().split(regExes.parenComma);\n        var shell;\n        var holes = [];\n        for(var i = 0, len = rings.length; i < len; ++i){\n            ring = rings[i].replace(regExes.trimParens, \"$1\");\n            linestring = parse$1.linestring.apply(this$1, [\n                ring\n            ]);\n            linearring = this$1.geometryFactory.createLinearRing(linestring._points);\n            if (i === 0) {\n                shell = linearring;\n            } else {\n                holes.push(linearring);\n            }\n        }\n        return this.geometryFactory.createPolygon(shell, holes);\n    },\n    /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */ multipolygon: function multipolygon(str) {\n        var this$1 = this;\n        if (str === undefined) {\n            return this.geometryFactory.createMultiPolygon();\n        }\n        var polygon;\n        var polygons = str.trim().split(regExes.doubleParenComma);\n        var components = [];\n        for(var i = 0, len = polygons.length; i < len; ++i){\n            polygon = polygons[i].replace(regExes.trimParens, \"$1\");\n            components.push(parse$1.polygon.apply(this$1, [\n                polygon\n            ]));\n        }\n        return this.geometryFactory.createMultiPolygon(components);\n    },\n    /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */ geometrycollection: function geometrycollection(str) {\n        var this$1 = this;\n        if (str === undefined) {\n            return this.geometryFactory.createGeometryCollection();\n        }\n        // separate components of the collection with |\n        str = str.replace(/,\\s*([A-Za-z])/g, \"|$1\");\n        var wktArray = str.trim().split(\"|\");\n        var components = [];\n        for(var i = 0, len = wktArray.length; i < len; ++i){\n            components.push(this$1.read(wktArray[i]));\n        }\n        return this.geometryFactory.createGeometryCollection(components);\n    }\n};\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */ /**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */ var WKTWriter = function WKTWriter(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory);\n};\n/**\n * Converts a <code>Geometry</code> to its Well-known Text representation.\n *\n * @param {Geometry} geometry a <code>Geometry</code> to process.\n * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n *       Features Specification).\n * @memberof WKTWriter\n */ WKTWriter.prototype.write = function write(geometry) {\n    return this.parser.write(geometry);\n};\n/**\n * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n * {@link Coordinate}s.\n *\n * @param p0 the first coordinate.\n * @param p1 the second coordinate.\n *\n * @return the WKT.\n * @private\n */ WKTWriter.toLineString = function toLineString(p0, p1) {\n    if (arguments.length !== 2) {\n        throw new Error(\"Not implemented\");\n    }\n    return \"LINESTRING ( \" + p0.x + \" \" + p0.y + \", \" + p1.x + \" \" + p1.y + \" )\";\n};\nvar RuntimeException = function(Error1) {\n    function RuntimeException(message) {\n        Error1.call(this, message);\n        this.name = \"RuntimeException\";\n        this.message = message;\n        this.stack = new Error1().stack;\n    }\n    if (Error1) RuntimeException.__proto__ = Error1;\n    RuntimeException.prototype = Object.create(Error1 && Error1.prototype);\n    RuntimeException.prototype.constructor = RuntimeException;\n    return RuntimeException;\n}(Error);\nvar AssertionFailedException = function(RuntimeException$$1) {\n    function AssertionFailedException() {\n        RuntimeException$$1.call(this);\n        if (arguments.length === 0) {\n            RuntimeException$$1.call(this);\n        } else if (arguments.length === 1) {\n            var message = arguments[0];\n            RuntimeException$$1.call(this, message);\n        }\n    }\n    if (RuntimeException$$1) AssertionFailedException.__proto__ = RuntimeException$$1;\n    AssertionFailedException.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);\n    AssertionFailedException.prototype.constructor = AssertionFailedException;\n    AssertionFailedException.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    AssertionFailedException.prototype.getClass = function getClass() {\n        return AssertionFailedException;\n    };\n    return AssertionFailedException;\n}(RuntimeException);\nvar Assert = function Assert() {};\nAssert.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nAssert.prototype.getClass = function getClass() {\n    return Assert;\n};\nAssert.shouldNeverReachHere = function shouldNeverReachHere() {\n    if (arguments.length === 0) {\n        Assert.shouldNeverReachHere(null);\n    } else if (arguments.length === 1) {\n        var message = arguments[0];\n        throw new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n    }\n};\nAssert.isTrue = function isTrue() {\n    var assertion;\n    var message;\n    if (arguments.length === 1) {\n        assertion = arguments[0];\n        Assert.isTrue(assertion, null);\n    } else if (arguments.length === 2) {\n        assertion = arguments[0];\n        message = arguments[1];\n        if (!assertion) {\n            if (message === null) {\n                throw new AssertionFailedException();\n            } else {\n                throw new AssertionFailedException(message);\n            }\n        }\n    }\n};\nAssert.equals = function equals() {\n    var expectedValue;\n    var actualValue;\n    var message;\n    if (arguments.length === 2) {\n        expectedValue = arguments[0];\n        actualValue = arguments[1];\n        Assert.equals(expectedValue, actualValue, null);\n    } else if (arguments.length === 3) {\n        expectedValue = arguments[0];\n        actualValue = arguments[1];\n        message = arguments[2];\n        if (!actualValue.equals(expectedValue)) {\n            throw new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n        }\n    }\n};\nvar LineIntersector = function LineIntersector() {\n    this._result = null;\n    this._inputLines = Array(2).fill().map(function() {\n        return Array(2);\n    });\n    this._intPt = new Array(2).fill(null);\n    this._intLineIndex = null;\n    this._isProper = null;\n    this._pa = null;\n    this._pb = null;\n    this._precisionModel = null;\n    this._intPt[0] = new Coordinate();\n    this._intPt[1] = new Coordinate();\n    this._pa = this._intPt[0];\n    this._pb = this._intPt[1];\n    this._result = 0;\n};\nvar staticAccessors$10 = {\n    DONT_INTERSECT: {\n        configurable: true\n    },\n    DO_INTERSECT: {\n        configurable: true\n    },\n    COLLINEAR: {\n        configurable: true\n    },\n    NO_INTERSECTION: {\n        configurable: true\n    },\n    POINT_INTERSECTION: {\n        configurable: true\n    },\n    COLLINEAR_INTERSECTION: {\n        configurable: true\n    }\n};\nLineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex();\n    return this._intLineIndex[segmentIndex][intIndex];\n};\nLineIntersector.prototype.getTopologySummary = function getTopologySummary() {\n    var catBuf = new StringBuffer();\n    if (this.isEndPoint()) {\n        catBuf.append(\" endpoint\");\n    }\n    if (this._isProper) {\n        catBuf.append(\" proper\");\n    }\n    if (this.isCollinear()) {\n        catBuf.append(\" collinear\");\n    }\n    return catBuf.toString();\n};\nLineIntersector.prototype.computeIntersection = function computeIntersection(p1, p2, p3, p4) {\n    this._inputLines[0][0] = p1;\n    this._inputLines[0][1] = p2;\n    this._inputLines[1][0] = p3;\n    this._inputLines[1][1] = p4;\n    this._result = this.computeIntersect(p1, p2, p3, p4);\n};\nLineIntersector.prototype.getIntersectionNum = function getIntersectionNum() {\n    return this._result;\n};\nLineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex() {\n    if (arguments.length === 0) {\n        if (this._intLineIndex === null) {\n            this._intLineIndex = Array(2).fill().map(function() {\n                return Array(2);\n            });\n            this.computeIntLineIndex(0);\n            this.computeIntLineIndex(1);\n        }\n    } else if (arguments.length === 1) {\n        var segmentIndex = arguments[0];\n        var dist0 = this.getEdgeDistance(segmentIndex, 0);\n        var dist1 = this.getEdgeDistance(segmentIndex, 1);\n        if (dist0 > dist1) {\n            this._intLineIndex[segmentIndex][0] = 0;\n            this._intLineIndex[segmentIndex][1] = 1;\n        } else {\n            this._intLineIndex[segmentIndex][0] = 1;\n            this._intLineIndex[segmentIndex][1] = 0;\n        }\n    }\n};\nLineIntersector.prototype.isProper = function isProper() {\n    return this.hasIntersection() && this._isProper;\n};\nLineIntersector.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel;\n};\nLineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        if (this.isInteriorIntersection(0)) {\n            return true;\n        }\n        if (this.isInteriorIntersection(1)) {\n            return true;\n        }\n        return false;\n    } else if (arguments.length === 1) {\n        var inputLineIndex = arguments[0];\n        for(var i = 0; i < this._result; i++){\n            if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\nLineIntersector.prototype.getIntersection = function getIntersection(intIndex) {\n    return this._intPt[intIndex];\n};\nLineIntersector.prototype.isEndPoint = function isEndPoint() {\n    return this.hasIntersection() && !this._isProper;\n};\nLineIntersector.prototype.hasIntersection = function hasIntersection() {\n    return this._result !== LineIntersector.NO_INTERSECTION;\n};\nLineIntersector.prototype.getEdgeDistance = function getEdgeDistance(segmentIndex, intIndex) {\n    var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n    return dist;\n};\nLineIntersector.prototype.isCollinear = function isCollinear() {\n    return this._result === LineIntersector.COLLINEAR_INTERSECTION;\n};\nLineIntersector.prototype.toString = function toString() {\n    return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n};\nLineIntersector.prototype.getEndpoint = function getEndpoint(segmentIndex, ptIndex) {\n    return this._inputLines[segmentIndex][ptIndex];\n};\nLineIntersector.prototype.isIntersection = function isIntersection(pt) {\n    var this$1 = this;\n    for(var i = 0; i < this._result; i++){\n        if (this$1._intPt[i].equals2D(pt)) {\n            return true;\n        }\n    }\n    return false;\n};\nLineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex();\n    return this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n};\nLineIntersector.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLineIntersector.prototype.getClass = function getClass() {\n    return LineIntersector;\n};\nLineIntersector.computeEdgeDistance = function computeEdgeDistance(p, p0, p1) {\n    var dx = Math.abs(p1.x - p0.x);\n    var dy = Math.abs(p1.y - p0.y);\n    var dist = -1.0;\n    if (p.equals(p0)) {\n        dist = 0.0;\n    } else if (p.equals(p1)) {\n        if (dx > dy) {\n            dist = dx;\n        } else {\n            dist = dy;\n        }\n    } else {\n        var pdx = Math.abs(p.x - p0.x);\n        var pdy = Math.abs(p.y - p0.y);\n        if (dx > dy) {\n            dist = pdx;\n        } else {\n            dist = pdy;\n        }\n        if (dist === 0.0 && !p.equals(p0)) {\n            dist = Math.max(pdx, pdy);\n        }\n    }\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n    return dist;\n};\nLineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance(p, p1, p2) {\n    var dx = p.x - p1.x;\n    var dy = p.y - p1.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n    return dist;\n};\nstaticAccessors$10.DONT_INTERSECT.get = function() {\n    return 0;\n};\nstaticAccessors$10.DO_INTERSECT.get = function() {\n    return 1;\n};\nstaticAccessors$10.COLLINEAR.get = function() {\n    return 2;\n};\nstaticAccessors$10.NO_INTERSECTION.get = function() {\n    return 0;\n};\nstaticAccessors$10.POINT_INTERSECTION.get = function() {\n    return 1;\n};\nstaticAccessors$10.COLLINEAR_INTERSECTION.get = function() {\n    return 2;\n};\nObject.defineProperties(LineIntersector, staticAccessors$10);\nvar RobustLineIntersector = function(LineIntersector$$1) {\n    function RobustLineIntersector() {\n        LineIntersector$$1.apply(this, arguments);\n    }\n    if (LineIntersector$$1) RobustLineIntersector.__proto__ = LineIntersector$$1;\n    RobustLineIntersector.prototype = Object.create(LineIntersector$$1 && LineIntersector$$1.prototype);\n    RobustLineIntersector.prototype.constructor = RobustLineIntersector;\n    RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes(intPt) {\n        var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n        var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n        return env0.contains(intPt) && env1.contains(intPt);\n    };\n    RobustLineIntersector.prototype.computeIntersection = function computeIntersection() {\n        if (arguments.length === 3) {\n            var p = arguments[0];\n            var p1 = arguments[1];\n            var p2 = arguments[2];\n            this._isProper = false;\n            if (Envelope.intersects(p1, p2, p)) {\n                if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n                    this._isProper = true;\n                    if (p.equals(p1) || p.equals(p2)) {\n                        this._isProper = false;\n                    }\n                    this._result = LineIntersector$$1.POINT_INTERSECTION;\n                    return null;\n                }\n            }\n            this._result = LineIntersector$$1.NO_INTERSECTION;\n        } else {\n            return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments);\n        }\n    };\n    RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum(n1, n2, n3, n4, normPt) {\n        normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n        normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n        n1.x -= normPt.x;\n        n1.y -= normPt.y;\n        n2.x -= normPt.x;\n        n2.y -= normPt.y;\n        n3.x -= normPt.x;\n        n3.y -= normPt.y;\n        n4.x -= normPt.x;\n        n4.y -= normPt.y;\n    };\n    RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection(p1, p2, q1, q2) {\n        var intPt = null;\n        try {\n            intPt = HCoordinate.intersection(p1, p2, q1, q2);\n        } catch (e) {\n            if (e instanceof NotRepresentableException) {\n                intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n            } else {\n                throw e;\n            }\n        } finally{}\n        return intPt;\n    };\n    RobustLineIntersector.prototype.intersection = function intersection(p1, p2, q1, q2) {\n        var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n        if (!this.isInSegmentEnvelopes(intPt)) {\n            intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n        }\n        if (this._precisionModel !== null) {\n            this._precisionModel.makePrecise(intPt);\n        }\n        return intPt;\n    };\n    RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue(x1, x2, x3, x4) {\n        var x = x1;\n        var xabs = Math.abs(x);\n        if (Math.abs(x2) < xabs) {\n            x = x2;\n            xabs = Math.abs(x2);\n        }\n        if (Math.abs(x3) < xabs) {\n            x = x3;\n            xabs = Math.abs(x3);\n        }\n        if (Math.abs(x4) < xabs) {\n            x = x4;\n        }\n        return x;\n    };\n    RobustLineIntersector.prototype.checkDD = function checkDD(p1, p2, q1, q2, intPt) {\n        var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n        var isIn = this.isInSegmentEnvelopes(intPtDD);\n        System.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n        if (intPt.distance(intPtDD) > 0.0001) {\n            System.out.println(\"Distance = \" + intPt.distance(intPtDD));\n        }\n    };\n    RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization(p1, p2, q1, q2) {\n        var n1 = new Coordinate(p1);\n        var n2 = new Coordinate(p2);\n        var n3 = new Coordinate(q1);\n        var n4 = new Coordinate(q2);\n        var normPt = new Coordinate();\n        this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n        var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n        intPt.x += normPt.x;\n        intPt.y += normPt.y;\n        return intPt;\n    };\n    RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection(p1, p2, q1, q2) {\n        var p1q1p2 = Envelope.intersects(p1, p2, q1);\n        var p1q2p2 = Envelope.intersects(p1, p2, q2);\n        var q1p1q2 = Envelope.intersects(q1, q2, p1);\n        var q1p2q2 = Envelope.intersects(q1, q2, p2);\n        if (p1q1p2 && p1q2p2) {\n            this._intPt[0] = q1;\n            this._intPt[1] = q2;\n            return LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        if (q1p1q2 && q1p2q2) {\n            this._intPt[0] = p1;\n            this._intPt[1] = p2;\n            return LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        if (p1q1p2 && q1p1q2) {\n            this._intPt[0] = q1;\n            this._intPt[1] = p1;\n            return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        if (p1q1p2 && q1p2q2) {\n            this._intPt[0] = q1;\n            this._intPt[1] = p2;\n            return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        if (p1q2p2 && q1p1q2) {\n            this._intPt[0] = q2;\n            this._intPt[1] = p1;\n            return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        if (p1q2p2 && q1p2q2) {\n            this._intPt[0] = q2;\n            this._intPt[1] = p2;\n            return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION;\n        }\n        return LineIntersector$$1.NO_INTERSECTION;\n    };\n    RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n        var minX0 = n00.x < n01.x ? n00.x : n01.x;\n        var minY0 = n00.y < n01.y ? n00.y : n01.y;\n        var maxX0 = n00.x > n01.x ? n00.x : n01.x;\n        var maxY0 = n00.y > n01.y ? n00.y : n01.y;\n        var minX1 = n10.x < n11.x ? n10.x : n11.x;\n        var minY1 = n10.y < n11.y ? n10.y : n11.y;\n        var maxX1 = n10.x > n11.x ? n10.x : n11.x;\n        var maxY1 = n10.y > n11.y ? n10.y : n11.y;\n        var intMinX = minX0 > minX1 ? minX0 : minX1;\n        var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n        var intMinY = minY0 > minY1 ? minY0 : minY1;\n        var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n        var intMidX = (intMinX + intMaxX) / 2.0;\n        var intMidY = (intMinY + intMaxY) / 2.0;\n        normPt.x = intMidX;\n        normPt.y = intMidY;\n        n00.x -= normPt.x;\n        n00.y -= normPt.y;\n        n01.x -= normPt.x;\n        n01.y -= normPt.y;\n        n10.x -= normPt.x;\n        n10.y -= normPt.y;\n        n11.x -= normPt.x;\n        n11.y -= normPt.y;\n    };\n    RobustLineIntersector.prototype.computeIntersect = function computeIntersect(p1, p2, q1, q2) {\n        this._isProper = false;\n        if (!Envelope.intersects(p1, p2, q1, q2)) {\n            return LineIntersector$$1.NO_INTERSECTION;\n        }\n        var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n        var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n        if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n            return LineIntersector$$1.NO_INTERSECTION;\n        }\n        var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n        var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n        if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n            return LineIntersector$$1.NO_INTERSECTION;\n        }\n        var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n        if (collinear) {\n            return this.computeCollinearIntersection(p1, p2, q1, q2);\n        }\n        if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n            this._isProper = false;\n            if (p1.equals2D(q1) || p1.equals2D(q2)) {\n                this._intPt[0] = p1;\n            } else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n                this._intPt[0] = p2;\n            } else if (Pq1 === 0) {\n                this._intPt[0] = new Coordinate(q1);\n            } else if (Pq2 === 0) {\n                this._intPt[0] = new Coordinate(q2);\n            } else if (Qp1 === 0) {\n                this._intPt[0] = new Coordinate(p1);\n            } else if (Qp2 === 0) {\n                this._intPt[0] = new Coordinate(p2);\n            }\n        } else {\n            this._isProper = true;\n            this._intPt[0] = this.intersection(p1, p2, q1, q2);\n        }\n        return LineIntersector$$1.POINT_INTERSECTION;\n    };\n    RobustLineIntersector.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    RobustLineIntersector.prototype.getClass = function getClass() {\n        return RobustLineIntersector;\n    };\n    RobustLineIntersector.nearestEndpoint = function nearestEndpoint(p1, p2, q1, q2) {\n        var nearestPt = p1;\n        var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n        var dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n        if (dist < minDist) {\n            minDist = dist;\n            nearestPt = p2;\n        }\n        dist = CGAlgorithms.distancePointLine(q1, p1, p2);\n        if (dist < minDist) {\n            minDist = dist;\n            nearestPt = q1;\n        }\n        dist = CGAlgorithms.distancePointLine(q2, p1, p2);\n        if (dist < minDist) {\n            minDist = dist;\n            nearestPt = q2;\n        }\n        return nearestPt;\n    };\n    return RobustLineIntersector;\n}(LineIntersector);\nvar RobustDeterminant = function RobustDeterminant() {};\nRobustDeterminant.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nRobustDeterminant.prototype.getClass = function getClass() {\n    return RobustDeterminant;\n};\nRobustDeterminant.orientationIndex = function orientationIndex(p1, p2, q) {\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dx2 = q.x - p2.x;\n    var dy2 = q.y - p2.y;\n    return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n};\nRobustDeterminant.signOfDet2x2 = function signOfDet2x2(x1, y1, x2, y2) {\n    var sign = null;\n    var swap = null;\n    var k = null;\n    sign = 1;\n    if (x1 === 0.0 || y2 === 0.0) {\n        if (y1 === 0.0 || x2 === 0.0) {\n            return 0;\n        } else if (y1 > 0) {\n            if (x2 > 0) {\n                return -sign;\n            } else {\n                return sign;\n            }\n        } else {\n            if (x2 > 0) {\n                return sign;\n            } else {\n                return -sign;\n            }\n        }\n    }\n    if (y1 === 0.0 || x2 === 0.0) {\n        if (y2 > 0) {\n            if (x1 > 0) {\n                return sign;\n            } else {\n                return -sign;\n            }\n        } else {\n            if (x1 > 0) {\n                return -sign;\n            } else {\n                return sign;\n            }\n        }\n    }\n    if (y1 > 0.0) {\n        if (y2 > 0.0) {\n            if (y1 <= y2) {} else {\n                sign = -sign;\n                swap = x1;\n                x1 = x2;\n                x2 = swap;\n                swap = y1;\n                y1 = y2;\n                y2 = swap;\n            }\n        } else {\n            if (y1 <= -y2) {\n                sign = -sign;\n                x2 = -x2;\n                y2 = -y2;\n            } else {\n                swap = x1;\n                x1 = -x2;\n                x2 = swap;\n                swap = y1;\n                y1 = -y2;\n                y2 = swap;\n            }\n        }\n    } else {\n        if (y2 > 0.0) {\n            if (-y1 <= y2) {\n                sign = -sign;\n                x1 = -x1;\n                y1 = -y1;\n            } else {\n                swap = -x1;\n                x1 = x2;\n                x2 = swap;\n                swap = -y1;\n                y1 = y2;\n                y2 = swap;\n            }\n        } else {\n            if (y1 >= y2) {\n                x1 = -x1;\n                y1 = -y1;\n                x2 = -x2;\n                y2 = -y2;\n            } else {\n                sign = -sign;\n                swap = -x1;\n                x1 = -x2;\n                x2 = swap;\n                swap = -y1;\n                y1 = -y2;\n                y2 = swap;\n            }\n        }\n    }\n    if (x1 > 0.0) {\n        if (x2 > 0.0) {\n            if (x1 <= x2) {} else {\n                return sign;\n            }\n        } else {\n            return sign;\n        }\n    } else {\n        if (x2 > 0.0) {\n            return -sign;\n        } else {\n            if (x1 >= x2) {\n                sign = -sign;\n                x1 = -x1;\n                x2 = -x2;\n            } else {\n                return -sign;\n            }\n        }\n    }\n    while(true){\n        k = Math.floor(x2 / x1);\n        x2 = x2 - k * x1;\n        y2 = y2 - k * y1;\n        if (y2 < 0.0) {\n            return -sign;\n        }\n        if (y2 > y1) {\n            return sign;\n        }\n        if (x1 > x2 + x2) {\n            if (y1 < y2 + y2) {\n                return sign;\n            }\n        } else {\n            if (y1 > y2 + y2) {\n                return -sign;\n            } else {\n                x2 = x1 - x2;\n                y2 = y1 - y2;\n                sign = -sign;\n            }\n        }\n        if (y2 === 0.0) {\n            if (x2 === 0.0) {\n                return 0;\n            } else {\n                return -sign;\n            }\n        }\n        if (x2 === 0.0) {\n            return sign;\n        }\n        k = Math.floor(x1 / x2);\n        x1 = x1 - k * x2;\n        y1 = y1 - k * y2;\n        if (y1 < 0.0) {\n            return sign;\n        }\n        if (y1 > y2) {\n            return -sign;\n        }\n        if (x2 > x1 + x1) {\n            if (y2 < y1 + y1) {\n                return -sign;\n            }\n        } else {\n            if (y2 > y1 + y1) {\n                return sign;\n            } else {\n                x1 = x2 - x1;\n                y1 = y2 - y1;\n                sign = -sign;\n            }\n        }\n        if (y1 === 0.0) {\n            if (x1 === 0.0) {\n                return 0;\n            } else {\n                return sign;\n            }\n        }\n        if (x1 === 0.0) {\n            return -sign;\n        }\n    }\n};\nvar RayCrossingCounter = function RayCrossingCounter() {\n    this._p = null;\n    this._crossingCount = 0;\n    this._isPointOnSegment = false;\n    var p = arguments[0];\n    this._p = p;\n};\nRayCrossingCounter.prototype.countSegment = function countSegment(p1, p2) {\n    if (p1.x < this._p.x && p2.x < this._p.x) {\n        return null;\n    }\n    if (this._p.x === p2.x && this._p.y === p2.y) {\n        this._isPointOnSegment = true;\n        return null;\n    }\n    if (p1.y === this._p.y && p2.y === this._p.y) {\n        var minx = p1.x;\n        var maxx = p2.x;\n        if (minx > maxx) {\n            minx = p2.x;\n            maxx = p1.x;\n        }\n        if (this._p.x >= minx && this._p.x <= maxx) {\n            this._isPointOnSegment = true;\n        }\n        return null;\n    }\n    if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n        var x1 = p1.x - this._p.x;\n        var y1 = p1.y - this._p.y;\n        var x2 = p2.x - this._p.x;\n        var y2 = p2.y - this._p.y;\n        var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n        if (xIntSign === 0.0) {\n            this._isPointOnSegment = true;\n            return null;\n        }\n        if (y2 < y1) {\n            xIntSign = -xIntSign;\n        }\n        if (xIntSign > 0.0) {\n            this._crossingCount++;\n        }\n    }\n};\nRayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon() {\n    return this.getLocation() !== Location.EXTERIOR;\n};\nRayCrossingCounter.prototype.getLocation = function getLocation() {\n    if (this._isPointOnSegment) {\n        return Location.BOUNDARY;\n    }\n    if (this._crossingCount % 2 === 1) {\n        return Location.INTERIOR;\n    }\n    return Location.EXTERIOR;\n};\nRayCrossingCounter.prototype.isOnSegment = function isOnSegment() {\n    return this._isPointOnSegment;\n};\nRayCrossingCounter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nRayCrossingCounter.prototype.getClass = function getClass() {\n    return RayCrossingCounter;\n};\nRayCrossingCounter.locatePointInRing = function locatePointInRing() {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n        var p = arguments[0];\n        var ring = arguments[1];\n        var counter = new RayCrossingCounter(p);\n        var p1 = new Coordinate();\n        var p2 = new Coordinate();\n        for(var i = 1; i < ring.size(); i++){\n            ring.getCoordinate(i, p1);\n            ring.getCoordinate(i - 1, p2);\n            counter.countSegment(p1, p2);\n            if (counter.isOnSegment()) {\n                return counter.getLocation();\n            }\n        }\n        return counter.getLocation();\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n        var p$1 = arguments[0];\n        var ring$1 = arguments[1];\n        var counter$1 = new RayCrossingCounter(p$1);\n        for(var i$1 = 1; i$1 < ring$1.length; i$1++){\n            var p1$1 = ring$1[i$1];\n            var p2$1 = ring$1[i$1 - 1];\n            counter$1.countSegment(p1$1, p2$1);\n            if (counter$1.isOnSegment()) {\n                return counter$1.getLocation();\n            }\n        }\n        return counter$1.getLocation();\n    }\n};\nvar CGAlgorithms = function CGAlgorithms() {};\nvar staticAccessors$3 = {\n    CLOCKWISE: {\n        configurable: true\n    },\n    RIGHT: {\n        configurable: true\n    },\n    COUNTERCLOCKWISE: {\n        configurable: true\n    },\n    LEFT: {\n        configurable: true\n    },\n    COLLINEAR: {\n        configurable: true\n    },\n    STRAIGHT: {\n        configurable: true\n    }\n};\nCGAlgorithms.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCGAlgorithms.prototype.getClass = function getClass() {\n    return CGAlgorithms;\n};\nCGAlgorithms.orientationIndex = function orientationIndex(p1, p2, q) {\n    return CGAlgorithmsDD.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.signedArea = function signedArea() {\n    if (arguments[0] instanceof Array) {\n        var ring = arguments[0];\n        if (ring.length < 3) {\n            return 0.0;\n        }\n        var sum = 0.0;\n        var x0 = ring[0].x;\n        for(var i = 1; i < ring.length - 1; i++){\n            var x = ring[i].x - x0;\n            var y1 = ring[i + 1].y;\n            var y2 = ring[i - 1].y;\n            sum += x * (y2 - y1);\n        }\n        return sum / 2.0;\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        var ring$1 = arguments[0];\n        var n = ring$1.size();\n        if (n < 3) {\n            return 0.0;\n        }\n        var p0 = new Coordinate();\n        var p1 = new Coordinate();\n        var p2 = new Coordinate();\n        ring$1.getCoordinate(0, p1);\n        ring$1.getCoordinate(1, p2);\n        var x0$1 = p1.x;\n        p2.x -= x0$1;\n        var sum$1 = 0.0;\n        for(var i$1 = 1; i$1 < n - 1; i$1++){\n            p0.y = p1.y;\n            p1.x = p2.x;\n            p1.y = p2.y;\n            ring$1.getCoordinate(i$1 + 1, p2);\n            p2.x -= x0$1;\n            sum$1 += p1.x * (p0.y - p2.y);\n        }\n        return sum$1 / 2.0;\n    }\n};\nCGAlgorithms.distanceLineLine = function distanceLineLine(A, B, C, D) {\n    if (A.equals(B)) {\n        return CGAlgorithms.distancePointLine(A, C, D);\n    }\n    if (C.equals(D)) {\n        return CGAlgorithms.distancePointLine(D, A, B);\n    }\n    var noIntersection = false;\n    if (!Envelope.intersects(A, B, C, D)) {\n        noIntersection = true;\n    } else {\n        var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n        if (denom === 0) {\n            noIntersection = true;\n        } else {\n            var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n            var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n            var s = sNum / denom;\n            var r = rNumb / denom;\n            if (r < 0 || r > 1 || s < 0 || s > 1) {\n                noIntersection = true;\n            }\n        }\n    }\n    if (noIntersection) {\n        return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n    }\n    return 0.0;\n};\nCGAlgorithms.isPointInRing = function isPointInRing(p, ring) {\n    return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n};\nCGAlgorithms.computeLength = function computeLength(pts) {\n    var n = pts.size();\n    if (n <= 1) {\n        return 0.0;\n    }\n    var len = 0.0;\n    var p = new Coordinate();\n    pts.getCoordinate(0, p);\n    var x0 = p.x;\n    var y0 = p.y;\n    for(var i = 1; i < n; i++){\n        pts.getCoordinate(i, p);\n        var x1 = p.x;\n        var y1 = p.y;\n        var dx = x1 - x0;\n        var dy = y1 - y0;\n        len += Math.sqrt(dx * dx + dy * dy);\n        x0 = x1;\n        y0 = y1;\n    }\n    return len;\n};\nCGAlgorithms.isCCW = function isCCW(ring) {\n    var nPts = ring.length - 1;\n    if (nPts < 3) {\n        throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n    }\n    var hiPt = ring[0];\n    var hiIndex = 0;\n    for(var i = 1; i <= nPts; i++){\n        var p = ring[i];\n        if (p.y > hiPt.y) {\n            hiPt = p;\n            hiIndex = i;\n        }\n    }\n    var iPrev = hiIndex;\n    do {\n        iPrev = iPrev - 1;\n        if (iPrev < 0) {\n            iPrev = nPts;\n        }\n    }while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n    var iNext = hiIndex;\n    do {\n        iNext = (iNext + 1) % nPts;\n    }while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n    var prev = ring[iPrev];\n    var next = ring[iNext];\n    if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) {\n        return false;\n    }\n    var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n    var isCCW = false;\n    if (disc === 0) {\n        isCCW = prev.x > next.x;\n    } else {\n        isCCW = disc > 0;\n    }\n    return isCCW;\n};\nCGAlgorithms.locatePointInRing = function locatePointInRing(p, ring) {\n    return RayCrossingCounter.locatePointInRing(p, ring);\n};\nCGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular(p, A, B) {\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2);\n};\nCGAlgorithms.computeOrientation = function computeOrientation(p1, p2, q) {\n    return CGAlgorithms.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.distancePointLine = function distancePointLine() {\n    if (arguments.length === 2) {\n        var p = arguments[0];\n        var line = arguments[1];\n        if (line.length === 0) {\n            throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n        }\n        var minDistance = p.distance(line[0]);\n        for(var i = 0; i < line.length - 1; i++){\n            var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n            if (dist < minDistance) {\n                minDistance = dist;\n            }\n        }\n        return minDistance;\n    } else if (arguments.length === 3) {\n        var p$1 = arguments[0];\n        var A = arguments[1];\n        var B = arguments[2];\n        if (A.x === B.x && A.y === B.y) {\n            return p$1.distance(A);\n        }\n        var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n        var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;\n        if (r <= 0.0) {\n            return p$1.distance(A);\n        }\n        if (r >= 1.0) {\n            return p$1.distance(B);\n        }\n        var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;\n        return Math.abs(s) * Math.sqrt(len2);\n    }\n};\nCGAlgorithms.isOnLine = function isOnLine(p, pt) {\n    var lineIntersector = new RobustLineIntersector();\n    for(var i = 1; i < pt.length; i++){\n        var p0 = pt[i - 1];\n        var p1 = pt[i];\n        lineIntersector.computeIntersection(p, p0, p1);\n        if (lineIntersector.hasIntersection()) {\n            return true;\n        }\n    }\n    return false;\n};\nstaticAccessors$3.CLOCKWISE.get = function() {\n    return -1;\n};\nstaticAccessors$3.RIGHT.get = function() {\n    return CGAlgorithms.CLOCKWISE;\n};\nstaticAccessors$3.COUNTERCLOCKWISE.get = function() {\n    return 1;\n};\nstaticAccessors$3.LEFT.get = function() {\n    return CGAlgorithms.COUNTERCLOCKWISE;\n};\nstaticAccessors$3.COLLINEAR.get = function() {\n    return 0;\n};\nstaticAccessors$3.STRAIGHT.get = function() {\n    return CGAlgorithms.COLLINEAR;\n};\nObject.defineProperties(CGAlgorithms, staticAccessors$3);\nvar GeometryComponentFilter = function GeometryComponentFilter() {};\nGeometryComponentFilter.prototype.filter = function filter(geom) {};\nGeometryComponentFilter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryComponentFilter.prototype.getClass = function getClass() {\n    return GeometryComponentFilter;\n};\nvar Geometry = function Geometry() {\n    var factory = arguments[0];\n    this._envelope = null;\n    this._factory = null;\n    this._SRID = null;\n    this._userData = null;\n    this._factory = factory;\n    this._SRID = factory.getSRID();\n};\nvar staticAccessors$11 = {\n    serialVersionUID: {\n        configurable: true\n    },\n    SORTINDEX_POINT: {\n        configurable: true\n    },\n    SORTINDEX_MULTIPOINT: {\n        configurable: true\n    },\n    SORTINDEX_LINESTRING: {\n        configurable: true\n    },\n    SORTINDEX_LINEARRING: {\n        configurable: true\n    },\n    SORTINDEX_MULTILINESTRING: {\n        configurable: true\n    },\n    SORTINDEX_POLYGON: {\n        configurable: true\n    },\n    SORTINDEX_MULTIPOLYGON: {\n        configurable: true\n    },\n    SORTINDEX_GEOMETRYCOLLECTION: {\n        configurable: true\n    },\n    geometryChangedFilter: {\n        configurable: true\n    }\n};\nGeometry.prototype.isGeometryCollection = function isGeometryCollection() {\n    return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n};\nGeometry.prototype.getFactory = function getFactory() {\n    return this._factory;\n};\nGeometry.prototype.getGeometryN = function getGeometryN(n) {\n    return this;\n};\nGeometry.prototype.getArea = function getArea() {\n    return 0.0;\n};\nGeometry.prototype.isRectangle = function isRectangle() {\n    return false;\n};\nGeometry.prototype.equals = function equals() {\n    if (arguments[0] instanceof Geometry) {\n        var g$1 = arguments[0];\n        if (g$1 === null) {\n            return false;\n        }\n        return this.equalsTopo(g$1);\n    } else if (arguments[0] instanceof Object) {\n        var o = arguments[0];\n        if (!(o instanceof Geometry)) {\n            return false;\n        }\n        var g = o;\n        return this.equalsExact(g);\n    }\n};\nGeometry.prototype.equalsExact = function equalsExact(other) {\n    return this === other || this.equalsExact(other, 0);\n};\nGeometry.prototype.geometryChanged = function geometryChanged() {\n    this.apply(Geometry.geometryChangedFilter);\n};\nGeometry.prototype.geometryChangedAction = function geometryChangedAction() {\n    this._envelope = null;\n};\nGeometry.prototype.equalsNorm = function equalsNorm(g) {\n    if (g === null) {\n        return false;\n    }\n    return this.norm().equalsExact(g.norm());\n};\nGeometry.prototype.getLength = function getLength() {\n    return 0.0;\n};\nGeometry.prototype.getNumGeometries = function getNumGeometries() {\n    return 1;\n};\nGeometry.prototype.compareTo = function compareTo() {\n    if (arguments.length === 1) {\n        var o = arguments[0];\n        var other = o;\n        if (this.getSortIndex() !== other.getSortIndex()) {\n            return this.getSortIndex() - other.getSortIndex();\n        }\n        if (this.isEmpty() && other.isEmpty()) {\n            return 0;\n        }\n        if (this.isEmpty()) {\n            return -1;\n        }\n        if (other.isEmpty()) {\n            return 1;\n        }\n        return this.compareToSameClass(o);\n    } else if (arguments.length === 2) {\n        var other$1 = arguments[0];\n        var comp = arguments[1];\n        if (this.getSortIndex() !== other$1.getSortIndex()) {\n            return this.getSortIndex() - other$1.getSortIndex();\n        }\n        if (this.isEmpty() && other$1.isEmpty()) {\n            return 0;\n        }\n        if (this.isEmpty()) {\n            return -1;\n        }\n        if (other$1.isEmpty()) {\n            return 1;\n        }\n        return this.compareToSameClass(other$1, comp);\n    }\n};\nGeometry.prototype.getUserData = function getUserData() {\n    return this._userData;\n};\nGeometry.prototype.getSRID = function getSRID() {\n    return this._SRID;\n};\nGeometry.prototype.getEnvelope = function getEnvelope() {\n    return this.getFactory().toGeometry(this.getEnvelopeInternal());\n};\nGeometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection(g) {\n    if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n        throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n    }\n};\nGeometry.prototype.equal = function equal(a, b, tolerance) {\n    if (tolerance === 0) {\n        return a.equals(b);\n    }\n    return a.distance(b) <= tolerance;\n};\nGeometry.prototype.norm = function norm() {\n    var copy = this.copy();\n    copy.normalize();\n    return copy;\n};\nGeometry.prototype.getPrecisionModel = function getPrecisionModel() {\n    return this._factory.getPrecisionModel();\n};\nGeometry.prototype.getEnvelopeInternal = function getEnvelopeInternal() {\n    if (this._envelope === null) {\n        this._envelope = this.computeEnvelopeInternal();\n    }\n    return new Envelope(this._envelope);\n};\nGeometry.prototype.setSRID = function setSRID(SRID) {\n    this._SRID = SRID;\n};\nGeometry.prototype.setUserData = function setUserData(userData) {\n    this._userData = userData;\n};\nGeometry.prototype.compare = function compare(a, b) {\n    var i = a.iterator();\n    var j = b.iterator();\n    while(i.hasNext() && j.hasNext()){\n        var aElement = i.next();\n        var bElement = j.next();\n        var comparison = aElement.compareTo(bElement);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    if (i.hasNext()) {\n        return 1;\n    }\n    if (j.hasNext()) {\n        return -1;\n    }\n    return 0;\n};\nGeometry.prototype.hashCode = function hashCode() {\n    return this.getEnvelopeInternal().hashCode();\n};\nGeometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived() {\n    if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n        return true;\n    }\n    return false;\n};\nGeometry.prototype.interfaces_ = function interfaces_() {\n    return [\n        Clonable,\n        Comparable,\n        Serializable\n    ];\n};\nGeometry.prototype.getClass = function getClass() {\n    return Geometry;\n};\nGeometry.hasNonEmptyElements = function hasNonEmptyElements(geometries) {\n    for(var i = 0; i < geometries.length; i++){\n        if (!geometries[i].isEmpty()) {\n            return true;\n        }\n    }\n    return false;\n};\nGeometry.hasNullElements = function hasNullElements(array) {\n    for(var i = 0; i < array.length; i++){\n        if (array[i] === null) {\n            return true;\n        }\n    }\n    return false;\n};\nstaticAccessors$11.serialVersionUID.get = function() {\n    return 8763622679187376702;\n};\nstaticAccessors$11.SORTINDEX_POINT.get = function() {\n    return 0;\n};\nstaticAccessors$11.SORTINDEX_MULTIPOINT.get = function() {\n    return 1;\n};\nstaticAccessors$11.SORTINDEX_LINESTRING.get = function() {\n    return 2;\n};\nstaticAccessors$11.SORTINDEX_LINEARRING.get = function() {\n    return 3;\n};\nstaticAccessors$11.SORTINDEX_MULTILINESTRING.get = function() {\n    return 4;\n};\nstaticAccessors$11.SORTINDEX_POLYGON.get = function() {\n    return 5;\n};\nstaticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function() {\n    return 6;\n};\nstaticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function() {\n    return 7;\n};\nstaticAccessors$11.geometryChangedFilter.get = function() {\n    return geometryChangedFilter;\n};\nObject.defineProperties(Geometry, staticAccessors$11);\nvar geometryChangedFilter = function geometryChangedFilter() {};\ngeometryChangedFilter.interfaces_ = function interfaces_() {\n    return [\n        GeometryComponentFilter\n    ];\n};\ngeometryChangedFilter.filter = function filter(geom) {\n    geom.geometryChangedAction();\n};\nvar CoordinateFilter = function CoordinateFilter() {};\nCoordinateFilter.prototype.filter = function filter(coord) {};\nCoordinateFilter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCoordinateFilter.prototype.getClass = function getClass() {\n    return CoordinateFilter;\n};\nvar BoundaryNodeRule = function BoundaryNodeRule() {};\nvar staticAccessors$12 = {\n    Mod2BoundaryNodeRule: {\n        configurable: true\n    },\n    EndPointBoundaryNodeRule: {\n        configurable: true\n    },\n    MultiValentEndPointBoundaryNodeRule: {\n        configurable: true\n    },\n    MonoValentEndPointBoundaryNodeRule: {\n        configurable: true\n    },\n    MOD2_BOUNDARY_RULE: {\n        configurable: true\n    },\n    ENDPOINT_BOUNDARY_RULE: {\n        configurable: true\n    },\n    MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {\n        configurable: true\n    },\n    MONOVALENT_ENDPOINT_BOUNDARY_RULE: {\n        configurable: true\n    },\n    OGC_SFS_BOUNDARY_RULE: {\n        configurable: true\n    }\n};\nBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {};\nBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBoundaryNodeRule.prototype.getClass = function getClass() {\n    return BoundaryNodeRule;\n};\nstaticAccessors$12.Mod2BoundaryNodeRule.get = function() {\n    return Mod2BoundaryNodeRule;\n};\nstaticAccessors$12.EndPointBoundaryNodeRule.get = function() {\n    return EndPointBoundaryNodeRule;\n};\nstaticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function() {\n    return MultiValentEndPointBoundaryNodeRule;\n};\nstaticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function() {\n    return MonoValentEndPointBoundaryNodeRule;\n};\nstaticAccessors$12.MOD2_BOUNDARY_RULE.get = function() {\n    return new Mod2BoundaryNodeRule();\n};\nstaticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function() {\n    return new EndPointBoundaryNodeRule();\n};\nstaticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {\n    return new MultiValentEndPointBoundaryNodeRule();\n};\nstaticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {\n    return new MonoValentEndPointBoundaryNodeRule();\n};\nstaticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function() {\n    return BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n};\nObject.defineProperties(BoundaryNodeRule, staticAccessors$12);\nvar Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule() {};\nMod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {\n    return boundaryCount % 2 === 1;\n};\nMod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_() {\n    return [\n        BoundaryNodeRule\n    ];\n};\nMod2BoundaryNodeRule.prototype.getClass = function getClass() {\n    return Mod2BoundaryNodeRule;\n};\nvar EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule() {};\nEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {\n    return boundaryCount > 0;\n};\nEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {\n    return [\n        BoundaryNodeRule\n    ];\n};\nEndPointBoundaryNodeRule.prototype.getClass = function getClass() {\n    return EndPointBoundaryNodeRule;\n};\nvar MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule() {};\nMultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {\n    return boundaryCount > 1;\n};\nMultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {\n    return [\n        BoundaryNodeRule\n    ];\n};\nMultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {\n    return MultiValentEndPointBoundaryNodeRule;\n};\nvar MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule() {};\nMonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary(boundaryCount) {\n    return boundaryCount === 1;\n};\nMonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_() {\n    return [\n        BoundaryNodeRule\n    ];\n};\nMonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass() {\n    return MonoValentEndPointBoundaryNodeRule;\n};\n// import Iterator from './Iterator'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */ var Collection = function Collection() {};\nCollection.prototype.add = function add() {};\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */ Collection.prototype.addAll = function addAll() {};\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */ Collection.prototype.isEmpty = function isEmpty() {};\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */ Collection.prototype.iterator = function iterator() {};\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */ Collection.prototype.size = function size() {};\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */ Collection.prototype.toArray = function toArray() {};\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */ Collection.prototype.remove = function remove() {};\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */ function IndexOutOfBoundsException(message) {\n    this.message = message || \"\";\n}\nIndexOutOfBoundsException.prototype = new Error();\n/**\n * @type {string}\n */ IndexOutOfBoundsException.prototype.name = \"IndexOutOfBoundsException\";\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */ var Iterator = function Iterator() {};\nIterator.prototype.hasNext = function hasNext() {};\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */ Iterator.prototype.next = function next() {};\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */ Iterator.prototype.remove = function remove() {};\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */ var List = function(Collection$$1) {\n    function List() {\n        Collection$$1.apply(this, arguments);\n    }\n    if (Collection$$1) List.__proto__ = Collection$$1;\n    List.prototype = Object.create(Collection$$1 && Collection$$1.prototype);\n    List.prototype.constructor = List;\n    List.prototype.get = function get() {};\n    /**\n   * Replaces the element at the specified position in this list with the\n   * specified element (optional operation).\n   * @param {number} index\n   * @param {Object} e\n   * @return {Object}\n   */ List.prototype.set = function set() {};\n    /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */ List.prototype.isEmpty = function isEmpty() {};\n    return List;\n}(Collection);\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */ function NoSuchElementException(message) {\n    this.message = message || \"\";\n}\nNoSuchElementException.prototype = new Error();\n/**\n * @type {string}\n */ NoSuchElementException.prototype.name = \"NoSuchElementException\";\n// import OperationNotSupported from './OperationNotSupported'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */ var ArrayList = function(List$$1) {\n    function ArrayList() {\n        List$$1.call(this);\n        this.array_ = [];\n        if (arguments[0] instanceof Collection) {\n            this.addAll(arguments[0]);\n        }\n    }\n    if (List$$1) ArrayList.__proto__ = List$$1;\n    ArrayList.prototype = Object.create(List$$1 && List$$1.prototype);\n    ArrayList.prototype.constructor = ArrayList;\n    ArrayList.prototype.ensureCapacity = function ensureCapacity() {};\n    ArrayList.prototype.interfaces_ = function interfaces_() {\n        return [\n            List$$1,\n            Collection\n        ];\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.add = function add(e) {\n        if (arguments.length === 1) {\n            this.array_.push(e);\n        } else {\n            this.array_.splice(arguments[0], arguments[1]);\n        }\n        return true;\n    };\n    ArrayList.prototype.clear = function clear() {\n        this.array_ = [];\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.addAll = function addAll(c) {\n        var this$1 = this;\n        for(var i = c.iterator(); i.hasNext();){\n            this$1.add(i.next());\n        }\n        return true;\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.set = function set(index, element) {\n        var oldElement = this.array_[index];\n        this.array_[index] = element;\n        return oldElement;\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.iterator = function iterator() {\n        return new Iterator_(this);\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.get = function get(index) {\n        if (index < 0 || index >= this.size()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return this.array_[index];\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.isEmpty = function isEmpty() {\n        return this.array_.length === 0;\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.size = function size() {\n        return this.array_.length;\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.toArray = function toArray() {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = this.array_.length; i < len; i++){\n            array.push(this$1.array_[i]);\n        }\n        return array;\n    };\n    /**\n   * @override\n   */ ArrayList.prototype.remove = function remove(o) {\n        var this$1 = this;\n        var found = false;\n        for(var i = 0, len = this.array_.length; i < len; i++){\n            if (this$1.array_[i] === o) {\n                this$1.array_.splice(i, 1);\n                found = true;\n                break;\n            }\n        }\n        return found;\n    };\n    return ArrayList;\n}(List);\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */ var Iterator_ = function(Iterator$$1) {\n    function Iterator_(arrayList) {\n        Iterator$$1.call(this);\n        /**\n     * @type {ArrayList}\n     * @private\n    */ this.arrayList_ = arrayList;\n        /**\n     * @type {number}\n     * @private\n    */ this.position_ = 0;\n    }\n    if (Iterator$$1) Iterator_.__proto__ = Iterator$$1;\n    Iterator_.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n    Iterator_.prototype.constructor = Iterator_;\n    /**\n   * @override\n   */ Iterator_.prototype.next = function next() {\n        if (this.position_ === this.arrayList_.size()) {\n            throw new NoSuchElementException();\n        }\n        return this.arrayList_.get(this.position_++);\n    };\n    /**\n   * @override\n   */ Iterator_.prototype.hasNext = function hasNext() {\n        if (this.position_ < this.arrayList_.size()) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    /**\n   * TODO: should be in ListIterator\n   * @override\n   */ Iterator_.prototype.set = function set(element) {\n        return this.arrayList_.set(this.position_ - 1, element);\n    };\n    /**\n   * @override\n   */ Iterator_.prototype.remove = function remove() {\n        this.arrayList_.remove(this.arrayList_.get(this.position_));\n    };\n    return Iterator_;\n}(Iterator);\nvar CoordinateList = function(ArrayList$$1) {\n    function CoordinateList() {\n        ArrayList$$1.call(this);\n        if (arguments.length === 0) {} else if (arguments.length === 1) {\n            var coord = arguments[0];\n            this.ensureCapacity(coord.length);\n            this.add(coord, true);\n        } else if (arguments.length === 2) {\n            var coord$1 = arguments[0];\n            var allowRepeated = arguments[1];\n            this.ensureCapacity(coord$1.length);\n            this.add(coord$1, allowRepeated);\n        }\n    }\n    if (ArrayList$$1) CoordinateList.__proto__ = ArrayList$$1;\n    CoordinateList.prototype = Object.create(ArrayList$$1 && ArrayList$$1.prototype);\n    CoordinateList.prototype.constructor = CoordinateList;\n    var staticAccessors = {\n        coordArrayType: {\n            configurable: true\n        }\n    };\n    staticAccessors.coordArrayType.get = function() {\n        return new Array(0).fill(null);\n    };\n    CoordinateList.prototype.getCoordinate = function getCoordinate(i) {\n        return this.get(i);\n    };\n    CoordinateList.prototype.addAll = function addAll() {\n        var this$1 = this;\n        if (arguments.length === 2) {\n            var coll = arguments[0];\n            var allowRepeated = arguments[1];\n            var isChanged = false;\n            for(var i = coll.iterator(); i.hasNext();){\n                this$1.add(i.next(), allowRepeated);\n                isChanged = true;\n            }\n            return isChanged;\n        } else {\n            return ArrayList$$1.prototype.addAll.apply(this, arguments);\n        }\n    };\n    CoordinateList.prototype.clone = function clone() {\n        var this$1 = this;\n        var clone = ArrayList$$1.prototype.clone.call(this);\n        for(var i = 0; i < this.size(); i++){\n            clone.add(i, this$1.get(i).copy());\n        }\n        return clone;\n    };\n    CoordinateList.prototype.toCoordinateArray = function toCoordinateArray() {\n        return this.toArray(CoordinateList.coordArrayType);\n    };\n    CoordinateList.prototype.add = function add() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var coord = arguments[0];\n            ArrayList$$1.prototype.add.call(this, coord);\n        } else if (arguments.length === 2) {\n            if (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n                var coord$1 = arguments[0];\n                var allowRepeated = arguments[1];\n                this.add(coord$1, allowRepeated, true);\n                return true;\n            } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n                var coord$2 = arguments[0];\n                var allowRepeated$1 = arguments[1];\n                if (!allowRepeated$1) {\n                    if (this.size() >= 1) {\n                        var last = this.get(this.size() - 1);\n                        if (last.equals2D(coord$2)) {\n                            return null;\n                        }\n                    }\n                }\n                ArrayList$$1.prototype.add.call(this, coord$2);\n            } else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n                var obj = arguments[0];\n                var allowRepeated$2 = arguments[1];\n                this.add(obj, allowRepeated$2);\n                return true;\n            }\n        } else if (arguments.length === 3) {\n            if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n                var coord$3 = arguments[0];\n                var allowRepeated$3 = arguments[1];\n                var direction = arguments[2];\n                if (direction) {\n                    for(var i$1 = 0; i$1 < coord$3.length; i$1++){\n                        this$1.add(coord$3[i$1], allowRepeated$3);\n                    }\n                } else {\n                    for(var i$2 = coord$3.length - 1; i$2 >= 0; i$2--){\n                        this$1.add(coord$3[i$2], allowRepeated$3);\n                    }\n                }\n                return true;\n            } else if (typeof arguments[2] === \"boolean\" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n                var i$3 = arguments[0];\n                var coord$4 = arguments[1];\n                var allowRepeated$4 = arguments[2];\n                if (!allowRepeated$4) {\n                    var size = this.size();\n                    if (size > 0) {\n                        if (i$3 > 0) {\n                            var prev = this.get(i$3 - 1);\n                            if (prev.equals2D(coord$4)) {\n                                return null;\n                            }\n                        }\n                        if (i$3 < size) {\n                            var next = this.get(i$3);\n                            if (next.equals2D(coord$4)) {\n                                return null;\n                            }\n                        }\n                    }\n                }\n                ArrayList$$1.prototype.add.call(this, i$3, coord$4);\n            }\n        } else if (arguments.length === 4) {\n            var coord$5 = arguments[0];\n            var allowRepeated$5 = arguments[1];\n            var start = arguments[2];\n            var end = arguments[3];\n            var inc = 1;\n            if (start > end) {\n                inc = -1;\n            }\n            for(var i = start; i !== end; i += inc){\n                this$1.add(coord$5[i], allowRepeated$5);\n            }\n            return true;\n        }\n    };\n    CoordinateList.prototype.closeRing = function closeRing() {\n        if (this.size() > 0) {\n            this.add(new Coordinate(this.get(0)), false);\n        }\n    };\n    CoordinateList.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    CoordinateList.prototype.getClass = function getClass() {\n        return CoordinateList;\n    };\n    Object.defineProperties(CoordinateList, staticAccessors);\n    return CoordinateList;\n}(ArrayList);\nvar CoordinateArrays = function CoordinateArrays() {};\nvar staticAccessors$13 = {\n    ForwardComparator: {\n        configurable: true\n    },\n    BidirectionalComparator: {\n        configurable: true\n    },\n    coordArrayType: {\n        configurable: true\n    }\n};\nstaticAccessors$13.ForwardComparator.get = function() {\n    return ForwardComparator;\n};\nstaticAccessors$13.BidirectionalComparator.get = function() {\n    return BidirectionalComparator;\n};\nstaticAccessors$13.coordArrayType.get = function() {\n    return new Array(0).fill(null);\n};\nCoordinateArrays.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCoordinateArrays.prototype.getClass = function getClass() {\n    return CoordinateArrays;\n};\nCoordinateArrays.isRing = function isRing(pts) {\n    if (pts.length < 4) {\n        return false;\n    }\n    if (!pts[0].equals2D(pts[pts.length - 1])) {\n        return false;\n    }\n    return true;\n};\nCoordinateArrays.ptNotInList = function ptNotInList(testPts, pts) {\n    for(var i = 0; i < testPts.length; i++){\n        var testPt = testPts[i];\n        if (CoordinateArrays.indexOf(testPt, pts) < 0) {\n            return testPt;\n        }\n    }\n    return null;\n};\nCoordinateArrays.scroll = function scroll(coordinates, firstCoordinate) {\n    var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n    if (i < 0) {\n        return null;\n    }\n    var newCoordinates = new Array(coordinates.length).fill(null);\n    System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n    System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n    System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function equals() {\n    if (arguments.length === 2) {\n        var coord1 = arguments[0];\n        var coord2 = arguments[1];\n        if (coord1 === coord2) {\n            return true;\n        }\n        if (coord1 === null || coord2 === null) {\n            return false;\n        }\n        if (coord1.length !== coord2.length) {\n            return false;\n        }\n        for(var i = 0; i < coord1.length; i++){\n            if (!coord1[i].equals(coord2[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else if (arguments.length === 3) {\n        var coord1$1 = arguments[0];\n        var coord2$1 = arguments[1];\n        var coordinateComparator = arguments[2];\n        if (coord1$1 === coord2$1) {\n            return true;\n        }\n        if (coord1$1 === null || coord2$1 === null) {\n            return false;\n        }\n        if (coord1$1.length !== coord2$1.length) {\n            return false;\n        }\n        for(var i$1 = 0; i$1 < coord1$1.length; i$1++){\n            if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nCoordinateArrays.intersection = function intersection(coordinates, env) {\n    var coordList = new CoordinateList();\n    for(var i = 0; i < coordinates.length; i++){\n        if (env.intersects(coordinates[i])) {\n            coordList.add(coordinates[i], true);\n        }\n    }\n    return coordList.toCoordinateArray();\n};\nCoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints(coord) {\n    for(var i = 1; i < coord.length; i++){\n        if (coord[i - 1].equals(coord[i])) {\n            return true;\n        }\n    }\n    return false;\n};\nCoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints(coord) {\n    if (!CoordinateArrays.hasRepeatedPoints(coord)) {\n        return coord;\n    }\n    var coordList = new CoordinateList(coord, false);\n    return coordList.toCoordinateArray();\n};\nCoordinateArrays.reverse = function reverse(coord) {\n    var last = coord.length - 1;\n    var mid = Math.trunc(last / 2);\n    for(var i = 0; i <= mid; i++){\n        var tmp = coord[i];\n        coord[i] = coord[last - i];\n        coord[last - i] = tmp;\n    }\n};\nCoordinateArrays.removeNull = function removeNull(coord) {\n    var nonNull = 0;\n    for(var i = 0; i < coord.length; i++){\n        if (coord[i] !== null) {\n            nonNull++;\n        }\n    }\n    var newCoord = new Array(nonNull).fill(null);\n    if (nonNull === 0) {\n        return newCoord;\n    }\n    var j = 0;\n    for(var i$1 = 0; i$1 < coord.length; i$1++){\n        if (coord[i$1] !== null) {\n            newCoord[j++] = coord[i$1];\n        }\n    }\n    return newCoord;\n};\nCoordinateArrays.copyDeep = function copyDeep() {\n    if (arguments.length === 1) {\n        var coordinates = arguments[0];\n        var copy = new Array(coordinates.length).fill(null);\n        for(var i = 0; i < coordinates.length; i++){\n            copy[i] = new Coordinate(coordinates[i]);\n        }\n        return copy;\n    } else if (arguments.length === 5) {\n        var src = arguments[0];\n        var srcStart = arguments[1];\n        var dest = arguments[2];\n        var destStart = arguments[3];\n        var length = arguments[4];\n        for(var i$1 = 0; i$1 < length; i$1++){\n            dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);\n        }\n    }\n};\nCoordinateArrays.isEqualReversed = function isEqualReversed(pts1, pts2) {\n    for(var i = 0; i < pts1.length; i++){\n        var p1 = pts1[i];\n        var p2 = pts2[pts1.length - i - 1];\n        if (p1.compareTo(p2) !== 0) {\n            return false;\n        }\n    }\n    return true;\n};\nCoordinateArrays.envelope = function envelope(coordinates) {\n    var env = new Envelope();\n    for(var i = 0; i < coordinates.length; i++){\n        env.expandToInclude(coordinates[i]);\n    }\n    return env;\n};\nCoordinateArrays.toCoordinateArray = function toCoordinateArray(coordList) {\n    return coordList.toArray(CoordinateArrays.coordArrayType);\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing(n, c) {\n    return c.length >= n ? c : [];\n};\nCoordinateArrays.indexOf = function indexOf(coordinate, coordinates) {\n    for(var i = 0; i < coordinates.length; i++){\n        if (coordinate.equals(coordinates[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nCoordinateArrays.increasingDirection = function increasingDirection(pts) {\n    for(var i = 0; i < Math.trunc(pts.length / 2); i++){\n        var j = pts.length - 1 - i;\n        var comp = pts[i].compareTo(pts[j]);\n        if (comp !== 0) {\n            return comp;\n        }\n    }\n    return 1;\n};\nCoordinateArrays.compare = function compare(pts1, pts2) {\n    var i = 0;\n    while(i < pts1.length && i < pts2.length){\n        var compare = pts1[i].compareTo(pts2[i]);\n        if (compare !== 0) {\n            return compare;\n        }\n        i++;\n    }\n    if (i < pts2.length) {\n        return -1;\n    }\n    if (i < pts1.length) {\n        return 1;\n    }\n    return 0;\n};\nCoordinateArrays.minCoordinate = function minCoordinate(coordinates) {\n    var minCoord = null;\n    for(var i = 0; i < coordinates.length; i++){\n        if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n            minCoord = coordinates[i];\n        }\n    }\n    return minCoord;\n};\nCoordinateArrays.extract = function extract(pts, start, end) {\n    start = MathUtil.clamp(start, 0, pts.length);\n    end = MathUtil.clamp(end, -1, pts.length);\n    var npts = end - start + 1;\n    if (end < 0) {\n        npts = 0;\n    }\n    if (start >= pts.length) {\n        npts = 0;\n    }\n    if (end < start) {\n        npts = 0;\n    }\n    var extractPts = new Array(npts).fill(null);\n    if (npts === 0) {\n        return extractPts;\n    }\n    var iPts = 0;\n    for(var i = start; i <= end; i++){\n        extractPts[iPts++] = pts[i];\n    }\n    return extractPts;\n};\nObject.defineProperties(CoordinateArrays, staticAccessors$13);\nvar ForwardComparator = function ForwardComparator() {};\nForwardComparator.prototype.compare = function compare(o1, o2) {\n    var pts1 = o1;\n    var pts2 = o2;\n    return CoordinateArrays.compare(pts1, pts2);\n};\nForwardComparator.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparator\n    ];\n};\nForwardComparator.prototype.getClass = function getClass() {\n    return ForwardComparator;\n};\nvar BidirectionalComparator = function BidirectionalComparator() {};\nBidirectionalComparator.prototype.compare = function compare(o1, o2) {\n    var pts1 = o1;\n    var pts2 = o2;\n    if (pts1.length < pts2.length) {\n        return -1;\n    }\n    if (pts1.length > pts2.length) {\n        return 1;\n    }\n    if (pts1.length === 0) {\n        return 0;\n    }\n    var forwardComp = CoordinateArrays.compare(pts1, pts2);\n    var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n    if (isEqualRev) {\n        return 0;\n    }\n    return forwardComp;\n};\nBidirectionalComparator.prototype.OLDcompare = function OLDcompare(o1, o2) {\n    var pts1 = o1;\n    var pts2 = o2;\n    if (pts1.length < pts2.length) {\n        return -1;\n    }\n    if (pts1.length > pts2.length) {\n        return 1;\n    }\n    if (pts1.length === 0) {\n        return 0;\n    }\n    var dir1 = CoordinateArrays.increasingDirection(pts1);\n    var dir2 = CoordinateArrays.increasingDirection(pts2);\n    var i1 = dir1 > 0 ? 0 : pts1.length - 1;\n    var i2 = dir2 > 0 ? 0 : pts1.length - 1;\n    for(var i = 0; i < pts1.length; i++){\n        var comparePt = pts1[i1].compareTo(pts2[i2]);\n        if (comparePt !== 0) {\n            return comparePt;\n        }\n        i1 += dir1;\n        i2 += dir2;\n    }\n    return 0;\n};\nBidirectionalComparator.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparator\n    ];\n};\nBidirectionalComparator.prototype.getClass = function getClass() {\n    return BidirectionalComparator;\n};\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */ var Map$1 = function Map1() {};\nMap$1.prototype.get = function get() {};\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */ Map$1.prototype.put = function put() {};\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */ Map$1.prototype.size = function size() {};\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */ Map$1.prototype.values = function values() {};\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */ Map$1.prototype.entrySet = function entrySet() {};\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */ var SortedMap = function(Map1) {\n    function SortedMap() {\n        Map1.apply(this, arguments);\n    }\n    if (Map1) SortedMap.__proto__ = Map1;\n    SortedMap.prototype = Object.create(Map1 && Map1.prototype);\n    SortedMap.prototype.constructor = SortedMap;\n    return SortedMap;\n}(Map$1);\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */ function OperationNotSupported(message) {\n    this.message = message || \"\";\n}\nOperationNotSupported.prototype = new Error();\n/**\n * @type {string}\n */ OperationNotSupported.prototype.name = \"OperationNotSupported\";\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */ function Set() {}\nSet.prototype = new Collection();\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */ Set.prototype.contains = function() {};\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */ var HashSet = function(Set$$1) {\n    function HashSet() {\n        Set$$1.call(this);\n        this.array_ = [];\n        if (arguments[0] instanceof Collection) {\n            this.addAll(arguments[0]);\n        }\n    }\n    if (Set$$1) HashSet.__proto__ = Set$$1;\n    HashSet.prototype = Object.create(Set$$1 && Set$$1.prototype);\n    HashSet.prototype.constructor = HashSet;\n    /**\n   * @override\n   */ HashSet.prototype.contains = function contains(o) {\n        var this$1 = this;\n        for(var i = 0, len = this.array_.length; i < len; i++){\n            var e = this$1.array_[i];\n            if (e === o) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.add = function add(o) {\n        if (this.contains(o)) {\n            return false;\n        }\n        this.array_.push(o);\n        return true;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.addAll = function addAll(c) {\n        var this$1 = this;\n        for(var i = c.iterator(); i.hasNext();){\n            this$1.add(i.next());\n        }\n        return true;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.remove = function remove(o) {\n        // throw new javascript.util.OperationNotSupported()\n        throw new Error();\n    };\n    /**\n   * @override\n   */ HashSet.prototype.size = function size() {\n        return this.array_.length;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.isEmpty = function isEmpty() {\n        return this.array_.length === 0;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.toArray = function toArray() {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0, len = this.array_.length; i < len; i++){\n            array.push(this$1.array_[i]);\n        }\n        return array;\n    };\n    /**\n   * @override\n   */ HashSet.prototype.iterator = function iterator() {\n        return new Iterator_$1(this);\n    };\n    return HashSet;\n}(Set);\n/**\n   * @extends {Iterator}\n   * @param {HashSet} hashSet\n   * @constructor\n   * @private\n   */ var Iterator_$1 = function(Iterator$$1) {\n    function Iterator_(hashSet) {\n        Iterator$$1.call(this);\n        /**\n     * @type {HashSet}\n     * @private\n     */ this.hashSet_ = hashSet;\n        /**\n     * @type {number}\n     * @private\n     */ this.position_ = 0;\n    }\n    if (Iterator$$1) Iterator_.__proto__ = Iterator$$1;\n    Iterator_.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n    Iterator_.prototype.constructor = Iterator_;\n    /**\n   * @override\n   */ Iterator_.prototype.next = function next() {\n        if (this.position_ === this.hashSet_.size()) {\n            throw new NoSuchElementException();\n        }\n        return this.hashSet_.array_[this.position_++];\n    };\n    /**\n   * @override\n   */ Iterator_.prototype.hasNext = function hasNext() {\n        if (this.position_ < this.hashSet_.size()) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    /**\n   * @override\n   */ Iterator_.prototype.remove = function remove() {\n        throw new OperationNotSupported();\n    };\n    return Iterator_;\n}(Iterator);\nvar BLACK = 0;\nvar RED = 1;\nfunction colorOf(p) {\n    return p === null ? BLACK : p.color;\n}\nfunction parentOf(p) {\n    return p === null ? null : p.parent;\n}\nfunction setColor(p, c) {\n    if (p !== null) {\n        p.color = c;\n    }\n}\nfunction leftOf(p) {\n    return p === null ? null : p.left;\n}\nfunction rightOf(p) {\n    return p === null ? null : p.right;\n}\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */ function TreeMap() {\n    /**\n   * @type {Object}\n   * @private\n   */ this.root_ = null;\n    /**\n   * @type {number}\n   * @private\n  */ this.size_ = 0;\n}\nTreeMap.prototype = new SortedMap();\n/**\n * @override\n */ TreeMap.prototype.get = function(key) {\n    var p = this.root_;\n    while(p !== null){\n        var cmp = key[\"compareTo\"](p.key);\n        if (cmp < 0) {\n            p = p.left;\n        } else if (cmp > 0) {\n            p = p.right;\n        } else {\n            return p.value;\n        }\n    }\n    return null;\n};\n/**\n * @override\n */ TreeMap.prototype.put = function(key, value) {\n    if (this.root_ === null) {\n        this.root_ = {\n            key: key,\n            value: value,\n            left: null,\n            right: null,\n            parent: null,\n            color: BLACK,\n            getValue: function getValue() {\n                return this.value;\n            },\n            getKey: function getKey() {\n                return this.key;\n            }\n        };\n        this.size_ = 1;\n        return null;\n    }\n    var t = this.root_;\n    var parent;\n    var cmp;\n    do {\n        parent = t;\n        cmp = key[\"compareTo\"](t.key);\n        if (cmp < 0) {\n            t = t.left;\n        } else if (cmp > 0) {\n            t = t.right;\n        } else {\n            var oldValue = t.value;\n            t.value = value;\n            return oldValue;\n        }\n    }while (t !== null);\n    var e = {\n        key: key,\n        left: null,\n        right: null,\n        value: value,\n        parent: parent,\n        color: BLACK,\n        getValue: function getValue() {\n            return this.value;\n        },\n        getKey: function getKey() {\n            return this.key;\n        }\n    };\n    if (cmp < 0) {\n        parent.left = e;\n    } else {\n        parent.right = e;\n    }\n    this.fixAfterInsertion(e);\n    this.size_++;\n    return null;\n};\n/**\n * @param {Object} x\n */ TreeMap.prototype.fixAfterInsertion = function(x) {\n    var this$1 = this;\n    x.color = RED;\n    while(x != null && x !== this.root_ && x.parent.color === RED){\n        if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n            var y = rightOf(parentOf(parentOf(x)));\n            if (colorOf(y) === RED) {\n                setColor(parentOf(x), BLACK);\n                setColor(y, BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                x = parentOf(parentOf(x));\n            } else {\n                if (x === rightOf(parentOf(x))) {\n                    x = parentOf(x);\n                    this$1.rotateLeft(x);\n                }\n                setColor(parentOf(x), BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                this$1.rotateRight(parentOf(parentOf(x)));\n            }\n        } else {\n            var y$1 = leftOf(parentOf(parentOf(x)));\n            if (colorOf(y$1) === RED) {\n                setColor(parentOf(x), BLACK);\n                setColor(y$1, BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                x = parentOf(parentOf(x));\n            } else {\n                if (x === leftOf(parentOf(x))) {\n                    x = parentOf(x);\n                    this$1.rotateRight(x);\n                }\n                setColor(parentOf(x), BLACK);\n                setColor(parentOf(parentOf(x)), RED);\n                this$1.rotateLeft(parentOf(parentOf(x)));\n            }\n        }\n    }\n    this.root_.color = BLACK;\n};\n/**\n * @override\n */ TreeMap.prototype.values = function() {\n    var arrayList = new ArrayList();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n        arrayList.add(p.value);\n        while((p = TreeMap.successor(p)) !== null){\n            arrayList.add(p.value);\n        }\n    }\n    return arrayList;\n};\n/**\n * @override\n */ TreeMap.prototype.entrySet = function() {\n    var hashSet = new HashSet();\n    var p = this.getFirstEntry();\n    if (p !== null) {\n        hashSet.add(p);\n        while((p = TreeMap.successor(p)) !== null){\n            hashSet.add(p);\n        }\n    }\n    return hashSet;\n};\n/**\n * @param {Object} p\n */ TreeMap.prototype.rotateLeft = function(p) {\n    if (p != null) {\n        var r = p.right;\n        p.right = r.left;\n        if (r.left != null) {\n            r.left.parent = p;\n        }\n        r.parent = p.parent;\n        if (p.parent === null) {\n            this.root_ = r;\n        } else if (p.parent.left === p) {\n            p.parent.left = r;\n        } else {\n            p.parent.right = r;\n        }\n        r.left = p;\n        p.parent = r;\n    }\n};\n/**\n * @param {Object} p\n */ TreeMap.prototype.rotateRight = function(p) {\n    if (p != null) {\n        var l = p.left;\n        p.left = l.right;\n        if (l.right != null) {\n            l.right.parent = p;\n        }\n        l.parent = p.parent;\n        if (p.parent === null) {\n            this.root_ = l;\n        } else if (p.parent.right === p) {\n            p.parent.right = l;\n        } else {\n            p.parent.left = l;\n        }\n        l.right = p;\n        p.parent = l;\n    }\n};\n/**\n * @return {Object}\n */ TreeMap.prototype.getFirstEntry = function() {\n    var p = this.root_;\n    if (p != null) {\n        while(p.left != null){\n            p = p.left;\n        }\n    }\n    return p;\n};\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */ TreeMap.successor = function(t) {\n    if (t === null) {\n        return null;\n    } else if (t.right !== null) {\n        var p = t.right;\n        while(p.left !== null){\n            p = p.left;\n        }\n        return p;\n    } else {\n        var p$1 = t.parent;\n        var ch = t;\n        while(p$1 !== null && ch === p$1.right){\n            ch = p$1;\n            p$1 = p$1.parent;\n        }\n        return p$1;\n    }\n};\n/**\n * @override\n */ TreeMap.prototype.size = function() {\n    return this.size_;\n};\nvar Lineal = function Lineal() {};\nLineal.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLineal.prototype.getClass = function getClass() {\n    return Lineal;\n};\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */ function SortedSet() {}\nSortedSet.prototype = new Set();\n// import Iterator from './Iterator'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */ function TreeSet() {\n    /**\n   * @type {Array}\n   * @private\n  */ this.array_ = [];\n    if (arguments[0] instanceof Collection) {\n        this.addAll(arguments[0]);\n    }\n}\nTreeSet.prototype = new SortedSet();\n/**\n * @override\n */ TreeSet.prototype.contains = function(o) {\n    var this$1 = this;\n    for(var i = 0, len = this.array_.length; i < len; i++){\n        var e = this$1.array_[i];\n        if (e[\"compareTo\"](o) === 0) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @override\n */ TreeSet.prototype.add = function(o) {\n    var this$1 = this;\n    if (this.contains(o)) {\n        return false;\n    }\n    for(var i = 0, len = this.array_.length; i < len; i++){\n        var e = this$1.array_[i];\n        if (e[\"compareTo\"](o) === 1) {\n            this$1.array_.splice(i, 0, o);\n            return true;\n        }\n    }\n    this.array_.push(o);\n    return true;\n};\n/**\n * @override\n */ TreeSet.prototype.addAll = function(c) {\n    var this$1 = this;\n    for(var i = c.iterator(); i.hasNext();){\n        this$1.add(i.next());\n    }\n    return true;\n};\n/**\n * @override\n */ TreeSet.prototype.remove = function(e) {\n    throw new OperationNotSupported();\n};\n/**\n * @override\n */ TreeSet.prototype.size = function() {\n    return this.array_.length;\n};\n/**\n * @override\n */ TreeSet.prototype.isEmpty = function() {\n    return this.array_.length === 0;\n};\n/**\n * @override\n */ TreeSet.prototype.toArray = function() {\n    var this$1 = this;\n    var array = [];\n    for(var i = 0, len = this.array_.length; i < len; i++){\n        array.push(this$1.array_[i]);\n    }\n    return array;\n};\n/**\n * @override\n */ TreeSet.prototype.iterator = function() {\n    return new Iterator_$2(this);\n};\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */ var Iterator_$2 = function(treeSet) {\n    /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */ this.treeSet_ = treeSet;\n    /**\n   * @type {number}\n   * @private\n   */ this.position_ = 0;\n};\n/**\n * @override\n */ Iterator_$2.prototype.next = function() {\n    if (this.position_ === this.treeSet_.size()) {\n        throw new NoSuchElementException();\n    }\n    return this.treeSet_.array_[this.position_++];\n};\n/**\n * @override\n */ Iterator_$2.prototype.hasNext = function() {\n    if (this.position_ < this.treeSet_.size()) {\n        return true;\n    } else {\n        return false;\n    }\n};\n/**\n * @override\n */ Iterator_$2.prototype.remove = function() {\n    throw new OperationNotSupported();\n};\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */ var Arrays = function Arrays() {};\nArrays.sort = function sort() {\n    var a = arguments[0];\n    var i;\n    var t;\n    var comparator;\n    var compare;\n    if (arguments.length === 1) {\n        compare = function(a, b) {\n            return a.compareTo(b);\n        };\n        a.sort(compare);\n    } else if (arguments.length === 2) {\n        comparator = arguments[1];\n        compare = function(a, b) {\n            return comparator[\"compare\"](a, b);\n        };\n        a.sort(compare);\n    } else if (arguments.length === 3) {\n        t = a.slice(arguments[1], arguments[2]);\n        t.sort();\n        var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n        a.splice(0, a.length);\n        for(i = 0; i < r.length; i++){\n            a.push(r[i]);\n        }\n    } else if (arguments.length === 4) {\n        t = a.slice(arguments[1], arguments[2]);\n        comparator = arguments[3];\n        compare = function(a, b) {\n            return comparator[\"compare\"](a, b);\n        };\n        t.sort(compare);\n        r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n        a.splice(0, a.length);\n        for(i = 0; i < r.length; i++){\n            a.push(r[i]);\n        }\n    }\n};\n/**\n * @param {Array} array\n * @return {ArrayList}\n */ Arrays.asList = function asList(array) {\n    var arrayList = new ArrayList();\n    for(var i = 0, len = array.length; i < len; i++){\n        arrayList.add(array[i]);\n    }\n    return arrayList;\n};\nvar Dimension = function Dimension() {};\nvar staticAccessors$14 = {\n    P: {\n        configurable: true\n    },\n    L: {\n        configurable: true\n    },\n    A: {\n        configurable: true\n    },\n    FALSE: {\n        configurable: true\n    },\n    TRUE: {\n        configurable: true\n    },\n    DONTCARE: {\n        configurable: true\n    },\n    SYM_FALSE: {\n        configurable: true\n    },\n    SYM_TRUE: {\n        configurable: true\n    },\n    SYM_DONTCARE: {\n        configurable: true\n    },\n    SYM_P: {\n        configurable: true\n    },\n    SYM_L: {\n        configurable: true\n    },\n    SYM_A: {\n        configurable: true\n    }\n};\nstaticAccessors$14.P.get = function() {\n    return 0;\n};\nstaticAccessors$14.L.get = function() {\n    return 1;\n};\nstaticAccessors$14.A.get = function() {\n    return 2;\n};\nstaticAccessors$14.FALSE.get = function() {\n    return -1;\n};\nstaticAccessors$14.TRUE.get = function() {\n    return -2;\n};\nstaticAccessors$14.DONTCARE.get = function() {\n    return -3;\n};\nstaticAccessors$14.SYM_FALSE.get = function() {\n    return \"F\";\n};\nstaticAccessors$14.SYM_TRUE.get = function() {\n    return \"T\";\n};\nstaticAccessors$14.SYM_DONTCARE.get = function() {\n    return \"*\";\n};\nstaticAccessors$14.SYM_P.get = function() {\n    return \"0\";\n};\nstaticAccessors$14.SYM_L.get = function() {\n    return \"1\";\n};\nstaticAccessors$14.SYM_A.get = function() {\n    return \"2\";\n};\nDimension.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDimension.prototype.getClass = function getClass() {\n    return Dimension;\n};\nDimension.toDimensionSymbol = function toDimensionSymbol(dimensionValue) {\n    switch(dimensionValue){\n        case Dimension.FALSE:\n            return Dimension.SYM_FALSE;\n        case Dimension.TRUE:\n            return Dimension.SYM_TRUE;\n        case Dimension.DONTCARE:\n            return Dimension.SYM_DONTCARE;\n        case Dimension.P:\n            return Dimension.SYM_P;\n        case Dimension.L:\n            return Dimension.SYM_L;\n        case Dimension.A:\n            return Dimension.SYM_A;\n        default:\n    }\n    throw new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n};\nDimension.toDimensionValue = function toDimensionValue(dimensionSymbol) {\n    switch(Character.toUpperCase(dimensionSymbol)){\n        case Dimension.SYM_FALSE:\n            return Dimension.FALSE;\n        case Dimension.SYM_TRUE:\n            return Dimension.TRUE;\n        case Dimension.SYM_DONTCARE:\n            return Dimension.DONTCARE;\n        case Dimension.SYM_P:\n            return Dimension.P;\n        case Dimension.SYM_L:\n            return Dimension.L;\n        case Dimension.SYM_A:\n            return Dimension.A;\n        default:\n    }\n    throw new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n};\nObject.defineProperties(Dimension, staticAccessors$14);\nvar GeometryFilter = function GeometryFilter() {};\nGeometryFilter.prototype.filter = function filter(geom) {};\nGeometryFilter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryFilter.prototype.getClass = function getClass() {\n    return GeometryFilter;\n};\nvar CoordinateSequenceFilter = function CoordinateSequenceFilter() {};\nCoordinateSequenceFilter.prototype.filter = function filter(seq, i) {};\nCoordinateSequenceFilter.prototype.isDone = function isDone() {};\nCoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged() {};\nCoordinateSequenceFilter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCoordinateSequenceFilter.prototype.getClass = function getClass() {\n    return CoordinateSequenceFilter;\n};\nvar GeometryCollection = function(Geometry$$1) {\n    function GeometryCollection(geometries, factory) {\n        Geometry$$1.call(this, factory);\n        this._geometries = geometries || [];\n        if (Geometry$$1.hasNullElements(this._geometries)) {\n            throw new IllegalArgumentException(\"geometries must not contain null elements\");\n        }\n    }\n    if (Geometry$$1) GeometryCollection.__proto__ = Geometry$$1;\n    GeometryCollection.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);\n    GeometryCollection.prototype.constructor = GeometryCollection;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {\n        var this$1 = this;\n        var envelope = new Envelope();\n        for(var i = 0; i < this._geometries.length; i++){\n            envelope.expandToInclude(this$1._geometries[i].getEnvelopeInternal());\n        }\n        return envelope;\n    };\n    GeometryCollection.prototype.getGeometryN = function getGeometryN(n) {\n        return this._geometries[n];\n    };\n    GeometryCollection.prototype.getSortIndex = function getSortIndex() {\n        return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION;\n    };\n    GeometryCollection.prototype.getCoordinates = function getCoordinates() {\n        var this$1 = this;\n        var coordinates = new Array(this.getNumPoints()).fill(null);\n        var k = -1;\n        for(var i = 0; i < this._geometries.length; i++){\n            var childCoordinates = this$1._geometries[i].getCoordinates();\n            for(var j = 0; j < childCoordinates.length; j++){\n                k++;\n                coordinates[k] = childCoordinates[j];\n            }\n        }\n        return coordinates;\n    };\n    GeometryCollection.prototype.getArea = function getArea() {\n        var this$1 = this;\n        var area = 0.0;\n        for(var i = 0; i < this._geometries.length; i++){\n            area += this$1._geometries[i].getArea();\n        }\n        return area;\n    };\n    GeometryCollection.prototype.equalsExact = function equalsExact() {\n        var this$1 = this;\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            var otherCollection = other;\n            if (this._geometries.length !== otherCollection._geometries.length) {\n                return false;\n            }\n            for(var i = 0; i < this._geometries.length; i++){\n                if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return Geometry$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    GeometryCollection.prototype.normalize = function normalize() {\n        var this$1 = this;\n        for(var i = 0; i < this._geometries.length; i++){\n            this$1._geometries[i].normalize();\n        }\n        Arrays.sort(this._geometries);\n    };\n    GeometryCollection.prototype.getCoordinate = function getCoordinate() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this._geometries[0].getCoordinate();\n    };\n    GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        var this$1 = this;\n        var dimension = Dimension.FALSE;\n        for(var i = 0; i < this._geometries.length; i++){\n            dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());\n        }\n        return dimension;\n    };\n    GeometryCollection.prototype.getDimension = function getDimension() {\n        var this$1 = this;\n        var dimension = Dimension.FALSE;\n        for(var i = 0; i < this._geometries.length; i++){\n            dimension = Math.max(dimension, this$1._geometries[i].getDimension());\n        }\n        return dimension;\n    };\n    GeometryCollection.prototype.getLength = function getLength() {\n        var this$1 = this;\n        var sum = 0.0;\n        for(var i = 0; i < this._geometries.length; i++){\n            sum += this$1._geometries[i].getLength();\n        }\n        return sum;\n    };\n    GeometryCollection.prototype.getNumPoints = function getNumPoints() {\n        var this$1 = this;\n        var numPoints = 0;\n        for(var i = 0; i < this._geometries.length; i++){\n            numPoints += this$1._geometries[i].getNumPoints();\n        }\n        return numPoints;\n    };\n    GeometryCollection.prototype.getNumGeometries = function getNumGeometries() {\n        return this._geometries.length;\n    };\n    GeometryCollection.prototype.reverse = function reverse() {\n        var this$1 = this;\n        var n = this._geometries.length;\n        var revGeoms = new Array(n).fill(null);\n        for(var i = 0; i < this._geometries.length; i++){\n            revGeoms[i] = this$1._geometries[i].reverse();\n        }\n        return this.getFactory().createGeometryCollection(revGeoms);\n    };\n    GeometryCollection.prototype.compareToSameClass = function compareToSameClass() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var o = arguments[0];\n            var theseElements = new TreeSet(Arrays.asList(this._geometries));\n            var otherElements = new TreeSet(Arrays.asList(o._geometries));\n            return this.compare(theseElements, otherElements);\n        } else if (arguments.length === 2) {\n            var o$1 = arguments[0];\n            var comp = arguments[1];\n            var gc = o$1;\n            var n1 = this.getNumGeometries();\n            var n2 = gc.getNumGeometries();\n            var i = 0;\n            while(i < n1 && i < n2){\n                var thisGeom = this$1.getGeometryN(i);\n                var otherGeom = gc.getGeometryN(i);\n                var holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n                if (holeComp !== 0) {\n                    return holeComp;\n                }\n                i++;\n            }\n            if (i < n1) {\n                return 1;\n            }\n            if (i < n2) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n    GeometryCollection.prototype.apply = function apply() {\n        var this$1 = this;\n        if (hasInterface(arguments[0], CoordinateFilter)) {\n            var filter = arguments[0];\n            for(var i = 0; i < this._geometries.length; i++){\n                this$1._geometries[i].apply(filter);\n            }\n        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n            var filter$1 = arguments[0];\n            if (this._geometries.length === 0) {\n                return null;\n            }\n            for(var i$1 = 0; i$1 < this._geometries.length; i$1++){\n                this$1._geometries[i$1].apply(filter$1);\n                if (filter$1.isDone()) {\n                    break;\n                }\n            }\n            if (filter$1.isGeometryChanged()) {\n                this.geometryChanged();\n            }\n        } else if (hasInterface(arguments[0], GeometryFilter)) {\n            var filter$2 = arguments[0];\n            filter$2.filter(this);\n            for(var i$2 = 0; i$2 < this._geometries.length; i$2++){\n                this$1._geometries[i$2].apply(filter$2);\n            }\n        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n            var filter$3 = arguments[0];\n            filter$3.filter(this);\n            for(var i$3 = 0; i$3 < this._geometries.length; i$3++){\n                this$1._geometries[i$3].apply(filter$3);\n            }\n        }\n    };\n    GeometryCollection.prototype.getBoundary = function getBoundary() {\n        this.checkNotGeometryCollection(this);\n        Assert.shouldNeverReachHere();\n        return null;\n    };\n    GeometryCollection.prototype.clone = function clone() {\n        var this$1 = this;\n        var gc = Geometry$$1.prototype.clone.call(this);\n        gc._geometries = new Array(this._geometries.length).fill(null);\n        for(var i = 0; i < this._geometries.length; i++){\n            gc._geometries[i] = this$1._geometries[i].clone();\n        }\n        return gc;\n    };\n    GeometryCollection.prototype.getGeometryType = function getGeometryType() {\n        return \"GeometryCollection\";\n    };\n    GeometryCollection.prototype.copy = function copy() {\n        var this$1 = this;\n        var geometries = new Array(this._geometries.length).fill(null);\n        for(var i = 0; i < geometries.length; i++){\n            geometries[i] = this$1._geometries[i].copy();\n        }\n        return new GeometryCollection(geometries, this._factory);\n    };\n    GeometryCollection.prototype.isEmpty = function isEmpty() {\n        var this$1 = this;\n        for(var i = 0; i < this._geometries.length; i++){\n            if (!this$1._geometries[i].isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    GeometryCollection.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    GeometryCollection.prototype.getClass = function getClass() {\n        return GeometryCollection;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return -5694727726395021467;\n    };\n    Object.defineProperties(GeometryCollection, staticAccessors);\n    return GeometryCollection;\n}(Geometry);\nvar MultiLineString = function(GeometryCollection$$1) {\n    function MultiLineString() {\n        GeometryCollection$$1.apply(this, arguments);\n    }\n    if (GeometryCollection$$1) MultiLineString.__proto__ = GeometryCollection$$1;\n    MultiLineString.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);\n    MultiLineString.prototype.constructor = MultiLineString;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    MultiLineString.prototype.getSortIndex = function getSortIndex() {\n        return Geometry.SORTINDEX_MULTILINESTRING;\n    };\n    MultiLineString.prototype.equalsExact = function equalsExact() {\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);\n        } else {\n            return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        if (this.isClosed()) {\n            return Dimension.FALSE;\n        }\n        return 0;\n    };\n    MultiLineString.prototype.isClosed = function isClosed() {\n        var this$1 = this;\n        if (this.isEmpty()) {\n            return false;\n        }\n        for(var i = 0; i < this._geometries.length; i++){\n            if (!this$1._geometries[i].isClosed()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    MultiLineString.prototype.getDimension = function getDimension() {\n        return 1;\n    };\n    MultiLineString.prototype.reverse = function reverse() {\n        var this$1 = this;\n        var nLines = this._geometries.length;\n        var revLines = new Array(nLines).fill(null);\n        for(var i = 0; i < this._geometries.length; i++){\n            revLines[nLines - 1 - i] = this$1._geometries[i].reverse();\n        }\n        return this.getFactory().createMultiLineString(revLines);\n    };\n    MultiLineString.prototype.getBoundary = function getBoundary() {\n        return new BoundaryOp(this).getBoundary();\n    };\n    MultiLineString.prototype.getGeometryType = function getGeometryType() {\n        return \"MultiLineString\";\n    };\n    MultiLineString.prototype.copy = function copy() {\n        var this$1 = this;\n        var lineStrings = new Array(this._geometries.length).fill(null);\n        for(var i = 0; i < lineStrings.length; i++){\n            lineStrings[i] = this$1._geometries[i].copy();\n        }\n        return new MultiLineString(lineStrings, this._factory);\n    };\n    MultiLineString.prototype.interfaces_ = function interfaces_() {\n        return [\n            Lineal\n        ];\n    };\n    MultiLineString.prototype.getClass = function getClass() {\n        return MultiLineString;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return 8166665132445433741;\n    };\n    Object.defineProperties(MultiLineString, staticAccessors);\n    return MultiLineString;\n}(GeometryCollection);\nvar BoundaryOp = function BoundaryOp() {\n    this._geom = null;\n    this._geomFact = null;\n    this._bnRule = null;\n    this._endpointMap = null;\n    if (arguments.length === 1) {\n        var geom = arguments[0];\n        var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n        this._geom = geom;\n        this._geomFact = geom.getFactory();\n        this._bnRule = bnRule;\n    } else if (arguments.length === 2) {\n        var geom$1 = arguments[0];\n        var bnRule$1 = arguments[1];\n        this._geom = geom$1;\n        this._geomFact = geom$1.getFactory();\n        this._bnRule = bnRule$1;\n    }\n};\nBoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString(mLine) {\n    if (this._geom.isEmpty()) {\n        return this.getEmptyMultiPoint();\n    }\n    var bdyPts = this.computeBoundaryCoordinates(mLine);\n    if (bdyPts.length === 1) {\n        return this._geomFact.createPoint(bdyPts[0]);\n    }\n    return this._geomFact.createMultiPointFromCoords(bdyPts);\n};\nBoundaryOp.prototype.getBoundary = function getBoundary() {\n    if (this._geom instanceof LineString) {\n        return this.boundaryLineString(this._geom);\n    }\n    if (this._geom instanceof MultiLineString) {\n        return this.boundaryMultiLineString(this._geom);\n    }\n    return this._geom.getBoundary();\n};\nBoundaryOp.prototype.boundaryLineString = function boundaryLineString(line) {\n    if (this._geom.isEmpty()) {\n        return this.getEmptyMultiPoint();\n    }\n    if (line.isClosed()) {\n        var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n        if (closedEndpointOnBoundary) {\n            return line.getStartPoint();\n        } else {\n            return this._geomFact.createMultiPoint();\n        }\n    }\n    return this._geomFact.createMultiPoint([\n        line.getStartPoint(),\n        line.getEndPoint()\n    ]);\n};\nBoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint() {\n    return this._geomFact.createMultiPoint();\n};\nBoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates(mLine) {\n    var this$1 = this;\n    var bdyPts = new ArrayList();\n    this._endpointMap = new TreeMap();\n    for(var i = 0; i < mLine.getNumGeometries(); i++){\n        var line = mLine.getGeometryN(i);\n        if (line.getNumPoints() === 0) {\n            continue;\n        }\n        this$1.addEndpoint(line.getCoordinateN(0));\n        this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n    }\n    for(var it = this._endpointMap.entrySet().iterator(); it.hasNext();){\n        var entry = it.next();\n        var counter = entry.getValue();\n        var valence = counter.count;\n        if (this$1._bnRule.isInBoundary(valence)) {\n            bdyPts.add(entry.getKey());\n        }\n    }\n    return CoordinateArrays.toCoordinateArray(bdyPts);\n};\nBoundaryOp.prototype.addEndpoint = function addEndpoint(pt) {\n    var counter = this._endpointMap.get(pt);\n    if (counter === null) {\n        counter = new Counter();\n        this._endpointMap.put(pt, counter);\n    }\n    counter.count++;\n};\nBoundaryOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBoundaryOp.prototype.getClass = function getClass() {\n    return BoundaryOp;\n};\nBoundaryOp.getBoundary = function getBoundary() {\n    if (arguments.length === 1) {\n        var g = arguments[0];\n        var bop = new BoundaryOp(g);\n        return bop.getBoundary();\n    } else if (arguments.length === 2) {\n        var g$1 = arguments[0];\n        var bnRule = arguments[1];\n        var bop$1 = new BoundaryOp(g$1, bnRule);\n        return bop$1.getBoundary();\n    }\n};\nvar Counter = function Counter() {\n    this.count = null;\n};\nCounter.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCounter.prototype.getClass = function getClass() {\n    return Counter;\n};\n// boundary\nfunction PrintStream() {}\nfunction StringReader() {}\nvar DecimalFormat = function DecimalFormat() {};\nfunction ByteArrayOutputStream() {}\nfunction IOException() {}\nfunction LineNumberReader() {}\nvar StringUtil = function StringUtil() {};\nvar staticAccessors$15 = {\n    NEWLINE: {\n        configurable: true\n    },\n    SIMPLE_ORDINATE_FORMAT: {\n        configurable: true\n    }\n};\nStringUtil.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nStringUtil.prototype.getClass = function getClass() {\n    return StringUtil;\n};\nStringUtil.chars = function chars(c, n) {\n    var ch = new Array(n).fill(null);\n    for(var i = 0; i < n; i++){\n        ch[i] = c;\n    }\n    return String(ch);\n};\nStringUtil.getStackTrace = function getStackTrace() {\n    if (arguments.length === 1) {\n        var t = arguments[0];\n        var os = new ByteArrayOutputStream();\n        var ps = new PrintStream(os);\n        t.printStackTrace(ps);\n        return os.toString();\n    } else if (arguments.length === 2) {\n        var t$1 = arguments[0];\n        var depth = arguments[1];\n        var stackTrace = \"\";\n        var stringReader = new StringReader(StringUtil.getStackTrace(t$1));\n        var lineNumberReader = new LineNumberReader(stringReader);\n        for(var i = 0; i < depth; i++){\n            try {\n                stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n            } catch (e) {\n                if (e instanceof IOException) {\n                    Assert.shouldNeverReachHere();\n                } else {\n                    throw e;\n                }\n            } finally{}\n        }\n        return stackTrace;\n    }\n};\nStringUtil.split = function split(s, separator) {\n    var separatorlen = separator.length;\n    var tokenList = new ArrayList();\n    var tmpString = \"\" + s;\n    var pos = tmpString.indexOf(separator);\n    while(pos >= 0){\n        var token = tmpString.substring(0, pos);\n        tokenList.add(token);\n        tmpString = tmpString.substring(pos + separatorlen);\n        pos = tmpString.indexOf(separator);\n    }\n    if (tmpString.length > 0) {\n        tokenList.add(tmpString);\n    }\n    var res = new Array(tokenList.size()).fill(null);\n    for(var i = 0; i < res.length; i++){\n        res[i] = tokenList.get(i);\n    }\n    return res;\n};\nStringUtil.toString = function toString() {\n    if (arguments.length === 1) {\n        var d = arguments[0];\n        return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n    }\n};\nStringUtil.spaces = function spaces(n) {\n    return StringUtil.chars(\" \", n);\n};\nstaticAccessors$15.NEWLINE.get = function() {\n    return System.getProperty(\"line.separator\");\n};\nstaticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function() {\n    return new DecimalFormat(\"0.#\");\n};\nObject.defineProperties(StringUtil, staticAccessors$15);\nvar CoordinateSequences = function CoordinateSequences() {};\nCoordinateSequences.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCoordinateSequences.prototype.getClass = function getClass() {\n    return CoordinateSequences;\n};\nCoordinateSequences.copyCoord = function copyCoord(src, srcPos, dest, destPos) {\n    var minDim = Math.min(src.getDimension(), dest.getDimension());\n    for(var dim = 0; dim < minDim; dim++){\n        dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n    }\n};\nCoordinateSequences.isRing = function isRing(seq) {\n    var n = seq.size();\n    if (n === 0) {\n        return true;\n    }\n    if (n <= 3) {\n        return false;\n    }\n    return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n};\nCoordinateSequences.isEqual = function isEqual(cs1, cs2) {\n    var cs1Size = cs1.size();\n    var cs2Size = cs2.size();\n    if (cs1Size !== cs2Size) {\n        return false;\n    }\n    var dim = Math.min(cs1.getDimension(), cs2.getDimension());\n    for(var i = 0; i < cs1Size; i++){\n        for(var d = 0; d < dim; d++){\n            var v1 = cs1.getOrdinate(i, d);\n            var v2 = cs2.getOrdinate(i, d);\n            if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) {\n                continue;\n            }\n            if (Double.isNaN(v1) && Double.isNaN(v2)) {\n                continue;\n            }\n            return false;\n        }\n    }\n    return true;\n};\nCoordinateSequences.extend = function extend(fact, seq, size) {\n    var newseq = fact.create(size, seq.getDimension());\n    var n = seq.size();\n    CoordinateSequences.copy(seq, 0, newseq, 0, n);\n    if (n > 0) {\n        for(var i = n; i < size; i++){\n            CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n        }\n    }\n    return newseq;\n};\nCoordinateSequences.reverse = function reverse(seq) {\n    var last = seq.size() - 1;\n    var mid = Math.trunc(last / 2);\n    for(var i = 0; i <= mid; i++){\n        CoordinateSequences.swap(seq, i, last - i);\n    }\n};\nCoordinateSequences.swap = function swap(seq, i, j) {\n    if (i === j) {\n        return null;\n    }\n    for(var dim = 0; dim < seq.getDimension(); dim++){\n        var tmp = seq.getOrdinate(i, dim);\n        seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n        seq.setOrdinate(j, dim, tmp);\n    }\n};\nCoordinateSequences.copy = function copy(src, srcPos, dest, destPos, length) {\n    for(var i = 0; i < length; i++){\n        CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n    }\n};\nCoordinateSequences.toString = function toString() {\n    if (arguments.length === 1) {\n        var cs = arguments[0];\n        var size = cs.size();\n        if (size === 0) {\n            return \"()\";\n        }\n        var dim = cs.getDimension();\n        var buf = new StringBuffer();\n        buf.append(\"(\");\n        for(var i = 0; i < size; i++){\n            if (i > 0) {\n                buf.append(\" \");\n            }\n            for(var d = 0; d < dim; d++){\n                if (d > 0) {\n                    buf.append(\",\");\n                }\n                buf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n            }\n        }\n        buf.append(\")\");\n        return buf.toString();\n    }\n};\nCoordinateSequences.ensureValidRing = function ensureValidRing(fact, seq) {\n    var n = seq.size();\n    if (n === 0) {\n        return seq;\n    }\n    if (n <= 3) {\n        return CoordinateSequences.createClosedRing(fact, seq, 4);\n    }\n    var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n    if (isClosed) {\n        return seq;\n    }\n    return CoordinateSequences.createClosedRing(fact, seq, n + 1);\n};\nCoordinateSequences.createClosedRing = function createClosedRing(fact, seq, size) {\n    var newseq = fact.create(size, seq.getDimension());\n    var n = seq.size();\n    CoordinateSequences.copy(seq, 0, newseq, 0, n);\n    for(var i = n; i < size; i++){\n        CoordinateSequences.copy(seq, 0, newseq, i, 1);\n    }\n    return newseq;\n};\nvar LineString = function(Geometry$$1) {\n    function LineString(points, factory) {\n        Geometry$$1.call(this, factory);\n        this._points = null;\n        this.init(points);\n    }\n    if (Geometry$$1) LineString.__proto__ = Geometry$$1;\n    LineString.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);\n    LineString.prototype.constructor = LineString;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {\n        if (this.isEmpty()) {\n            return new Envelope();\n        }\n        return this._points.expandEnvelope(new Envelope());\n    };\n    LineString.prototype.isRing = function isRing() {\n        return this.isClosed() && this.isSimple();\n    };\n    LineString.prototype.getSortIndex = function getSortIndex() {\n        return Geometry$$1.SORTINDEX_LINESTRING;\n    };\n    LineString.prototype.getCoordinates = function getCoordinates() {\n        return this._points.toCoordinateArray();\n    };\n    LineString.prototype.equalsExact = function equalsExact() {\n        var this$1 = this;\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            var otherLineString = other;\n            if (this._points.size() !== otherLineString._points.size()) {\n                return false;\n            }\n            for(var i = 0; i < this._points.size(); i++){\n                if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return Geometry$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    LineString.prototype.normalize = function normalize() {\n        var this$1 = this;\n        for(var i = 0; i < Math.trunc(this._points.size() / 2); i++){\n            var j = this$1._points.size() - 1 - i;\n            if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {\n                if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {\n                    CoordinateSequences.reverse(this$1._points);\n                }\n                return null;\n            }\n        }\n    };\n    LineString.prototype.getCoordinate = function getCoordinate() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this._points.getCoordinate(0);\n    };\n    LineString.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        if (this.isClosed()) {\n            return Dimension.FALSE;\n        }\n        return 0;\n    };\n    LineString.prototype.isClosed = function isClosed() {\n        if (this.isEmpty()) {\n            return false;\n        }\n        return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n    };\n    LineString.prototype.getEndPoint = function getEndPoint() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this.getPointN(this.getNumPoints() - 1);\n    };\n    LineString.prototype.getDimension = function getDimension() {\n        return 1;\n    };\n    LineString.prototype.getLength = function getLength() {\n        return CGAlgorithms.computeLength(this._points);\n    };\n    LineString.prototype.getNumPoints = function getNumPoints() {\n        return this._points.size();\n    };\n    LineString.prototype.reverse = function reverse() {\n        var seq = this._points.copy();\n        CoordinateSequences.reverse(seq);\n        var revLine = this.getFactory().createLineString(seq);\n        return revLine;\n    };\n    LineString.prototype.compareToSameClass = function compareToSameClass() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var o = arguments[0];\n            var line = o;\n            var i = 0;\n            var j = 0;\n            while(i < this._points.size() && j < line._points.size()){\n                var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n                if (comparison !== 0) {\n                    return comparison;\n                }\n                i++;\n                j++;\n            }\n            if (i < this._points.size()) {\n                return 1;\n            }\n            if (j < line._points.size()) {\n                return -1;\n            }\n            return 0;\n        } else if (arguments.length === 2) {\n            var o$1 = arguments[0];\n            var comp = arguments[1];\n            var line$1 = o$1;\n            return comp.compare(this._points, line$1._points);\n        }\n    };\n    LineString.prototype.apply = function apply() {\n        var this$1 = this;\n        if (hasInterface(arguments[0], CoordinateFilter)) {\n            var filter = arguments[0];\n            for(var i = 0; i < this._points.size(); i++){\n                filter.filter(this$1._points.getCoordinate(i));\n            }\n        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n            var filter$1 = arguments[0];\n            if (this._points.size() === 0) {\n                return null;\n            }\n            for(var i$1 = 0; i$1 < this._points.size(); i$1++){\n                filter$1.filter(this$1._points, i$1);\n                if (filter$1.isDone()) {\n                    break;\n                }\n            }\n            if (filter$1.isGeometryChanged()) {\n                this.geometryChanged();\n            }\n        } else if (hasInterface(arguments[0], GeometryFilter)) {\n            var filter$2 = arguments[0];\n            filter$2.filter(this);\n        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n            var filter$3 = arguments[0];\n            filter$3.filter(this);\n        }\n    };\n    LineString.prototype.getBoundary = function getBoundary() {\n        return new BoundaryOp(this).getBoundary();\n    };\n    LineString.prototype.isEquivalentClass = function isEquivalentClass(other) {\n        return other instanceof LineString;\n    };\n    LineString.prototype.clone = function clone() {\n        var ls = Geometry$$1.prototype.clone.call(this);\n        ls._points = this._points.clone();\n        return ls;\n    };\n    LineString.prototype.getCoordinateN = function getCoordinateN(n) {\n        return this._points.getCoordinate(n);\n    };\n    LineString.prototype.getGeometryType = function getGeometryType() {\n        return \"LineString\";\n    };\n    LineString.prototype.copy = function copy() {\n        return new LineString(this._points.copy(), this._factory);\n    };\n    LineString.prototype.getCoordinateSequence = function getCoordinateSequence() {\n        return this._points;\n    };\n    LineString.prototype.isEmpty = function isEmpty() {\n        return this._points.size() === 0;\n    };\n    LineString.prototype.init = function init(points) {\n        if (points === null) {\n            points = this.getFactory().getCoordinateSequenceFactory().create([]);\n        }\n        if (points.size() === 1) {\n            throw new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n        }\n        this._points = points;\n    };\n    LineString.prototype.isCoordinate = function isCoordinate(pt) {\n        var this$1 = this;\n        for(var i = 0; i < this._points.size(); i++){\n            if (this$1._points.getCoordinate(i).equals(pt)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    LineString.prototype.getStartPoint = function getStartPoint() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        return this.getPointN(0);\n    };\n    LineString.prototype.getPointN = function getPointN(n) {\n        return this.getFactory().createPoint(this._points.getCoordinate(n));\n    };\n    LineString.prototype.interfaces_ = function interfaces_() {\n        return [\n            Lineal\n        ];\n    };\n    LineString.prototype.getClass = function getClass() {\n        return LineString;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return 3110669828065365560;\n    };\n    Object.defineProperties(LineString, staticAccessors);\n    return LineString;\n}(Geometry);\nvar Puntal = function Puntal() {};\nPuntal.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPuntal.prototype.getClass = function getClass() {\n    return Puntal;\n};\nvar Point = function(Geometry$$1) {\n    function Point(coordinates, factory) {\n        Geometry$$1.call(this, factory);\n        this._coordinates = coordinates || null;\n        this.init(this._coordinates);\n    }\n    if (Geometry$$1) Point.__proto__ = Geometry$$1;\n    Point.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);\n    Point.prototype.constructor = Point;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {\n        if (this.isEmpty()) {\n            return new Envelope();\n        }\n        var env = new Envelope();\n        env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n        return env;\n    };\n    Point.prototype.getSortIndex = function getSortIndex() {\n        return Geometry$$1.SORTINDEX_POINT;\n    };\n    Point.prototype.getCoordinates = function getCoordinates() {\n        return this.isEmpty() ? [] : [\n            this.getCoordinate()\n        ];\n    };\n    Point.prototype.equalsExact = function equalsExact() {\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            if (this.isEmpty() && other.isEmpty()) {\n                return true;\n            }\n            if (this.isEmpty() !== other.isEmpty()) {\n                return false;\n            }\n            return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n        } else {\n            return Geometry$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    Point.prototype.normalize = function normalize() {};\n    Point.prototype.getCoordinate = function getCoordinate() {\n        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n    };\n    Point.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        return Dimension.FALSE;\n    };\n    Point.prototype.getDimension = function getDimension() {\n        return 0;\n    };\n    Point.prototype.getNumPoints = function getNumPoints() {\n        return this.isEmpty() ? 0 : 1;\n    };\n    Point.prototype.reverse = function reverse() {\n        return this.copy();\n    };\n    Point.prototype.getX = function getX() {\n        if (this.getCoordinate() === null) {\n            throw new Error(\"getX called on empty Point\");\n        }\n        return this.getCoordinate().x;\n    };\n    Point.prototype.compareToSameClass = function compareToSameClass() {\n        if (arguments.length === 1) {\n            var other = arguments[0];\n            var point$1 = other;\n            return this.getCoordinate().compareTo(point$1.getCoordinate());\n        } else if (arguments.length === 2) {\n            var other$1 = arguments[0];\n            var comp = arguments[1];\n            var point = other$1;\n            return comp.compare(this._coordinates, point._coordinates);\n        }\n    };\n    Point.prototype.apply = function apply() {\n        if (hasInterface(arguments[0], CoordinateFilter)) {\n            var filter = arguments[0];\n            if (this.isEmpty()) {\n                return null;\n            }\n            filter.filter(this.getCoordinate());\n        } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n            var filter$1 = arguments[0];\n            if (this.isEmpty()) {\n                return null;\n            }\n            filter$1.filter(this._coordinates, 0);\n            if (filter$1.isGeometryChanged()) {\n                this.geometryChanged();\n            }\n        } else if (hasInterface(arguments[0], GeometryFilter)) {\n            var filter$2 = arguments[0];\n            filter$2.filter(this);\n        } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n            var filter$3 = arguments[0];\n            filter$3.filter(this);\n        }\n    };\n    Point.prototype.getBoundary = function getBoundary() {\n        return this.getFactory().createGeometryCollection(null);\n    };\n    Point.prototype.clone = function clone() {\n        var p = Geometry$$1.prototype.clone.call(this);\n        p._coordinates = this._coordinates.clone();\n        return p;\n    };\n    Point.prototype.getGeometryType = function getGeometryType() {\n        return \"Point\";\n    };\n    Point.prototype.copy = function copy() {\n        return new Point(this._coordinates.copy(), this._factory);\n    };\n    Point.prototype.getCoordinateSequence = function getCoordinateSequence() {\n        return this._coordinates;\n    };\n    Point.prototype.getY = function getY() {\n        if (this.getCoordinate() === null) {\n            throw new Error(\"getY called on empty Point\");\n        }\n        return this.getCoordinate().y;\n    };\n    Point.prototype.isEmpty = function isEmpty() {\n        return this._coordinates.size() === 0;\n    };\n    Point.prototype.init = function init(coordinates) {\n        if (coordinates === null) {\n            coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n        }\n        Assert.isTrue(coordinates.size() <= 1);\n        this._coordinates = coordinates;\n    };\n    Point.prototype.isSimple = function isSimple() {\n        return true;\n    };\n    Point.prototype.interfaces_ = function interfaces_() {\n        return [\n            Puntal\n        ];\n    };\n    Point.prototype.getClass = function getClass() {\n        return Point;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return 4902022702746614570;\n    };\n    Object.defineProperties(Point, staticAccessors);\n    return Point;\n}(Geometry);\nvar Polygonal = function Polygonal() {};\nPolygonal.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPolygonal.prototype.getClass = function getClass() {\n    return Polygonal;\n};\nvar Polygon = function(Geometry$$1) {\n    function Polygon(shell, holes, factory) {\n        Geometry$$1.call(this, factory);\n        this._shell = null;\n        this._holes = null;\n        if (shell === null) {\n            shell = this.getFactory().createLinearRing();\n        }\n        if (holes === null) {\n            holes = [];\n        }\n        if (Geometry$$1.hasNullElements(holes)) {\n            throw new IllegalArgumentException(\"holes must not contain null elements\");\n        }\n        if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {\n            throw new IllegalArgumentException(\"shell is empty but holes are not\");\n        }\n        this._shell = shell;\n        this._holes = holes;\n    }\n    if (Geometry$$1) Polygon.__proto__ = Geometry$$1;\n    Polygon.prototype = Object.create(Geometry$$1 && Geometry$$1.prototype);\n    Polygon.prototype.constructor = Polygon;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal() {\n        return this._shell.getEnvelopeInternal();\n    };\n    Polygon.prototype.getSortIndex = function getSortIndex() {\n        return Geometry$$1.SORTINDEX_POLYGON;\n    };\n    Polygon.prototype.getCoordinates = function getCoordinates() {\n        var this$1 = this;\n        if (this.isEmpty()) {\n            return [];\n        }\n        var coordinates = new Array(this.getNumPoints()).fill(null);\n        var k = -1;\n        var shellCoordinates = this._shell.getCoordinates();\n        for(var x = 0; x < shellCoordinates.length; x++){\n            k++;\n            coordinates[k] = shellCoordinates[x];\n        }\n        for(var i = 0; i < this._holes.length; i++){\n            var childCoordinates = this$1._holes[i].getCoordinates();\n            for(var j = 0; j < childCoordinates.length; j++){\n                k++;\n                coordinates[k] = childCoordinates[j];\n            }\n        }\n        return coordinates;\n    };\n    Polygon.prototype.getArea = function getArea() {\n        var this$1 = this;\n        var area = 0.0;\n        area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n        for(var i = 0; i < this._holes.length; i++){\n            area -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));\n        }\n        return area;\n    };\n    Polygon.prototype.isRectangle = function isRectangle() {\n        if (this.getNumInteriorRing() !== 0) {\n            return false;\n        }\n        if (this._shell === null) {\n            return false;\n        }\n        if (this._shell.getNumPoints() !== 5) {\n            return false;\n        }\n        var seq = this._shell.getCoordinateSequence();\n        var env = this.getEnvelopeInternal();\n        for(var i = 0; i < 5; i++){\n            var x = seq.getX(i);\n            if (!(x === env.getMinX() || x === env.getMaxX())) {\n                return false;\n            }\n            var y = seq.getY(i);\n            if (!(y === env.getMinY() || y === env.getMaxY())) {\n                return false;\n            }\n        }\n        var prevX = seq.getX(0);\n        var prevY = seq.getY(0);\n        for(var i$1 = 1; i$1 <= 4; i$1++){\n            var x$1 = seq.getX(i$1);\n            var y$1 = seq.getY(i$1);\n            var xChanged = x$1 !== prevX;\n            var yChanged = y$1 !== prevY;\n            if (xChanged === yChanged) {\n                return false;\n            }\n            prevX = x$1;\n            prevY = y$1;\n        }\n        return true;\n    };\n    Polygon.prototype.equalsExact = function equalsExact() {\n        var this$1 = this;\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            var otherPolygon = other;\n            var thisShell = this._shell;\n            var otherPolygonShell = otherPolygon._shell;\n            if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n                return false;\n            }\n            if (this._holes.length !== otherPolygon._holes.length) {\n                return false;\n            }\n            for(var i = 0; i < this._holes.length; i++){\n                if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return Geometry$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    Polygon.prototype.normalize = function normalize() {\n        var this$1 = this;\n        if (arguments.length === 0) {\n            this.normalize(this._shell, true);\n            for(var i = 0; i < this._holes.length; i++){\n                this$1.normalize(this$1._holes[i], false);\n            }\n            Arrays.sort(this._holes);\n        } else if (arguments.length === 2) {\n            var ring = arguments[0];\n            var clockwise = arguments[1];\n            if (ring.isEmpty()) {\n                return null;\n            }\n            var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n            System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n            var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n            CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n            System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n            ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n            if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n                CoordinateArrays.reverse(ring.getCoordinates());\n            }\n        }\n    };\n    Polygon.prototype.getCoordinate = function getCoordinate() {\n        return this._shell.getCoordinate();\n    };\n    Polygon.prototype.getNumInteriorRing = function getNumInteriorRing() {\n        return this._holes.length;\n    };\n    Polygon.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        return 1;\n    };\n    Polygon.prototype.getDimension = function getDimension() {\n        return 2;\n    };\n    Polygon.prototype.getLength = function getLength() {\n        var this$1 = this;\n        var len = 0.0;\n        len += this._shell.getLength();\n        for(var i = 0; i < this._holes.length; i++){\n            len += this$1._holes[i].getLength();\n        }\n        return len;\n    };\n    Polygon.prototype.getNumPoints = function getNumPoints() {\n        var this$1 = this;\n        var numPoints = this._shell.getNumPoints();\n        for(var i = 0; i < this._holes.length; i++){\n            numPoints += this$1._holes[i].getNumPoints();\n        }\n        return numPoints;\n    };\n    Polygon.prototype.reverse = function reverse() {\n        var this$1 = this;\n        var poly = this.copy();\n        poly._shell = this._shell.copy().reverse();\n        poly._holes = new Array(this._holes.length).fill(null);\n        for(var i = 0; i < this._holes.length; i++){\n            poly._holes[i] = this$1._holes[i].copy().reverse();\n        }\n        return poly;\n    };\n    Polygon.prototype.convexHull = function convexHull() {\n        return this.getExteriorRing().convexHull();\n    };\n    Polygon.prototype.compareToSameClass = function compareToSameClass() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var o = arguments[0];\n            var thisShell = this._shell;\n            var otherShell = o._shell;\n            return thisShell.compareToSameClass(otherShell);\n        } else if (arguments.length === 2) {\n            var o$1 = arguments[0];\n            var comp = arguments[1];\n            var poly = o$1;\n            var thisShell$1 = this._shell;\n            var otherShell$1 = poly._shell;\n            var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);\n            if (shellComp !== 0) {\n                return shellComp;\n            }\n            var nHole1 = this.getNumInteriorRing();\n            var nHole2 = poly.getNumInteriorRing();\n            var i = 0;\n            while(i < nHole1 && i < nHole2){\n                var thisHole = this$1.getInteriorRingN(i);\n                var otherHole = poly.getInteriorRingN(i);\n                var holeComp = thisHole.compareToSameClass(otherHole, comp);\n                if (holeComp !== 0) {\n                    return holeComp;\n                }\n                i++;\n            }\n            if (i < nHole1) {\n                return 1;\n            }\n            if (i < nHole2) {\n                return -1;\n            }\n            return 0;\n        }\n    };\n    Polygon.prototype.apply = function apply(filter) {\n        var this$1 = this;\n        if (hasInterface(filter, CoordinateFilter)) {\n            this._shell.apply(filter);\n            for(var i$1 = 0; i$1 < this._holes.length; i$1++){\n                this$1._holes[i$1].apply(filter);\n            }\n        } else if (hasInterface(filter, CoordinateSequenceFilter)) {\n            this._shell.apply(filter);\n            if (!filter.isDone()) {\n                for(var i$2 = 0; i$2 < this._holes.length; i$2++){\n                    this$1._holes[i$2].apply(filter);\n                    if (filter.isDone()) {\n                        break;\n                    }\n                }\n            }\n            if (filter.isGeometryChanged()) {\n                this.geometryChanged();\n            }\n        } else if (hasInterface(filter, GeometryFilter)) {\n            filter.filter(this);\n        } else if (hasInterface(filter, GeometryComponentFilter)) {\n            filter.filter(this);\n            this._shell.apply(filter);\n            for(var i = 0; i < this._holes.length; i++){\n                this$1._holes[i].apply(filter);\n            }\n        }\n    };\n    Polygon.prototype.getBoundary = function getBoundary() {\n        var this$1 = this;\n        if (this.isEmpty()) {\n            return this.getFactory().createMultiLineString();\n        }\n        var rings = new Array(this._holes.length + 1).fill(null);\n        rings[0] = this._shell;\n        for(var i = 0; i < this._holes.length; i++){\n            rings[i + 1] = this$1._holes[i];\n        }\n        if (rings.length <= 1) {\n            return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n        }\n        return this.getFactory().createMultiLineString(rings);\n    };\n    Polygon.prototype.clone = function clone() {\n        var this$1 = this;\n        var poly = Geometry$$1.prototype.clone.call(this);\n        poly._shell = this._shell.clone();\n        poly._holes = new Array(this._holes.length).fill(null);\n        for(var i = 0; i < this._holes.length; i++){\n            poly._holes[i] = this$1._holes[i].clone();\n        }\n        return poly;\n    };\n    Polygon.prototype.getGeometryType = function getGeometryType() {\n        return \"Polygon\";\n    };\n    Polygon.prototype.copy = function copy() {\n        var this$1 = this;\n        var shell = this._shell.copy();\n        var holes = new Array(this._holes.length).fill(null);\n        for(var i = 0; i < holes.length; i++){\n            holes[i] = this$1._holes[i].copy();\n        }\n        return new Polygon(shell, holes, this._factory);\n    };\n    Polygon.prototype.getExteriorRing = function getExteriorRing() {\n        return this._shell;\n    };\n    Polygon.prototype.isEmpty = function isEmpty() {\n        return this._shell.isEmpty();\n    };\n    Polygon.prototype.getInteriorRingN = function getInteriorRingN(n) {\n        return this._holes[n];\n    };\n    Polygon.prototype.interfaces_ = function interfaces_() {\n        return [\n            Polygonal\n        ];\n    };\n    Polygon.prototype.getClass = function getClass() {\n        return Polygon;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return -3494792200821764533;\n    };\n    Object.defineProperties(Polygon, staticAccessors);\n    return Polygon;\n}(Geometry);\nvar MultiPoint = function(GeometryCollection$$1) {\n    function MultiPoint() {\n        GeometryCollection$$1.apply(this, arguments);\n    }\n    if (GeometryCollection$$1) MultiPoint.__proto__ = GeometryCollection$$1;\n    MultiPoint.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);\n    MultiPoint.prototype.constructor = MultiPoint;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    MultiPoint.prototype.getSortIndex = function getSortIndex() {\n        return Geometry.SORTINDEX_MULTIPOINT;\n    };\n    MultiPoint.prototype.isValid = function isValid() {\n        return true;\n    };\n    MultiPoint.prototype.equalsExact = function equalsExact() {\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);\n        } else {\n            return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    MultiPoint.prototype.getCoordinate = function getCoordinate() {\n        if (arguments.length === 1) {\n            var n = arguments[0];\n            return this._geometries[n].getCoordinate();\n        } else {\n            return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments);\n        }\n    };\n    MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        return Dimension.FALSE;\n    };\n    MultiPoint.prototype.getDimension = function getDimension() {\n        return 0;\n    };\n    MultiPoint.prototype.getBoundary = function getBoundary() {\n        return this.getFactory().createGeometryCollection(null);\n    };\n    MultiPoint.prototype.getGeometryType = function getGeometryType() {\n        return \"MultiPoint\";\n    };\n    MultiPoint.prototype.copy = function copy() {\n        var this$1 = this;\n        var points = new Array(this._geometries.length).fill(null);\n        for(var i = 0; i < points.length; i++){\n            points[i] = this$1._geometries[i].copy();\n        }\n        return new MultiPoint(points, this._factory);\n    };\n    MultiPoint.prototype.interfaces_ = function interfaces_() {\n        return [\n            Puntal\n        ];\n    };\n    MultiPoint.prototype.getClass = function getClass() {\n        return MultiPoint;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return -8048474874175355449;\n    };\n    Object.defineProperties(MultiPoint, staticAccessors);\n    return MultiPoint;\n}(GeometryCollection);\nvar LinearRing = function(LineString$$1) {\n    function LinearRing(points, factory) {\n        if (points instanceof Coordinate && factory instanceof GeometryFactory) {\n            points = factory.getCoordinateSequenceFactory().create(points);\n        }\n        LineString$$1.call(this, points, factory);\n        this.validateConstruction();\n    }\n    if (LineString$$1) LinearRing.__proto__ = LineString$$1;\n    LinearRing.prototype = Object.create(LineString$$1 && LineString$$1.prototype);\n    LinearRing.prototype.constructor = LinearRing;\n    var staticAccessors = {\n        MINIMUM_VALID_SIZE: {\n            configurable: true\n        },\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    LinearRing.prototype.getSortIndex = function getSortIndex() {\n        return Geometry.SORTINDEX_LINEARRING;\n    };\n    LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        return Dimension.FALSE;\n    };\n    LinearRing.prototype.isClosed = function isClosed() {\n        if (this.isEmpty()) {\n            return true;\n        }\n        return LineString$$1.prototype.isClosed.call(this);\n    };\n    LinearRing.prototype.reverse = function reverse() {\n        var seq = this._points.copy();\n        CoordinateSequences.reverse(seq);\n        var rev = this.getFactory().createLinearRing(seq);\n        return rev;\n    };\n    LinearRing.prototype.validateConstruction = function validateConstruction() {\n        if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {\n            throw new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n        }\n        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n            throw new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n        }\n    };\n    LinearRing.prototype.getGeometryType = function getGeometryType() {\n        return \"LinearRing\";\n    };\n    LinearRing.prototype.copy = function copy() {\n        return new LinearRing(this._points.copy(), this._factory);\n    };\n    LinearRing.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    LinearRing.prototype.getClass = function getClass() {\n        return LinearRing;\n    };\n    staticAccessors.MINIMUM_VALID_SIZE.get = function() {\n        return 4;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return -4261142084085851829;\n    };\n    Object.defineProperties(LinearRing, staticAccessors);\n    return LinearRing;\n}(LineString);\nvar MultiPolygon = function(GeometryCollection$$1) {\n    function MultiPolygon() {\n        GeometryCollection$$1.apply(this, arguments);\n    }\n    if (GeometryCollection$$1) MultiPolygon.__proto__ = GeometryCollection$$1;\n    MultiPolygon.prototype = Object.create(GeometryCollection$$1 && GeometryCollection$$1.prototype);\n    MultiPolygon.prototype.constructor = MultiPolygon;\n    var staticAccessors = {\n        serialVersionUID: {\n            configurable: true\n        }\n    };\n    MultiPolygon.prototype.getSortIndex = function getSortIndex() {\n        return Geometry.SORTINDEX_MULTIPOLYGON;\n    };\n    MultiPolygon.prototype.equalsExact = function equalsExact() {\n        if (arguments.length === 2) {\n            var other = arguments[0];\n            var tolerance = arguments[1];\n            if (!this.isEquivalentClass(other)) {\n                return false;\n            }\n            return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance);\n        } else {\n            return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments);\n        }\n    };\n    MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension() {\n        return 1;\n    };\n    MultiPolygon.prototype.getDimension = function getDimension() {\n        return 2;\n    };\n    MultiPolygon.prototype.reverse = function reverse() {\n        var this$1 = this;\n        var n = this._geometries.length;\n        var revGeoms = new Array(n).fill(null);\n        for(var i = 0; i < this._geometries.length; i++){\n            revGeoms[i] = this$1._geometries[i].reverse();\n        }\n        return this.getFactory().createMultiPolygon(revGeoms);\n    };\n    MultiPolygon.prototype.getBoundary = function getBoundary() {\n        var this$1 = this;\n        if (this.isEmpty()) {\n            return this.getFactory().createMultiLineString();\n        }\n        var allRings = new ArrayList();\n        for(var i = 0; i < this._geometries.length; i++){\n            var polygon = this$1._geometries[i];\n            var rings = polygon.getBoundary();\n            for(var j = 0; j < rings.getNumGeometries(); j++){\n                allRings.add(rings.getGeometryN(j));\n            }\n        }\n        var allRingsArray = new Array(allRings.size()).fill(null);\n        return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n    };\n    MultiPolygon.prototype.getGeometryType = function getGeometryType() {\n        return \"MultiPolygon\";\n    };\n    MultiPolygon.prototype.copy = function copy() {\n        var this$1 = this;\n        var polygons = new Array(this._geometries.length).fill(null);\n        for(var i = 0; i < polygons.length; i++){\n            polygons[i] = this$1._geometries[i].copy();\n        }\n        return new MultiPolygon(polygons, this._factory);\n    };\n    MultiPolygon.prototype.interfaces_ = function interfaces_() {\n        return [\n            Polygonal\n        ];\n    };\n    MultiPolygon.prototype.getClass = function getClass() {\n        return MultiPolygon;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return -551033529766975875;\n    };\n    Object.defineProperties(MultiPolygon, staticAccessors);\n    return MultiPolygon;\n}(GeometryCollection);\nvar GeometryEditor = function GeometryEditor(factory) {\n    this._factory = factory || null;\n    this._isUserDataCopied = false;\n};\nvar staticAccessors$16 = {\n    NoOpGeometryOperation: {\n        configurable: true\n    },\n    CoordinateOperation: {\n        configurable: true\n    },\n    CoordinateSequenceOperation: {\n        configurable: true\n    }\n};\nGeometryEditor.prototype.setCopyUserData = function setCopyUserData(isUserDataCopied) {\n    this._isUserDataCopied = isUserDataCopied;\n};\nGeometryEditor.prototype.edit = function edit(geometry, operation) {\n    if (geometry === null) {\n        return null;\n    }\n    var result = this.editInternal(geometry, operation);\n    if (this._isUserDataCopied) {\n        result.setUserData(geometry.getUserData());\n    }\n    return result;\n};\nGeometryEditor.prototype.editInternal = function editInternal(geometry, operation) {\n    if (this._factory === null) {\n        this._factory = geometry.getFactory();\n    }\n    if (geometry instanceof GeometryCollection) {\n        return this.editGeometryCollection(geometry, operation);\n    }\n    if (geometry instanceof Polygon) {\n        return this.editPolygon(geometry, operation);\n    }\n    if (geometry instanceof Point) {\n        return operation.edit(geometry, this._factory);\n    }\n    if (geometry instanceof LineString) {\n        return operation.edit(geometry, this._factory);\n    }\n    Assert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n    return null;\n};\nGeometryEditor.prototype.editGeometryCollection = function editGeometryCollection(collection, operation) {\n    var this$1 = this;\n    var collectionForType = operation.edit(collection, this._factory);\n    var geometries = new ArrayList();\n    for(var i = 0; i < collectionForType.getNumGeometries(); i++){\n        var geometry = this$1.edit(collectionForType.getGeometryN(i), operation);\n        if (geometry === null || geometry.isEmpty()) {\n            continue;\n        }\n        geometries.add(geometry);\n    }\n    if (collectionForType.getClass() === MultiPoint) {\n        return this._factory.createMultiPoint(geometries.toArray([]));\n    }\n    if (collectionForType.getClass() === MultiLineString) {\n        return this._factory.createMultiLineString(geometries.toArray([]));\n    }\n    if (collectionForType.getClass() === MultiPolygon) {\n        return this._factory.createMultiPolygon(geometries.toArray([]));\n    }\n    return this._factory.createGeometryCollection(geometries.toArray([]));\n};\nGeometryEditor.prototype.editPolygon = function editPolygon(polygon, operation) {\n    var this$1 = this;\n    var newPolygon = operation.edit(polygon, this._factory);\n    if (newPolygon === null) {\n        newPolygon = this._factory.createPolygon(null);\n    }\n    if (newPolygon.isEmpty()) {\n        return newPolygon;\n    }\n    var shell = this.edit(newPolygon.getExteriorRing(), operation);\n    if (shell === null || shell.isEmpty()) {\n        return this._factory.createPolygon();\n    }\n    var holes = new ArrayList();\n    for(var i = 0; i < newPolygon.getNumInteriorRing(); i++){\n        var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation);\n        if (hole === null || hole.isEmpty()) {\n            continue;\n        }\n        holes.add(hole);\n    }\n    return this._factory.createPolygon(shell, holes.toArray([]));\n};\nGeometryEditor.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryEditor.prototype.getClass = function getClass() {\n    return GeometryEditor;\n};\nGeometryEditor.GeometryEditorOperation = function GeometryEditorOperation() {};\nstaticAccessors$16.NoOpGeometryOperation.get = function() {\n    return NoOpGeometryOperation;\n};\nstaticAccessors$16.CoordinateOperation.get = function() {\n    return CoordinateOperation;\n};\nstaticAccessors$16.CoordinateSequenceOperation.get = function() {\n    return CoordinateSequenceOperation;\n};\nObject.defineProperties(GeometryEditor, staticAccessors$16);\nvar NoOpGeometryOperation = function NoOpGeometryOperation() {};\nNoOpGeometryOperation.prototype.edit = function edit(geometry, factory) {\n    return geometry;\n};\nNoOpGeometryOperation.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryEditor.GeometryEditorOperation\n    ];\n};\nNoOpGeometryOperation.prototype.getClass = function getClass() {\n    return NoOpGeometryOperation;\n};\nvar CoordinateOperation = function CoordinateOperation() {};\nCoordinateOperation.prototype.edit = function edit(geometry, factory) {\n    var coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n    if (coords === null) {\n        return geometry;\n    }\n    if (geometry instanceof LinearRing) {\n        return factory.createLinearRing(coords);\n    }\n    if (geometry instanceof LineString) {\n        return factory.createLineString(coords);\n    }\n    if (geometry instanceof Point) {\n        if (coords.length > 0) {\n            return factory.createPoint(coords[0]);\n        } else {\n            return factory.createPoint();\n        }\n    }\n    return geometry;\n};\nCoordinateOperation.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryEditor.GeometryEditorOperation\n    ];\n};\nCoordinateOperation.prototype.getClass = function getClass() {\n    return CoordinateOperation;\n};\nvar CoordinateSequenceOperation = function CoordinateSequenceOperation() {};\nCoordinateSequenceOperation.prototype.edit = function edit(geometry, factory) {\n    if (geometry instanceof LinearRing) {\n        return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n    }\n    if (geometry instanceof LineString) {\n        return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n    }\n    if (geometry instanceof Point) {\n        return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n    }\n    return geometry;\n};\nCoordinateSequenceOperation.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryEditor.GeometryEditorOperation\n    ];\n};\nCoordinateSequenceOperation.prototype.getClass = function getClass() {\n    return CoordinateSequenceOperation;\n};\nvar CoordinateArraySequence = function CoordinateArraySequence() {\n    var this$1 = this;\n    this._dimension = 3;\n    this._coordinates = null;\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n            this._coordinates = arguments[0];\n            this._dimension = 3;\n        } else if (Number.isInteger(arguments[0])) {\n            var size = arguments[0];\n            this._coordinates = new Array(size).fill(null);\n            for(var i = 0; i < size; i++){\n                this$1._coordinates[i] = new Coordinate();\n            }\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordSeq = arguments[0];\n            if (coordSeq === null) {\n                this._coordinates = new Array(0).fill(null);\n                return null;\n            }\n            this._dimension = coordSeq.getDimension();\n            this._coordinates = new Array(coordSeq.size()).fill(null);\n            for(var i$1 = 0; i$1 < this._coordinates.length; i$1++){\n                this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);\n            }\n        }\n    } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n            var coordinates = arguments[0];\n            var dimension = arguments[1];\n            this._coordinates = coordinates;\n            this._dimension = dimension;\n            if (coordinates === null) {\n                this._coordinates = new Array(0).fill(null);\n            }\n        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n            var size$1 = arguments[0];\n            var dimension$1 = arguments[1];\n            this._coordinates = new Array(size$1).fill(null);\n            this._dimension = dimension$1;\n            for(var i$2 = 0; i$2 < size$1; i$2++){\n                this$1._coordinates[i$2] = new Coordinate();\n            }\n        }\n    }\n};\nvar staticAccessors$18 = {\n    serialVersionUID: {\n        configurable: true\n    }\n};\nCoordinateArraySequence.prototype.setOrdinate = function setOrdinate(index, ordinateIndex, value) {\n    switch(ordinateIndex){\n        case CoordinateSequence.X:\n            this._coordinates[index].x = value;\n            break;\n        case CoordinateSequence.Y:\n            this._coordinates[index].y = value;\n            break;\n        case CoordinateSequence.Z:\n            this._coordinates[index].z = value;\n            break;\n        default:\n            throw new IllegalArgumentException(\"invalid ordinateIndex\");\n    }\n};\nCoordinateArraySequence.prototype.size = function size() {\n    return this._coordinates.length;\n};\nCoordinateArraySequence.prototype.getOrdinate = function getOrdinate(index, ordinateIndex) {\n    switch(ordinateIndex){\n        case CoordinateSequence.X:\n            return this._coordinates[index].x;\n        case CoordinateSequence.Y:\n            return this._coordinates[index].y;\n        case CoordinateSequence.Z:\n            return this._coordinates[index].z;\n        default:\n    }\n    return Double.NaN;\n};\nCoordinateArraySequence.prototype.getCoordinate = function getCoordinate() {\n    if (arguments.length === 1) {\n        var i = arguments[0];\n        return this._coordinates[i];\n    } else if (arguments.length === 2) {\n        var index = arguments[0];\n        var coord = arguments[1];\n        coord.x = this._coordinates[index].x;\n        coord.y = this._coordinates[index].y;\n        coord.z = this._coordinates[index].z;\n    }\n};\nCoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy(i) {\n    return new Coordinate(this._coordinates[i]);\n};\nCoordinateArraySequence.prototype.getDimension = function getDimension() {\n    return this._dimension;\n};\nCoordinateArraySequence.prototype.getX = function getX(index) {\n    return this._coordinates[index].x;\n};\nCoordinateArraySequence.prototype.clone = function clone() {\n    var this$1 = this;\n    var cloneCoordinates = new Array(this.size()).fill(null);\n    for(var i = 0; i < this._coordinates.length; i++){\n        cloneCoordinates[i] = this$1._coordinates[i].clone();\n    }\n    return new CoordinateArraySequence(cloneCoordinates, this._dimension);\n};\nCoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope(env) {\n    var this$1 = this;\n    for(var i = 0; i < this._coordinates.length; i++){\n        env.expandToInclude(this$1._coordinates[i]);\n    }\n    return env;\n};\nCoordinateArraySequence.prototype.copy = function copy() {\n    var this$1 = this;\n    var cloneCoordinates = new Array(this.size()).fill(null);\n    for(var i = 0; i < this._coordinates.length; i++){\n        cloneCoordinates[i] = this$1._coordinates[i].copy();\n    }\n    return new CoordinateArraySequence(cloneCoordinates, this._dimension);\n};\nCoordinateArraySequence.prototype.toString = function toString() {\n    var this$1 = this;\n    if (this._coordinates.length > 0) {\n        var strBuf = new StringBuffer(17 * this._coordinates.length);\n        strBuf.append(\"(\");\n        strBuf.append(this._coordinates[0]);\n        for(var i = 1; i < this._coordinates.length; i++){\n            strBuf.append(\", \");\n            strBuf.append(this$1._coordinates[i]);\n        }\n        strBuf.append(\")\");\n        return strBuf.toString();\n    } else {\n        return \"()\";\n    }\n};\nCoordinateArraySequence.prototype.getY = function getY(index) {\n    return this._coordinates[index].y;\n};\nCoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray() {\n    return this._coordinates;\n};\nCoordinateArraySequence.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateSequence,\n        Serializable\n    ];\n};\nCoordinateArraySequence.prototype.getClass = function getClass() {\n    return CoordinateArraySequence;\n};\nstaticAccessors$18.serialVersionUID.get = function() {\n    return -915438501601840650;\n};\nObject.defineProperties(CoordinateArraySequence, staticAccessors$18);\nvar CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory() {};\nvar staticAccessors$17 = {\n    serialVersionUID: {\n        configurable: true\n    },\n    instanceObject: {\n        configurable: true\n    }\n};\nCoordinateArraySequenceFactory.prototype.readResolve = function readResolve() {\n    return CoordinateArraySequenceFactory.instance();\n};\nCoordinateArraySequenceFactory.prototype.create = function create() {\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n            var coordinates = arguments[0];\n            return new CoordinateArraySequence(coordinates);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordSeq = arguments[0];\n            return new CoordinateArraySequence(coordSeq);\n        }\n    } else if (arguments.length === 2) {\n        var size = arguments[0];\n        var dimension = arguments[1];\n        if (dimension > 3) {\n            dimension = 3;\n        }\n        if (dimension < 2) {\n            return new CoordinateArraySequence(size);\n        }\n        return new CoordinateArraySequence(size, dimension);\n    }\n};\nCoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateSequenceFactory,\n        Serializable\n    ];\n};\nCoordinateArraySequenceFactory.prototype.getClass = function getClass() {\n    return CoordinateArraySequenceFactory;\n};\nCoordinateArraySequenceFactory.instance = function instance() {\n    return CoordinateArraySequenceFactory.instanceObject;\n};\nstaticAccessors$17.serialVersionUID.get = function() {\n    return -4099577099607551657;\n};\nstaticAccessors$17.instanceObject.get = function() {\n    return new CoordinateArraySequenceFactory();\n};\nObject.defineProperties(CoordinateArraySequenceFactory, staticAccessors$17);\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */ var HashMap = function(MapInterface) {\n    function HashMap() {\n        MapInterface.call(this);\n        this.map_ = new Map();\n    }\n    if (MapInterface) HashMap.__proto__ = MapInterface;\n    HashMap.prototype = Object.create(MapInterface && MapInterface.prototype);\n    HashMap.prototype.constructor = HashMap;\n    /**\n   * @override\n   */ HashMap.prototype.get = function get(key) {\n        return this.map_.get(key) || null;\n    };\n    /**\n   * @override\n   */ HashMap.prototype.put = function put(key, value) {\n        this.map_.set(key, value);\n        return value;\n    };\n    /**\n   * @override\n   */ HashMap.prototype.values = function values() {\n        var arrayList = new ArrayList();\n        var it = this.map_.values();\n        var o = it.next();\n        while(!o.done){\n            arrayList.add(o.value);\n            o = it.next();\n        }\n        return arrayList;\n    };\n    /**\n   * @override\n   */ HashMap.prototype.entrySet = function entrySet() {\n        var hashSet = new HashSet();\n        this.map_.entries().forEach(function(entry) {\n            return hashSet.add(entry);\n        });\n        return hashSet;\n    };\n    /**\n   * @override\n   */ HashMap.prototype.size = function size() {\n        return this.map_.size();\n    };\n    return HashMap;\n}(Map$1);\nvar PrecisionModel = function PrecisionModel() {\n    this._modelType = null;\n    this._scale = null;\n    if (arguments.length === 0) {\n        this._modelType = PrecisionModel.FLOATING;\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Type) {\n            var modelType = arguments[0];\n            this._modelType = modelType;\n            if (modelType === PrecisionModel.FIXED) {\n                this.setScale(1.0);\n            }\n        } else if (typeof arguments[0] === \"number\") {\n            var scale = arguments[0];\n            this._modelType = PrecisionModel.FIXED;\n            this.setScale(scale);\n        } else if (arguments[0] instanceof PrecisionModel) {\n            var pm = arguments[0];\n            this._modelType = pm._modelType;\n            this._scale = pm._scale;\n        }\n    }\n};\nvar staticAccessors$19 = {\n    serialVersionUID: {\n        configurable: true\n    },\n    maximumPreciseValue: {\n        configurable: true\n    }\n};\nPrecisionModel.prototype.equals = function equals(other) {\n    if (!(other instanceof PrecisionModel)) {\n        return false;\n    }\n    var otherPrecisionModel = other;\n    return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n};\nPrecisionModel.prototype.compareTo = function compareTo(o) {\n    var other = o;\n    var sigDigits = this.getMaximumSignificantDigits();\n    var otherSigDigits = other.getMaximumSignificantDigits();\n    return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n};\nPrecisionModel.prototype.getScale = function getScale() {\n    return this._scale;\n};\nPrecisionModel.prototype.isFloating = function isFloating() {\n    return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n};\nPrecisionModel.prototype.getType = function getType() {\n    return this._modelType;\n};\nPrecisionModel.prototype.toString = function toString() {\n    var description = \"UNKNOWN\";\n    if (this._modelType === PrecisionModel.FLOATING) {\n        description = \"Floating\";\n    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n        description = \"Floating-Single\";\n    } else if (this._modelType === PrecisionModel.FIXED) {\n        description = \"Fixed (Scale=\" + this.getScale() + \")\";\n    }\n    return description;\n};\nPrecisionModel.prototype.makePrecise = function makePrecise() {\n    if (typeof arguments[0] === \"number\") {\n        var val = arguments[0];\n        if (Double.isNaN(val)) {\n            return val;\n        }\n        if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n            var floatSingleVal = val;\n            return floatSingleVal;\n        }\n        if (this._modelType === PrecisionModel.FIXED) {\n            return Math.round(val * this._scale) / this._scale;\n        }\n        return val;\n    } else if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        if (this._modelType === PrecisionModel.FLOATING) {\n            return null;\n        }\n        coord.x = this.makePrecise(coord.x);\n        coord.y = this.makePrecise(coord.y);\n    }\n};\nPrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits() {\n    var maxSigDigits = 16;\n    if (this._modelType === PrecisionModel.FLOATING) {\n        maxSigDigits = 16;\n    } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n        maxSigDigits = 6;\n    } else if (this._modelType === PrecisionModel.FIXED) {\n        maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n    }\n    return maxSigDigits;\n};\nPrecisionModel.prototype.setScale = function setScale(scale) {\n    this._scale = Math.abs(scale);\n};\nPrecisionModel.prototype.interfaces_ = function interfaces_() {\n    return [\n        Serializable,\n        Comparable\n    ];\n};\nPrecisionModel.prototype.getClass = function getClass() {\n    return PrecisionModel;\n};\nPrecisionModel.mostPrecise = function mostPrecise(pm1, pm2) {\n    if (pm1.compareTo(pm2) >= 0) {\n        return pm1;\n    }\n    return pm2;\n};\nstaticAccessors$19.serialVersionUID.get = function() {\n    return 7777263578777803835;\n};\nstaticAccessors$19.maximumPreciseValue.get = function() {\n    return 9007199254740992.0;\n};\nObject.defineProperties(PrecisionModel, staticAccessors$19);\nvar Type = function Type(name) {\n    this._name = name || null;\n    Type.nameToTypeMap.put(name, this);\n};\nvar staticAccessors$1$1 = {\n    serialVersionUID: {\n        configurable: true\n    },\n    nameToTypeMap: {\n        configurable: true\n    }\n};\nType.prototype.readResolve = function readResolve() {\n    return Type.nameToTypeMap.get(this._name);\n};\nType.prototype.toString = function toString() {\n    return this._name;\n};\nType.prototype.interfaces_ = function interfaces_() {\n    return [\n        Serializable\n    ];\n};\nType.prototype.getClass = function getClass() {\n    return Type;\n};\nstaticAccessors$1$1.serialVersionUID.get = function() {\n    return -5528602631731589822;\n};\nstaticAccessors$1$1.nameToTypeMap.get = function() {\n    return new HashMap();\n};\nObject.defineProperties(Type, staticAccessors$1$1);\nPrecisionModel.Type = Type;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nvar GeometryFactory = function GeometryFactory() {\n    this._precisionModel = new PrecisionModel();\n    this._SRID = 0;\n    this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n            this._coordinateSequenceFactory = arguments[0];\n        } else if (arguments[0] instanceof PrecisionModel) {\n            this._precisionModel = arguments[0];\n        }\n    } else if (arguments.length === 2) {\n        this._precisionModel = arguments[0];\n        this._SRID = arguments[1];\n    } else if (arguments.length === 3) {\n        this._precisionModel = arguments[0];\n        this._SRID = arguments[1];\n        this._coordinateSequenceFactory = arguments[2];\n    }\n};\nvar staticAccessors$2 = {\n    serialVersionUID: {\n        configurable: true\n    }\n};\nGeometryFactory.prototype.toGeometry = function toGeometry(envelope) {\n    if (envelope.isNull()) {\n        return this.createPoint(null);\n    }\n    if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n        return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n    }\n    if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n        return this.createLineString([\n            new Coordinate(envelope.getMinX(), envelope.getMinY()),\n            new Coordinate(envelope.getMaxX(), envelope.getMaxY())\n        ]);\n    }\n    return this.createPolygon(this.createLinearRing([\n        new Coordinate(envelope.getMinX(), envelope.getMinY()),\n        new Coordinate(envelope.getMinX(), envelope.getMaxY()),\n        new Coordinate(envelope.getMaxX(), envelope.getMaxY()),\n        new Coordinate(envelope.getMaxX(), envelope.getMinY()),\n        new Coordinate(envelope.getMinX(), envelope.getMinY())\n    ]), null);\n};\nGeometryFactory.prototype.createLineString = function createLineString(coordinates) {\n    if (!coordinates) {\n        return new LineString(this.getCoordinateSequenceFactory().create([]), this);\n    } else if (coordinates instanceof Array) {\n        return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this);\n    } else if (hasInterface(coordinates, CoordinateSequence)) {\n        return new LineString(coordinates, this);\n    }\n};\nGeometryFactory.prototype.createMultiLineString = function createMultiLineString() {\n    if (arguments.length === 0) {\n        return new MultiLineString(null, this);\n    } else if (arguments.length === 1) {\n        var lineStrings = arguments[0];\n        return new MultiLineString(lineStrings, this);\n    }\n};\nGeometryFactory.prototype.buildGeometry = function buildGeometry(geomList) {\n    var geomClass = null;\n    var isHeterogeneous = false;\n    var hasGeometryCollection = false;\n    for(var i = geomList.iterator(); i.hasNext();){\n        var geom = i.next();\n        var partClass = geom.getClass();\n        if (geomClass === null) {\n            geomClass = partClass;\n        }\n        if (partClass !== geomClass) {\n            isHeterogeneous = true;\n        }\n        if (geom.isGeometryCollectionOrDerived()) {\n            hasGeometryCollection = true;\n        }\n    }\n    if (geomClass === null) {\n        return this.createGeometryCollection();\n    }\n    if (isHeterogeneous || hasGeometryCollection) {\n        return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n    }\n    var geom0 = geomList.iterator().next();\n    var isCollection = geomList.size() > 1;\n    if (isCollection) {\n        if (geom0 instanceof Polygon) {\n            return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n        } else if (geom0 instanceof LineString) {\n            return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n        } else if (geom0 instanceof Point) {\n            return this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n        }\n        Assert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n    }\n    return geom0;\n};\nGeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords(coordinates) {\n    return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n};\nGeometryFactory.prototype.createPoint = function createPoint() {\n    if (arguments.length === 0) {\n        return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n            var coordinate = arguments[0];\n            return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([\n                coordinate\n            ]) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordinates = arguments[0];\n            return new Point(coordinates, this);\n        }\n    }\n};\nGeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory() {\n    return this._coordinateSequenceFactory;\n};\nGeometryFactory.prototype.createPolygon = function createPolygon() {\n    if (arguments.length === 0) {\n        return new Polygon(null, null, this);\n    } else if (arguments.length === 1) {\n        if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordinates = arguments[0];\n            return this.createPolygon(this.createLinearRing(coordinates));\n        } else if (arguments[0] instanceof Array) {\n            var coordinates$1 = arguments[0];\n            return this.createPolygon(this.createLinearRing(coordinates$1));\n        } else if (arguments[0] instanceof LinearRing) {\n            var shell = arguments[0];\n            return this.createPolygon(shell, null);\n        }\n    } else if (arguments.length === 2) {\n        var shell$1 = arguments[0];\n        var holes = arguments[1];\n        return new Polygon(shell$1, holes, this);\n    }\n};\nGeometryFactory.prototype.getSRID = function getSRID() {\n    return this._SRID;\n};\nGeometryFactory.prototype.createGeometryCollection = function createGeometryCollection() {\n    if (arguments.length === 0) {\n        return new GeometryCollection(null, this);\n    } else if (arguments.length === 1) {\n        var geometries = arguments[0];\n        return new GeometryCollection(geometries, this);\n    }\n};\nGeometryFactory.prototype.createGeometry = function createGeometry(g) {\n    var editor = new GeometryEditor(this);\n    return editor.edit(g, {\n        edit: function() {\n            if (arguments.length === 2) {\n                var coordSeq = arguments[0];\n                // const geometry = arguments[1]\n                return this._coordinateSequenceFactory.create(coordSeq);\n            }\n        }\n    });\n};\nGeometryFactory.prototype.getPrecisionModel = function getPrecisionModel() {\n    return this._precisionModel;\n};\nGeometryFactory.prototype.createLinearRing = function createLinearRing() {\n    if (arguments.length === 0) {\n        return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n            var coordinates = arguments[0];\n            return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordinates$1 = arguments[0];\n            return new LinearRing(coordinates$1, this);\n        }\n    }\n};\nGeometryFactory.prototype.createMultiPolygon = function createMultiPolygon() {\n    if (arguments.length === 0) {\n        return new MultiPolygon(null, this);\n    } else if (arguments.length === 1) {\n        var polygons = arguments[0];\n        return new MultiPolygon(polygons, this);\n    }\n};\nGeometryFactory.prototype.createMultiPoint = function createMultiPoint() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        return new MultiPoint(null, this);\n    } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n            var point = arguments[0];\n            return new MultiPoint(point, this);\n        } else if (arguments[0] instanceof Array) {\n            var coordinates = arguments[0];\n            return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n            var coordinates$1 = arguments[0];\n            if (coordinates$1 === null) {\n                return this.createMultiPoint(new Array(0).fill(null));\n            }\n            var points = new Array(coordinates$1.size()).fill(null);\n            for(var i = 0; i < coordinates$1.size(); i++){\n                var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());\n                CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);\n                points[i] = this$1.createPoint(ptSeq);\n            }\n            return this.createMultiPoint(points);\n        }\n    }\n};\nGeometryFactory.prototype.interfaces_ = function interfaces_() {\n    return [\n        Serializable\n    ];\n};\nGeometryFactory.prototype.getClass = function getClass() {\n    return GeometryFactory;\n};\nGeometryFactory.toMultiPolygonArray = function toMultiPolygonArray(multiPolygons) {\n    var multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n    return multiPolygons.toArray(multiPolygonArray);\n};\nGeometryFactory.toGeometryArray = function toGeometryArray(geometries) {\n    if (geometries === null) {\n        return null;\n    }\n    var geometryArray = new Array(geometries.size()).fill(null);\n    return geometries.toArray(geometryArray);\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory() {\n    return CoordinateArraySequenceFactory.instance();\n};\nGeometryFactory.toMultiLineStringArray = function toMultiLineStringArray(multiLineStrings) {\n    var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n    return multiLineStrings.toArray(multiLineStringArray);\n};\nGeometryFactory.toLineStringArray = function toLineStringArray(lineStrings) {\n    var lineStringArray = new Array(lineStrings.size()).fill(null);\n    return lineStrings.toArray(lineStringArray);\n};\nGeometryFactory.toMultiPointArray = function toMultiPointArray(multiPoints) {\n    var multiPointArray = new Array(multiPoints.size()).fill(null);\n    return multiPoints.toArray(multiPointArray);\n};\nGeometryFactory.toLinearRingArray = function toLinearRingArray(linearRings) {\n    var linearRingArray = new Array(linearRings.size()).fill(null);\n    return linearRings.toArray(linearRingArray);\n};\nGeometryFactory.toPointArray = function toPointArray(points) {\n    var pointArray = new Array(points.size()).fill(null);\n    return points.toArray(pointArray);\n};\nGeometryFactory.toPolygonArray = function toPolygonArray(polygons) {\n    var polygonArray = new Array(polygons.size()).fill(null);\n    return polygons.toArray(polygonArray);\n};\nGeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord(coord, exemplar) {\n    exemplar.getPrecisionModel().makePrecise(coord);\n    return exemplar.getFactory().createPoint(coord);\n};\nstaticAccessors$2.serialVersionUID.get = function() {\n    return -6820524753094095635;\n};\nObject.defineProperties(GeometryFactory, staticAccessors$2);\nvar geometryTypes = [\n    \"Point\",\n    \"MultiPoint\",\n    \"LineString\",\n    \"MultiLineString\",\n    \"Polygon\",\n    \"MultiPolygon\"\n];\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */ /**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */ var GeoJSONParser = function GeoJSONParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n *\n * @param {}\n *        A GeoJSON object.\n * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n * @private\n */ GeoJSONParser.prototype.read = function read(json) {\n    var obj;\n    if (typeof json === \"string\") {\n        obj = JSON.parse(json);\n    } else {\n        obj = json;\n    }\n    var type = obj.type;\n    if (!parse[type]) {\n        throw new Error(\"Unknown GeoJSON type: \" + obj.type);\n    }\n    if (geometryTypes.indexOf(type) !== -1) {\n        return parse[type].apply(this, [\n            obj.coordinates\n        ]);\n    } else if (type === \"GeometryCollection\") {\n        return parse[type].apply(this, [\n            obj.geometries\n        ]);\n    }\n    // feature or feature collection\n    return parse[type].apply(this, [\n        obj\n    ]);\n};\n/**\n * Serialize a Geometry object into GeoJSON\n *\n * @param {Geometry}\n *        geometry A Geometry or array of Geometries.\n * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n * @private\n */ GeoJSONParser.prototype.write = function write(geometry) {\n    var type = geometry.getGeometryType();\n    if (!extract[type]) {\n        throw new Error(\"Geometry is not supported\");\n    }\n    return extract[type].apply(this, [\n        geometry\n    ]);\n};\nvar parse = {\n    /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */ Feature: function(obj) {\n        var feature = {};\n        // copy features\n        for(var key in obj){\n            feature[key] = obj[key];\n        }\n        // parse geometry\n        if (obj.geometry) {\n            var type = obj.geometry.type;\n            if (!parse[type]) {\n                throw new Error(\"Unknown GeoJSON type: \" + obj.type);\n            }\n            feature.geometry = this.read(obj.geometry);\n        }\n        // bbox\n        if (obj.bbox) {\n            feature.bbox = parse.bbox.apply(this, [\n                obj.bbox\n            ]);\n        }\n        return feature;\n    },\n    /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */ FeatureCollection: function(obj) {\n        var this$1 = this;\n        var featureCollection = {};\n        if (obj.features) {\n            featureCollection.features = [];\n            for(var i = 0; i < obj.features.length; ++i){\n                featureCollection.features.push(this$1.read(obj.features[i]));\n            }\n        }\n        if (obj.bbox) {\n            featureCollection.bbox = this.parse.bbox.apply(this, [\n                obj.bbox\n            ]);\n        }\n        return featureCollection;\n    },\n    /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */ coordinates: function(array) {\n        var coordinates = [];\n        for(var i = 0; i < array.length; ++i){\n            var sub = array[i];\n            coordinates.push(new Coordinate(sub[0], sub[1]));\n        }\n        return coordinates;\n    },\n    /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */ bbox: function(array) {\n        return this.geometryFactory.createLinearRing([\n            new Coordinate(array[0], array[1]),\n            new Coordinate(array[2], array[1]),\n            new Coordinate(array[2], array[3]),\n            new Coordinate(array[0], array[3]),\n            new Coordinate(array[0], array[1])\n        ]);\n    },\n    /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */ Point: function(array) {\n        var coordinate = new Coordinate(array[0], array[1]);\n        return this.geometryFactory.createPoint(coordinate);\n    },\n    /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */ MultiPoint: function(array) {\n        var this$1 = this;\n        var points = [];\n        for(var i = 0; i < array.length; ++i){\n            points.push(parse.Point.apply(this$1, [\n                array[i]\n            ]));\n        }\n        return this.geometryFactory.createMultiPoint(points);\n    },\n    /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */ LineString: function(array) {\n        var coordinates = parse.coordinates.apply(this, [\n            array\n        ]);\n        return this.geometryFactory.createLineString(coordinates);\n    },\n    /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */ MultiLineString: function(array) {\n        var this$1 = this;\n        var lineStrings = [];\n        for(var i = 0; i < array.length; ++i){\n            lineStrings.push(parse.LineString.apply(this$1, [\n                array[i]\n            ]));\n        }\n        return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */ Polygon: function(array) {\n        var this$1 = this;\n        var shellCoordinates = parse.coordinates.apply(this, [\n            array[0]\n        ]);\n        var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n        var holes = [];\n        for(var i = 1; i < array.length; ++i){\n            var hole = array[i];\n            var coordinates = parse.coordinates.apply(this$1, [\n                hole\n            ]);\n            var linearRing = this$1.geometryFactory.createLinearRing(coordinates);\n            holes.push(linearRing);\n        }\n        return this.geometryFactory.createPolygon(shell, holes);\n    },\n    /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */ MultiPolygon: function(array) {\n        var this$1 = this;\n        var polygons = [];\n        for(var i = 0; i < array.length; ++i){\n            var polygon = array[i];\n            polygons.push(parse.Polygon.apply(this$1, [\n                polygon\n            ]));\n        }\n        return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */ GeometryCollection: function(array) {\n        var this$1 = this;\n        var geometries = [];\n        for(var i = 0; i < array.length; ++i){\n            var geometry = array[i];\n            geometries.push(this$1.read(geometry));\n        }\n        return this.geometryFactory.createGeometryCollection(geometries);\n    }\n};\nvar extract = {\n    /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */ coordinate: function(coordinate) {\n        return [\n            coordinate.x,\n            coordinate.y\n        ];\n    },\n    /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */ Point: function(point) {\n        var array = extract.coordinate.apply(this, [\n            point.getCoordinate()\n        ]);\n        return {\n            type: \"Point\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */ MultiPoint: function(multipoint) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0; i < multipoint._geometries.length; ++i){\n            var point = multipoint._geometries[i];\n            var geoJson = extract.Point.apply(this$1, [\n                point\n            ]);\n            array.push(geoJson.coordinates);\n        }\n        return {\n            type: \"MultiPoint\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */ LineString: function(linestring) {\n        var this$1 = this;\n        var array = [];\n        var coordinates = linestring.getCoordinates();\n        for(var i = 0; i < coordinates.length; ++i){\n            var coordinate = coordinates[i];\n            array.push(extract.coordinate.apply(this$1, [\n                coordinate\n            ]));\n        }\n        return {\n            type: \"LineString\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */ MultiLineString: function(multilinestring) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0; i < multilinestring._geometries.length; ++i){\n            var linestring = multilinestring._geometries[i];\n            var geoJson = extract.LineString.apply(this$1, [\n                linestring\n            ]);\n            array.push(geoJson.coordinates);\n        }\n        return {\n            type: \"MultiLineString\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */ Polygon: function(polygon) {\n        var this$1 = this;\n        var array = [];\n        var shellGeoJson = extract.LineString.apply(this, [\n            polygon._shell\n        ]);\n        array.push(shellGeoJson.coordinates);\n        for(var i = 0; i < polygon._holes.length; ++i){\n            var hole = polygon._holes[i];\n            var holeGeoJson = extract.LineString.apply(this$1, [\n                hole\n            ]);\n            array.push(holeGeoJson.coordinates);\n        }\n        return {\n            type: \"Polygon\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */ MultiPolygon: function(multipolygon) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0; i < multipolygon._geometries.length; ++i){\n            var polygon = multipolygon._geometries[i];\n            var geoJson = extract.Polygon.apply(this$1, [\n                polygon\n            ]);\n            array.push(geoJson.coordinates);\n        }\n        return {\n            type: \"MultiPolygon\",\n            coordinates: array\n        };\n    },\n    /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */ GeometryCollection: function(collection) {\n        var this$1 = this;\n        var array = [];\n        for(var i = 0; i < collection._geometries.length; ++i){\n            var geometry = collection._geometries[i];\n            var type = geometry.getGeometryType();\n            array.push(extract[type].apply(this$1, [\n                geometry\n            ]));\n        }\n        return {\n            type: \"GeometryCollection\",\n            geometries: array\n        };\n    }\n};\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */ /**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */ var GeoJSONReader = function GeoJSONReader(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n    this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Reads a GeoJSON representation of a {@link Geometry}\n *\n * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n *\n * @param {Object|String} geoJson a GeoJSON Object or String.\n * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n * @memberof GeoJSONReader\n */ GeoJSONReader.prototype.read = function read(geoJson) {\n    var geometry = this.parser.read(geoJson);\n    if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n        this.reducePrecision(geometry);\n    }\n    return geometry;\n};\n// NOTE: this is a hack\nGeoJSONReader.prototype.reducePrecision = function reducePrecision(geometry) {\n    var this$1 = this;\n    var i, len;\n    if (geometry.coordinate) {\n        this.precisionModel.makePrecise(geometry.coordinate);\n    } else if (geometry.points) {\n        for(i = 0, len = geometry.points.length; i < len; i++){\n            this$1.precisionModel.makePrecise(geometry.points[i]);\n        }\n    } else if (geometry.geometries) {\n        for(i = 0, len = geometry.geometries.length; i < len; i++){\n            this$1.reducePrecision(geometry.geometries[i]);\n        }\n    }\n};\n/**\n * @module GeoJSONWriter\n */ /**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */ /**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */ var GeoJSONWriter = function GeoJSONWriter() {\n    this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Converts a <code>Geometry</code> to its GeoJSON representation.\n *\n * @param {Geometry}\n *        geometry a <code>Geometry</code> to process.\n * @return {Object} The GeoJSON representation of the Geometry.\n * @memberof GeoJSONWriter\n */ GeoJSONWriter.prototype.write = function write(geometry) {\n    return this.parser.write(geometry);\n};\n/* eslint-disable no-undef */ // io\nvar Position = function Position() {};\nvar staticAccessors$20 = {\n    ON: {\n        configurable: true\n    },\n    LEFT: {\n        configurable: true\n    },\n    RIGHT: {\n        configurable: true\n    }\n};\nPosition.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPosition.prototype.getClass = function getClass() {\n    return Position;\n};\nPosition.opposite = function opposite(position) {\n    if (position === Position.LEFT) {\n        return Position.RIGHT;\n    }\n    if (position === Position.RIGHT) {\n        return Position.LEFT;\n    }\n    return position;\n};\nstaticAccessors$20.ON.get = function() {\n    return 0;\n};\nstaticAccessors$20.LEFT.get = function() {\n    return 1;\n};\nstaticAccessors$20.RIGHT.get = function() {\n    return 2;\n};\nObject.defineProperties(Position, staticAccessors$20);\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */ function EmptyStackException(message) {\n    this.message = message || \"\";\n}\nEmptyStackException.prototype = new Error();\n/**\n * @type {string}\n */ EmptyStackException.prototype.name = \"EmptyStackException\";\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */ function Stack() {\n    /**\n   * @type {Array}\n   * @private\n   */ this.array_ = [];\n}\nStack.prototype = new List();\n/**\n * @override\n */ Stack.prototype.add = function(e) {\n    this.array_.push(e);\n    return true;\n};\n/**\n * @override\n */ Stack.prototype.get = function(index) {\n    if (index < 0 || index >= this.size()) {\n        throw new Error();\n    }\n    return this.array_[index];\n};\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */ Stack.prototype.push = function(e) {\n    this.array_.push(e);\n    return e;\n};\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */ Stack.prototype.pop = function(e) {\n    if (this.array_.length === 0) {\n        throw new EmptyStackException();\n    }\n    return this.array_.pop();\n};\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */ Stack.prototype.peek = function() {\n    if (this.array_.length === 0) {\n        throw new EmptyStackException();\n    }\n    return this.array_[this.array_.length - 1];\n};\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */ Stack.prototype.empty = function() {\n    if (this.array_.length === 0) {\n        return true;\n    } else {\n        return false;\n    }\n};\n/**\n * @return {boolean}\n */ Stack.prototype.isEmpty = function() {\n    return this.empty();\n};\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */ Stack.prototype.search = function(o) {\n    return this.array_.indexOf(o);\n};\n/**\n * @return {number}\n * @export\n */ Stack.prototype.size = function() {\n    return this.array_.length;\n};\n/**\n * @return {Array}\n */ Stack.prototype.toArray = function() {\n    var this$1 = this;\n    var array = [];\n    for(var i = 0, len = this.array_.length; i < len; i++){\n        array.push(this$1.array_[i]);\n    }\n    return array;\n};\nvar RightmostEdgeFinder = function RightmostEdgeFinder() {\n    this._minIndex = -1;\n    this._minCoord = null;\n    this._minDe = null;\n    this._orientedDe = null;\n};\nRightmostEdgeFinder.prototype.getCoordinate = function getCoordinate() {\n    return this._minCoord;\n};\nRightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide(de, index) {\n    var side = this.getRightmostSideOfSegment(de, index);\n    if (side < 0) {\n        side = this.getRightmostSideOfSegment(de, index - 1);\n    }\n    if (side < 0) {\n        this._minCoord = null;\n        this.checkForRightmostCoordinate(de);\n    }\n    return side;\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex() {\n    var pts = this._minDe.getEdge().getCoordinates();\n    Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n    var pPrev = pts[this._minIndex - 1];\n    var pNext = pts[this._minIndex + 1];\n    var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n    var usePrev = false;\n    if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n        usePrev = true;\n    } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n        usePrev = true;\n    }\n    if (usePrev) {\n        this._minIndex = this._minIndex - 1;\n    }\n};\nRightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment(de, i) {\n    var e = de.getEdge();\n    var coord = e.getCoordinates();\n    if (i < 0 || i + 1 >= coord.length) {\n        return -1;\n    }\n    if (coord[i].y === coord[i + 1].y) {\n        return -1;\n    }\n    var pos = Position.LEFT;\n    if (coord[i].y < coord[i + 1].y) {\n        pos = Position.RIGHT;\n    }\n    return pos;\n};\nRightmostEdgeFinder.prototype.getEdge = function getEdge() {\n    return this._orientedDe;\n};\nRightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate(de) {\n    var this$1 = this;\n    var coord = de.getEdge().getCoordinates();\n    for(var i = 0; i < coord.length - 1; i++){\n        if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {\n            this$1._minDe = de;\n            this$1._minIndex = i;\n            this$1._minCoord = coord[i];\n        }\n    }\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode() {\n    var node = this._minDe.getNode();\n    var star = node.getEdges();\n    this._minDe = star.getRightmostEdge();\n    if (!this._minDe.isForward()) {\n        this._minDe = this._minDe.getSym();\n        this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n    }\n};\nRightmostEdgeFinder.prototype.findEdge = function findEdge(dirEdgeList) {\n    var this$1 = this;\n    for(var i = dirEdgeList.iterator(); i.hasNext();){\n        var de = i.next();\n        if (!de.isForward()) {\n            continue;\n        }\n        this$1.checkForRightmostCoordinate(de);\n    }\n    Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n    if (this._minIndex === 0) {\n        this.findRightmostEdgeAtNode();\n    } else {\n        this.findRightmostEdgeAtVertex();\n    }\n    this._orientedDe = this._minDe;\n    var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n    if (rightmostSide === Position.LEFT) {\n        this._orientedDe = this._minDe.getSym();\n    }\n};\nRightmostEdgeFinder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nRightmostEdgeFinder.prototype.getClass = function getClass() {\n    return RightmostEdgeFinder;\n};\nvar TopologyException = function(RuntimeException$$1) {\n    function TopologyException(msg, pt) {\n        RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));\n        this.pt = pt ? new Coordinate(pt) : null;\n        this.name = \"TopologyException\";\n    }\n    if (RuntimeException$$1) TopologyException.__proto__ = RuntimeException$$1;\n    TopologyException.prototype = Object.create(RuntimeException$$1 && RuntimeException$$1.prototype);\n    TopologyException.prototype.constructor = TopologyException;\n    TopologyException.prototype.getCoordinate = function getCoordinate() {\n        return this.pt;\n    };\n    TopologyException.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    TopologyException.prototype.getClass = function getClass() {\n        return TopologyException;\n    };\n    TopologyException.msgWithCoord = function msgWithCoord(msg, pt) {\n        if (!pt) {\n            return msg + \" [ \" + pt + \" ]\";\n        }\n        return msg;\n    };\n    return TopologyException;\n}(RuntimeException);\nvar LinkedList = function LinkedList() {\n    this.array_ = [];\n};\nLinkedList.prototype.addLast = function addLast(e) {\n    this.array_.push(e);\n};\nLinkedList.prototype.removeFirst = function removeFirst() {\n    return this.array_.shift();\n};\nLinkedList.prototype.isEmpty = function isEmpty() {\n    return this.array_.length === 0;\n};\nvar BufferSubgraph = function BufferSubgraph() {\n    this._finder = null;\n    this._dirEdgeList = new ArrayList();\n    this._nodes = new ArrayList();\n    this._rightMostCoord = null;\n    this._env = null;\n    this._finder = new RightmostEdgeFinder();\n};\nBufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges() {\n    for(var it = this._dirEdgeList.iterator(); it.hasNext();){\n        var de = it.next();\n        de.setVisited(false);\n    }\n};\nBufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate() {\n    return this._rightMostCoord;\n};\nBufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth(n) {\n    var this$1 = this;\n    var startEdge = null;\n    for(var i = n.getEdges().iterator(); i.hasNext();){\n        var de = i.next();\n        if (de.isVisited() || de.getSym().isVisited()) {\n            startEdge = de;\n            break;\n        }\n    }\n    if (startEdge === null) {\n        throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n    }\n    n.getEdges().computeDepths(startEdge);\n    for(var i$1 = n.getEdges().iterator(); i$1.hasNext();){\n        var de$1 = i$1.next();\n        de$1.setVisited(true);\n        this$1.copySymDepths(de$1);\n    }\n};\nBufferSubgraph.prototype.computeDepth = function computeDepth(outsideDepth) {\n    this.clearVisitedEdges();\n    var de = this._finder.getEdge();\n    // const n = de.getNode()\n    // const label = de.getLabel()\n    de.setEdgeDepths(Position.RIGHT, outsideDepth);\n    this.copySymDepths(de);\n    this.computeDepths(de);\n};\nBufferSubgraph.prototype.create = function create(node) {\n    this.addReachable(node);\n    this._finder.findEdge(this._dirEdgeList);\n    this._rightMostCoord = this._finder.getCoordinate();\n};\nBufferSubgraph.prototype.findResultEdges = function findResultEdges() {\n    for(var it = this._dirEdgeList.iterator(); it.hasNext();){\n        var de = it.next();\n        if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n            de.setInResult(true);\n        }\n    }\n};\nBufferSubgraph.prototype.computeDepths = function computeDepths(startEdge) {\n    var this$1 = this;\n    var nodesVisited = new HashSet();\n    var nodeQueue = new LinkedList();\n    var startNode = startEdge.getNode();\n    nodeQueue.addLast(startNode);\n    nodesVisited.add(startNode);\n    startEdge.setVisited(true);\n    while(!nodeQueue.isEmpty()){\n        var n = nodeQueue.removeFirst();\n        nodesVisited.add(n);\n        this$1.computeNodeDepth(n);\n        for(var i = n.getEdges().iterator(); i.hasNext();){\n            var de = i.next();\n            var sym = de.getSym();\n            if (sym.isVisited()) {\n                continue;\n            }\n            var adjNode = sym.getNode();\n            if (!nodesVisited.contains(adjNode)) {\n                nodeQueue.addLast(adjNode);\n                nodesVisited.add(adjNode);\n            }\n        }\n    }\n};\nBufferSubgraph.prototype.compareTo = function compareTo(o) {\n    var graph = o;\n    if (this._rightMostCoord.x < graph._rightMostCoord.x) {\n        return -1;\n    }\n    if (this._rightMostCoord.x > graph._rightMostCoord.x) {\n        return 1;\n    }\n    return 0;\n};\nBufferSubgraph.prototype.getEnvelope = function getEnvelope() {\n    if (this._env === null) {\n        var edgeEnv = new Envelope();\n        for(var it = this._dirEdgeList.iterator(); it.hasNext();){\n            var dirEdge = it.next();\n            var pts = dirEdge.getEdge().getCoordinates();\n            for(var i = 0; i < pts.length - 1; i++){\n                edgeEnv.expandToInclude(pts[i]);\n            }\n        }\n        this._env = edgeEnv;\n    }\n    return this._env;\n};\nBufferSubgraph.prototype.addReachable = function addReachable(startNode) {\n    var this$1 = this;\n    var nodeStack = new Stack();\n    nodeStack.add(startNode);\n    while(!nodeStack.empty()){\n        var node = nodeStack.pop();\n        this$1.add(node, nodeStack);\n    }\n};\nBufferSubgraph.prototype.copySymDepths = function copySymDepths(de) {\n    var sym = de.getSym();\n    sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n    sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n};\nBufferSubgraph.prototype.add = function add(node, nodeStack) {\n    var this$1 = this;\n    node.setVisited(true);\n    this._nodes.add(node);\n    for(var i = node.getEdges().iterator(); i.hasNext();){\n        var de = i.next();\n        this$1._dirEdgeList.add(de);\n        var sym = de.getSym();\n        var symNode = sym.getNode();\n        if (!symNode.isVisited()) {\n            nodeStack.push(symNode);\n        }\n    }\n};\nBufferSubgraph.prototype.getNodes = function getNodes() {\n    return this._nodes;\n};\nBufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges() {\n    return this._dirEdgeList;\n};\nBufferSubgraph.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nBufferSubgraph.prototype.getClass = function getClass() {\n    return BufferSubgraph;\n};\nvar TopologyLocation = function TopologyLocation() {\n    var this$1 = this;\n    this.location = null;\n    if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n            var location = arguments[0];\n            this.init(location.length);\n        } else if (Number.isInteger(arguments[0])) {\n            var on = arguments[0];\n            this.init(1);\n            this.location[Position.ON] = on;\n        } else if (arguments[0] instanceof TopologyLocation) {\n            var gl = arguments[0];\n            this.init(gl.location.length);\n            if (gl !== null) {\n                for(var i = 0; i < this.location.length; i++){\n                    this$1.location[i] = gl.location[i];\n                }\n            }\n        }\n    } else if (arguments.length === 3) {\n        var on$1 = arguments[0];\n        var left = arguments[1];\n        var right = arguments[2];\n        this.init(3);\n        this.location[Position.ON] = on$1;\n        this.location[Position.LEFT] = left;\n        this.location[Position.RIGHT] = right;\n    }\n};\nTopologyLocation.prototype.setAllLocations = function setAllLocations(locValue) {\n    var this$1 = this;\n    for(var i = 0; i < this.location.length; i++){\n        this$1.location[i] = locValue;\n    }\n};\nTopologyLocation.prototype.isNull = function isNull() {\n    var this$1 = this;\n    for(var i = 0; i < this.location.length; i++){\n        if (this$1.location[i] !== Location.NONE) {\n            return false;\n        }\n    }\n    return true;\n};\nTopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull(locValue) {\n    var this$1 = this;\n    for(var i = 0; i < this.location.length; i++){\n        if (this$1.location[i] === Location.NONE) {\n            this$1.location[i] = locValue;\n        }\n    }\n};\nTopologyLocation.prototype.isLine = function isLine() {\n    return this.location.length === 1;\n};\nTopologyLocation.prototype.merge = function merge(gl) {\n    var this$1 = this;\n    if (gl.location.length > this.location.length) {\n        var newLoc = new Array(3).fill(null);\n        newLoc[Position.ON] = this.location[Position.ON];\n        newLoc[Position.LEFT] = Location.NONE;\n        newLoc[Position.RIGHT] = Location.NONE;\n        this.location = newLoc;\n    }\n    for(var i = 0; i < this.location.length; i++){\n        if (this$1.location[i] === Location.NONE && i < gl.location.length) {\n            this$1.location[i] = gl.location[i];\n        }\n    }\n};\nTopologyLocation.prototype.getLocations = function getLocations() {\n    return this.location;\n};\nTopologyLocation.prototype.flip = function flip() {\n    if (this.location.length <= 1) {\n        return null;\n    }\n    var temp = this.location[Position.LEFT];\n    this.location[Position.LEFT] = this.location[Position.RIGHT];\n    this.location[Position.RIGHT] = temp;\n};\nTopologyLocation.prototype.toString = function toString() {\n    var buf = new StringBuffer();\n    if (this.location.length > 1) {\n        buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n    }\n    buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n    if (this.location.length > 1) {\n        buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n    }\n    return buf.toString();\n};\nTopologyLocation.prototype.setLocations = function setLocations(on, left, right) {\n    this.location[Position.ON] = on;\n    this.location[Position.LEFT] = left;\n    this.location[Position.RIGHT] = right;\n};\nTopologyLocation.prototype.get = function get(posIndex) {\n    if (posIndex < this.location.length) {\n        return this.location[posIndex];\n    }\n    return Location.NONE;\n};\nTopologyLocation.prototype.isArea = function isArea() {\n    return this.location.length > 1;\n};\nTopologyLocation.prototype.isAnyNull = function isAnyNull() {\n    var this$1 = this;\n    for(var i = 0; i < this.location.length; i++){\n        if (this$1.location[i] === Location.NONE) {\n            return true;\n        }\n    }\n    return false;\n};\nTopologyLocation.prototype.setLocation = function setLocation() {\n    if (arguments.length === 1) {\n        var locValue = arguments[0];\n        this.setLocation(Position.ON, locValue);\n    } else if (arguments.length === 2) {\n        var locIndex = arguments[0];\n        var locValue$1 = arguments[1];\n        this.location[locIndex] = locValue$1;\n    }\n};\nTopologyLocation.prototype.init = function init(size) {\n    this.location = new Array(size).fill(null);\n    this.setAllLocations(Location.NONE);\n};\nTopologyLocation.prototype.isEqualOnSide = function isEqualOnSide(le, locIndex) {\n    return this.location[locIndex] === le.location[locIndex];\n};\nTopologyLocation.prototype.allPositionsEqual = function allPositionsEqual(loc) {\n    var this$1 = this;\n    for(var i = 0; i < this.location.length; i++){\n        if (this$1.location[i] !== loc) {\n            return false;\n        }\n    }\n    return true;\n};\nTopologyLocation.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nTopologyLocation.prototype.getClass = function getClass() {\n    return TopologyLocation;\n};\nvar Label = function Label() {\n    this.elt = new Array(2).fill(null);\n    if (arguments.length === 1) {\n        if (Number.isInteger(arguments[0])) {\n            var onLoc = arguments[0];\n            this.elt[0] = new TopologyLocation(onLoc);\n            this.elt[1] = new TopologyLocation(onLoc);\n        } else if (arguments[0] instanceof Label) {\n            var lbl = arguments[0];\n            this.elt[0] = new TopologyLocation(lbl.elt[0]);\n            this.elt[1] = new TopologyLocation(lbl.elt[1]);\n        }\n    } else if (arguments.length === 2) {\n        var geomIndex = arguments[0];\n        var onLoc$1 = arguments[1];\n        this.elt[0] = new TopologyLocation(Location.NONE);\n        this.elt[1] = new TopologyLocation(Location.NONE);\n        this.elt[geomIndex].setLocation(onLoc$1);\n    } else if (arguments.length === 3) {\n        var onLoc$2 = arguments[0];\n        var leftLoc = arguments[1];\n        var rightLoc = arguments[2];\n        this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n        this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n    } else if (arguments.length === 4) {\n        var geomIndex$1 = arguments[0];\n        var onLoc$3 = arguments[1];\n        var leftLoc$1 = arguments[2];\n        var rightLoc$1 = arguments[3];\n        this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n        this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n        this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);\n    }\n};\nLabel.prototype.getGeometryCount = function getGeometryCount() {\n    var count = 0;\n    if (!this.elt[0].isNull()) {\n        count++;\n    }\n    if (!this.elt[1].isNull()) {\n        count++;\n    }\n    return count;\n};\nLabel.prototype.setAllLocations = function setAllLocations(geomIndex, location) {\n    this.elt[geomIndex].setAllLocations(location);\n};\nLabel.prototype.isNull = function isNull(geomIndex) {\n    return this.elt[geomIndex].isNull();\n};\nLabel.prototype.setAllLocationsIfNull = function setAllLocationsIfNull() {\n    if (arguments.length === 1) {\n        var location = arguments[0];\n        this.setAllLocationsIfNull(0, location);\n        this.setAllLocationsIfNull(1, location);\n    } else if (arguments.length === 2) {\n        var geomIndex = arguments[0];\n        var location$1 = arguments[1];\n        this.elt[geomIndex].setAllLocationsIfNull(location$1);\n    }\n};\nLabel.prototype.isLine = function isLine(geomIndex) {\n    return this.elt[geomIndex].isLine();\n};\nLabel.prototype.merge = function merge(lbl) {\n    var this$1 = this;\n    for(var i = 0; i < 2; i++){\n        if (this$1.elt[i] === null && lbl.elt[i] !== null) {\n            this$1.elt[i] = new TopologyLocation(lbl.elt[i]);\n        } else {\n            this$1.elt[i].merge(lbl.elt[i]);\n        }\n    }\n};\nLabel.prototype.flip = function flip() {\n    this.elt[0].flip();\n    this.elt[1].flip();\n};\nLabel.prototype.getLocation = function getLocation() {\n    if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this.elt[geomIndex].get(Position.ON);\n    } else if (arguments.length === 2) {\n        var geomIndex$1 = arguments[0];\n        var posIndex = arguments[1];\n        return this.elt[geomIndex$1].get(posIndex);\n    }\n};\nLabel.prototype.toString = function toString() {\n    var buf = new StringBuffer();\n    if (this.elt[0] !== null) {\n        buf.append(\"A:\");\n        buf.append(this.elt[0].toString());\n    }\n    if (this.elt[1] !== null) {\n        buf.append(\" B:\");\n        buf.append(this.elt[1].toString());\n    }\n    return buf.toString();\n};\nLabel.prototype.isArea = function isArea() {\n    if (arguments.length === 0) {\n        return this.elt[0].isArea() || this.elt[1].isArea();\n    } else if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this.elt[geomIndex].isArea();\n    }\n};\nLabel.prototype.isAnyNull = function isAnyNull(geomIndex) {\n    return this.elt[geomIndex].isAnyNull();\n};\nLabel.prototype.setLocation = function setLocation() {\n    if (arguments.length === 2) {\n        var geomIndex = arguments[0];\n        var location = arguments[1];\n        this.elt[geomIndex].setLocation(Position.ON, location);\n    } else if (arguments.length === 3) {\n        var geomIndex$1 = arguments[0];\n        var posIndex = arguments[1];\n        var location$1 = arguments[2];\n        this.elt[geomIndex$1].setLocation(posIndex, location$1);\n    }\n};\nLabel.prototype.isEqualOnSide = function isEqualOnSide(lbl, side) {\n    return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n};\nLabel.prototype.allPositionsEqual = function allPositionsEqual(geomIndex, loc) {\n    return this.elt[geomIndex].allPositionsEqual(loc);\n};\nLabel.prototype.toLine = function toLine(geomIndex) {\n    if (this.elt[geomIndex].isArea()) {\n        this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n    }\n};\nLabel.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLabel.prototype.getClass = function getClass() {\n    return Label;\n};\nLabel.toLineLabel = function toLineLabel(label) {\n    var lineLabel = new Label(Location.NONE);\n    for(var i = 0; i < 2; i++){\n        lineLabel.setLocation(i, label.getLocation(i));\n    }\n    return lineLabel;\n};\nvar EdgeRing = function EdgeRing() {\n    this._startDe = null;\n    this._maxNodeDegree = -1;\n    this._edges = new ArrayList();\n    this._pts = new ArrayList();\n    this._label = new Label(Location.NONE);\n    this._ring = null;\n    this._isHole = null;\n    this._shell = null;\n    this._holes = new ArrayList();\n    this._geometryFactory = null;\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    this._geometryFactory = geometryFactory;\n    this.computePoints(start);\n    this.computeRing();\n};\nEdgeRing.prototype.computeRing = function computeRing() {\n    var this$1 = this;\n    if (this._ring !== null) {\n        return null;\n    }\n    var coord = new Array(this._pts.size()).fill(null);\n    for(var i = 0; i < this._pts.size(); i++){\n        coord[i] = this$1._pts.get(i);\n    }\n    this._ring = this._geometryFactory.createLinearRing(coord);\n    this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n};\nEdgeRing.prototype.isIsolated = function isIsolated() {\n    return this._label.getGeometryCount() === 1;\n};\nEdgeRing.prototype.computePoints = function computePoints(start) {\n    var this$1 = this;\n    this._startDe = start;\n    var de = start;\n    var isFirstEdge = true;\n    do {\n        if (de === null) {\n            throw new TopologyException(\"Found null DirectedEdge\");\n        }\n        if (de.getEdgeRing() === this$1) {\n            throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n        }\n        this$1._edges.add(de);\n        var label = de.getLabel();\n        Assert.isTrue(label.isArea());\n        this$1.mergeLabel(label);\n        this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n        isFirstEdge = false;\n        this$1.setEdgeRing(de, this$1);\n        de = this$1.getNext(de);\n    }while (de !== this._startDe);\n};\nEdgeRing.prototype.getLinearRing = function getLinearRing() {\n    return this._ring;\n};\nEdgeRing.prototype.getCoordinate = function getCoordinate(i) {\n    return this._pts.get(i);\n};\nEdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree() {\n    var this$1 = this;\n    this._maxNodeDegree = 0;\n    var de = this._startDe;\n    do {\n        var node = de.getNode();\n        var degree = node.getEdges().getOutgoingDegree(this$1);\n        if (degree > this$1._maxNodeDegree) {\n            this$1._maxNodeDegree = degree;\n        }\n        de = this$1.getNext(de);\n    }while (de !== this._startDe);\n    this._maxNodeDegree *= 2;\n};\nEdgeRing.prototype.addPoints = function addPoints(edge, isForward, isFirstEdge) {\n    var this$1 = this;\n    var edgePts = edge.getCoordinates();\n    if (isForward) {\n        var startIndex = 1;\n        if (isFirstEdge) {\n            startIndex = 0;\n        }\n        for(var i = startIndex; i < edgePts.length; i++){\n            this$1._pts.add(edgePts[i]);\n        }\n    } else {\n        var startIndex$1 = edgePts.length - 2;\n        if (isFirstEdge) {\n            startIndex$1 = edgePts.length - 1;\n        }\n        for(var i$1 = startIndex$1; i$1 >= 0; i$1--){\n            this$1._pts.add(edgePts[i$1]);\n        }\n    }\n};\nEdgeRing.prototype.isHole = function isHole() {\n    return this._isHole;\n};\nEdgeRing.prototype.setInResult = function setInResult() {\n    var de = this._startDe;\n    do {\n        de.getEdge().setInResult(true);\n        de = de.getNext();\n    }while (de !== this._startDe);\n};\nEdgeRing.prototype.containsPoint = function containsPoint(p) {\n    var shell = this.getLinearRing();\n    var env = shell.getEnvelopeInternal();\n    if (!env.contains(p)) {\n        return false;\n    }\n    if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) {\n        return false;\n    }\n    for(var i = this._holes.iterator(); i.hasNext();){\n        var hole = i.next();\n        if (hole.containsPoint(p)) {\n            return false;\n        }\n    }\n    return true;\n};\nEdgeRing.prototype.addHole = function addHole(ring) {\n    this._holes.add(ring);\n};\nEdgeRing.prototype.isShell = function isShell() {\n    return this._shell === null;\n};\nEdgeRing.prototype.getLabel = function getLabel() {\n    return this._label;\n};\nEdgeRing.prototype.getEdges = function getEdges() {\n    return this._edges;\n};\nEdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree() {\n    if (this._maxNodeDegree < 0) {\n        this.computeMaxNodeDegree();\n    }\n    return this._maxNodeDegree;\n};\nEdgeRing.prototype.getShell = function getShell() {\n    return this._shell;\n};\nEdgeRing.prototype.mergeLabel = function mergeLabel() {\n    if (arguments.length === 1) {\n        var deLabel = arguments[0];\n        this.mergeLabel(deLabel, 0);\n        this.mergeLabel(deLabel, 1);\n    } else if (arguments.length === 2) {\n        var deLabel$1 = arguments[0];\n        var geomIndex = arguments[1];\n        var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);\n        if (loc === Location.NONE) {\n            return null;\n        }\n        if (this._label.getLocation(geomIndex) === Location.NONE) {\n            this._label.setLocation(geomIndex, loc);\n            return null;\n        }\n    }\n};\nEdgeRing.prototype.setShell = function setShell(shell) {\n    this._shell = shell;\n    if (shell !== null) {\n        shell.addHole(this);\n    }\n};\nEdgeRing.prototype.toPolygon = function toPolygon(geometryFactory) {\n    var this$1 = this;\n    var holeLR = new Array(this._holes.size()).fill(null);\n    for(var i = 0; i < this._holes.size(); i++){\n        holeLR[i] = this$1._holes.get(i).getLinearRing();\n    }\n    var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n    return poly;\n};\nEdgeRing.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeRing.prototype.getClass = function getClass() {\n    return EdgeRing;\n};\nvar MinimalEdgeRing = function(EdgeRing$$1) {\n    function MinimalEdgeRing() {\n        var start = arguments[0];\n        var geometryFactory = arguments[1];\n        EdgeRing$$1.call(this, start, geometryFactory);\n    }\n    if (EdgeRing$$1) MinimalEdgeRing.__proto__ = EdgeRing$$1;\n    MinimalEdgeRing.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);\n    MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;\n    MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing(de, er) {\n        de.setMinEdgeRing(er);\n    };\n    MinimalEdgeRing.prototype.getNext = function getNext(de) {\n        return de.getNextMin();\n    };\n    MinimalEdgeRing.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    MinimalEdgeRing.prototype.getClass = function getClass() {\n        return MinimalEdgeRing;\n    };\n    return MinimalEdgeRing;\n}(EdgeRing);\nvar MaximalEdgeRing = function(EdgeRing$$1) {\n    function MaximalEdgeRing() {\n        var start = arguments[0];\n        var geometryFactory = arguments[1];\n        EdgeRing$$1.call(this, start, geometryFactory);\n    }\n    if (EdgeRing$$1) MaximalEdgeRing.__proto__ = EdgeRing$$1;\n    MaximalEdgeRing.prototype = Object.create(EdgeRing$$1 && EdgeRing$$1.prototype);\n    MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;\n    MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings() {\n        var this$1 = this;\n        var minEdgeRings = new ArrayList();\n        var de = this._startDe;\n        do {\n            if (de.getMinEdgeRing() === null) {\n                var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);\n                minEdgeRings.add(minEr);\n            }\n            de = de.getNext();\n        }while (de !== this._startDe);\n        return minEdgeRings;\n    };\n    MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing(de, er) {\n        de.setEdgeRing(er);\n    };\n    MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings() {\n        var this$1 = this;\n        var de = this._startDe;\n        do {\n            var node = de.getNode();\n            node.getEdges().linkMinimalDirectedEdges(this$1);\n            de = de.getNext();\n        }while (de !== this._startDe);\n    };\n    MaximalEdgeRing.prototype.getNext = function getNext(de) {\n        return de.getNext();\n    };\n    MaximalEdgeRing.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    MaximalEdgeRing.prototype.getClass = function getClass() {\n        return MaximalEdgeRing;\n    };\n    return MaximalEdgeRing;\n}(EdgeRing);\nvar GraphComponent = function GraphComponent() {\n    this._label = null;\n    this._isInResult = false;\n    this._isCovered = false;\n    this._isCoveredSet = false;\n    this._isVisited = false;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var label = arguments[0];\n        this._label = label;\n    }\n};\nGraphComponent.prototype.setVisited = function setVisited(isVisited) {\n    this._isVisited = isVisited;\n};\nGraphComponent.prototype.setInResult = function setInResult(isInResult) {\n    this._isInResult = isInResult;\n};\nGraphComponent.prototype.isCovered = function isCovered() {\n    return this._isCovered;\n};\nGraphComponent.prototype.isCoveredSet = function isCoveredSet() {\n    return this._isCoveredSet;\n};\nGraphComponent.prototype.setLabel = function setLabel(label) {\n    this._label = label;\n};\nGraphComponent.prototype.getLabel = function getLabel() {\n    return this._label;\n};\nGraphComponent.prototype.setCovered = function setCovered(isCovered) {\n    this._isCovered = isCovered;\n    this._isCoveredSet = true;\n};\nGraphComponent.prototype.updateIM = function updateIM(im) {\n    Assert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n    this.computeIM(im);\n};\nGraphComponent.prototype.isInResult = function isInResult() {\n    return this._isInResult;\n};\nGraphComponent.prototype.isVisited = function isVisited() {\n    return this._isVisited;\n};\nGraphComponent.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGraphComponent.prototype.getClass = function getClass() {\n    return GraphComponent;\n};\nvar Node = function(GraphComponent$$1) {\n    function Node() {\n        GraphComponent$$1.call(this);\n        this._coord = null;\n        this._edges = null;\n        var coord = arguments[0];\n        var edges = arguments[1];\n        this._coord = coord;\n        this._edges = edges;\n        this._label = new Label(0, Location.NONE);\n    }\n    if (GraphComponent$$1) Node.__proto__ = GraphComponent$$1;\n    Node.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);\n    Node.prototype.constructor = Node;\n    Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult() {\n        for(var it = this.getEdges().getEdges().iterator(); it.hasNext();){\n            var de = it.next();\n            if (de.getEdge().isInResult()) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Node.prototype.isIsolated = function isIsolated() {\n        return this._label.getGeometryCount() === 1;\n    };\n    Node.prototype.getCoordinate = function getCoordinate() {\n        return this._coord;\n    };\n    Node.prototype.print = function print(out) {\n        out.println(\"node \" + this._coord + \" lbl: \" + this._label);\n    };\n    Node.prototype.computeIM = function computeIM(im) {};\n    Node.prototype.computeMergedLocation = function computeMergedLocation(label2, eltIndex) {\n        var loc = Location.NONE;\n        loc = this._label.getLocation(eltIndex);\n        if (!label2.isNull(eltIndex)) {\n            var nLoc = label2.getLocation(eltIndex);\n            if (loc !== Location.BOUNDARY) {\n                loc = nLoc;\n            }\n        }\n        return loc;\n    };\n    Node.prototype.setLabel = function setLabel() {\n        if (arguments.length === 2) {\n            var argIndex = arguments[0];\n            var onLocation = arguments[1];\n            if (this._label === null) {\n                this._label = new Label(argIndex, onLocation);\n            } else {\n                this._label.setLocation(argIndex, onLocation);\n            }\n        } else {\n            return GraphComponent$$1.prototype.setLabel.apply(this, arguments);\n        }\n    };\n    Node.prototype.getEdges = function getEdges() {\n        return this._edges;\n    };\n    Node.prototype.mergeLabel = function mergeLabel() {\n        var this$1 = this;\n        if (arguments[0] instanceof Node) {\n            var n = arguments[0];\n            this.mergeLabel(n._label);\n        } else if (arguments[0] instanceof Label) {\n            var label2 = arguments[0];\n            for(var i = 0; i < 2; i++){\n                var loc = this$1.computeMergedLocation(label2, i);\n                var thisLoc = this$1._label.getLocation(i);\n                if (thisLoc === Location.NONE) {\n                    this$1._label.setLocation(i, loc);\n                }\n            }\n        }\n    };\n    Node.prototype.add = function add(e) {\n        this._edges.insert(e);\n        e.setNode(this);\n    };\n    Node.prototype.setLabelBoundary = function setLabelBoundary(argIndex) {\n        if (this._label === null) {\n            return null;\n        }\n        var loc = Location.NONE;\n        if (this._label !== null) {\n            loc = this._label.getLocation(argIndex);\n        }\n        var newLoc = null;\n        switch(loc){\n            case Location.BOUNDARY:\n                newLoc = Location.INTERIOR;\n                break;\n            case Location.INTERIOR:\n                newLoc = Location.BOUNDARY;\n                break;\n            default:\n                newLoc = Location.BOUNDARY;\n                break;\n        }\n        this._label.setLocation(argIndex, newLoc);\n    };\n    Node.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    Node.prototype.getClass = function getClass() {\n        return Node;\n    };\n    return Node;\n}(GraphComponent);\nvar NodeMap = function NodeMap() {\n    this.nodeMap = new TreeMap();\n    this.nodeFact = null;\n    var nodeFact = arguments[0];\n    this.nodeFact = nodeFact;\n};\nNodeMap.prototype.find = function find(coord) {\n    return this.nodeMap.get(coord);\n};\nNodeMap.prototype.addNode = function addNode() {\n    if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        var node = this.nodeMap.get(coord);\n        if (node === null) {\n            node = this.nodeFact.createNode(coord);\n            this.nodeMap.put(coord, node);\n        }\n        return node;\n    } else if (arguments[0] instanceof Node) {\n        var n = arguments[0];\n        var node$1 = this.nodeMap.get(n.getCoordinate());\n        if (node$1 === null) {\n            this.nodeMap.put(n.getCoordinate(), n);\n            return n;\n        }\n        node$1.mergeLabel(n);\n        return node$1;\n    }\n};\nNodeMap.prototype.print = function print(out) {\n    for(var it = this.iterator(); it.hasNext();){\n        var n = it.next();\n        n.print(out);\n    }\n};\nNodeMap.prototype.iterator = function iterator() {\n    return this.nodeMap.values().iterator();\n};\nNodeMap.prototype.values = function values() {\n    return this.nodeMap.values();\n};\nNodeMap.prototype.getBoundaryNodes = function getBoundaryNodes(geomIndex) {\n    var bdyNodes = new ArrayList();\n    for(var i = this.iterator(); i.hasNext();){\n        var node = i.next();\n        if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) {\n            bdyNodes.add(node);\n        }\n    }\n    return bdyNodes;\n};\nNodeMap.prototype.add = function add(e) {\n    var p = e.getCoordinate();\n    var n = this.addNode(p);\n    n.add(e);\n};\nNodeMap.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nNodeMap.prototype.getClass = function getClass() {\n    return NodeMap;\n};\nvar Quadrant = function Quadrant() {};\nvar staticAccessors$21 = {\n    NE: {\n        configurable: true\n    },\n    NW: {\n        configurable: true\n    },\n    SW: {\n        configurable: true\n    },\n    SE: {\n        configurable: true\n    }\n};\nQuadrant.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nQuadrant.prototype.getClass = function getClass() {\n    return Quadrant;\n};\nQuadrant.isNorthern = function isNorthern(quad) {\n    return quad === Quadrant.NE || quad === Quadrant.NW;\n};\nQuadrant.isOpposite = function isOpposite(quad1, quad2) {\n    if (quad1 === quad2) {\n        return false;\n    }\n    var diff = (quad1 - quad2 + 4) % 4;\n    if (diff === 2) {\n        return true;\n    }\n    return false;\n};\nQuadrant.commonHalfPlane = function commonHalfPlane(quad1, quad2) {\n    if (quad1 === quad2) {\n        return quad1;\n    }\n    var diff = (quad1 - quad2 + 4) % 4;\n    if (diff === 2) {\n        return -1;\n    }\n    var min = quad1 < quad2 ? quad1 : quad2;\n    var max = quad1 > quad2 ? quad1 : quad2;\n    if (min === 0 && max === 3) {\n        return 3;\n    }\n    return min;\n};\nQuadrant.isInHalfPlane = function isInHalfPlane(quad, halfPlane) {\n    if (halfPlane === Quadrant.SE) {\n        return quad === Quadrant.SE || quad === Quadrant.SW;\n    }\n    return quad === halfPlane || quad === halfPlane + 1;\n};\nQuadrant.quadrant = function quadrant() {\n    if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n        var dx = arguments[0];\n        var dy = arguments[1];\n        if (dx === 0.0 && dy === 0.0) {\n            throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n        }\n        if (dx >= 0.0) {\n            if (dy >= 0.0) {\n                return Quadrant.NE;\n            } else {\n                return Quadrant.SE;\n            }\n        } else {\n            if (dy >= 0.0) {\n                return Quadrant.NW;\n            } else {\n                return Quadrant.SW;\n            }\n        }\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        if (p1.x === p0.x && p1.y === p0.y) {\n            throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n        }\n        if (p1.x >= p0.x) {\n            if (p1.y >= p0.y) {\n                return Quadrant.NE;\n            } else {\n                return Quadrant.SE;\n            }\n        } else {\n            if (p1.y >= p0.y) {\n                return Quadrant.NW;\n            } else {\n                return Quadrant.SW;\n            }\n        }\n    }\n};\nstaticAccessors$21.NE.get = function() {\n    return 0;\n};\nstaticAccessors$21.NW.get = function() {\n    return 1;\n};\nstaticAccessors$21.SW.get = function() {\n    return 2;\n};\nstaticAccessors$21.SE.get = function() {\n    return 3;\n};\nObject.defineProperties(Quadrant, staticAccessors$21);\nvar EdgeEnd = function EdgeEnd() {\n    this._edge = null;\n    this._label = null;\n    this._node = null;\n    this._p0 = null;\n    this._p1 = null;\n    this._dx = null;\n    this._dy = null;\n    this._quadrant = null;\n    if (arguments.length === 1) {\n        var edge = arguments[0];\n        this._edge = edge;\n    } else if (arguments.length === 3) {\n        var edge$1 = arguments[0];\n        var p0 = arguments[1];\n        var p1 = arguments[2];\n        var label = null;\n        this._edge = edge$1;\n        this.init(p0, p1);\n        this._label = label;\n    } else if (arguments.length === 4) {\n        var edge$2 = arguments[0];\n        var p0$1 = arguments[1];\n        var p1$1 = arguments[2];\n        var label$1 = arguments[3];\n        this._edge = edge$2;\n        this.init(p0$1, p1$1);\n        this._label = label$1;\n    }\n};\nEdgeEnd.prototype.compareDirection = function compareDirection(e) {\n    if (this._dx === e._dx && this._dy === e._dy) {\n        return 0;\n    }\n    if (this._quadrant > e._quadrant) {\n        return 1;\n    }\n    if (this._quadrant < e._quadrant) {\n        return -1;\n    }\n    return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1);\n};\nEdgeEnd.prototype.getDy = function getDy() {\n    return this._dy;\n};\nEdgeEnd.prototype.getCoordinate = function getCoordinate() {\n    return this._p0;\n};\nEdgeEnd.prototype.setNode = function setNode(node) {\n    this._node = node;\n};\nEdgeEnd.prototype.print = function print(out) {\n    var angle = Math.atan2(this._dy, this._dx);\n    var className = this.getClass().getName();\n    var lastDotPos = className.lastIndexOf(\".\");\n    var name = className.substring(lastDotPos + 1);\n    out.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n};\nEdgeEnd.prototype.compareTo = function compareTo(obj) {\n    var e = obj;\n    return this.compareDirection(e);\n};\nEdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate() {\n    return this._p1;\n};\nEdgeEnd.prototype.getDx = function getDx() {\n    return this._dx;\n};\nEdgeEnd.prototype.getLabel = function getLabel() {\n    return this._label;\n};\nEdgeEnd.prototype.getEdge = function getEdge() {\n    return this._edge;\n};\nEdgeEnd.prototype.getQuadrant = function getQuadrant() {\n    return this._quadrant;\n};\nEdgeEnd.prototype.getNode = function getNode() {\n    return this._node;\n};\nEdgeEnd.prototype.toString = function toString() {\n    var angle = Math.atan2(this._dy, this._dx);\n    var className = this.getClass().getName();\n    var lastDotPos = className.lastIndexOf(\".\");\n    var name = className.substring(lastDotPos + 1);\n    return \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n};\nEdgeEnd.prototype.computeLabel = function computeLabel(boundaryNodeRule) {};\nEdgeEnd.prototype.init = function init(p0, p1) {\n    this._p0 = p0;\n    this._p1 = p1;\n    this._dx = p1.x - p0.x;\n    this._dy = p1.y - p0.y;\n    this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n    Assert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n};\nEdgeEnd.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nEdgeEnd.prototype.getClass = function getClass() {\n    return EdgeEnd;\n};\nvar DirectedEdge = function(EdgeEnd$$1) {\n    function DirectedEdge() {\n        var edge = arguments[0];\n        var isForward = arguments[1];\n        EdgeEnd$$1.call(this, edge);\n        this._isForward = null;\n        this._isInResult = false;\n        this._isVisited = false;\n        this._sym = null;\n        this._next = null;\n        this._nextMin = null;\n        this._edgeRing = null;\n        this._minEdgeRing = null;\n        this._depth = [\n            0,\n            -999,\n            -999\n        ];\n        this._isForward = isForward;\n        if (isForward) {\n            this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n        } else {\n            var n = edge.getNumPoints() - 1;\n            this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n        }\n        this.computeDirectedLabel();\n    }\n    if (EdgeEnd$$1) DirectedEdge.__proto__ = EdgeEnd$$1;\n    DirectedEdge.prototype = Object.create(EdgeEnd$$1 && EdgeEnd$$1.prototype);\n    DirectedEdge.prototype.constructor = DirectedEdge;\n    DirectedEdge.prototype.getNextMin = function getNextMin() {\n        return this._nextMin;\n    };\n    DirectedEdge.prototype.getDepth = function getDepth(position) {\n        return this._depth[position];\n    };\n    DirectedEdge.prototype.setVisited = function setVisited(isVisited) {\n        this._isVisited = isVisited;\n    };\n    DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel() {\n        this._label = new Label(this._edge.getLabel());\n        if (!this._isForward) {\n            this._label.flip();\n        }\n    };\n    DirectedEdge.prototype.getNext = function getNext() {\n        return this._next;\n    };\n    DirectedEdge.prototype.setDepth = function setDepth(position, depthVal) {\n        if (this._depth[position] !== -999) {\n            if (this._depth[position] !== depthVal) {\n                throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n            }\n        }\n        this._depth[position] = depthVal;\n    };\n    DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge() {\n        var this$1 = this;\n        var isInteriorAreaEdge = true;\n        for(var i = 0; i < 2; i++){\n            if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n                isInteriorAreaEdge = false;\n            }\n        }\n        return isInteriorAreaEdge;\n    };\n    DirectedEdge.prototype.setNextMin = function setNextMin(nextMin) {\n        this._nextMin = nextMin;\n    };\n    DirectedEdge.prototype.print = function print(out) {\n        EdgeEnd$$1.prototype.print.call(this, out);\n        out.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n        out.print(\" (\" + this.getDepthDelta() + \")\");\n        if (this._isInResult) {\n            out.print(\" inResult\");\n        }\n    };\n    DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing(minEdgeRing) {\n        this._minEdgeRing = minEdgeRing;\n    };\n    DirectedEdge.prototype.isLineEdge = function isLineEdge() {\n        var isLine = this._label.isLine(0) || this._label.isLine(1);\n        var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n        var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n        return isLine && isExteriorIfArea0 && isExteriorIfArea1;\n    };\n    DirectedEdge.prototype.setEdgeRing = function setEdgeRing(edgeRing) {\n        this._edgeRing = edgeRing;\n    };\n    DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing() {\n        return this._minEdgeRing;\n    };\n    DirectedEdge.prototype.getDepthDelta = function getDepthDelta() {\n        var depthDelta = this._edge.getDepthDelta();\n        if (!this._isForward) {\n            depthDelta = -depthDelta;\n        }\n        return depthDelta;\n    };\n    DirectedEdge.prototype.setInResult = function setInResult(isInResult) {\n        this._isInResult = isInResult;\n    };\n    DirectedEdge.prototype.getSym = function getSym() {\n        return this._sym;\n    };\n    DirectedEdge.prototype.isForward = function isForward() {\n        return this._isForward;\n    };\n    DirectedEdge.prototype.getEdge = function getEdge() {\n        return this._edge;\n    };\n    DirectedEdge.prototype.printEdge = function printEdge(out) {\n        this.print(out);\n        out.print(\" \");\n        if (this._isForward) {\n            this._edge.print(out);\n        } else {\n            this._edge.printReverse(out);\n        }\n    };\n    DirectedEdge.prototype.setSym = function setSym(de) {\n        this._sym = de;\n    };\n    DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge(isVisited) {\n        this.setVisited(isVisited);\n        this._sym.setVisited(isVisited);\n    };\n    DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths(position, depth) {\n        var depthDelta = this.getEdge().getDepthDelta();\n        if (!this._isForward) {\n            depthDelta = -depthDelta;\n        }\n        var directionFactor = 1;\n        if (position === Position.LEFT) {\n            directionFactor = -1;\n        }\n        var oppositePos = Position.opposite(position);\n        var delta = depthDelta * directionFactor;\n        var oppositeDepth = depth + delta;\n        this.setDepth(position, depth);\n        this.setDepth(oppositePos, oppositeDepth);\n    };\n    DirectedEdge.prototype.getEdgeRing = function getEdgeRing() {\n        return this._edgeRing;\n    };\n    DirectedEdge.prototype.isInResult = function isInResult() {\n        return this._isInResult;\n    };\n    DirectedEdge.prototype.setNext = function setNext(next) {\n        this._next = next;\n    };\n    DirectedEdge.prototype.isVisited = function isVisited() {\n        return this._isVisited;\n    };\n    DirectedEdge.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    DirectedEdge.prototype.getClass = function getClass() {\n        return DirectedEdge;\n    };\n    DirectedEdge.depthFactor = function depthFactor(currLocation, nextLocation) {\n        if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) {\n            return 1;\n        } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) {\n            return -1;\n        }\n        return 0;\n    };\n    return DirectedEdge;\n}(EdgeEnd);\nvar NodeFactory = function NodeFactory() {};\nNodeFactory.prototype.createNode = function createNode(coord) {\n    return new Node(coord, null);\n};\nNodeFactory.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nNodeFactory.prototype.getClass = function getClass() {\n    return NodeFactory;\n};\nvar PlanarGraph = function PlanarGraph() {\n    this._edges = new ArrayList();\n    this._nodes = null;\n    this._edgeEndList = new ArrayList();\n    if (arguments.length === 0) {\n        this._nodes = new NodeMap(new NodeFactory());\n    } else if (arguments.length === 1) {\n        var nodeFact = arguments[0];\n        this._nodes = new NodeMap(nodeFact);\n    }\n};\nPlanarGraph.prototype.printEdges = function printEdges(out) {\n    var this$1 = this;\n    out.println(\"Edges:\");\n    for(var i = 0; i < this._edges.size(); i++){\n        out.println(\"edge \" + i + \":\");\n        var e = this$1._edges.get(i);\n        e.print(out);\n        e.eiList.print(out);\n    }\n};\nPlanarGraph.prototype.find = function find(coord) {\n    return this._nodes.find(coord);\n};\nPlanarGraph.prototype.addNode = function addNode() {\n    if (arguments[0] instanceof Node) {\n        var node = arguments[0];\n        return this._nodes.addNode(node);\n    } else if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        return this._nodes.addNode(coord);\n    }\n};\nPlanarGraph.prototype.getNodeIterator = function getNodeIterator() {\n    return this._nodes.iterator();\n};\nPlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {\n    for(var nodeit = this._nodes.iterator(); nodeit.hasNext();){\n        var node = nodeit.next();\n        node.getEdges().linkResultDirectedEdges();\n    }\n};\nPlanarGraph.prototype.debugPrintln = function debugPrintln(o) {\n    System.out.println(o);\n};\nPlanarGraph.prototype.isBoundaryNode = function isBoundaryNode(geomIndex, coord) {\n    var node = this._nodes.find(coord);\n    if (node === null) {\n        return false;\n    }\n    var label = node.getLabel();\n    if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) {\n        return true;\n    }\n    return false;\n};\nPlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {\n    for(var nodeit = this._nodes.iterator(); nodeit.hasNext();){\n        var node = nodeit.next();\n        node.getEdges().linkAllDirectedEdges();\n    }\n};\nPlanarGraph.prototype.matchInSameDirection = function matchInSameDirection(p0, p1, ep0, ep1) {\n    if (!p0.equals(ep0)) {\n        return false;\n    }\n    if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) {\n        return true;\n    }\n    return false;\n};\nPlanarGraph.prototype.getEdgeEnds = function getEdgeEnds() {\n    return this._edgeEndList;\n};\nPlanarGraph.prototype.debugPrint = function debugPrint(o) {\n    System.out.print(o);\n};\nPlanarGraph.prototype.getEdgeIterator = function getEdgeIterator() {\n    return this._edges.iterator();\n};\nPlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection(p0, p1) {\n    var this$1 = this;\n    for(var i = 0; i < this._edges.size(); i++){\n        var e = this$1._edges.get(i);\n        var eCoord = e.getCoordinates();\n        if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) {\n            return e;\n        }\n        if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) {\n            return e;\n        }\n    }\n    return null;\n};\nPlanarGraph.prototype.insertEdge = function insertEdge(e) {\n    this._edges.add(e);\n};\nPlanarGraph.prototype.findEdgeEnd = function findEdgeEnd(e) {\n    for(var i = this.getEdgeEnds().iterator(); i.hasNext();){\n        var ee = i.next();\n        if (ee.getEdge() === e) {\n            return ee;\n        }\n    }\n    return null;\n};\nPlanarGraph.prototype.addEdges = function addEdges(edgesToAdd) {\n    var this$1 = this;\n    for(var it = edgesToAdd.iterator(); it.hasNext();){\n        var e = it.next();\n        this$1._edges.add(e);\n        var de1 = new DirectedEdge(e, true);\n        var de2 = new DirectedEdge(e, false);\n        de1.setSym(de2);\n        de2.setSym(de1);\n        this$1.add(de1);\n        this$1.add(de2);\n    }\n};\nPlanarGraph.prototype.add = function add(e) {\n    this._nodes.add(e);\n    this._edgeEndList.add(e);\n};\nPlanarGraph.prototype.getNodes = function getNodes() {\n    return this._nodes.values();\n};\nPlanarGraph.prototype.findEdge = function findEdge(p0, p1) {\n    var this$1 = this;\n    for(var i = 0; i < this._edges.size(); i++){\n        var e = this$1._edges.get(i);\n        var eCoord = e.getCoordinates();\n        if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) {\n            return e;\n        }\n    }\n    return null;\n};\nPlanarGraph.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPlanarGraph.prototype.getClass = function getClass() {\n    return PlanarGraph;\n};\nPlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges(nodes) {\n    for(var nodeit = nodes.iterator(); nodeit.hasNext();){\n        var node = nodeit.next();\n        node.getEdges().linkResultDirectedEdges();\n    }\n};\nvar PolygonBuilder = function PolygonBuilder() {\n    this._geometryFactory = null;\n    this._shellList = new ArrayList();\n    var geometryFactory = arguments[0];\n    this._geometryFactory = geometryFactory;\n};\nPolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n    for(var it = edgeRings.iterator(); it.hasNext();){\n        var er = it.next();\n        if (er.isHole()) {\n            freeHoleList.add(er);\n        } else {\n            shellList.add(er);\n        }\n    }\n};\nPolygonBuilder.prototype.computePolygons = function computePolygons(shellList) {\n    var this$1 = this;\n    var resultPolyList = new ArrayList();\n    for(var it = shellList.iterator(); it.hasNext();){\n        var er = it.next();\n        var poly = er.toPolygon(this$1._geometryFactory);\n        resultPolyList.add(poly);\n    }\n    return resultPolyList;\n};\nPolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles(shellList, freeHoleList) {\n    var this$1 = this;\n    for(var it = freeHoleList.iterator(); it.hasNext();){\n        var hole = it.next();\n        if (hole.getShell() === null) {\n            var shell = this$1.findEdgeRingContaining(hole, shellList);\n            if (shell === null) {\n                throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n            }\n            hole.setShell(shell);\n        }\n    }\n};\nPolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n    var this$1 = this;\n    var edgeRings = new ArrayList();\n    for(var it = maxEdgeRings.iterator(); it.hasNext();){\n        var er = it.next();\n        if (er.getMaxNodeDegree() > 2) {\n            er.linkDirectedEdgesForMinimalEdgeRings();\n            var minEdgeRings = er.buildMinimalRings();\n            var shell = this$1.findShell(minEdgeRings);\n            if (shell !== null) {\n                this$1.placePolygonHoles(shell, minEdgeRings);\n                shellList.add(shell);\n            } else {\n                freeHoleList.addAll(minEdgeRings);\n            }\n        } else {\n            edgeRings.add(er);\n        }\n    }\n    return edgeRings;\n};\nPolygonBuilder.prototype.containsPoint = function containsPoint(p) {\n    for(var it = this._shellList.iterator(); it.hasNext();){\n        var er = it.next();\n        if (er.containsPoint(p)) {\n            return true;\n        }\n    }\n    return false;\n};\nPolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings(dirEdges) {\n    var this$1 = this;\n    var maxEdgeRings = new ArrayList();\n    for(var it = dirEdges.iterator(); it.hasNext();){\n        var de = it.next();\n        if (de.isInResult() && de.getLabel().isArea()) {\n            if (de.getEdgeRing() === null) {\n                var er = new MaximalEdgeRing(de, this$1._geometryFactory);\n                maxEdgeRings.add(er);\n                er.setInResult();\n            }\n        }\n    }\n    return maxEdgeRings;\n};\nPolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles(shell, minEdgeRings) {\n    for(var it = minEdgeRings.iterator(); it.hasNext();){\n        var er = it.next();\n        if (er.isHole()) {\n            er.setShell(shell);\n        }\n    }\n};\nPolygonBuilder.prototype.getPolygons = function getPolygons() {\n    var resultPolyList = this.computePolygons(this._shellList);\n    return resultPolyList;\n};\nPolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining(testEr, shellList) {\n    var testRing = testEr.getLinearRing();\n    var testEnv = testRing.getEnvelopeInternal();\n    var testPt = testRing.getCoordinateN(0);\n    var minShell = null;\n    var minEnv = null;\n    for(var it = shellList.iterator(); it.hasNext();){\n        var tryShell = it.next();\n        var tryRing = tryShell.getLinearRing();\n        var tryEnv = tryRing.getEnvelopeInternal();\n        if (minShell !== null) {\n            minEnv = minShell.getLinearRing().getEnvelopeInternal();\n        }\n        var isContained = false;\n        if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) {\n            isContained = true;\n        }\n        if (isContained) {\n            if (minShell === null || minEnv.contains(tryEnv)) {\n                minShell = tryShell;\n            }\n        }\n    }\n    return minShell;\n};\nPolygonBuilder.prototype.findShell = function findShell(minEdgeRings) {\n    var shellCount = 0;\n    var shell = null;\n    for(var it = minEdgeRings.iterator(); it.hasNext();){\n        var er = it.next();\n        if (!er.isHole()) {\n            shell = er;\n            shellCount++;\n        }\n    }\n    Assert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n    return shell;\n};\nPolygonBuilder.prototype.add = function add() {\n    if (arguments.length === 1) {\n        var graph = arguments[0];\n        this.add(graph.getEdgeEnds(), graph.getNodes());\n    } else if (arguments.length === 2) {\n        var dirEdges = arguments[0];\n        var nodes = arguments[1];\n        PlanarGraph.linkResultDirectedEdges(nodes);\n        var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n        var freeHoleList = new ArrayList();\n        var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n        this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n        this.placeFreeHoles(this._shellList, freeHoleList);\n    }\n};\nPolygonBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPolygonBuilder.prototype.getClass = function getClass() {\n    return PolygonBuilder;\n};\nvar Boundable = function Boundable() {};\nBoundable.prototype.getBounds = function getBounds() {};\nBoundable.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBoundable.prototype.getClass = function getClass() {\n    return Boundable;\n};\nvar ItemBoundable = function ItemBoundable() {\n    this._bounds = null;\n    this._item = null;\n    var bounds = arguments[0];\n    var item = arguments[1];\n    this._bounds = bounds;\n    this._item = item;\n};\nItemBoundable.prototype.getItem = function getItem() {\n    return this._item;\n};\nItemBoundable.prototype.getBounds = function getBounds() {\n    return this._bounds;\n};\nItemBoundable.prototype.interfaces_ = function interfaces_() {\n    return [\n        Boundable,\n        Serializable\n    ];\n};\nItemBoundable.prototype.getClass = function getClass() {\n    return ItemBoundable;\n};\nvar PriorityQueue = function PriorityQueue() {\n    this._size = null;\n    this._items = null;\n    this._size = 0;\n    this._items = new ArrayList();\n    this._items.add(null);\n};\nPriorityQueue.prototype.poll = function poll() {\n    if (this.isEmpty()) {\n        return null;\n    }\n    var minItem = this._items.get(1);\n    this._items.set(1, this._items.get(this._size));\n    this._size -= 1;\n    this.reorder(1);\n    return minItem;\n};\nPriorityQueue.prototype.size = function size() {\n    return this._size;\n};\nPriorityQueue.prototype.reorder = function reorder(hole) {\n    var this$1 = this;\n    var child = null;\n    var tmp = this._items.get(hole);\n    for(; hole * 2 <= this._size; hole = child){\n        child = hole * 2;\n        if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) {\n            child++;\n        }\n        if (this$1._items.get(child).compareTo(tmp) < 0) {\n            this$1._items.set(hole, this$1._items.get(child));\n        } else {\n            break;\n        }\n    }\n    this._items.set(hole, tmp);\n};\nPriorityQueue.prototype.clear = function clear() {\n    this._size = 0;\n    this._items.clear();\n};\nPriorityQueue.prototype.isEmpty = function isEmpty() {\n    return this._size === 0;\n};\nPriorityQueue.prototype.add = function add(x) {\n    var this$1 = this;\n    this._items.add(null);\n    this._size += 1;\n    var hole = this._size;\n    this._items.set(0, x);\n    for(; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2){\n        this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));\n    }\n    this._items.set(hole, x);\n};\nPriorityQueue.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPriorityQueue.prototype.getClass = function getClass() {\n    return PriorityQueue;\n};\nvar ItemVisitor = function ItemVisitor() {};\nItemVisitor.prototype.visitItem = function visitItem(item) {};\nItemVisitor.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nItemVisitor.prototype.getClass = function getClass() {\n    return ItemVisitor;\n};\nvar SpatialIndex = function SpatialIndex() {};\nSpatialIndex.prototype.insert = function insert(itemEnv, item) {};\nSpatialIndex.prototype.remove = function remove(itemEnv, item) {};\nSpatialIndex.prototype.query = function query() {\n// if (arguments.length === 1) {\n// const searchEnv = arguments[0]\n// } else if (arguments.length === 2) {\n// const searchEnv = arguments[0]\n// const visitor = arguments[1]\n// }\n};\nSpatialIndex.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSpatialIndex.prototype.getClass = function getClass() {\n    return SpatialIndex;\n};\nvar AbstractNode = function AbstractNode() {\n    this._childBoundables = new ArrayList();\n    this._bounds = null;\n    this._level = null;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var level = arguments[0];\n        this._level = level;\n    }\n};\nvar staticAccessors$22 = {\n    serialVersionUID: {\n        configurable: true\n    }\n};\nAbstractNode.prototype.getLevel = function getLevel() {\n    return this._level;\n};\nAbstractNode.prototype.size = function size() {\n    return this._childBoundables.size();\n};\nAbstractNode.prototype.getChildBoundables = function getChildBoundables() {\n    return this._childBoundables;\n};\nAbstractNode.prototype.addChildBoundable = function addChildBoundable(childBoundable) {\n    Assert.isTrue(this._bounds === null);\n    this._childBoundables.add(childBoundable);\n};\nAbstractNode.prototype.isEmpty = function isEmpty() {\n    return this._childBoundables.isEmpty();\n};\nAbstractNode.prototype.getBounds = function getBounds() {\n    if (this._bounds === null) {\n        this._bounds = this.computeBounds();\n    }\n    return this._bounds;\n};\nAbstractNode.prototype.interfaces_ = function interfaces_() {\n    return [\n        Boundable,\n        Serializable\n    ];\n};\nAbstractNode.prototype.getClass = function getClass() {\n    return AbstractNode;\n};\nstaticAccessors$22.serialVersionUID.get = function() {\n    return 6493722185909573708;\n};\nObject.defineProperties(AbstractNode, staticAccessors$22);\nvar Collections = function Collections() {};\nCollections.reverseOrder = function reverseOrder() {\n    return {\n        compare: function compare(a, b) {\n            return b.compareTo(a);\n        }\n    };\n};\nCollections.min = function min(l) {\n    Collections.sort(l);\n    return l.get(0);\n};\nCollections.sort = function sort(l, c) {\n    var a = l.toArray();\n    if (c) {\n        Arrays.sort(a, c);\n    } else {\n        Arrays.sort(a);\n    }\n    var i = l.iterator();\n    for(var pos = 0, alen = a.length; pos < alen; pos++){\n        i.next();\n        i.set(a[pos]);\n    }\n};\nCollections.singletonList = function singletonList(o) {\n    var arrayList = new ArrayList();\n    arrayList.add(o);\n    return arrayList;\n};\nvar BoundablePair = function BoundablePair() {\n    this._boundable1 = null;\n    this._boundable2 = null;\n    this._distance = null;\n    this._itemDistance = null;\n    var boundable1 = arguments[0];\n    var boundable2 = arguments[1];\n    var itemDistance = arguments[2];\n    this._boundable1 = boundable1;\n    this._boundable2 = boundable2;\n    this._itemDistance = itemDistance;\n    this._distance = this.distance();\n};\nBoundablePair.prototype.expandToQueue = function expandToQueue(priQ, minDistance) {\n    var isComp1 = BoundablePair.isComposite(this._boundable1);\n    var isComp2 = BoundablePair.isComposite(this._boundable2);\n    if (isComp1 && isComp2) {\n        if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n            this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n            return null;\n        } else {\n            this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n            return null;\n        }\n    } else if (isComp1) {\n        this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n        return null;\n    } else if (isComp2) {\n        this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n        return null;\n    }\n    throw new IllegalArgumentException(\"neither boundable is composite\");\n};\nBoundablePair.prototype.isLeaves = function isLeaves() {\n    return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n};\nBoundablePair.prototype.compareTo = function compareTo(o) {\n    var nd = o;\n    if (this._distance < nd._distance) {\n        return -1;\n    }\n    if (this._distance > nd._distance) {\n        return 1;\n    }\n    return 0;\n};\nBoundablePair.prototype.expand = function expand(bndComposite, bndOther, priQ, minDistance) {\n    var this$1 = this;\n    var children = bndComposite.getChildBoundables();\n    for(var i = children.iterator(); i.hasNext();){\n        var child = i.next();\n        var bp = new BoundablePair(child, bndOther, this$1._itemDistance);\n        if (bp.getDistance() < minDistance) {\n            priQ.add(bp);\n        }\n    }\n};\nBoundablePair.prototype.getBoundable = function getBoundable(i) {\n    if (i === 0) {\n        return this._boundable1;\n    }\n    return this._boundable2;\n};\nBoundablePair.prototype.getDistance = function getDistance() {\n    return this._distance;\n};\nBoundablePair.prototype.distance = function distance() {\n    if (this.isLeaves()) {\n        return this._itemDistance.distance(this._boundable1, this._boundable2);\n    }\n    return this._boundable1.getBounds().distance(this._boundable2.getBounds());\n};\nBoundablePair.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nBoundablePair.prototype.getClass = function getClass() {\n    return BoundablePair;\n};\nBoundablePair.area = function area(b) {\n    return b.getBounds().getArea();\n};\nBoundablePair.isComposite = function isComposite(item) {\n    return item instanceof AbstractNode;\n};\nvar AbstractSTRtree = function AbstractSTRtree() {\n    this._root = null;\n    this._built = false;\n    this._itemBoundables = new ArrayList();\n    this._nodeCapacity = null;\n    if (arguments.length === 0) {\n        var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;\n        this._nodeCapacity = nodeCapacity;\n    } else if (arguments.length === 1) {\n        var nodeCapacity$1 = arguments[0];\n        Assert.isTrue(nodeCapacity$1 > 1, \"Node capacity must be greater than 1\");\n        this._nodeCapacity = nodeCapacity$1;\n    }\n};\nvar staticAccessors$23 = {\n    IntersectsOp: {\n        configurable: true\n    },\n    serialVersionUID: {\n        configurable: true\n    },\n    DEFAULT_NODE_CAPACITY: {\n        configurable: true\n    }\n};\nAbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity() {\n    return this._nodeCapacity;\n};\nAbstractSTRtree.prototype.lastNode = function lastNode(nodes) {\n    return nodes.get(nodes.size() - 1);\n};\nAbstractSTRtree.prototype.size = function size() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        if (this.isEmpty()) {\n            return 0;\n        }\n        this.build();\n        return this.size(this._root);\n    } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var size = 0;\n        for(var i = node.getChildBoundables().iterator(); i.hasNext();){\n            var childBoundable = i.next();\n            if (childBoundable instanceof AbstractNode) {\n                size += this$1.size(childBoundable);\n            } else if (childBoundable instanceof ItemBoundable) {\n                size += 1;\n            }\n        }\n        return size;\n    }\n};\nAbstractSTRtree.prototype.removeItem = function removeItem(node, item) {\n    var childToRemove = null;\n    for(var i = node.getChildBoundables().iterator(); i.hasNext();){\n        var childBoundable = i.next();\n        if (childBoundable instanceof ItemBoundable) {\n            if (childBoundable.getItem() === item) {\n                childToRemove = childBoundable;\n            }\n        }\n    }\n    if (childToRemove !== null) {\n        node.getChildBoundables().remove(childToRemove);\n        return true;\n    }\n    return false;\n};\nAbstractSTRtree.prototype.itemsTree = function itemsTree() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        this.build();\n        var valuesTree = this.itemsTree(this._root);\n        if (valuesTree === null) {\n            return new ArrayList();\n        }\n        return valuesTree;\n    } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var valuesTreeForNode = new ArrayList();\n        for(var i = node.getChildBoundables().iterator(); i.hasNext();){\n            var childBoundable = i.next();\n            if (childBoundable instanceof AbstractNode) {\n                var valuesTreeForChild = this$1.itemsTree(childBoundable);\n                if (valuesTreeForChild !== null) {\n                    valuesTreeForNode.add(valuesTreeForChild);\n                }\n            } else if (childBoundable instanceof ItemBoundable) {\n                valuesTreeForNode.add(childBoundable.getItem());\n            } else {\n                Assert.shouldNeverReachHere();\n            }\n        }\n        if (valuesTreeForNode.size() <= 0) {\n            return null;\n        }\n        return valuesTreeForNode;\n    }\n};\nAbstractSTRtree.prototype.insert = function insert(bounds, item) {\n    Assert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n    this._itemBoundables.add(new ItemBoundable(bounds, item));\n};\nAbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel() {\n    var this$1 = this;\n    if (arguments.length === 1) {\n        var level = arguments[0];\n        var boundables = new ArrayList();\n        this.boundablesAtLevel(level, this._root, boundables);\n        return boundables;\n    } else if (arguments.length === 3) {\n        var level$1 = arguments[0];\n        var top = arguments[1];\n        var boundables$1 = arguments[2];\n        Assert.isTrue(level$1 > -2);\n        if (top.getLevel() === level$1) {\n            boundables$1.add(top);\n            return null;\n        }\n        for(var i = top.getChildBoundables().iterator(); i.hasNext();){\n            var boundable = i.next();\n            if (boundable instanceof AbstractNode) {\n                this$1.boundablesAtLevel(level$1, boundable, boundables$1);\n            } else {\n                Assert.isTrue(boundable instanceof ItemBoundable);\n                if (level$1 === -1) {\n                    boundables$1.add(boundable);\n                }\n            }\n        }\n        return null;\n    }\n};\nAbstractSTRtree.prototype.query = function query() {\n    var this$1 = this;\n    if (arguments.length === 1) {\n        var searchBounds = arguments[0];\n        this.build();\n        var matches = new ArrayList();\n        if (this.isEmpty()) {\n            return matches;\n        }\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n            this.query(searchBounds, this._root, matches);\n        }\n        return matches;\n    } else if (arguments.length === 2) {\n        var searchBounds$1 = arguments[0];\n        var visitor = arguments[1];\n        this.build();\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {\n            this.query(searchBounds$1, this._root, visitor);\n        }\n    } else if (arguments.length === 3) {\n        if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n            var searchBounds$2 = arguments[0];\n            var node = arguments[1];\n            var visitor$1 = arguments[2];\n            var childBoundables = node.getChildBoundables();\n            for(var i = 0; i < childBoundables.size(); i++){\n                var childBoundable = childBoundables.get(i);\n                if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {\n                    continue;\n                }\n                if (childBoundable instanceof AbstractNode) {\n                    this$1.query(searchBounds$2, childBoundable, visitor$1);\n                } else if (childBoundable instanceof ItemBoundable) {\n                    visitor$1.visitItem(childBoundable.getItem());\n                } else {\n                    Assert.shouldNeverReachHere();\n                }\n            }\n        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n            var searchBounds$3 = arguments[0];\n            var node$1 = arguments[1];\n            var matches$1 = arguments[2];\n            var childBoundables$1 = node$1.getChildBoundables();\n            for(var i$1 = 0; i$1 < childBoundables$1.size(); i$1++){\n                var childBoundable$1 = childBoundables$1.get(i$1);\n                if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {\n                    continue;\n                }\n                if (childBoundable$1 instanceof AbstractNode) {\n                    this$1.query(searchBounds$3, childBoundable$1, matches$1);\n                } else if (childBoundable$1 instanceof ItemBoundable) {\n                    matches$1.add(childBoundable$1.getItem());\n                } else {\n                    Assert.shouldNeverReachHere();\n                }\n            }\n        }\n    }\n};\nAbstractSTRtree.prototype.build = function build() {\n    if (this._built) {\n        return null;\n    }\n    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n    this._itemBoundables = null;\n    this._built = true;\n};\nAbstractSTRtree.prototype.getRoot = function getRoot() {\n    this.build();\n    return this._root;\n};\nAbstractSTRtree.prototype.remove = function remove() {\n    var this$1 = this;\n    if (arguments.length === 2) {\n        var searchBounds = arguments[0];\n        var item = arguments[1];\n        this.build();\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n            return this.remove(searchBounds, this._root, item);\n        }\n        return false;\n    } else if (arguments.length === 3) {\n        var searchBounds$1 = arguments[0];\n        var node = arguments[1];\n        var item$1 = arguments[2];\n        var found = this.removeItem(node, item$1);\n        if (found) {\n            return true;\n        }\n        var childToPrune = null;\n        for(var i = node.getChildBoundables().iterator(); i.hasNext();){\n            var childBoundable = i.next();\n            if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {\n                continue;\n            }\n            if (childBoundable instanceof AbstractNode) {\n                found = this$1.remove(searchBounds$1, childBoundable, item$1);\n                if (found) {\n                    childToPrune = childBoundable;\n                    break;\n                }\n            }\n        }\n        if (childToPrune !== null) {\n            if (childToPrune.getChildBoundables().isEmpty()) {\n                node.getChildBoundables().remove(childToPrune);\n            }\n        }\n        return found;\n    }\n};\nAbstractSTRtree.prototype.createHigherLevels = function createHigherLevels(boundablesOfALevel, level) {\n    Assert.isTrue(!boundablesOfALevel.isEmpty());\n    var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n    if (parentBoundables.size() === 1) {\n        return parentBoundables.get(0);\n    }\n    return this.createHigherLevels(parentBoundables, level + 1);\n};\nAbstractSTRtree.prototype.depth = function depth() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        if (this.isEmpty()) {\n            return 0;\n        }\n        this.build();\n        return this.depth(this._root);\n    } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var maxChildDepth = 0;\n        for(var i = node.getChildBoundables().iterator(); i.hasNext();){\n            var childBoundable = i.next();\n            if (childBoundable instanceof AbstractNode) {\n                var childDepth = this$1.depth(childBoundable);\n                if (childDepth > maxChildDepth) {\n                    maxChildDepth = childDepth;\n                }\n            }\n        }\n        return maxChildDepth + 1;\n    }\n};\nAbstractSTRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {\n    var this$1 = this;\n    Assert.isTrue(!childBoundables.isEmpty());\n    var parentBoundables = new ArrayList();\n    parentBoundables.add(this.createNode(newLevel));\n    var sortedChildBoundables = new ArrayList(childBoundables);\n    Collections.sort(sortedChildBoundables, this.getComparator());\n    for(var i = sortedChildBoundables.iterator(); i.hasNext();){\n        var childBoundable = i.next();\n        if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {\n            parentBoundables.add(this$1.createNode(newLevel));\n        }\n        this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);\n    }\n    return parentBoundables;\n};\nAbstractSTRtree.prototype.isEmpty = function isEmpty() {\n    if (!this._built) {\n        return this._itemBoundables.isEmpty();\n    }\n    return this._root.isEmpty();\n};\nAbstractSTRtree.prototype.interfaces_ = function interfaces_() {\n    return [\n        Serializable\n    ];\n};\nAbstractSTRtree.prototype.getClass = function getClass() {\n    return AbstractSTRtree;\n};\nAbstractSTRtree.compareDoubles = function compareDoubles(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nstaticAccessors$23.IntersectsOp.get = function() {\n    return IntersectsOp;\n};\nstaticAccessors$23.serialVersionUID.get = function() {\n    return -3886435814360241337;\n};\nstaticAccessors$23.DEFAULT_NODE_CAPACITY.get = function() {\n    return 10;\n};\nObject.defineProperties(AbstractSTRtree, staticAccessors$23);\nvar IntersectsOp = function IntersectsOp() {};\nvar ItemDistance = function ItemDistance() {};\nItemDistance.prototype.distance = function distance(item1, item2) {};\nItemDistance.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nItemDistance.prototype.getClass = function getClass() {\n    return ItemDistance;\n};\nvar STRtree = function(AbstractSTRtree$$1) {\n    function STRtree(nodeCapacity) {\n        nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;\n        AbstractSTRtree$$1.call(this, nodeCapacity);\n    }\n    if (AbstractSTRtree$$1) STRtree.__proto__ = AbstractSTRtree$$1;\n    STRtree.prototype = Object.create(AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype);\n    STRtree.prototype.constructor = STRtree;\n    var staticAccessors = {\n        STRtreeNode: {\n            configurable: true\n        },\n        serialVersionUID: {\n            configurable: true\n        },\n        xComparator: {\n            configurable: true\n        },\n        yComparator: {\n            configurable: true\n        },\n        intersectsOp: {\n            configurable: true\n        },\n        DEFAULT_NODE_CAPACITY: {\n            configurable: true\n        }\n    };\n    STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n        var this$1 = this;\n        Assert.isTrue(verticalSlices.length > 0);\n        var parentBoundables = new ArrayList();\n        for(var i = 0; i < verticalSlices.length; i++){\n            parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n        }\n        return parentBoundables;\n    };\n    STRtree.prototype.createNode = function createNode(level) {\n        return new STRtreeNode(level);\n    };\n    STRtree.prototype.size = function size() {\n        if (arguments.length === 0) {\n            return AbstractSTRtree$$1.prototype.size.call(this);\n        } else {\n            return AbstractSTRtree$$1.prototype.size.apply(this, arguments);\n        }\n    };\n    STRtree.prototype.insert = function insert() {\n        if (arguments.length === 2) {\n            var itemEnv = arguments[0];\n            var item = arguments[1];\n            if (itemEnv.isNull()) {\n                return null;\n            }\n            AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);\n        } else {\n            return AbstractSTRtree$$1.prototype.insert.apply(this, arguments);\n        }\n    };\n    STRtree.prototype.getIntersectsOp = function getIntersectsOp() {\n        return STRtree.intersectsOp;\n    };\n    STRtree.prototype.verticalSlices = function verticalSlices(childBoundables, sliceCount) {\n        var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n        var slices = new Array(sliceCount).fill(null);\n        var i = childBoundables.iterator();\n        for(var j = 0; j < sliceCount; j++){\n            slices[j] = new ArrayList();\n            var boundablesAddedToSlice = 0;\n            while(i.hasNext() && boundablesAddedToSlice < sliceCapacity){\n                var childBoundable = i.next();\n                slices[j].add(childBoundable);\n                boundablesAddedToSlice++;\n            }\n        }\n        return slices;\n    };\n    STRtree.prototype.query = function query() {\n        if (arguments.length === 1) {\n            var searchEnv = arguments[0];\n            return AbstractSTRtree$$1.prototype.query.call(this, searchEnv);\n        } else if (arguments.length === 2) {\n            var searchEnv$1 = arguments[0];\n            var visitor = arguments[1];\n            AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);\n        } else if (arguments.length === 3) {\n            if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n                var searchBounds = arguments[0];\n                var node = arguments[1];\n                var visitor$1 = arguments[2];\n                AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);\n            } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n                var searchBounds$1 = arguments[0];\n                var node$1 = arguments[1];\n                var matches = arguments[2];\n                AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);\n            }\n        }\n    };\n    STRtree.prototype.getComparator = function getComparator() {\n        return STRtree.yComparator;\n    };\n    STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n        return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n    };\n    STRtree.prototype.remove = function remove() {\n        if (arguments.length === 2) {\n            var itemEnv = arguments[0];\n            var item = arguments[1];\n            return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item);\n        } else {\n            return AbstractSTRtree$$1.prototype.remove.apply(this, arguments);\n        }\n    };\n    STRtree.prototype.depth = function depth() {\n        if (arguments.length === 0) {\n            return AbstractSTRtree$$1.prototype.depth.call(this);\n        } else {\n            return AbstractSTRtree$$1.prototype.depth.apply(this, arguments);\n        }\n    };\n    STRtree.prototype.createParentBoundables = function createParentBoundables(childBoundables, newLevel) {\n        Assert.isTrue(!childBoundables.isEmpty());\n        var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n        var sortedChildBoundables = new ArrayList(childBoundables);\n        Collections.sort(sortedChildBoundables, STRtree.xComparator);\n        var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n        return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n    };\n    STRtree.prototype.nearestNeighbour = function nearestNeighbour() {\n        if (arguments.length === 1) {\n            if (hasInterface(arguments[0], ItemDistance)) {\n                var itemDist = arguments[0];\n                var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n                return this.nearestNeighbour(bp);\n            } else if (arguments[0] instanceof BoundablePair) {\n                var initBndPair = arguments[0];\n                return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n            }\n        } else if (arguments.length === 2) {\n            if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n                var tree = arguments[0];\n                var itemDist$1 = arguments[1];\n                var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);\n                return this.nearestNeighbour(bp$1);\n            } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n                var initBndPair$1 = arguments[0];\n                var maxDistance = arguments[1];\n                var distanceLowerBound = maxDistance;\n                var minPair = null;\n                var priQ = new PriorityQueue();\n                priQ.add(initBndPair$1);\n                while(!priQ.isEmpty() && distanceLowerBound > 0.0){\n                    var bndPair = priQ.poll();\n                    var currentDistance = bndPair.getDistance();\n                    if (currentDistance >= distanceLowerBound) {\n                        break;\n                    }\n                    if (bndPair.isLeaves()) {\n                        distanceLowerBound = currentDistance;\n                        minPair = bndPair;\n                    } else {\n                        bndPair.expandToQueue(priQ, distanceLowerBound);\n                    }\n                }\n                return [\n                    minPair.getBoundable(0).getItem(),\n                    minPair.getBoundable(1).getItem()\n                ];\n            }\n        } else if (arguments.length === 3) {\n            var env = arguments[0];\n            var item = arguments[1];\n            var itemDist$2 = arguments[2];\n            var bnd = new ItemBoundable(env, item);\n            var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);\n            return this.nearestNeighbour(bp$2)[0];\n        }\n    };\n    STRtree.prototype.interfaces_ = function interfaces_() {\n        return [\n            SpatialIndex,\n            Serializable\n        ];\n    };\n    STRtree.prototype.getClass = function getClass() {\n        return STRtree;\n    };\n    STRtree.centreX = function centreX(e) {\n        return STRtree.avg(e.getMinX(), e.getMaxX());\n    };\n    STRtree.avg = function avg(a, b) {\n        return (a + b) / 2;\n    };\n    STRtree.centreY = function centreY(e) {\n        return STRtree.avg(e.getMinY(), e.getMaxY());\n    };\n    staticAccessors.STRtreeNode.get = function() {\n        return STRtreeNode;\n    };\n    staticAccessors.serialVersionUID.get = function() {\n        return 259274702368956900;\n    };\n    staticAccessors.xComparator.get = function() {\n        return {\n            interfaces_: function() {\n                return [\n                    Comparator\n                ];\n            },\n            compare: function(o1, o2) {\n                return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n            }\n        };\n    };\n    staticAccessors.yComparator.get = function() {\n        return {\n            interfaces_: function() {\n                return [\n                    Comparator\n                ];\n            },\n            compare: function(o1, o2) {\n                return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n            }\n        };\n    };\n    staticAccessors.intersectsOp.get = function() {\n        return {\n            interfaces_: function() {\n                return [\n                    AbstractSTRtree$$1.IntersectsOp\n                ];\n            },\n            intersects: function(aBounds, bBounds) {\n                return aBounds.intersects(bBounds);\n            }\n        };\n    };\n    staticAccessors.DEFAULT_NODE_CAPACITY.get = function() {\n        return 10;\n    };\n    Object.defineProperties(STRtree, staticAccessors);\n    return STRtree;\n}(AbstractSTRtree);\nvar STRtreeNode = function(AbstractNode$$1) {\n    function STRtreeNode() {\n        var level = arguments[0];\n        AbstractNode$$1.call(this, level);\n    }\n    if (AbstractNode$$1) STRtreeNode.__proto__ = AbstractNode$$1;\n    STRtreeNode.prototype = Object.create(AbstractNode$$1 && AbstractNode$$1.prototype);\n    STRtreeNode.prototype.constructor = STRtreeNode;\n    STRtreeNode.prototype.computeBounds = function computeBounds() {\n        var bounds = null;\n        for(var i = this.getChildBoundables().iterator(); i.hasNext();){\n            var childBoundable = i.next();\n            if (bounds === null) {\n                bounds = new Envelope(childBoundable.getBounds());\n            } else {\n                bounds.expandToInclude(childBoundable.getBounds());\n            }\n        }\n        return bounds;\n    };\n    STRtreeNode.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    STRtreeNode.prototype.getClass = function getClass() {\n        return STRtreeNode;\n    };\n    return STRtreeNode;\n}(AbstractNode);\nvar SegmentPointComparator = function SegmentPointComparator() {};\nSegmentPointComparator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSegmentPointComparator.prototype.getClass = function getClass() {\n    return SegmentPointComparator;\n};\nSegmentPointComparator.relativeSign = function relativeSign(x0, x1) {\n    if (x0 < x1) {\n        return -1;\n    }\n    if (x0 > x1) {\n        return 1;\n    }\n    return 0;\n};\nSegmentPointComparator.compare = function compare(octant, p0, p1) {\n    if (p0.equals2D(p1)) {\n        return 0;\n    }\n    var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n    var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n    switch(octant){\n        case 0:\n            return SegmentPointComparator.compareValue(xSign, ySign);\n        case 1:\n            return SegmentPointComparator.compareValue(ySign, xSign);\n        case 2:\n            return SegmentPointComparator.compareValue(ySign, -xSign);\n        case 3:\n            return SegmentPointComparator.compareValue(-xSign, ySign);\n        case 4:\n            return SegmentPointComparator.compareValue(-xSign, -ySign);\n        case 5:\n            return SegmentPointComparator.compareValue(-ySign, -xSign);\n        case 6:\n            return SegmentPointComparator.compareValue(-ySign, xSign);\n        case 7:\n            return SegmentPointComparator.compareValue(xSign, -ySign);\n        default:\n    }\n    Assert.shouldNeverReachHere(\"invalid octant value\");\n    return 0;\n};\nSegmentPointComparator.compareValue = function compareValue(compareSign0, compareSign1) {\n    if (compareSign0 < 0) {\n        return -1;\n    }\n    if (compareSign0 > 0) {\n        return 1;\n    }\n    if (compareSign1 < 0) {\n        return -1;\n    }\n    if (compareSign1 > 0) {\n        return 1;\n    }\n    return 0;\n};\nvar SegmentNode = function SegmentNode() {\n    this._segString = null;\n    this.coord = null;\n    this.segmentIndex = null;\n    this._segmentOctant = null;\n    this._isInterior = null;\n    var segString = arguments[0];\n    var coord = arguments[1];\n    var segmentIndex = arguments[2];\n    var segmentOctant = arguments[3];\n    this._segString = segString;\n    this.coord = new Coordinate(coord);\n    this.segmentIndex = segmentIndex;\n    this._segmentOctant = segmentOctant;\n    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n};\nSegmentNode.prototype.getCoordinate = function getCoordinate() {\n    return this.coord;\n};\nSegmentNode.prototype.print = function print(out) {\n    out.print(this.coord);\n    out.print(\" seg # = \" + this.segmentIndex);\n};\nSegmentNode.prototype.compareTo = function compareTo(obj) {\n    var other = obj;\n    if (this.segmentIndex < other.segmentIndex) {\n        return -1;\n    }\n    if (this.segmentIndex > other.segmentIndex) {\n        return 1;\n    }\n    if (this.coord.equals2D(other.coord)) {\n        return 0;\n    }\n    return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n};\nSegmentNode.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && !this._isInterior) {\n        return true;\n    }\n    if (this.segmentIndex === maxSegmentIndex) {\n        return true;\n    }\n    return false;\n};\nSegmentNode.prototype.isInterior = function isInterior() {\n    return this._isInterior;\n};\nSegmentNode.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nSegmentNode.prototype.getClass = function getClass() {\n    return SegmentNode;\n};\n// import Iterator from '../../../../java/util/Iterator'\nvar SegmentNodeList = function SegmentNodeList() {\n    this._nodeMap = new TreeMap();\n    this._edge = null;\n    var edge = arguments[0];\n    this._edge = edge;\n};\nSegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates() {\n    var this$1 = this;\n    var coordList = new CoordinateList();\n    this.addEndpoints();\n    var it = this.iterator();\n    var eiPrev = it.next();\n    while(it.hasNext()){\n        var ei = it.next();\n        this$1.addEdgeCoordinates(eiPrev, ei, coordList);\n        eiPrev = ei;\n    }\n    return coordList.toCoordinateArray();\n};\nSegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes() {\n    var this$1 = this;\n    var collapsedVertexIndexes = new ArrayList();\n    this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n    this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n    for(var it = collapsedVertexIndexes.iterator(); it.hasNext();){\n        var vertexIndex = it.next().intValue();\n        this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);\n    }\n};\nSegmentNodeList.prototype.print = function print(out) {\n    out.println(\"Intersections:\");\n    for(var it = this.iterator(); it.hasNext();){\n        var ei = it.next();\n        ei.print(out);\n    }\n};\nSegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n    var this$1 = this;\n    for(var i = 0; i < this._edge.size() - 2; i++){\n        var p0 = this$1._edge.getCoordinate(i);\n        // const p1 = this._edge.getCoordinate(i + 1)\n        var p2 = this$1._edge.getCoordinate(i + 2);\n        if (p0.equals2D(p2)) {\n            collapsedVertexIndexes.add(new Integer(i + 1));\n        }\n    }\n};\nSegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates(ei0, ei1, coordList) {\n    var this$1 = this;\n    // let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n    var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n    var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n    // if (!useIntPt1) {\n    // npts--\n    // }\n    // const ipt = 0\n    coordList.add(new Coordinate(ei0.coord), false);\n    for(var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++){\n        coordList.add(this$1._edge.getCoordinate(i));\n    }\n    if (useIntPt1) {\n        coordList.add(new Coordinate(ei1.coord));\n    }\n};\nSegmentNodeList.prototype.iterator = function iterator() {\n    return this._nodeMap.values().iterator();\n};\nSegmentNodeList.prototype.addSplitEdges = function addSplitEdges(edgeList) {\n    var this$1 = this;\n    this.addEndpoints();\n    this.addCollapsedNodes();\n    var it = this.iterator();\n    var eiPrev = it.next();\n    while(it.hasNext()){\n        var ei = it.next();\n        var newEdge = this$1.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n    }\n};\nSegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n    if (!ei0.coord.equals2D(ei1.coord)) {\n        return false;\n    }\n    var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n    if (!ei1.isInterior()) {\n        numVerticesBetween--;\n    }\n    if (numVerticesBetween === 1) {\n        collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n        return true;\n    }\n    return false;\n};\nSegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n    var this$1 = this;\n    var collapsedVertexIndex = new Array(1).fill(null);\n    var it = this.iterator();\n    var eiPrev = it.next();\n    while(it.hasNext()){\n        var ei = it.next();\n        var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n        if (isCollapsed) {\n            collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n        }\n        eiPrev = ei;\n    }\n};\nSegmentNodeList.prototype.getEdge = function getEdge() {\n    return this._edge;\n};\nSegmentNodeList.prototype.addEndpoints = function addEndpoints() {\n    var maxSegIndex = this._edge.size() - 1;\n    this.add(this._edge.getCoordinate(0), 0);\n    this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n};\nSegmentNodeList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {\n    var this$1 = this;\n    var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n    var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n    var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n    if (!useIntPt1) {\n        npts--;\n    }\n    var pts = new Array(npts).fill(null);\n    var ipt = 0;\n    pts[ipt++] = new Coordinate(ei0.coord);\n    for(var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++){\n        pts[ipt++] = this$1._edge.getCoordinate(i);\n    }\n    if (useIntPt1) {\n        pts[ipt] = new Coordinate(ei1.coord);\n    }\n    return new NodedSegmentString(pts, this._edge.getData());\n};\nSegmentNodeList.prototype.add = function add(intPt, segmentIndex) {\n    var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n    var ei = this._nodeMap.get(eiNew);\n    if (ei !== null) {\n        Assert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n        return ei;\n    }\n    this._nodeMap.put(eiNew, eiNew);\n    return eiNew;\n};\nSegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness(splitEdges) {\n    var edgePts = this._edge.getCoordinates();\n    var split0 = splitEdges.get(0);\n    var pt0 = split0.getCoordinate(0);\n    if (!pt0.equals2D(edgePts[0])) {\n        throw new RuntimeException(\"bad split edge start point at \" + pt0);\n    }\n    var splitn = splitEdges.get(splitEdges.size() - 1);\n    var splitnPts = splitn.getCoordinates();\n    var ptn = splitnPts[splitnPts.length - 1];\n    if (!ptn.equals2D(edgePts[edgePts.length - 1])) {\n        throw new RuntimeException(\"bad split edge end point at \" + ptn);\n    }\n};\nSegmentNodeList.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSegmentNodeList.prototype.getClass = function getClass() {\n    return SegmentNodeList;\n};\n// class NodeVertexIterator {\n//   constructor () {\n//     this._nodeList = null\n//     this._edge = null\n//     this._nodeIt = null\n//     this._currNode = null\n//     this._nextNode = null\n//     this._currSegIndex = 0\n//     let nodeList = arguments[0]\n//     this._nodeList = nodeList\n//     this._edge = nodeList.getEdge()\n//     this._nodeIt = nodeList.iterator()\n//     this.readNextNode()\n//   }\n//   next () {\n//     if (this._currNode === null) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode === null) return null\n//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n//     return null\n//   }\n//   remove () {\n//     // throw new UnsupportedOperationException(this.getClass().getName())\n//   }\n//   hasNext () {\n//     if (this._nextNode === null) return false\n//     return true\n//   }\n//   readNextNode () {\n//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n//   }\n//   interfaces_ () {\n//     return [Iterator]\n//   }\n//   getClass () {\n//     return NodeVertexIterator\n//   }\n// }\nvar Octant = function Octant() {};\nOctant.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOctant.prototype.getClass = function getClass() {\n    return Octant;\n};\nOctant.octant = function octant() {\n    if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n        var dx = arguments[0];\n        var dy = arguments[1];\n        if (dx === 0.0 && dy === 0.0) {\n            throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n        }\n        var adx = Math.abs(dx);\n        var ady = Math.abs(dy);\n        if (dx >= 0) {\n            if (dy >= 0) {\n                if (adx >= ady) {\n                    return 0;\n                } else {\n                    return 1;\n                }\n            } else {\n                if (adx >= ady) {\n                    return 7;\n                } else {\n                    return 6;\n                }\n            }\n        } else {\n            if (dy >= 0) {\n                if (adx >= ady) {\n                    return 3;\n                } else {\n                    return 2;\n                }\n            } else {\n                if (adx >= ady) {\n                    return 4;\n                } else {\n                    return 5;\n                }\n            }\n        }\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        var dx$1 = p1.x - p0.x;\n        var dy$1 = p1.y - p0.y;\n        if (dx$1 === 0.0 && dy$1 === 0.0) {\n            throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n        }\n        return Octant.octant(dx$1, dy$1);\n    }\n};\nvar SegmentString = function SegmentString() {};\nSegmentString.prototype.getCoordinates = function getCoordinates() {};\nSegmentString.prototype.size = function size() {};\nSegmentString.prototype.getCoordinate = function getCoordinate(i) {};\nSegmentString.prototype.isClosed = function isClosed() {};\nSegmentString.prototype.setData = function setData(data) {};\nSegmentString.prototype.getData = function getData() {};\nSegmentString.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSegmentString.prototype.getClass = function getClass() {\n    return SegmentString;\n};\nvar NodableSegmentString = function NodableSegmentString() {};\nNodableSegmentString.prototype.addIntersection = function addIntersection(intPt, segmentIndex) {};\nNodableSegmentString.prototype.interfaces_ = function interfaces_() {\n    return [\n        SegmentString\n    ];\n};\nNodableSegmentString.prototype.getClass = function getClass() {\n    return NodableSegmentString;\n};\nvar NodedSegmentString = function NodedSegmentString() {\n    this._nodeList = new SegmentNodeList(this);\n    this._pts = null;\n    this._data = null;\n    var pts = arguments[0];\n    var data = arguments[1];\n    this._pts = pts;\n    this._data = data;\n};\nNodedSegmentString.prototype.getCoordinates = function getCoordinates() {\n    return this._pts;\n};\nNodedSegmentString.prototype.size = function size() {\n    return this._pts.length;\n};\nNodedSegmentString.prototype.getCoordinate = function getCoordinate(i) {\n    return this._pts[i];\n};\nNodedSegmentString.prototype.isClosed = function isClosed() {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n};\nNodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {\n    if (index === this._pts.length - 1) {\n        return -1;\n    }\n    return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n};\nNodedSegmentString.prototype.setData = function setData(data) {\n    this._data = data;\n};\nNodedSegmentString.prototype.safeOctant = function safeOctant(p0, p1) {\n    if (p0.equals2D(p1)) {\n        return 0;\n    }\n    return Octant.octant(p0, p1);\n};\nNodedSegmentString.prototype.getData = function getData() {\n    return this._data;\n};\nNodedSegmentString.prototype.addIntersection = function addIntersection() {\n    if (arguments.length === 2) {\n        var intPt$1 = arguments[0];\n        var segmentIndex = arguments[1];\n        this.addIntersectionNode(intPt$1, segmentIndex);\n    } else if (arguments.length === 4) {\n        var li = arguments[0];\n        var segmentIndex$1 = arguments[1];\n        // const geomIndex = arguments[2]\n        var intIndex = arguments[3];\n        var intPt = new Coordinate(li.getIntersection(intIndex));\n        this.addIntersection(intPt, segmentIndex$1);\n    }\n};\nNodedSegmentString.prototype.toString = function toString() {\n    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n};\nNodedSegmentString.prototype.getNodeList = function getNodeList() {\n    return this._nodeList;\n};\nNodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode(intPt, segmentIndex) {\n    var normalizedSegmentIndex = segmentIndex;\n    var nextSegIndex = normalizedSegmentIndex + 1;\n    if (nextSegIndex < this._pts.length) {\n        var nextPt = this._pts[nextSegIndex];\n        if (intPt.equals2D(nextPt)) {\n            normalizedSegmentIndex = nextSegIndex;\n        }\n    }\n    var ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n    return ei;\n};\nNodedSegmentString.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {\n    var this$1 = this;\n    for(var i = 0; i < li.getIntersectionNum(); i++){\n        this$1.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n};\nNodedSegmentString.prototype.interfaces_ = function interfaces_() {\n    return [\n        NodableSegmentString\n    ];\n};\nNodedSegmentString.prototype.getClass = function getClass() {\n    return NodedSegmentString;\n};\nNodedSegmentString.getNodedSubstrings = function getNodedSubstrings() {\n    if (arguments.length === 1) {\n        var segStrings = arguments[0];\n        var resultEdgelist = new ArrayList();\n        NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n        return resultEdgelist;\n    } else if (arguments.length === 2) {\n        var segStrings$1 = arguments[0];\n        var resultEdgelist$1 = arguments[1];\n        for(var i = segStrings$1.iterator(); i.hasNext();){\n            var ss = i.next();\n            ss.getNodeList().addSplitEdges(resultEdgelist$1);\n        }\n    }\n};\nvar LineSegment = function LineSegment() {\n    this.p0 = null;\n    this.p1 = null;\n    if (arguments.length === 0) {\n        this.p0 = new Coordinate();\n        this.p1 = new Coordinate();\n    } else if (arguments.length === 1) {\n        var ls = arguments[0];\n        this.p0 = new Coordinate(ls.p0);\n        this.p1 = new Coordinate(ls.p1);\n    } else if (arguments.length === 2) {\n        this.p0 = arguments[0];\n        this.p1 = arguments[1];\n    } else if (arguments.length === 4) {\n        var x0 = arguments[0];\n        var y0 = arguments[1];\n        var x1 = arguments[2];\n        var y1 = arguments[3];\n        this.p0 = new Coordinate(x0, y0);\n        this.p1 = new Coordinate(x1, y1);\n    }\n};\nvar staticAccessors$24 = {\n    serialVersionUID: {\n        configurable: true\n    }\n};\nLineSegment.prototype.minX = function minX() {\n    return Math.min(this.p0.x, this.p1.x);\n};\nLineSegment.prototype.orientationIndex = function orientationIndex() {\n    if (arguments[0] instanceof LineSegment) {\n        var seg = arguments[0];\n        var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n        var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n        if (orient0 >= 0 && orient1 >= 0) {\n            return Math.max(orient0, orient1);\n        }\n        if (orient0 <= 0 && orient1 <= 0) {\n            return Math.max(orient0, orient1);\n        }\n        return 0;\n    } else if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        return CGAlgorithms.orientationIndex(this.p0, this.p1, p);\n    }\n};\nLineSegment.prototype.toGeometry = function toGeometry(geomFactory) {\n    return geomFactory.createLineString([\n        this.p0,\n        this.p1\n    ]);\n};\nLineSegment.prototype.isVertical = function isVertical() {\n    return this.p0.x === this.p1.x;\n};\nLineSegment.prototype.equals = function equals(o) {\n    if (!(o instanceof LineSegment)) {\n        return false;\n    }\n    var other = o;\n    return this.p0.equals(other.p0) && this.p1.equals(other.p1);\n};\nLineSegment.prototype.intersection = function intersection(line) {\n    var li = new RobustLineIntersector();\n    li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n    if (li.hasIntersection()) {\n        return li.getIntersection(0);\n    }\n    return null;\n};\nLineSegment.prototype.project = function project() {\n    if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        if (p.equals(this.p0) || p.equals(this.p1)) {\n            return new Coordinate(p);\n        }\n        var r = this.projectionFactor(p);\n        var coord = new Coordinate();\n        coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n        coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n        return coord;\n    } else if (arguments[0] instanceof LineSegment) {\n        var seg = arguments[0];\n        var pf0 = this.projectionFactor(seg.p0);\n        var pf1 = this.projectionFactor(seg.p1);\n        if (pf0 >= 1.0 && pf1 >= 1.0) {\n            return null;\n        }\n        if (pf0 <= 0.0 && pf1 <= 0.0) {\n            return null;\n        }\n        var newp0 = this.project(seg.p0);\n        if (pf0 < 0.0) {\n            newp0 = this.p0;\n        }\n        if (pf0 > 1.0) {\n            newp0 = this.p1;\n        }\n        var newp1 = this.project(seg.p1);\n        if (pf1 < 0.0) {\n            newp1 = this.p0;\n        }\n        if (pf1 > 1.0) {\n            newp1 = this.p1;\n        }\n        return new LineSegment(newp0, newp1);\n    }\n};\nLineSegment.prototype.normalize = function normalize() {\n    if (this.p1.compareTo(this.p0) < 0) {\n        this.reverse();\n    }\n};\nLineSegment.prototype.angle = function angle() {\n    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n};\nLineSegment.prototype.getCoordinate = function getCoordinate(i) {\n    if (i === 0) {\n        return this.p0;\n    }\n    return this.p1;\n};\nLineSegment.prototype.distancePerpendicular = function distancePerpendicular(p) {\n    return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);\n};\nLineSegment.prototype.minY = function minY() {\n    return Math.min(this.p0.y, this.p1.y);\n};\nLineSegment.prototype.midPoint = function midPoint() {\n    return LineSegment.midPoint(this.p0, this.p1);\n};\nLineSegment.prototype.projectionFactor = function projectionFactor(p) {\n    if (p.equals(this.p0)) {\n        return 0.0;\n    }\n    if (p.equals(this.p1)) {\n        return 1.0;\n    }\n    var dx = this.p1.x - this.p0.x;\n    var dy = this.p1.y - this.p0.y;\n    var len = dx * dx + dy * dy;\n    if (len <= 0.0) {\n        return Double.NaN;\n    }\n    var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n    return r;\n};\nLineSegment.prototype.closestPoints = function closestPoints(line) {\n    var intPt = this.intersection(line);\n    if (intPt !== null) {\n        return [\n            intPt,\n            intPt\n        ];\n    }\n    var closestPt = new Array(2).fill(null);\n    var minDistance = Double.MAX_VALUE;\n    var dist = null;\n    var close00 = this.closestPoint(line.p0);\n    minDistance = close00.distance(line.p0);\n    closestPt[0] = close00;\n    closestPt[1] = line.p0;\n    var close01 = this.closestPoint(line.p1);\n    dist = close01.distance(line.p1);\n    if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = close01;\n        closestPt[1] = line.p1;\n    }\n    var close10 = line.closestPoint(this.p0);\n    dist = close10.distance(this.p0);\n    if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p0;\n        closestPt[1] = close10;\n    }\n    var close11 = line.closestPoint(this.p1);\n    dist = close11.distance(this.p1);\n    if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p1;\n        closestPt[1] = close11;\n    }\n    return closestPt;\n};\nLineSegment.prototype.closestPoint = function closestPoint(p) {\n    var factor = this.projectionFactor(p);\n    if (factor > 0 && factor < 1) {\n        return this.project(p);\n    }\n    var dist0 = this.p0.distance(p);\n    var dist1 = this.p1.distance(p);\n    if (dist0 < dist1) {\n        return this.p0;\n    }\n    return this.p1;\n};\nLineSegment.prototype.maxX = function maxX() {\n    return Math.max(this.p0.x, this.p1.x);\n};\nLineSegment.prototype.getLength = function getLength() {\n    return this.p0.distance(this.p1);\n};\nLineSegment.prototype.compareTo = function compareTo(o) {\n    var other = o;\n    var comp0 = this.p0.compareTo(other.p0);\n    if (comp0 !== 0) {\n        return comp0;\n    }\n    return this.p1.compareTo(other.p1);\n};\nLineSegment.prototype.reverse = function reverse() {\n    var temp = this.p0;\n    this.p0 = this.p1;\n    this.p1 = temp;\n};\nLineSegment.prototype.equalsTopo = function equalsTopo(other) {\n    return this.p0.equals(other.p0) && (this.p1.equals(other.p1) || this.p0.equals(other.p1)) && this.p1.equals(other.p0);\n};\nLineSegment.prototype.lineIntersection = function lineIntersection(line) {\n    try {\n        var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n        return intPt;\n    } catch (ex) {\n        if (ex instanceof NotRepresentableException) {} else {\n            throw ex;\n        }\n    } finally{}\n    return null;\n};\nLineSegment.prototype.maxY = function maxY() {\n    return Math.max(this.p0.y, this.p1.y);\n};\nLineSegment.prototype.pointAlongOffset = function pointAlongOffset(segmentLengthFraction, offsetDistance) {\n    var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n    var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n    var dx = this.p1.x - this.p0.x;\n    var dy = this.p1.y - this.p0.y;\n    var len = Math.sqrt(dx * dx + dy * dy);\n    var ux = 0.0;\n    var uy = 0.0;\n    if (offsetDistance !== 0.0) {\n        if (len <= 0.0) {\n            throw new Error(\"Cannot compute offset from zero-length line segment\");\n        }\n        ux = offsetDistance * dx / len;\n        uy = offsetDistance * dy / len;\n    }\n    var offsetx = segx - uy;\n    var offsety = segy + ux;\n    var coord = new Coordinate(offsetx, offsety);\n    return coord;\n};\nLineSegment.prototype.setCoordinates = function setCoordinates() {\n    if (arguments.length === 1) {\n        var ls = arguments[0];\n        this.setCoordinates(ls.p0, ls.p1);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        this.p0.x = p0.x;\n        this.p0.y = p0.y;\n        this.p1.x = p1.x;\n        this.p1.y = p1.y;\n    }\n};\nLineSegment.prototype.segmentFraction = function segmentFraction(inputPt) {\n    var segFrac = this.projectionFactor(inputPt);\n    if (segFrac < 0.0) {\n        segFrac = 0.0;\n    } else if (segFrac > 1.0 || Double.isNaN(segFrac)) {\n        segFrac = 1.0;\n    }\n    return segFrac;\n};\nLineSegment.prototype.toString = function toString() {\n    return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n};\nLineSegment.prototype.isHorizontal = function isHorizontal() {\n    return this.p0.y === this.p1.y;\n};\nLineSegment.prototype.distance = function distance() {\n    if (arguments[0] instanceof LineSegment) {\n        var ls = arguments[0];\n        return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);\n    } else if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        return CGAlgorithms.distancePointLine(p, this.p0, this.p1);\n    }\n};\nLineSegment.prototype.pointAlong = function pointAlong(segmentLengthFraction) {\n    var coord = new Coordinate();\n    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n    return coord;\n};\nLineSegment.prototype.hashCode = function hashCode() {\n    var bits0 = Double.doubleToLongBits(this.p0.x);\n    bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;\n    var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n    var bits1 = Double.doubleToLongBits(this.p1.x);\n    bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;\n    var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n    return hash0 ^ hash1;\n};\nLineSegment.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable,\n        Serializable\n    ];\n};\nLineSegment.prototype.getClass = function getClass() {\n    return LineSegment;\n};\nLineSegment.midPoint = function midPoint(p0, p1) {\n    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n};\nstaticAccessors$24.serialVersionUID.get = function() {\n    return 3252005833466256227;\n};\nObject.defineProperties(LineSegment, staticAccessors$24);\nvar MonotoneChainOverlapAction = function MonotoneChainOverlapAction() {\n    this.tempEnv1 = new Envelope();\n    this.tempEnv2 = new Envelope();\n    this._overlapSeg1 = new LineSegment();\n    this._overlapSeg2 = new LineSegment();\n};\nMonotoneChainOverlapAction.prototype.overlap = function overlap() {\n    if (arguments.length === 2) {\n    // const seg1 = arguments[0]\n    // const seg2 = arguments[1]\n    } else if (arguments.length === 4) {\n        var mc1 = arguments[0];\n        var start1 = arguments[1];\n        var mc2 = arguments[2];\n        var start2 = arguments[3];\n        mc1.getLineSegment(start1, this._overlapSeg1);\n        mc2.getLineSegment(start2, this._overlapSeg2);\n        this.overlap(this._overlapSeg1, this._overlapSeg2);\n    }\n};\nMonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChainOverlapAction.prototype.getClass = function getClass() {\n    return MonotoneChainOverlapAction;\n};\nvar MonotoneChain = function MonotoneChain() {\n    this._pts = null;\n    this._start = null;\n    this._end = null;\n    this._env = null;\n    this._context = null;\n    this._id = null;\n    var pts = arguments[0];\n    var start = arguments[1];\n    var end = arguments[2];\n    var context = arguments[3];\n    this._pts = pts;\n    this._start = start;\n    this._end = end;\n    this._context = context;\n};\nMonotoneChain.prototype.getLineSegment = function getLineSegment(index, ls) {\n    ls.p0 = this._pts[index];\n    ls.p1 = this._pts[index + 1];\n};\nMonotoneChain.prototype.computeSelect = function computeSelect(searchEnv, start0, end0, mcs) {\n    var p0 = this._pts[start0];\n    var p1 = this._pts[end0];\n    mcs.tempEnv1.init(p0, p1);\n    if (end0 - start0 === 1) {\n        mcs.select(this, start0);\n        return null;\n    }\n    if (!searchEnv.intersects(mcs.tempEnv1)) {\n        return null;\n    }\n    var mid = Math.trunc((start0 + end0) / 2);\n    if (start0 < mid) {\n        this.computeSelect(searchEnv, start0, mid, mcs);\n    }\n    if (mid < end0) {\n        this.computeSelect(searchEnv, mid, end0, mcs);\n    }\n};\nMonotoneChain.prototype.getCoordinates = function getCoordinates() {\n    var this$1 = this;\n    var coord = new Array(this._end - this._start + 1).fill(null);\n    var index = 0;\n    for(var i = this._start; i <= this._end; i++){\n        coord[index++] = this$1._pts[i];\n    }\n    return coord;\n};\nMonotoneChain.prototype.computeOverlaps = function computeOverlaps(mc, mco) {\n    this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n};\nMonotoneChain.prototype.setId = function setId(id) {\n    this._id = id;\n};\nMonotoneChain.prototype.select = function select(searchEnv, mcs) {\n    this.computeSelect(searchEnv, this._start, this._end, mcs);\n};\nMonotoneChain.prototype.getEnvelope = function getEnvelope() {\n    if (this._env === null) {\n        var p0 = this._pts[this._start];\n        var p1 = this._pts[this._end];\n        this._env = new Envelope(p0, p1);\n    }\n    return this._env;\n};\nMonotoneChain.prototype.getEndIndex = function getEndIndex() {\n    return this._end;\n};\nMonotoneChain.prototype.getStartIndex = function getStartIndex() {\n    return this._start;\n};\nMonotoneChain.prototype.getContext = function getContext() {\n    return this._context;\n};\nMonotoneChain.prototype.getId = function getId() {\n    return this._id;\n};\nMonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal(start0, end0, mc, start1, end1, mco) {\n    var p00 = this._pts[start0];\n    var p01 = this._pts[end0];\n    var p10 = mc._pts[start1];\n    var p11 = mc._pts[end1];\n    if (end0 - start0 === 1 && end1 - start1 === 1) {\n        mco.overlap(this, start0, mc, start1);\n        return null;\n    }\n    mco.tempEnv1.init(p00, p01);\n    mco.tempEnv2.init(p10, p11);\n    if (!mco.tempEnv1.intersects(mco.tempEnv2)) {\n        return null;\n    }\n    var mid0 = Math.trunc((start0 + end0) / 2);\n    var mid1 = Math.trunc((start1 + end1) / 2);\n    if (start0 < mid0) {\n        if (start1 < mid1) {\n            this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);\n        }\n        if (mid1 < end1) {\n            this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);\n        }\n    }\n    if (mid0 < end0) {\n        if (start1 < mid1) {\n            this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);\n        }\n        if (mid1 < end1) {\n            this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);\n        }\n    }\n};\nMonotoneChain.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChain.prototype.getClass = function getClass() {\n    return MonotoneChain;\n};\nvar MonotoneChainBuilder = function MonotoneChainBuilder() {};\nMonotoneChainBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChainBuilder.prototype.getClass = function getClass() {\n    return MonotoneChainBuilder;\n};\nMonotoneChainBuilder.getChainStartIndices = function getChainStartIndices(pts) {\n    var start = 0;\n    var startIndexList = new ArrayList();\n    startIndexList.add(new Integer(start));\n    do {\n        var last = MonotoneChainBuilder.findChainEnd(pts, start);\n        startIndexList.add(new Integer(last));\n        start = last;\n    }while (start < pts.length - 1);\n    var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n    return startIndex;\n};\nMonotoneChainBuilder.findChainEnd = function findChainEnd(pts, start) {\n    var safeStart = start;\n    while(safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])){\n        safeStart++;\n    }\n    if (safeStart >= pts.length - 1) {\n        return pts.length - 1;\n    }\n    var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n    var last = start + 1;\n    while(last < pts.length){\n        if (!pts[last - 1].equals2D(pts[last])) {\n            var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n            if (quad !== chainQuad) {\n                break;\n            }\n        }\n        last++;\n    }\n    return last - 1;\n};\nMonotoneChainBuilder.getChains = function getChains() {\n    if (arguments.length === 1) {\n        var pts = arguments[0];\n        return MonotoneChainBuilder.getChains(pts, null);\n    } else if (arguments.length === 2) {\n        var pts$1 = arguments[0];\n        var context = arguments[1];\n        var mcList = new ArrayList();\n        var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);\n        for(var i = 0; i < startIndex.length - 1; i++){\n            var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);\n            mcList.add(mc);\n        }\n        return mcList;\n    }\n};\nMonotoneChainBuilder.toIntArray = function toIntArray(list) {\n    var array = new Array(list.size()).fill(null);\n    for(var i = 0; i < array.length; i++){\n        array[i] = list.get(i).intValue();\n    }\n    return array;\n};\nvar Noder = function Noder() {};\nNoder.prototype.computeNodes = function computeNodes(segStrings) {};\nNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {};\nNoder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nNoder.prototype.getClass = function getClass() {\n    return Noder;\n};\nvar SinglePassNoder = function SinglePassNoder() {\n    this._segInt = null;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var segInt = arguments[0];\n        this.setSegmentIntersector(segInt);\n    }\n};\nSinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector(segInt) {\n    this._segInt = segInt;\n};\nSinglePassNoder.prototype.interfaces_ = function interfaces_() {\n    return [\n        Noder\n    ];\n};\nSinglePassNoder.prototype.getClass = function getClass() {\n    return SinglePassNoder;\n};\nvar MCIndexNoder = function(SinglePassNoder$$1) {\n    function MCIndexNoder(si) {\n        if (si) {\n            SinglePassNoder$$1.call(this, si);\n        } else {\n            SinglePassNoder$$1.call(this);\n        }\n        this._monoChains = new ArrayList();\n        this._index = new STRtree();\n        this._idCounter = 0;\n        this._nodedSegStrings = null;\n        this._nOverlaps = 0;\n    }\n    if (SinglePassNoder$$1) MCIndexNoder.__proto__ = SinglePassNoder$$1;\n    MCIndexNoder.prototype = Object.create(SinglePassNoder$$1 && SinglePassNoder$$1.prototype);\n    MCIndexNoder.prototype.constructor = MCIndexNoder;\n    var staticAccessors = {\n        SegmentOverlapAction: {\n            configurable: true\n        }\n    };\n    MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains() {\n        return this._monoChains;\n    };\n    MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {\n        return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n    };\n    MCIndexNoder.prototype.getIndex = function getIndex() {\n        return this._index;\n    };\n    MCIndexNoder.prototype.add = function add(segStr) {\n        var this$1 = this;\n        var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n        for(var i = segChains.iterator(); i.hasNext();){\n            var mc = i.next();\n            mc.setId(this$1._idCounter++);\n            this$1._index.insert(mc.getEnvelope(), mc);\n            this$1._monoChains.add(mc);\n        }\n    };\n    MCIndexNoder.prototype.computeNodes = function computeNodes(inputSegStrings) {\n        var this$1 = this;\n        this._nodedSegStrings = inputSegStrings;\n        for(var i = inputSegStrings.iterator(); i.hasNext();){\n            this$1.add(i.next());\n        }\n        this.intersectChains();\n    };\n    MCIndexNoder.prototype.intersectChains = function intersectChains() {\n        var this$1 = this;\n        var overlapAction = new SegmentOverlapAction(this._segInt);\n        for(var i = this._monoChains.iterator(); i.hasNext();){\n            var queryChain = i.next();\n            var overlapChains = this$1._index.query(queryChain.getEnvelope());\n            for(var j = overlapChains.iterator(); j.hasNext();){\n                var testChain = j.next();\n                if (testChain.getId() > queryChain.getId()) {\n                    queryChain.computeOverlaps(testChain, overlapAction);\n                    this$1._nOverlaps++;\n                }\n                if (this$1._segInt.isDone()) {\n                    return null;\n                }\n            }\n        }\n    };\n    MCIndexNoder.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    MCIndexNoder.prototype.getClass = function getClass() {\n        return MCIndexNoder;\n    };\n    staticAccessors.SegmentOverlapAction.get = function() {\n        return SegmentOverlapAction;\n    };\n    Object.defineProperties(MCIndexNoder, staticAccessors);\n    return MCIndexNoder;\n}(SinglePassNoder);\nvar SegmentOverlapAction = function(MonotoneChainOverlapAction$$1) {\n    function SegmentOverlapAction() {\n        MonotoneChainOverlapAction$$1.call(this);\n        this._si = null;\n        var si = arguments[0];\n        this._si = si;\n    }\n    if (MonotoneChainOverlapAction$$1) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;\n    SegmentOverlapAction.prototype = Object.create(MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype);\n    SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;\n    SegmentOverlapAction.prototype.overlap = function overlap() {\n        if (arguments.length === 4) {\n            var mc1 = arguments[0];\n            var start1 = arguments[1];\n            var mc2 = arguments[2];\n            var start2 = arguments[3];\n            var ss1 = mc1.getContext();\n            var ss2 = mc2.getContext();\n            this._si.processIntersections(ss1, start1, ss2, start2);\n        } else {\n            return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments);\n        }\n    };\n    SegmentOverlapAction.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    SegmentOverlapAction.prototype.getClass = function getClass() {\n        return SegmentOverlapAction;\n    };\n    return SegmentOverlapAction;\n}(MonotoneChainOverlapAction);\nvar BufferParameters = function BufferParameters() {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n    this._endCapStyle = BufferParameters.CAP_ROUND;\n    this._joinStyle = BufferParameters.JOIN_ROUND;\n    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n    this._isSingleSided = false;\n    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var quadrantSegments = arguments[0];\n        this.setQuadrantSegments(quadrantSegments);\n    } else if (arguments.length === 2) {\n        var quadrantSegments$1 = arguments[0];\n        var endCapStyle = arguments[1];\n        this.setQuadrantSegments(quadrantSegments$1);\n        this.setEndCapStyle(endCapStyle);\n    } else if (arguments.length === 4) {\n        var quadrantSegments$2 = arguments[0];\n        var endCapStyle$1 = arguments[1];\n        var joinStyle = arguments[2];\n        var mitreLimit = arguments[3];\n        this.setQuadrantSegments(quadrantSegments$2);\n        this.setEndCapStyle(endCapStyle$1);\n        this.setJoinStyle(joinStyle);\n        this.setMitreLimit(mitreLimit);\n    }\n};\nvar staticAccessors$25 = {\n    CAP_ROUND: {\n        configurable: true\n    },\n    CAP_FLAT: {\n        configurable: true\n    },\n    CAP_SQUARE: {\n        configurable: true\n    },\n    JOIN_ROUND: {\n        configurable: true\n    },\n    JOIN_MITRE: {\n        configurable: true\n    },\n    JOIN_BEVEL: {\n        configurable: true\n    },\n    DEFAULT_QUADRANT_SEGMENTS: {\n        configurable: true\n    },\n    DEFAULT_MITRE_LIMIT: {\n        configurable: true\n    },\n    DEFAULT_SIMPLIFY_FACTOR: {\n        configurable: true\n    }\n};\nBufferParameters.prototype.getEndCapStyle = function getEndCapStyle() {\n    return this._endCapStyle;\n};\nBufferParameters.prototype.isSingleSided = function isSingleSided() {\n    return this._isSingleSided;\n};\nBufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments(quadSegs) {\n    this._quadrantSegments = quadSegs;\n    if (this._quadrantSegments === 0) {\n        this._joinStyle = BufferParameters.JOIN_BEVEL;\n    }\n    if (this._quadrantSegments < 0) {\n        this._joinStyle = BufferParameters.JOIN_MITRE;\n        this._mitreLimit = Math.abs(this._quadrantSegments);\n    }\n    if (quadSegs <= 0) {\n        this._quadrantSegments = 1;\n    }\n    if (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n    }\n};\nBufferParameters.prototype.getJoinStyle = function getJoinStyle() {\n    return this._joinStyle;\n};\nBufferParameters.prototype.setJoinStyle = function setJoinStyle(joinStyle) {\n    this._joinStyle = joinStyle;\n};\nBufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor(simplifyFactor) {\n    this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n};\nBufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor() {\n    return this._simplifyFactor;\n};\nBufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments() {\n    return this._quadrantSegments;\n};\nBufferParameters.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {\n    this._endCapStyle = endCapStyle;\n};\nBufferParameters.prototype.getMitreLimit = function getMitreLimit() {\n    return this._mitreLimit;\n};\nBufferParameters.prototype.setMitreLimit = function setMitreLimit(mitreLimit) {\n    this._mitreLimit = mitreLimit;\n};\nBufferParameters.prototype.setSingleSided = function setSingleSided(isSingleSided) {\n    this._isSingleSided = isSingleSided;\n};\nBufferParameters.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferParameters.prototype.getClass = function getClass() {\n    return BufferParameters;\n};\nBufferParameters.bufferDistanceError = function bufferDistanceError(quadSegs) {\n    var alpha = Math.PI / 2.0 / quadSegs;\n    return 1 - Math.cos(alpha / 2.0);\n};\nstaticAccessors$25.CAP_ROUND.get = function() {\n    return 1;\n};\nstaticAccessors$25.CAP_FLAT.get = function() {\n    return 2;\n};\nstaticAccessors$25.CAP_SQUARE.get = function() {\n    return 3;\n};\nstaticAccessors$25.JOIN_ROUND.get = function() {\n    return 1;\n};\nstaticAccessors$25.JOIN_MITRE.get = function() {\n    return 2;\n};\nstaticAccessors$25.JOIN_BEVEL.get = function() {\n    return 3;\n};\nstaticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function() {\n    return 8;\n};\nstaticAccessors$25.DEFAULT_MITRE_LIMIT.get = function() {\n    return 5.0;\n};\nstaticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function() {\n    return 0.01;\n};\nObject.defineProperties(BufferParameters, staticAccessors$25);\nvar BufferInputLineSimplifier = function BufferInputLineSimplifier(inputLine) {\n    this._distanceTol = null;\n    this._isDeleted = null;\n    this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n    this._inputLine = inputLine || null;\n};\nvar staticAccessors$26 = {\n    INIT: {\n        configurable: true\n    },\n    DELETE: {\n        configurable: true\n    },\n    KEEP: {\n        configurable: true\n    },\n    NUM_PTS_TO_CHECK: {\n        configurable: true\n    }\n};\nBufferInputLineSimplifier.prototype.isDeletable = function isDeletable(i0, i1, i2, distanceTol) {\n    var p0 = this._inputLine[i0];\n    var p1 = this._inputLine[i1];\n    var p2 = this._inputLine[i2];\n    if (!this.isConcave(p0, p1, p2)) {\n        return false;\n    }\n    if (!this.isShallow(p0, p1, p2, distanceTol)) {\n        return false;\n    }\n    return this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n};\nBufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities() {\n    var this$1 = this;\n    var index = 1;\n    // const maxIndex = this._inputLine.length - 1\n    var midIndex = this.findNextNonDeletedIndex(index);\n    var lastIndex = this.findNextNonDeletedIndex(midIndex);\n    var isChanged = false;\n    while(lastIndex < this._inputLine.length){\n        var isMiddleVertexDeleted = false;\n        if (this$1.isDeletable(index, midIndex, lastIndex, this$1._distanceTol)) {\n            this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n            isMiddleVertexDeleted = true;\n            isChanged = true;\n        }\n        if (isMiddleVertexDeleted) {\n            index = lastIndex;\n        } else {\n            index = midIndex;\n        }\n        midIndex = this$1.findNextNonDeletedIndex(index);\n        lastIndex = this$1.findNextNonDeletedIndex(midIndex);\n    }\n    return isChanged;\n};\nBufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity(p0, p1, p2, distanceTol) {\n    var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n    var isAngleToSimplify = orientation === this._angleOrientation;\n    if (!isAngleToSimplify) {\n        return false;\n    }\n    var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n    return dist < distanceTol;\n};\nBufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled(p0, p2, i0, i2, distanceTol) {\n    var this$1 = this;\n    var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n    if (inc <= 0) {\n        inc = 1;\n    }\n    for(var i = i0; i < i2; i += inc){\n        if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) {\n            return false;\n        }\n    }\n    return true;\n};\nBufferInputLineSimplifier.prototype.isConcave = function isConcave(p0, p1, p2) {\n    var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n    var isConcave = orientation === this._angleOrientation;\n    return isConcave;\n};\nBufferInputLineSimplifier.prototype.simplify = function simplify(distanceTol) {\n    var this$1 = this;\n    this._distanceTol = Math.abs(distanceTol);\n    if (distanceTol < 0) {\n        this._angleOrientation = CGAlgorithms.CLOCKWISE;\n    }\n    this._isDeleted = new Array(this._inputLine.length).fill(null);\n    var isChanged = false;\n    do {\n        isChanged = this$1.deleteShallowConcavities();\n    }while (isChanged);\n    return this.collapseLine();\n};\nBufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex(index) {\n    var next = index + 1;\n    while(next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE){\n        next++;\n    }\n    return next;\n};\nBufferInputLineSimplifier.prototype.isShallow = function isShallow(p0, p1, p2, distanceTol) {\n    var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n    return dist < distanceTol;\n};\nBufferInputLineSimplifier.prototype.collapseLine = function collapseLine() {\n    var this$1 = this;\n    var coordList = new CoordinateList();\n    for(var i = 0; i < this._inputLine.length; i++){\n        if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) {\n            coordList.add(this$1._inputLine[i]);\n        }\n    }\n    return coordList.toCoordinateArray();\n};\nBufferInputLineSimplifier.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferInputLineSimplifier.prototype.getClass = function getClass() {\n    return BufferInputLineSimplifier;\n};\nBufferInputLineSimplifier.simplify = function simplify(inputLine, distanceTol) {\n    var simp = new BufferInputLineSimplifier(inputLine);\n    return simp.simplify(distanceTol);\n};\nstaticAccessors$26.INIT.get = function() {\n    return 0;\n};\nstaticAccessors$26.DELETE.get = function() {\n    return 1;\n};\nstaticAccessors$26.KEEP.get = function() {\n    return 1;\n};\nstaticAccessors$26.NUM_PTS_TO_CHECK.get = function() {\n    return 10;\n};\nObject.defineProperties(BufferInputLineSimplifier, staticAccessors$26);\nvar OffsetSegmentString = function OffsetSegmentString() {\n    this._ptList = null;\n    this._precisionModel = null;\n    this._minimimVertexDistance = 0.0;\n    this._ptList = new ArrayList();\n};\nvar staticAccessors$28 = {\n    COORDINATE_ARRAY_TYPE: {\n        configurable: true\n    }\n};\nOffsetSegmentString.prototype.getCoordinates = function getCoordinates() {\n    var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n    return coord;\n};\nOffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel;\n};\nOffsetSegmentString.prototype.addPt = function addPt(pt) {\n    var bufPt = new Coordinate(pt);\n    this._precisionModel.makePrecise(bufPt);\n    if (this.isRedundant(bufPt)) {\n        return null;\n    }\n    this._ptList.add(bufPt);\n};\nOffsetSegmentString.prototype.revere = function revere() {};\nOffsetSegmentString.prototype.addPts = function addPts(pt, isForward) {\n    var this$1 = this;\n    if (isForward) {\n        for(var i = 0; i < pt.length; i++){\n            this$1.addPt(pt[i]);\n        }\n    } else {\n        for(var i$1 = pt.length - 1; i$1 >= 0; i$1--){\n            this$1.addPt(pt[i$1]);\n        }\n    }\n};\nOffsetSegmentString.prototype.isRedundant = function isRedundant(pt) {\n    if (this._ptList.size() < 1) {\n        return false;\n    }\n    var lastPt = this._ptList.get(this._ptList.size() - 1);\n    var ptDist = pt.distance(lastPt);\n    if (ptDist < this._minimimVertexDistance) {\n        return true;\n    }\n    return false;\n};\nOffsetSegmentString.prototype.toString = function toString() {\n    var fact = new GeometryFactory();\n    var line = fact.createLineString(this.getCoordinates());\n    return line.toString();\n};\nOffsetSegmentString.prototype.closeRing = function closeRing() {\n    if (this._ptList.size() < 1) {\n        return null;\n    }\n    var startPt = new Coordinate(this._ptList.get(0));\n    var lastPt = this._ptList.get(this._ptList.size() - 1);\n    // const last2Pt = null\n    // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)\n    if (startPt.equals(lastPt)) {\n        return null;\n    }\n    this._ptList.add(startPt);\n};\nOffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance(minimimVertexDistance) {\n    this._minimimVertexDistance = minimimVertexDistance;\n};\nOffsetSegmentString.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOffsetSegmentString.prototype.getClass = function getClass() {\n    return OffsetSegmentString;\n};\nstaticAccessors$28.COORDINATE_ARRAY_TYPE.get = function() {\n    return new Array(0).fill(null);\n};\nObject.defineProperties(OffsetSegmentString, staticAccessors$28);\nvar Angle = function Angle() {};\nvar staticAccessors$29 = {\n    PI_TIMES_2: {\n        configurable: true\n    },\n    PI_OVER_2: {\n        configurable: true\n    },\n    PI_OVER_4: {\n        configurable: true\n    },\n    COUNTERCLOCKWISE: {\n        configurable: true\n    },\n    CLOCKWISE: {\n        configurable: true\n    },\n    NONE: {\n        configurable: true\n    }\n};\nAngle.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nAngle.prototype.getClass = function getClass() {\n    return Angle;\n};\nAngle.toDegrees = function toDegrees(radians) {\n    return radians * 180 / Math.PI;\n};\nAngle.normalize = function normalize(angle) {\n    while(angle > Math.PI){\n        angle -= Angle.PI_TIMES_2;\n    }\n    while(angle <= -Math.PI){\n        angle += Angle.PI_TIMES_2;\n    }\n    return angle;\n};\nAngle.angle = function angle() {\n    if (arguments.length === 1) {\n        var p = arguments[0];\n        return Math.atan2(p.y, p.x);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        var dx = p1.x - p0.x;\n        var dy = p1.y - p0.y;\n        return Math.atan2(dy, dx);\n    }\n};\nAngle.isAcute = function isAcute(p0, p1, p2) {\n    var dx0 = p0.x - p1.x;\n    var dy0 = p0.y - p1.y;\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dotprod = dx0 * dx1 + dy0 * dy1;\n    return dotprod > 0;\n};\nAngle.isObtuse = function isObtuse(p0, p1, p2) {\n    var dx0 = p0.x - p1.x;\n    var dy0 = p0.y - p1.y;\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dotprod = dx0 * dx1 + dy0 * dy1;\n    return dotprod < 0;\n};\nAngle.interiorAngle = function interiorAngle(p0, p1, p2) {\n    var anglePrev = Angle.angle(p1, p0);\n    var angleNext = Angle.angle(p1, p2);\n    return Math.abs(angleNext - anglePrev);\n};\nAngle.normalizePositive = function normalizePositive(angle) {\n    if (angle < 0.0) {\n        while(angle < 0.0){\n            angle += Angle.PI_TIMES_2;\n        }\n        if (angle >= Angle.PI_TIMES_2) {\n            angle = 0.0;\n        }\n    } else {\n        while(angle >= Angle.PI_TIMES_2){\n            angle -= Angle.PI_TIMES_2;\n        }\n        if (angle < 0.0) {\n            angle = 0.0;\n        }\n    }\n    return angle;\n};\nAngle.angleBetween = function angleBetween(tip1, tail, tip2) {\n    var a1 = Angle.angle(tail, tip1);\n    var a2 = Angle.angle(tail, tip2);\n    return Angle.diff(a1, a2);\n};\nAngle.diff = function diff(ang1, ang2) {\n    var delAngle = null;\n    if (ang1 < ang2) {\n        delAngle = ang2 - ang1;\n    } else {\n        delAngle = ang1 - ang2;\n    }\n    if (delAngle > Math.PI) {\n        delAngle = 2 * Math.PI - delAngle;\n    }\n    return delAngle;\n};\nAngle.toRadians = function toRadians(angleDegrees) {\n    return angleDegrees * Math.PI / 180.0;\n};\nAngle.getTurn = function getTurn(ang1, ang2) {\n    var crossproduct = Math.sin(ang2 - ang1);\n    if (crossproduct > 0) {\n        return Angle.COUNTERCLOCKWISE;\n    }\n    if (crossproduct < 0) {\n        return Angle.CLOCKWISE;\n    }\n    return Angle.NONE;\n};\nAngle.angleBetweenOriented = function angleBetweenOriented(tip1, tail, tip2) {\n    var a1 = Angle.angle(tail, tip1);\n    var a2 = Angle.angle(tail, tip2);\n    var angDel = a2 - a1;\n    if (angDel <= -Math.PI) {\n        return angDel + Angle.PI_TIMES_2;\n    }\n    if (angDel > Math.PI) {\n        return angDel - Angle.PI_TIMES_2;\n    }\n    return angDel;\n};\nstaticAccessors$29.PI_TIMES_2.get = function() {\n    return 2.0 * Math.PI;\n};\nstaticAccessors$29.PI_OVER_2.get = function() {\n    return Math.PI / 2.0;\n};\nstaticAccessors$29.PI_OVER_4.get = function() {\n    return Math.PI / 4.0;\n};\nstaticAccessors$29.COUNTERCLOCKWISE.get = function() {\n    return CGAlgorithms.COUNTERCLOCKWISE;\n};\nstaticAccessors$29.CLOCKWISE.get = function() {\n    return CGAlgorithms.CLOCKWISE;\n};\nstaticAccessors$29.NONE.get = function() {\n    return CGAlgorithms.COLLINEAR;\n};\nObject.defineProperties(Angle, staticAccessors$29);\nvar OffsetSegmentGenerator = function OffsetSegmentGenerator() {\n    this._maxCurveSegmentError = 0.0;\n    this._filletAngleQuantum = null;\n    this._closingSegLengthFactor = 1;\n    this._segList = null;\n    this._distance = 0.0;\n    this._precisionModel = null;\n    this._bufParams = null;\n    this._li = null;\n    this._s0 = null;\n    this._s1 = null;\n    this._s2 = null;\n    this._seg0 = new LineSegment();\n    this._seg1 = new LineSegment();\n    this._offset0 = new LineSegment();\n    this._offset1 = new LineSegment();\n    this._side = 0;\n    this._hasNarrowConcaveAngle = false;\n    var precisionModel = arguments[0];\n    var bufParams = arguments[1];\n    var distance = arguments[2];\n    this._precisionModel = precisionModel;\n    this._bufParams = bufParams;\n    this._li = new RobustLineIntersector();\n    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) {\n        this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n    }\n    this.init(distance);\n};\nvar staticAccessors$27 = {\n    OFFSET_SEGMENT_SEPARATION_FACTOR: {\n        configurable: true\n    },\n    INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {\n        configurable: true\n    },\n    CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {\n        configurable: true\n    },\n    MAX_CLOSING_SEG_LEN_FACTOR: {\n        configurable: true\n    }\n};\nOffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment(p, addStartPoint) {\n    this._s0 = this._s1;\n    this._s1 = this._s2;\n    this._s2 = p;\n    this._seg0.setCoordinates(this._s0, this._s1);\n    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n    this._seg1.setCoordinates(this._s1, this._s2);\n    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n    if (this._s1.equals(this._s2)) {\n        return null;\n    }\n    var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n    var outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n    if (orientation === 0) {\n        this.addCollinear(addStartPoint);\n    } else if (outsideTurn) {\n        this.addOutsideTurn(orientation, addStartPoint);\n    } else {\n        this.addInsideTurn(orientation, addStartPoint);\n    }\n};\nOffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap(p0, p1) {\n    var seg = new LineSegment(p0, p1);\n    var offsetL = new LineSegment();\n    this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n    var offsetR = new LineSegment();\n    this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    var angle = Math.atan2(dy, dx);\n    switch(this._bufParams.getEndCapStyle()){\n        case BufferParameters.CAP_ROUND:\n            this._segList.addPt(offsetL.p1);\n            this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n            this._segList.addPt(offsetR.p1);\n            break;\n        case BufferParameters.CAP_FLAT:\n            this._segList.addPt(offsetL.p1);\n            this._segList.addPt(offsetR.p1);\n            break;\n        case BufferParameters.CAP_SQUARE:\n            var squareCapSideOffset = new Coordinate();\n            squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n            squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n            var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n            var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n            this._segList.addPt(squareCapLOffset);\n            this._segList.addPt(squareCapROffset);\n            break;\n        default:\n    }\n};\nOffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates() {\n    var pts = this._segList.getCoordinates();\n    return pts;\n};\nOffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin(p, offset0, offset1, distance) {\n    var isMitreWithinLimit = true;\n    var intPt = null;\n    try {\n        intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n        var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n        if (mitreRatio > this._bufParams.getMitreLimit()) {\n            isMitreWithinLimit = false;\n        }\n    } catch (ex) {\n        if (ex instanceof NotRepresentableException) {\n            intPt = new Coordinate(0, 0);\n            isMitreWithinLimit = false;\n        } else {\n            throw ex;\n        }\n    } finally{}\n    if (isMitreWithinLimit) {\n        this._segList.addPt(intPt);\n    } else {\n        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n    }\n};\nOffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner(p, p0, p1, direction, radius) {\n    var dx0 = p0.x - p.x;\n    var dy0 = p0.y - p.y;\n    var startAngle = Math.atan2(dy0, dx0);\n    var dx1 = p1.x - p.x;\n    var dy1 = p1.y - p.y;\n    var endAngle = Math.atan2(dy1, dx1);\n    if (direction === CGAlgorithms.CLOCKWISE) {\n        if (startAngle <= endAngle) {\n            startAngle += 2.0 * Math.PI;\n        }\n    } else {\n        if (startAngle >= endAngle) {\n            startAngle -= 2.0 * Math.PI;\n        }\n    }\n    this._segList.addPt(p0);\n    this.addFilletArc(p, startAngle, endAngle, direction, radius);\n    this._segList.addPt(p1);\n};\nOffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn(orientation, addStartPoint) {\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n        this._segList.addPt(this._offset0.p1);\n        return null;\n    }\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n    } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n        this.addBevelJoin(this._offset0, this._offset1);\n    } else {\n        if (addStartPoint) {\n            this._segList.addPt(this._offset0.p1);\n        }\n        this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n        this._segList.addPt(this._offset1.p0);\n    }\n};\nOffsetSegmentGenerator.prototype.createSquare = function createSquare(p) {\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n    this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addSegments = function addSegments(pt, isForward) {\n    this._segList.addPts(pt, isForward);\n};\nOffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment() {\n    this._segList.addPt(this._offset1.p0);\n};\nOffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment() {\n    this._segList.addPt(this._offset1.p1);\n};\nOffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments(s1, s2, side) {\n    this._s1 = s1;\n    this._s2 = s2;\n    this._side = side;\n    this._seg1.setCoordinates(s1, s2);\n    this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n};\nOffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n    var basePt = this._seg0.p1;\n    var ang0 = Angle.angle(basePt, this._seg0.p0);\n    // const ang1 = Angle.angle(basePt, this._seg1.p1)\n    var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n    var angDiffHalf = angDiff / 2;\n    var midAng = Angle.normalize(ang0 + angDiffHalf);\n    var mitreMidAng = Angle.normalize(midAng + Math.PI);\n    var mitreDist = mitreLimit * distance;\n    var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n    var bevelHalfLen = distance - bevelDelta;\n    var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n    var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n    var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n    var mitreMidLine = new LineSegment(basePt, bevelMidPt);\n    var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n    var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n    if (this._side === Position.LEFT) {\n        this._segList.addPt(bevelEndLeft);\n        this._segList.addPt(bevelEndRight);\n    } else {\n        this._segList.addPt(bevelEndRight);\n        this._segList.addPt(bevelEndLeft);\n    }\n};\nOffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment(seg, side, distance, offset) {\n    var sideSign = side === Position.LEFT ? 1 : -1;\n    var dx = seg.p1.x - seg.p0.x;\n    var dy = seg.p1.y - seg.p0.y;\n    var len = Math.sqrt(dx * dx + dy * dy);\n    var ux = sideSign * distance * dx / len;\n    var uy = sideSign * distance * dy / len;\n    offset.p0.x = seg.p0.x - uy;\n    offset.p0.y = seg.p0.y + ux;\n    offset.p1.x = seg.p1.x - uy;\n    offset.p1.y = seg.p1.y + ux;\n};\nOffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc(p, startAngle, endAngle, direction, radius) {\n    var this$1 = this;\n    var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n    var totalAngle = Math.abs(startAngle - endAngle);\n    var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n    if (nSegs < 1) {\n        return null;\n    }\n    var initAngle = 0.0;\n    var currAngleInc = totalAngle / nSegs;\n    var currAngle = initAngle;\n    var pt = new Coordinate();\n    while(currAngle < totalAngle){\n        var angle = startAngle + directionFactor * currAngle;\n        pt.x = p.x + radius * Math.cos(angle);\n        pt.y = p.y + radius * Math.sin(angle);\n        this$1._segList.addPt(pt);\n        currAngle += currAngleInc;\n    }\n};\nOffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn(orientation, addStartPoint) {\n    this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n    if (this._li.hasIntersection()) {\n        this._segList.addPt(this._li.getIntersection(0));\n    } else {\n        this._hasNarrowConcaveAngle = true;\n        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n            this._segList.addPt(this._offset0.p1);\n        } else {\n            this._segList.addPt(this._offset0.p1);\n            if (this._closingSegLengthFactor > 0) {\n                var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n                this._segList.addPt(mid0);\n                var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n                this._segList.addPt(mid1);\n            } else {\n                this._segList.addPt(this._s1);\n            }\n            this._segList.addPt(this._offset1.p0);\n        }\n    }\n};\nOffsetSegmentGenerator.prototype.createCircle = function createCircle(p) {\n    var pt = new Coordinate(p.x + this._distance, p.y);\n    this._segList.addPt(pt);\n    this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n    this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin(offset0, offset1) {\n    this._segList.addPt(offset0.p1);\n    this._segList.addPt(offset1.p0);\n};\nOffsetSegmentGenerator.prototype.init = function init(distance) {\n    this._distance = distance;\n    this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n    this._segList = new OffsetSegmentString();\n    this._segList.setPrecisionModel(this._precisionModel);\n    this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n};\nOffsetSegmentGenerator.prototype.addCollinear = function addCollinear(addStartPoint) {\n    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n    var numInt = this._li.getIntersectionNum();\n    if (numInt >= 2) {\n        if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n            if (addStartPoint) {\n                this._segList.addPt(this._offset0.p1);\n            }\n            this._segList.addPt(this._offset1.p0);\n        } else {\n            this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n        }\n    }\n};\nOffsetSegmentGenerator.prototype.closeRing = function closeRing() {\n    this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle() {\n    return this._hasNarrowConcaveAngle;\n};\nOffsetSegmentGenerator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOffsetSegmentGenerator.prototype.getClass = function getClass() {\n    return OffsetSegmentGenerator;\n};\nstaticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {\n    return 1.0E-3;\n};\nstaticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {\n    return 1.0E-3;\n};\nstaticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {\n    return 1.0E-6;\n};\nstaticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {\n    return 80;\n};\nObject.defineProperties(OffsetSegmentGenerator, staticAccessors$27);\nvar OffsetCurveBuilder = function OffsetCurveBuilder() {\n    this._distance = 0.0;\n    this._precisionModel = null;\n    this._bufParams = null;\n    var precisionModel = arguments[0];\n    var bufParams = arguments[1];\n    this._precisionModel = precisionModel;\n    this._bufParams = bufParams;\n};\nOffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve(inputPts, distance) {\n    this._distance = distance;\n    if (distance === 0.0) {\n        return null;\n    }\n    var isRightSide = distance < 0.0;\n    var posDistance = Math.abs(distance);\n    var segGen = this.getSegGen(posDistance);\n    if (inputPts.length <= 1) {\n        this.computePointCurve(inputPts[0], segGen);\n    } else {\n        this.computeOffsetCurve(inputPts, isRightSide, segGen);\n    }\n    var curvePts = segGen.getCoordinates();\n    if (isRightSide) {\n        CoordinateArrays.reverse(curvePts);\n    }\n    return curvePts;\n};\nOffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n    var distTol = this.simplifyTolerance(this._distance);\n    if (isRightSide) {\n        segGen.addSegments(inputPts, true);\n        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        var n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n        for(var i = n2 - 2; i >= 0; i--){\n            segGen.addNextSegment(simp2[i], true);\n        }\n    } else {\n        segGen.addSegments(inputPts, false);\n        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        var n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n        for(var i$1 = 2; i$1 <= n1; i$1++){\n            segGen.addNextSegment(simp1[i$1], true);\n        }\n    }\n    segGen.addLastSegment();\n    segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve(inputPts, side, segGen) {\n    var distTol = this.simplifyTolerance(this._distance);\n    if (side === Position.RIGHT) {\n        distTol = -distTol;\n    }\n    var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n = simp.length - 1;\n    segGen.initSideSegments(simp[n - 1], simp[0], side);\n    for(var i = 1; i <= n; i++){\n        var addStartPoint = i !== 1;\n        segGen.addNextSegment(simp[i], addStartPoint);\n    }\n    segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve(inputPts, segGen) {\n    var distTol = this.simplifyTolerance(this._distance);\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    for(var i = 2; i <= n1; i++){\n        segGen.addNextSegment(simp1[i], true);\n    }\n    segGen.addLastSegment();\n    segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    for(var i$1 = n2 - 2; i$1 >= 0; i$1--){\n        segGen.addNextSegment(simp2[i$1], true);\n    }\n    segGen.addLastSegment();\n    segGen.addLineEndCap(simp2[1], simp2[0]);\n    segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computePointCurve = function computePointCurve(pt, segGen) {\n    switch(this._bufParams.getEndCapStyle()){\n        case BufferParameters.CAP_ROUND:\n            segGen.createCircle(pt);\n            break;\n        case BufferParameters.CAP_SQUARE:\n            segGen.createSquare(pt);\n            break;\n        default:\n    }\n};\nOffsetCurveBuilder.prototype.getLineCurve = function getLineCurve(inputPts, distance) {\n    this._distance = distance;\n    if (distance < 0.0 && !this._bufParams.isSingleSided()) {\n        return null;\n    }\n    if (distance === 0.0) {\n        return null;\n    }\n    var posDistance = Math.abs(distance);\n    var segGen = this.getSegGen(posDistance);\n    if (inputPts.length <= 1) {\n        this.computePointCurve(inputPts[0], segGen);\n    } else {\n        if (this._bufParams.isSingleSided()) {\n            var isRightSide = distance < 0.0;\n            this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n        } else {\n            this.computeLineBufferCurve(inputPts, segGen);\n        }\n    }\n    var lineCoord = segGen.getCoordinates();\n    return lineCoord;\n};\nOffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters() {\n    return this._bufParams;\n};\nOffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance(bufDistance) {\n    return bufDistance * this._bufParams.getSimplifyFactor();\n};\nOffsetCurveBuilder.prototype.getRingCurve = function getRingCurve(inputPts, side, distance) {\n    this._distance = distance;\n    if (inputPts.length <= 2) {\n        return this.getLineCurve(inputPts, distance);\n    }\n    if (distance === 0.0) {\n        return OffsetCurveBuilder.copyCoordinates(inputPts);\n    }\n    var segGen = this.getSegGen(distance);\n    this.computeRingBufferCurve(inputPts, side, segGen);\n    return segGen.getCoordinates();\n};\nOffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve(inputPts, isRightSide, segGen) {\n    var distTol = this.simplifyTolerance(this._distance);\n    if (isRightSide) {\n        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        var n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n        for(var i = n2 - 2; i >= 0; i--){\n            segGen.addNextSegment(simp2[i], true);\n        }\n    } else {\n        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        var n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n        for(var i$1 = 2; i$1 <= n1; i$1++){\n            segGen.addNextSegment(simp1[i$1], true);\n        }\n    }\n    segGen.addLastSegment();\n};\nOffsetCurveBuilder.prototype.getSegGen = function getSegGen(distance) {\n    return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n};\nOffsetCurveBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOffsetCurveBuilder.prototype.getClass = function getClass() {\n    return OffsetCurveBuilder;\n};\nOffsetCurveBuilder.copyCoordinates = function copyCoordinates(pts) {\n    var copy = new Array(pts.length).fill(null);\n    for(var i = 0; i < copy.length; i++){\n        copy[i] = new Coordinate(pts[i]);\n    }\n    return copy;\n};\nvar SubgraphDepthLocater = function SubgraphDepthLocater() {\n    this._subgraphs = null;\n    this._seg = new LineSegment();\n    this._cga = new CGAlgorithms();\n    var subgraphs = arguments[0];\n    this._subgraphs = subgraphs;\n};\nvar staticAccessors$30 = {\n    DepthSegment: {\n        configurable: true\n    }\n};\nSubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments() {\n    var this$1 = this;\n    if (arguments.length === 1) {\n        var stabbingRayLeftPt = arguments[0];\n        var stabbedSegments = new ArrayList();\n        for(var i = this._subgraphs.iterator(); i.hasNext();){\n            var bsg = i.next();\n            var env = bsg.getEnvelope();\n            if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) {\n                continue;\n            }\n            this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n        }\n        return stabbedSegments;\n    } else if (arguments.length === 3) {\n        if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n            var stabbingRayLeftPt$1 = arguments[0];\n            var dirEdge = arguments[1];\n            var stabbedSegments$1 = arguments[2];\n            var pts = dirEdge.getEdge().getCoordinates();\n            for(var i$1 = 0; i$1 < pts.length - 1; i$1++){\n                this$1._seg.p0 = pts[i$1];\n                this$1._seg.p1 = pts[i$1 + 1];\n                if (this$1._seg.p0.y > this$1._seg.p1.y) {\n                    this$1._seg.reverse();\n                }\n                var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);\n                if (maxx < stabbingRayLeftPt$1.x) {\n                    continue;\n                }\n                if (this$1._seg.isHorizontal()) {\n                    continue;\n                }\n                if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) {\n                    continue;\n                }\n                if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) {\n                    continue;\n                }\n                var depth = dirEdge.getDepth(Position.LEFT);\n                if (!this$1._seg.p0.equals(pts[i$1])) {\n                    depth = dirEdge.getDepth(Position.RIGHT);\n                }\n                var ds = new DepthSegment(this$1._seg, depth);\n                stabbedSegments$1.add(ds);\n            }\n        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n            var stabbingRayLeftPt$2 = arguments[0];\n            var dirEdges = arguments[1];\n            var stabbedSegments$2 = arguments[2];\n            for(var i$2 = dirEdges.iterator(); i$2.hasNext();){\n                var de = i$2.next();\n                if (!de.isForward()) {\n                    continue;\n                }\n                this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);\n            }\n        }\n    }\n};\nSubgraphDepthLocater.prototype.getDepth = function getDepth(p) {\n    var stabbedSegments = this.findStabbedSegments(p);\n    if (stabbedSegments.size() === 0) {\n        return 0;\n    }\n    var ds = Collections.min(stabbedSegments);\n    return ds._leftDepth;\n};\nSubgraphDepthLocater.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSubgraphDepthLocater.prototype.getClass = function getClass() {\n    return SubgraphDepthLocater;\n};\nstaticAccessors$30.DepthSegment.get = function() {\n    return DepthSegment;\n};\nObject.defineProperties(SubgraphDepthLocater, staticAccessors$30);\nvar DepthSegment = function DepthSegment() {\n    this._upwardSeg = null;\n    this._leftDepth = null;\n    var seg = arguments[0];\n    var depth = arguments[1];\n    this._upwardSeg = new LineSegment(seg);\n    this._leftDepth = depth;\n};\nDepthSegment.prototype.compareTo = function compareTo(obj) {\n    var other = obj;\n    if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) {\n        return 1;\n    }\n    if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) {\n        return -1;\n    }\n    var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n    if (orientIndex !== 0) {\n        return orientIndex;\n    }\n    orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n    if (orientIndex !== 0) {\n        return orientIndex;\n    }\n    return this._upwardSeg.compareTo(other._upwardSeg);\n};\nDepthSegment.prototype.compareX = function compareX(seg0, seg1) {\n    var compare0 = seg0.p0.compareTo(seg1.p0);\n    if (compare0 !== 0) {\n        return compare0;\n    }\n    return seg0.p1.compareTo(seg1.p1);\n};\nDepthSegment.prototype.toString = function toString() {\n    return this._upwardSeg.toString();\n};\nDepthSegment.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nDepthSegment.prototype.getClass = function getClass() {\n    return DepthSegment;\n};\nvar Triangle = function Triangle(p0, p1, p2) {\n    this.p0 = p0 || null;\n    this.p1 = p1 || null;\n    this.p2 = p2 || null;\n};\nTriangle.prototype.area = function area() {\n    return Triangle.area(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.signedArea = function signedArea() {\n    return Triangle.signedArea(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.interpolateZ = function interpolateZ(p) {\n    if (p === null) {\n        throw new IllegalArgumentException(\"Supplied point is null.\");\n    }\n    return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);\n};\nTriangle.prototype.longestSideLength = function longestSideLength() {\n    return Triangle.longestSideLength(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.isAcute = function isAcute() {\n    return Triangle.isAcute(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.circumcentre = function circumcentre() {\n    return Triangle.circumcentre(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.area3D = function area3D() {\n    return Triangle.area3D(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.centroid = function centroid() {\n    return Triangle.centroid(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.inCentre = function inCentre() {\n    return Triangle.inCentre(this.p0, this.p1, this.p2);\n};\nTriangle.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nTriangle.prototype.getClass = function getClass() {\n    return Triangle;\n};\nTriangle.area = function area(a, b, c) {\n    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n};\nTriangle.signedArea = function signedArea(a, b, c) {\n    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n};\nTriangle.det = function det(m00, m01, m10, m11) {\n    return m00 * m11 - m01 * m10;\n};\nTriangle.interpolateZ = function interpolateZ(p, v0, v1, v2) {\n    var x0 = v0.x;\n    var y0 = v0.y;\n    var a = v1.x - x0;\n    var b = v2.x - x0;\n    var c = v1.y - y0;\n    var d = v2.y - y0;\n    var det = a * d - b * c;\n    var dx = p.x - x0;\n    var dy = p.y - y0;\n    var t = (d * dx - b * dy) / det;\n    var u = (-c * dx + a * dy) / det;\n    var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n    return z;\n};\nTriangle.longestSideLength = function longestSideLength(a, b, c) {\n    var lenAB = a.distance(b);\n    var lenBC = b.distance(c);\n    var lenCA = c.distance(a);\n    var maxLen = lenAB;\n    if (lenBC > maxLen) {\n        maxLen = lenBC;\n    }\n    if (lenCA > maxLen) {\n        maxLen = lenCA;\n    }\n    return maxLen;\n};\nTriangle.isAcute = function isAcute(a, b, c) {\n    if (!Angle.isAcute(a, b, c)) {\n        return false;\n    }\n    if (!Angle.isAcute(b, c, a)) {\n        return false;\n    }\n    if (!Angle.isAcute(c, a, b)) {\n        return false;\n    }\n    return true;\n};\nTriangle.circumcentre = function circumcentre(a, b, c) {\n    var cx = c.x;\n    var cy = c.y;\n    var ax = a.x - cx;\n    var ay = a.y - cy;\n    var bx = b.x - cx;\n    var by = b.y - cy;\n    var denom = 2 * Triangle.det(ax, ay, bx, by);\n    var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n    var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n    var ccx = cx - numx / denom;\n    var ccy = cy + numy / denom;\n    return new Coordinate(ccx, ccy);\n};\nTriangle.perpendicularBisector = function perpendicularBisector(a, b) {\n    var dx = b.x - a.x;\n    var dy = b.y - a.y;\n    var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n    var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n    return new HCoordinate(l1, l2);\n};\nTriangle.angleBisector = function angleBisector(a, b, c) {\n    var len0 = b.distance(a);\n    var len2 = b.distance(c);\n    var frac = len0 / (len0 + len2);\n    var dx = c.x - a.x;\n    var dy = c.y - a.y;\n    var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n    return splitPt;\n};\nTriangle.area3D = function area3D(a, b, c) {\n    var ux = b.x - a.x;\n    var uy = b.y - a.y;\n    var uz = b.z - a.z;\n    var vx = c.x - a.x;\n    var vy = c.y - a.y;\n    var vz = c.z - a.z;\n    var crossx = uy * vz - uz * vy;\n    var crossy = uz * vx - ux * vz;\n    var crossz = ux * vy - uy * vx;\n    var absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n    var area3D = Math.sqrt(absSq) / 2;\n    return area3D;\n};\nTriangle.centroid = function centroid(a, b, c) {\n    var x = (a.x + b.x + c.x) / 3;\n    var y = (a.y + b.y + c.y) / 3;\n    return new Coordinate(x, y);\n};\nTriangle.inCentre = function inCentre(a, b, c) {\n    var len0 = b.distance(c);\n    var len1 = a.distance(c);\n    var len2 = a.distance(b);\n    var circum = len0 + len1 + len2;\n    var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n    var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n    return new Coordinate(inCentreX, inCentreY);\n};\nvar OffsetCurveSetBuilder = function OffsetCurveSetBuilder() {\n    this._inputGeom = null;\n    this._distance = null;\n    this._curveBuilder = null;\n    this._curveList = new ArrayList();\n    var inputGeom = arguments[0];\n    var distance = arguments[1];\n    var curveBuilder = arguments[2];\n    this._inputGeom = inputGeom;\n    this._distance = distance;\n    this._curveBuilder = curveBuilder;\n};\nOffsetCurveSetBuilder.prototype.addPoint = function addPoint(p) {\n    if (this._distance <= 0.0) {\n        return null;\n    }\n    var coord = p.getCoordinates();\n    var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addPolygon = function addPolygon(p) {\n    var this$1 = this;\n    var offsetDistance = this._distance;\n    var offsetSide = Position.LEFT;\n    if (this._distance < 0.0) {\n        offsetDistance = -this._distance;\n        offsetSide = Position.RIGHT;\n    }\n    var shell = p.getExteriorRing();\n    var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n    if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) {\n        return null;\n    }\n    if (this._distance <= 0.0 && shellCoord.length < 3) {\n        return null;\n    }\n    this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n    for(var i = 0; i < p.getNumInteriorRing(); i++){\n        var hole = p.getInteriorRingN(i);\n        var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n        if (this$1._distance > 0.0 && this$1.isErodedCompletely(hole, -this$1._distance)) {\n            continue;\n        }\n        this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n    }\n};\nOffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n    var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n    var inCentre = tri.inCentre();\n    var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n    return distToCentre < Math.abs(bufferDistance);\n};\nOffsetCurveSetBuilder.prototype.addLineString = function addLineString(line) {\n    if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) {\n        return null;\n    }\n    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n    var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addCurve = function addCurve(coord, leftLoc, rightLoc) {\n    if (coord === null || coord.length < 2) {\n        return null;\n    }\n    var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n    this._curveList.add(e);\n};\nOffsetCurveSetBuilder.prototype.getCurves = function getCurves() {\n    this.add(this._inputGeom);\n    return this._curveList;\n};\nOffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n    if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) {\n        return null;\n    }\n    var leftLoc = cwLeftLoc;\n    var rightLoc = cwRightLoc;\n    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n        leftLoc = cwRightLoc;\n        rightLoc = cwLeftLoc;\n        side = Position.opposite(side);\n    }\n    var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n    this.addCurve(curve, leftLoc, rightLoc);\n};\nOffsetCurveSetBuilder.prototype.add = function add(g) {\n    if (g.isEmpty()) {\n        return null;\n    }\n    if (g instanceof Polygon) {\n        this.addPolygon(g);\n    } else if (g instanceof LineString) {\n        this.addLineString(g);\n    } else if (g instanceof Point) {\n        this.addPoint(g);\n    } else if (g instanceof MultiPoint) {\n        this.addCollection(g);\n    } else if (g instanceof MultiLineString) {\n        this.addCollection(g);\n    } else if (g instanceof MultiPolygon) {\n        this.addCollection(g);\n    } else if (g instanceof GeometryCollection) {\n        this.addCollection(g);\n    }\n// else throw new UnsupportedOperationException(g.getClass().getName())\n};\nOffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely(ring, bufferDistance) {\n    var ringCoord = ring.getCoordinates();\n    // const minDiam = 0.0\n    if (ringCoord.length < 4) {\n        return bufferDistance < 0;\n    }\n    if (ringCoord.length === 4) {\n        return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n    }\n    var env = ring.getEnvelopeInternal();\n    var envMinDimension = Math.min(env.getHeight(), env.getWidth());\n    if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) {\n        return true;\n    }\n    return false;\n};\nOffsetCurveSetBuilder.prototype.addCollection = function addCollection(gc) {\n    var this$1 = this;\n    for(var i = 0; i < gc.getNumGeometries(); i++){\n        var g = gc.getGeometryN(i);\n        this$1.add(g);\n    }\n};\nOffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOffsetCurveSetBuilder.prototype.getClass = function getClass() {\n    return OffsetCurveSetBuilder;\n};\nvar PointOnGeometryLocator = function PointOnGeometryLocator() {};\nPointOnGeometryLocator.prototype.locate = function locate(p) {};\nPointOnGeometryLocator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPointOnGeometryLocator.prototype.getClass = function getClass() {\n    return PointOnGeometryLocator;\n};\nvar GeometryCollectionIterator = function GeometryCollectionIterator() {\n    this._parent = null;\n    this._atStart = null;\n    this._max = null;\n    this._index = null;\n    this._subcollectionIterator = null;\n    var parent = arguments[0];\n    this._parent = parent;\n    this._atStart = true;\n    this._index = 0;\n    this._max = parent.getNumGeometries();\n};\nGeometryCollectionIterator.prototype.next = function next() {\n    if (this._atStart) {\n        this._atStart = false;\n        if (GeometryCollectionIterator.isAtomic(this._parent)) {\n            this._index++;\n        }\n        return this._parent;\n    }\n    if (this._subcollectionIterator !== null) {\n        if (this._subcollectionIterator.hasNext()) {\n            return this._subcollectionIterator.next();\n        } else {\n            this._subcollectionIterator = null;\n        }\n    }\n    if (this._index >= this._max) {\n        throw new NoSuchElementException();\n    }\n    var obj = this._parent.getGeometryN(this._index++);\n    if (obj instanceof GeometryCollection) {\n        this._subcollectionIterator = new GeometryCollectionIterator(obj);\n        return this._subcollectionIterator.next();\n    }\n    return obj;\n};\nGeometryCollectionIterator.prototype.remove = function remove() {\n    throw new Error(this.getClass().getName());\n};\nGeometryCollectionIterator.prototype.hasNext = function hasNext() {\n    if (this._atStart) {\n        return true;\n    }\n    if (this._subcollectionIterator !== null) {\n        if (this._subcollectionIterator.hasNext()) {\n            return true;\n        }\n        this._subcollectionIterator = null;\n    }\n    if (this._index >= this._max) {\n        return false;\n    }\n    return true;\n};\nGeometryCollectionIterator.prototype.interfaces_ = function interfaces_() {\n    return [\n        Iterator\n    ];\n};\nGeometryCollectionIterator.prototype.getClass = function getClass() {\n    return GeometryCollectionIterator;\n};\nGeometryCollectionIterator.isAtomic = function isAtomic(geom) {\n    return !(geom instanceof GeometryCollection);\n};\nvar SimplePointInAreaLocator = function SimplePointInAreaLocator() {\n    this._geom = null;\n    var geom = arguments[0];\n    this._geom = geom;\n};\nSimplePointInAreaLocator.prototype.locate = function locate(p) {\n    return SimplePointInAreaLocator.locate(p, this._geom);\n};\nSimplePointInAreaLocator.prototype.interfaces_ = function interfaces_() {\n    return [\n        PointOnGeometryLocator\n    ];\n};\nSimplePointInAreaLocator.prototype.getClass = function getClass() {\n    return SimplePointInAreaLocator;\n};\nSimplePointInAreaLocator.isPointInRing = function isPointInRing(p, ring) {\n    if (!ring.getEnvelopeInternal().intersects(p)) {\n        return false;\n    }\n    return CGAlgorithms.isPointInRing(p, ring.getCoordinates());\n};\nSimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon(p, poly) {\n    if (poly.isEmpty()) {\n        return false;\n    }\n    var shell = poly.getExteriorRing();\n    if (!SimplePointInAreaLocator.isPointInRing(p, shell)) {\n        return false;\n    }\n    for(var i = 0; i < poly.getNumInteriorRing(); i++){\n        var hole = poly.getInteriorRingN(i);\n        if (SimplePointInAreaLocator.isPointInRing(p, hole)) {\n            return false;\n        }\n    }\n    return true;\n};\nSimplePointInAreaLocator.containsPoint = function containsPoint(p, geom) {\n    if (geom instanceof Polygon) {\n        return SimplePointInAreaLocator.containsPointInPolygon(p, geom);\n    } else if (geom instanceof GeometryCollection) {\n        var geomi = new GeometryCollectionIterator(geom);\n        while(geomi.hasNext()){\n            var g2 = geomi.next();\n            if (g2 !== geom) {\n                if (SimplePointInAreaLocator.containsPoint(p, g2)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\nSimplePointInAreaLocator.locate = function locate(p, geom) {\n    if (geom.isEmpty()) {\n        return Location.EXTERIOR;\n    }\n    if (SimplePointInAreaLocator.containsPoint(p, geom)) {\n        return Location.INTERIOR;\n    }\n    return Location.EXTERIOR;\n};\nvar EdgeEndStar = function EdgeEndStar() {\n    this._edgeMap = new TreeMap();\n    this._edgeList = null;\n    this._ptInAreaLocation = [\n        Location.NONE,\n        Location.NONE\n    ];\n};\nEdgeEndStar.prototype.getNextCW = function getNextCW(ee) {\n    this.getEdges();\n    var i = this._edgeList.indexOf(ee);\n    var iNextCW = i - 1;\n    if (i === 0) {\n        iNextCW = this._edgeList.size() - 1;\n    }\n    return this._edgeList.get(iNextCW);\n};\nEdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels(geomIndex) {\n    var startLoc = Location.NONE;\n    for(var it = this.iterator(); it.hasNext();){\n        var e = it.next();\n        var label = e.getLabel();\n        if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) {\n            startLoc = label.getLocation(geomIndex, Position.LEFT);\n        }\n    }\n    if (startLoc === Location.NONE) {\n        return null;\n    }\n    var currLoc = startLoc;\n    for(var it$1 = this.iterator(); it$1.hasNext();){\n        var e$1 = it$1.next();\n        var label$1 = e$1.getLabel();\n        if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) {\n            label$1.setLocation(geomIndex, Position.ON, currLoc);\n        }\n        if (label$1.isArea(geomIndex)) {\n            var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);\n            var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);\n            if (rightLoc !== Location.NONE) {\n                if (rightLoc !== currLoc) {\n                    throw new TopologyException(\"side location conflict\", e$1.getCoordinate());\n                }\n                if (leftLoc === Location.NONE) {\n                    Assert.shouldNeverReachHere(\"found single null side (at \" + e$1.getCoordinate() + \")\");\n                }\n                currLoc = leftLoc;\n            } else {\n                Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n                label$1.setLocation(geomIndex, Position.RIGHT, currLoc);\n                label$1.setLocation(geomIndex, Position.LEFT, currLoc);\n            }\n        }\n    }\n};\nEdgeEndStar.prototype.getCoordinate = function getCoordinate() {\n    var it = this.iterator();\n    if (!it.hasNext()) {\n        return null;\n    }\n    var e = it.next();\n    return e.getCoordinate();\n};\nEdgeEndStar.prototype.print = function print(out) {\n    System.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n    for(var it = this.iterator(); it.hasNext();){\n        var e = it.next();\n        e.print(out);\n    }\n};\nEdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent(geomGraph) {\n    this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n    return this.checkAreaLabelsConsistent(0);\n};\nEdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent(geomIndex) {\n    var edges = this.getEdges();\n    if (edges.size() <= 0) {\n        return true;\n    }\n    var lastEdgeIndex = edges.size() - 1;\n    var startLabel = edges.get(lastEdgeIndex).getLabel();\n    var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n    Assert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n    var currLoc = startLoc;\n    for(var it = this.iterator(); it.hasNext();){\n        var e = it.next();\n        var label = e.getLabel();\n        Assert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n        var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n        var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n        if (leftLoc === rightLoc) {\n            return false;\n        }\n        if (rightLoc !== currLoc) {\n            return false;\n        }\n        currLoc = leftLoc;\n    }\n    return true;\n};\nEdgeEndStar.prototype.findIndex = function findIndex(eSearch) {\n    var this$1 = this;\n    this.iterator();\n    for(var i = 0; i < this._edgeList.size(); i++){\n        var e = this$1._edgeList.get(i);\n        if (e === eSearch) {\n            return i;\n        }\n    }\n    return -1;\n};\nEdgeEndStar.prototype.iterator = function iterator() {\n    return this.getEdges().iterator();\n};\nEdgeEndStar.prototype.getEdges = function getEdges() {\n    if (this._edgeList === null) {\n        this._edgeList = new ArrayList(this._edgeMap.values());\n    }\n    return this._edgeList;\n};\nEdgeEndStar.prototype.getLocation = function getLocation(geomIndex, p, geom) {\n    if (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n        this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n    }\n    return this._ptInAreaLocation[geomIndex];\n};\nEdgeEndStar.prototype.toString = function toString() {\n    var buf = new StringBuffer();\n    buf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n    buf.append(\"\\n\");\n    for(var it = this.iterator(); it.hasNext();){\n        var e = it.next();\n        buf.append(e);\n        buf.append(\"\\n\");\n    }\n    return buf.toString();\n};\nEdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels(boundaryNodeRule) {\n    for(var it = this.iterator(); it.hasNext();){\n        var ee = it.next();\n        ee.computeLabel(boundaryNodeRule);\n    }\n};\nEdgeEndStar.prototype.computeLabelling = function computeLabelling(geomGraph) {\n    var this$1 = this;\n    this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n    this.propagateSideLabels(0);\n    this.propagateSideLabels(1);\n    var hasDimensionalCollapseEdge = [\n        false,\n        false\n    ];\n    for(var it = this.iterator(); it.hasNext();){\n        var e = it.next();\n        var label = e.getLabel();\n        for(var geomi = 0; geomi < 2; geomi++){\n            if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) {\n                hasDimensionalCollapseEdge[geomi] = true;\n            }\n        }\n    }\n    for(var it$1 = this.iterator(); it$1.hasNext();){\n        var e$1 = it$1.next();\n        var label$1 = e$1.getLabel();\n        for(var geomi$1 = 0; geomi$1 < 2; geomi$1++){\n            if (label$1.isAnyNull(geomi$1)) {\n                var loc = Location.NONE;\n                if (hasDimensionalCollapseEdge[geomi$1]) {\n                    loc = Location.EXTERIOR;\n                } else {\n                    var p = e$1.getCoordinate();\n                    loc = this$1.getLocation(geomi$1, p, geomGraph);\n                }\n                label$1.setAllLocationsIfNull(geomi$1, loc);\n            }\n        }\n    }\n};\nEdgeEndStar.prototype.getDegree = function getDegree() {\n    return this._edgeMap.size();\n};\nEdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd(e, obj) {\n    this._edgeMap.put(e, obj);\n    this._edgeList = null;\n};\nEdgeEndStar.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeEndStar.prototype.getClass = function getClass() {\n    return EdgeEndStar;\n};\nvar DirectedEdgeStar = function(EdgeEndStar$$1) {\n    function DirectedEdgeStar() {\n        EdgeEndStar$$1.call(this);\n        this._resultAreaEdgeList = null;\n        this._label = null;\n        this._SCANNING_FOR_INCOMING = 1;\n        this._LINKING_TO_OUTGOING = 2;\n    }\n    if (EdgeEndStar$$1) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;\n    DirectedEdgeStar.prototype = Object.create(EdgeEndStar$$1 && EdgeEndStar$$1.prototype);\n    DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;\n    DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges() {\n        var this$1 = this;\n        this.getResultAreaEdges();\n        var firstOut = null;\n        var incoming = null;\n        var state = this._SCANNING_FOR_INCOMING;\n        for(var i = 0; i < this._resultAreaEdgeList.size(); i++){\n            var nextOut = this$1._resultAreaEdgeList.get(i);\n            var nextIn = nextOut.getSym();\n            if (!nextOut.getLabel().isArea()) {\n                continue;\n            }\n            if (firstOut === null && nextOut.isInResult()) {\n                firstOut = nextOut;\n            }\n            switch(state){\n                case this$1._SCANNING_FOR_INCOMING:\n                    if (!nextIn.isInResult()) {\n                        continue;\n                    }\n                    incoming = nextIn;\n                    state = this$1._LINKING_TO_OUTGOING;\n                    break;\n                case this$1._LINKING_TO_OUTGOING:\n                    if (!nextOut.isInResult()) {\n                        continue;\n                    }\n                    incoming.setNext(nextOut);\n                    state = this$1._SCANNING_FOR_INCOMING;\n                    break;\n                default:\n            }\n        }\n        if (state === this._LINKING_TO_OUTGOING) {\n            if (firstOut === null) {\n                throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n            }\n            Assert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n            incoming.setNext(firstOut);\n        }\n    };\n    DirectedEdgeStar.prototype.insert = function insert(ee) {\n        var de = ee;\n        this.insertEdgeEnd(de, de);\n    };\n    DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge() {\n        var edges = this.getEdges();\n        var size = edges.size();\n        if (size < 1) {\n            return null;\n        }\n        var de0 = edges.get(0);\n        if (size === 1) {\n            return de0;\n        }\n        var deLast = edges.get(size - 1);\n        var quad0 = de0.getQuadrant();\n        var quad1 = deLast.getQuadrant();\n        if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {\n            return de0;\n        } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {\n            return deLast;\n        } else {\n            // const nonHorizontalEdge = null\n            if (de0.getDy() !== 0) {\n                return de0;\n            } else if (deLast.getDy() !== 0) {\n                return deLast;\n            }\n        }\n        Assert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n        return null;\n    };\n    DirectedEdgeStar.prototype.print = function print(out) {\n        System.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n        for(var it = this.iterator(); it.hasNext();){\n            var de = it.next();\n            out.print(\"out \");\n            de.print(out);\n            out.println();\n            out.print(\"in \");\n            de.getSym().print(out);\n            out.println();\n        }\n    };\n    DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges() {\n        var this$1 = this;\n        if (this._resultAreaEdgeList !== null) {\n            return this._resultAreaEdgeList;\n        }\n        this._resultAreaEdgeList = new ArrayList();\n        for(var it = this.iterator(); it.hasNext();){\n            var de = it.next();\n            if (de.isInResult() || de.getSym().isInResult()) {\n                this$1._resultAreaEdgeList.add(de);\n            }\n        }\n        return this._resultAreaEdgeList;\n    };\n    DirectedEdgeStar.prototype.updateLabelling = function updateLabelling(nodeLabel) {\n        for(var it = this.iterator(); it.hasNext();){\n            var de = it.next();\n            var label = de.getLabel();\n            label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n            label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n        }\n    };\n    DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges() {\n        var this$1 = this;\n        this.getEdges();\n        var prevOut = null;\n        var firstIn = null;\n        for(var i = this._edgeList.size() - 1; i >= 0; i--){\n            var nextOut = this$1._edgeList.get(i);\n            var nextIn = nextOut.getSym();\n            if (firstIn === null) {\n                firstIn = nextIn;\n            }\n            if (prevOut !== null) {\n                nextIn.setNext(prevOut);\n            }\n            prevOut = nextOut;\n        }\n        firstIn.setNext(prevOut);\n    };\n    DirectedEdgeStar.prototype.computeDepths = function computeDepths() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var de = arguments[0];\n            var edgeIndex = this.findIndex(de);\n            // const label = de.getLabel()\n            var startDepth = de.getDepth(Position.LEFT);\n            var targetLastDepth = de.getDepth(Position.RIGHT);\n            var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n            var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n            if (lastDepth !== targetLastDepth) {\n                throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n            }\n        } else if (arguments.length === 3) {\n            var startIndex = arguments[0];\n            var endIndex = arguments[1];\n            var startDepth$1 = arguments[2];\n            var currDepth = startDepth$1;\n            for(var i = startIndex; i < endIndex; i++){\n                var nextDe = this$1._edgeList.get(i);\n                // const label = nextDe.getLabel()\n                nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n                currDepth = nextDe.getDepth(Position.LEFT);\n            }\n            return currDepth;\n        }\n    };\n    DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels() {\n        for(var it = this.iterator(); it.hasNext();){\n            var de = it.next();\n            var label = de.getLabel();\n            label.merge(de.getSym().getLabel());\n        }\n    };\n    DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges(er) {\n        var this$1 = this;\n        var firstOut = null;\n        var incoming = null;\n        var state = this._SCANNING_FOR_INCOMING;\n        for(var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--){\n            var nextOut = this$1._resultAreaEdgeList.get(i);\n            var nextIn = nextOut.getSym();\n            if (firstOut === null && nextOut.getEdgeRing() === er) {\n                firstOut = nextOut;\n            }\n            switch(state){\n                case this$1._SCANNING_FOR_INCOMING:\n                    if (nextIn.getEdgeRing() !== er) {\n                        continue;\n                    }\n                    incoming = nextIn;\n                    state = this$1._LINKING_TO_OUTGOING;\n                    break;\n                case this$1._LINKING_TO_OUTGOING:\n                    if (nextOut.getEdgeRing() !== er) {\n                        continue;\n                    }\n                    incoming.setNextMin(nextOut);\n                    state = this$1._SCANNING_FOR_INCOMING;\n                    break;\n                default:\n            }\n        }\n        if (state === this._LINKING_TO_OUTGOING) {\n            Assert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n            Assert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n            incoming.setNextMin(firstOut);\n        }\n    };\n    DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree() {\n        if (arguments.length === 0) {\n            var degree = 0;\n            for(var it = this.iterator(); it.hasNext();){\n                var de = it.next();\n                if (de.isInResult()) {\n                    degree++;\n                }\n            }\n            return degree;\n        } else if (arguments.length === 1) {\n            var er = arguments[0];\n            var degree$1 = 0;\n            for(var it$1 = this.iterator(); it$1.hasNext();){\n                var de$1 = it$1.next();\n                if (de$1.getEdgeRing() === er) {\n                    degree$1++;\n                }\n            }\n            return degree$1;\n        }\n    };\n    DirectedEdgeStar.prototype.getLabel = function getLabel() {\n        return this._label;\n    };\n    DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges() {\n        var startLoc = Location.NONE;\n        for(var it = this.iterator(); it.hasNext();){\n            var nextOut = it.next();\n            var nextIn = nextOut.getSym();\n            if (!nextOut.isLineEdge()) {\n                if (nextOut.isInResult()) {\n                    startLoc = Location.INTERIOR;\n                    break;\n                }\n                if (nextIn.isInResult()) {\n                    startLoc = Location.EXTERIOR;\n                    break;\n                }\n            }\n        }\n        if (startLoc === Location.NONE) {\n            return null;\n        }\n        var currLoc = startLoc;\n        for(var it$1 = this.iterator(); it$1.hasNext();){\n            var nextOut$1 = it$1.next();\n            var nextIn$1 = nextOut$1.getSym();\n            if (nextOut$1.isLineEdge()) {\n                nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);\n            } else {\n                if (nextOut$1.isInResult()) {\n                    currLoc = Location.EXTERIOR;\n                }\n                if (nextIn$1.isInResult()) {\n                    currLoc = Location.INTERIOR;\n                }\n            }\n        }\n    };\n    DirectedEdgeStar.prototype.computeLabelling = function computeLabelling(geom) {\n        var this$1 = this;\n        EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);\n        this._label = new Label(Location.NONE);\n        for(var it = this.iterator(); it.hasNext();){\n            var ee = it.next();\n            var e = ee.getEdge();\n            var eLabel = e.getLabel();\n            for(var i = 0; i < 2; i++){\n                var eLoc = eLabel.getLocation(i);\n                if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) {\n                    this$1._label.setLocation(i, Location.INTERIOR);\n                }\n            }\n        }\n    };\n    DirectedEdgeStar.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    DirectedEdgeStar.prototype.getClass = function getClass() {\n        return DirectedEdgeStar;\n    };\n    return DirectedEdgeStar;\n}(EdgeEndStar);\nvar OverlayNodeFactory = function(NodeFactory$$1) {\n    function OverlayNodeFactory() {\n        NodeFactory$$1.apply(this, arguments);\n    }\n    if (NodeFactory$$1) OverlayNodeFactory.__proto__ = NodeFactory$$1;\n    OverlayNodeFactory.prototype = Object.create(NodeFactory$$1 && NodeFactory$$1.prototype);\n    OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;\n    OverlayNodeFactory.prototype.createNode = function createNode(coord) {\n        return new Node(coord, new DirectedEdgeStar());\n    };\n    OverlayNodeFactory.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    OverlayNodeFactory.prototype.getClass = function getClass() {\n        return OverlayNodeFactory;\n    };\n    return OverlayNodeFactory;\n}(NodeFactory);\nvar OrientedCoordinateArray = function OrientedCoordinateArray() {\n    this._pts = null;\n    this._orientation = null;\n    var pts = arguments[0];\n    this._pts = pts;\n    this._orientation = OrientedCoordinateArray.orientation(pts);\n};\nOrientedCoordinateArray.prototype.compareTo = function compareTo(o1) {\n    var oca = o1;\n    var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n    return comp;\n};\nOrientedCoordinateArray.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nOrientedCoordinateArray.prototype.getClass = function getClass() {\n    return OrientedCoordinateArray;\n};\nOrientedCoordinateArray.orientation = function orientation(pts) {\n    return CoordinateArrays.increasingDirection(pts) === 1;\n};\nOrientedCoordinateArray.compareOriented = function compareOriented(pts1, orientation1, pts2, orientation2) {\n    var dir1 = orientation1 ? 1 : -1;\n    var dir2 = orientation2 ? 1 : -1;\n    var limit1 = orientation1 ? pts1.length : -1;\n    var limit2 = orientation2 ? pts2.length : -1;\n    var i1 = orientation1 ? 0 : pts1.length - 1;\n    var i2 = orientation2 ? 0 : pts2.length - 1;\n    // const comp = 0\n    while(true){\n        var compPt = pts1[i1].compareTo(pts2[i2]);\n        if (compPt !== 0) {\n            return compPt;\n        }\n        i1 += dir1;\n        i2 += dir2;\n        var done1 = i1 === limit1;\n        var done2 = i2 === limit2;\n        if (done1 && !done2) {\n            return -1;\n        }\n        if (!done1 && done2) {\n            return 1;\n        }\n        if (done1 && done2) {\n            return 0;\n        }\n    }\n};\nvar EdgeList = function EdgeList() {\n    this._edges = new ArrayList();\n    this._ocaMap = new TreeMap();\n};\nEdgeList.prototype.print = function print(out) {\n    var this$1 = this;\n    out.print(\"MULTILINESTRING ( \");\n    for(var j = 0; j < this._edges.size(); j++){\n        var e = this$1._edges.get(j);\n        if (j > 0) {\n            out.print(\",\");\n        }\n        out.print(\"(\");\n        var pts = e.getCoordinates();\n        for(var i = 0; i < pts.length; i++){\n            if (i > 0) {\n                out.print(\",\");\n            }\n            out.print(pts[i].x + \" \" + pts[i].y);\n        }\n        out.println(\")\");\n    }\n    out.print(\")  \");\n};\nEdgeList.prototype.addAll = function addAll(edgeColl) {\n    var this$1 = this;\n    for(var i = edgeColl.iterator(); i.hasNext();){\n        this$1.add(i.next());\n    }\n};\nEdgeList.prototype.findEdgeIndex = function findEdgeIndex(e) {\n    var this$1 = this;\n    for(var i = 0; i < this._edges.size(); i++){\n        if (this$1._edges.get(i).equals(e)) {\n            return i;\n        }\n    }\n    return -1;\n};\nEdgeList.prototype.iterator = function iterator() {\n    return this._edges.iterator();\n};\nEdgeList.prototype.getEdges = function getEdges() {\n    return this._edges;\n};\nEdgeList.prototype.get = function get(i) {\n    return this._edges.get(i);\n};\nEdgeList.prototype.findEqualEdge = function findEqualEdge(e) {\n    var oca = new OrientedCoordinateArray(e.getCoordinates());\n    var matchEdge = this._ocaMap.get(oca);\n    return matchEdge;\n};\nEdgeList.prototype.add = function add(e) {\n    this._edges.add(e);\n    var oca = new OrientedCoordinateArray(e.getCoordinates());\n    this._ocaMap.put(oca, e);\n};\nEdgeList.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeList.prototype.getClass = function getClass() {\n    return EdgeList;\n};\nvar SegmentIntersector = function SegmentIntersector() {};\nSegmentIntersector.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {};\nSegmentIntersector.prototype.isDone = function isDone() {};\nSegmentIntersector.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSegmentIntersector.prototype.getClass = function getClass() {\n    return SegmentIntersector;\n};\nvar IntersectionAdder = function IntersectionAdder() {\n    this._hasIntersection = false;\n    this._hasProper = false;\n    this._hasProperInterior = false;\n    this._hasInterior = false;\n    this._properIntersectionPoint = null;\n    this._li = null;\n    this._isSelfIntersection = null;\n    this.numIntersections = 0;\n    this.numInteriorIntersections = 0;\n    this.numProperIntersections = 0;\n    this.numTests = 0;\n    var li = arguments[0];\n    this._li = li;\n};\nIntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1) {\n        if (this._li.getIntersectionNum() === 1) {\n            if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) {\n                return true;\n            }\n            if (e0.isClosed()) {\n                var maxSegIndex = e0.size() - 1;\n                if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\nIntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {\n    return this._properIntersectionPoint;\n};\nIntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {\n    return this._hasProperInterior;\n};\nIntersectionAdder.prototype.getLineIntersector = function getLineIntersector() {\n    return this._li;\n};\nIntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection() {\n    return this._hasProper;\n};\nIntersectionAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) {\n        return null;\n    }\n    this.numTests++;\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n        this.numIntersections++;\n        if (this._li.isInteriorIntersection()) {\n            this.numInteriorIntersections++;\n            this._hasInterior = true;\n        }\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n            this._hasIntersection = true;\n            e0.addIntersections(this._li, segIndex0, 0);\n            e1.addIntersections(this._li, segIndex1, 1);\n            if (this._li.isProper()) {\n                this.numProperIntersections++;\n                this._hasProper = true;\n                this._hasProperInterior = true;\n            }\n        }\n    }\n};\nIntersectionAdder.prototype.hasIntersection = function hasIntersection() {\n    return this._hasIntersection;\n};\nIntersectionAdder.prototype.isDone = function isDone() {\n    return false;\n};\nIntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection() {\n    return this._hasInterior;\n};\nIntersectionAdder.prototype.interfaces_ = function interfaces_() {\n    return [\n        SegmentIntersector\n    ];\n};\nIntersectionAdder.prototype.getClass = function getClass() {\n    return IntersectionAdder;\n};\nIntersectionAdder.isAdjacentSegments = function isAdjacentSegments(i1, i2) {\n    return Math.abs(i1 - i2) === 1;\n};\nvar EdgeIntersection = function EdgeIntersection() {\n    this.coord = null;\n    this.segmentIndex = null;\n    this.dist = null;\n    var coord = arguments[0];\n    var segmentIndex = arguments[1];\n    var dist = arguments[2];\n    this.coord = new Coordinate(coord);\n    this.segmentIndex = segmentIndex;\n    this.dist = dist;\n};\nEdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex() {\n    return this.segmentIndex;\n};\nEdgeIntersection.prototype.getCoordinate = function getCoordinate() {\n    return this.coord;\n};\nEdgeIntersection.prototype.print = function print(out) {\n    out.print(this.coord);\n    out.print(\" seg # = \" + this.segmentIndex);\n    out.println(\" dist = \" + this.dist);\n};\nEdgeIntersection.prototype.compareTo = function compareTo(obj) {\n    var other = obj;\n    return this.compare(other.segmentIndex, other.dist);\n};\nEdgeIntersection.prototype.isEndPoint = function isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && this.dist === 0.0) {\n        return true;\n    }\n    if (this.segmentIndex === maxSegmentIndex) {\n        return true;\n    }\n    return false;\n};\nEdgeIntersection.prototype.toString = function toString() {\n    return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n};\nEdgeIntersection.prototype.getDistance = function getDistance() {\n    return this.dist;\n};\nEdgeIntersection.prototype.compare = function compare(segmentIndex, dist) {\n    if (this.segmentIndex < segmentIndex) {\n        return -1;\n    }\n    if (this.segmentIndex > segmentIndex) {\n        return 1;\n    }\n    if (this.dist < dist) {\n        return -1;\n    }\n    if (this.dist > dist) {\n        return 1;\n    }\n    return 0;\n};\nEdgeIntersection.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nEdgeIntersection.prototype.getClass = function getClass() {\n    return EdgeIntersection;\n};\nvar EdgeIntersectionList = function EdgeIntersectionList() {\n    this._nodeMap = new TreeMap();\n    this.edge = null;\n    var edge = arguments[0];\n    this.edge = edge;\n};\nEdgeIntersectionList.prototype.print = function print(out) {\n    out.println(\"Intersections:\");\n    for(var it = this.iterator(); it.hasNext();){\n        var ei = it.next();\n        ei.print(out);\n    }\n};\nEdgeIntersectionList.prototype.iterator = function iterator() {\n    return this._nodeMap.values().iterator();\n};\nEdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges(edgeList) {\n    var this$1 = this;\n    this.addEndpoints();\n    var it = this.iterator();\n    var eiPrev = it.next();\n    while(it.hasNext()){\n        var ei = it.next();\n        var newEdge = this$1.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n    }\n};\nEdgeIntersectionList.prototype.addEndpoints = function addEndpoints() {\n    var maxSegIndex = this.edge.pts.length - 1;\n    this.add(this.edge.pts[0], 0, 0.0);\n    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n};\nEdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge(ei0, ei1) {\n    var this$1 = this;\n    var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n    var lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n    var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n    if (!useIntPt1) {\n        npts--;\n    }\n    var pts = new Array(npts).fill(null);\n    var ipt = 0;\n    pts[ipt++] = new Coordinate(ei0.coord);\n    for(var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++){\n        pts[ipt++] = this$1.edge.pts[i];\n    }\n    if (useIntPt1) {\n        pts[ipt] = ei1.coord;\n    }\n    return new Edge(pts, new Label(this.edge._label));\n};\nEdgeIntersectionList.prototype.add = function add(intPt, segmentIndex, dist) {\n    var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n    var ei = this._nodeMap.get(eiNew);\n    if (ei !== null) {\n        return ei;\n    }\n    this._nodeMap.put(eiNew, eiNew);\n    return eiNew;\n};\nEdgeIntersectionList.prototype.isIntersection = function isIntersection(pt) {\n    for(var it = this.iterator(); it.hasNext();){\n        var ei = it.next();\n        if (ei.coord.equals(pt)) {\n            return true;\n        }\n    }\n    return false;\n};\nEdgeIntersectionList.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeIntersectionList.prototype.getClass = function getClass() {\n    return EdgeIntersectionList;\n};\nvar MonotoneChainIndexer = function MonotoneChainIndexer() {};\nMonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices(pts) {\n    var this$1 = this;\n    var start = 0;\n    var startIndexList = new ArrayList();\n    startIndexList.add(new Integer(start));\n    do {\n        var last = this$1.findChainEnd(pts, start);\n        startIndexList.add(new Integer(last));\n        start = last;\n    }while (start < pts.length - 1);\n    var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n    return startIndex;\n};\nMonotoneChainIndexer.prototype.findChainEnd = function findChainEnd(pts, start) {\n    var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n    var last = start + 1;\n    while(last < pts.length){\n        var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n        if (quad !== chainQuad) {\n            break;\n        }\n        last++;\n    }\n    return last - 1;\n};\nMonotoneChainIndexer.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChainIndexer.prototype.getClass = function getClass() {\n    return MonotoneChainIndexer;\n};\nMonotoneChainIndexer.toIntArray = function toIntArray(list) {\n    var array = new Array(list.size()).fill(null);\n    for(var i = 0; i < array.length; i++){\n        array[i] = list.get(i).intValue();\n    }\n    return array;\n};\nvar MonotoneChainEdge = function MonotoneChainEdge() {\n    this.e = null;\n    this.pts = null;\n    this.startIndex = null;\n    this.env1 = new Envelope();\n    this.env2 = new Envelope();\n    var e = arguments[0];\n    this.e = e;\n    this.pts = e.getCoordinates();\n    var mcb = new MonotoneChainIndexer();\n    this.startIndex = mcb.getChainStartIndices(this.pts);\n};\nMonotoneChainEdge.prototype.getCoordinates = function getCoordinates() {\n    return this.pts;\n};\nMonotoneChainEdge.prototype.getMaxX = function getMaxX(chainIndex) {\n    var x1 = this.pts[this.startIndex[chainIndex]].x;\n    var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n    return x1 > x2 ? x1 : x2;\n};\nMonotoneChainEdge.prototype.getMinX = function getMinX(chainIndex) {\n    var x1 = this.pts[this.startIndex[chainIndex]].x;\n    var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n    return x1 < x2 ? x1 : x2;\n};\nMonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain() {\n    if (arguments.length === 4) {\n        var chainIndex0 = arguments[0];\n        var mce = arguments[1];\n        var chainIndex1 = arguments[2];\n        var si = arguments[3];\n        this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n    } else if (arguments.length === 6) {\n        var start0 = arguments[0];\n        var end0 = arguments[1];\n        var mce$1 = arguments[2];\n        var start1 = arguments[3];\n        var end1 = arguments[4];\n        var ei = arguments[5];\n        var p00 = this.pts[start0];\n        var p01 = this.pts[end0];\n        var p10 = mce$1.pts[start1];\n        var p11 = mce$1.pts[end1];\n        if (end0 - start0 === 1 && end1 - start1 === 1) {\n            ei.addIntersections(this.e, start0, mce$1.e, start1);\n            return null;\n        }\n        this.env1.init(p00, p01);\n        this.env2.init(p10, p11);\n        if (!this.env1.intersects(this.env2)) {\n            return null;\n        }\n        var mid0 = Math.trunc((start0 + end0) / 2);\n        var mid1 = Math.trunc((start1 + end1) / 2);\n        if (start0 < mid0) {\n            if (start1 < mid1) {\n                this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei);\n            }\n            if (mid1 < end1) {\n                this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei);\n            }\n        }\n        if (mid0 < end0) {\n            if (start1 < mid1) {\n                this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei);\n            }\n            if (mid1 < end1) {\n                this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei);\n            }\n        }\n    }\n};\nMonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes() {\n    return this.startIndex;\n};\nMonotoneChainEdge.prototype.computeIntersects = function computeIntersects(mce, si) {\n    var this$1 = this;\n    for(var i = 0; i < this.startIndex.length - 1; i++){\n        for(var j = 0; j < mce.startIndex.length - 1; j++){\n            this$1.computeIntersectsForChain(i, mce, j, si);\n        }\n    }\n};\nMonotoneChainEdge.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChainEdge.prototype.getClass = function getClass() {\n    return MonotoneChainEdge;\n};\nvar Depth = function Depth() {\n    var this$1 = this;\n    this._depth = Array(2).fill().map(function() {\n        return Array(3);\n    });\n    for(var i = 0; i < 2; i++){\n        for(var j = 0; j < 3; j++){\n            this$1._depth[i][j] = Depth.NULL_VALUE;\n        }\n    }\n};\nvar staticAccessors$31 = {\n    NULL_VALUE: {\n        configurable: true\n    }\n};\nDepth.prototype.getDepth = function getDepth(geomIndex, posIndex) {\n    return this._depth[geomIndex][posIndex];\n};\nDepth.prototype.setDepth = function setDepth(geomIndex, posIndex, depthValue) {\n    this._depth[geomIndex][posIndex] = depthValue;\n};\nDepth.prototype.isNull = function isNull() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        for(var i = 0; i < 2; i++){\n            for(var j = 0; j < 3; j++){\n                if (this$1._depth[i][j] !== Depth.NULL_VALUE) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    } else if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this._depth[geomIndex][1] === Depth.NULL_VALUE;\n    } else if (arguments.length === 2) {\n        var geomIndex$1 = arguments[0];\n        var posIndex = arguments[1];\n        return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE;\n    }\n};\nDepth.prototype.normalize = function normalize() {\n    var this$1 = this;\n    for(var i = 0; i < 2; i++){\n        if (!this$1.isNull(i)) {\n            var minDepth = this$1._depth[i][1];\n            if (this$1._depth[i][2] < minDepth) {\n                minDepth = this$1._depth[i][2];\n            }\n            if (minDepth < 0) {\n                minDepth = 0;\n            }\n            for(var j = 1; j < 3; j++){\n                var newValue = 0;\n                if (this$1._depth[i][j] > minDepth) {\n                    newValue = 1;\n                }\n                this$1._depth[i][j] = newValue;\n            }\n        }\n    }\n};\nDepth.prototype.getDelta = function getDelta(geomIndex) {\n    return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n};\nDepth.prototype.getLocation = function getLocation(geomIndex, posIndex) {\n    if (this._depth[geomIndex][posIndex] <= 0) {\n        return Location.EXTERIOR;\n    }\n    return Location.INTERIOR;\n};\nDepth.prototype.toString = function toString() {\n    return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n};\nDepth.prototype.add = function add() {\n    var this$1 = this;\n    if (arguments.length === 1) {\n        var lbl = arguments[0];\n        for(var i = 0; i < 2; i++){\n            for(var j = 1; j < 3; j++){\n                var loc = lbl.getLocation(i, j);\n                if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n                    if (this$1.isNull(i, j)) {\n                        this$1._depth[i][j] = Depth.depthAtLocation(loc);\n                    } else {\n                        this$1._depth[i][j] += Depth.depthAtLocation(loc);\n                    }\n                }\n            }\n        }\n    } else if (arguments.length === 3) {\n        var geomIndex = arguments[0];\n        var posIndex = arguments[1];\n        var location = arguments[2];\n        if (location === Location.INTERIOR) {\n            this._depth[geomIndex][posIndex]++;\n        }\n    }\n};\nDepth.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDepth.prototype.getClass = function getClass() {\n    return Depth;\n};\nDepth.depthAtLocation = function depthAtLocation(location) {\n    if (location === Location.EXTERIOR) {\n        return 0;\n    }\n    if (location === Location.INTERIOR) {\n        return 1;\n    }\n    return Depth.NULL_VALUE;\n};\nstaticAccessors$31.NULL_VALUE.get = function() {\n    return -1;\n};\nObject.defineProperties(Depth, staticAccessors$31);\nvar Edge = function(GraphComponent$$1) {\n    function Edge() {\n        GraphComponent$$1.call(this);\n        this.pts = null;\n        this._env = null;\n        this.eiList = new EdgeIntersectionList(this);\n        this._name = null;\n        this._mce = null;\n        this._isIsolated = true;\n        this._depth = new Depth();\n        this._depthDelta = 0;\n        if (arguments.length === 1) {\n            var pts = arguments[0];\n            Edge.call(this, pts, null);\n        } else if (arguments.length === 2) {\n            var pts$1 = arguments[0];\n            var label = arguments[1];\n            this.pts = pts$1;\n            this._label = label;\n        }\n    }\n    if (GraphComponent$$1) Edge.__proto__ = GraphComponent$$1;\n    Edge.prototype = Object.create(GraphComponent$$1 && GraphComponent$$1.prototype);\n    Edge.prototype.constructor = Edge;\n    Edge.prototype.getDepth = function getDepth() {\n        return this._depth;\n    };\n    Edge.prototype.getCollapsedEdge = function getCollapsedEdge() {\n        var newPts = new Array(2).fill(null);\n        newPts[0] = this.pts[0];\n        newPts[1] = this.pts[1];\n        var newe = new Edge(newPts, Label.toLineLabel(this._label));\n        return newe;\n    };\n    Edge.prototype.isIsolated = function isIsolated() {\n        return this._isIsolated;\n    };\n    Edge.prototype.getCoordinates = function getCoordinates() {\n        return this.pts;\n    };\n    Edge.prototype.setIsolated = function setIsolated(isIsolated) {\n        this._isIsolated = isIsolated;\n    };\n    Edge.prototype.setName = function setName(name) {\n        this._name = name;\n    };\n    Edge.prototype.equals = function equals(o) {\n        var this$1 = this;\n        if (!(o instanceof Edge)) {\n            return false;\n        }\n        var e = o;\n        if (this.pts.length !== e.pts.length) {\n            return false;\n        }\n        var isEqualForward = true;\n        var isEqualReverse = true;\n        var iRev = this.pts.length;\n        for(var i = 0; i < this.pts.length; i++){\n            if (!this$1.pts[i].equals2D(e.pts[i])) {\n                isEqualForward = false;\n            }\n            if (!this$1.pts[i].equals2D(e.pts[--iRev])) {\n                isEqualReverse = false;\n            }\n            if (!isEqualForward && !isEqualReverse) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Edge.prototype.getCoordinate = function getCoordinate() {\n        if (arguments.length === 0) {\n            if (this.pts.length > 0) {\n                return this.pts[0];\n            }\n            return null;\n        } else if (arguments.length === 1) {\n            var i = arguments[0];\n            return this.pts[i];\n        }\n    };\n    Edge.prototype.print = function print(out) {\n        var this$1 = this;\n        out.print(\"edge \" + this._name + \": \");\n        out.print(\"LINESTRING (\");\n        for(var i = 0; i < this.pts.length; i++){\n            if (i > 0) {\n                out.print(\",\");\n            }\n            out.print(this$1.pts[i].x + \" \" + this$1.pts[i].y);\n        }\n        out.print(\")  \" + this._label + \" \" + this._depthDelta);\n    };\n    Edge.prototype.computeIM = function computeIM(im) {\n        Edge.updateIM(this._label, im);\n    };\n    Edge.prototype.isCollapsed = function isCollapsed() {\n        if (!this._label.isArea()) {\n            return false;\n        }\n        if (this.pts.length !== 3) {\n            return false;\n        }\n        if (this.pts[0].equals(this.pts[2])) {\n            return true;\n        }\n        return false;\n    };\n    Edge.prototype.isClosed = function isClosed() {\n        return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    };\n    Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex() {\n        return this.pts.length - 1;\n    };\n    Edge.prototype.getDepthDelta = function getDepthDelta() {\n        return this._depthDelta;\n    };\n    Edge.prototype.getNumPoints = function getNumPoints() {\n        return this.pts.length;\n    };\n    Edge.prototype.printReverse = function printReverse(out) {\n        var this$1 = this;\n        out.print(\"edge \" + this._name + \": \");\n        for(var i = this.pts.length - 1; i >= 0; i--){\n            out.print(this$1.pts[i] + \" \");\n        }\n        out.println(\"\");\n    };\n    Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge() {\n        if (this._mce === null) {\n            this._mce = new MonotoneChainEdge(this);\n        }\n        return this._mce;\n    };\n    Edge.prototype.getEnvelope = function getEnvelope() {\n        var this$1 = this;\n        if (this._env === null) {\n            this._env = new Envelope();\n            for(var i = 0; i < this.pts.length; i++){\n                this$1._env.expandToInclude(this$1.pts[i]);\n            }\n        }\n        return this._env;\n    };\n    Edge.prototype.addIntersection = function addIntersection(li, segmentIndex, geomIndex, intIndex) {\n        var intPt = new Coordinate(li.getIntersection(intIndex));\n        var normalizedSegmentIndex = segmentIndex;\n        var dist = li.getEdgeDistance(geomIndex, intIndex);\n        var nextSegIndex = normalizedSegmentIndex + 1;\n        if (nextSegIndex < this.pts.length) {\n            var nextPt = this.pts[nextSegIndex];\n            if (intPt.equals2D(nextPt)) {\n                normalizedSegmentIndex = nextSegIndex;\n                dist = 0.0;\n            }\n        }\n        this.eiList.add(intPt, normalizedSegmentIndex, dist);\n    };\n    Edge.prototype.toString = function toString() {\n        var this$1 = this;\n        var buf = new StringBuffer();\n        buf.append(\"edge \" + this._name + \": \");\n        buf.append(\"LINESTRING (\");\n        for(var i = 0; i < this.pts.length; i++){\n            if (i > 0) {\n                buf.append(\",\");\n            }\n            buf.append(this$1.pts[i].x + \" \" + this$1.pts[i].y);\n        }\n        buf.append(\")  \" + this._label + \" \" + this._depthDelta);\n        return buf.toString();\n    };\n    Edge.prototype.isPointwiseEqual = function isPointwiseEqual(e) {\n        var this$1 = this;\n        if (this.pts.length !== e.pts.length) {\n            return false;\n        }\n        for(var i = 0; i < this.pts.length; i++){\n            if (!this$1.pts[i].equals2D(e.pts[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Edge.prototype.setDepthDelta = function setDepthDelta(depthDelta) {\n        this._depthDelta = depthDelta;\n    };\n    Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList() {\n        return this.eiList;\n    };\n    Edge.prototype.addIntersections = function addIntersections(li, segmentIndex, geomIndex) {\n        var this$1 = this;\n        for(var i = 0; i < li.getIntersectionNum(); i++){\n            this$1.addIntersection(li, segmentIndex, geomIndex, i);\n        }\n    };\n    Edge.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    Edge.prototype.getClass = function getClass() {\n        return Edge;\n    };\n    Edge.updateIM = function updateIM() {\n        if (arguments.length === 2) {\n            var label = arguments[0];\n            var im = arguments[1];\n            im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n            if (label.isArea()) {\n                im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n                im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n            }\n        } else {\n            return GraphComponent$$1.prototype.updateIM.apply(this, arguments);\n        }\n    };\n    return Edge;\n}(GraphComponent);\nvar BufferBuilder = function BufferBuilder(bufParams) {\n    this._workingPrecisionModel = null;\n    this._workingNoder = null;\n    this._geomFact = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    this._bufParams = bufParams || null;\n};\nBufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel(pm) {\n    this._workingPrecisionModel = pm;\n};\nBufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge(e) {\n    var existingEdge = this._edgeList.findEqualEdge(e);\n    if (existingEdge !== null) {\n        var existingLabel = existingEdge.getLabel();\n        var labelToMerge = e.getLabel();\n        if (!existingEdge.isPointwiseEqual(e)) {\n            labelToMerge = new Label(e.getLabel());\n            labelToMerge.flip();\n        }\n        existingLabel.merge(labelToMerge);\n        var mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n        var existingDelta = existingEdge.getDepthDelta();\n        var newDelta = existingDelta + mergeDelta;\n        existingEdge.setDepthDelta(newDelta);\n    } else {\n        this._edgeList.add(e);\n        e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n    }\n};\nBufferBuilder.prototype.buildSubgraphs = function buildSubgraphs(subgraphList, polyBuilder) {\n    var processedGraphs = new ArrayList();\n    for(var i = subgraphList.iterator(); i.hasNext();){\n        var subgraph = i.next();\n        var p = subgraph.getRightmostCoordinate();\n        var locater = new SubgraphDepthLocater(processedGraphs);\n        var outsideDepth = locater.getDepth(p);\n        subgraph.computeDepth(outsideDepth);\n        subgraph.findResultEdges();\n        processedGraphs.add(subgraph);\n        polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n    }\n};\nBufferBuilder.prototype.createSubgraphs = function createSubgraphs(graph) {\n    var subgraphList = new ArrayList();\n    for(var i = graph.getNodes().iterator(); i.hasNext();){\n        var node = i.next();\n        if (!node.isVisited()) {\n            var subgraph = new BufferSubgraph();\n            subgraph.create(node);\n            subgraphList.add(subgraph);\n        }\n    }\n    Collections.sort(subgraphList, Collections.reverseOrder());\n    return subgraphList;\n};\nBufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry() {\n    var emptyGeom = this._geomFact.createPolygon();\n    return emptyGeom;\n};\nBufferBuilder.prototype.getNoder = function getNoder(precisionModel) {\n    if (this._workingNoder !== null) {\n        return this._workingNoder;\n    }\n    var noder = new MCIndexNoder();\n    var li = new RobustLineIntersector();\n    li.setPrecisionModel(precisionModel);\n    noder.setSegmentIntersector(new IntersectionAdder(li));\n    return noder;\n};\nBufferBuilder.prototype.buffer = function buffer(g, distance) {\n    var precisionModel = this._workingPrecisionModel;\n    if (precisionModel === null) {\n        precisionModel = g.getPrecisionModel();\n    }\n    this._geomFact = g.getFactory();\n    var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n    var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n    var bufferSegStrList = curveSetBuilder.getCurves();\n    if (bufferSegStrList.size() <= 0) {\n        return this.createEmptyResultGeometry();\n    }\n    this.computeNodedEdges(bufferSegStrList, precisionModel);\n    this._graph = new PlanarGraph(new OverlayNodeFactory());\n    this._graph.addEdges(this._edgeList.getEdges());\n    var subgraphList = this.createSubgraphs(this._graph);\n    var polyBuilder = new PolygonBuilder(this._geomFact);\n    this.buildSubgraphs(subgraphList, polyBuilder);\n    var resultPolyList = polyBuilder.getPolygons();\n    if (resultPolyList.size() <= 0) {\n        return this.createEmptyResultGeometry();\n    }\n    var resultGeom = this._geomFact.buildGeometry(resultPolyList);\n    return resultGeom;\n};\nBufferBuilder.prototype.computeNodedEdges = function computeNodedEdges(bufferSegStrList, precisionModel) {\n    var this$1 = this;\n    var noder = this.getNoder(precisionModel);\n    noder.computeNodes(bufferSegStrList);\n    var nodedSegStrings = noder.getNodedSubstrings();\n    for(var i = nodedSegStrings.iterator(); i.hasNext();){\n        var segStr = i.next();\n        var pts = segStr.getCoordinates();\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n            continue;\n        }\n        var oldLabel = segStr.getData();\n        var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n        this$1.insertUniqueEdge(edge);\n    }\n};\nBufferBuilder.prototype.setNoder = function setNoder(noder) {\n    this._workingNoder = noder;\n};\nBufferBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferBuilder.prototype.getClass = function getClass() {\n    return BufferBuilder;\n};\nBufferBuilder.depthDelta = function depthDelta(label) {\n    var lLoc = label.getLocation(0, Position.LEFT);\n    var rLoc = label.getLocation(0, Position.RIGHT);\n    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) {\n        return 1;\n    } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) {\n        return -1;\n    }\n    return 0;\n};\nBufferBuilder.convertSegStrings = function convertSegStrings(it) {\n    var fact = new GeometryFactory();\n    var lines = new ArrayList();\n    while(it.hasNext()){\n        var ss = it.next();\n        var line = fact.createLineString(ss.getCoordinates());\n        lines.add(line);\n    }\n    return fact.buildGeometry(lines);\n};\nvar ScaledNoder = function ScaledNoder() {\n    this._noder = null;\n    this._scaleFactor = null;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._isScaled = false;\n    if (arguments.length === 2) {\n        var noder = arguments[0];\n        var scaleFactor = arguments[1];\n        this._noder = noder;\n        this._scaleFactor = scaleFactor;\n        this._offsetX = 0.0;\n        this._offsetY = 0.0;\n        this._isScaled = !this.isIntegerPrecision();\n    } else if (arguments.length === 4) {\n        var noder$1 = arguments[0];\n        var scaleFactor$1 = arguments[1];\n        var offsetX = arguments[2];\n        var offsetY = arguments[3];\n        this._noder = noder$1;\n        this._scaleFactor = scaleFactor$1;\n        this._offsetX = offsetX;\n        this._offsetY = offsetY;\n        this._isScaled = !this.isIntegerPrecision();\n    }\n};\nScaledNoder.prototype.rescale = function rescale() {\n    var this$1 = this;\n    if (hasInterface(arguments[0], Collection)) {\n        var segStrings = arguments[0];\n        for(var i = segStrings.iterator(); i.hasNext();){\n            var ss = i.next();\n            this$1.rescale(ss.getCoordinates());\n        }\n    } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n        // let p0 = null\n        // let p1 = null\n        // if (pts.length === 2) {\n        // p0 = new Coordinate(pts[0])\n        // p1 = new Coordinate(pts[1])\n        // }\n        for(var i$1 = 0; i$1 < pts.length; i$1++){\n            pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;\n            pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;\n        }\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n            System.out.println(pts);\n        }\n    }\n};\nScaledNoder.prototype.scale = function scale() {\n    var this$1 = this;\n    if (hasInterface(arguments[0], Collection)) {\n        var segStrings = arguments[0];\n        var nodedSegmentStrings = new ArrayList();\n        for(var i = segStrings.iterator(); i.hasNext();){\n            var ss = i.next();\n            nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));\n        }\n        return nodedSegmentStrings;\n    } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n        var roundPts = new Array(pts.length).fill(null);\n        for(var i$1 = 0; i$1 < pts.length; i$1++){\n            roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);\n        }\n        var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n        return roundPtsNoDup;\n    }\n};\nScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision() {\n    return this._scaleFactor === 1.0;\n};\nScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings() {\n    var splitSS = this._noder.getNodedSubstrings();\n    if (this._isScaled) {\n        this.rescale(splitSS);\n    }\n    return splitSS;\n};\nScaledNoder.prototype.computeNodes = function computeNodes(inputSegStrings) {\n    var intSegStrings = inputSegStrings;\n    if (this._isScaled) {\n        intSegStrings = this.scale(inputSegStrings);\n    }\n    this._noder.computeNodes(intSegStrings);\n};\nScaledNoder.prototype.interfaces_ = function interfaces_() {\n    return [\n        Noder\n    ];\n};\nScaledNoder.prototype.getClass = function getClass() {\n    return ScaledNoder;\n};\nvar NodingValidator = function NodingValidator() {\n    this._li = new RobustLineIntersector();\n    this._segStrings = null;\n    var segStrings = arguments[0];\n    this._segStrings = segStrings;\n};\nvar staticAccessors$33 = {\n    fact: {\n        configurable: true\n    }\n};\nNodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        for(var i = this._segStrings.iterator(); i.hasNext();){\n            var ss = i.next();\n            var pts = ss.getCoordinates();\n            this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);\n            this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);\n        }\n    } else if (arguments.length === 2) {\n        var testPt = arguments[0];\n        var segStrings = arguments[1];\n        for(var i$1 = segStrings.iterator(); i$1.hasNext();){\n            var ss$1 = i$1.next();\n            var pts$1 = ss$1.getCoordinates();\n            for(var j = 1; j < pts$1.length - 1; j++){\n                if (pts$1[j].equals(testPt)) {\n                    throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n                }\n            }\n        }\n    }\n};\nNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        for(var i = this._segStrings.iterator(); i.hasNext();){\n            var ss0 = i.next();\n            for(var j = this._segStrings.iterator(); j.hasNext();){\n                var ss1 = j.next();\n                this$1.checkInteriorIntersections(ss0, ss1);\n            }\n        }\n    } else if (arguments.length === 2) {\n        var ss0$1 = arguments[0];\n        var ss1$1 = arguments[1];\n        var pts0 = ss0$1.getCoordinates();\n        var pts1 = ss1$1.getCoordinates();\n        for(var i0 = 0; i0 < pts0.length - 1; i0++){\n            for(var i1 = 0; i1 < pts1.length - 1; i1++){\n                this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);\n            }\n        }\n    } else if (arguments.length === 4) {\n        var e0 = arguments[0];\n        var segIndex0 = arguments[1];\n        var e1 = arguments[2];\n        var segIndex1 = arguments[3];\n        if (e0 === e1 && segIndex0 === segIndex1) {\n            return null;\n        }\n        var p00 = e0.getCoordinates()[segIndex0];\n        var p01 = e0.getCoordinates()[segIndex0 + 1];\n        var p10 = e1.getCoordinates()[segIndex1];\n        var p11 = e1.getCoordinates()[segIndex1 + 1];\n        this._li.computeIntersection(p00, p01, p10, p11);\n        if (this._li.hasIntersection()) {\n            if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n                throw new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n            }\n        }\n    }\n};\nNodingValidator.prototype.checkValid = function checkValid() {\n    this.checkEndPtVertexIntersections();\n    this.checkInteriorIntersections();\n    this.checkCollapses();\n};\nNodingValidator.prototype.checkCollapses = function checkCollapses() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        for(var i = this._segStrings.iterator(); i.hasNext();){\n            var ss = i.next();\n            this$1.checkCollapses(ss);\n        }\n    } else if (arguments.length === 1) {\n        var ss$1 = arguments[0];\n        var pts = ss$1.getCoordinates();\n        for(var i$1 = 0; i$1 < pts.length - 2; i$1++){\n            this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);\n        }\n    }\n};\nNodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection(li, p0, p1) {\n    for(var i = 0; i < li.getIntersectionNum(); i++){\n        var intPt = li.getIntersection(i);\n        if (!(intPt.equals(p0) || intPt.equals(p1))) {\n            return true;\n        }\n    }\n    return false;\n};\nNodingValidator.prototype.checkCollapse = function checkCollapse(p0, p1, p2) {\n    if (p0.equals(p2)) {\n        throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([\n            p0,\n            p1,\n            p2\n        ]));\n    }\n};\nNodingValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nNodingValidator.prototype.getClass = function getClass() {\n    return NodingValidator;\n};\nstaticAccessors$33.fact.get = function() {\n    return new GeometryFactory();\n};\nObject.defineProperties(NodingValidator, staticAccessors$33);\nvar HotPixel = function HotPixel() {\n    this._li = null;\n    this._pt = null;\n    this._originalPt = null;\n    this._ptScaled = null;\n    this._p0Scaled = null;\n    this._p1Scaled = null;\n    this._scaleFactor = null;\n    this._minx = null;\n    this._maxx = null;\n    this._miny = null;\n    this._maxy = null;\n    this._corner = new Array(4).fill(null);\n    this._safeEnv = null;\n    var pt = arguments[0];\n    var scaleFactor = arguments[1];\n    var li = arguments[2];\n    this._originalPt = pt;\n    this._pt = pt;\n    this._scaleFactor = scaleFactor;\n    this._li = li;\n    if (scaleFactor <= 0) {\n        throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n    }\n    if (scaleFactor !== 1.0) {\n        this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n        this._p0Scaled = new Coordinate();\n        this._p1Scaled = new Coordinate();\n    }\n    this.initCorners(this._pt);\n};\nvar staticAccessors$34 = {\n    SAFE_ENV_EXPANSION_FACTOR: {\n        configurable: true\n    }\n};\nHotPixel.prototype.intersectsScaled = function intersectsScaled(p0, p1) {\n    var segMinx = Math.min(p0.x, p1.x);\n    var segMaxx = Math.max(p0.x, p1.x);\n    var segMiny = Math.min(p0.y, p1.y);\n    var segMaxy = Math.max(p0.y, p1.y);\n    var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n    if (isOutsidePixelEnv) {\n        return false;\n    }\n    var intersects = this.intersectsToleranceSquare(p0, p1);\n    Assert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n    return intersects;\n};\nHotPixel.prototype.initCorners = function initCorners(pt) {\n    var tolerance = 0.5;\n    this._minx = pt.x - tolerance;\n    this._maxx = pt.x + tolerance;\n    this._miny = pt.y - tolerance;\n    this._maxy = pt.y + tolerance;\n    this._corner[0] = new Coordinate(this._maxx, this._maxy);\n    this._corner[1] = new Coordinate(this._minx, this._maxy);\n    this._corner[2] = new Coordinate(this._minx, this._miny);\n    this._corner[3] = new Coordinate(this._maxx, this._miny);\n};\nHotPixel.prototype.intersects = function intersects(p0, p1) {\n    if (this._scaleFactor === 1.0) {\n        return this.intersectsScaled(p0, p1);\n    }\n    this.copyScaled(p0, this._p0Scaled);\n    this.copyScaled(p1, this._p1Scaled);\n    return this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n};\nHotPixel.prototype.scale = function scale(val) {\n    return Math.round(val * this._scaleFactor);\n};\nHotPixel.prototype.getCoordinate = function getCoordinate() {\n    return this._originalPt;\n};\nHotPixel.prototype.copyScaled = function copyScaled(p, pScaled) {\n    pScaled.x = this.scale(p.x);\n    pScaled.y = this.scale(p.y);\n};\nHotPixel.prototype.getSafeEnvelope = function getSafeEnvelope() {\n    if (this._safeEnv === null) {\n        var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n        this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n    }\n    return this._safeEnv;\n};\nHotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure(p0, p1) {\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n    if (this._li.hasIntersection()) {\n        return true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n    if (this._li.hasIntersection()) {\n        return true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n    if (this._li.hasIntersection()) {\n        return true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n    if (this._li.hasIntersection()) {\n        return true;\n    }\n    return false;\n};\nHotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare(p0, p1) {\n    var intersectsLeft = false;\n    var intersectsBottom = false;\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n    if (this._li.isProper()) {\n        return true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n    if (this._li.isProper()) {\n        return true;\n    }\n    if (this._li.hasIntersection()) {\n        intersectsLeft = true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n    if (this._li.isProper()) {\n        return true;\n    }\n    if (this._li.hasIntersection()) {\n        intersectsBottom = true;\n    }\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n    if (this._li.isProper()) {\n        return true;\n    }\n    if (intersectsLeft && intersectsBottom) {\n        return true;\n    }\n    if (p0.equals(this._pt)) {\n        return true;\n    }\n    if (p1.equals(this._pt)) {\n        return true;\n    }\n    return false;\n};\nHotPixel.prototype.addSnappedNode = function addSnappedNode(segStr, segIndex) {\n    var p0 = segStr.getCoordinate(segIndex);\n    var p1 = segStr.getCoordinate(segIndex + 1);\n    if (this.intersects(p0, p1)) {\n        segStr.addIntersection(this.getCoordinate(), segIndex);\n        return true;\n    }\n    return false;\n};\nHotPixel.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nHotPixel.prototype.getClass = function getClass() {\n    return HotPixel;\n};\nstaticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function() {\n    return 0.75;\n};\nObject.defineProperties(HotPixel, staticAccessors$34);\nvar MonotoneChainSelectAction = function MonotoneChainSelectAction() {\n    this.tempEnv1 = new Envelope();\n    this.selectedSegment = new LineSegment();\n};\nMonotoneChainSelectAction.prototype.select = function select() {\n    if (arguments.length === 1) {\n    // const seg = arguments[0]\n    } else if (arguments.length === 2) {\n        var mc = arguments[0];\n        var startIndex = arguments[1];\n        mc.getLineSegment(startIndex, this.selectedSegment);\n        this.select(this.selectedSegment);\n    }\n};\nMonotoneChainSelectAction.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChainSelectAction.prototype.getClass = function getClass() {\n    return MonotoneChainSelectAction;\n};\nvar MCIndexPointSnapper = function MCIndexPointSnapper() {\n    this._index = null;\n    var index = arguments[0];\n    this._index = index;\n};\nvar staticAccessors$35 = {\n    HotPixelSnapAction: {\n        configurable: true\n    }\n};\nMCIndexPointSnapper.prototype.snap = function snap() {\n    if (arguments.length === 1) {\n        var hotPixel = arguments[0];\n        return this.snap(hotPixel, null, -1);\n    } else if (arguments.length === 3) {\n        var hotPixel$1 = arguments[0];\n        var parentEdge = arguments[1];\n        var hotPixelVertexIndex = arguments[2];\n        var pixelEnv = hotPixel$1.getSafeEnvelope();\n        var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);\n        this._index.query(pixelEnv, {\n            interfaces_: function() {\n                return [\n                    ItemVisitor\n                ];\n            },\n            visitItem: function(item) {\n                var testChain = item;\n                testChain.select(pixelEnv, hotPixelSnapAction);\n            }\n        });\n        return hotPixelSnapAction.isNodeAdded();\n    }\n};\nMCIndexPointSnapper.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMCIndexPointSnapper.prototype.getClass = function getClass() {\n    return MCIndexPointSnapper;\n};\nstaticAccessors$35.HotPixelSnapAction.get = function() {\n    return HotPixelSnapAction;\n};\nObject.defineProperties(MCIndexPointSnapper, staticAccessors$35);\nvar HotPixelSnapAction = function(MonotoneChainSelectAction$$1) {\n    function HotPixelSnapAction() {\n        MonotoneChainSelectAction$$1.call(this);\n        this._hotPixel = null;\n        this._parentEdge = null;\n        this._hotPixelVertexIndex = null;\n        this._isNodeAdded = false;\n        var hotPixel = arguments[0];\n        var parentEdge = arguments[1];\n        var hotPixelVertexIndex = arguments[2];\n        this._hotPixel = hotPixel;\n        this._parentEdge = parentEdge;\n        this._hotPixelVertexIndex = hotPixelVertexIndex;\n    }\n    if (MonotoneChainSelectAction$$1) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;\n    HotPixelSnapAction.prototype = Object.create(MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype);\n    HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;\n    HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded() {\n        return this._isNodeAdded;\n    };\n    HotPixelSnapAction.prototype.select = function select() {\n        if (arguments.length === 2) {\n            var mc = arguments[0];\n            var startIndex = arguments[1];\n            var ss = mc.getContext();\n            if (this._parentEdge !== null) {\n                if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) {\n                    return null;\n                }\n            }\n            this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n        } else {\n            return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments);\n        }\n    };\n    HotPixelSnapAction.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    HotPixelSnapAction.prototype.getClass = function getClass() {\n        return HotPixelSnapAction;\n    };\n    return HotPixelSnapAction;\n}(MonotoneChainSelectAction);\nvar InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder() {\n    this._li = null;\n    this._interiorIntersections = null;\n    var li = arguments[0];\n    this._li = li;\n    this._interiorIntersections = new ArrayList();\n};\nInteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {\n    var this$1 = this;\n    if (e0 === e1 && segIndex0 === segIndex1) {\n        return null;\n    }\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n        if (this._li.isInteriorIntersection()) {\n            for(var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++){\n                this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));\n            }\n            e0.addIntersections(this._li, segIndex0, 0);\n            e1.addIntersections(this._li, segIndex1, 1);\n        }\n    }\n};\nInteriorIntersectionFinderAdder.prototype.isDone = function isDone() {\n    return false;\n};\nInteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections() {\n    return this._interiorIntersections;\n};\nInteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_() {\n    return [\n        SegmentIntersector\n    ];\n};\nInteriorIntersectionFinderAdder.prototype.getClass = function getClass() {\n    return InteriorIntersectionFinderAdder;\n};\nvar MCIndexSnapRounder = function MCIndexSnapRounder() {\n    this._pm = null;\n    this._li = null;\n    this._scaleFactor = null;\n    this._noder = null;\n    this._pointSnapper = null;\n    this._nodedSegStrings = null;\n    var pm = arguments[0];\n    this._pm = pm;\n    this._li = new RobustLineIntersector();\n    this._li.setPrecisionModel(pm);\n    this._scaleFactor = pm.getScale();\n};\nMCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness(inputSegmentStrings) {\n    var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n    var nv = new NodingValidator(resultSegStrings);\n    try {\n        nv.checkValid();\n    } catch (ex) {\n        if (ex instanceof Exception) {\n            ex.printStackTrace();\n        } else {\n            throw ex;\n        }\n    } finally{}\n};\nMCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings() {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n};\nMCIndexSnapRounder.prototype.snapRound = function snapRound(segStrings, li) {\n    var intersections = this.findInteriorIntersections(segStrings, li);\n    this.computeIntersectionSnaps(intersections);\n    this.computeVertexSnaps(segStrings);\n};\nMCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections(segStrings, li) {\n    var intFinderAdder = new InteriorIntersectionFinderAdder(li);\n    this._noder.setSegmentIntersector(intFinderAdder);\n    this._noder.computeNodes(segStrings);\n    return intFinderAdder.getInteriorIntersections();\n};\nMCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps() {\n    var this$1 = this;\n    if (hasInterface(arguments[0], Collection)) {\n        var edges = arguments[0];\n        for(var i0 = edges.iterator(); i0.hasNext();){\n            var edge0 = i0.next();\n            this$1.computeVertexSnaps(edge0);\n        }\n    } else if (arguments[0] instanceof NodedSegmentString) {\n        var e = arguments[0];\n        var pts0 = e.getCoordinates();\n        for(var i = 0; i < pts0.length; i++){\n            var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);\n            var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);\n            if (isNodeAdded) {\n                e.addIntersection(pts0[i], i);\n            }\n        }\n    }\n};\nMCIndexSnapRounder.prototype.computeNodes = function computeNodes(inputSegmentStrings) {\n    this._nodedSegStrings = inputSegmentStrings;\n    this._noder = new MCIndexNoder();\n    this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n    this.snapRound(inputSegmentStrings, this._li);\n};\nMCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps(snapPts) {\n    var this$1 = this;\n    for(var it = snapPts.iterator(); it.hasNext();){\n        var snapPt = it.next();\n        var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);\n        this$1._pointSnapper.snap(hotPixel);\n    }\n};\nMCIndexSnapRounder.prototype.interfaces_ = function interfaces_() {\n    return [\n        Noder\n    ];\n};\nMCIndexSnapRounder.prototype.getClass = function getClass() {\n    return MCIndexSnapRounder;\n};\nvar BufferOp = function BufferOp() {\n    this._argGeom = null;\n    this._distance = null;\n    this._bufParams = new BufferParameters();\n    this._resultGeometry = null;\n    this._saveException = null;\n    if (arguments.length === 1) {\n        var g = arguments[0];\n        this._argGeom = g;\n    } else if (arguments.length === 2) {\n        var g$1 = arguments[0];\n        var bufParams = arguments[1];\n        this._argGeom = g$1;\n        this._bufParams = bufParams;\n    }\n};\nvar staticAccessors$32 = {\n    CAP_ROUND: {\n        configurable: true\n    },\n    CAP_BUTT: {\n        configurable: true\n    },\n    CAP_FLAT: {\n        configurable: true\n    },\n    CAP_SQUARE: {\n        configurable: true\n    },\n    MAX_PRECISION_DIGITS: {\n        configurable: true\n    }\n};\nBufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision(fixedPM) {\n    var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n    var bufBuilder = new BufferBuilder(this._bufParams);\n    bufBuilder.setWorkingPrecisionModel(fixedPM);\n    bufBuilder.setNoder(noder);\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n};\nBufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        for(var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--){\n            try {\n                this$1.bufferReducedPrecision(precDigits);\n            } catch (ex) {\n                if (ex instanceof TopologyException) {\n                    this$1._saveException = ex;\n                } else {\n                    throw ex;\n                }\n            } finally{}\n            if (this$1._resultGeometry !== null) {\n                return null;\n            }\n        }\n        throw this._saveException;\n    } else if (arguments.length === 1) {\n        var precisionDigits = arguments[0];\n        var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n        var fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n        this.bufferFixedPrecision(fixedPM);\n    }\n};\nBufferOp.prototype.computeGeometry = function computeGeometry() {\n    this.bufferOriginalPrecision();\n    if (this._resultGeometry !== null) {\n        return null;\n    }\n    var argPM = this._argGeom.getFactory().getPrecisionModel();\n    if (argPM.getType() === PrecisionModel.FIXED) {\n        this.bufferFixedPrecision(argPM);\n    } else {\n        this.bufferReducedPrecision();\n    }\n};\nBufferOp.prototype.setQuadrantSegments = function setQuadrantSegments(quadrantSegments) {\n    this._bufParams.setQuadrantSegments(quadrantSegments);\n};\nBufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision() {\n    try {\n        var bufBuilder = new BufferBuilder(this._bufParams);\n        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n    } catch (ex) {\n        if (ex instanceof RuntimeException) {\n            this._saveException = ex;\n        } else {\n            throw ex;\n        }\n    } finally{}\n};\nBufferOp.prototype.getResultGeometry = function getResultGeometry(distance) {\n    this._distance = distance;\n    this.computeGeometry();\n    return this._resultGeometry;\n};\nBufferOp.prototype.setEndCapStyle = function setEndCapStyle(endCapStyle) {\n    this._bufParams.setEndCapStyle(endCapStyle);\n};\nBufferOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferOp.prototype.getClass = function getClass() {\n    return BufferOp;\n};\nBufferOp.bufferOp = function bufferOp() {\n    if (arguments.length === 2) {\n        var g = arguments[0];\n        var distance = arguments[1];\n        var gBuf = new BufferOp(g);\n        var geomBuf = gBuf.getResultGeometry(distance);\n        return geomBuf;\n    } else if (arguments.length === 3) {\n        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n            var g$1 = arguments[0];\n            var distance$1 = arguments[1];\n            var quadrantSegments = arguments[2];\n            var bufOp = new BufferOp(g$1);\n            bufOp.setQuadrantSegments(quadrantSegments);\n            var geomBuf$1 = bufOp.getResultGeometry(distance$1);\n            return geomBuf$1;\n        } else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n            var g$2 = arguments[0];\n            var distance$2 = arguments[1];\n            var params = arguments[2];\n            var bufOp$1 = new BufferOp(g$2, params);\n            var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);\n            return geomBuf$2;\n        }\n    } else if (arguments.length === 4) {\n        var g$3 = arguments[0];\n        var distance$3 = arguments[1];\n        var quadrantSegments$1 = arguments[2];\n        var endCapStyle = arguments[3];\n        var bufOp$2 = new BufferOp(g$3);\n        bufOp$2.setQuadrantSegments(quadrantSegments$1);\n        bufOp$2.setEndCapStyle(endCapStyle);\n        var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);\n        return geomBuf$3;\n    }\n};\nBufferOp.precisionScaleFactor = function precisionScaleFactor(g, distance, maxPrecisionDigits) {\n    var env = g.getEnvelopeInternal();\n    var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n    var expandByDistance = distance > 0.0 ? distance : 0.0;\n    var bufEnvMax = envMax + 2 * expandByDistance;\n    var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n    var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n    var scaleFactor = Math.pow(10.0, minUnitLog10);\n    return scaleFactor;\n};\nstaticAccessors$32.CAP_ROUND.get = function() {\n    return BufferParameters.CAP_ROUND;\n};\nstaticAccessors$32.CAP_BUTT.get = function() {\n    return BufferParameters.CAP_FLAT;\n};\nstaticAccessors$32.CAP_FLAT.get = function() {\n    return BufferParameters.CAP_FLAT;\n};\nstaticAccessors$32.CAP_SQUARE.get = function() {\n    return BufferParameters.CAP_SQUARE;\n};\nstaticAccessors$32.MAX_PRECISION_DIGITS.get = function() {\n    return 12;\n};\nObject.defineProperties(BufferOp, staticAccessors$32);\nvar PointPairDistance = function PointPairDistance() {\n    this._pt = [\n        new Coordinate(),\n        new Coordinate()\n    ];\n    this._distance = Double.NaN;\n    this._isNull = true;\n};\nPointPairDistance.prototype.getCoordinates = function getCoordinates() {\n    return this._pt;\n};\nPointPairDistance.prototype.getCoordinate = function getCoordinate(i) {\n    return this._pt[i];\n};\nPointPairDistance.prototype.setMinimum = function setMinimum() {\n    if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        if (this._isNull) {\n            this.initialize(p0, p1);\n            return null;\n        }\n        var dist = p0.distance(p1);\n        if (dist < this._distance) {\n            this.initialize(p0, p1, dist);\n        }\n    }\n};\nPointPairDistance.prototype.initialize = function initialize() {\n    if (arguments.length === 0) {\n        this._isNull = true;\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        this._pt[0].setCoordinate(p0);\n        this._pt[1].setCoordinate(p1);\n        this._distance = p0.distance(p1);\n        this._isNull = false;\n    } else if (arguments.length === 3) {\n        var p0$1 = arguments[0];\n        var p1$1 = arguments[1];\n        var distance = arguments[2];\n        this._pt[0].setCoordinate(p0$1);\n        this._pt[1].setCoordinate(p1$1);\n        this._distance = distance;\n        this._isNull = false;\n    }\n};\nPointPairDistance.prototype.getDistance = function getDistance() {\n    return this._distance;\n};\nPointPairDistance.prototype.setMaximum = function setMaximum() {\n    if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        if (this._isNull) {\n            this.initialize(p0, p1);\n            return null;\n        }\n        var dist = p0.distance(p1);\n        if (dist > this._distance) {\n            this.initialize(p0, p1, dist);\n        }\n    }\n};\nPointPairDistance.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPointPairDistance.prototype.getClass = function getClass() {\n    return PointPairDistance;\n};\nvar DistanceToPointFinder = function DistanceToPointFinder() {};\nDistanceToPointFinder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDistanceToPointFinder.prototype.getClass = function getClass() {\n    return DistanceToPointFinder;\n};\nDistanceToPointFinder.computeDistance = function computeDistance() {\n    if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {\n        var line = arguments[0];\n        var pt = arguments[1];\n        var ptDist = arguments[2];\n        var coords = line.getCoordinates();\n        var tempSegment = new LineSegment();\n        for(var i = 0; i < coords.length - 1; i++){\n            tempSegment.setCoordinates(coords[i], coords[i + 1]);\n            var closestPt = tempSegment.closestPoint(pt);\n            ptDist.setMinimum(closestPt, pt);\n        }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {\n        var poly = arguments[0];\n        var pt$1 = arguments[1];\n        var ptDist$1 = arguments[2];\n        DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n        for(var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++){\n            DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n        }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {\n        var geom = arguments[0];\n        var pt$2 = arguments[1];\n        var ptDist$2 = arguments[2];\n        if (geom instanceof LineString) {\n            DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n        } else if (geom instanceof Polygon) {\n            DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n        } else if (geom instanceof GeometryCollection) {\n            var gc = geom;\n            for(var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++){\n                var g = gc.getGeometryN(i$2);\n                DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);\n            }\n        } else {\n            ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n        }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {\n        var segment = arguments[0];\n        var pt$3 = arguments[1];\n        var ptDist$3 = arguments[2];\n        var closestPt$1 = segment.closestPoint(pt$3);\n        ptDist$3.setMinimum(closestPt$1, pt$3);\n    }\n};\nvar BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder(inputGeom) {\n    this._maxPtDist = new PointPairDistance();\n    this._inputGeom = inputGeom || null;\n};\nvar staticAccessors$36 = {\n    MaxPointDistanceFilter: {\n        configurable: true\n    },\n    MaxMidpointDistanceFilter: {\n        configurable: true\n    }\n};\nBufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance(curve) {\n    var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);\n    curve.apply(distFilter);\n    this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance(curve) {\n    var distFilter = new MaxPointDistanceFilter(this._inputGeom);\n    curve.apply(distFilter);\n    this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance(bufferCurve) {\n    this.computeMaxVertexDistance(bufferCurve);\n    this.computeMaxMidpointDistance(bufferCurve);\n    return this._maxPtDist.getDistance();\n};\nBufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints() {\n    return this._maxPtDist;\n};\nBufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferCurveMaximumDistanceFinder.prototype.getClass = function getClass() {\n    return BufferCurveMaximumDistanceFinder;\n};\nstaticAccessors$36.MaxPointDistanceFilter.get = function() {\n    return MaxPointDistanceFilter;\n};\nstaticAccessors$36.MaxMidpointDistanceFilter.get = function() {\n    return MaxMidpointDistanceFilter;\n};\nObject.defineProperties(BufferCurveMaximumDistanceFinder, staticAccessors$36);\nvar MaxPointDistanceFilter = function MaxPointDistanceFilter(geom) {\n    this._maxPtDist = new PointPairDistance();\n    this._minPtDist = new PointPairDistance();\n    this._geom = geom || null;\n};\nMaxPointDistanceFilter.prototype.filter = function filter(pt) {\n    this._minPtDist.initialize();\n    DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);\n    this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {\n    return this._maxPtDist;\n};\nMaxPointDistanceFilter.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateFilter\n    ];\n};\nMaxPointDistanceFilter.prototype.getClass = function getClass() {\n    return MaxPointDistanceFilter;\n};\nvar MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter(geom) {\n    this._maxPtDist = new PointPairDistance();\n    this._minPtDist = new PointPairDistance();\n    this._geom = geom || null;\n};\nMaxMidpointDistanceFilter.prototype.filter = function filter(seq, index) {\n    if (index === 0) {\n        return null;\n    }\n    var p0 = seq.getCoordinate(index - 1);\n    var p1 = seq.getCoordinate(index);\n    var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n    this._minPtDist.initialize();\n    DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);\n    this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxMidpointDistanceFilter.prototype.isDone = function isDone() {\n    return false;\n};\nMaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {\n    return false;\n};\nMaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {\n    return this._maxPtDist;\n};\nMaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateSequenceFilter\n    ];\n};\nMaxMidpointDistanceFilter.prototype.getClass = function getClass() {\n    return MaxMidpointDistanceFilter;\n};\nvar PolygonExtracter = function PolygonExtracter(comps) {\n    this._comps = comps || null;\n};\nPolygonExtracter.prototype.filter = function filter(geom) {\n    if (geom instanceof Polygon) {\n        this._comps.add(geom);\n    }\n};\nPolygonExtracter.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryFilter\n    ];\n};\nPolygonExtracter.prototype.getClass = function getClass() {\n    return PolygonExtracter;\n};\nPolygonExtracter.getPolygons = function getPolygons() {\n    if (arguments.length === 1) {\n        var geom = arguments[0];\n        return PolygonExtracter.getPolygons(geom, new ArrayList());\n    } else if (arguments.length === 2) {\n        var geom$1 = arguments[0];\n        var list = arguments[1];\n        if (geom$1 instanceof Polygon) {\n            list.add(geom$1);\n        } else if (geom$1 instanceof GeometryCollection) {\n            geom$1.apply(new PolygonExtracter(list));\n        }\n        return list;\n    }\n};\nvar LinearComponentExtracter = function LinearComponentExtracter() {\n    this._lines = null;\n    this._isForcedToLineString = false;\n    if (arguments.length === 1) {\n        var lines = arguments[0];\n        this._lines = lines;\n    } else if (arguments.length === 2) {\n        var lines$1 = arguments[0];\n        var isForcedToLineString = arguments[1];\n        this._lines = lines$1;\n        this._isForcedToLineString = isForcedToLineString;\n    }\n};\nLinearComponentExtracter.prototype.filter = function filter(geom) {\n    if (this._isForcedToLineString && geom instanceof LinearRing) {\n        var line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n        this._lines.add(line);\n        return null;\n    }\n    if (geom instanceof LineString) {\n        this._lines.add(geom);\n    }\n};\nLinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString(isForcedToLineString) {\n    this._isForcedToLineString = isForcedToLineString;\n};\nLinearComponentExtracter.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryComponentFilter\n    ];\n};\nLinearComponentExtracter.prototype.getClass = function getClass() {\n    return LinearComponentExtracter;\n};\nLinearComponentExtracter.getGeometry = function getGeometry() {\n    if (arguments.length === 1) {\n        var geom = arguments[0];\n        return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n    } else if (arguments.length === 2) {\n        var geom$1 = arguments[0];\n        var forceToLineString = arguments[1];\n        return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString));\n    }\n};\nLinearComponentExtracter.getLines = function getLines() {\n    if (arguments.length === 1) {\n        var geom = arguments[0];\n        return LinearComponentExtracter.getLines(geom, false);\n    } else if (arguments.length === 2) {\n        if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n            var geoms = arguments[0];\n            var lines$1 = arguments[1];\n            for(var i = geoms.iterator(); i.hasNext();){\n                var g = i.next();\n                LinearComponentExtracter.getLines(g, lines$1);\n            }\n            return lines$1;\n        } else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n            var geom$1 = arguments[0];\n            var forceToLineString = arguments[1];\n            var lines = new ArrayList();\n            geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));\n            return lines;\n        } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n            var geom$2 = arguments[0];\n            var lines$2 = arguments[1];\n            if (geom$2 instanceof LineString) {\n                lines$2.add(geom$2);\n            } else {\n                geom$2.apply(new LinearComponentExtracter(lines$2));\n            }\n            return lines$2;\n        }\n    } else if (arguments.length === 3) {\n        if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n            var geoms$1 = arguments[0];\n            var lines$3 = arguments[1];\n            var forceToLineString$1 = arguments[2];\n            for(var i$1 = geoms$1.iterator(); i$1.hasNext();){\n                var g$1 = i$1.next();\n                LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);\n            }\n            return lines$3;\n        } else if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n            var geom$3 = arguments[0];\n            var lines$4 = arguments[1];\n            var forceToLineString$2 = arguments[2];\n            geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));\n            return lines$4;\n        }\n    }\n};\nvar PointLocator = function PointLocator() {\n    this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n    this._isIn = null;\n    this._numBoundaries = null;\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n        var boundaryRule = arguments[0];\n        if (boundaryRule === null) {\n            throw new IllegalArgumentException(\"Rule must be non-null\");\n        }\n        this._boundaryRule = boundaryRule;\n    }\n};\nPointLocator.prototype.locateInternal = function locateInternal() {\n    var this$1 = this;\n    if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n        var p = arguments[0];\n        var poly = arguments[1];\n        if (poly.isEmpty()) {\n            return Location.EXTERIOR;\n        }\n        var shell = poly.getExteriorRing();\n        var shellLoc = this.locateInPolygonRing(p, shell);\n        if (shellLoc === Location.EXTERIOR) {\n            return Location.EXTERIOR;\n        }\n        if (shellLoc === Location.BOUNDARY) {\n            return Location.BOUNDARY;\n        }\n        for(var i = 0; i < poly.getNumInteriorRing(); i++){\n            var hole = poly.getInteriorRingN(i);\n            var holeLoc = this$1.locateInPolygonRing(p, hole);\n            if (holeLoc === Location.INTERIOR) {\n                return Location.EXTERIOR;\n            }\n            if (holeLoc === Location.BOUNDARY) {\n                return Location.BOUNDARY;\n            }\n        }\n        return Location.INTERIOR;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n        var p$1 = arguments[0];\n        var l = arguments[1];\n        if (!l.getEnvelopeInternal().intersects(p$1)) {\n            return Location.EXTERIOR;\n        }\n        var pt = l.getCoordinates();\n        if (!l.isClosed()) {\n            if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {\n                return Location.BOUNDARY;\n            }\n        }\n        if (CGAlgorithms.isOnLine(p$1, pt)) {\n            return Location.INTERIOR;\n        }\n        return Location.EXTERIOR;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n        var p$2 = arguments[0];\n        var pt$1 = arguments[1];\n        var ptCoord = pt$1.getCoordinate();\n        if (ptCoord.equals2D(p$2)) {\n            return Location.INTERIOR;\n        }\n        return Location.EXTERIOR;\n    }\n};\nPointLocator.prototype.locateInPolygonRing = function locateInPolygonRing(p, ring) {\n    if (!ring.getEnvelopeInternal().intersects(p)) {\n        return Location.EXTERIOR;\n    }\n    return CGAlgorithms.locatePointInRing(p, ring.getCoordinates());\n};\nPointLocator.prototype.intersects = function intersects(p, geom) {\n    return this.locate(p, geom) !== Location.EXTERIOR;\n};\nPointLocator.prototype.updateLocationInfo = function updateLocationInfo(loc) {\n    if (loc === Location.INTERIOR) {\n        this._isIn = true;\n    }\n    if (loc === Location.BOUNDARY) {\n        this._numBoundaries++;\n    }\n};\nPointLocator.prototype.computeLocation = function computeLocation(p, geom) {\n    var this$1 = this;\n    if (geom instanceof Point) {\n        this.updateLocationInfo(this.locateInternal(p, geom));\n    }\n    if (geom instanceof LineString) {\n        this.updateLocationInfo(this.locateInternal(p, geom));\n    } else if (geom instanceof Polygon) {\n        this.updateLocationInfo(this.locateInternal(p, geom));\n    } else if (geom instanceof MultiLineString) {\n        var ml = geom;\n        for(var i = 0; i < ml.getNumGeometries(); i++){\n            var l = ml.getGeometryN(i);\n            this$1.updateLocationInfo(this$1.locateInternal(p, l));\n        }\n    } else if (geom instanceof MultiPolygon) {\n        var mpoly = geom;\n        for(var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++){\n            var poly = mpoly.getGeometryN(i$1);\n            this$1.updateLocationInfo(this$1.locateInternal(p, poly));\n        }\n    } else if (geom instanceof GeometryCollection) {\n        var geomi = new GeometryCollectionIterator(geom);\n        while(geomi.hasNext()){\n            var g2 = geomi.next();\n            if (g2 !== geom) {\n                this$1.computeLocation(p, g2);\n            }\n        }\n    }\n};\nPointLocator.prototype.locate = function locate(p, geom) {\n    if (geom.isEmpty()) {\n        return Location.EXTERIOR;\n    }\n    if (geom instanceof LineString) {\n        return this.locateInternal(p, geom);\n    } else if (geom instanceof Polygon) {\n        return this.locateInternal(p, geom);\n    }\n    this._isIn = false;\n    this._numBoundaries = 0;\n    this.computeLocation(p, geom);\n    if (this._boundaryRule.isInBoundary(this._numBoundaries)) {\n        return Location.BOUNDARY;\n    }\n    if (this._numBoundaries > 0 || this._isIn) {\n        return Location.INTERIOR;\n    }\n    return Location.EXTERIOR;\n};\nPointLocator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPointLocator.prototype.getClass = function getClass() {\n    return PointLocator;\n};\nvar GeometryLocation = function GeometryLocation() {\n    this._component = null;\n    this._segIndex = null;\n    this._pt = null;\n    if (arguments.length === 2) {\n        var component = arguments[0];\n        var pt = arguments[1];\n        GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n    } else if (arguments.length === 3) {\n        var component$1 = arguments[0];\n        var segIndex = arguments[1];\n        var pt$1 = arguments[2];\n        this._component = component$1;\n        this._segIndex = segIndex;\n        this._pt = pt$1;\n    }\n};\nvar staticAccessors$38 = {\n    INSIDE_AREA: {\n        configurable: true\n    }\n};\nGeometryLocation.prototype.isInsideArea = function isInsideArea() {\n    return this._segIndex === GeometryLocation.INSIDE_AREA;\n};\nGeometryLocation.prototype.getCoordinate = function getCoordinate() {\n    return this._pt;\n};\nGeometryLocation.prototype.getGeometryComponent = function getGeometryComponent() {\n    return this._component;\n};\nGeometryLocation.prototype.getSegmentIndex = function getSegmentIndex() {\n    return this._segIndex;\n};\nGeometryLocation.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryLocation.prototype.getClass = function getClass() {\n    return GeometryLocation;\n};\nstaticAccessors$38.INSIDE_AREA.get = function() {\n    return -1;\n};\nObject.defineProperties(GeometryLocation, staticAccessors$38);\nvar PointExtracter = function PointExtracter(pts) {\n    this._pts = pts || null;\n};\nPointExtracter.prototype.filter = function filter(geom) {\n    if (geom instanceof Point) {\n        this._pts.add(geom);\n    }\n};\nPointExtracter.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryFilter\n    ];\n};\nPointExtracter.prototype.getClass = function getClass() {\n    return PointExtracter;\n};\nPointExtracter.getPoints = function getPoints() {\n    if (arguments.length === 1) {\n        var geom = arguments[0];\n        if (geom instanceof Point) {\n            return Collections.singletonList(geom);\n        }\n        return PointExtracter.getPoints(geom, new ArrayList());\n    } else if (arguments.length === 2) {\n        var geom$1 = arguments[0];\n        var list = arguments[1];\n        if (geom$1 instanceof Point) {\n            list.add(geom$1);\n        } else if (geom$1 instanceof GeometryCollection) {\n            geom$1.apply(new PointExtracter(list));\n        }\n        return list;\n    }\n};\nvar ConnectedElementLocationFilter = function ConnectedElementLocationFilter() {\n    this._locations = null;\n    var locations = arguments[0];\n    this._locations = locations;\n};\nConnectedElementLocationFilter.prototype.filter = function filter(geom) {\n    if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) {\n        this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n    }\n};\nConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryFilter\n    ];\n};\nConnectedElementLocationFilter.prototype.getClass = function getClass() {\n    return ConnectedElementLocationFilter;\n};\nConnectedElementLocationFilter.getLocations = function getLocations(geom) {\n    var locations = new ArrayList();\n    geom.apply(new ConnectedElementLocationFilter(locations));\n    return locations;\n};\nvar DistanceOp = function DistanceOp() {\n    this._geom = null;\n    this._terminateDistance = 0.0;\n    this._ptLocator = new PointLocator();\n    this._minDistanceLocation = null;\n    this._minDistance = Double.MAX_VALUE;\n    if (arguments.length === 2) {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        this._geom = [\n            g0,\n            g1\n        ];\n        this._terminateDistance = 0.0;\n    } else if (arguments.length === 3) {\n        var g0$1 = arguments[0];\n        var g1$1 = arguments[1];\n        var terminateDistance = arguments[2];\n        this._geom = new Array(2).fill(null);\n        this._geom[0] = g0$1;\n        this._geom[1] = g1$1;\n        this._terminateDistance = terminateDistance;\n    }\n};\nDistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        var locPtPoly = new Array(2).fill(null);\n        this.computeContainmentDistance(0, locPtPoly);\n        if (this._minDistance <= this._terminateDistance) {\n            return null;\n        }\n        this.computeContainmentDistance(1, locPtPoly);\n    } else if (arguments.length === 2) {\n        var polyGeomIndex = arguments[0];\n        var locPtPoly$1 = arguments[1];\n        var locationsIndex = 1 - polyGeomIndex;\n        var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n        if (polys.size() > 0) {\n            var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n            this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);\n            if (this._minDistance <= this._terminateDistance) {\n                this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];\n                this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];\n                return null;\n            }\n        }\n    } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n            var locs = arguments[0];\n            var polys$1 = arguments[1];\n            var locPtPoly$2 = arguments[2];\n            for(var i = 0; i < locs.size(); i++){\n                var loc = locs.get(i);\n                for(var j = 0; j < polys$1.size(); j++){\n                    this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);\n                    if (this$1._minDistance <= this$1._terminateDistance) {\n                        return null;\n                    }\n                }\n            }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n            var ptLoc = arguments[0];\n            var poly = arguments[1];\n            var locPtPoly$3 = arguments[2];\n            var pt = ptLoc.getCoordinate();\n            if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n                this._minDistance = 0.0;\n                locPtPoly$3[0] = ptLoc;\n                locPtPoly$3[1] = new GeometryLocation(poly, pt);\n                return null;\n            }\n        }\n    }\n};\nDistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints(lines, points, locGeom) {\n    var this$1 = this;\n    for(var i = 0; i < lines.size(); i++){\n        var line = lines.get(i);\n        for(var j = 0; j < points.size(); j++){\n            var pt = points.get(j);\n            this$1.computeMinDistance(line, pt, locGeom);\n            if (this$1._minDistance <= this$1._terminateDistance) {\n                return null;\n            }\n        }\n    }\n};\nDistanceOp.prototype.computeFacetDistance = function computeFacetDistance() {\n    var locGeom = new Array(2).fill(null);\n    var lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n    var lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n    var pts0 = PointExtracter.getPoints(this._geom[0]);\n    var pts1 = PointExtracter.getPoints(this._geom[1]);\n    this.computeMinDistanceLines(lines0, lines1, locGeom);\n    this.updateMinDistance(locGeom, false);\n    if (this._minDistance <= this._terminateDistance) {\n        return null;\n    }\n    locGeom[0] = null;\n    locGeom[1] = null;\n    this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n    this.updateMinDistance(locGeom, false);\n    if (this._minDistance <= this._terminateDistance) {\n        return null;\n    }\n    locGeom[0] = null;\n    locGeom[1] = null;\n    this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n    this.updateMinDistance(locGeom, true);\n    if (this._minDistance <= this._terminateDistance) {\n        return null;\n    }\n    locGeom[0] = null;\n    locGeom[1] = null;\n    this.computeMinDistancePoints(pts0, pts1, locGeom);\n    this.updateMinDistance(locGeom, false);\n};\nDistanceOp.prototype.nearestLocations = function nearestLocations() {\n    this.computeMinDistance();\n    return this._minDistanceLocation;\n};\nDistanceOp.prototype.updateMinDistance = function updateMinDistance(locGeom, flip) {\n    if (locGeom[0] === null) {\n        return null;\n    }\n    if (flip) {\n        this._minDistanceLocation[0] = locGeom[1];\n        this._minDistanceLocation[1] = locGeom[0];\n    } else {\n        this._minDistanceLocation[0] = locGeom[0];\n        this._minDistanceLocation[1] = locGeom[1];\n    }\n};\nDistanceOp.prototype.nearestPoints = function nearestPoints() {\n    this.computeMinDistance();\n    var nearestPts = [\n        this._minDistanceLocation[0].getCoordinate(),\n        this._minDistanceLocation[1].getCoordinate()\n    ];\n    return nearestPts;\n};\nDistanceOp.prototype.computeMinDistance = function computeMinDistance() {\n    var this$1 = this;\n    if (arguments.length === 0) {\n        if (this._minDistanceLocation !== null) {\n            return null;\n        }\n        this._minDistanceLocation = new Array(2).fill(null);\n        this.computeContainmentDistance();\n        if (this._minDistance <= this._terminateDistance) {\n            return null;\n        }\n        this.computeFacetDistance();\n    } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n            var line = arguments[0];\n            var pt = arguments[1];\n            var locGeom = arguments[2];\n            if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) {\n                return null;\n            }\n            var coord0 = line.getCoordinates();\n            var coord = pt.getCoordinate();\n            for(var i = 0; i < coord0.length - 1; i++){\n                var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n                if (dist < this$1._minDistance) {\n                    this$1._minDistance = dist;\n                    var seg = new LineSegment(coord0[i], coord0[i + 1]);\n                    var segClosestPoint = seg.closestPoint(coord);\n                    locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n                    locGeom[1] = new GeometryLocation(pt, 0, coord);\n                }\n                if (this$1._minDistance <= this$1._terminateDistance) {\n                    return null;\n                }\n            }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n            var line0 = arguments[0];\n            var line1 = arguments[1];\n            var locGeom$1 = arguments[2];\n            if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) {\n                return null;\n            }\n            var coord0$1 = line0.getCoordinates();\n            var coord1 = line1.getCoordinates();\n            for(var i$1 = 0; i$1 < coord0$1.length - 1; i$1++){\n                for(var j = 0; j < coord1.length - 1; j++){\n                    var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);\n                    if (dist$1 < this$1._minDistance) {\n                        this$1._minDistance = dist$1;\n                        var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);\n                        var seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n                        var closestPt = seg0.closestPoints(seg1);\n                        locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);\n                        locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);\n                    }\n                    if (this$1._minDistance <= this$1._terminateDistance) {\n                        return null;\n                    }\n                }\n            }\n        }\n    }\n};\nDistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints(points0, points1, locGeom) {\n    var this$1 = this;\n    for(var i = 0; i < points0.size(); i++){\n        var pt0 = points0.get(i);\n        for(var j = 0; j < points1.size(); j++){\n            var pt1 = points1.get(j);\n            var dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n            if (dist < this$1._minDistance) {\n                this$1._minDistance = dist;\n                locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n                locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n            }\n            if (this$1._minDistance <= this$1._terminateDistance) {\n                return null;\n            }\n        }\n    }\n};\nDistanceOp.prototype.distance = function distance() {\n    if (this._geom[0] === null || this._geom[1] === null) {\n        throw new IllegalArgumentException(\"null geometries are not supported\");\n    }\n    if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) {\n        return 0.0;\n    }\n    this.computeMinDistance();\n    return this._minDistance;\n};\nDistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines(lines0, lines1, locGeom) {\n    var this$1 = this;\n    for(var i = 0; i < lines0.size(); i++){\n        var line0 = lines0.get(i);\n        for(var j = 0; j < lines1.size(); j++){\n            var line1 = lines1.get(j);\n            this$1.computeMinDistance(line0, line1, locGeom);\n            if (this$1._minDistance <= this$1._terminateDistance) {\n                return null;\n            }\n        }\n    }\n};\nDistanceOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDistanceOp.prototype.getClass = function getClass() {\n    return DistanceOp;\n};\nDistanceOp.distance = function distance(g0, g1) {\n    var distOp = new DistanceOp(g0, g1);\n    return distOp.distance();\n};\nDistanceOp.isWithinDistance = function isWithinDistance(g0, g1, distance) {\n    var distOp = new DistanceOp(g0, g1, distance);\n    return distOp.distance() <= distance;\n};\nDistanceOp.nearestPoints = function nearestPoints(g0, g1) {\n    var distOp = new DistanceOp(g0, g1);\n    return distOp.nearestPoints();\n};\nvar PointPairDistance$2 = function PointPairDistance() {\n    this._pt = [\n        new Coordinate(),\n        new Coordinate()\n    ];\n    this._distance = Double.NaN;\n    this._isNull = true;\n};\nPointPairDistance$2.prototype.getCoordinates = function getCoordinates() {\n    return this._pt;\n};\nPointPairDistance$2.prototype.getCoordinate = function getCoordinate(i) {\n    return this._pt[i];\n};\nPointPairDistance$2.prototype.setMinimum = function setMinimum() {\n    if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        if (this._isNull) {\n            this.initialize(p0, p1);\n            return null;\n        }\n        var dist = p0.distance(p1);\n        if (dist < this._distance) {\n            this.initialize(p0, p1, dist);\n        }\n    }\n};\nPointPairDistance$2.prototype.initialize = function initialize() {\n    if (arguments.length === 0) {\n        this._isNull = true;\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        this._pt[0].setCoordinate(p0);\n        this._pt[1].setCoordinate(p1);\n        this._distance = p0.distance(p1);\n        this._isNull = false;\n    } else if (arguments.length === 3) {\n        var p0$1 = arguments[0];\n        var p1$1 = arguments[1];\n        var distance = arguments[2];\n        this._pt[0].setCoordinate(p0$1);\n        this._pt[1].setCoordinate(p1$1);\n        this._distance = distance;\n        this._isNull = false;\n    }\n};\nPointPairDistance$2.prototype.toString = function toString() {\n    return WKTWriter.toLineString(this._pt[0], this._pt[1]);\n};\nPointPairDistance$2.prototype.getDistance = function getDistance() {\n    return this._distance;\n};\nPointPairDistance$2.prototype.setMaximum = function setMaximum() {\n    if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n    } else if (arguments.length === 2) {\n        var p0 = arguments[0];\n        var p1 = arguments[1];\n        if (this._isNull) {\n            this.initialize(p0, p1);\n            return null;\n        }\n        var dist = p0.distance(p1);\n        if (dist > this._distance) {\n            this.initialize(p0, p1, dist);\n        }\n    }\n};\nPointPairDistance$2.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPointPairDistance$2.prototype.getClass = function getClass() {\n    return PointPairDistance$2;\n};\nvar DistanceToPoint = function DistanceToPoint() {};\nDistanceToPoint.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDistanceToPoint.prototype.getClass = function getClass() {\n    return DistanceToPoint;\n};\nDistanceToPoint.computeDistance = function computeDistance() {\n    if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {\n        var line = arguments[0];\n        var pt = arguments[1];\n        var ptDist = arguments[2];\n        var tempSegment = new LineSegment();\n        var coords = line.getCoordinates();\n        for(var i = 0; i < coords.length - 1; i++){\n            tempSegment.setCoordinates(coords[i], coords[i + 1]);\n            var closestPt = tempSegment.closestPoint(pt);\n            ptDist.setMinimum(closestPt, pt);\n        }\n    } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {\n        var poly = arguments[0];\n        var pt$1 = arguments[1];\n        var ptDist$1 = arguments[2];\n        DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n        for(var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++){\n            DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n        }\n    } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {\n        var geom = arguments[0];\n        var pt$2 = arguments[1];\n        var ptDist$2 = arguments[2];\n        if (geom instanceof LineString) {\n            DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n        } else if (geom instanceof Polygon) {\n            DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n        } else if (geom instanceof GeometryCollection) {\n            var gc = geom;\n            for(var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++){\n                var g = gc.getGeometryN(i$2);\n                DistanceToPoint.computeDistance(g, pt$2, ptDist$2);\n            }\n        } else {\n            ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n        }\n    } else if (arguments[2] instanceof PointPairDistance$2 && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {\n        var segment = arguments[0];\n        var pt$3 = arguments[1];\n        var ptDist$3 = arguments[2];\n        var closestPt$1 = segment.closestPoint(pt$3);\n        ptDist$3.setMinimum(closestPt$1, pt$3);\n    }\n};\nvar DiscreteHausdorffDistance = function DiscreteHausdorffDistance() {\n    this._g0 = null;\n    this._g1 = null;\n    this._ptDist = new PointPairDistance$2();\n    this._densifyFrac = 0.0;\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    this._g0 = g0;\n    this._g1 = g1;\n};\nvar staticAccessors$39 = {\n    MaxPointDistanceFilter: {\n        configurable: true\n    },\n    MaxDensifiedByFractionDistanceFilter: {\n        configurable: true\n    }\n};\nDiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates() {\n    return this._ptDist.getCoordinates();\n};\nDiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction(densifyFrac) {\n    if (densifyFrac > 1.0 || densifyFrac <= 0.0) {\n        throw new IllegalArgumentException(\"Fraction is not in range (0.0 - 1.0]\");\n    }\n    this._densifyFrac = densifyFrac;\n};\nDiscreteHausdorffDistance.prototype.compute = function compute(g0, g1) {\n    this.computeOrientedDistance(g0, g1, this._ptDist);\n    this.computeOrientedDistance(g1, g0, this._ptDist);\n};\nDiscreteHausdorffDistance.prototype.distance = function distance() {\n    this.compute(this._g0, this._g1);\n    return this._ptDist.getDistance();\n};\nDiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance(discreteGeom, geom, ptDist) {\n    var distFilter = new MaxPointDistanceFilter$1(geom);\n    discreteGeom.apply(distFilter);\n    ptDist.setMaximum(distFilter.getMaxPointDistance());\n    if (this._densifyFrac > 0) {\n        var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n        discreteGeom.apply(fracFilter);\n        ptDist.setMaximum(fracFilter.getMaxPointDistance());\n    }\n};\nDiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance() {\n    this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n    return this._ptDist.getDistance();\n};\nDiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nDiscreteHausdorffDistance.prototype.getClass = function getClass() {\n    return DiscreteHausdorffDistance;\n};\nDiscreteHausdorffDistance.distance = function distance() {\n    if (arguments.length === 2) {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        var dist = new DiscreteHausdorffDistance(g0, g1);\n        return dist.distance();\n    } else if (arguments.length === 3) {\n        var g0$1 = arguments[0];\n        var g1$1 = arguments[1];\n        var densifyFrac = arguments[2];\n        var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);\n        dist$1.setDensifyFraction(densifyFrac);\n        return dist$1.distance();\n    }\n};\nstaticAccessors$39.MaxPointDistanceFilter.get = function() {\n    return MaxPointDistanceFilter$1;\n};\nstaticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function() {\n    return MaxDensifiedByFractionDistanceFilter;\n};\nObject.defineProperties(DiscreteHausdorffDistance, staticAccessors$39);\nvar MaxPointDistanceFilter$1 = function MaxPointDistanceFilter() {\n    this._maxPtDist = new PointPairDistance$2();\n    this._minPtDist = new PointPairDistance$2();\n    this._euclideanDist = new DistanceToPoint();\n    this._geom = null;\n    var geom = arguments[0];\n    this._geom = geom;\n};\nMaxPointDistanceFilter$1.prototype.filter = function filter(pt) {\n    this._minPtDist.initialize();\n    DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n    this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance() {\n    return this._maxPtDist;\n};\nMaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateFilter\n    ];\n};\nMaxPointDistanceFilter$1.prototype.getClass = function getClass() {\n    return MaxPointDistanceFilter$1;\n};\nvar MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter() {\n    this._maxPtDist = new PointPairDistance$2();\n    this._minPtDist = new PointPairDistance$2();\n    this._geom = null;\n    this._numSubSegs = 0;\n    var geom = arguments[0];\n    var fraction = arguments[1];\n    this._geom = geom;\n    this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n};\nMaxDensifiedByFractionDistanceFilter.prototype.filter = function filter(seq, index) {\n    var this$1 = this;\n    if (index === 0) {\n        return null;\n    }\n    var p0 = seq.getCoordinate(index - 1);\n    var p1 = seq.getCoordinate(index);\n    var delx = (p1.x - p0.x) / this._numSubSegs;\n    var dely = (p1.y - p0.y) / this._numSubSegs;\n    for(var i = 0; i < this._numSubSegs; i++){\n        var x = p0.x + i * delx;\n        var y = p0.y + i * dely;\n        var pt = new Coordinate(x, y);\n        this$1._minPtDist.initialize();\n        DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);\n        this$1._maxPtDist.setMaximum(this$1._minPtDist);\n    }\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone() {\n    return false;\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged() {\n    return false;\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance() {\n    return this._maxPtDist;\n};\nMaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateSequenceFilter\n    ];\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass() {\n    return MaxDensifiedByFractionDistanceFilter;\n};\nvar BufferDistanceValidator = function BufferDistanceValidator(input, bufDistance, result) {\n    this._minValidDistance = null;\n    this._maxValidDistance = null;\n    this._minDistanceFound = null;\n    this._maxDistanceFound = null;\n    this._isValid = true;\n    this._errMsg = null;\n    this._errorLocation = null;\n    this._errorIndicator = null;\n    this._input = input || null;\n    this._bufDistance = bufDistance || null;\n    this._result = result || null;\n};\nvar staticAccessors$37 = {\n    VERBOSE: {\n        configurable: true\n    },\n    MAX_DISTANCE_DIFF_FRAC: {\n        configurable: true\n    }\n};\nBufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance(input, bufCurve, maxDist) {\n    var haus = new DiscreteHausdorffDistance(bufCurve, input);\n    haus.setDensifyFraction(0.25);\n    this._maxDistanceFound = haus.orientedDistance();\n    if (this._maxDistanceFound > maxDist) {\n        this._isValid = false;\n        var pts = haus.getCoordinates();\n        this._errorLocation = pts[1];\n        this._errorIndicator = input.getFactory().createLineString(pts);\n        this._errMsg = \"Distance between buffer curve and input is too large (\" + this._maxDistanceFound + \" at \" + WKTWriter.toLineString(pts[0], pts[1]) + \")\";\n    }\n};\nBufferDistanceValidator.prototype.isValid = function isValid() {\n    var posDistance = Math.abs(this._bufDistance);\n    var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;\n    this._minValidDistance = posDistance - distDelta;\n    this._maxValidDistance = posDistance + distDelta;\n    if (this._input.isEmpty() || this._result.isEmpty()) {\n        return true;\n    }\n    if (this._bufDistance > 0.0) {\n        this.checkPositiveValid();\n    } else {\n        this.checkNegativeValid();\n    }\n    if (BufferDistanceValidator.VERBOSE) {\n        System.out.println(\"Min Dist= \" + this._minDistanceFound + \"  err= \" + (1.0 - this._minDistanceFound / this._bufDistance) + \"  Max Dist= \" + this._maxDistanceFound + \"  err= \" + (this._maxDistanceFound / this._bufDistance - 1.0));\n    }\n    return this._isValid;\n};\nBufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid() {\n    if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {\n        return null;\n    }\n    var inputCurve = this.getPolygonLines(this._input);\n    this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);\n    if (!this._isValid) {\n        return null;\n    }\n    this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator() {\n    return this._errorIndicator;\n};\nBufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance(g1, g2, minDist) {\n    var distOp = new DistanceOp(g1, g2, minDist);\n    this._minDistanceFound = distOp.distance();\n    if (this._minDistanceFound < minDist) {\n        this._isValid = false;\n        var pts = distOp.nearestPoints();\n        this._errorLocation = distOp.nearestPoints()[1];\n        this._errorIndicator = g1.getFactory().createLineString(pts);\n        this._errMsg = \"Distance between buffer curve and input is too small (\" + this._minDistanceFound + \" at \" + WKTWriter.toLineString(pts[0], pts[1]) + \" )\";\n    }\n};\nBufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid() {\n    var bufCurve = this._result.getBoundary();\n    this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);\n    if (!this._isValid) {\n        return null;\n    }\n    this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation() {\n    return this._errorLocation;\n};\nBufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines(g) {\n    var lines = new ArrayList();\n    var lineExtracter = new LinearComponentExtracter(lines);\n    var polys = PolygonExtracter.getPolygons(g);\n    for(var i = polys.iterator(); i.hasNext();){\n        var poly = i.next();\n        poly.apply(lineExtracter);\n    }\n    return g.getFactory().buildGeometry(lines);\n};\nBufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage() {\n    return this._errMsg;\n};\nBufferDistanceValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferDistanceValidator.prototype.getClass = function getClass() {\n    return BufferDistanceValidator;\n};\nstaticAccessors$37.VERBOSE.get = function() {\n    return false;\n};\nstaticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function() {\n    return 0.012;\n};\nObject.defineProperties(BufferDistanceValidator, staticAccessors$37);\nvar BufferResultValidator = function BufferResultValidator(input, distance, result) {\n    this._isValid = true;\n    this._errorMsg = null;\n    this._errorLocation = null;\n    this._errorIndicator = null;\n    this._input = input || null;\n    this._distance = distance || null;\n    this._result = result || null;\n};\nvar staticAccessors$40 = {\n    VERBOSE: {\n        configurable: true\n    },\n    MAX_ENV_DIFF_FRAC: {\n        configurable: true\n    }\n};\nBufferResultValidator.prototype.isValid = function isValid() {\n    this.checkPolygonal();\n    if (!this._isValid) {\n        return this._isValid;\n    }\n    this.checkExpectedEmpty();\n    if (!this._isValid) {\n        return this._isValid;\n    }\n    this.checkEnvelope();\n    if (!this._isValid) {\n        return this._isValid;\n    }\n    this.checkArea();\n    if (!this._isValid) {\n        return this._isValid;\n    }\n    this.checkDistance();\n    return this._isValid;\n};\nBufferResultValidator.prototype.checkEnvelope = function checkEnvelope() {\n    if (this._distance < 0.0) {\n        return null;\n    }\n    var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;\n    if (padding === 0.0) {\n        padding = 0.001;\n    }\n    var expectedEnv = new Envelope(this._input.getEnvelopeInternal());\n    expectedEnv.expandBy(this._distance);\n    var bufEnv = new Envelope(this._result.getEnvelopeInternal());\n    bufEnv.expandBy(padding);\n    if (!bufEnv.contains(expectedEnv)) {\n        this._isValid = false;\n        this._errorMsg = \"Buffer envelope is incorrect\";\n        this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);\n    }\n    this.report(\"Envelope\");\n};\nBufferResultValidator.prototype.checkDistance = function checkDistance() {\n    var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);\n    if (!distValid.isValid()) {\n        this._isValid = false;\n        this._errorMsg = distValid.getErrorMessage();\n        this._errorLocation = distValid.getErrorLocation();\n        this._errorIndicator = distValid.getErrorIndicator();\n    }\n    this.report(\"Distance\");\n};\nBufferResultValidator.prototype.checkArea = function checkArea() {\n    var inputArea = this._input.getArea();\n    var resultArea = this._result.getArea();\n    if (this._distance > 0.0 && inputArea > resultArea) {\n        this._isValid = false;\n        this._errorMsg = \"Area of positive buffer is smaller than input\";\n        this._errorIndicator = this._result;\n    }\n    if (this._distance < 0.0 && inputArea < resultArea) {\n        this._isValid = false;\n        this._errorMsg = \"Area of negative buffer is larger than input\";\n        this._errorIndicator = this._result;\n    }\n    this.report(\"Area\");\n};\nBufferResultValidator.prototype.checkPolygonal = function checkPolygonal() {\n    if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) {\n        this._isValid = false;\n    }\n    this._errorMsg = \"Result is not polygonal\";\n    this._errorIndicator = this._result;\n    this.report(\"Polygonal\");\n};\nBufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator() {\n    return this._errorIndicator;\n};\nBufferResultValidator.prototype.getErrorLocation = function getErrorLocation() {\n    return this._errorLocation;\n};\nBufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty() {\n    if (this._input.getDimension() >= 2) {\n        return null;\n    }\n    if (this._distance > 0.0) {\n        return null;\n    }\n    if (!this._result.isEmpty()) {\n        this._isValid = false;\n        this._errorMsg = \"Result is non-empty\";\n        this._errorIndicator = this._result;\n    }\n    this.report(\"ExpectedEmpty\");\n};\nBufferResultValidator.prototype.report = function report(checkName) {\n    if (!BufferResultValidator.VERBOSE) {\n        return null;\n    }\n    System.out.println(\"Check \" + checkName + \": \" + (this._isValid ? \"passed\" : \"FAILED\"));\n};\nBufferResultValidator.prototype.getErrorMessage = function getErrorMessage() {\n    return this._errorMsg;\n};\nBufferResultValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nBufferResultValidator.prototype.getClass = function getClass() {\n    return BufferResultValidator;\n};\nBufferResultValidator.isValidMsg = function isValidMsg(g, distance, result) {\n    var validator = new BufferResultValidator(g, distance, result);\n    if (!validator.isValid()) {\n        return validator.getErrorMessage();\n    }\n    return null;\n};\nBufferResultValidator.isValid = function isValid(g, distance, result) {\n    var validator = new BufferResultValidator(g, distance, result);\n    if (validator.isValid()) {\n        return true;\n    }\n    return false;\n};\nstaticAccessors$40.VERBOSE.get = function() {\n    return false;\n};\nstaticAccessors$40.MAX_ENV_DIFF_FRAC.get = function() {\n    return 0.012;\n};\nObject.defineProperties(BufferResultValidator, staticAccessors$40);\n// operation.buffer\nvar BasicSegmentString = function BasicSegmentString() {\n    this._pts = null;\n    this._data = null;\n    var pts = arguments[0];\n    var data = arguments[1];\n    this._pts = pts;\n    this._data = data;\n};\nBasicSegmentString.prototype.getCoordinates = function getCoordinates() {\n    return this._pts;\n};\nBasicSegmentString.prototype.size = function size() {\n    return this._pts.length;\n};\nBasicSegmentString.prototype.getCoordinate = function getCoordinate(i) {\n    return this._pts[i];\n};\nBasicSegmentString.prototype.isClosed = function isClosed() {\n    return this._pts[0].equals(this._pts[this._pts.length - 1]);\n};\nBasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant(index) {\n    if (index === this._pts.length - 1) {\n        return -1;\n    }\n    return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n};\nBasicSegmentString.prototype.setData = function setData(data) {\n    this._data = data;\n};\nBasicSegmentString.prototype.getData = function getData() {\n    return this._data;\n};\nBasicSegmentString.prototype.toString = function toString() {\n    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n};\nBasicSegmentString.prototype.interfaces_ = function interfaces_() {\n    return [\n        SegmentString\n    ];\n};\nBasicSegmentString.prototype.getClass = function getClass() {\n    return BasicSegmentString;\n};\nvar InteriorIntersectionFinder = function InteriorIntersectionFinder() {\n    this._findAllIntersections = false;\n    this._isCheckEndSegmentsOnly = false;\n    this._li = null;\n    this._interiorIntersection = null;\n    this._intSegments = null;\n    this._intersections = new ArrayList();\n    this._intersectionCount = 0;\n    this._keepIntersections = true;\n    var li = arguments[0];\n    this._li = li;\n    this._interiorIntersection = null;\n};\nInteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection() {\n    return this._interiorIntersection;\n};\nInteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n    this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n};\nInteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments() {\n    return this._intSegments;\n};\nInteriorIntersectionFinder.prototype.count = function count() {\n    return this._intersectionCount;\n};\nInteriorIntersectionFinder.prototype.getIntersections = function getIntersections() {\n    return this._intersections;\n};\nInteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {\n    this._findAllIntersections = findAllIntersections;\n};\nInteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections(keepIntersections) {\n    this._keepIntersections = keepIntersections;\n};\nInteriorIntersectionFinder.prototype.processIntersections = function processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (!this._findAllIntersections && this.hasIntersection()) {\n        return null;\n    }\n    if (e0 === e1 && segIndex0 === segIndex1) {\n        return null;\n    }\n    if (this._isCheckEndSegmentsOnly) {\n        var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n        if (!isEndSegPresent) {\n            return null;\n        }\n    }\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n        if (this._li.isInteriorIntersection()) {\n            this._intSegments = new Array(4).fill(null);\n            this._intSegments[0] = p00;\n            this._intSegments[1] = p01;\n            this._intSegments[2] = p10;\n            this._intSegments[3] = p11;\n            this._interiorIntersection = this._li.getIntersection(0);\n            if (this._keepIntersections) {\n                this._intersections.add(this._interiorIntersection);\n            }\n            this._intersectionCount++;\n        }\n    }\n};\nInteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment(segStr, index) {\n    if (index === 0) {\n        return true;\n    }\n    if (index >= segStr.size() - 2) {\n        return true;\n    }\n    return false;\n};\nInteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection() {\n    return this._interiorIntersection !== null;\n};\nInteriorIntersectionFinder.prototype.isDone = function isDone() {\n    if (this._findAllIntersections) {\n        return false;\n    }\n    return this._interiorIntersection !== null;\n};\nInteriorIntersectionFinder.prototype.interfaces_ = function interfaces_() {\n    return [\n        SegmentIntersector\n    ];\n};\nInteriorIntersectionFinder.prototype.getClass = function getClass() {\n    return InteriorIntersectionFinder;\n};\nInteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder(li) {\n    var finder = new InteriorIntersectionFinder(li);\n    finder.setFindAllIntersections(true);\n    return finder;\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder(li) {\n    return new InteriorIntersectionFinder(li);\n};\nInteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter(li) {\n    var finder = new InteriorIntersectionFinder(li);\n    finder.setFindAllIntersections(true);\n    finder.setKeepIntersections(false);\n    return finder;\n};\nvar FastNodingValidator = function FastNodingValidator() {\n    this._li = new RobustLineIntersector();\n    this._segStrings = null;\n    this._findAllIntersections = false;\n    this._segInt = null;\n    this._isValid = true;\n    var segStrings = arguments[0];\n    this._segStrings = segStrings;\n};\nFastNodingValidator.prototype.execute = function execute() {\n    if (this._segInt !== null) {\n        return null;\n    }\n    this.checkInteriorIntersections();\n};\nFastNodingValidator.prototype.getIntersections = function getIntersections() {\n    return this._segInt.getIntersections();\n};\nFastNodingValidator.prototype.isValid = function isValid() {\n    this.execute();\n    return this._isValid;\n};\nFastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections(findAllIntersections) {\n    this._findAllIntersections = findAllIntersections;\n};\nFastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections() {\n    this._isValid = true;\n    this._segInt = new InteriorIntersectionFinder(this._li);\n    this._segInt.setFindAllIntersections(this._findAllIntersections);\n    var noder = new MCIndexNoder();\n    noder.setSegmentIntersector(this._segInt);\n    noder.computeNodes(this._segStrings);\n    if (this._segInt.hasIntersection()) {\n        this._isValid = false;\n        return null;\n    }\n};\nFastNodingValidator.prototype.checkValid = function checkValid() {\n    this.execute();\n    if (!this._isValid) {\n        throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n    }\n};\nFastNodingValidator.prototype.getErrorMessage = function getErrorMessage() {\n    if (this._isValid) {\n        return \"no intersections found\";\n    }\n    var intSegs = this._segInt.getIntersectionSegments();\n    return \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n};\nFastNodingValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nFastNodingValidator.prototype.getClass = function getClass() {\n    return FastNodingValidator;\n};\nFastNodingValidator.computeIntersections = function computeIntersections(segStrings) {\n    var nv = new FastNodingValidator(segStrings);\n    nv.setFindAllIntersections(true);\n    nv.isValid();\n    return nv.getIntersections();\n};\nvar EdgeNodingValidator = function EdgeNodingValidator() {\n    this._nv = null;\n    var edges = arguments[0];\n    this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n};\nEdgeNodingValidator.prototype.checkValid = function checkValid() {\n    this._nv.checkValid();\n};\nEdgeNodingValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeNodingValidator.prototype.getClass = function getClass() {\n    return EdgeNodingValidator;\n};\nEdgeNodingValidator.toSegmentStrings = function toSegmentStrings(edges) {\n    var segStrings = new ArrayList();\n    for(var i = edges.iterator(); i.hasNext();){\n        var e = i.next();\n        segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n    }\n    return segStrings;\n};\nEdgeNodingValidator.checkValid = function checkValid(edges) {\n    var validator = new EdgeNodingValidator(edges);\n    validator.checkValid();\n};\nvar GeometryCollectionMapper = function GeometryCollectionMapper(mapOp) {\n    this._mapOp = mapOp;\n};\nGeometryCollectionMapper.prototype.map = function map(gc) {\n    var this$1 = this;\n    var mapped = new ArrayList();\n    for(var i = 0; i < gc.getNumGeometries(); i++){\n        var g = this$1._mapOp.map(gc.getGeometryN(i));\n        if (!g.isEmpty()) {\n            mapped.add(g);\n        }\n    }\n    return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n};\nGeometryCollectionMapper.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryCollectionMapper.prototype.getClass = function getClass() {\n    return GeometryCollectionMapper;\n};\nGeometryCollectionMapper.map = function map(gc, op) {\n    var mapper = new GeometryCollectionMapper(op);\n    return mapper.map(gc);\n};\nvar LineBuilder = function LineBuilder() {\n    this._op = null;\n    this._geometryFactory = null;\n    this._ptLocator = null;\n    this._lineEdgesList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    var op = arguments[0];\n    var geometryFactory = arguments[1];\n    var ptLocator = arguments[2];\n    this._op = op;\n    this._geometryFactory = geometryFactory;\n    this._ptLocator = ptLocator;\n};\nLineBuilder.prototype.collectLines = function collectLines(opCode) {\n    var this$1 = this;\n    for(var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){\n        var de = it.next();\n        this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);\n        this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);\n    }\n};\nLineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine(e, targetIndex) {\n    var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n    e.getLabel().setLocation(targetIndex, loc);\n};\nLineBuilder.prototype.build = function build(opCode) {\n    this.findCoveredLineEdges();\n    this.collectLines(opCode);\n    this.buildLines(opCode);\n    return this._resultLineList;\n};\nLineBuilder.prototype.collectLineEdge = function collectLineEdge(de, opCode, edges) {\n    var label = de.getLabel();\n    var e = de.getEdge();\n    if (de.isLineEdge()) {\n        if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n            edges.add(e);\n            de.setVisitedEdge(true);\n        }\n    }\n};\nLineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges() {\n    var this$1 = this;\n    for(var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){\n        var node = nodeit.next();\n        node.getEdges().findCoveredLineEdges();\n    }\n    for(var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){\n        var de = it.next();\n        var e = de.getEdge();\n        if (de.isLineEdge() && !e.isCoveredSet()) {\n            var isCovered = this$1._op.isCoveredByA(de.getCoordinate());\n            e.setCovered(isCovered);\n        }\n    }\n};\nLineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines(edgesList) {\n    var this$1 = this;\n    for(var it = edgesList.iterator(); it.hasNext();){\n        var e = it.next();\n        var label = e.getLabel();\n        if (e.isIsolated()) {\n            if (label.isNull(0)) {\n                this$1.labelIsolatedLine(e, 0);\n            } else {\n                this$1.labelIsolatedLine(e, 1);\n            }\n        }\n    }\n};\nLineBuilder.prototype.buildLines = function buildLines(opCode) {\n    var this$1 = this;\n    for(var it = this._lineEdgesList.iterator(); it.hasNext();){\n        var e = it.next();\n        // const label = e.getLabel()\n        var line = this$1._geometryFactory.createLineString(e.getCoordinates());\n        this$1._resultLineList.add(line);\n        e.setInResult(true);\n    }\n};\nLineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge(de, opCode, edges) {\n    var label = de.getLabel();\n    if (de.isLineEdge()) {\n        return null;\n    }\n    if (de.isVisited()) {\n        return null;\n    }\n    if (de.isInteriorAreaEdge()) {\n        return null;\n    }\n    if (de.getEdge().isInResult()) {\n        return null;\n    }\n    Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n    if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n        edges.add(de.getEdge());\n        de.setVisitedEdge(true);\n    }\n};\nLineBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLineBuilder.prototype.getClass = function getClass() {\n    return LineBuilder;\n};\nvar PointBuilder = function PointBuilder() {\n    this._op = null;\n    this._geometryFactory = null;\n    this._resultPointList = new ArrayList();\n    var op = arguments[0];\n    var geometryFactory = arguments[1];\n    // const ptLocator = arguments[2]\n    this._op = op;\n    this._geometryFactory = geometryFactory;\n};\nPointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint(n) {\n    var coord = n.getCoordinate();\n    if (!this._op.isCoveredByLA(coord)) {\n        var pt = this._geometryFactory.createPoint(coord);\n        this._resultPointList.add(pt);\n    }\n};\nPointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes(opCode) {\n    var this$1 = this;\n    for(var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){\n        var n = nodeit.next();\n        if (n.isInResult()) {\n            continue;\n        }\n        if (n.isIncidentEdgeInResult()) {\n            continue;\n        }\n        if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n            var label = n.getLabel();\n            if (OverlayOp.isResultOfOp(label, opCode)) {\n                this$1.filterCoveredNodeToPoint(n);\n            }\n        }\n    }\n};\nPointBuilder.prototype.build = function build(opCode) {\n    this.extractNonCoveredResultNodes(opCode);\n    return this._resultPointList;\n};\nPointBuilder.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nPointBuilder.prototype.getClass = function getClass() {\n    return PointBuilder;\n};\nvar GeometryTransformer = function GeometryTransformer() {\n    this._inputGeom = null;\n    this._factory = null;\n    this._pruneEmptyGeometry = true;\n    this._preserveGeometryCollectionType = true;\n    this._preserveCollections = false;\n    this._preserveType = false;\n};\nGeometryTransformer.prototype.transformPoint = function transformPoint(geom, parent) {\n    return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n};\nGeometryTransformer.prototype.transformPolygon = function transformPolygon(geom, parent) {\n    var this$1 = this;\n    var isAllValidLinearRings = true;\n    var shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n    if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) {\n        isAllValidLinearRings = false;\n    }\n    var holes = new ArrayList();\n    for(var i = 0; i < geom.getNumInteriorRing(); i++){\n        var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);\n        if (hole === null || hole.isEmpty()) {\n            continue;\n        }\n        if (!(hole instanceof LinearRing)) {\n            isAllValidLinearRings = false;\n        }\n        holes.add(hole);\n    }\n    if (isAllValidLinearRings) {\n        return this._factory.createPolygon(shell, holes.toArray([]));\n    } else {\n        var components = new ArrayList();\n        if (shell !== null) {\n            components.add(shell);\n        }\n        components.addAll(holes);\n        return this._factory.buildGeometry(components);\n    }\n};\nGeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence(coords) {\n    return this._factory.getCoordinateSequenceFactory().create(coords);\n};\nGeometryTransformer.prototype.getInputGeometry = function getInputGeometry() {\n    return this._inputGeom;\n};\nGeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString(geom, parent) {\n    var this$1 = this;\n    var transGeomList = new ArrayList();\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);\n        if (transformGeom === null) {\n            continue;\n        }\n        if (transformGeom.isEmpty()) {\n            continue;\n        }\n        transGeomList.add(transformGeom);\n    }\n    return this._factory.buildGeometry(transGeomList);\n};\nGeometryTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {\n    return this.copy(coords);\n};\nGeometryTransformer.prototype.transformLineString = function transformLineString(geom, parent) {\n    return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n};\nGeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint(geom, parent) {\n    var this$1 = this;\n    var transGeomList = new ArrayList();\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);\n        if (transformGeom === null) {\n            continue;\n        }\n        if (transformGeom.isEmpty()) {\n            continue;\n        }\n        transGeomList.add(transformGeom);\n    }\n    return this._factory.buildGeometry(transGeomList);\n};\nGeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon(geom, parent) {\n    var this$1 = this;\n    var transGeomList = new ArrayList();\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);\n        if (transformGeom === null) {\n            continue;\n        }\n        if (transformGeom.isEmpty()) {\n            continue;\n        }\n        transGeomList.add(transformGeom);\n    }\n    return this._factory.buildGeometry(transGeomList);\n};\nGeometryTransformer.prototype.copy = function copy(seq) {\n    return seq.copy();\n};\nGeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection(geom, parent) {\n    var this$1 = this;\n    var transGeomList = new ArrayList();\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var transformGeom = this$1.transform(geom.getGeometryN(i));\n        if (transformGeom === null) {\n            continue;\n        }\n        if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) {\n            continue;\n        }\n        transGeomList.add(transformGeom);\n    }\n    if (this._preserveGeometryCollectionType) {\n        return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n    }\n    return this._factory.buildGeometry(transGeomList);\n};\nGeometryTransformer.prototype.transform = function transform(inputGeom) {\n    this._inputGeom = inputGeom;\n    this._factory = inputGeom.getFactory();\n    if (inputGeom instanceof Point) {\n        return this.transformPoint(inputGeom, null);\n    }\n    if (inputGeom instanceof MultiPoint) {\n        return this.transformMultiPoint(inputGeom, null);\n    }\n    if (inputGeom instanceof LinearRing) {\n        return this.transformLinearRing(inputGeom, null);\n    }\n    if (inputGeom instanceof LineString) {\n        return this.transformLineString(inputGeom, null);\n    }\n    if (inputGeom instanceof MultiLineString) {\n        return this.transformMultiLineString(inputGeom, null);\n    }\n    if (inputGeom instanceof Polygon) {\n        return this.transformPolygon(inputGeom, null);\n    }\n    if (inputGeom instanceof MultiPolygon) {\n        return this.transformMultiPolygon(inputGeom, null);\n    }\n    if (inputGeom instanceof GeometryCollection) {\n        return this.transformGeometryCollection(inputGeom, null);\n    }\n    throw new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n};\nGeometryTransformer.prototype.transformLinearRing = function transformLinearRing(geom, parent) {\n    var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n    if (seq === null) {\n        return this._factory.createLinearRing(null);\n    }\n    var seqSize = seq.size();\n    if (seqSize > 0 && seqSize < 4 && !this._preserveType) {\n        return this._factory.createLineString(seq);\n    }\n    return this._factory.createLinearRing(seq);\n};\nGeometryTransformer.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryTransformer.prototype.getClass = function getClass() {\n    return GeometryTransformer;\n};\nvar LineStringSnapper = function LineStringSnapper() {\n    this._snapTolerance = 0.0;\n    this._srcPts = null;\n    this._seg = new LineSegment();\n    this._allowSnappingToSourceVertices = false;\n    this._isClosed = false;\n    if (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n        var srcLine = arguments[0];\n        var snapTolerance = arguments[1];\n        LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n    } else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n        var srcPts = arguments[0];\n        var snapTolerance$1 = arguments[1];\n        this._srcPts = srcPts;\n        this._isClosed = LineStringSnapper.isClosed(srcPts);\n        this._snapTolerance = snapTolerance$1;\n    }\n};\nLineStringSnapper.prototype.snapVertices = function snapVertices(srcCoords, snapPts) {\n    var this$1 = this;\n    var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n    for(var i = 0; i < end; i++){\n        var srcPt = srcCoords.get(i);\n        var snapVert = this$1.findSnapForVertex(srcPt, snapPts);\n        if (snapVert !== null) {\n            srcCoords.set(i, new Coordinate(snapVert));\n            if (i === 0 && this$1._isClosed) {\n                srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n            }\n        }\n    }\n};\nLineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex(pt, snapPts) {\n    var this$1 = this;\n    for(var i = 0; i < snapPts.length; i++){\n        if (pt.equals2D(snapPts[i])) {\n            return null;\n        }\n        if (pt.distance(snapPts[i]) < this$1._snapTolerance) {\n            return snapPts[i];\n        }\n    }\n    return null;\n};\nLineStringSnapper.prototype.snapTo = function snapTo(snapPts) {\n    var coordList = new CoordinateList(this._srcPts);\n    this.snapVertices(coordList, snapPts);\n    this.snapSegments(coordList, snapPts);\n    var newPts = coordList.toCoordinateArray();\n    return newPts;\n};\nLineStringSnapper.prototype.snapSegments = function snapSegments(srcCoords, snapPts) {\n    var this$1 = this;\n    if (snapPts.length === 0) {\n        return null;\n    }\n    var distinctPtCount = snapPts.length;\n    if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) {\n        distinctPtCount = snapPts.length - 1;\n    }\n    for(var i = 0; i < distinctPtCount; i++){\n        var snapPt = snapPts[i];\n        var index = this$1.findSegmentIndexToSnap(snapPt, srcCoords);\n        if (index >= 0) {\n            srcCoords.add(index + 1, new Coordinate(snapPt), false);\n        }\n    }\n};\nLineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap(snapPt, srcCoords) {\n    var this$1 = this;\n    var minDist = Double.MAX_VALUE;\n    var snapIndex = -1;\n    for(var i = 0; i < srcCoords.size() - 1; i++){\n        this$1._seg.p0 = srcCoords.get(i);\n        this$1._seg.p1 = srcCoords.get(i + 1);\n        if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {\n            if (this$1._allowSnappingToSourceVertices) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n        var dist = this$1._seg.distance(snapPt);\n        if (dist < this$1._snapTolerance && dist < minDist) {\n            minDist = dist;\n            snapIndex = i;\n        }\n    }\n    return snapIndex;\n};\nLineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n    this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n};\nLineStringSnapper.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nLineStringSnapper.prototype.getClass = function getClass() {\n    return LineStringSnapper;\n};\nLineStringSnapper.isClosed = function isClosed(pts) {\n    if (pts.length <= 1) {\n        return false;\n    }\n    return pts[0].equals2D(pts[pts.length - 1]);\n};\nvar GeometrySnapper = function GeometrySnapper(srcGeom) {\n    this._srcGeom = srcGeom || null;\n};\nvar staticAccessors$41 = {\n    SNAP_PRECISION_FACTOR: {\n        configurable: true\n    }\n};\nGeometrySnapper.prototype.snapTo = function snapTo(snapGeom, snapTolerance) {\n    var snapPts = this.extractTargetCoordinates(snapGeom);\n    var snapTrans = new SnapTransformer(snapTolerance, snapPts);\n    return snapTrans.transform(this._srcGeom);\n};\nGeometrySnapper.prototype.snapToSelf = function snapToSelf(snapTolerance, cleanResult) {\n    var snapPts = this.extractTargetCoordinates(this._srcGeom);\n    var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n    var snappedGeom = snapTrans.transform(this._srcGeom);\n    var result = snappedGeom;\n    if (cleanResult && hasInterface(result, Polygonal)) {\n        result = snappedGeom.buffer(0);\n    }\n    return result;\n};\nGeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance(ringPts) {\n    var minSegLen = this.computeMinimumSegmentLength(ringPts);\n    var snapTol = minSegLen / 10;\n    return snapTol;\n};\nGeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates(g) {\n    var ptSet = new TreeSet();\n    var pts = g.getCoordinates();\n    for(var i = 0; i < pts.length; i++){\n        ptSet.add(pts[i]);\n    }\n    return ptSet.toArray(new Array(0).fill(null));\n};\nGeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength(pts) {\n    var minSegLen = Double.MAX_VALUE;\n    for(var i = 0; i < pts.length - 1; i++){\n        var segLen = pts[i].distance(pts[i + 1]);\n        if (segLen < minSegLen) {\n            minSegLen = segLen;\n        }\n    }\n    return minSegLen;\n};\nGeometrySnapper.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometrySnapper.prototype.getClass = function getClass() {\n    return GeometrySnapper;\n};\nGeometrySnapper.snap = function snap(g0, g1, snapTolerance) {\n    var snapGeom = new Array(2).fill(null);\n    var snapper0 = new GeometrySnapper(g0);\n    snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n    var snapper1 = new GeometrySnapper(g1);\n    snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n    return snapGeom;\n};\nGeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance() {\n    if (arguments.length === 1) {\n        var g = arguments[0];\n        var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n        var pm = g.getPrecisionModel();\n        if (pm.getType() === PrecisionModel.FIXED) {\n            var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n            if (fixedSnapTol > snapTolerance) {\n                snapTolerance = fixedSnapTol;\n            }\n        }\n        return snapTolerance;\n    } else if (arguments.length === 2) {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n    }\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance(g) {\n    var env = g.getEnvelopeInternal();\n    var minDimension = Math.min(env.getHeight(), env.getWidth());\n    var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n    return snapTol;\n};\nGeometrySnapper.snapToSelf = function snapToSelf(geom, snapTolerance, cleanResult) {\n    var snapper0 = new GeometrySnapper(geom);\n    return snapper0.snapToSelf(snapTolerance, cleanResult);\n};\nstaticAccessors$41.SNAP_PRECISION_FACTOR.get = function() {\n    return 1e-9;\n};\nObject.defineProperties(GeometrySnapper, staticAccessors$41);\nvar SnapTransformer = function(GeometryTransformer$$1) {\n    function SnapTransformer(snapTolerance, snapPts, isSelfSnap) {\n        GeometryTransformer$$1.call(this);\n        this._snapTolerance = snapTolerance || null;\n        this._snapPts = snapPts || null;\n        this._isSelfSnap = isSelfSnap !== undefined ? isSelfSnap : false;\n    }\n    if (GeometryTransformer$$1) SnapTransformer.__proto__ = GeometryTransformer$$1;\n    SnapTransformer.prototype = Object.create(GeometryTransformer$$1 && GeometryTransformer$$1.prototype);\n    SnapTransformer.prototype.constructor = SnapTransformer;\n    SnapTransformer.prototype.snapLine = function snapLine(srcPts, snapPts) {\n        var snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n        snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n        return snapper.snapTo(snapPts);\n    };\n    SnapTransformer.prototype.transformCoordinates = function transformCoordinates(coords, parent) {\n        var srcPts = coords.toCoordinateArray();\n        var newPts = this.snapLine(srcPts, this._snapPts);\n        return this._factory.getCoordinateSequenceFactory().create(newPts);\n    };\n    SnapTransformer.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    SnapTransformer.prototype.getClass = function getClass() {\n        return SnapTransformer;\n    };\n    return SnapTransformer;\n}(GeometryTransformer);\nvar CommonBits = function CommonBits() {\n    this._isFirst = true;\n    this._commonMantissaBitsCount = 53;\n    this._commonBits = 0;\n    this._commonSignExp = null;\n};\nCommonBits.prototype.getCommon = function getCommon() {\n    return Double.longBitsToDouble(this._commonBits);\n};\nCommonBits.prototype.add = function add(num) {\n    var numBits = Double.doubleToLongBits(num);\n    if (this._isFirst) {\n        this._commonBits = numBits;\n        this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n        this._isFirst = false;\n        return null;\n    }\n    var numSignExp = CommonBits.signExpBits(numBits);\n    if (numSignExp !== this._commonSignExp) {\n        this._commonBits = 0;\n        return null;\n    }\n    this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n    this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n};\nCommonBits.prototype.toString = function toString() {\n    if (arguments.length === 1) {\n        var bits = arguments[0];\n        var x = Double.longBitsToDouble(bits);\n        var numStr = Double.toBinaryString(bits);\n        var padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n        var bitStr = padStr.substring(padStr.length - 64);\n        var str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n        return str;\n    }\n};\nCommonBits.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCommonBits.prototype.getClass = function getClass() {\n    return CommonBits;\n};\nCommonBits.getBit = function getBit(bits, i) {\n    var mask = 1 << i;\n    return (bits & mask) !== 0 ? 1 : 0;\n};\nCommonBits.signExpBits = function signExpBits(num) {\n    return num >> 52;\n};\nCommonBits.zeroLowerBits = function zeroLowerBits(bits, nBits) {\n    var invMask = (1 << nBits) - 1;\n    var mask = ~invMask;\n    var zeroed = bits & mask;\n    return zeroed;\n};\nCommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits(num1, num2) {\n    var count = 0;\n    for(var i = 52; i >= 0; i--){\n        if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) {\n            return count;\n        }\n        count++;\n    }\n    return 52;\n};\nvar CommonBitsRemover = function CommonBitsRemover() {\n    this._commonCoord = null;\n    this._ccFilter = new CommonCoordinateFilter();\n};\nvar staticAccessors$42 = {\n    CommonCoordinateFilter: {\n        configurable: true\n    },\n    Translater: {\n        configurable: true\n    }\n};\nCommonBitsRemover.prototype.addCommonBits = function addCommonBits(geom) {\n    var trans = new Translater(this._commonCoord);\n    geom.apply(trans);\n    geom.geometryChanged();\n};\nCommonBitsRemover.prototype.removeCommonBits = function removeCommonBits(geom) {\n    if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) {\n        return geom;\n    }\n    var invCoord = new Coordinate(this._commonCoord);\n    invCoord.x = -invCoord.x;\n    invCoord.y = -invCoord.y;\n    var trans = new Translater(invCoord);\n    geom.apply(trans);\n    geom.geometryChanged();\n    return geom;\n};\nCommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate() {\n    return this._commonCoord;\n};\nCommonBitsRemover.prototype.add = function add(geom) {\n    geom.apply(this._ccFilter);\n    this._commonCoord = this._ccFilter.getCommonCoordinate();\n};\nCommonBitsRemover.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCommonBitsRemover.prototype.getClass = function getClass() {\n    return CommonBitsRemover;\n};\nstaticAccessors$42.CommonCoordinateFilter.get = function() {\n    return CommonCoordinateFilter;\n};\nstaticAccessors$42.Translater.get = function() {\n    return Translater;\n};\nObject.defineProperties(CommonBitsRemover, staticAccessors$42);\nvar CommonCoordinateFilter = function CommonCoordinateFilter() {\n    this._commonBitsX = new CommonBits();\n    this._commonBitsY = new CommonBits();\n};\nCommonCoordinateFilter.prototype.filter = function filter(coord) {\n    this._commonBitsX.add(coord.x);\n    this._commonBitsY.add(coord.y);\n};\nCommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate() {\n    return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n};\nCommonCoordinateFilter.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateFilter\n    ];\n};\nCommonCoordinateFilter.prototype.getClass = function getClass() {\n    return CommonCoordinateFilter;\n};\nvar Translater = function Translater() {\n    this.trans = null;\n    var trans = arguments[0];\n    this.trans = trans;\n};\nTranslater.prototype.filter = function filter(seq, i) {\n    var xp = seq.getOrdinate(i, 0) + this.trans.x;\n    var yp = seq.getOrdinate(i, 1) + this.trans.y;\n    seq.setOrdinate(i, 0, xp);\n    seq.setOrdinate(i, 1, yp);\n};\nTranslater.prototype.isDone = function isDone() {\n    return false;\n};\nTranslater.prototype.isGeometryChanged = function isGeometryChanged() {\n    return true;\n};\nTranslater.prototype.interfaces_ = function interfaces_() {\n    return [\n        CoordinateSequenceFilter\n    ];\n};\nTranslater.prototype.getClass = function getClass() {\n    return Translater;\n};\nvar SnapOverlayOp = function SnapOverlayOp(g1, g2) {\n    this._geom = new Array(2).fill(null);\n    this._snapTolerance = null;\n    this._cbr = null;\n    this._geom[0] = g1;\n    this._geom[1] = g2;\n    this.computeSnapTolerance();\n};\nSnapOverlayOp.prototype.selfSnap = function selfSnap(geom) {\n    var snapper0 = new GeometrySnapper(geom);\n    var snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n    return snapGeom;\n};\nSnapOverlayOp.prototype.removeCommonBits = function removeCommonBits(geom) {\n    this._cbr = new CommonBitsRemover();\n    this._cbr.add(geom[0]);\n    this._cbr.add(geom[1]);\n    var remGeom = new Array(2).fill(null);\n    remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n    remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n    return remGeom;\n};\nSnapOverlayOp.prototype.prepareResult = function prepareResult(geom) {\n    this._cbr.addCommonBits(geom);\n    return geom;\n};\nSnapOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {\n    var prepGeom = this.snap(this._geom);\n    var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n    return this.prepareResult(result);\n};\nSnapOverlayOp.prototype.checkValid = function checkValid(g) {\n    if (!g.isValid()) {\n        System.out.println(\"Snapped geometry is invalid\");\n    }\n};\nSnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance() {\n    this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n};\nSnapOverlayOp.prototype.snap = function snap(geom) {\n    var remGeom = this.removeCommonBits(geom);\n    var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n    return snapGeom;\n};\nSnapOverlayOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSnapOverlayOp.prototype.getClass = function getClass() {\n    return SnapOverlayOp;\n};\nSnapOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {\n    var op = new SnapOverlayOp(g0, g1);\n    return op.getResultGeometry(opCode);\n};\nSnapOverlayOp.union = function union(g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapOverlayOp.intersection = function intersection(g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapOverlayOp.symDifference = function symDifference(g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapOverlayOp.difference = function difference(g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\nvar SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp(g1, g2) {\n    this._geom = new Array(2).fill(null);\n    this._geom[0] = g1;\n    this._geom[1] = g2;\n};\nSnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry(opCode) {\n    var result = null;\n    var isSuccess = false;\n    var savedException = null;\n    try {\n        result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n        var isValid = true;\n        if (isValid) {\n            isSuccess = true;\n        }\n    } catch (ex) {\n        if (ex instanceof RuntimeException) {\n            savedException = ex;\n        } else {\n            throw ex;\n        }\n    } finally{}\n    if (!isSuccess) {\n        try {\n            result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n        } catch (ex) {\n            if (ex instanceof RuntimeException) {\n                throw savedException;\n            } else {\n                throw ex;\n            }\n        } finally{}\n    }\n    return result;\n};\nSnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSnapIfNeededOverlayOp.prototype.getClass = function getClass() {\n    return SnapIfNeededOverlayOp;\n};\nSnapIfNeededOverlayOp.overlayOp = function overlayOp(g0, g1, opCode) {\n    var op = new SnapIfNeededOverlayOp(g0, g1);\n    return op.getResultGeometry(opCode);\n};\nSnapIfNeededOverlayOp.union = function union(g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapIfNeededOverlayOp.intersection = function intersection(g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapIfNeededOverlayOp.symDifference = function symDifference(g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapIfNeededOverlayOp.difference = function difference(g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\nvar MonotoneChain$2 = function MonotoneChain() {\n    this.mce = null;\n    this.chainIndex = null;\n    var mce = arguments[0];\n    var chainIndex = arguments[1];\n    this.mce = mce;\n    this.chainIndex = chainIndex;\n};\nMonotoneChain$2.prototype.computeIntersections = function computeIntersections(mc, si) {\n    this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n};\nMonotoneChain$2.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nMonotoneChain$2.prototype.getClass = function getClass() {\n    return MonotoneChain$2;\n};\nvar SweepLineEvent = function SweepLineEvent() {\n    this._label = null;\n    this._xValue = null;\n    this._eventType = null;\n    this._insertEvent = null;\n    this._deleteEventIndex = null;\n    this._obj = null;\n    if (arguments.length === 2) {\n        var x = arguments[0];\n        var insertEvent = arguments[1];\n        this._eventType = SweepLineEvent.DELETE;\n        this._xValue = x;\n        this._insertEvent = insertEvent;\n    } else if (arguments.length === 3) {\n        var label = arguments[0];\n        var x$1 = arguments[1];\n        var obj = arguments[2];\n        this._eventType = SweepLineEvent.INSERT;\n        this._label = label;\n        this._xValue = x$1;\n        this._obj = obj;\n    }\n};\nvar staticAccessors$43 = {\n    INSERT: {\n        configurable: true\n    },\n    DELETE: {\n        configurable: true\n    }\n};\nSweepLineEvent.prototype.isDelete = function isDelete() {\n    return this._eventType === SweepLineEvent.DELETE;\n};\nSweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex(deleteEventIndex) {\n    this._deleteEventIndex = deleteEventIndex;\n};\nSweepLineEvent.prototype.getObject = function getObject() {\n    return this._obj;\n};\nSweepLineEvent.prototype.compareTo = function compareTo(o) {\n    var pe = o;\n    if (this._xValue < pe._xValue) {\n        return -1;\n    }\n    if (this._xValue > pe._xValue) {\n        return 1;\n    }\n    if (this._eventType < pe._eventType) {\n        return -1;\n    }\n    if (this._eventType > pe._eventType) {\n        return 1;\n    }\n    return 0;\n};\nSweepLineEvent.prototype.getInsertEvent = function getInsertEvent() {\n    return this._insertEvent;\n};\nSweepLineEvent.prototype.isInsert = function isInsert() {\n    return this._eventType === SweepLineEvent.INSERT;\n};\nSweepLineEvent.prototype.isSameLabel = function isSameLabel(ev) {\n    if (this._label === null) {\n        return false;\n    }\n    return this._label === ev._label;\n};\nSweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex() {\n    return this._deleteEventIndex;\n};\nSweepLineEvent.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparable\n    ];\n};\nSweepLineEvent.prototype.getClass = function getClass() {\n    return SweepLineEvent;\n};\nstaticAccessors$43.INSERT.get = function() {\n    return 1;\n};\nstaticAccessors$43.DELETE.get = function() {\n    return 2;\n};\nObject.defineProperties(SweepLineEvent, staticAccessors$43);\nvar EdgeSetIntersector = function EdgeSetIntersector() {};\nEdgeSetIntersector.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nEdgeSetIntersector.prototype.getClass = function getClass() {\n    return EdgeSetIntersector;\n};\nvar SegmentIntersector$2 = function SegmentIntersector() {\n    this._hasIntersection = false;\n    this._hasProper = false;\n    this._hasProperInterior = false;\n    this._properIntersectionPoint = null;\n    this._li = null;\n    this._includeProper = null;\n    this._recordIsolated = null;\n    this._isSelfIntersection = null;\n    this._numIntersections = 0;\n    this.numTests = 0;\n    this._bdyNodes = null;\n    this._isDone = false;\n    this._isDoneWhenProperInt = false;\n    var li = arguments[0];\n    var includeProper = arguments[1];\n    var recordIsolated = arguments[2];\n    this._li = li;\n    this._includeProper = includeProper;\n    this._recordIsolated = recordIsolated;\n};\nSegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1) {\n        if (this._li.getIntersectionNum() === 1) {\n            if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) {\n                return true;\n            }\n            if (e0.isClosed()) {\n                var maxSegIndex = e0.getNumPoints() - 1;\n                if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\nSegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint() {\n    return this._properIntersectionPoint;\n};\nSegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt(isDoneWhenProperInt) {\n    this._isDoneWhenProperInt = isDoneWhenProperInt;\n};\nSegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection() {\n    return this._hasProperInterior;\n};\nSegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal(li, bdyNodes) {\n    for(var i = bdyNodes.iterator(); i.hasNext();){\n        var node = i.next();\n        var pt = node.getCoordinate();\n        if (li.isIntersection(pt)) {\n            return true;\n        }\n    }\n    return false;\n};\nSegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection() {\n    return this._hasProper;\n};\nSegmentIntersector$2.prototype.hasIntersection = function hasIntersection() {\n    return this._hasIntersection;\n};\nSegmentIntersector$2.prototype.isDone = function isDone() {\n    return this._isDone;\n};\nSegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint(li, bdyNodes) {\n    if (bdyNodes === null) {\n        return false;\n    }\n    if (this.isBoundaryPointInternal(li, bdyNodes[0])) {\n        return true;\n    }\n    if (this.isBoundaryPointInternal(li, bdyNodes[1])) {\n        return true;\n    }\n    return false;\n};\nSegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes(bdyNodes0, bdyNodes1) {\n    this._bdyNodes = new Array(2).fill(null);\n    this._bdyNodes[0] = bdyNodes0;\n    this._bdyNodes[1] = bdyNodes1;\n};\nSegmentIntersector$2.prototype.addIntersections = function addIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) {\n        return null;\n    }\n    this.numTests++;\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n        if (this._recordIsolated) {\n            e0.setIsolated(false);\n            e1.setIsolated(false);\n        }\n        this._numIntersections++;\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n            this._hasIntersection = true;\n            if (this._includeProper || !this._li.isProper()) {\n                e0.addIntersections(this._li, segIndex0, 0);\n                e1.addIntersections(this._li, segIndex1, 1);\n            }\n            if (this._li.isProper()) {\n                this._properIntersectionPoint = this._li.getIntersection(0).copy();\n                this._hasProper = true;\n                if (this._isDoneWhenProperInt) {\n                    this._isDone = true;\n                }\n                if (!this.isBoundaryPoint(this._li, this._bdyNodes)) {\n                    this._hasProperInterior = true;\n                }\n            }\n        }\n    }\n};\nSegmentIntersector$2.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSegmentIntersector$2.prototype.getClass = function getClass() {\n    return SegmentIntersector$2;\n};\nSegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments(i1, i2) {\n    return Math.abs(i1 - i2) === 1;\n};\nvar SimpleMCSweepLineIntersector = function(EdgeSetIntersector$$1) {\n    function SimpleMCSweepLineIntersector() {\n        EdgeSetIntersector$$1.call(this);\n        this.events = new ArrayList();\n        this.nOverlaps = null;\n    }\n    if (EdgeSetIntersector$$1) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;\n    SimpleMCSweepLineIntersector.prototype = Object.create(EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype);\n    SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;\n    SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents() {\n        var this$1 = this;\n        Collections.sort(this.events);\n        for(var i = 0; i < this.events.size(); i++){\n            var ev = this$1.events.get(i);\n            if (ev.isDelete()) {\n                ev.getInsertEvent().setDeleteEventIndex(i);\n            }\n        }\n    };\n    SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var si = arguments[0];\n            this.nOverlaps = 0;\n            this.prepareEvents();\n            for(var i = 0; i < this.events.size(); i++){\n                var ev = this$1.events.get(i);\n                if (ev.isInsert()) {\n                    this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n                }\n                if (si.isDone()) {\n                    break;\n                }\n            }\n        } else if (arguments.length === 3) {\n            if (arguments[2] instanceof SegmentIntersector$2 && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n                var edges0 = arguments[0];\n                var edges1 = arguments[1];\n                var si$1 = arguments[2];\n                this.addEdges(edges0, edges0);\n                this.addEdges(edges1, edges1);\n                this.computeIntersections(si$1);\n            } else if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2) {\n                var edges = arguments[0];\n                var si$2 = arguments[1];\n                var testAllSegments = arguments[2];\n                if (testAllSegments) {\n                    this.addEdges(edges, null);\n                } else {\n                    this.addEdges(edges);\n                }\n                this.computeIntersections(si$2);\n            }\n        }\n    };\n    SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge(edge, edgeSet) {\n        var this$1 = this;\n        var mce = edge.getMonotoneChainEdge();\n        var startIndex = mce.getStartIndexes();\n        for(var i = 0; i < startIndex.length - 1; i++){\n            var mc = new MonotoneChain$2(mce, i);\n            var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n            this$1.events.add(insertEvent);\n            this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n        }\n    };\n    SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps(start, end, ev0, si) {\n        var this$1 = this;\n        var mc0 = ev0.getObject();\n        for(var i = start; i < end; i++){\n            var ev1 = this$1.events.get(i);\n            if (ev1.isInsert()) {\n                var mc1 = ev1.getObject();\n                if (!ev0.isSameLabel(ev1)) {\n                    mc0.computeIntersections(mc1, si);\n                    this$1.nOverlaps++;\n                }\n            }\n        }\n    };\n    SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges() {\n        var this$1 = this;\n        if (arguments.length === 1) {\n            var edges = arguments[0];\n            for(var i = edges.iterator(); i.hasNext();){\n                var edge = i.next();\n                this$1.addEdge(edge, edge);\n            }\n        } else if (arguments.length === 2) {\n            var edges$1 = arguments[0];\n            var edgeSet = arguments[1];\n            for(var i$1 = edges$1.iterator(); i$1.hasNext();){\n                var edge$1 = i$1.next();\n                this$1.addEdge(edge$1, edgeSet);\n            }\n        }\n    };\n    SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    SimpleMCSweepLineIntersector.prototype.getClass = function getClass() {\n        return SimpleMCSweepLineIntersector;\n    };\n    return SimpleMCSweepLineIntersector;\n}(EdgeSetIntersector);\nvar IntervalRTreeNode = function IntervalRTreeNode() {\n    this._min = Double.POSITIVE_INFINITY;\n    this._max = Double.NEGATIVE_INFINITY;\n};\nvar staticAccessors$45 = {\n    NodeComparator: {\n        configurable: true\n    }\n};\nIntervalRTreeNode.prototype.getMin = function getMin() {\n    return this._min;\n};\nIntervalRTreeNode.prototype.intersects = function intersects(queryMin, queryMax) {\n    if (this._min > queryMax || this._max < queryMin) {\n        return false;\n    }\n    return true;\n};\nIntervalRTreeNode.prototype.getMax = function getMax() {\n    return this._max;\n};\nIntervalRTreeNode.prototype.toString = function toString() {\n    return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n};\nIntervalRTreeNode.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nIntervalRTreeNode.prototype.getClass = function getClass() {\n    return IntervalRTreeNode;\n};\nstaticAccessors$45.NodeComparator.get = function() {\n    return NodeComparator;\n};\nObject.defineProperties(IntervalRTreeNode, staticAccessors$45);\nvar NodeComparator = function NodeComparator() {};\nNodeComparator.prototype.compare = function compare(o1, o2) {\n    var n1 = o1;\n    var n2 = o2;\n    var mid1 = (n1._min + n1._max) / 2;\n    var mid2 = (n2._min + n2._max) / 2;\n    if (mid1 < mid2) {\n        return -1;\n    }\n    if (mid1 > mid2) {\n        return 1;\n    }\n    return 0;\n};\nNodeComparator.prototype.interfaces_ = function interfaces_() {\n    return [\n        Comparator\n    ];\n};\nNodeComparator.prototype.getClass = function getClass() {\n    return NodeComparator;\n};\nvar IntervalRTreeLeafNode = function(IntervalRTreeNode$$1) {\n    function IntervalRTreeLeafNode() {\n        IntervalRTreeNode$$1.call(this);\n        this._item = null;\n        var min = arguments[0];\n        var max = arguments[1];\n        var item = arguments[2];\n        this._min = min;\n        this._max = max;\n        this._item = item;\n    }\n    if (IntervalRTreeNode$$1) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;\n    IntervalRTreeLeafNode.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);\n    IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;\n    IntervalRTreeLeafNode.prototype.query = function query(queryMin, queryMax, visitor) {\n        if (!this.intersects(queryMin, queryMax)) {\n            return null;\n        }\n        visitor.visitItem(this._item);\n    };\n    IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    IntervalRTreeLeafNode.prototype.getClass = function getClass() {\n        return IntervalRTreeLeafNode;\n    };\n    return IntervalRTreeLeafNode;\n}(IntervalRTreeNode);\nvar IntervalRTreeBranchNode = function(IntervalRTreeNode$$1) {\n    function IntervalRTreeBranchNode() {\n        IntervalRTreeNode$$1.call(this);\n        this._node1 = null;\n        this._node2 = null;\n        var n1 = arguments[0];\n        var n2 = arguments[1];\n        this._node1 = n1;\n        this._node2 = n2;\n        this.buildExtent(this._node1, this._node2);\n    }\n    if (IntervalRTreeNode$$1) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;\n    IntervalRTreeBranchNode.prototype = Object.create(IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype);\n    IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;\n    IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent(n1, n2) {\n        this._min = Math.min(n1._min, n2._min);\n        this._max = Math.max(n1._max, n2._max);\n    };\n    IntervalRTreeBranchNode.prototype.query = function query(queryMin, queryMax, visitor) {\n        if (!this.intersects(queryMin, queryMax)) {\n            return null;\n        }\n        if (this._node1 !== null) {\n            this._node1.query(queryMin, queryMax, visitor);\n        }\n        if (this._node2 !== null) {\n            this._node2.query(queryMin, queryMax, visitor);\n        }\n    };\n    IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    IntervalRTreeBranchNode.prototype.getClass = function getClass() {\n        return IntervalRTreeBranchNode;\n    };\n    return IntervalRTreeBranchNode;\n}(IntervalRTreeNode);\nvar SortedPackedIntervalRTree = function SortedPackedIntervalRTree() {\n    this._leaves = new ArrayList();\n    this._root = null;\n    this._level = 0;\n};\nSortedPackedIntervalRTree.prototype.buildTree = function buildTree() {\n    var this$1 = this;\n    Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n    var src = this._leaves;\n    var temp = null;\n    var dest = new ArrayList();\n    while(true){\n        this$1.buildLevel(src, dest);\n        if (dest.size() === 1) {\n            return dest.get(0);\n        }\n        temp = src;\n        src = dest;\n        dest = temp;\n    }\n};\nSortedPackedIntervalRTree.prototype.insert = function insert(min, max, item) {\n    if (this._root !== null) {\n        throw new Error(\"Index cannot be added to once it has been queried\");\n    }\n    this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n};\nSortedPackedIntervalRTree.prototype.query = function query(min, max, visitor) {\n    this.init();\n    this._root.query(min, max, visitor);\n};\nSortedPackedIntervalRTree.prototype.buildRoot = function buildRoot() {\n    if (this._root !== null) {\n        return null;\n    }\n    this._root = this.buildTree();\n};\nSortedPackedIntervalRTree.prototype.printNode = function printNode(node) {\n    System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n};\nSortedPackedIntervalRTree.prototype.init = function init() {\n    if (this._root !== null) {\n        return null;\n    }\n    this.buildRoot();\n};\nSortedPackedIntervalRTree.prototype.buildLevel = function buildLevel(src, dest) {\n    this._level++;\n    dest.clear();\n    for(var i = 0; i < src.size(); i += 2){\n        var n1 = src.get(i);\n        var n2 = i + 1 < src.size() ? src.get(i) : null;\n        if (n2 === null) {\n            dest.add(n1);\n        } else {\n            var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n            dest.add(node);\n        }\n    }\n};\nSortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nSortedPackedIntervalRTree.prototype.getClass = function getClass() {\n    return SortedPackedIntervalRTree;\n};\nvar ArrayListVisitor = function ArrayListVisitor() {\n    this._items = new ArrayList();\n};\nArrayListVisitor.prototype.visitItem = function visitItem(item) {\n    this._items.add(item);\n};\nArrayListVisitor.prototype.getItems = function getItems() {\n    return this._items;\n};\nArrayListVisitor.prototype.interfaces_ = function interfaces_() {\n    return [\n        ItemVisitor\n    ];\n};\nArrayListVisitor.prototype.getClass = function getClass() {\n    return ArrayListVisitor;\n};\nvar IndexedPointInAreaLocator = function IndexedPointInAreaLocator() {\n    this._index = null;\n    var g = arguments[0];\n    if (!hasInterface(g, Polygonal)) {\n        throw new IllegalArgumentException(\"Argument must be Polygonal\");\n    }\n    this._index = new IntervalIndexedGeometry(g);\n};\nvar staticAccessors$44 = {\n    SegmentVisitor: {\n        configurable: true\n    },\n    IntervalIndexedGeometry: {\n        configurable: true\n    }\n};\nIndexedPointInAreaLocator.prototype.locate = function locate(p) {\n    var rcc = new RayCrossingCounter(p);\n    var visitor = new SegmentVisitor(rcc);\n    this._index.query(p.y, p.y, visitor);\n    return rcc.getLocation();\n};\nIndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_() {\n    return [\n        PointOnGeometryLocator\n    ];\n};\nIndexedPointInAreaLocator.prototype.getClass = function getClass() {\n    return IndexedPointInAreaLocator;\n};\nstaticAccessors$44.SegmentVisitor.get = function() {\n    return SegmentVisitor;\n};\nstaticAccessors$44.IntervalIndexedGeometry.get = function() {\n    return IntervalIndexedGeometry;\n};\nObject.defineProperties(IndexedPointInAreaLocator, staticAccessors$44);\nvar SegmentVisitor = function SegmentVisitor() {\n    this._counter = null;\n    var counter = arguments[0];\n    this._counter = counter;\n};\nSegmentVisitor.prototype.visitItem = function visitItem(item) {\n    var seg = item;\n    this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n};\nSegmentVisitor.prototype.interfaces_ = function interfaces_() {\n    return [\n        ItemVisitor\n    ];\n};\nSegmentVisitor.prototype.getClass = function getClass() {\n    return SegmentVisitor;\n};\nvar IntervalIndexedGeometry = function IntervalIndexedGeometry() {\n    this._index = new SortedPackedIntervalRTree();\n    var geom = arguments[0];\n    this.init(geom);\n};\nIntervalIndexedGeometry.prototype.init = function init(geom) {\n    var this$1 = this;\n    var lines = LinearComponentExtracter.getLines(geom);\n    for(var i = lines.iterator(); i.hasNext();){\n        var line = i.next();\n        var pts = line.getCoordinates();\n        this$1.addLine(pts);\n    }\n};\nIntervalIndexedGeometry.prototype.addLine = function addLine(pts) {\n    var this$1 = this;\n    for(var i = 1; i < pts.length; i++){\n        var seg = new LineSegment(pts[i - 1], pts[i]);\n        var min = Math.min(seg.p0.y, seg.p1.y);\n        var max = Math.max(seg.p0.y, seg.p1.y);\n        this$1._index.insert(min, max, seg);\n    }\n};\nIntervalIndexedGeometry.prototype.query = function query() {\n    if (arguments.length === 2) {\n        var min = arguments[0];\n        var max = arguments[1];\n        var visitor = new ArrayListVisitor();\n        this._index.query(min, max, visitor);\n        return visitor.getItems();\n    } else if (arguments.length === 3) {\n        var min$1 = arguments[0];\n        var max$1 = arguments[1];\n        var visitor$1 = arguments[2];\n        this._index.query(min$1, max$1, visitor$1);\n    }\n};\nIntervalIndexedGeometry.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nIntervalIndexedGeometry.prototype.getClass = function getClass() {\n    return IntervalIndexedGeometry;\n};\nvar GeometryGraph = function(PlanarGraph$$1) {\n    function GeometryGraph() {\n        PlanarGraph$$1.call(this);\n        this._parentGeom = null;\n        this._lineEdgeMap = new HashMap();\n        this._boundaryNodeRule = null;\n        this._useBoundaryDeterminationRule = true;\n        this._argIndex = null;\n        this._boundaryNodes = null;\n        this._hasTooFewPoints = false;\n        this._invalidPoint = null;\n        this._areaPtLocator = null;\n        this._ptLocator = new PointLocator();\n        if (arguments.length === 2) {\n            var argIndex = arguments[0];\n            var parentGeom = arguments[1];\n            var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n            this._argIndex = argIndex;\n            this._parentGeom = parentGeom;\n            this._boundaryNodeRule = boundaryNodeRule;\n            if (parentGeom !== null) {\n                this.add(parentGeom);\n            }\n        } else if (arguments.length === 3) {\n            var argIndex$1 = arguments[0];\n            var parentGeom$1 = arguments[1];\n            var boundaryNodeRule$1 = arguments[2];\n            this._argIndex = argIndex$1;\n            this._parentGeom = parentGeom$1;\n            this._boundaryNodeRule = boundaryNodeRule$1;\n            if (parentGeom$1 !== null) {\n                this.add(parentGeom$1);\n            }\n        }\n    }\n    if (PlanarGraph$$1) GeometryGraph.__proto__ = PlanarGraph$$1;\n    GeometryGraph.prototype = Object.create(PlanarGraph$$1 && PlanarGraph$$1.prototype);\n    GeometryGraph.prototype.constructor = GeometryGraph;\n    GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint(argIndex, coord) {\n        var n = this._nodes.addNode(coord);\n        var lbl = n.getLabel();\n        var boundaryCount = 1;\n        var loc = Location.NONE;\n        loc = lbl.getLocation(argIndex, Position.ON);\n        if (loc === Location.BOUNDARY) {\n            boundaryCount++;\n        }\n        var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n        lbl.setLocation(argIndex, newLoc);\n    };\n    GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes() {\n        if (arguments.length === 2) {\n            var li = arguments[0];\n            var computeRingSelfNodes = arguments[1];\n            return this.computeSelfNodes(li, computeRingSelfNodes, false);\n        } else if (arguments.length === 3) {\n            var li$1 = arguments[0];\n            var computeRingSelfNodes$1 = arguments[1];\n            var isDoneIfProperInt = arguments[2];\n            var si = new SegmentIntersector$2(li$1, true, false);\n            si.setIsDoneIfProperInt(isDoneIfProperInt);\n            var esi = this.createEdgeSetIntersector();\n            var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n            var computeAllSegments = computeRingSelfNodes$1 || !isRings;\n            esi.computeIntersections(this._edges, si, computeAllSegments);\n            this.addSelfIntersectionNodes(this._argIndex);\n            return si;\n        }\n    };\n    GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges(edgelist) {\n        for(var i = this._edges.iterator(); i.hasNext();){\n            var e = i.next();\n            e.eiList.addSplitEdges(edgelist);\n        }\n    };\n    GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections(g, li, includeProper) {\n        var si = new SegmentIntersector$2(li, includeProper, true);\n        si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n        var esi = this.createEdgeSetIntersector();\n        esi.computeIntersections(this._edges, g._edges, si);\n        return si;\n    };\n    GeometryGraph.prototype.getGeometry = function getGeometry() {\n        return this._parentGeom;\n    };\n    GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule() {\n        return this._boundaryNodeRule;\n    };\n    GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints() {\n        return this._hasTooFewPoints;\n    };\n    GeometryGraph.prototype.addPoint = function addPoint() {\n        if (arguments[0] instanceof Point) {\n            var p = arguments[0];\n            var coord = p.getCoordinate();\n            this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n        } else if (arguments[0] instanceof Coordinate) {\n            var pt = arguments[0];\n            this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n        }\n    };\n    GeometryGraph.prototype.addPolygon = function addPolygon(p) {\n        var this$1 = this;\n        this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n        for(var i = 0; i < p.getNumInteriorRing(); i++){\n            var hole = p.getInteriorRingN(i);\n            this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n        }\n    };\n    GeometryGraph.prototype.addEdge = function addEdge(e) {\n        this.insertEdge(e);\n        var coord = e.getCoordinates();\n        this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n        this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n    };\n    GeometryGraph.prototype.addLineString = function addLineString(line) {\n        var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n        if (coord.length < 2) {\n            this._hasTooFewPoints = true;\n            this._invalidPoint = coord[0];\n            return null;\n        }\n        var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n        this._lineEdgeMap.put(line, e);\n        this.insertEdge(e);\n        Assert.isTrue(coord.length >= 2, \"found LineString with single point\");\n        this.insertBoundaryPoint(this._argIndex, coord[0]);\n        this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n    };\n    GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint() {\n        return this._invalidPoint;\n    };\n    GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints() {\n        var coll = this.getBoundaryNodes();\n        var pts = new Array(coll.size()).fill(null);\n        var i = 0;\n        for(var it = coll.iterator(); it.hasNext();){\n            var node = it.next();\n            pts[i++] = node.getCoordinate().copy();\n        }\n        return pts;\n    };\n    GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes() {\n        if (this._boundaryNodes === null) {\n            this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n        }\n        return this._boundaryNodes;\n    };\n    GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode(argIndex, coord, loc) {\n        if (this.isBoundaryNode(argIndex, coord)) {\n            return null;\n        }\n        if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) {\n            this.insertBoundaryPoint(argIndex, coord);\n        } else {\n            this.insertPoint(argIndex, coord, loc);\n        }\n    };\n    GeometryGraph.prototype.addPolygonRing = function addPolygonRing(lr, cwLeft, cwRight) {\n        if (lr.isEmpty()) {\n            return null;\n        }\n        var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n        if (coord.length < 4) {\n            this._hasTooFewPoints = true;\n            this._invalidPoint = coord[0];\n            return null;\n        }\n        var left = cwLeft;\n        var right = cwRight;\n        if (CGAlgorithms.isCCW(coord)) {\n            left = cwRight;\n            right = cwLeft;\n        }\n        var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n        this._lineEdgeMap.put(lr, e);\n        this.insertEdge(e);\n        this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    };\n    GeometryGraph.prototype.insertPoint = function insertPoint(argIndex, coord, onLocation) {\n        var n = this._nodes.addNode(coord);\n        var lbl = n.getLabel();\n        if (lbl === null) {\n            n._label = new Label(argIndex, onLocation);\n        } else {\n            lbl.setLocation(argIndex, onLocation);\n        }\n    };\n    GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector() {\n        return new SimpleMCSweepLineIntersector();\n    };\n    GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes(argIndex) {\n        var this$1 = this;\n        for(var i = this._edges.iterator(); i.hasNext();){\n            var e = i.next();\n            var eLoc = e.getLabel().getLocation(argIndex);\n            for(var eiIt = e.eiList.iterator(); eiIt.hasNext();){\n                var ei = eiIt.next();\n                this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n            }\n        }\n    };\n    GeometryGraph.prototype.add = function add() {\n        if (arguments.length === 1) {\n            var g = arguments[0];\n            if (g.isEmpty()) {\n                return null;\n            }\n            if (g instanceof MultiPolygon) {\n                this._useBoundaryDeterminationRule = false;\n            }\n            if (g instanceof Polygon) {\n                this.addPolygon(g);\n            } else if (g instanceof LineString) {\n                this.addLineString(g);\n            } else if (g instanceof Point) {\n                this.addPoint(g);\n            } else if (g instanceof MultiPoint) {\n                this.addCollection(g);\n            } else if (g instanceof MultiLineString) {\n                this.addCollection(g);\n            } else if (g instanceof MultiPolygon) {\n                this.addCollection(g);\n            } else if (g instanceof GeometryCollection) {\n                this.addCollection(g);\n            } else {\n                throw new Error(g.getClass().getName());\n            }\n        } else {\n            return PlanarGraph$$1.prototype.add.apply(this, arguments);\n        }\n    };\n    GeometryGraph.prototype.addCollection = function addCollection(gc) {\n        var this$1 = this;\n        for(var i = 0; i < gc.getNumGeometries(); i++){\n            var g = gc.getGeometryN(i);\n            this$1.add(g);\n        }\n    };\n    GeometryGraph.prototype.locate = function locate(pt) {\n        if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n            if (this._areaPtLocator === null) {\n                this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n            }\n            return this._areaPtLocator.locate(pt);\n        }\n        return this._ptLocator.locate(pt, this._parentGeom);\n    };\n    GeometryGraph.prototype.findEdge = function findEdge() {\n        if (arguments.length === 1) {\n            var line = arguments[0];\n            return this._lineEdgeMap.get(line);\n        } else {\n            return PlanarGraph$$1.prototype.findEdge.apply(this, arguments);\n        }\n    };\n    GeometryGraph.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    GeometryGraph.prototype.getClass = function getClass() {\n        return GeometryGraph;\n    };\n    GeometryGraph.determineBoundary = function determineBoundary(boundaryNodeRule, boundaryCount) {\n        return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n    };\n    return GeometryGraph;\n}(PlanarGraph);\nvar GeometryGraphOp = function GeometryGraphOp() {\n    this._li = new RobustLineIntersector();\n    this._resultPrecisionModel = null;\n    this._arg = null;\n    if (arguments.length === 1) {\n        var g0 = arguments[0];\n        this.setComputationPrecision(g0.getPrecisionModel());\n        this._arg = new Array(1).fill(null);\n        this._arg[0] = new GeometryGraph(0, g0);\n    } else if (arguments.length === 2) {\n        var g0$1 = arguments[0];\n        var g1 = arguments[1];\n        var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n        if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) {\n            this.setComputationPrecision(g0$1.getPrecisionModel());\n        } else {\n            this.setComputationPrecision(g1.getPrecisionModel());\n        }\n        this._arg = new Array(2).fill(null);\n        this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);\n        this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n    } else if (arguments.length === 3) {\n        var g0$2 = arguments[0];\n        var g1$1 = arguments[1];\n        var boundaryNodeRule$1 = arguments[2];\n        if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) {\n            this.setComputationPrecision(g0$2.getPrecisionModel());\n        } else {\n            this.setComputationPrecision(g1$1.getPrecisionModel());\n        }\n        this._arg = new Array(2).fill(null);\n        this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);\n        this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);\n    }\n};\nGeometryGraphOp.prototype.getArgGeometry = function getArgGeometry(i) {\n    return this._arg[i].getGeometry();\n};\nGeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision(pm) {\n    this._resultPrecisionModel = pm;\n    this._li.setPrecisionModel(this._resultPrecisionModel);\n};\nGeometryGraphOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryGraphOp.prototype.getClass = function getClass() {\n    return GeometryGraphOp;\n};\n// operation.geometrygraph\nvar GeometryMapper = function GeometryMapper() {};\nGeometryMapper.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryMapper.prototype.getClass = function getClass() {\n    return GeometryMapper;\n};\nGeometryMapper.map = function map() {\n    if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n        var geom = arguments[0];\n        var op = arguments[1];\n        var mapped = new ArrayList();\n        for(var i = 0; i < geom.getNumGeometries(); i++){\n            var g = op.map(geom.getGeometryN(i));\n            if (g !== null) {\n                mapped.add(g);\n            }\n        }\n        return geom.getFactory().buildGeometry(mapped);\n    } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n        var geoms = arguments[0];\n        var op$1 = arguments[1];\n        var mapped$1 = new ArrayList();\n        for(var i$1 = geoms.iterator(); i$1.hasNext();){\n            var g$1 = i$1.next();\n            var gr = op$1.map(g$1);\n            if (gr !== null) {\n                mapped$1.add(gr);\n            }\n        }\n        return mapped$1;\n    }\n};\nGeometryMapper.MapOp = function MapOp() {};\nvar OverlayOp = function(GeometryGraphOp) {\n    function OverlayOp() {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        GeometryGraphOp.call(this, g0, g1);\n        this._ptLocator = new PointLocator();\n        this._geomFact = null;\n        this._resultGeom = null;\n        this._graph = null;\n        this._edgeList = new EdgeList();\n        this._resultPolyList = new ArrayList();\n        this._resultLineList = new ArrayList();\n        this._resultPointList = new ArrayList();\n        this._graph = new PlanarGraph(new OverlayNodeFactory());\n        this._geomFact = g0.getFactory();\n    }\n    if (GeometryGraphOp) OverlayOp.__proto__ = GeometryGraphOp;\n    OverlayOp.prototype = Object.create(GeometryGraphOp && GeometryGraphOp.prototype);\n    OverlayOp.prototype.constructor = OverlayOp;\n    OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge(e) {\n        var existingEdge = this._edgeList.findEqualEdge(e);\n        if (existingEdge !== null) {\n            var existingLabel = existingEdge.getLabel();\n            var labelToMerge = e.getLabel();\n            if (!existingEdge.isPointwiseEqual(e)) {\n                labelToMerge = new Label(e.getLabel());\n                labelToMerge.flip();\n            }\n            var depth = existingEdge.getDepth();\n            if (depth.isNull()) {\n                depth.add(existingLabel);\n            }\n            depth.add(labelToMerge);\n            existingLabel.merge(labelToMerge);\n        } else {\n            this._edgeList.add(e);\n        }\n    };\n    OverlayOp.prototype.getGraph = function getGraph() {\n        return this._graph;\n    };\n    OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges() {\n        for(var it = this._graph.getEdgeEnds().iterator(); it.hasNext();){\n            var de = it.next();\n            var sym = de.getSym();\n            if (de.isInResult() && sym.isInResult()) {\n                de.setInResult(false);\n                sym.setInResult(false);\n            }\n        }\n    };\n    OverlayOp.prototype.isCoveredByLA = function isCoveredByLA(coord) {\n        if (this.isCovered(coord, this._resultLineList)) {\n            return true;\n        }\n        if (this.isCovered(coord, this._resultPolyList)) {\n            return true;\n        }\n        return false;\n    };\n    OverlayOp.prototype.computeGeometry = function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n        var geomList = new ArrayList();\n        geomList.addAll(resultPointList);\n        geomList.addAll(resultLineList);\n        geomList.addAll(resultPolyList);\n        if (geomList.isEmpty()) {\n            return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n        }\n        return this._geomFact.buildGeometry(geomList);\n    };\n    OverlayOp.prototype.mergeSymLabels = function mergeSymLabels() {\n        for(var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){\n            var node = nodeit.next();\n            node.getEdges().mergeSymLabels();\n        }\n    };\n    OverlayOp.prototype.isCovered = function isCovered(coord, geomList) {\n        var this$1 = this;\n        for(var it = geomList.iterator(); it.hasNext();){\n            var geom = it.next();\n            var loc = this$1._ptLocator.locate(coord, geom);\n            if (loc !== Location.EXTERIOR) {\n                return true;\n            }\n        }\n        return false;\n    };\n    OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges() {\n        var newEdges = new ArrayList();\n        for(var it = this._edgeList.iterator(); it.hasNext();){\n            var e = it.next();\n            if (e.isCollapsed()) {\n                it.remove();\n                newEdges.add(e.getCollapsedEdge());\n            }\n        }\n        this._edgeList.addAll(newEdges);\n    };\n    OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling() {\n        for(var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){\n            var node = nodeit.next();\n            var lbl = node.getEdges().getLabel();\n            node.getLabel().merge(lbl);\n        }\n    };\n    OverlayOp.prototype.getResultGeometry = function getResultGeometry(overlayOpCode) {\n        this.computeOverlay(overlayOpCode);\n        return this._resultGeom;\n    };\n    OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges(edges) {\n        var this$1 = this;\n        for(var i = edges.iterator(); i.hasNext();){\n            var e = i.next();\n            this$1.insertUniqueEdge(e);\n        }\n    };\n    OverlayOp.prototype.computeOverlay = function computeOverlay(opCode) {\n        this.copyPoints(0);\n        this.copyPoints(1);\n        this._arg[0].computeSelfNodes(this._li, false);\n        this._arg[1].computeSelfNodes(this._li, false);\n        this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n        var baseSplitEdges = new ArrayList();\n        this._arg[0].computeSplitEdges(baseSplitEdges);\n        this._arg[1].computeSplitEdges(baseSplitEdges);\n        // const splitEdges = baseSplitEdges\n        this.insertUniqueEdges(baseSplitEdges);\n        this.computeLabelsFromDepths();\n        this.replaceCollapsedEdges();\n        EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n        this._graph.addEdges(this._edgeList.getEdges());\n        this.computeLabelling();\n        this.labelIncompleteNodes();\n        this.findResultAreaEdges(opCode);\n        this.cancelDuplicateResultEdges();\n        var polyBuilder = new PolygonBuilder(this._geomFact);\n        polyBuilder.add(this._graph);\n        this._resultPolyList = polyBuilder.getPolygons();\n        var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n        this._resultLineList = lineBuilder.build(opCode);\n        var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n        this._resultPointList = pointBuilder.build(opCode);\n        this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n    };\n    OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode(n, targetIndex) {\n        var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n        n.getLabel().setLocation(targetIndex, loc);\n    };\n    OverlayOp.prototype.copyPoints = function copyPoints(argIndex) {\n        var this$1 = this;\n        for(var i = this._arg[argIndex].getNodeIterator(); i.hasNext();){\n            var graphNode = i.next();\n            var newNode = this$1._graph.addNode(graphNode.getCoordinate());\n            newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n        }\n    };\n    OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges(opCode) {\n        for(var it = this._graph.getEdgeEnds().iterator(); it.hasNext();){\n            var de = it.next();\n            var label = de.getLabel();\n            if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n                de.setInResult(true);\n            }\n        }\n    };\n    OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths() {\n        for(var it = this._edgeList.iterator(); it.hasNext();){\n            var e = it.next();\n            var lbl = e.getLabel();\n            var depth = e.getDepth();\n            if (!depth.isNull()) {\n                depth.normalize();\n                for(var i = 0; i < 2; i++){\n                    if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n                        if (depth.getDelta(i) === 0) {\n                            lbl.toLine(i);\n                        } else {\n                            Assert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n                            lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n                            Assert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n                            lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n                        }\n                    }\n                }\n            }\n        }\n    };\n    OverlayOp.prototype.computeLabelling = function computeLabelling() {\n        var this$1 = this;\n        for(var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){\n            var node = nodeit.next();\n            node.getEdges().computeLabelling(this$1._arg);\n        }\n        this.mergeSymLabels();\n        this.updateNodeLabelling();\n    };\n    OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes() {\n        var this$1 = this;\n        // let nodeCount = 0\n        for(var ni = this._graph.getNodes().iterator(); ni.hasNext();){\n            var n = ni.next();\n            var label = n.getLabel();\n            if (n.isIsolated()) {\n                // nodeCount++\n                if (label.isNull(0)) {\n                    this$1.labelIncompleteNode(n, 0);\n                } else {\n                    this$1.labelIncompleteNode(n, 1);\n                }\n            }\n            n.getEdges().updateLabelling(label);\n        }\n    };\n    OverlayOp.prototype.isCoveredByA = function isCoveredByA(coord) {\n        if (this.isCovered(coord, this._resultPolyList)) {\n            return true;\n        }\n        return false;\n    };\n    OverlayOp.prototype.interfaces_ = function interfaces_() {\n        return [];\n    };\n    OverlayOp.prototype.getClass = function getClass() {\n        return OverlayOp;\n    };\n    return OverlayOp;\n}(GeometryGraphOp);\nOverlayOp.overlayOp = function(geom0, geom1, opCode) {\n    var gov = new OverlayOp(geom0, geom1);\n    var geomOv = gov.getResultGeometry(opCode);\n    return geomOv;\n};\nOverlayOp.intersection = function(g, other) {\n    if (g.isEmpty() || other.isEmpty()) {\n        return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());\n    }\n    if (g.isGeometryCollection()) {\n        var g2 = other;\n        return GeometryCollectionMapper.map(g, {\n            interfaces_: function() {\n                return [\n                    GeometryMapper.MapOp\n                ];\n            },\n            map: function(g) {\n                return g.intersection(g2);\n            }\n        });\n    }\n    g.checkNotGeometryCollection(g);\n    g.checkNotGeometryCollection(other);\n    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);\n};\nOverlayOp.symDifference = function(g, other) {\n    if (g.isEmpty() || other.isEmpty()) {\n        if (g.isEmpty() && other.isEmpty()) {\n            return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());\n        }\n        if (g.isEmpty()) {\n            return other.copy();\n        }\n        if (other.isEmpty()) {\n            return g.copy();\n        }\n    }\n    g.checkNotGeometryCollection(g);\n    g.checkNotGeometryCollection(other);\n    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);\n};\nOverlayOp.resultDimension = function(opCode, g0, g1) {\n    var dim0 = g0.getDimension();\n    var dim1 = g1.getDimension();\n    var resultDimension = -1;\n    switch(opCode){\n        case OverlayOp.INTERSECTION:\n            resultDimension = Math.min(dim0, dim1);\n            break;\n        case OverlayOp.UNION:\n            resultDimension = Math.max(dim0, dim1);\n            break;\n        case OverlayOp.DIFFERENCE:\n            resultDimension = dim0;\n            break;\n        case OverlayOp.SYMDIFFERENCE:\n            resultDimension = Math.max(dim0, dim1);\n            break;\n        default:\n    }\n    return resultDimension;\n};\nOverlayOp.createEmptyResult = function(overlayOpCode, a, b, geomFact) {\n    var result = null;\n    switch(OverlayOp.resultDimension(overlayOpCode, a, b)){\n        case -1:\n            result = geomFact.createGeometryCollection(new Array(0).fill(null));\n            break;\n        case 0:\n            result = geomFact.createPoint();\n            break;\n        case 1:\n            result = geomFact.createLineString();\n            break;\n        case 2:\n            result = geomFact.createPolygon();\n            break;\n        default:\n    }\n    return result;\n};\nOverlayOp.difference = function(g, other) {\n    if (g.isEmpty()) {\n        return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());\n    }\n    if (other.isEmpty()) {\n        return g.copy();\n    }\n    g.checkNotGeometryCollection(g);\n    g.checkNotGeometryCollection(other);\n    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);\n};\nOverlayOp.isResultOfOp = function() {\n    if (arguments.length === 2) {\n        var label = arguments[0];\n        var opCode = arguments[1];\n        var loc0 = label.getLocation(0);\n        var loc1 = label.getLocation(1);\n        return OverlayOp.isResultOfOp(loc0, loc1, opCode);\n    } else if (arguments.length === 3) {\n        var loc0$1 = arguments[0];\n        var loc1$1 = arguments[1];\n        var overlayOpCode = arguments[2];\n        if (loc0$1 === Location.BOUNDARY) {\n            loc0$1 = Location.INTERIOR;\n        }\n        if (loc1$1 === Location.BOUNDARY) {\n            loc1$1 = Location.INTERIOR;\n        }\n        switch(overlayOpCode){\n            case OverlayOp.INTERSECTION:\n                return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR;\n            case OverlayOp.UNION:\n                return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR;\n            case OverlayOp.DIFFERENCE:\n                return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR;\n            case OverlayOp.SYMDIFFERENCE:\n                return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR || loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR;\n            default:\n        }\n        return false;\n    }\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\nvar FuzzyPointLocator = function FuzzyPointLocator() {\n    this._g = null;\n    this._boundaryDistanceTolerance = null;\n    this._linework = null;\n    this._ptLocator = new PointLocator();\n    this._seg = new LineSegment();\n    var g = arguments[0];\n    var boundaryDistanceTolerance = arguments[1];\n    this._g = g;\n    this._boundaryDistanceTolerance = boundaryDistanceTolerance;\n    this._linework = this.extractLinework(g);\n};\nFuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary(pt) {\n    var this$1 = this;\n    for(var i = 0; i < this._linework.getNumGeometries(); i++){\n        var line = this$1._linework.getGeometryN(i);\n        var seq = line.getCoordinateSequence();\n        for(var j = 0; j < seq.size() - 1; j++){\n            seq.getCoordinate(j, this$1._seg.p0);\n            seq.getCoordinate(j + 1, this$1._seg.p1);\n            var dist = this$1._seg.distance(pt);\n            if (dist <= this$1._boundaryDistanceTolerance) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\nFuzzyPointLocator.prototype.getLocation = function getLocation(pt) {\n    if (this.isWithinToleranceOfBoundary(pt)) {\n        return Location.BOUNDARY;\n    }\n    return this._ptLocator.locate(pt, this._g);\n};\nFuzzyPointLocator.prototype.extractLinework = function extractLinework(g) {\n    var extracter = new PolygonalLineworkExtracter();\n    g.apply(extracter);\n    var linework = extracter.getLinework();\n    var lines = GeometryFactory.toLineStringArray(linework);\n    return g.getFactory().createMultiLineString(lines);\n};\nFuzzyPointLocator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nFuzzyPointLocator.prototype.getClass = function getClass() {\n    return FuzzyPointLocator;\n};\nvar PolygonalLineworkExtracter = function PolygonalLineworkExtracter() {\n    this._linework = null;\n    this._linework = new ArrayList();\n};\nPolygonalLineworkExtracter.prototype.getLinework = function getLinework() {\n    return this._linework;\n};\nPolygonalLineworkExtracter.prototype.filter = function filter(g) {\n    var this$1 = this;\n    if (g instanceof Polygon) {\n        var poly = g;\n        this._linework.add(poly.getExteriorRing());\n        for(var i = 0; i < poly.getNumInteriorRing(); i++){\n            this$1._linework.add(poly.getInteriorRingN(i));\n        }\n    }\n};\nPolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_() {\n    return [\n        GeometryFilter\n    ];\n};\nPolygonalLineworkExtracter.prototype.getClass = function getClass() {\n    return PolygonalLineworkExtracter;\n};\nvar OffsetPointGenerator = function OffsetPointGenerator() {\n    this._g = null;\n    this._doLeft = true;\n    this._doRight = true;\n    var g = arguments[0];\n    this._g = g;\n};\nOffsetPointGenerator.prototype.extractPoints = function extractPoints(line, offsetDistance, offsetPts) {\n    var this$1 = this;\n    var pts = line.getCoordinates();\n    for(var i = 0; i < pts.length - 1; i++){\n        this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);\n    }\n};\nOffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate(doLeft, doRight) {\n    this._doLeft = doLeft;\n    this._doRight = doRight;\n};\nOffsetPointGenerator.prototype.getPoints = function getPoints(offsetDistance) {\n    var this$1 = this;\n    var offsetPts = new ArrayList();\n    var lines = LinearComponentExtracter.getLines(this._g);\n    for(var i = lines.iterator(); i.hasNext();){\n        var line = i.next();\n        this$1.extractPoints(line, offsetDistance, offsetPts);\n    }\n    return offsetPts;\n};\nOffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints(p0, p1, offsetDistance, offsetPts) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    var len = Math.sqrt(dx * dx + dy * dy);\n    var ux = offsetDistance * dx / len;\n    var uy = offsetDistance * dy / len;\n    var midX = (p1.x + p0.x) / 2;\n    var midY = (p1.y + p0.y) / 2;\n    if (this._doLeft) {\n        var offsetLeft = new Coordinate(midX - uy, midY + ux);\n        offsetPts.add(offsetLeft);\n    }\n    if (this._doRight) {\n        var offsetRight = new Coordinate(midX + uy, midY - ux);\n        offsetPts.add(offsetRight);\n    }\n};\nOffsetPointGenerator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOffsetPointGenerator.prototype.getClass = function getClass() {\n    return OffsetPointGenerator;\n};\nvar OverlayResultValidator = function OverlayResultValidator() {\n    this._geom = null;\n    this._locFinder = null;\n    this._location = new Array(3).fill(null);\n    this._invalidLocation = null;\n    this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;\n    this._testCoords = new ArrayList();\n    var a = arguments[0];\n    var b = arguments[1];\n    var result = arguments[2];\n    this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);\n    this._geom = [\n        a,\n        b,\n        result\n    ];\n    this._locFinder = [\n        new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance),\n        new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance),\n        new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)\n    ];\n};\nvar staticAccessors$46 = {\n    TOLERANCE: {\n        configurable: true\n    }\n};\nOverlayResultValidator.prototype.reportResult = function reportResult(overlayOp, location, expectedInterior) {\n    System.out.println(\"Overlay result invalid - A:\" + Location.toLocationSymbol(location[0]) + \" B:\" + Location.toLocationSymbol(location[1]) + \" expected:\" + (expectedInterior ? \"i\" : \"e\") + \" actual:\" + Location.toLocationSymbol(location[2]));\n};\nOverlayResultValidator.prototype.isValid = function isValid(overlayOp) {\n    this.addTestPts(this._geom[0]);\n    this.addTestPts(this._geom[1]);\n    var isValid = this.checkValid(overlayOp);\n    return isValid;\n};\nOverlayResultValidator.prototype.checkValid = function checkValid() {\n    var this$1 = this;\n    if (arguments.length === 1) {\n        var overlayOp = arguments[0];\n        for(var i = 0; i < this._testCoords.size(); i++){\n            var pt = this$1._testCoords.get(i);\n            if (!this$1.checkValid(overlayOp, pt)) {\n                this$1._invalidLocation = pt;\n                return false;\n            }\n        }\n        return true;\n    } else if (arguments.length === 2) {\n        var overlayOp$1 = arguments[0];\n        var pt$1 = arguments[1];\n        this._location[0] = this._locFinder[0].getLocation(pt$1);\n        this._location[1] = this._locFinder[1].getLocation(pt$1);\n        this._location[2] = this._locFinder[2].getLocation(pt$1);\n        if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) {\n            return true;\n        }\n        return this.isValidResult(overlayOp$1, this._location);\n    }\n};\nOverlayResultValidator.prototype.addTestPts = function addTestPts(g) {\n    var ptGen = new OffsetPointGenerator(g);\n    this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));\n};\nOverlayResultValidator.prototype.isValidResult = function isValidResult(overlayOp, location) {\n    var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);\n    var resultInInterior = location[2] === Location.INTERIOR;\n    var isValid = !(expectedInterior ^ resultInInterior);\n    if (!isValid) {\n        this.reportResult(overlayOp, location, expectedInterior);\n    }\n    return isValid;\n};\nOverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation() {\n    return this._invalidLocation;\n};\nOverlayResultValidator.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nOverlayResultValidator.prototype.getClass = function getClass() {\n    return OverlayResultValidator;\n};\nOverlayResultValidator.hasLocation = function hasLocation(location, loc) {\n    for(var i = 0; i < 3; i++){\n        if (location[i] === loc) {\n            return true;\n        }\n    }\n    return false;\n};\nOverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance(g0, g1) {\n    return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1));\n};\nOverlayResultValidator.isValid = function isValid(a, b, overlayOp, result) {\n    var validator = new OverlayResultValidator(a, b, result);\n    return validator.isValid(overlayOp);\n};\nstaticAccessors$46.TOLERANCE.get = function() {\n    return 0.000001;\n};\nObject.defineProperties(OverlayResultValidator, staticAccessors$46);\n// operation.overlay\nvar GeometryCombiner = function GeometryCombiner(geoms) {\n    this._geomFactory = null;\n    this._skipEmpty = false;\n    this._inputGeoms = null;\n    this._geomFactory = GeometryCombiner.extractFactory(geoms);\n    this._inputGeoms = geoms;\n};\nGeometryCombiner.prototype.extractElements = function extractElements(geom, elems) {\n    var this$1 = this;\n    if (geom === null) {\n        return null;\n    }\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var elemGeom = geom.getGeometryN(i);\n        if (this$1._skipEmpty && elemGeom.isEmpty()) {\n            continue;\n        }\n        elems.add(elemGeom);\n    }\n};\nGeometryCombiner.prototype.combine = function combine() {\n    var this$1 = this;\n    var elems = new ArrayList();\n    for(var i = this._inputGeoms.iterator(); i.hasNext();){\n        var g = i.next();\n        this$1.extractElements(g, elems);\n    }\n    if (elems.size() === 0) {\n        if (this._geomFactory !== null) {\n            return this._geomFactory.createGeometryCollection(null);\n        }\n        return null;\n    }\n    return this._geomFactory.buildGeometry(elems);\n};\nGeometryCombiner.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nGeometryCombiner.prototype.getClass = function getClass() {\n    return GeometryCombiner;\n};\nGeometryCombiner.combine = function combine() {\n    if (arguments.length === 1) {\n        var geoms = arguments[0];\n        var combiner = new GeometryCombiner(geoms);\n        return combiner.combine();\n    } else if (arguments.length === 2) {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n        return combiner$1.combine();\n    } else if (arguments.length === 3) {\n        var g0$1 = arguments[0];\n        var g1$1 = arguments[1];\n        var g2 = arguments[2];\n        var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));\n        return combiner$2.combine();\n    }\n};\nGeometryCombiner.extractFactory = function extractFactory(geoms) {\n    if (geoms.isEmpty()) {\n        return null;\n    }\n    return geoms.iterator().next().getFactory();\n};\nGeometryCombiner.createList = function createList() {\n    if (arguments.length === 2) {\n        var obj0 = arguments[0];\n        var obj1 = arguments[1];\n        var list = new ArrayList();\n        list.add(obj0);\n        list.add(obj1);\n        return list;\n    } else if (arguments.length === 3) {\n        var obj0$1 = arguments[0];\n        var obj1$1 = arguments[1];\n        var obj2 = arguments[2];\n        var list$1 = new ArrayList();\n        list$1.add(obj0$1);\n        list$1.add(obj1$1);\n        list$1.add(obj2);\n        return list$1;\n    }\n};\nvar CascadedPolygonUnion = function CascadedPolygonUnion() {\n    this._inputPolys = null;\n    this._geomFactory = null;\n    var polys = arguments[0];\n    this._inputPolys = polys;\n    if (this._inputPolys === null) {\n        this._inputPolys = new ArrayList();\n    }\n};\nvar staticAccessors$47 = {\n    STRTREE_NODE_CAPACITY: {\n        configurable: true\n    }\n};\nCascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries(geomTree) {\n    var this$1 = this;\n    var geoms = new ArrayList();\n    for(var i = geomTree.iterator(); i.hasNext();){\n        var o = i.next();\n        var geom = null;\n        if (hasInterface(o, List)) {\n            geom = this$1.unionTree(o);\n        } else if (o instanceof Geometry) {\n            geom = o;\n        }\n        geoms.add(geom);\n    }\n    return geoms;\n};\nCascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope(env, geom, disjointGeoms) {\n    var intersectingGeoms = new ArrayList();\n    for(var i = 0; i < geom.getNumGeometries(); i++){\n        var elem = geom.getGeometryN(i);\n        if (elem.getEnvelopeInternal().intersects(env)) {\n            intersectingGeoms.add(elem);\n        } else {\n            disjointGeoms.add(elem);\n        }\n    }\n    return this._geomFactory.buildGeometry(intersectingGeoms);\n};\nCascadedPolygonUnion.prototype.unionOptimized = function unionOptimized(g0, g1) {\n    var g0Env = g0.getEnvelopeInternal();\n    var g1Env = g1.getEnvelopeInternal();\n    if (!g0Env.intersects(g1Env)) {\n        var combo = GeometryCombiner.combine(g0, g1);\n        return combo;\n    }\n    if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) {\n        return this.unionActual(g0, g1);\n    }\n    var commonEnv = g0Env.intersection(g1Env);\n    return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n};\nCascadedPolygonUnion.prototype.union = function union() {\n    if (this._inputPolys === null) {\n        throw new Error(\"union() method cannot be called twice\");\n    }\n    if (this._inputPolys.isEmpty()) {\n        return null;\n    }\n    this._geomFactory = this._inputPolys.iterator().next().getFactory();\n    var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n    for(var i = this._inputPolys.iterator(); i.hasNext();){\n        var item = i.next();\n        index.insert(item.getEnvelopeInternal(), item);\n    }\n    this._inputPolys = null;\n    var itemTree = index.itemsTree();\n    var unionAll = this.unionTree(itemTree);\n    return unionAll;\n};\nCascadedPolygonUnion.prototype.binaryUnion = function binaryUnion() {\n    if (arguments.length === 1) {\n        var geoms = arguments[0];\n        return this.binaryUnion(geoms, 0, geoms.size());\n    } else if (arguments.length === 3) {\n        var geoms$1 = arguments[0];\n        var start = arguments[1];\n        var end = arguments[2];\n        if (end - start <= 1) {\n            var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);\n            return this.unionSafe(g0, null);\n        } else if (end - start === 2) {\n            return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1));\n        } else {\n            var mid = Math.trunc((end + start) / 2);\n            var g0$1 = this.binaryUnion(geoms$1, start, mid);\n            var g1 = this.binaryUnion(geoms$1, mid, end);\n            return this.unionSafe(g0$1, g1);\n        }\n    }\n};\nCascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion(geoms) {\n    var union = null;\n    for(var i = geoms.iterator(); i.hasNext();){\n        var g = i.next();\n        if (union === null) {\n            union = g.copy();\n        } else {\n            union = union.union(g);\n        }\n    }\n    return union;\n};\nCascadedPolygonUnion.prototype.unionSafe = function unionSafe(g0, g1) {\n    if (g0 === null && g1 === null) {\n        return null;\n    }\n    if (g0 === null) {\n        return g1.copy();\n    }\n    if (g1 === null) {\n        return g0.copy();\n    }\n    return this.unionOptimized(g0, g1);\n};\nCascadedPolygonUnion.prototype.unionActual = function unionActual(g0, g1) {\n    return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n};\nCascadedPolygonUnion.prototype.unionTree = function unionTree(geomTree) {\n    var geoms = this.reduceToGeometries(geomTree);\n    var union = this.binaryUnion(geoms);\n    return union;\n};\nCascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection(g0, g1, common) {\n    var disjointPolys = new ArrayList();\n    var g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n    var g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n    var union = this.unionActual(g0Int, g1Int);\n    disjointPolys.add(union);\n    var overallUnion = GeometryCombiner.combine(disjointPolys);\n    return overallUnion;\n};\nCascadedPolygonUnion.prototype.bufferUnion = function bufferUnion() {\n    if (arguments.length === 1) {\n        var geoms = arguments[0];\n        var factory = geoms.get(0).getFactory();\n        var gColl = factory.buildGeometry(geoms);\n        var unionAll = gColl.buffer(0.0);\n        return unionAll;\n    } else if (arguments.length === 2) {\n        var g0 = arguments[0];\n        var g1 = arguments[1];\n        var factory$1 = g0.getFactory();\n        var gColl$1 = factory$1.createGeometryCollection([\n            g0,\n            g1\n        ]);\n        var unionAll$1 = gColl$1.buffer(0.0);\n        return unionAll$1;\n    }\n};\nCascadedPolygonUnion.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nCascadedPolygonUnion.prototype.getClass = function getClass() {\n    return CascadedPolygonUnion;\n};\nCascadedPolygonUnion.restrictToPolygons = function restrictToPolygons(g) {\n    if (hasInterface(g, Polygonal)) {\n        return g;\n    }\n    var polygons = PolygonExtracter.getPolygons(g);\n    if (polygons.size() === 1) {\n        return polygons.get(0);\n    }\n    return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n};\nCascadedPolygonUnion.getGeometry = function getGeometry(list, index) {\n    if (index >= list.size()) {\n        return null;\n    }\n    return list.get(index);\n};\nCascadedPolygonUnion.union = function union(polys) {\n    var op = new CascadedPolygonUnion(polys);\n    return op.union();\n};\nstaticAccessors$47.STRTREE_NODE_CAPACITY.get = function() {\n    return 4;\n};\nObject.defineProperties(CascadedPolygonUnion, staticAccessors$47);\nvar UnionOp = function UnionOp() {};\nUnionOp.prototype.interfaces_ = function interfaces_() {\n    return [];\n};\nUnionOp.prototype.getClass = function getClass() {\n    return UnionOp;\n};\nUnionOp.union = function union(g, other) {\n    if (g.isEmpty() || other.isEmpty()) {\n        if (g.isEmpty() && other.isEmpty()) {\n            return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n        }\n        if (g.isEmpty()) {\n            return other.copy();\n        }\n        if (other.isEmpty()) {\n            return g.copy();\n        }\n    }\n    g.checkNotGeometryCollection(g);\n    g.checkNotGeometryCollection(other);\n    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n};\n// operation.union\n// operation\n/**\n * Polyfill for IE support\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHVyZi1qc3RzL2pzdHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozt3Q0FHd0MsR0FFeEMsSUFBSSxDQUFFLFdBQVVBLE1BQU1DLFNBQVMsR0FBRztJQUNoQ0MsT0FBT0MsY0FBYyxDQUFDSCxNQUFNQyxTQUFTLEVBQUUsUUFBUTtRQUM3Q0csY0FBYztRQUNkQyxPQUFPLFNBQVNDLEtBQU1ELEtBQUs7WUFDekIsSUFBSSxJQUFJLEtBQUtFLGFBQWEsSUFBSSxLQUFLLE1BQU07Z0JBQ3ZDLE1BQU0sSUFBSUMsVUFBVSxJQUFJLEdBQUc7WUFDN0I7WUFFQSxJQUFJQyxZQUFZUCxPQUFPLElBQUk7WUFFM0IsSUFBSVEsU0FBU0MsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNKLFVBQVVDLE1BQU0sRUFBRSxtQkFBbUIsTUFBTTtZQUUxRSxJQUFJSSxnQkFBZ0IsS0FBS0MsWUFBWUMsU0FBU0MsT0FBT0YsU0FBUyxDQUFDLEVBQUUsR0FBRyxPQUFPLElBQUk7WUFFL0VELGdCQUFnQkEsZ0JBQWdCLElBQUlILEtBQUtDLEdBQUcsQ0FBQ0YsU0FBU0ksZUFBZSxLQUFLSCxLQUFLRSxHQUFHLENBQUNDLGVBQWVKO1lBRWxHLElBQUlRLGNBQWMsS0FBS0gsYUFBYUEsU0FBUyxDQUFDLEVBQUUsS0FBS1IsWUFBWVMsU0FBU0MsT0FBT0YsU0FBUyxDQUFDLEVBQUUsR0FBRyxPQUFPLElBQUlMO1lBRTNHUSxjQUFjQSxjQUFjLElBQUlQLEtBQUtDLEdBQUcsQ0FBQ0YsU0FBU0ssU0FBUyxDQUFDLEVBQUUsRUFBRSxLQUFLSixLQUFLRSxHQUFHLENBQUNLLGFBQWFSO1lBRTNGLE1BQU9JLGdCQUFnQkksWUFBYTtnQkFDbENULFNBQVMsQ0FBQ0ssY0FBYyxHQUFHVDtnQkFFM0IsRUFBRVM7WUFDSjtZQUVBLE9BQU9MO1FBQ1Q7UUFDQVUsVUFBVTtJQUNaO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNERixPQUFPRyxRQUFRLEdBQUdILE9BQU9HLFFBQVEsSUFBSSxTQUFVZixLQUFLO0lBQ2xELE9BQU8sT0FBT0EsVUFBVSxZQUFZZSxTQUFTZjtBQUMvQztBQUVBWSxPQUFPSSxTQUFTLEdBQUdKLE9BQU9JLFNBQVMsSUFBSSxTQUFVQyxHQUFHO0lBQ2xELE9BQU8sT0FBT0EsUUFBUSxZQUN0QkYsU0FBU0UsUUFDVFgsS0FBS1ksS0FBSyxDQUFDRCxTQUFTQTtBQUN0QjtBQUVBTCxPQUFPTyxVQUFVLEdBQUdQLE9BQU9PLFVBQVUsSUFBSUE7QUFFekNQLE9BQU9RLEtBQUssR0FBR1IsT0FBT1EsS0FBSyxJQUFJLFNBQVVwQixLQUFLO0lBQzVDLE9BQU9BLFVBQVVBLE1BQU0sc0JBQXNCOztBQUMvQztBQUVBOztDQUVDLEdBQ0RNLEtBQUtlLEtBQUssR0FBR2YsS0FBS2UsS0FBSyxJQUFJLFNBQVVDLENBQUM7SUFDcEMsT0FBT0EsSUFBSSxJQUFJaEIsS0FBS2lCLElBQUksQ0FBQ0QsS0FBS2hCLEtBQUtZLEtBQUssQ0FBQ0k7QUFDM0M7QUFFQSxJQUFJRSxhQUFhLFNBQVNBLGNBQWU7QUFFekNBLFdBQVc1QixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDMUMsT0FBTyxFQUFFO0FBQ1g7QUFDQUQsV0FBVzVCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN2QyxPQUFPRjtBQUNUO0FBQ0FBLFdBQVc1QixTQUFTLENBQUMrQixtQkFBbUIsR0FBRyxTQUFTQSxvQkFBcUJDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQ3hGLE9BQU94QixLQUFLeUIsR0FBRyxDQUFDSCxLQUFLQyxPQUFPQztBQUM5QjtBQUVBLElBQUlFLDJCQUE0QixTQUFVQyxNQUFLO0lBQzlDLFNBQVNELHlCQUEwQkUsT0FBTztRQUN6Q0QsT0FBTUUsSUFBSSxDQUFDLElBQUksRUFBRUQ7UUFDakIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNGLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNHLEtBQUssR0FBRyxJQUFLSixTQUFTSSxLQUFLO0lBQ2pDO0lBRUEsSUFBS0osUUFBUUQseUJBQXlCTSxTQUFTLEdBQUdMO0lBQ2xERCx5QkFBeUJwQyxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUVOLFVBQVNBLE9BQU1yQyxTQUFTO0lBQzVFb0MseUJBQXlCcEMsU0FBUyxDQUFDNEMsV0FBVyxHQUFHUjtJQUVqRCxPQUFPQTtBQUNSLEVBQUVDO0FBRUYsSUFBSVEsU0FBUyxTQUFTQSxVQUFXO0FBRWpDLElBQUlDLG9CQUFvQjtJQUFFQyxXQUFXO1FBQUU1QyxjQUFjO0lBQUs7QUFBRTtBQUU1RDBDLE9BQU9yQixLQUFLLEdBQUcsU0FBU0EsTUFBT3dCLENBQUM7SUFBSSxPQUFPaEMsT0FBT1EsS0FBSyxDQUFDd0I7QUFBRztBQUMzREgsT0FBT0ksZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCRCxDQUFDO0lBQUksT0FBT0E7QUFBRTtBQUNuRUgsT0FBT0ssZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCRixDQUFDO0lBQUksT0FBT0E7QUFBRTtBQUNuRUgsT0FBT00sVUFBVSxHQUFHLFNBQVNBLFdBQVlILENBQUM7SUFBSSxPQUFPLENBQUNoQyxPQUFPRyxRQUFRLENBQUM2QjtBQUFHO0FBQ3pFRixrQkFBa0JDLFNBQVMsQ0FBQ0ssR0FBRyxHQUFHO0lBQWMsT0FBT3BDLE9BQU8rQixTQUFTO0FBQUM7QUFFeEU5QyxPQUFPb0QsZ0JBQWdCLENBQUVSLFFBQVFDO0FBRWpDLElBQUlRLGFBQWEsU0FBU0EsY0FBZTtBQUV6QyxJQUFJQyxXQUFXLFNBQVNBLFlBQWE7QUFFckMsSUFBSUMsYUFBYSxTQUFTQSxjQUFlO0FBRXpDLFNBQVNDLGdCQUFpQjtBQUUxQixzQ0FBc0M7QUFFdEMsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJLENBQUNoQyxDQUFDLEdBQUc7SUFDVCxJQUFJLENBQUNpQyxDQUFDLEdBQUc7SUFDVCxJQUFJLENBQUNDLENBQUMsR0FBRztJQUNULElBQUk5QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUNpQixDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNpQyxDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0YsV0FBV0csYUFBYTtJQUNuQyxPQUFPLElBQUkvQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJcUQsSUFBSWhELFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQ1ksQ0FBQyxHQUFHb0MsRUFBRXBDLENBQUM7UUFDWixJQUFJLENBQUNpQyxDQUFDLEdBQUdHLEVBQUVILENBQUM7UUFDWixJQUFJLENBQUNDLENBQUMsR0FBR0UsRUFBRUYsQ0FBQztJQUNkLE9BQU8sSUFBSTlDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUksQ0FBQ2lCLENBQUMsR0FBR1osU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDNkMsQ0FBQyxHQUFHN0MsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDOEMsQ0FBQyxHQUFHRixXQUFXRyxhQUFhO0lBQ25DLE9BQU8sSUFBSS9DLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUksQ0FBQ2lCLENBQUMsR0FBR1osU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDNkMsQ0FBQyxHQUFHN0MsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDOEMsQ0FBQyxHQUFHOUMsU0FBUyxDQUFDLEVBQUU7SUFDdkI7QUFDRjtBQUVBLElBQUlpRCxrQkFBa0I7SUFBRUMsdUJBQXVCO1FBQUU3RCxjQUFjO0lBQUs7SUFBRThELGtCQUFrQjtRQUFFOUQsY0FBYztJQUFLO0lBQUUwRCxlQUFlO1FBQUUxRCxjQUFjO0lBQUs7SUFBRStELEdBQUc7UUFBRS9ELGNBQWM7SUFBSztJQUFFZ0UsR0FBRztRQUFFaEUsY0FBYztJQUFLO0lBQUVpRSxHQUFHO1FBQUVqRSxjQUFjO0lBQUs7QUFBRTtBQUNuT3VELFdBQVcxRCxTQUFTLENBQUNxRSxXQUFXLEdBQUcsU0FBU0EsWUFBYUMsYUFBYSxFQUFFbEUsS0FBSztJQUMzRSxPQUFRa0U7UUFDTixLQUFLWixXQUFXUSxDQUFDO1lBQ2YsSUFBSSxDQUFDeEMsQ0FBQyxHQUFHdEI7WUFDVDtRQUNGLEtBQUtzRCxXQUFXUyxDQUFDO1lBQ2YsSUFBSSxDQUFDUixDQUFDLEdBQUd2RDtZQUNUO1FBQ0YsS0FBS3NELFdBQVdVLENBQUM7WUFDZixJQUFJLENBQUNSLENBQUMsR0FBR3hEO1lBQ1Q7UUFDRjtZQUNFLE1BQU0sSUFBSWdDLHlCQUF5Qiw2QkFBNkJrQztJQUNwRTtBQUNGO0FBQ0FaLFdBQVcxRCxTQUFTLENBQUN1RSxRQUFRLEdBQUcsU0FBU0E7SUFDdkMsSUFBSXpELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkrRCxRQUFRMUQsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSSxJQUFJLENBQUNZLENBQUMsS0FBSzhDLE1BQU05QyxDQUFDLEVBQUU7WUFDdEIsT0FBTztRQUNUO1FBQ0EsSUFBSSxJQUFJLENBQUNpQyxDQUFDLEtBQUthLE1BQU1iLENBQUMsRUFBRTtZQUN0QixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1QsT0FBTyxJQUFJN0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXFELElBQUloRCxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJb0IsWUFBWXBCLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUksQ0FBQ2MsV0FBV0csbUJBQW1CLENBQUMsSUFBSSxDQUFDTCxDQUFDLEVBQUVvQyxFQUFFcEMsQ0FBQyxFQUFFUSxZQUFZO1lBQzNELE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQ04sV0FBV0csbUJBQW1CLENBQUMsSUFBSSxDQUFDNEIsQ0FBQyxFQUFFRyxFQUFFSCxDQUFDLEVBQUV6QixZQUFZO1lBQzNELE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtBQUNGO0FBQ0F3QixXQUFXMUQsU0FBUyxDQUFDeUUsV0FBVyxHQUFHLFNBQVNBLFlBQWFILGFBQWE7SUFDcEUsT0FBUUE7UUFDTixLQUFLWixXQUFXUSxDQUFDO1lBQ2YsT0FBTyxJQUFJLENBQUN4QyxDQUFDO1FBQ2YsS0FBS2dDLFdBQVdTLENBQUM7WUFDZixPQUFPLElBQUksQ0FBQ1IsQ0FBQztRQUNmLEtBQUtELFdBQVdVLENBQUM7WUFDZixPQUFPLElBQUksQ0FBQ1IsQ0FBQztRQUNmO0lBQ0Y7SUFDQSxNQUFNLElBQUl4Qix5QkFBeUIsNkJBQTZCa0M7QUFDbEU7QUFDQVosV0FBVzFELFNBQVMsQ0FBQzBFLFFBQVEsR0FBRyxTQUFTQSxTQUFVRixLQUFLO0lBQ3RELE9BQU8sSUFBSSxDQUFDOUMsQ0FBQyxLQUFLOEMsTUFBTTlDLENBQUMsSUFDbEIsSUFBSSxDQUFDaUMsQ0FBQyxLQUFLYSxNQUFNYixDQUFDLElBQ2pCLENBQUMsSUFBSSxDQUFDQyxDQUFDLEtBQUtZLE1BQU1aLENBQUMsSUFBSWYsT0FBT3JCLEtBQUssQ0FBQyxJQUFJLENBQUNvQyxDQUFDLE1BQzNDZixPQUFPckIsS0FBSyxDQUFDZ0QsTUFBTVosQ0FBQztBQUM3QjtBQUNBRixXQUFXMUQsU0FBUyxDQUFDMkUsTUFBTSxHQUFHLFNBQVNBLE9BQVFILEtBQUs7SUFDbEQsSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJkLFVBQVMsR0FBSTtRQUNsQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPLElBQUksQ0FBQ2EsUUFBUSxDQUFDQztBQUN2QjtBQUNBZCxXQUFXMUQsU0FBUyxDQUFDNEUsUUFBUSxHQUFHLFNBQVNBLFNBQVVkLENBQUMsRUFBRTVCLFNBQVM7SUFDN0QsT0FBT04sV0FBV0csbUJBQW1CLENBQUMsSUFBSSxDQUFDNkIsQ0FBQyxFQUFFRSxFQUFFRixDQUFDLEVBQUUxQjtBQUNyRDtBQUNBd0IsV0FBVzFELFNBQVMsQ0FBQzZFLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxDQUFDO0lBQ3BELElBQUlOLFFBQVFNO0lBQ1osSUFBSSxJQUFJLENBQUNwRCxDQUFDLEdBQUc4QyxNQUFNOUMsQ0FBQyxFQUFFO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDbEMsSUFBSSxJQUFJLENBQUNBLENBQUMsR0FBRzhDLE1BQU05QyxDQUFDLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDakMsSUFBSSxJQUFJLENBQUNpQyxDQUFDLEdBQUdhLE1BQU1iLENBQUMsRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ2xDLElBQUksSUFBSSxDQUFDQSxDQUFDLEdBQUdhLE1BQU1iLENBQUMsRUFBRTtRQUFFLE9BQU87SUFBRTtJQUNqQyxPQUFPO0FBQ1Q7QUFDQUQsV0FBVzFELFNBQVMsQ0FBQytFLEtBQUssR0FBRyxTQUFTQTtBQUNwQyxRQUFRO0FBQ1IsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsaURBQWlEO0FBQ2pELHlGQUF5RjtBQUN6RixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDakI7QUFDQXJCLFdBQVcxRCxTQUFTLENBQUNnRixJQUFJLEdBQUcsU0FBU0E7SUFDbkMsT0FBTyxJQUFJdEIsV0FBVyxJQUFJO0FBQzVCO0FBQ0FBLFdBQVcxRCxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxNQUFNLElBQUksQ0FBQ3ZELENBQUMsR0FBRyxPQUFPLElBQUksQ0FBQ2lDLENBQUMsR0FBRyxPQUFPLElBQUksQ0FBQ0MsQ0FBQyxHQUFHO0FBQ3hEO0FBQ0FGLFdBQVcxRCxTQUFTLENBQUNrRixVQUFVLEdBQUcsU0FBU0EsV0FBWXBCLENBQUM7SUFDdEQsSUFBSXFCLEtBQUssSUFBSSxDQUFDekQsQ0FBQyxHQUFHb0MsRUFBRXBDLENBQUM7SUFDckIsSUFBSTBELEtBQUssSUFBSSxDQUFDekIsQ0FBQyxHQUFHRyxFQUFFSCxDQUFDO0lBQ3JCLElBQUkwQixLQUFLLElBQUksQ0FBQ3pCLENBQUMsR0FBR0UsRUFBRUYsQ0FBQztJQUNyQixPQUFPbEQsS0FBSzRFLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0EsS0FBS0MsS0FBS0E7QUFDNUM7QUFDQTNCLFdBQVcxRCxTQUFTLENBQUN1RixRQUFRLEdBQUcsU0FBU0EsU0FBVXpCLENBQUM7SUFDbEQsSUFBSXFCLEtBQUssSUFBSSxDQUFDekQsQ0FBQyxHQUFHb0MsRUFBRXBDLENBQUM7SUFDckIsSUFBSTBELEtBQUssSUFBSSxDQUFDekIsQ0FBQyxHQUFHRyxFQUFFSCxDQUFDO0lBQ3JCLE9BQU9qRCxLQUFLNEUsSUFBSSxDQUFDSCxLQUFLQSxLQUFLQyxLQUFLQTtBQUNsQztBQUNBMUIsV0FBVzFELFNBQVMsQ0FBQ3dGLFFBQVEsR0FBRyxTQUFTQTtJQUN2QyxJQUFJQyxTQUFTO0lBQ2JBLFNBQVMsS0FBS0EsU0FBUy9CLFdBQVc4QixRQUFRLENBQUMsSUFBSSxDQUFDOUQsQ0FBQztJQUNqRCtELFNBQVMsS0FBS0EsU0FBUy9CLFdBQVc4QixRQUFRLENBQUMsSUFBSSxDQUFDN0IsQ0FBQztJQUNqRCxPQUFPOEI7QUFDVDtBQUNBL0IsV0FBVzFELFNBQVMsQ0FBQzBGLGFBQWEsR0FBRyxTQUFTQSxjQUFlbEIsS0FBSztJQUNoRSxJQUFJLENBQUM5QyxDQUFDLEdBQUc4QyxNQUFNOUMsQ0FBQztJQUNoQixJQUFJLENBQUNpQyxDQUFDLEdBQUdhLE1BQU1iLENBQUM7SUFDaEIsSUFBSSxDQUFDQyxDQUFDLEdBQUdZLE1BQU1aLENBQUM7QUFDbEI7QUFDQUYsV0FBVzFELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxPQUFPO1FBQUN5QjtRQUFZQztRQUFVRTtLQUFhO0FBQzdDO0FBQ0FDLFdBQVcxRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdkMsT0FBTzRCO0FBQ1Q7QUFDQUEsV0FBVzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM3QixJQUFJMUUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSWlCLElBQUlaLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUk2RSxJQUFJOUMsT0FBT0ksZ0JBQWdCLENBQUN2QjtRQUNoQyxPQUFPaEIsS0FBS2UsS0FBSyxDQUFDLENBQUNrRSxJQUFJQSxDQUFBQSxNQUFPO0lBQ2hDO0FBQ0Y7QUFDQTVCLGdCQUFnQkMscUJBQXFCLENBQUNaLEdBQUcsR0FBRztJQUFjLE9BQU9ZO0FBQXNCO0FBQ3ZGRCxnQkFBZ0JFLGdCQUFnQixDQUFDYixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQW9CO0FBQ2hGVyxnQkFBZ0JGLGFBQWEsQ0FBQ1QsR0FBRyxHQUFHO0lBQWMsT0FBT1AsT0FBTytDLEdBQUc7QUFBQztBQUNwRTdCLGdCQUFnQkcsQ0FBQyxDQUFDZCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDL0NXLGdCQUFnQkksQ0FBQyxDQUFDZixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDL0NXLGdCQUFnQkssQ0FBQyxDQUFDaEIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBRS9DbkQsT0FBT29ELGdCQUFnQixDQUFFSyxZQUFZSztBQUVyQyxJQUFJQyx3QkFBd0IsU0FBU0Esc0JBQXVCNkIsZ0JBQWdCO0lBQzFFLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDekIsSUFBSWhGLFVBQVVMLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJSyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUM5RCxJQUFJc0YscUJBQXFCakYsU0FBUyxDQUFDLEVBQUU7UUFDckMsSUFBSWlGLHVCQUF1QixLQUFLQSx1QkFBdUIsR0FBRztZQUFFLE1BQU0sSUFBSTNELHlCQUF5QjtRQUEyQztRQUMxSSxJQUFJLENBQUMwRCxpQkFBaUIsR0FBR0M7SUFDM0I7QUFDRjtBQUNBL0Isc0JBQXNCaEUsU0FBUyxDQUFDZ0csT0FBTyxHQUFHLFNBQVNBLFFBQVNDLEVBQUUsRUFBRUMsRUFBRTtJQUNoRSxJQUFJQyxLQUFLRjtJQUNULElBQUlHLEtBQUtGO0lBQ1QsSUFBSUcsUUFBUXJDLHNCQUFzQmdDLE9BQU8sQ0FBQ0csR0FBR3pFLENBQUMsRUFBRTBFLEdBQUcxRSxDQUFDO0lBQ3BELElBQUkyRSxVQUFVLEdBQUc7UUFBRSxPQUFPQTtJQUFNO0lBQ2hDLElBQUlDLFFBQVF0QyxzQkFBc0JnQyxPQUFPLENBQUNHLEdBQUd4QyxDQUFDLEVBQUV5QyxHQUFHekMsQ0FBQztJQUNwRCxJQUFJMkMsVUFBVSxHQUFHO1FBQUUsT0FBT0E7SUFBTTtJQUNoQyxJQUFJLElBQUksQ0FBQ1IsaUJBQWlCLElBQUksR0FBRztRQUFFLE9BQU87SUFBRTtJQUM1QyxJQUFJUyxRQUFRdkMsc0JBQXNCZ0MsT0FBTyxDQUFDRyxHQUFHdkMsQ0FBQyxFQUFFd0MsR0FBR3hDLENBQUM7SUFDcEQsT0FBTzJDO0FBQ1Q7QUFDQXZDLHNCQUFzQmhFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNyRCxPQUFPO1FBQUMyQjtLQUFXO0FBQ3JCO0FBQ0FRLHNCQUFzQmhFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNsRCxPQUFPa0M7QUFDVDtBQUNBQSxzQkFBc0JnQyxPQUFPLEdBQUcsU0FBU0EsUUFBU1EsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BELElBQUlELElBQUlDLEdBQUc7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUN2QixJQUFJRCxJQUFJQyxHQUFHO1FBQUUsT0FBTztJQUFFO0lBQ3RCLElBQUk1RCxPQUFPckIsS0FBSyxDQUFDZ0YsSUFBSTtRQUNuQixJQUFJM0QsT0FBT3JCLEtBQUssQ0FBQ2lGLElBQUk7WUFBRSxPQUFPO1FBQUU7UUFDaEMsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxJQUFJNUQsT0FBT3JCLEtBQUssQ0FBQ2lGLElBQUk7UUFBRSxPQUFPO0lBQUU7SUFDaEMsT0FBTztBQUNUO0FBRUEsc0RBQXNEO0FBQ3RELHdEQUF3RDtBQUV4RCxJQUFJQyw0QkFBNEIsU0FBU0EsNkJBQThCO0FBRXZFQSwwQkFBMEIxRyxTQUFTLENBQUMyQyxNQUFNLEdBQUcsU0FBU0E7QUFDcEQsZ0NBQWdDO0FBQ2hDLHVDQUF1QztBQUN2QyxtQ0FBbUM7QUFDbkMsK0RBQStEO0FBQy9ELGdDQUFnQztBQUNoQyxJQUFJO0FBQ0osdUNBQXVDO0FBQ3ZDLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsSUFBSTtBQUNOO0FBQ0ErRCwwQkFBMEIxRyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDekQsT0FBTyxFQUFFO0FBQ1g7QUFDQTZFLDBCQUEwQjFHLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN0RCxPQUFPNEU7QUFDVDtBQUVBLElBQUlDLFdBQVcsU0FBU0EsWUFBYTtBQUVyQyxJQUFJQyxvQkFBb0I7SUFBRUMsVUFBVTtRQUFFMUcsY0FBYztJQUFLO0lBQUUyRyxVQUFVO1FBQUUzRyxjQUFjO0lBQUs7SUFBRTRHLFVBQVU7UUFBRTVHLGNBQWM7SUFBSztJQUFFNkcsTUFBTTtRQUFFN0csY0FBYztJQUFLO0FBQUU7QUFFMUp3RyxTQUFTM0csU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sRUFBRTtBQUNYO0FBQ0E4RSxTQUFTM0csU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU82RTtBQUNUO0FBQ0FBLFNBQVNNLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQkMsYUFBYTtJQUNsRSxPQUFRQTtRQUNOLEtBQUtQLFNBQVNJLFFBQVE7WUFDcEIsT0FBTztRQUNULEtBQUtKLFNBQVNHLFFBQVE7WUFDcEIsT0FBTztRQUNULEtBQUtILFNBQVNFLFFBQVE7WUFDcEIsT0FBTztRQUNULEtBQUtGLFNBQVNLLElBQUk7WUFDaEIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxNQUFNLElBQUk1RSx5QkFBeUIsNkJBQTZCOEU7QUFDbEU7QUFDQU4sa0JBQWtCQyxRQUFRLENBQUN6RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDeER3RCxrQkFBa0JFLFFBQVEsQ0FBQzFELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUN4RHdELGtCQUFrQkcsUUFBUSxDQUFDM0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ3hEd0Qsa0JBQWtCSSxJQUFJLENBQUM1RCxHQUFHLEdBQUc7SUFBYyxPQUFPLENBQUM7QUFBRTtBQUVyRG5ELE9BQU9vRCxnQkFBZ0IsQ0FBRXNELFVBQVVDO0FBRW5DLElBQUlPLGVBQWUsU0FBVXJDLENBQUMsRUFBRXNDLENBQUM7SUFDL0IsT0FBT3RDLEVBQUVqRCxXQUFXLElBQUlpRCxFQUFFakQsV0FBVyxHQUFHd0YsT0FBTyxDQUFDRCxLQUFLLENBQUM7QUFDeEQ7QUFFQSxJQUFJRSxXQUFXLFNBQVNBLFlBQWE7QUFFckMsSUFBSUMsb0JBQW9CO0lBQUVDLFFBQVE7UUFBRXJILGNBQWM7SUFBSztBQUFFO0FBRXpEbUgsU0FBU3RILFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxPQUFPLEVBQUU7QUFDWDtBQUNBeUYsU0FBU3RILFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPd0Y7QUFDVDtBQUNBQSxTQUFTRyxLQUFLLEdBQUcsU0FBU0EsTUFBTy9GLENBQUM7SUFDaEMsSUFBSWdHLEtBQUtoSCxLQUFLaUgsR0FBRyxDQUFDakc7SUFDbEIsSUFBSW1CLE9BQU9NLFVBQVUsQ0FBQ3VFLEtBQUs7UUFBRSxPQUFPQTtJQUFHO0lBQ3ZDLElBQUk3RSxPQUFPckIsS0FBSyxDQUFDa0csS0FBSztRQUFFLE9BQU9BO0lBQUc7SUFDbEMsT0FBT0EsS0FBS0osU0FBU0UsTUFBTTtBQUM3QjtBQUNBRixTQUFTMUcsR0FBRyxHQUFHLFNBQVNBLElBQUtnSCxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFO0lBQ3pDLElBQUluSCxNQUFNZ0g7SUFDVixJQUFJQyxLQUFLakgsS0FBSztRQUFFQSxNQUFNaUg7SUFBSTtJQUMxQixJQUFJQyxLQUFLbEgsS0FBSztRQUFFQSxNQUFNa0g7SUFBSTtJQUMxQixJQUFJQyxLQUFLbkgsS0FBSztRQUFFQSxNQUFNbUg7SUFBSTtJQUMxQixPQUFPbkg7QUFDVDtBQUNBMEcsU0FBU1UsS0FBSyxHQUFHLFNBQVNBO0lBQ3hCLElBQUksT0FBT2xILFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBYSxPQUFPQSxTQUFTLENBQUMsRUFBRSxLQUFLLFlBQVksT0FBT0EsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFXO1FBQzlHLElBQUlZLElBQUlaLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUlGLE1BQU1FLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUlILE1BQU1HLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUlZLElBQUlkLEtBQUs7WUFBRSxPQUFPQTtRQUFJO1FBQzFCLElBQUljLElBQUlmLEtBQUs7WUFBRSxPQUFPQTtRQUFJO1FBQzFCLE9BQU9lO0lBQ1QsT0FBTyxJQUFJVixPQUFPSSxTQUFTLENBQUNOLFNBQVMsQ0FBQyxFQUFFLEtBQU1FLE9BQU9JLFNBQVMsQ0FBQ04sU0FBUyxDQUFDLEVBQUUsS0FBS0UsT0FBT0ksU0FBUyxDQUFDTixTQUFTLENBQUMsRUFBRSxHQUFJO1FBQy9HLElBQUltSCxNQUFNbkgsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSW9ILFFBQVFwSCxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJcUgsUUFBUXJILFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUltSCxNQUFNQyxPQUFPO1lBQUUsT0FBT0E7UUFBTTtRQUNoQyxJQUFJRCxNQUFNRSxPQUFPO1lBQUUsT0FBT0E7UUFBTTtRQUNoQyxPQUFPRjtJQUNUO0FBQ0Y7QUFDQVgsU0FBU2MsSUFBSSxHQUFHLFNBQVNBLEtBQU1DLEtBQUssRUFBRTFILEdBQUc7SUFDdkMsSUFBSTBILFFBQVEsR0FBRztRQUNiLE9BQU8xSCxNQUFNLENBQUMwSCxRQUFRMUg7SUFDeEI7SUFDQSxPQUFPMEgsUUFBUTFIO0FBQ2pCO0FBQ0EyRyxTQUFTM0csR0FBRyxHQUFHLFNBQVNBO0lBQ3RCLElBQUlHLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUltSCxLQUFLOUcsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSStHLEtBQUsvRyxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJZ0gsS0FBS2hILFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlILE1BQU1pSDtRQUNWLElBQUlDLEtBQUtsSCxLQUFLO1lBQUVBLE1BQU1rSDtRQUFJO1FBQzFCLElBQUlDLEtBQUtuSCxLQUFLO1lBQUVBLE1BQU1tSDtRQUFJO1FBQzFCLE9BQU9uSDtJQUNULE9BQU8sSUFBSUcsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTZILE9BQU94SCxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJeUgsT0FBT3pILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUkwSCxPQUFPMUgsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSWlILEtBQUtqSCxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJcUgsUUFBUUc7UUFDWixJQUFJQyxPQUFPSixPQUFPO1lBQUVBLFFBQVFJO1FBQU07UUFDbEMsSUFBSUMsT0FBT0wsT0FBTztZQUFFQSxRQUFRSztRQUFNO1FBQ2xDLElBQUlULEtBQUtJLE9BQU87WUFBRUEsUUFBUUo7UUFBSTtRQUM5QixPQUFPSTtJQUNUO0FBQ0Y7QUFDQWIsU0FBU21CLE9BQU8sR0FBRyxTQUFTQSxRQUFTekcsRUFBRSxFQUFFQyxFQUFFO0lBQ3pDLE9BQU8sQ0FBQ0QsS0FBS0MsRUFBQyxJQUFLO0FBQ3JCO0FBQ0FzRixrQkFBa0JDLE1BQU0sQ0FBQ3BFLEdBQUcsR0FBRztJQUFjLE9BQU8xQyxLQUFLaUgsR0FBRyxDQUFDO0FBQUk7QUFFakUxSCxPQUFPb0QsZ0JBQWdCLENBQUVpRSxVQUFVQztBQUVuQyxJQUFJbUIsZUFBZSxTQUFTQSxhQUFjQyxHQUFHO0lBQzNDLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtBQUNiO0FBQ0FELGFBQWExSSxTQUFTLENBQUM0SSxNQUFNLEdBQUcsU0FBU0EsT0FBUUMsQ0FBQztJQUNoRCxJQUFJLENBQUNGLEdBQUcsSUFBSUU7QUFDZDtBQUVBSCxhQUFhMUksU0FBUyxDQUFDOEksU0FBUyxHQUFHLFNBQVNBLFVBQVcxQixDQUFDLEVBQUV0RCxDQUFDO0lBQ3pELElBQUksQ0FBQzZFLEdBQUcsR0FBRyxJQUFJLENBQUNBLEdBQUcsQ0FBQ0ksTUFBTSxDQUFDLEdBQUczQixLQUFLdEQsSUFBSSxJQUFJLENBQUM2RSxHQUFHLENBQUNJLE1BQU0sQ0FBQzNCLElBQUk7QUFDN0Q7QUFFQXNCLGFBQWExSSxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0EsU0FBVTRELENBQUM7SUFDcEQsT0FBTyxJQUFJLENBQUNGLEdBQUc7QUFDakI7QUFFQSxJQUFJSyxVQUFVLFNBQVNBLFFBQVM1SSxLQUFLO0lBQ25DLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtBQUNmO0FBQ0E0SSxRQUFRaEosU0FBUyxDQUFDaUosUUFBUSxHQUFHLFNBQVNBO0lBQ3BDLE9BQU8sSUFBSSxDQUFDN0ksS0FBSztBQUNuQjtBQUNBNEksUUFBUWhKLFNBQVMsQ0FBQzZFLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxDQUFDO0lBQ2pELElBQUksSUFBSSxDQUFDMUUsS0FBSyxHQUFHMEUsR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ2hDLElBQUksSUFBSSxDQUFDMUUsS0FBSyxHQUFHMEUsR0FBRztRQUFFLE9BQU87SUFBRTtJQUMvQixPQUFPO0FBQ1Q7QUFDQWtFLFFBQVF4SCxLQUFLLEdBQUcsU0FBU0EsTUFBT3dCLENBQUM7SUFBSSxPQUFPaEMsT0FBT1EsS0FBSyxDQUFDd0I7QUFBRztBQUU1RCxJQUFJa0csWUFBWSxTQUFTQSxhQUFjO0FBRXZDQSxVQUFVQyxZQUFZLEdBQUcsU0FBU0EsYUFBY3JGLENBQUM7SUFBSSxPQUFRLEtBQU0sTUFBTUEsS0FBSyxLQUFNQSxNQUFNO0FBQUs7QUFDL0ZvRixVQUFVRSxXQUFXLEdBQUcsU0FBU0EsWUFBYXRGLENBQUM7SUFBSSxPQUFPQSxFQUFFc0YsV0FBVztBQUFHO0FBRTFFLElBQUlDLEtBQUssU0FBU0E7SUFDaEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUl6SSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUMrSSxJQUFJLENBQUM7SUFDWixPQUFPLElBQUkxSSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJLE9BQU9LLFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVTtZQUNwQyxJQUFJWSxJQUFJWixTQUFTLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMwSSxJQUFJLENBQUM5SDtRQUNaLE9BQU8sSUFBSVosU0FBUyxDQUFDLEVBQUUsWUFBWXVJLElBQUk7WUFDckMsSUFBSUksS0FBSzNJLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQzBJLElBQUksQ0FBQ0M7UUFDWixPQUFPLElBQUksT0FBTzNJLFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVTtZQUMzQyxJQUFJNkgsTUFBTTdILFNBQVMsQ0FBQyxFQUFFO1lBQ3RCdUksR0FBRzlHLElBQUksQ0FBQyxJQUFJLEVBQUU4RyxHQUFHSyxLQUFLLENBQUNmO1FBQ3pCO0lBQ0YsT0FBTyxJQUFJN0gsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWtKLEtBQUs3SSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJOEksS0FBSzlJLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQzBJLElBQUksQ0FBQ0csSUFBSUM7SUFDaEI7QUFDRjtBQUVBLElBQUlDLG9CQUFvQjtJQUFFQyxJQUFJO1FBQUUzSixjQUFjO0lBQUs7SUFBRTRKLFFBQVE7UUFBRTVKLGNBQWM7SUFBSztJQUFFNkosTUFBTTtRQUFFN0osY0FBYztJQUFLO0lBQUU4SixHQUFHO1FBQUU5SixjQUFjO0lBQUs7SUFBRXlGLEtBQUs7UUFBRXpGLGNBQWM7SUFBSztJQUFFK0osS0FBSztRQUFFL0osY0FBYztJQUFLO0lBQUVnSyxPQUFPO1FBQUVoSyxjQUFjO0lBQUs7SUFBRWlLLGtCQUFrQjtRQUFFakssY0FBYztJQUFLO0lBQUVrSyxLQUFLO1FBQUVsSyxjQUFjO0lBQUs7SUFBRW1LLEtBQUs7UUFBRW5LLGNBQWM7SUFBSztJQUFFb0ssdUJBQXVCO1FBQUVwSyxjQUFjO0lBQUs7SUFBRXFLLGNBQWM7UUFBRXJLLGNBQWM7SUFBSztBQUFFO0FBQ3Jaa0osR0FBR3JKLFNBQVMsQ0FBQ3lLLEVBQUUsR0FBRyxTQUFTQSxHQUFJOUcsQ0FBQztJQUM5QixPQUFPLENBQUMsSUFBSSxDQUFDMkYsR0FBRyxHQUFHM0YsRUFBRTJGLEdBQUcsSUFBSSxJQUFJLENBQUNBLEdBQUcsS0FBSzNGLEVBQUUyRixHQUFHLEtBQUssSUFBSSxDQUFDQyxHQUFHLElBQUk1RixFQUFFNEYsR0FBRztBQUN0RTtBQUNBRixHQUFHckosU0FBUyxDQUFDMEssd0JBQXdCLEdBQUcsU0FBU0EseUJBQTBCQyxrQkFBa0IsRUFBRUMsU0FBUztJQUN0RyxJQUFJakgsSUFBSSxJQUFJLENBQUN4QixHQUFHO0lBQ2hCLElBQUkwSSxNQUFNeEIsR0FBR3VCLFNBQVMsQ0FBQ2pILEVBQUUyRixHQUFHO0lBQzVCLElBQUl3QixRQUFRekIsR0FBR2dCLEdBQUcsQ0FBQ1UsR0FBRyxDQUFDRjtJQUN2QmxILElBQUlBLEVBQUVxSCxNQUFNLENBQUNGO0lBQ2IsSUFBSW5ILEVBQUVzSCxFQUFFLENBQUM1QixHQUFHZ0IsR0FBRyxHQUFHO1FBQ2hCMUcsSUFBSUEsRUFBRXFILE1BQU0sQ0FBQzNCLEdBQUdnQixHQUFHO1FBQ25CUSxPQUFPO0lBQ1QsT0FBTyxJQUFJbEgsRUFBRXVILEVBQUUsQ0FBQzdCLEdBQUdpQixHQUFHLEdBQUc7UUFDdkIzRyxJQUFJQSxFQUFFd0gsUUFBUSxDQUFDOUIsR0FBR2dCLEdBQUc7UUFDckJRLE9BQU87SUFDVDtJQUNBLElBQUlPLGtCQUFrQlAsTUFBTTtJQUM1QixJQUFJUSxNQUFNLElBQUkzQztJQUNkLElBQUk0QyxZQUFZakMsR0FBR2UsZ0JBQWdCLEdBQUc7SUFDdEMsSUFBSyxJQUFJaEQsSUFBSSxHQUFHQSxLQUFLa0UsV0FBV2xFLElBQUs7UUFDbkMsSUFBSXVELHNCQUFzQnZELE1BQU1nRSxpQkFBaUI7WUFDL0NDLElBQUl6QyxNQUFNLENBQUM7UUFDYjtRQUNBLElBQUkyQyxRQUFRN0ssS0FBS2UsS0FBSyxDQUFDa0MsRUFBRTJGLEdBQUc7UUFDNUIsSUFBSWlDLFFBQVEsR0FBRztZQUNiO1FBQ0Y7UUFDQSxJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLFlBQVk7UUFDaEIsSUFBSUYsUUFBUSxHQUFHO1lBQ2JDLGFBQWE7WUFDYkMsWUFBWTtRQUNkLE9BQU87WUFDTEEsWUFBWSxNQUFNRjtRQUNwQjtRQUNBRixJQUFJekMsTUFBTSxDQUFDNkM7UUFDWDlILElBQUlBLEVBQUUrSCxRQUFRLENBQUNyQyxHQUFHc0MsT0FBTyxDQUFDSixRQUFRSixRQUFRLENBQUM5QixHQUFHZ0IsR0FBRztRQUNqRCxJQUFJbUIsWUFBWTtZQUFFN0gsRUFBRWlJLE9BQU8sQ0FBQ3ZDLEdBQUdnQixHQUFHO1FBQUc7UUFDckMsSUFBSXdCLDJCQUEyQjtRQUMvQixJQUFJQyxTQUFTekMsR0FBR3VCLFNBQVMsQ0FBQ2pILEVBQUUyRixHQUFHO1FBQy9CLElBQUl3QyxTQUFTLEtBQUtwTCxLQUFLeUIsR0FBRyxDQUFDMkosV0FBV1IsWUFBWWxFLEdBQUc7WUFBRXlFLDJCQUEyQjtRQUFPO1FBQ3pGLElBQUksQ0FBQ0EsMEJBQTBCO1lBQUU7UUFBTTtJQUN6QztJQUNBakIsU0FBUyxDQUFDLEVBQUUsR0FBR0M7SUFDZixPQUFPUSxJQUFJcEcsUUFBUTtBQUNyQjtBQUNBb0UsR0FBR3JKLFNBQVMsQ0FBQytMLEdBQUcsR0FBRyxTQUFTQTtJQUMxQixPQUFPLElBQUksQ0FBQ1osUUFBUSxDQUFDLElBQUk7QUFDM0I7QUFDQTlCLEdBQUdySixTQUFTLENBQUNnTSxXQUFXLEdBQUcsU0FBU0E7SUFDbEMsT0FBTyxJQUFJLENBQUMxQyxHQUFHLEdBQUcsSUFBSSxDQUFDQyxHQUFHO0FBQzVCO0FBQ0FGLEdBQUdySixTQUFTLENBQUMwTCxRQUFRLEdBQUcsU0FBU0E7SUFDL0IsSUFBSTVLLFNBQVMsQ0FBQyxFQUFFLFlBQVl1SSxJQUFJO1FBQzlCLElBQUkxRixJQUFJN0MsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUNtTCxHQUFHLENBQUN0SSxFQUFFdUksTUFBTTtJQUMxQixPQUFPLElBQUksT0FBT3BMLFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUMzQyxJQUFJcUwsTUFBTXJMLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sSUFBSSxDQUFDbUwsR0FBRyxDQUFDLENBQUNFO0lBQ25CO0FBQ0Y7QUFDQTlDLEdBQUdySixTQUFTLENBQUMyRSxNQUFNLEdBQUcsU0FBU0E7SUFDN0IsSUFBSTdELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlrRCxJQUFJN0MsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUN3SSxHQUFHLEtBQUszRixFQUFFMkYsR0FBRyxJQUFJLElBQUksQ0FBQ0MsR0FBRyxLQUFLNUYsRUFBRTRGLEdBQUc7SUFDakQ7QUFDRjtBQUNBRixHQUFHckosU0FBUyxDQUFDb00sTUFBTSxHQUFHLFNBQVNBO0lBQzdCLE9BQU8sSUFBSSxDQUFDOUMsR0FBRyxLQUFLLE9BQU8sSUFBSSxDQUFDQyxHQUFHLEtBQUs7QUFDMUM7QUFDQUYsR0FBR3JKLFNBQVMsQ0FBQ3FNLFlBQVksR0FBRyxTQUFTQTtJQUNuQyxJQUFJdkwsU0FBUyxDQUFDLEVBQUUsWUFBWXVJLElBQUk7UUFDOUIsSUFBSTFGLElBQUk3QyxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJLElBQUksQ0FBQ1UsS0FBSyxJQUFJO1lBQUUsT0FBTyxJQUFJO1FBQUM7UUFDaEMsT0FBTyxJQUFJLENBQUNvSyxPQUFPLENBQUMsQ0FBQ2pJLEVBQUUyRixHQUFHLEVBQUUsQ0FBQzNGLEVBQUU0RixHQUFHO0lBQ3BDLE9BQU8sSUFBSSxPQUFPekksU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzNDLElBQUlxTCxNQUFNckwsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxJQUFJLENBQUNVLEtBQUssSUFBSTtZQUFFLE9BQU8sSUFBSTtRQUFDO1FBQ2hDLE9BQU8sSUFBSSxDQUFDb0ssT0FBTyxDQUFDLENBQUNPLEtBQUs7SUFDNUI7QUFDRjtBQUNBOUMsR0FBR3JKLFNBQVMsQ0FBQ3NNLHNCQUFzQixHQUFHLFNBQVNBO0lBQzdDLElBQUksSUFBSSxDQUFDRixNQUFNLElBQUk7UUFBRSxPQUFPO0lBQU07SUFDbEMsSUFBSSxJQUFJLENBQUM1SyxLQUFLLElBQUk7UUFBRSxPQUFPO0lBQU87SUFDbEMsT0FBTztBQUNUO0FBQ0E2SCxHQUFHckosU0FBUyxDQUFDWSxHQUFHLEdBQUcsU0FBU0EsSUFBS2MsQ0FBQztJQUNoQyxJQUFJLElBQUksQ0FBQytJLEVBQUUsQ0FBQy9JLElBQUk7UUFDZCxPQUFPLElBQUk7SUFDYixPQUFPO1FBQ0wsT0FBT0E7SUFDVDtBQUNGO0FBQ0EySCxHQUFHckosU0FBUyxDQUFDdU0sVUFBVSxHQUFHLFNBQVNBO0lBQ2pDLElBQUl6TCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZdUksSUFBSTtZQUM5QixJQUFJMUYsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLE9BQU8sSUFBSSxDQUFDeUwsVUFBVSxDQUFDNUksRUFBRTJGLEdBQUcsRUFBRTNGLEVBQUU0RixHQUFHO1FBQ3JDLE9BQU8sSUFBSSxPQUFPekksU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQzNDLElBQUlxTCxNQUFNckwsU0FBUyxDQUFDLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUN5TCxVQUFVLENBQUNKLEtBQUs7UUFDOUI7SUFDRixPQUFPLElBQUlyTCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJK0wsTUFBTTFMLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUkyTCxNQUFNM0wsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTRMLEtBQUs7UUFDVCxJQUFJQyxLQUFLO1FBQ1QsSUFBSUMsS0FBSztRQUNULElBQUlDLEtBQUs7UUFDVCxJQUFJQyxJQUFJO1FBQ1IsSUFBSWhKLElBQUk7UUFDUixJQUFJaUosSUFBSTtRQUNSLElBQUlDLElBQUk7UUFDUkYsSUFBSSxJQUFJLENBQUN4RCxHQUFHLEdBQUdrRDtRQUNmMUksSUFBSXVGLEdBQUdjLEtBQUssR0FBRzJDO1FBQ2ZKLEtBQUs1SSxJQUFJZ0o7UUFDVEUsSUFBSTNELEdBQUdjLEtBQUssR0FBR3FDO1FBQ2ZFLEtBQUs1SSxJQUFJNEk7UUFDVEMsS0FBS0csSUFBSUo7UUFDVEUsS0FBS0ksSUFBSVI7UUFDVE8sSUFBSUQsSUFBSU47UUFDUkksS0FBS0ksSUFBSUo7UUFDVEMsS0FBS0wsTUFBTUk7UUFDWEksSUFBSU4sS0FBS0UsS0FBS0csSUFBSUwsS0FBS0csS0FBS0YsS0FBS0MsS0FBS0QsS0FBS0U7UUFDM0MvSSxJQUFJLENBQUMsSUFBSSxDQUFDd0YsR0FBRyxHQUFHeUQsSUFBSUMsSUFBSSxJQUFJLENBQUN6RCxHQUFHLEdBQUd1RCxJQUFJTCxHQUFFLElBQUtEO1FBQzlDUSxJQUFJRixJQUFJaEo7UUFDUixJQUFJLENBQUN3RixHQUFHLEdBQUcwRDtRQUNYLElBQUksQ0FBQ3pELEdBQUcsR0FBR3VELElBQUlFLElBQUlsSjtRQUNuQixPQUFPLElBQUk7SUFDYjtBQUNGO0FBQ0F1RixHQUFHckosU0FBUyxDQUFDaU4sSUFBSSxHQUFHLFNBQVNBO0lBQzNCLE9BQU8sUUFBUSxJQUFJLENBQUMzRCxHQUFHLEdBQUcsT0FBTyxJQUFJLENBQUNDLEdBQUcsR0FBRztBQUM5QztBQUNBRixHQUFHckosU0FBUyxDQUFDZ0wsTUFBTSxHQUFHLFNBQVNBO0lBQzdCLElBQUlsSyxTQUFTLENBQUMsRUFBRSxZQUFZdUksSUFBSTtRQUM5QixJQUFJMUYsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUk0TCxLQUFLO1FBQ1QsSUFBSUMsS0FBSztRQUNULElBQUlDLEtBQUs7UUFDVCxJQUFJQyxLQUFLO1FBQ1QsSUFBSUMsSUFBSTtRQUNSLElBQUloSixJQUFJO1FBQ1IsSUFBSWlKLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBQ1JGLElBQUksSUFBSSxDQUFDeEQsR0FBRyxHQUFHM0YsRUFBRTJGLEdBQUc7UUFDcEJ4RixJQUFJdUYsR0FBR2MsS0FBSyxHQUFHMkM7UUFDZkosS0FBSzVJLElBQUlnSjtRQUNURSxJQUFJM0QsR0FBR2MsS0FBSyxHQUFHeEcsRUFBRTJGLEdBQUc7UUFDcEJvRCxLQUFLNUksSUFBSTRJO1FBQ1RDLEtBQUtHLElBQUlKO1FBQ1RFLEtBQUtJLElBQUlySixFQUFFMkYsR0FBRztRQUNkeUQsSUFBSUQsSUFBSW5KLEVBQUUyRixHQUFHO1FBQ2JzRCxLQUFLSSxJQUFJSjtRQUNUQyxLQUFLbEosRUFBRTJGLEdBQUcsR0FBR3NEO1FBQ2JJLElBQUlOLEtBQUtFLEtBQUtHLElBQUlMLEtBQUtHLEtBQUtGLEtBQUtDLEtBQUtELEtBQUtFO1FBQzNDL0ksSUFBSSxDQUFDLElBQUksQ0FBQ3dGLEdBQUcsR0FBR3lELElBQUlDLElBQUksSUFBSSxDQUFDekQsR0FBRyxHQUFHdUQsSUFBSW5KLEVBQUU0RixHQUFHLElBQUk1RixFQUFFMkYsR0FBRztRQUNyRDBELElBQUlGLElBQUloSjtRQUNSLElBQUlvSixNQUFNRjtRQUNWLElBQUlHLE1BQU1MLElBQUlFLElBQUlsSjtRQUNsQixPQUFPLElBQUl1RixHQUFHNkQsS0FBS0M7SUFDckIsT0FBTyxJQUFJLE9BQU9yTSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7UUFDM0MsSUFBSXFMLE1BQU1yTCxTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJK0IsT0FBT3JCLEtBQUssQ0FBQzJLLE1BQU07WUFBRSxPQUFPOUMsR0FBRytELFNBQVM7UUFBRztRQUMvQyxPQUFPL0QsR0FBR3JFLElBQUksQ0FBQyxJQUFJLEVBQUV1SCxVQUFVLENBQUNKLEtBQUs7SUFDdkM7QUFDRjtBQUNBOUMsR0FBR3JKLFNBQVMsQ0FBQ3FOLEVBQUUsR0FBRyxTQUFTQSxHQUFJMUosQ0FBQztJQUM5QixPQUFPLENBQUMsSUFBSSxDQUFDMkYsR0FBRyxHQUFHM0YsRUFBRTJGLEdBQUcsSUFBSSxJQUFJLENBQUNBLEdBQUcsS0FBSzNGLEVBQUUyRixHQUFHLEtBQUssSUFBSSxDQUFDQyxHQUFHLElBQUk1RixFQUFFNEYsR0FBRztBQUN0RTtBQUNBRixHQUFHckosU0FBUyxDQUFDK0ssR0FBRyxHQUFHLFNBQVNBLElBQUt1QyxHQUFHO0lBQ2xDLElBQUlBLFFBQVEsS0FBSztRQUFFLE9BQU9qRSxHQUFHc0MsT0FBTyxDQUFDO0lBQUs7SUFDMUMsSUFBSTRCLElBQUksSUFBSWxFLEdBQUcsSUFBSTtJQUNuQixJQUFJbUUsSUFBSW5FLEdBQUdzQyxPQUFPLENBQUM7SUFDbkIsSUFBSTNJLElBQUl0QyxLQUFLeUIsR0FBRyxDQUFDbUw7SUFDakIsSUFBSXRLLElBQUksR0FBRztRQUNULE1BQU9BLElBQUksRUFBRztZQUNaLElBQUlBLElBQUksTUFBTSxHQUFHO2dCQUNmd0ssRUFBRUMsWUFBWSxDQUFDRjtZQUNqQjtZQUNBdkssS0FBSztZQUNMLElBQUlBLElBQUksR0FBRztnQkFBRXVLLElBQUlBLEVBQUV4QixHQUFHO1lBQUk7UUFDNUI7SUFDRixPQUFPO1FBQ0x5QixJQUFJRDtJQUNOO0lBQ0EsSUFBSUQsTUFBTSxHQUFHO1FBQUUsT0FBT0UsRUFBRUUsVUFBVTtJQUFHO0lBQ3JDLE9BQU9GO0FBQ1Q7QUFDQW5FLEdBQUdySixTQUFTLENBQUMyQixJQUFJLEdBQUcsU0FBU0E7SUFDM0IsSUFBSSxJQUFJLENBQUNILEtBQUssSUFBSTtRQUFFLE9BQU82SCxHQUFHekQsR0FBRztJQUFDO0lBQ2xDLElBQUkrSCxNQUFNak4sS0FBS2lCLElBQUksQ0FBQyxJQUFJLENBQUMySCxHQUFHO0lBQzVCLElBQUlzRSxNQUFNO0lBQ1YsSUFBSUQsUUFBUSxJQUFJLENBQUNyRSxHQUFHLEVBQUU7UUFDcEJzRSxNQUFNbE4sS0FBS2lCLElBQUksQ0FBQyxJQUFJLENBQUM0SCxHQUFHO0lBQzFCO0lBQ0EsT0FBTyxJQUFJRixHQUFHc0UsS0FBS0M7QUFDckI7QUFDQXZFLEdBQUdySixTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV0MsQ0FBQztJQUM1QyxJQUFJTixRQUFRTTtJQUNaLElBQUksSUFBSSxDQUFDd0UsR0FBRyxHQUFHOUUsTUFBTThFLEdBQUcsRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ3RDLElBQUksSUFBSSxDQUFDQSxHQUFHLEdBQUc5RSxNQUFNOEUsR0FBRyxFQUFFO1FBQUUsT0FBTztJQUFFO0lBQ3JDLElBQUksSUFBSSxDQUFDQyxHQUFHLEdBQUcvRSxNQUFNK0UsR0FBRyxFQUFFO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDdEMsSUFBSSxJQUFJLENBQUNBLEdBQUcsR0FBRy9FLE1BQU0rRSxHQUFHLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDckMsT0FBTztBQUNUO0FBQ0FGLEdBQUdySixTQUFTLENBQUM2TixJQUFJLEdBQUcsU0FBU0E7SUFDM0IsSUFBSSxJQUFJLENBQUNyTSxLQUFLLElBQUk7UUFBRSxPQUFPLElBQUk7SUFBQztJQUNoQyxJQUFJc00sUUFBUSxJQUFJLENBQUM3QixHQUFHLENBQUM7SUFDckIsT0FBTzZCLE1BQU14TSxLQUFLO0FBQ3BCO0FBQ0ErSCxHQUFHckosU0FBUyxDQUFDK04sUUFBUSxHQUFHLFNBQVNBO0lBQy9CLElBQUlqTixTQUFTLENBQUMsRUFBRSxZQUFZdUksSUFBSTtRQUM5QixJQUFJakosUUFBUVUsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSSxDQUFDMEksSUFBSSxDQUFDcEo7UUFDVixPQUFPLElBQUk7SUFDYixPQUFPLElBQUksT0FBT1UsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzNDLElBQUlrTixVQUFVbE4sU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSSxDQUFDMEksSUFBSSxDQUFDd0U7UUFDVixPQUFPLElBQUk7SUFDYjtBQUNGO0FBQ0EzRSxHQUFHckosU0FBUyxDQUFDVyxHQUFHLEdBQUcsU0FBU0EsSUFBS2UsQ0FBQztJQUNoQyxJQUFJLElBQUksQ0FBQzJMLEVBQUUsQ0FBQzNMLElBQUk7UUFDZCxPQUFPLElBQUk7SUFDYixPQUFPO1FBQ0wsT0FBT0E7SUFDVDtBQUNGO0FBQ0EySCxHQUFHckosU0FBUyxDQUFDc0YsSUFBSSxHQUFHLFNBQVNBO0lBQzNCLElBQUksSUFBSSxDQUFDOEcsTUFBTSxJQUFJO1FBQUUsT0FBTy9DLEdBQUdzQyxPQUFPLENBQUM7SUFBSztJQUM1QyxJQUFJLElBQUksQ0FBQ3NDLFVBQVUsSUFBSTtRQUNyQixPQUFPNUUsR0FBR3pELEdBQUc7SUFDZjtJQUNBLElBQUlsRSxJQUFJLE1BQU1oQixLQUFLNEUsSUFBSSxDQUFDLElBQUksQ0FBQ2dFLEdBQUc7SUFDaEMsSUFBSTRFLEtBQUssSUFBSSxDQUFDNUUsR0FBRyxHQUFHNUg7SUFDcEIsSUFBSXlNLE9BQU85RSxHQUFHc0MsT0FBTyxDQUFDdUM7SUFDdEIsSUFBSUUsU0FBUyxJQUFJLENBQUMxQyxRQUFRLENBQUN5QyxLQUFLcEMsR0FBRztJQUNuQyxJQUFJc0MsS0FBS0QsT0FBTzlFLEdBQUcsR0FBSTVILENBQUFBLElBQUksR0FBRTtJQUM3QixPQUFPeU0sS0FBS2xDLEdBQUcsQ0FBQ29DO0FBQ2xCO0FBQ0FoRixHQUFHckosU0FBUyxDQUFDNEwsT0FBTyxHQUFHLFNBQVNBO0lBQzlCLElBQUk5SyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZdUksSUFBSTtZQUM5QixJQUFJMUYsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLE9BQU8sSUFBSSxDQUFDOEssT0FBTyxDQUFDakksRUFBRTJGLEdBQUcsRUFBRTNGLEVBQUU0RixHQUFHO1FBQ2xDLE9BQU8sSUFBSSxPQUFPekksU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQzNDLElBQUlxTCxNQUFNckwsU0FBUyxDQUFDLEVBQUU7WUFDdEIsSUFBSXdOLElBQUk7WUFDUixJQUFJQyxJQUFJO1lBQ1IsSUFBSUMsSUFBSTtZQUNSLElBQUloQixJQUFJO1lBQ1IsSUFBSTNFLElBQUk7WUFDUixJQUFJbEQsSUFBSTtZQUNSNkksSUFBSSxJQUFJLENBQUNsRixHQUFHLEdBQUc2QztZQUNmdEQsSUFBSTJGLElBQUksSUFBSSxDQUFDbEYsR0FBRztZQUNoQmtFLElBQUlnQixJQUFJM0Y7WUFDUjJFLElBQUlyQixNQUFNdEQsSUFBSyxLQUFJLENBQUNTLEdBQUcsR0FBR2tFLENBQUFBO1lBQzFCN0gsSUFBSTZILElBQUksSUFBSSxDQUFDakUsR0FBRztZQUNoQitFLElBQUlFLElBQUk3STtZQUNSNEksSUFBSTVJLElBQUs2SSxDQUFBQSxJQUFJRixDQUFBQTtZQUNiLElBQUksQ0FBQ2hGLEdBQUcsR0FBR2dGLElBQUlDO1lBQ2YsSUFBSSxDQUFDaEYsR0FBRyxHQUFHZ0YsSUFBS0QsQ0FBQUEsSUFBSSxJQUFJLENBQUNoRixHQUFHO1lBQzVCLE9BQU8sSUFBSTtRQUNiO0lBQ0YsT0FBTyxJQUFJeEksVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSStMLE1BQU0xTCxTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJMkwsTUFBTTNMLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUkyTixNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWLElBQUlDLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBQ1IsSUFBSUMsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSUMsTUFBTTtRQUNWSCxNQUFNLElBQUksQ0FBQ3ZGLEdBQUcsR0FBR2tEO1FBQ2pCbUMsSUFBSSxJQUFJLENBQUNwRixHQUFHLEdBQUdrRDtRQUNmc0MsTUFBTUYsTUFBTSxJQUFJLENBQUN2RixHQUFHO1FBQ3BCMEYsTUFBTUwsSUFBSSxJQUFJLENBQUNwRixHQUFHO1FBQ2xCdUYsTUFBTUQsTUFBTUU7UUFDWkgsSUFBSUQsSUFBSUs7UUFDUkYsTUFBTXRDLE1BQU11QyxNQUFPLEtBQUksQ0FBQ3pGLEdBQUcsR0FBR3dGLEdBQUU7UUFDaENGLElBQUluQyxNQUFNdUMsTUFBTyxLQUFJLENBQUN6RixHQUFHLEdBQUdxRixDQUFBQTtRQUM1QkcsTUFBTUQsTUFBTUg7UUFDWkYsTUFBTUksTUFBTUU7UUFDWkwsTUFBTUssTUFBT0YsQ0FBQUEsTUFBTUosR0FBRTtRQUNyQk0sTUFBTUgsSUFBSUY7UUFDVixJQUFJeEIsTUFBTXVCLE1BQU1NO1FBQ2hCLElBQUk1QixNQUFNNEIsTUFBT04sQ0FBQUEsTUFBTXZCLEdBQUU7UUFDekIsSUFBSSxDQUFDNUQsR0FBRyxHQUFHNEQ7UUFDWCxJQUFJLENBQUMzRCxHQUFHLEdBQUc0RDtRQUNYLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFDQTlELEdBQUdySixTQUFTLENBQUN5TixZQUFZLEdBQUcsU0FBU0E7SUFDbkMsSUFBSTNNLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVl1SSxJQUFJO1lBQzlCLElBQUkxRixJQUFJN0MsU0FBUyxDQUFDLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUMyTSxZQUFZLENBQUM5SixFQUFFMkYsR0FBRyxFQUFFM0YsRUFBRTRGLEdBQUc7UUFDdkMsT0FBTyxJQUFJLE9BQU96SSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7WUFDM0MsSUFBSXFMLE1BQU1yTCxTQUFTLENBQUMsRUFBRTtZQUN0QixPQUFPLElBQUksQ0FBQzJNLFlBQVksQ0FBQ3RCLEtBQUs7UUFDaEM7SUFDRixPQUFPLElBQUlyTCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJK0wsTUFBTTFMLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUkyTCxNQUFNM0wsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSW1PLEtBQUs7UUFDVCxJQUFJQyxLQUFLO1FBQ1QsSUFBSXRDLEtBQUs7UUFDVCxJQUFJQyxLQUFLO1FBQ1QsSUFBSUMsSUFBSTtRQUNSLElBQUloSixJQUFJO1FBQ1JnSixJQUFJekQsR0FBR2MsS0FBSyxHQUFHLElBQUksQ0FBQ2IsR0FBRztRQUN2QjJGLEtBQUtuQyxJQUFJLElBQUksQ0FBQ3hELEdBQUc7UUFDakJ4RixJQUFJdUYsR0FBR2MsS0FBSyxHQUFHcUM7UUFDZnlDLEtBQUtuQyxJQUFJbUM7UUFDVEMsS0FBSyxJQUFJLENBQUM1RixHQUFHLEdBQUcyRjtRQUNoQnJDLEtBQUs5SSxJQUFJMEk7UUFDVE0sSUFBSSxJQUFJLENBQUN4RCxHQUFHLEdBQUdrRDtRQUNmSSxLQUFLOUksSUFBSThJO1FBQ1RDLEtBQUtMLE1BQU1JO1FBQ1g5SSxJQUFJbUwsS0FBS3JDLEtBQUtFLElBQUltQyxLQUFLcEMsS0FBS3FDLEtBQUt0QyxLQUFLc0MsS0FBS3JDLEtBQU0sS0FBSSxDQUFDdkQsR0FBRyxHQUFHbUQsTUFBTSxJQUFJLENBQUNsRCxHQUFHLEdBQUdpRCxHQUFFO1FBQy9FLElBQUlVLE1BQU1KLElBQUloSjtRQUNkbUwsS0FBS25DLElBQUlJO1FBQ1QsSUFBSUMsTUFBTXJKLElBQUltTDtRQUNkLElBQUksQ0FBQzNGLEdBQUcsR0FBRzREO1FBQ1gsSUFBSSxDQUFDM0QsR0FBRyxHQUFHNEQ7UUFDWCxPQUFPLElBQUk7SUFDYjtBQUNGO0FBQ0E5RCxHQUFHckosU0FBUyxDQUFDbVAsT0FBTyxHQUFHLFNBQVNBO0lBQzlCLE9BQU8sSUFBSSxDQUFDMUIsWUFBWSxDQUFDLElBQUk7QUFDL0I7QUFDQXBFLEdBQUdySixTQUFTLENBQUNzQixLQUFLLEdBQUcsU0FBU0E7SUFDNUIsSUFBSSxJQUFJLENBQUNFLEtBQUssSUFBSTtRQUFFLE9BQU82SCxHQUFHekQsR0FBRztJQUFDO0lBQ2xDLElBQUkrSCxNQUFNak4sS0FBS1ksS0FBSyxDQUFDLElBQUksQ0FBQ2dJLEdBQUc7SUFDN0IsSUFBSXNFLE1BQU07SUFDVixJQUFJRCxRQUFRLElBQUksQ0FBQ3JFLEdBQUcsRUFBRTtRQUNwQnNFLE1BQU1sTixLQUFLWSxLQUFLLENBQUMsSUFBSSxDQUFDaUksR0FBRztJQUMzQjtJQUNBLE9BQU8sSUFBSUYsR0FBR3NFLEtBQUtDO0FBQ3JCO0FBQ0F2RSxHQUFHckosU0FBUyxDQUFDa00sTUFBTSxHQUFHLFNBQVNBO0lBQzdCLElBQUksSUFBSSxDQUFDMUssS0FBSyxJQUFJO1FBQUUsT0FBTyxJQUFJO0lBQUM7SUFDaEMsT0FBTyxJQUFJNkgsR0FBRyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDQyxHQUFHO0FBQ3BDO0FBQ0FGLEdBQUdySixTQUFTLENBQUMrRSxLQUFLLEdBQUcsU0FBU0E7QUFDNUIsUUFBUTtBQUNSLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsa0RBQWtEO0FBQ2xELGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNqQjtBQUNBc0UsR0FBR3JKLFNBQVMsQ0FBQ21MLFFBQVEsR0FBRyxTQUFTQTtJQUMvQixJQUFJckssU0FBUyxDQUFDLEVBQUUsWUFBWXVJLElBQUk7UUFDOUIsSUFBSTFGLElBQUk3QyxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJNkMsRUFBRW5DLEtBQUssSUFBSTtZQUFFLE9BQU82SCxHQUFHK0QsU0FBUztRQUFHO1FBQ3ZDLE9BQU8vRCxHQUFHckUsSUFBSSxDQUFDLElBQUksRUFBRXlJLFlBQVksQ0FBQzlKO0lBQ3BDLE9BQU8sSUFBSSxPQUFPN0MsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzNDLElBQUlxTCxNQUFNckwsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSStCLE9BQU9yQixLQUFLLENBQUMySyxNQUFNO1lBQUUsT0FBTzlDLEdBQUcrRCxTQUFTO1FBQUc7UUFDL0MsT0FBTy9ELEdBQUdyRSxJQUFJLENBQUMsSUFBSSxFQUFFeUksWUFBWSxDQUFDdEIsS0FBSztJQUN6QztBQUNGO0FBQ0E5QyxHQUFHckosU0FBUyxDQUFDd0IsS0FBSyxHQUFHLFNBQVNBO0lBQzVCLE9BQU9xQixPQUFPckIsS0FBSyxDQUFDLElBQUksQ0FBQzhILEdBQUc7QUFDOUI7QUFDQUQsR0FBR3JKLFNBQVMsQ0FBQ2lKLFFBQVEsR0FBRyxTQUFTQTtJQUMvQixPQUFPdkksS0FBS2UsS0FBSyxDQUFDLElBQUksQ0FBQzZILEdBQUc7QUFDNUI7QUFDQUQsR0FBR3JKLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtJQUMvQixJQUFJNEYsTUFBTXhCLEdBQUd1QixTQUFTLENBQUMsSUFBSSxDQUFDdEIsR0FBRztJQUMvQixJQUFJdUIsT0FBTyxDQUFDLEtBQUtBLE9BQU8sSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDdUUsa0JBQWtCO0lBQUc7SUFDL0QsT0FBTyxJQUFJLENBQUNDLGFBQWE7QUFDM0I7QUFDQWhHLEdBQUdySixTQUFTLENBQUNvUCxrQkFBa0IsR0FBRyxTQUFTQTtJQUN6QyxJQUFJRSxhQUFhLElBQUksQ0FBQ2hELHNCQUFzQjtJQUM1QyxJQUFJZ0QsZUFBZSxNQUFNO1FBQUUsT0FBT0E7SUFBVztJQUM3QyxJQUFJMUUsWUFBWSxJQUFJN0ssTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDbEMsSUFBSWtQLFlBQVksSUFBSSxDQUFDN0Usd0JBQXdCLENBQUMsTUFBTUU7SUFDcEQsSUFBSVEsa0JBQWtCUixTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3JDLElBQUk0RSxNQUFNRDtJQUNWLElBQUlBLFVBQVVFLE1BQU0sQ0FBQyxPQUFPLEtBQUs7UUFDL0JELE1BQU0sTUFBTUQ7SUFDZCxPQUFPLElBQUluRSxrQkFBa0IsR0FBRztRQUM5Qm9FLE1BQU0sT0FBT25HLEdBQUdxRyxZQUFZLENBQUMsS0FBSyxDQUFDdEUsbUJBQW1CbUU7SUFDeEQsT0FBTyxJQUFJQSxVQUFVbEksT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1FBQ3hDLElBQUlzSSxZQUFZdkUsa0JBQWtCbUUsVUFBVTlPLE1BQU07UUFDbEQsSUFBSW1QLFNBQVN2RyxHQUFHcUcsWUFBWSxDQUFDLEtBQUtDO1FBQ2xDSCxNQUFNRCxZQUFZSyxTQUFTO0lBQzdCO0lBQ0EsSUFBSSxJQUFJLENBQUMzQixVQUFVLElBQUk7UUFBRSxPQUFPLE1BQU11QjtJQUFJO0lBQzFDLE9BQU9BO0FBQ1Q7QUFDQW5HLEdBQUdySixTQUFTLENBQUMwTixVQUFVLEdBQUcsU0FBU0E7SUFDakMsSUFBSWhCLEtBQUs7SUFDVCxJQUFJQyxLQUFLO0lBQ1QsSUFBSUMsS0FBSztJQUNULElBQUlDLEtBQUs7SUFDVCxJQUFJQyxJQUFJO0lBQ1IsSUFBSWhKLElBQUk7SUFDUixJQUFJaUosSUFBSTtJQUNSLElBQUlDLElBQUk7SUFDUkYsSUFBSSxNQUFNLElBQUksQ0FBQ3hELEdBQUc7SUFDbEJ4RixJQUFJdUYsR0FBR2MsS0FBSyxHQUFHMkM7SUFDZkosS0FBSzVJLElBQUlnSjtJQUNURSxJQUFJM0QsR0FBR2MsS0FBSyxHQUFHLElBQUksQ0FBQ2IsR0FBRztJQUN2Qm9ELEtBQUs1SSxJQUFJNEk7SUFDVEMsS0FBS0csSUFBSUo7SUFDVEUsS0FBS0ksSUFBSSxJQUFJLENBQUMxRCxHQUFHO0lBQ2pCeUQsSUFBSUQsSUFBSSxJQUFJLENBQUN4RCxHQUFHO0lBQ2hCc0QsS0FBS0ksSUFBSUo7SUFDVEMsS0FBSyxJQUFJLENBQUN2RCxHQUFHLEdBQUdzRDtJQUNoQkksSUFBSU4sS0FBS0UsS0FBS0csSUFBSUwsS0FBS0csS0FBS0YsS0FBS0MsS0FBS0QsS0FBS0U7SUFDM0MvSSxJQUFJLENBQUMsTUFBTWlKLElBQUlDLElBQUlGLElBQUksSUFBSSxDQUFDdkQsR0FBRyxJQUFJLElBQUksQ0FBQ0QsR0FBRztJQUMzQyxJQUFJNEQsTUFBTUosSUFBSWhKO0lBQ2QsSUFBSXFKLE1BQU1MLElBQUlJLE1BQU1wSjtJQUNwQixPQUFPLElBQUl1RixHQUFHNkQsS0FBS0M7QUFDckI7QUFDQTlELEdBQUdySixTQUFTLENBQUNxUCxhQUFhLEdBQUcsU0FBU0E7SUFDcEMsSUFBSSxJQUFJLENBQUNqRCxNQUFNLElBQUk7UUFBRSxPQUFPL0MsR0FBR21CLFlBQVk7SUFBQztJQUM1QyxJQUFJOEUsYUFBYSxJQUFJLENBQUNoRCxzQkFBc0I7SUFDNUMsSUFBSWdELGVBQWUsTUFBTTtRQUFFLE9BQU9BO0lBQVc7SUFDN0MsSUFBSTFFLFlBQVksSUFBSTdLLE1BQU0sR0FBR00sSUFBSSxDQUFDO0lBQ2xDLElBQUl3UCxTQUFTLElBQUksQ0FBQ25GLHdCQUF3QixDQUFDLE9BQU9FO0lBQ2xELElBQUlrRixTQUFTekcsR0FBR2tCLHFCQUFxQixHQUFHSyxTQUFTLENBQUMsRUFBRTtJQUNwRCxJQUFJaUYsT0FBT0osTUFBTSxDQUFDLE9BQU8sS0FBSztRQUM1QixNQUFNLElBQUlwTixNQUFNLHlCQUF5QndOO0lBQzNDO0lBQ0EsSUFBSUUsaUJBQWlCO0lBQ3JCLElBQUlGLE9BQU9wUCxNQUFNLEdBQUcsR0FBRztRQUFFc1AsaUJBQWlCRixPQUFPRyxTQUFTLENBQUM7SUFBSTtJQUMvRCxJQUFJQyxvQkFBb0JKLE9BQU9KLE1BQU0sQ0FBQyxLQUFLLE1BQU1NO0lBQ2pELElBQUksSUFBSSxDQUFDOUIsVUFBVSxJQUFJO1FBQUUsT0FBTyxNQUFNZ0Msb0JBQW9CSDtJQUFPO0lBQ2pFLE9BQU9HLG9CQUFvQkg7QUFDN0I7QUFDQXpHLEdBQUdySixTQUFTLENBQUNtQyxHQUFHLEdBQUcsU0FBU0E7SUFDMUIsSUFBSSxJQUFJLENBQUNYLEtBQUssSUFBSTtRQUFFLE9BQU82SCxHQUFHekQsR0FBRztJQUFDO0lBQ2xDLElBQUksSUFBSSxDQUFDcUksVUFBVSxJQUFJO1FBQUUsT0FBTyxJQUFJLENBQUMvQixNQUFNO0lBQUc7SUFDOUMsT0FBTyxJQUFJN0MsR0FBRyxJQUFJO0FBQ3BCO0FBQ0FBLEdBQUdySixTQUFTLENBQUNrUSxVQUFVLEdBQUcsU0FBU0E7SUFDakMsT0FBTyxDQUFDLElBQUksQ0FBQzVHLEdBQUcsR0FBRyxPQUFPLElBQUksQ0FBQ0EsR0FBRyxLQUFLLEdBQUUsS0FBTSxJQUFJLENBQUNDLEdBQUcsR0FBRztBQUM1RDtBQUNBRixHQUFHckosU0FBUyxDQUFDa0wsRUFBRSxHQUFHLFNBQVNBLEdBQUl2SCxDQUFDO0lBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUMyRixHQUFHLEdBQUczRixFQUFFMkYsR0FBRyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxLQUFLM0YsRUFBRTJGLEdBQUcsS0FBSyxJQUFJLENBQUNDLEdBQUcsR0FBRzVGLEVBQUU0RixHQUFHO0FBQ3JFO0FBQ0FGLEdBQUdySixTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0E7SUFDMUIsSUFBSW5MLFNBQVMsQ0FBQyxFQUFFLFlBQVl1SSxJQUFJO1FBQzlCLElBQUkxRixJQUFJN0MsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBT3VJLEdBQUdyRSxJQUFJLENBQUMsSUFBSSxFQUFFNEcsT0FBTyxDQUFDakk7SUFDL0IsT0FBTyxJQUFJLE9BQU83QyxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7UUFDM0MsSUFBSXFMLE1BQU1yTCxTQUFTLENBQUMsRUFBRTtRQUN0QixPQUFPdUksR0FBR3JFLElBQUksQ0FBQyxJQUFJLEVBQUU0RyxPQUFPLENBQUNPO0lBQy9CO0FBQ0Y7QUFDQTlDLEdBQUdySixTQUFTLENBQUN3SixJQUFJLEdBQUcsU0FBU0E7SUFDM0IsSUFBSTFJLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUksT0FBT0ssU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQ3BDLElBQUlZLElBQUlaLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUksQ0FBQ3dJLEdBQUcsR0FBRzVIO1lBQ1gsSUFBSSxDQUFDNkgsR0FBRyxHQUFHO1FBQ2IsT0FBTyxJQUFJekksU0FBUyxDQUFDLEVBQUUsWUFBWXVJLElBQUk7WUFDckMsSUFBSUksS0FBSzNJLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQ3dJLEdBQUcsR0FBR0csR0FBR0gsR0FBRztZQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0UsR0FBR0YsR0FBRztRQUNuQjtJQUNGLE9BQU8sSUFBSXpJLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlrSixLQUFLN0ksU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSThJLEtBQUs5SSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUN3SSxHQUFHLEdBQUdLO1FBQ1gsSUFBSSxDQUFDSixHQUFHLEdBQUdLO0lBQ2I7QUFDRjtBQUNBUCxHQUFHckosU0FBUyxDQUFDaUwsRUFBRSxHQUFHLFNBQVNBLEdBQUl0SCxDQUFDO0lBQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUMyRixHQUFHLEdBQUczRixFQUFFMkYsR0FBRyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxLQUFLM0YsRUFBRTJGLEdBQUcsS0FBSyxJQUFJLENBQUNDLEdBQUcsR0FBRzVGLEVBQUU0RixHQUFHO0FBQ3JFO0FBQ0FGLEdBQUdySixTQUFTLENBQUNpTyxVQUFVLEdBQUcsU0FBU0E7SUFDakMsT0FBTyxDQUFDLElBQUksQ0FBQzNFLEdBQUcsR0FBRyxPQUFPLElBQUksQ0FBQ0EsR0FBRyxLQUFLLEdBQUUsS0FBTSxJQUFJLENBQUNDLEdBQUcsR0FBRztBQUM1RDtBQUNBRixHQUFHckosU0FBUyxDQUFDeUIsS0FBSyxHQUFHLFNBQVNBO0lBQzVCLElBQUksSUFBSSxDQUFDRCxLQUFLLElBQUk7UUFBRSxPQUFPNkgsR0FBR3pELEdBQUc7SUFBQztJQUNsQyxJQUFJLElBQUksQ0FBQ3NLLFVBQVUsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDNU8sS0FBSztJQUFJLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ0ssSUFBSTtJQUFHO0FBQzVFO0FBQ0EwSCxHQUFHckosU0FBUyxDQUFDbVEsTUFBTSxHQUFHLFNBQVNBO0lBQzdCLElBQUksSUFBSSxDQUFDN0csR0FBRyxHQUFHLEdBQUc7UUFBRSxPQUFPO0lBQUU7SUFDN0IsSUFBSSxJQUFJLENBQUNBLEdBQUcsR0FBRyxHQUFHO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDOUIsSUFBSSxJQUFJLENBQUNDLEdBQUcsR0FBRyxHQUFHO1FBQUUsT0FBTztJQUFFO0lBQzdCLElBQUksSUFBSSxDQUFDQSxHQUFHLEdBQUcsR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzlCLE9BQU87QUFDVDtBQUNBRixHQUFHckosU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xDLE9BQU87UUFBQzRCO1FBQWNIO1FBQVlDO0tBQVM7QUFDN0M7QUFDQThGLEdBQUdySixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDL0IsT0FBT3VIO0FBQ1Q7QUFDQUEsR0FBRzBDLEdBQUcsR0FBRyxTQUFTQSxJQUFLckssQ0FBQztJQUN0QixPQUFPMkgsR0FBR3NDLE9BQU8sQ0FBQ2pLLEdBQUcrTCxZQUFZLENBQUMvTDtBQUNwQztBQUNBMkgsR0FBR3NDLE9BQU8sR0FBRyxTQUFTQTtJQUNwQixJQUFJLE9BQU83SyxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7UUFDcEMsSUFBSTZILE1BQU03SCxTQUFTLENBQUMsRUFBRTtRQUN0QixPQUFPdUksR0FBR0ssS0FBSyxDQUFDZjtJQUNsQixPQUFPLElBQUksT0FBTzdILFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUMzQyxJQUFJWSxJQUFJWixTQUFTLENBQUMsRUFBRTtRQUNwQixPQUFPLElBQUl1SSxHQUFHM0g7SUFDaEI7QUFDRjtBQUNBMkgsR0FBRy9ELElBQUksR0FBRyxTQUFTQSxLQUFNNUQsQ0FBQztJQUN4QixPQUFPMkgsR0FBR3NDLE9BQU8sQ0FBQ2pLLEdBQUc0RCxJQUFJO0FBQzNCO0FBQ0ErRCxHQUFHSyxLQUFLLEdBQUcsU0FBU0EsTUFBT2YsR0FBRztJQUM1QixJQUFJdkIsSUFBSTtJQUNSLElBQUlnSixTQUFTekgsSUFBSWxJLE1BQU07SUFDdkIsTUFBT3lJLFVBQVVDLFlBQVksQ0FBQ1IsSUFBSThHLE1BQU0sQ0FBQ3JJLElBQUs7UUFBRUE7SUFBSztJQUNyRCxJQUFJNkcsYUFBYTtJQUNqQixJQUFJN0csSUFBSWdKLFFBQVE7UUFDZCxJQUFJQyxTQUFTMUgsSUFBSThHLE1BQU0sQ0FBQ3JJO1FBQ3hCLElBQUlpSixXQUFXLE9BQU9BLFdBQVcsS0FBSztZQUNwQ2pKO1lBQ0EsSUFBSWlKLFdBQVcsS0FBSztnQkFBRXBDLGFBQWE7WUFBTTtRQUMzQztJQUNGO0lBQ0EsSUFBSTVNLE1BQU0sSUFBSWdJO0lBQ2QsSUFBSWlDLFlBQVk7SUFDaEIsSUFBSWdGLGVBQWU7SUFDbkIsSUFBSWhELE1BQU07SUFDVixNQUFPLEtBQU07UUFDWCxJQUFJbEcsS0FBS2dKLFFBQVE7WUFBRTtRQUFNO1FBQ3pCLElBQUlHLEtBQUs1SCxJQUFJOEcsTUFBTSxDQUFDckk7UUFDcEJBO1FBQ0EsSUFBSThCLFVBQVVzSCxPQUFPLENBQUNELEtBQUs7WUFDekIsSUFBSUUsSUFBSUYsS0FBSztZQUNibFAsSUFBSW9NLFlBQVksQ0FBQ3BFLEdBQUdnQixHQUFHO1lBQ3ZCaEosSUFBSXVLLE9BQU8sQ0FBQzZFO1lBQ1puRjtZQUNBO1FBQ0Y7UUFDQSxJQUFJaUYsT0FBTyxLQUFLO1lBQ2RELGVBQWVoRjtZQUNmO1FBQ0Y7UUFDQSxJQUFJaUYsT0FBTyxPQUFPQSxPQUFPLEtBQUs7WUFDNUIsSUFBSVQsU0FBU25ILElBQUlxSCxTQUFTLENBQUM1STtZQUMzQixJQUFJO2dCQUNGa0csTUFBTXRFLFFBQVFqSSxRQUFRLENBQUMrTztZQUN6QixFQUFFLE9BQU9ZLElBQUk7Z0JBQ1gsSUFBSUEsY0FBY3JPLE9BQU87b0JBQ3ZCLE1BQU0sSUFBSUEsTUFBTSxzQkFBc0J5TixTQUFTLGdCQUFnQm5IO2dCQUNqRSxPQUFPO29CQUFFLE1BQU0rSDtnQkFBRztZQUNwQixTQUFVLENBQUM7WUFDWDtRQUNGO1FBQ0EsTUFBTSxJQUFJck8sTUFBTSwyQkFBMkJrTyxLQUFLLG1CQUFtQm5KLElBQUksZ0JBQWdCdUI7SUFDekY7SUFDQSxJQUFJZ0ksT0FBT3RQO0lBQ1gsSUFBSXVQLGVBQWV0RixZQUFZZ0YsZUFBZWhEO0lBQzlDLElBQUlzRCxpQkFBaUIsR0FBRztRQUN0QkQsT0FBT3RQO0lBQ1QsT0FBTyxJQUFJdVAsZUFBZSxHQUFHO1FBQzNCLElBQUk5RixRQUFRekIsR0FBR2dCLEdBQUcsQ0FBQ1UsR0FBRyxDQUFDNkY7UUFDdkJELE9BQU90UCxJQUFJMkosTUFBTSxDQUFDRjtJQUNwQixPQUFPLElBQUk4RixlQUFlLEdBQUc7UUFDM0IsSUFBSUMsVUFBVXhILEdBQUdnQixHQUFHLENBQUNVLEdBQUcsQ0FBQyxDQUFDNkY7UUFDMUJELE9BQU90UCxJQUFJOEosUUFBUSxDQUFDMEY7SUFDdEI7SUFDQSxJQUFJNUMsWUFBWTtRQUNkLE9BQU8wQyxLQUFLekUsTUFBTTtJQUNwQjtJQUNBLE9BQU95RTtBQUNUO0FBQ0F0SCxHQUFHK0QsU0FBUyxHQUFHLFNBQVNBO0lBQ3RCLE9BQU8sSUFBSS9ELEdBQUd4RyxPQUFPK0MsR0FBRyxFQUFFL0MsT0FBTytDLEdBQUc7QUFDdEM7QUFDQXlELEdBQUdyRSxJQUFJLEdBQUcsU0FBU0EsS0FBTXlFLEVBQUU7SUFDekIsT0FBTyxJQUFJSixHQUFHSTtBQUNoQjtBQUNBSixHQUFHdUIsU0FBUyxHQUFHLFNBQVNBLFVBQVdsSixDQUFDO0lBQ2xDLElBQUlvUCxPQUFPcFEsS0FBS3lCLEdBQUcsQ0FBQ1Q7SUFDcEIsSUFBSXFQLFNBQVNyUSxLQUFLaUgsR0FBRyxDQUFDbUosUUFBUXBRLEtBQUtpSCxHQUFHLENBQUM7SUFDdkMsSUFBSXFKLE9BQU90USxLQUFLZSxLQUFLLENBQUNmLEtBQUtZLEtBQUssQ0FBQ3lQO0lBQ2pDLElBQUlFLFVBQVV2USxLQUFLcUssR0FBRyxDQUFDLElBQUlpRztJQUMzQixJQUFJQyxVQUFVLE1BQU1ILE1BQU07UUFBRUUsUUFBUTtJQUFHO0lBQ3ZDLE9BQU9BO0FBQ1Q7QUFDQTNILEdBQUdxRyxZQUFZLEdBQUcsU0FBU0EsYUFBY2EsRUFBRSxFQUFFVyxHQUFHO0lBQzlDLElBQUk3RixNQUFNLElBQUkzQztJQUNkLElBQUssSUFBSXRCLElBQUksR0FBR0EsSUFBSThKLEtBQUs5SixJQUFLO1FBQzVCaUUsSUFBSXpDLE1BQU0sQ0FBQzJIO0lBQ2I7SUFDQSxPQUFPbEYsSUFBSXBHLFFBQVE7QUFDckI7QUFDQTRFLGtCQUFrQkMsRUFBRSxDQUFDMUcsR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJaUcsR0FBRywwQkFBMEI7QUFBMEI7QUFDM0dRLGtCQUFrQkUsTUFBTSxDQUFDM0csR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJaUcsR0FBRywwQkFBMEI7QUFBMEI7QUFDL0dRLGtCQUFrQkcsSUFBSSxDQUFDNUcsR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJaUcsR0FBRywwQkFBMEI7QUFBMEI7QUFDN0dRLGtCQUFrQkksQ0FBQyxDQUFDN0csR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJaUcsR0FBRywwQkFBMEI7QUFBMEI7QUFDMUdRLGtCQUFrQmpFLEdBQUcsQ0FBQ3hDLEdBQUcsR0FBRztJQUFjLE9BQU8sSUFBSWlHLEdBQUd4RyxPQUFPK0MsR0FBRyxFQUFFL0MsT0FBTytDLEdBQUc7QUFBRTtBQUNoRmlFLGtCQUFrQkssR0FBRyxDQUFDOUcsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFxQjtBQUN0RXlHLGtCQUFrQk0sS0FBSyxDQUFDL0csR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFZO0FBQy9EeUcsa0JBQWtCTyxnQkFBZ0IsQ0FBQ2hILEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRztBQUNqRXlHLGtCQUFrQlEsR0FBRyxDQUFDakgsR0FBRyxHQUFHO0lBQWMsT0FBT2lHLEdBQUdzQyxPQUFPLENBQUM7QUFBTTtBQUNsRTlCLGtCQUFrQlMsR0FBRyxDQUFDbEgsR0FBRyxHQUFHO0lBQWMsT0FBT2lHLEdBQUdzQyxPQUFPLENBQUM7QUFBSztBQUNqRTlCLGtCQUFrQlUscUJBQXFCLENBQUNuSCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUk7QUFDdkV5RyxrQkFBa0JXLFlBQVksQ0FBQ3BILEdBQUcsR0FBRztJQUFjLE9BQU87QUFBUTtBQUVsRW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRWdHLElBQUlRO0FBRTdCLElBQUlzSCxpQkFBaUIsU0FBU0Esa0JBQW1CO0FBRWpELElBQUlDLG9CQUFvQjtJQUFFQyxpQkFBaUI7UUFBRWxSLGNBQWM7SUFBSztBQUFFO0FBRWxFZ1IsZUFBZW5SLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM5QyxPQUFPLEVBQUU7QUFDWDtBQUNBc1AsZUFBZW5SLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPcVA7QUFDVDtBQUNBQSxlQUFlRyxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxDQUFDO0lBQ3BFLElBQUlwSixRQUFROEksZUFBZU8sc0JBQXNCLENBQUNILElBQUlDLElBQUlDO0lBQzFELElBQUlwSixTQUFTLEdBQUc7UUFBRSxPQUFPQTtJQUFNO0lBQy9CLElBQUlzSixNQUFNdEksR0FBR3NDLE9BQU8sQ0FBQzZGLEdBQUc5UCxDQUFDLEVBQUVrSyxPQUFPLENBQUMsQ0FBQzJGLEdBQUc3UCxDQUFDO0lBQ3hDLElBQUlrUSxNQUFNdkksR0FBR3NDLE9BQU8sQ0FBQzZGLEdBQUc3TixDQUFDLEVBQUVpSSxPQUFPLENBQUMsQ0FBQzJGLEdBQUc1TixDQUFDO0lBQ3hDLElBQUlrTyxNQUFNeEksR0FBR3NDLE9BQU8sQ0FBQzhGLEVBQUUvUCxDQUFDLEVBQUVrSyxPQUFPLENBQUMsQ0FBQzRGLEdBQUc5UCxDQUFDO0lBQ3ZDLElBQUlvUSxNQUFNekksR0FBR3NDLE9BQU8sQ0FBQzhGLEVBQUU5TixDQUFDLEVBQUVpSSxPQUFPLENBQUMsQ0FBQzRGLEdBQUc3TixDQUFDO0lBQ3ZDLE9BQU9nTyxJQUFJbEUsWUFBWSxDQUFDcUUsS0FBS3pGLFlBQVksQ0FBQ3VGLElBQUluRSxZQUFZLENBQUNvRSxNQUFNMUIsTUFBTTtBQUN6RTtBQUNBZ0IsZUFBZVksWUFBWSxHQUFHLFNBQVNBLGFBQWMvUCxFQUFFLEVBQUVnUSxFQUFFLEVBQUUvUCxFQUFFLEVBQUVnUSxFQUFFO0lBQ2pFLElBQUlDLE1BQU1sUSxHQUFHbUosUUFBUSxDQUFDOEcsSUFBSTVGLFlBQVksQ0FBQzJGLEdBQUc3RyxRQUFRLENBQUNsSjtJQUNuRCxPQUFPaVEsSUFBSS9CLE1BQU07QUFDbkI7QUFDQWdCLGVBQWVnQixZQUFZLEdBQUcsU0FBU0EsYUFBY1osRUFBRSxFQUFFQyxFQUFFLEVBQUVZLEVBQUUsRUFBRUMsRUFBRTtJQUNqRSxJQUFJQyxTQUFTakosR0FBR3NDLE9BQU8sQ0FBQzBHLEdBQUcxTyxDQUFDLEVBQUUwSSxZQUFZLENBQUMrRixHQUFHek8sQ0FBQyxFQUFFOEosWUFBWSxDQUFDcEUsR0FBR3NDLE9BQU8sQ0FBQzZGLEdBQUc5UCxDQUFDLEVBQUUySyxZQUFZLENBQUNrRixHQUFHN1AsQ0FBQztJQUNoRyxJQUFJNlEsU0FBU2xKLEdBQUdzQyxPQUFPLENBQUMwRyxHQUFHM1EsQ0FBQyxFQUFFMkssWUFBWSxDQUFDK0YsR0FBRzFRLENBQUMsRUFBRStMLFlBQVksQ0FBQ3BFLEdBQUdzQyxPQUFPLENBQUM2RixHQUFHN04sQ0FBQyxFQUFFMEksWUFBWSxDQUFDa0YsR0FBRzVOLENBQUM7SUFDaEcsSUFBSTZPLFFBQVFGLE9BQU81RyxRQUFRLENBQUM2RztJQUM1QixJQUFJRSxRQUFRcEosR0FBR3NDLE9BQU8sQ0FBQzBHLEdBQUczUSxDQUFDLEVBQUUySyxZQUFZLENBQUMrRixHQUFHMVEsQ0FBQyxFQUFFK0wsWUFBWSxDQUFDcEUsR0FBR3NDLE9BQU8sQ0FBQzRGLEdBQUc1TixDQUFDLEVBQUUwSSxZQUFZLENBQUMrRixHQUFHek8sQ0FBQztJQUMvRixJQUFJK08sUUFBUXJKLEdBQUdzQyxPQUFPLENBQUMwRyxHQUFHMU8sQ0FBQyxFQUFFMEksWUFBWSxDQUFDK0YsR0FBR3pPLENBQUMsRUFBRThKLFlBQVksQ0FBQ3BFLEdBQUdzQyxPQUFPLENBQUM0RixHQUFHN1AsQ0FBQyxFQUFFMkssWUFBWSxDQUFDK0YsR0FBRzFRLENBQUM7SUFDL0YsSUFBSWlSLE9BQU9GLE1BQU0vRyxRQUFRLENBQUNnSDtJQUMxQixJQUFJRSxRQUFRRCxLQUFLcEcsVUFBVSxDQUFDaUcsT0FBT3hHLFdBQVc7SUFDOUMsSUFBSXRLLElBQUkySCxHQUFHc0MsT0FBTyxDQUFDNEYsR0FBRzdQLENBQUMsRUFBRWtLLE9BQU8sQ0FBQ3ZDLEdBQUdzQyxPQUFPLENBQUM2RixHQUFHOVAsQ0FBQyxFQUFFMkssWUFBWSxDQUFDa0YsR0FBRzdQLENBQUMsRUFBRStMLFlBQVksQ0FBQ21GLFFBQVE1RyxXQUFXO0lBQ3JHLElBQUk2RyxRQUFReEosR0FBR3NDLE9BQU8sQ0FBQzZGLEdBQUc5UCxDQUFDLEVBQUUySyxZQUFZLENBQUNrRixHQUFHN1AsQ0FBQyxFQUFFK0wsWUFBWSxDQUFDcEUsR0FBR3NDLE9BQU8sQ0FBQzRGLEdBQUc1TixDQUFDLEVBQUUwSSxZQUFZLENBQUMrRixHQUFHek8sQ0FBQztJQUMvRixJQUFJbVAsUUFBUXpKLEdBQUdzQyxPQUFPLENBQUM2RixHQUFHN04sQ0FBQyxFQUFFMEksWUFBWSxDQUFDa0YsR0FBRzVOLENBQUMsRUFBRThKLFlBQVksQ0FBQ3BFLEdBQUdzQyxPQUFPLENBQUM0RixHQUFHN1AsQ0FBQyxFQUFFMkssWUFBWSxDQUFDK0YsR0FBRzFRLENBQUM7SUFDL0YsSUFBSXFSLE9BQU9GLE1BQU1uSCxRQUFRLENBQUNvSDtJQUMxQixJQUFJRSxRQUFRRCxLQUFLeEcsVUFBVSxDQUFDaUcsT0FBT3hHLFdBQVc7SUFDOUMsSUFBSXJJLElBQUkwRixHQUFHc0MsT0FBTyxDQUFDeUcsR0FBR3pPLENBQUMsRUFBRWlJLE9BQU8sQ0FBQ3ZDLEdBQUdzQyxPQUFPLENBQUMwRyxHQUFHMU8sQ0FBQyxFQUFFMEksWUFBWSxDQUFDK0YsR0FBR3pPLENBQUMsRUFBRThKLFlBQVksQ0FBQ3VGLFFBQVFoSCxXQUFXO0lBQ3JHLE9BQU8sSUFBSXRJLFdBQVdoQyxHQUFHaUM7QUFDM0I7QUFDQXdOLGVBQWVPLHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3QnVCLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFO0lBQ2pGLElBQUlDLFNBQVM7SUFDYixJQUFJQyxVQUFVLENBQUNKLEdBQUd2UixDQUFDLEdBQUd5UixHQUFHelIsQ0FBQyxJQUFLd1IsQ0FBQUEsR0FBR3ZQLENBQUMsR0FBR3dQLEdBQUd4UCxDQUFDO0lBQzFDLElBQUkyUCxXQUFXLENBQUNMLEdBQUd0UCxDQUFDLEdBQUd3UCxHQUFHeFAsQ0FBQyxJQUFLdVAsQ0FBQUEsR0FBR3hSLENBQUMsR0FBR3lSLEdBQUd6UixDQUFDO0lBQzNDLElBQUl3USxNQUFNbUIsVUFBVUM7SUFDcEIsSUFBSUQsVUFBVSxLQUFLO1FBQ2pCLElBQUlDLFlBQVksS0FBSztZQUNuQixPQUFPbkMsZUFBZWhCLE1BQU0sQ0FBQytCO1FBQy9CLE9BQU87WUFDTGtCLFNBQVNDLFVBQVVDO1FBQ3JCO0lBQ0YsT0FBTyxJQUFJRCxVQUFVLEtBQUs7UUFDeEIsSUFBSUMsWUFBWSxLQUFLO1lBQ25CLE9BQU9uQyxlQUFlaEIsTUFBTSxDQUFDK0I7UUFDL0IsT0FBTztZQUNMa0IsU0FBUyxDQUFDQyxVQUFVQztRQUN0QjtJQUNGLE9BQU87UUFDTCxPQUFPbkMsZUFBZWhCLE1BQU0sQ0FBQytCO0lBQy9CO0lBQ0EsSUFBSXFCLFdBQVdwQyxlQUFlRSxlQUFlLEdBQUcrQjtJQUNoRCxJQUFJbEIsT0FBT3FCLFlBQVksQ0FBQ3JCLE9BQU9xQixVQUFVO1FBQ3ZDLE9BQU9wQyxlQUFlaEIsTUFBTSxDQUFDK0I7SUFDL0I7SUFDQSxPQUFPO0FBQ1Q7QUFDQWYsZUFBZWhCLE1BQU0sR0FBRyxTQUFTQSxPQUFRek8sQ0FBQztJQUN4QyxJQUFJQSxJQUFJLEdBQUc7UUFBRSxPQUFPO0lBQUU7SUFDdEIsSUFBSUEsSUFBSSxHQUFHO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDdkIsT0FBTztBQUNUO0FBQ0EwUCxrQkFBa0JDLGVBQWUsQ0FBQ2pPLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBTTtBQUVuRW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRThOLGdCQUFnQkM7QUFFekMsSUFBSW9DLHFCQUFxQixTQUFTQSxzQkFBdUI7QUFFekQsSUFBSUMsb0JBQW9CO0lBQUV2UCxHQUFHO1FBQUUvRCxjQUFjO0lBQUs7SUFBRWdFLEdBQUc7UUFBRWhFLGNBQWM7SUFBSztJQUFFaUUsR0FBRztRQUFFakUsY0FBYztJQUFLO0lBQUV1VCxHQUFHO1FBQUV2VCxjQUFjO0lBQUs7QUFBRTtBQUVsSXNULGtCQUFrQnZQLENBQUMsQ0FBQ2QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ2pEcVEsa0JBQWtCdFAsQ0FBQyxDQUFDZixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDakRxUSxrQkFBa0JyUCxDQUFDLENBQUNoQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDakRxUSxrQkFBa0JDLENBQUMsQ0FBQ3RRLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUNqRG9RLG1CQUFtQnhULFNBQVMsQ0FBQ3FFLFdBQVcsR0FBRyxTQUFTQSxZQUFhZ0UsS0FBSyxFQUFFL0QsYUFBYSxFQUFFbEUsS0FBSyxHQUFHO0FBQy9Gb1QsbUJBQW1CeFQsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBLFFBQVM7QUFDdERILG1CQUFtQnhULFNBQVMsQ0FBQ3lFLFdBQVcsR0FBRyxTQUFTQSxZQUFhNEQsS0FBSyxFQUFFL0QsYUFBYSxHQUFHO0FBQ3hGa1AsbUJBQW1CeFQsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBLGlCQUFrQjtBQUN4RUosbUJBQW1CeFQsU0FBUyxDQUFDNlQsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1Cek0sQ0FBQyxHQUFHO0FBQ2pGb00sbUJBQW1CeFQsU0FBUyxDQUFDOFQsWUFBWSxHQUFHLFNBQVNBLGdCQUFpQjtBQUN0RU4sbUJBQW1CeFQsU0FBUyxDQUFDK1QsSUFBSSxHQUFHLFNBQVNBLEtBQU0xTCxLQUFLLEdBQUc7QUFDM0RtTCxtQkFBbUJ4VCxTQUFTLENBQUMrRSxLQUFLLEdBQUcsU0FBU0EsU0FBVTtBQUN4RHlPLG1CQUFtQnhULFNBQVMsQ0FBQ2dVLGNBQWMsR0FBRyxTQUFTQSxlQUFnQkMsR0FBRyxHQUFHO0FBQzdFVCxtQkFBbUJ4VCxTQUFTLENBQUNnRixJQUFJLEdBQUcsU0FBU0EsUUFBUztBQUN0RHdPLG1CQUFtQnhULFNBQVMsQ0FBQ2tVLElBQUksR0FBRyxTQUFTQSxLQUFNN0wsS0FBSyxHQUFHO0FBQzNEbUwsbUJBQW1CeFQsU0FBUyxDQUFDbVUsaUJBQWlCLEdBQUcsU0FBU0EscUJBQXNCO0FBQ2hGWCxtQkFBbUJ4VCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTztRQUFDMEI7S0FBUztBQUNuQjtBQUNBaVEsbUJBQW1CeFQsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU8wUjtBQUNUO0FBRUF2VCxPQUFPb0QsZ0JBQWdCLENBQUVtUSxvQkFBb0JDO0FBRTdDLElBQUlXLFlBQVksU0FBU0EsYUFBYztBQUV2QyxJQUFJQyw0QkFBNkIsU0FBVUMsWUFBWTtJQUNyRCxTQUFTRDtRQUNQQyxhQUFhL1IsSUFBSSxDQUFDLElBQUksRUFBRTtJQUMxQjtJQUVBLElBQUsrUixjQUFlRCwwQkFBMEIzUixTQUFTLEdBQUc0UjtJQUMxREQsMEJBQTBCclUsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFMlIsZ0JBQWdCQSxhQUFhdFUsU0FBUztJQUMzRnFVLDBCQUEwQnJVLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3lSO0lBQ2xEQSwwQkFBMEJyVSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDekQsT0FBTyxFQUFFO0lBQ1g7SUFDQXdTLDBCQUEwQnJVLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUN0RCxPQUFPdVM7SUFDVDtJQUVBLE9BQU9BO0FBQ1QsRUFBRUQ7QUFFRixJQUFJRyxTQUFTLFNBQVNBLFVBQVc7QUFFakNBLE9BQU9DLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUUxRCxHQUFHO0lBQ3BFLElBQUlwTixJQUFJO0lBQ1IsSUFBSyxJQUFJc0QsSUFBSXNOLFFBQVF0TixJQUFJc04sU0FBU3hELEtBQUs5SixJQUFLO1FBQzFDdU4sSUFBSSxDQUFDQyxVQUFVOVEsRUFBRSxHQUFHMlEsR0FBRyxDQUFDck4sRUFBRTtRQUMxQnREO0lBQ0Y7QUFDRjtBQUVBeVEsT0FBT00sV0FBVyxHQUFHLFNBQVNBLFlBQWFyUyxJQUFJO0lBQzdDLE9BQU87UUFDTCxrQkFBa0I7SUFDcEIsRUFBQyxDQUFDQSxLQUFLO0FBQ1Q7QUFFQSxJQUFJc1MsY0FBYyxTQUFTQTtJQUN6QixJQUFJLENBQUNwVCxDQUFDLEdBQUc7SUFDVCxJQUFJLENBQUNpQyxDQUFDLEdBQUc7SUFDVCxJQUFJLENBQUNvUixDQUFDLEdBQUc7SUFDVCxJQUFJalUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSxDQUFDaUIsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDaUMsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDb1IsQ0FBQyxHQUFHO0lBQ1gsT0FBTyxJQUFJalUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXVVLElBQUlsVSxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUNZLENBQUMsR0FBR3NULEVBQUV0VCxDQUFDO1FBQ1osSUFBSSxDQUFDaUMsQ0FBQyxHQUFHcVIsRUFBRXJSLENBQUM7UUFDWixJQUFJLENBQUNvUixDQUFDLEdBQUc7SUFDWCxPQUFPLElBQUlqVSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJLE9BQU9LLFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBWSxPQUFPQSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7WUFDeEUsSUFBSW1VLEtBQUtuVSxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJb1UsS0FBS3BVLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQ1ksQ0FBQyxHQUFHdVQ7WUFDVCxJQUFJLENBQUN0UixDQUFDLEdBQUd1UjtZQUNULElBQUksQ0FBQ0gsQ0FBQyxHQUFHO1FBQ1gsT0FBTyxJQUFJalUsU0FBUyxDQUFDLEVBQUUsWUFBWWdVLGVBQWVoVSxTQUFTLENBQUMsRUFBRSxZQUFZZ1UsYUFBYTtZQUNyRixJQUFJdkQsS0FBS3pRLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUkwUSxLQUFLMVEsU0FBUyxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDWSxDQUFDLEdBQUc2UCxHQUFHNU4sQ0FBQyxHQUFHNk4sR0FBR3VELENBQUMsR0FBR3ZELEdBQUc3TixDQUFDLEdBQUc0TixHQUFHd0QsQ0FBQztZQUNsQyxJQUFJLENBQUNwUixDQUFDLEdBQUc2TixHQUFHOVAsQ0FBQyxHQUFHNlAsR0FBR3dELENBQUMsR0FBR3hELEdBQUc3UCxDQUFDLEdBQUc4UCxHQUFHdUQsQ0FBQztZQUNsQyxJQUFJLENBQUNBLENBQUMsR0FBR3hELEdBQUc3UCxDQUFDLEdBQUc4UCxHQUFHN04sQ0FBQyxHQUFHNk4sR0FBRzlQLENBQUMsR0FBRzZQLEdBQUc1TixDQUFDO1FBQ3BDLE9BQU8sSUFBSTdDLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxjQUFjNUMsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7WUFDbkYsSUFBSXlSLE9BQU9yVSxTQUFTLENBQUMsRUFBRTtZQUN2QixJQUFJc1UsT0FBT3RVLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZCLElBQUksQ0FBQ1ksQ0FBQyxHQUFHeVQsS0FBS3hSLENBQUMsR0FBR3lSLEtBQUt6UixDQUFDO1lBQ3hCLElBQUksQ0FBQ0EsQ0FBQyxHQUFHeVIsS0FBSzFULENBQUMsR0FBR3lULEtBQUt6VCxDQUFDO1lBQ3hCLElBQUksQ0FBQ3FULENBQUMsR0FBR0ksS0FBS3pULENBQUMsR0FBRzBULEtBQUt6UixDQUFDLEdBQUd5UixLQUFLMVQsQ0FBQyxHQUFHeVQsS0FBS3hSLENBQUM7UUFDNUM7SUFDRixPQUFPLElBQUk3QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNFUsT0FBT3ZVLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUl3VSxPQUFPeFUsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXlVLEtBQUt6VSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUNZLENBQUMsR0FBRzJUO1FBQ1QsSUFBSSxDQUFDMVIsQ0FBQyxHQUFHMlI7UUFDVCxJQUFJLENBQUNQLENBQUMsR0FBR1E7SUFDWCxPQUFPLElBQUl6VSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJK1UsT0FBTzFVLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUkyVSxPQUFPM1UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXNSLEtBQUt0UixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJdVIsS0FBS3ZSLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUk0VSxLQUFLRixLQUFLN1IsQ0FBQyxHQUFHOFIsS0FBSzlSLENBQUM7UUFDeEIsSUFBSWdTLEtBQUtGLEtBQUsvVCxDQUFDLEdBQUc4VCxLQUFLOVQsQ0FBQztRQUN4QixJQUFJa1UsS0FBS0osS0FBSzlULENBQUMsR0FBRytULEtBQUs5UixDQUFDLEdBQUc4UixLQUFLL1QsQ0FBQyxHQUFHOFQsS0FBSzdSLENBQUM7UUFDMUMsSUFBSWtTLEtBQUt6RCxHQUFHek8sQ0FBQyxHQUFHME8sR0FBRzFPLENBQUM7UUFDcEIsSUFBSW1TLEtBQUt6RCxHQUFHM1EsQ0FBQyxHQUFHMFEsR0FBRzFRLENBQUM7UUFDcEIsSUFBSXFVLEtBQUszRCxHQUFHMVEsQ0FBQyxHQUFHMlEsR0FBRzFPLENBQUMsR0FBRzBPLEdBQUczUSxDQUFDLEdBQUcwUSxHQUFHek8sQ0FBQztRQUNsQyxJQUFJLENBQUNqQyxDQUFDLEdBQUdpVSxLQUFLSSxLQUFLRCxLQUFLRjtRQUN4QixJQUFJLENBQUNqUyxDQUFDLEdBQUdrUyxLQUFLRCxLQUFLRixLQUFLSztRQUN4QixJQUFJLENBQUNoQixDQUFDLEdBQUdXLEtBQUtJLEtBQUtELEtBQUtGO0lBQzFCO0FBQ0Y7QUFDQWIsWUFBWTlVLFNBQVMsQ0FBQ2tVLElBQUksR0FBRyxTQUFTQTtJQUNwQyxJQUFJMU4sSUFBSSxJQUFJLENBQUM3QyxDQUFDLEdBQUcsSUFBSSxDQUFDb1IsQ0FBQztJQUN2QixJQUFJbFMsT0FBT3JCLEtBQUssQ0FBQ2dGLE1BQU0zRCxPQUFPTSxVQUFVLENBQUNxRCxJQUFJO1FBQzNDLE1BQU0sSUFBSTZOO0lBQ1o7SUFDQSxPQUFPN047QUFDVDtBQUNBc08sWUFBWTlVLFNBQVMsQ0FBQytULElBQUksR0FBRyxTQUFTQTtJQUNwQyxJQUFJdk4sSUFBSSxJQUFJLENBQUM5RSxDQUFDLEdBQUcsSUFBSSxDQUFDcVQsQ0FBQztJQUN2QixJQUFJbFMsT0FBT3JCLEtBQUssQ0FBQ2dGLE1BQU0zRCxPQUFPTSxVQUFVLENBQUNxRCxJQUFJO1FBQzNDLE1BQU0sSUFBSTZOO0lBQ1o7SUFDQSxPQUFPN047QUFDVDtBQUNBc08sWUFBWTlVLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQTtJQUM3QyxJQUFJb0IsSUFBSSxJQUFJdFI7SUFDWnNSLEVBQUV0VCxDQUFDLEdBQUcsSUFBSSxDQUFDcVMsSUFBSTtJQUNmaUIsRUFBRXJSLENBQUMsR0FBRyxJQUFJLENBQUN1USxJQUFJO0lBQ2YsT0FBT2M7QUFDVDtBQUNBRixZQUFZOVUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sRUFBRTtBQUNYO0FBQ0FpVCxZQUFZOVUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU9nVDtBQUNUO0FBQ0FBLFlBQVkzQyxZQUFZLEdBQUcsU0FBU0EsYUFBY1osRUFBRSxFQUFFQyxFQUFFLEVBQUVZLEVBQUUsRUFBRUMsRUFBRTtJQUM5RCxJQUFJcUQsS0FBS25FLEdBQUc1TixDQUFDLEdBQUc2TixHQUFHN04sQ0FBQztJQUNwQixJQUFJZ1MsS0FBS25FLEdBQUc5UCxDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQztJQUNwQixJQUFJa1UsS0FBS3JFLEdBQUc3UCxDQUFDLEdBQUc4UCxHQUFHN04sQ0FBQyxHQUFHNk4sR0FBRzlQLENBQUMsR0FBRzZQLEdBQUc1TixDQUFDO0lBQ2xDLElBQUlrUyxLQUFLekQsR0FBR3pPLENBQUMsR0FBRzBPLEdBQUcxTyxDQUFDO0lBQ3BCLElBQUltUyxLQUFLekQsR0FBRzNRLENBQUMsR0FBRzBRLEdBQUcxUSxDQUFDO0lBQ3BCLElBQUlxVSxLQUFLM0QsR0FBRzFRLENBQUMsR0FBRzJRLEdBQUcxTyxDQUFDLEdBQUcwTyxHQUFHM1EsQ0FBQyxHQUFHMFEsR0FBR3pPLENBQUM7SUFDbEMsSUFBSWpDLElBQUlpVSxLQUFLSSxLQUFLRCxLQUFLRjtJQUN2QixJQUFJalMsSUFBSWtTLEtBQUtELEtBQUtGLEtBQUtLO0lBQ3ZCLElBQUloQixJQUFJVyxLQUFLSSxLQUFLRCxLQUFLRjtJQUN2QixJQUFJSyxPQUFPdFUsSUFBSXFUO0lBQ2YsSUFBSWtCLE9BQU90UyxJQUFJb1I7SUFDZixJQUFJbFMsT0FBT3JCLEtBQUssQ0FBQ3dVLFNBQVVuVCxPQUFPTSxVQUFVLENBQUM2UyxTQUFTblQsT0FBT3JCLEtBQUssQ0FBQ3lVLFNBQVVwVCxPQUFPTSxVQUFVLENBQUM4UyxPQUFPO1FBQ3BHLE1BQU0sSUFBSTVCO0lBQ1o7SUFDQSxPQUFPLElBQUkzUSxXQUFXc1MsTUFBTUM7QUFDOUI7QUFFQSxJQUFJQyxXQUFXLFNBQVNBO0lBQ3RCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSXhWLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUksQ0FBQytJLElBQUk7SUFDWCxPQUFPLElBQUkxSSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtZQUN0QyxJQUFJc1IsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUksQ0FBQzBJLElBQUksQ0FBQ3dMLEVBQUV0VCxDQUFDLEVBQUVzVCxFQUFFdFQsQ0FBQyxFQUFFc1QsRUFBRXJSLENBQUMsRUFBRXFSLEVBQUVyUixDQUFDO1FBQzlCLE9BQU8sSUFBSTdDLFNBQVMsQ0FBQyxFQUFFLFlBQVlvVixVQUFVO1lBQzNDLElBQUlqQyxNQUFNblQsU0FBUyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDMEksSUFBSSxDQUFDeUs7UUFDWjtJQUNGLE9BQU8sSUFBSW5ULFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk4USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSTBRLEtBQUsxUSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUMwSSxJQUFJLENBQUMrSCxHQUFHN1AsQ0FBQyxFQUFFOFAsR0FBRzlQLENBQUMsRUFBRTZQLEdBQUc1TixDQUFDLEVBQUU2TixHQUFHN04sQ0FBQztJQUNsQyxPQUFPLElBQUk3QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJdUIsS0FBS2xCLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUltQixLQUFLbkIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSWtSLEtBQUtsUixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJbVIsS0FBS25SLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQzBJLElBQUksQ0FBQ3hILElBQUlDLElBQUkrUCxJQUFJQztJQUN4QjtBQUNGO0FBRUEsSUFBSXNFLG9CQUFvQjtJQUFFdFMsa0JBQWtCO1FBQUU5RCxjQUFjO0lBQUs7QUFBRTtBQUNuRStWLFNBQVNsVyxTQUFTLENBQUN3VyxPQUFPLEdBQUcsU0FBU0E7SUFDcEMsT0FBTyxJQUFJLENBQUNDLFFBQVEsS0FBSyxJQUFJLENBQUNDLFNBQVM7QUFDekM7QUFDQVIsU0FBU2xXLFNBQVMsQ0FBQzJFLE1BQU0sR0FBRyxTQUFTQSxPQUFRSCxLQUFLO0lBQ2hELElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCMFIsUUFBTyxHQUFJO1FBQ2hDLE9BQU87SUFDVDtJQUNBLElBQUlTLGdCQUFnQm5TO0lBQ3BCLElBQUksSUFBSSxDQUFDb1MsTUFBTSxJQUFJO1FBQ2pCLE9BQU9ELGNBQWNDLE1BQU07SUFDN0I7SUFDQSxPQUFPLElBQUksQ0FBQ1IsS0FBSyxLQUFLTyxjQUFjRSxPQUFPLE1BQU0sSUFBSSxDQUFDUCxLQUFLLEtBQUtLLGNBQWNHLE9BQU8sTUFBTSxJQUFJLENBQUNYLEtBQUssS0FBS1EsY0FBY0ksT0FBTyxNQUFNLElBQUksQ0FBQ1YsS0FBSyxLQUFLTSxjQUFjSyxPQUFPO0FBQzNLO0FBQ0FkLFNBQVNsVyxTQUFTLENBQUNtUyxZQUFZLEdBQUcsU0FBU0EsYUFBYzhCLEdBQUc7SUFDMUQsSUFBSSxJQUFJLENBQUMyQyxNQUFNLE1BQU0zQyxJQUFJMkMsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDSyxVQUFVLENBQUNoRCxNQUFNO1FBQUUsT0FBTyxJQUFJaUM7SUFBVztJQUNwRixJQUFJZ0IsVUFBVSxJQUFJLENBQUNmLEtBQUssR0FBR2xDLElBQUlrQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUdsQyxJQUFJa0MsS0FBSztJQUM3RCxJQUFJZ0IsVUFBVSxJQUFJLENBQUNkLEtBQUssR0FBR3BDLElBQUlvQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUdwQyxJQUFJb0MsS0FBSztJQUM3RCxJQUFJZSxVQUFVLElBQUksQ0FBQ2hCLEtBQUssR0FBR25DLElBQUltQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUduQyxJQUFJbUMsS0FBSztJQUM3RCxJQUFJaUIsVUFBVSxJQUFJLENBQUNmLEtBQUssR0FBR3JDLElBQUlxQyxLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUdyQyxJQUFJcUMsS0FBSztJQUM3RCxPQUFPLElBQUlKLFNBQVNnQixTQUFTRSxTQUFTRCxTQUFTRTtBQUNqRDtBQUNBbkIsU0FBU2xXLFNBQVMsQ0FBQzRXLE1BQU0sR0FBRyxTQUFTQTtJQUNuQyxPQUFPLElBQUksQ0FBQ1IsS0FBSyxHQUFHLElBQUksQ0FBQ0QsS0FBSztBQUNoQztBQUNBRCxTQUFTbFcsU0FBUyxDQUFDNlcsT0FBTyxHQUFHLFNBQVNBO0lBQ3BDLE9BQU8sSUFBSSxDQUFDVCxLQUFLO0FBQ25CO0FBQ0FGLFNBQVNsVyxTQUFTLENBQUNzWCxNQUFNLEdBQUcsU0FBU0E7SUFDbkMsSUFBSXhXLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFZO1lBQ3RDLElBQUlzUixJQUFJbFUsU0FBUyxDQUFDLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUN3VyxNQUFNLENBQUN0QyxFQUFFdFQsQ0FBQyxFQUFFc1QsRUFBRXJSLENBQUM7UUFDN0IsT0FBTyxJQUFJN0MsU0FBUyxDQUFDLEVBQUUsWUFBWW9WLFVBQVU7WUFDM0MsSUFBSTFSLFFBQVExRCxTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJLElBQUksQ0FBQzhWLE1BQU0sTUFBTXBTLE1BQU1vUyxNQUFNLElBQUk7Z0JBQ25DLE9BQU87WUFDVDtZQUNBLE9BQU9wUyxNQUFNdVMsT0FBTyxNQUFNLElBQUksQ0FBQ1osS0FBSyxJQUFJM1IsTUFBTXFTLE9BQU8sTUFBTSxJQUFJLENBQUNULEtBQUssSUFBSTVSLE1BQU13UyxPQUFPLE1BQU0sSUFBSSxDQUFDWCxLQUFLLElBQUk3UixNQUFNc1MsT0FBTyxNQUFNLElBQUksQ0FBQ1IsS0FBSztRQUN6STtJQUNGLE9BQU8sSUFBSXhWLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlpQixJQUFJWixTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJNkMsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDOFYsTUFBTSxJQUFJO1lBQUUsT0FBTztRQUFNO1FBQ2xDLE9BQU9sVixLQUFLLElBQUksQ0FBQ3lVLEtBQUssSUFBSXpVLEtBQUssSUFBSSxDQUFDMFUsS0FBSyxJQUFJelMsS0FBSyxJQUFJLENBQUMwUyxLQUFLLElBQUkxUyxLQUFLLElBQUksQ0FBQzJTLEtBQUs7SUFDakY7QUFDRjtBQUNBSixTQUFTbFcsU0FBUyxDQUFDaVgsVUFBVSxHQUFHLFNBQVNBO0lBQ3ZDLElBQUluVyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZb1YsVUFBVTtZQUNwQyxJQUFJMVIsUUFBUTFELFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUksSUFBSSxDQUFDOFYsTUFBTSxNQUFNcFMsTUFBTW9TLE1BQU0sSUFBSTtnQkFDbkMsT0FBTztZQUNUO1lBQ0EsT0FBTyxDQUFFcFMsQ0FBQUEsTUFBTTJSLEtBQUssR0FBRyxJQUFJLENBQUNDLEtBQUssSUFBSTVSLE1BQU00UixLQUFLLEdBQUcsSUFBSSxDQUFDRCxLQUFLLElBQUkzUixNQUFNNlIsS0FBSyxHQUFHLElBQUksQ0FBQ0MsS0FBSyxJQUFJOVIsTUFBTThSLEtBQUssR0FBRyxJQUFJLENBQUNELEtBQUs7UUFDdkgsT0FBTyxJQUFJdlYsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7WUFDN0MsSUFBSXNSLElBQUlsVSxTQUFTLENBQUMsRUFBRTtZQUNwQixPQUFPLElBQUksQ0FBQ21XLFVBQVUsQ0FBQ2pDLEVBQUV0VCxDQUFDLEVBQUVzVCxFQUFFclIsQ0FBQztRQUNqQztJQUNGLE9BQU8sSUFBSTdDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlpQixJQUFJWixTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJNkMsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDOFYsTUFBTSxJQUFJO1lBQUUsT0FBTztRQUFNO1FBQ2xDLE9BQU8sQ0FBRWxWLENBQUFBLElBQUksSUFBSSxDQUFDMFUsS0FBSyxJQUFJMVUsSUFBSSxJQUFJLENBQUN5VSxLQUFLLElBQUl4UyxJQUFJLElBQUksQ0FBQzJTLEtBQUssSUFBSTNTLElBQUksSUFBSSxDQUFDMFMsS0FBSztJQUMvRTtBQUNGO0FBQ0FILFNBQVNsVyxTQUFTLENBQUNnWCxPQUFPLEdBQUcsU0FBU0E7SUFDcEMsT0FBTyxJQUFJLENBQUNYLEtBQUs7QUFDbkI7QUFDQUgsU0FBU2xXLFNBQVMsQ0FBQytXLE9BQU8sR0FBRyxTQUFTQTtJQUNwQyxPQUFPLElBQUksQ0FBQ1osS0FBSztBQUNuQjtBQUNBRCxTQUFTbFcsU0FBUyxDQUFDdVgsZUFBZSxHQUFHLFNBQVNBO0lBQzVDLElBQUl6VyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtZQUN0QyxJQUFJc1IsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUksQ0FBQ3lXLGVBQWUsQ0FBQ3ZDLEVBQUV0VCxDQUFDLEVBQUVzVCxFQUFFclIsQ0FBQztRQUMvQixPQUFPLElBQUk3QyxTQUFTLENBQUMsRUFBRSxZQUFZb1YsVUFBVTtZQUMzQyxJQUFJMVIsUUFBUTFELFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUkwRCxNQUFNb1MsTUFBTSxJQUFJO2dCQUNsQixPQUFPO1lBQ1Q7WUFDQSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxJQUFJO2dCQUNqQixJQUFJLENBQUNULEtBQUssR0FBRzNSLE1BQU11UyxPQUFPO2dCQUMxQixJQUFJLENBQUNYLEtBQUssR0FBRzVSLE1BQU1xUyxPQUFPO2dCQUMxQixJQUFJLENBQUNSLEtBQUssR0FBRzdSLE1BQU13UyxPQUFPO2dCQUMxQixJQUFJLENBQUNWLEtBQUssR0FBRzlSLE1BQU1zUyxPQUFPO1lBQzVCLE9BQU87Z0JBQ0wsSUFBSXRTLE1BQU0yUixLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEVBQUU7b0JBQzVCLElBQUksQ0FBQ0EsS0FBSyxHQUFHM1IsTUFBTTJSLEtBQUs7Z0JBQzFCO2dCQUNBLElBQUkzUixNQUFNNFIsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxFQUFFO29CQUM1QixJQUFJLENBQUNBLEtBQUssR0FBRzVSLE1BQU00UixLQUFLO2dCQUMxQjtnQkFDQSxJQUFJNVIsTUFBTTZSLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssRUFBRTtvQkFDNUIsSUFBSSxDQUFDQSxLQUFLLEdBQUc3UixNQUFNNlIsS0FBSztnQkFDMUI7Z0JBQ0EsSUFBSTdSLE1BQU04UixLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEVBQUU7b0JBQzVCLElBQUksQ0FBQ0EsS0FBSyxHQUFHOVIsTUFBTThSLEtBQUs7Z0JBQzFCO1lBQ0Y7UUFDRjtJQUNGLE9BQU8sSUFBSXhWLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlpQixJQUFJWixTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJNkMsSUFBSTdDLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDOFYsTUFBTSxJQUFJO1lBQ2pCLElBQUksQ0FBQ1QsS0FBSyxHQUFHelU7WUFDYixJQUFJLENBQUMwVSxLQUFLLEdBQUcxVTtZQUNiLElBQUksQ0FBQzJVLEtBQUssR0FBRzFTO1lBQ2IsSUFBSSxDQUFDMlMsS0FBSyxHQUFHM1M7UUFDZixPQUFPO1lBQ0wsSUFBSWpDLElBQUksSUFBSSxDQUFDeVUsS0FBSyxFQUFFO2dCQUNsQixJQUFJLENBQUNBLEtBQUssR0FBR3pVO1lBQ2Y7WUFDQSxJQUFJQSxJQUFJLElBQUksQ0FBQzBVLEtBQUssRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUcxVTtZQUNmO1lBQ0EsSUFBSWlDLElBQUksSUFBSSxDQUFDMFMsS0FBSyxFQUFFO2dCQUNsQixJQUFJLENBQUNBLEtBQUssR0FBRzFTO1lBQ2Y7WUFDQSxJQUFJQSxJQUFJLElBQUksQ0FBQzJTLEtBQUssRUFBRTtnQkFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUczUztZQUNmO1FBQ0Y7SUFDRjtBQUNGO0FBQ0F1UyxTQUFTbFcsU0FBUyxDQUFDd1gsU0FBUyxHQUFHLFNBQVNBO0lBQ3RDLElBQUksSUFBSSxDQUFDWixNQUFNLElBQUk7UUFBRSxPQUFPO0lBQUk7SUFDaEMsSUFBSTdCLElBQUksSUFBSSxDQUFDMEIsUUFBUTtJQUNyQixJQUFJbEksSUFBSSxJQUFJLENBQUNtSSxTQUFTO0lBQ3RCLElBQUkzQixJQUFJeEcsR0FBRztRQUFFLE9BQU93RztJQUFFO0lBQ3RCLE9BQU94RztBQUNUO0FBQ0EySCxTQUFTbFcsU0FBUyxDQUFDeVcsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLElBQUksSUFBSSxDQUFDRyxNQUFNLElBQUk7UUFDakIsT0FBTztJQUNUO0lBQ0EsT0FBTyxJQUFJLENBQUNSLEtBQUssR0FBRyxJQUFJLENBQUNELEtBQUs7QUFDaEM7QUFDQUQsU0FBU2xXLFNBQVMsQ0FBQzZFLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxDQUFDO0lBQ2xELElBQUltUCxNQUFNblA7SUFDVixJQUFJLElBQUksQ0FBQzhSLE1BQU0sSUFBSTtRQUNqQixJQUFJM0MsSUFBSTJDLE1BQU0sSUFBSTtZQUFFLE9BQU87UUFBRTtRQUM3QixPQUFPLENBQUM7SUFDVixPQUFPO1FBQ0wsSUFBSTNDLElBQUkyQyxNQUFNLElBQUk7WUFBRSxPQUFPO1FBQUU7SUFDL0I7SUFDQSxJQUFJLElBQUksQ0FBQ1QsS0FBSyxHQUFHbEMsSUFBSWtDLEtBQUssRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ3hDLElBQUksSUFBSSxDQUFDQSxLQUFLLEdBQUdsQyxJQUFJa0MsS0FBSyxFQUFFO1FBQUUsT0FBTztJQUFFO0lBQ3ZDLElBQUksSUFBSSxDQUFDRSxLQUFLLEdBQUdwQyxJQUFJb0MsS0FBSyxFQUFFO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDeEMsSUFBSSxJQUFJLENBQUNBLEtBQUssR0FBR3BDLElBQUlvQyxLQUFLLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDdkMsSUFBSSxJQUFJLENBQUNELEtBQUssR0FBR25DLElBQUltQyxLQUFLLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUN4QyxJQUFJLElBQUksQ0FBQ0EsS0FBSyxHQUFHbkMsSUFBSW1DLEtBQUssRUFBRTtRQUFFLE9BQU87SUFBRTtJQUN2QyxJQUFJLElBQUksQ0FBQ0UsS0FBSyxHQUFHckMsSUFBSXFDLEtBQUssRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ3hDLElBQUksSUFBSSxDQUFDQSxLQUFLLEdBQUdyQyxJQUFJcUMsS0FBSyxFQUFFO1FBQUUsT0FBTztJQUFFO0lBQ3ZDLE9BQU87QUFDVDtBQUNBSixTQUFTbFcsU0FBUyxDQUFDeVgsU0FBUyxHQUFHLFNBQVNBLFVBQVdDLE1BQU0sRUFBRUMsTUFBTTtJQUMvRCxJQUFJLElBQUksQ0FBQ2YsTUFBTSxJQUFJO1FBQ2pCLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ3BOLElBQUksQ0FBQyxJQUFJLENBQUN1TixPQUFPLEtBQUtXLFFBQVEsSUFBSSxDQUFDYixPQUFPLEtBQUthLFFBQVEsSUFBSSxDQUFDVixPQUFPLEtBQUtXLFFBQVEsSUFBSSxDQUFDYixPQUFPLEtBQUthO0FBQ3hHO0FBQ0F6QixTQUFTbFcsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sU0FBUyxJQUFJLENBQUNrUixLQUFLLEdBQUcsUUFBUSxJQUFJLENBQUNDLEtBQUssR0FBRyxPQUFPLElBQUksQ0FBQ0MsS0FBSyxHQUFHLFFBQVEsSUFBSSxDQUFDQyxLQUFLLEdBQUc7QUFDN0Y7QUFDQUosU0FBU2xXLFNBQVMsQ0FBQzRYLFNBQVMsR0FBRyxTQUFTQTtJQUN0QyxJQUFJLENBQUN6QixLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEtBQUssR0FBRyxDQUFDO0lBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEtBQUssR0FBRyxDQUFDO0FBQ2hCO0FBQ0FKLFNBQVNsVyxTQUFTLENBQUMwVyxTQUFTLEdBQUcsU0FBU0E7SUFDdEMsSUFBSSxJQUFJLENBQUNFLE1BQU0sSUFBSTtRQUNqQixPQUFPO0lBQ1Q7SUFDQSxPQUFPLElBQUksQ0FBQ04sS0FBSyxHQUFHLElBQUksQ0FBQ0QsS0FBSztBQUNoQztBQUNBSCxTQUFTbFcsU0FBUyxDQUFDNlgsU0FBUyxHQUFHLFNBQVNBO0lBQ3RDLElBQUksSUFBSSxDQUFDakIsTUFBTSxJQUFJO1FBQUUsT0FBTztJQUFJO0lBQ2hDLElBQUk3QixJQUFJLElBQUksQ0FBQzBCLFFBQVE7SUFDckIsSUFBSWxJLElBQUksSUFBSSxDQUFDbUksU0FBUztJQUN0QixJQUFJM0IsSUFBSXhHLEdBQUc7UUFBRSxPQUFPd0c7SUFBRTtJQUN0QixPQUFPeEc7QUFDVDtBQUNBMkgsU0FBU2xXLFNBQVMsQ0FBQzhYLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxJQUFJaFgsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSThFLFdBQVd6RSxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJLENBQUNnWCxRQUFRLENBQUN2UyxVQUFVQTtJQUMxQixPQUFPLElBQUl6RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJc1gsU0FBU2pYLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlrWCxTQUFTbFgsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSSxJQUFJLENBQUM4VixNQUFNLElBQUk7WUFBRSxPQUFPO1FBQUs7UUFDakMsSUFBSSxDQUFDVCxLQUFLLElBQUk0QjtRQUNkLElBQUksQ0FBQzNCLEtBQUssSUFBSTJCO1FBQ2QsSUFBSSxDQUFDMUIsS0FBSyxJQUFJMkI7UUFDZCxJQUFJLENBQUMxQixLQUFLLElBQUkwQjtRQUNkLElBQUksSUFBSSxDQUFDN0IsS0FBSyxHQUFHLElBQUksQ0FBQ0MsS0FBSyxJQUFJLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0MsS0FBSyxFQUFFO1lBQUUsSUFBSSxDQUFDc0IsU0FBUztRQUFJO0lBQzlFO0FBQ0Y7QUFDQTFCLFNBQVNsVyxTQUFTLENBQUNpWSxRQUFRLEdBQUcsU0FBU0E7SUFDckMsSUFBSW5YLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVlvVixVQUFVO1lBQ3BDLElBQUkxUixRQUFRMUQsU0FBUyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxJQUFJLENBQUN3VyxNQUFNLENBQUM5UztRQUNyQixPQUFPLElBQUkxRCxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtZQUM3QyxJQUFJc1IsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLE9BQU8sSUFBSSxDQUFDd1csTUFBTSxDQUFDdEM7UUFDckI7SUFDRixPQUFPLElBQUlsVSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJaUIsSUFBSVosU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSTZDLElBQUk3QyxTQUFTLENBQUMsRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQ3dXLE1BQU0sQ0FBQzVWLEdBQUdpQztJQUN4QjtBQUNGO0FBQ0F1UyxTQUFTbFcsU0FBUyxDQUFDa1ksTUFBTSxHQUFHLFNBQVNBO0lBQ25DLElBQUksSUFBSSxDQUFDdEIsTUFBTSxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQ2pDLE9BQU8sSUFBSWxULFdBQVcsQ0FBQyxJQUFJLENBQUNxVCxPQUFPLEtBQUssSUFBSSxDQUFDRixPQUFPLEVBQUMsSUFBSyxLQUFLLENBQUMsSUFBSSxDQUFDRyxPQUFPLEtBQUssSUFBSSxDQUFDRixPQUFPLEVBQUMsSUFBSztBQUNyRztBQUNBWixTQUFTbFcsU0FBUyxDQUFDd0osSUFBSSxHQUFHLFNBQVNBO0lBQ2pDLElBQUkxSSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUNtWCxTQUFTO0lBQ2hCLE9BQU8sSUFBSTlXLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFZO1lBQ3RDLElBQUlzUixJQUFJbFUsU0FBUyxDQUFDLEVBQUU7WUFDcEIsSUFBSSxDQUFDMEksSUFBSSxDQUFDd0wsRUFBRXRULENBQUMsRUFBRXNULEVBQUV0VCxDQUFDLEVBQUVzVCxFQUFFclIsQ0FBQyxFQUFFcVIsRUFBRXJSLENBQUM7UUFDOUIsT0FBTyxJQUFJN0MsU0FBUyxDQUFDLEVBQUUsWUFBWW9WLFVBQVU7WUFDM0MsSUFBSWpDLE1BQU1uVCxTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJLENBQUNxVixLQUFLLEdBQUdsQyxJQUFJa0MsS0FBSztZQUN0QixJQUFJLENBQUNDLEtBQUssR0FBR25DLElBQUltQyxLQUFLO1lBQ3RCLElBQUksQ0FBQ0MsS0FBSyxHQUFHcEMsSUFBSW9DLEtBQUs7WUFDdEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdyQyxJQUFJcUMsS0FBSztRQUN4QjtJQUNGLE9BQU8sSUFBSXhWLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk4USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSTBRLEtBQUsxUSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUMwSSxJQUFJLENBQUMrSCxHQUFHN1AsQ0FBQyxFQUFFOFAsR0FBRzlQLENBQUMsRUFBRTZQLEdBQUc1TixDQUFDLEVBQUU2TixHQUFHN04sQ0FBQztJQUNsQyxPQUFPLElBQUk3QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJdUIsS0FBS2xCLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUltQixLQUFLbkIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSWtSLEtBQUtsUixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJbVIsS0FBS25SLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlrQixLQUFLQyxJQUFJO1lBQ1gsSUFBSSxDQUFDa1UsS0FBSyxHQUFHblU7WUFDYixJQUFJLENBQUNvVSxLQUFLLEdBQUduVTtRQUNmLE9BQU87WUFDTCxJQUFJLENBQUNrVSxLQUFLLEdBQUdsVTtZQUNiLElBQUksQ0FBQ21VLEtBQUssR0FBR3BVO1FBQ2Y7UUFDQSxJQUFJZ1EsS0FBS0MsSUFBSTtZQUNYLElBQUksQ0FBQ29FLEtBQUssR0FBR3JFO1lBQ2IsSUFBSSxDQUFDc0UsS0FBSyxHQUFHckU7UUFDZixPQUFPO1lBQ0wsSUFBSSxDQUFDb0UsS0FBSyxHQUFHcEU7WUFDYixJQUFJLENBQUNxRSxLQUFLLEdBQUd0RTtRQUNmO0lBQ0Y7QUFDRjtBQUNBa0UsU0FBU2xXLFNBQVMsQ0FBQzhXLE9BQU8sR0FBRyxTQUFTQTtJQUNwQyxPQUFPLElBQUksQ0FBQ1IsS0FBSztBQUNuQjtBQUNBSixTQUFTbFcsU0FBUyxDQUFDdUYsUUFBUSxHQUFHLFNBQVNBLFNBQVUwTyxHQUFHO0lBQ2xELElBQUksSUFBSSxDQUFDZ0QsVUFBVSxDQUFDaEQsTUFBTTtRQUFFLE9BQU87SUFBRTtJQUNyQyxJQUFJOU8sS0FBSztJQUNULElBQUksSUFBSSxDQUFDaVIsS0FBSyxHQUFHbkMsSUFBSWtDLEtBQUssRUFBRTtRQUFFaFIsS0FBSzhPLElBQUlrQyxLQUFLLEdBQUcsSUFBSSxDQUFDQyxLQUFLO0lBQUUsT0FBTyxJQUFJLElBQUksQ0FBQ0QsS0FBSyxHQUFHbEMsSUFBSW1DLEtBQUssRUFBRTtRQUFFalIsS0FBSyxJQUFJLENBQUNnUixLQUFLLEdBQUdsQyxJQUFJbUMsS0FBSztJQUFFO0lBQzdILElBQUloUixLQUFLO0lBQ1QsSUFBSSxJQUFJLENBQUNrUixLQUFLLEdBQUdyQyxJQUFJb0MsS0FBSyxFQUFFO1FBQUVqUixLQUFLNk8sSUFBSW9DLEtBQUssR0FBRyxJQUFJLENBQUNDLEtBQUs7SUFBRSxPQUFPLElBQUksSUFBSSxDQUFDRCxLQUFLLEdBQUdwQyxJQUFJcUMsS0FBSyxFQUFFO1FBQUVsUixLQUFLLElBQUksQ0FBQ2lSLEtBQUssR0FBR3BDLElBQUlxQyxLQUFLO0lBQUU7SUFDN0gsSUFBSW5SLE9BQU8sS0FBSztRQUFFLE9BQU9DO0lBQUc7SUFDNUIsSUFBSUEsT0FBTyxLQUFLO1FBQUUsT0FBT0Q7SUFBRztJQUM1QixPQUFPekUsS0FBSzRFLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0E7QUFDbEM7QUFDQThRLFNBQVNsVyxTQUFTLENBQUN3RixRQUFRLEdBQUcsU0FBU0E7SUFDckMsSUFBSUMsU0FBUztJQUNiQSxTQUFTLEtBQUtBLFNBQVMvQixXQUFXOEIsUUFBUSxDQUFDLElBQUksQ0FBQzJRLEtBQUs7SUFDckQxUSxTQUFTLEtBQUtBLFNBQVMvQixXQUFXOEIsUUFBUSxDQUFDLElBQUksQ0FBQzRRLEtBQUs7SUFDckQzUSxTQUFTLEtBQUtBLFNBQVMvQixXQUFXOEIsUUFBUSxDQUFDLElBQUksQ0FBQzZRLEtBQUs7SUFDckQ1USxTQUFTLEtBQUtBLFNBQVMvQixXQUFXOEIsUUFBUSxDQUFDLElBQUksQ0FBQzhRLEtBQUs7SUFDckQsT0FBTzdRO0FBQ1Q7QUFDQXlRLFNBQVNsVyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDeEMsT0FBTztRQUFDeUI7UUFBWUc7S0FBYTtBQUNuQztBQUNBeVMsU0FBU2xXLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPb1U7QUFDVDtBQUNBQSxTQUFTZSxVQUFVLEdBQUcsU0FBU0E7SUFDN0IsSUFBSW5XLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUk4USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSTBRLEtBQUsxUSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJMlEsSUFBSTNRLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUkyUSxFQUFFL1AsQ0FBQyxJQUFLNlAsQ0FBQUEsR0FBRzdQLENBQUMsR0FBRzhQLEdBQUc5UCxDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQyxHQUFHOFAsR0FBRzlQLENBQUMsS0FBSytQLEVBQUUvUCxDQUFDLElBQUs2UCxDQUFBQSxHQUFHN1AsQ0FBQyxHQUFHOFAsR0FBRzlQLENBQUMsR0FBRzZQLEdBQUc3UCxDQUFDLEdBQUc4UCxHQUFHOVAsQ0FBQyxLQUFNK1AsRUFBRTlOLENBQUMsSUFBSzROLENBQUFBLEdBQUc1TixDQUFDLEdBQUc2TixHQUFHN04sQ0FBQyxHQUFHNE4sR0FBRzVOLENBQUMsR0FBRzZOLEdBQUc3TixDQUFDLEtBQUs4TixFQUFFOU4sQ0FBQyxJQUFLNE4sQ0FBQUEsR0FBRzVOLENBQUMsR0FBRzZOLEdBQUc3TixDQUFDLEdBQUc0TixHQUFHNU4sQ0FBQyxHQUFHNk4sR0FBRzdOLENBQUMsR0FBSTtZQUMxSixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1QsT0FBTyxJQUFJN0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTBVLE9BQU9yVSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJc1UsT0FBT3RVLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlzUixLQUFLdFIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXVSLEtBQUt2UixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJcVgsT0FBT3pYLEtBQUtFLEdBQUcsQ0FBQ3dSLEdBQUcxUSxDQUFDLEVBQUUyUSxHQUFHM1EsQ0FBQztRQUM5QixJQUFJMFcsT0FBTzFYLEtBQUtDLEdBQUcsQ0FBQ3lSLEdBQUcxUSxDQUFDLEVBQUUyUSxHQUFHM1EsQ0FBQztRQUM5QixJQUFJMlcsT0FBTzNYLEtBQUtFLEdBQUcsQ0FBQ3VVLEtBQUt6VCxDQUFDLEVBQUUwVCxLQUFLMVQsQ0FBQztRQUNsQyxJQUFJNFcsT0FBTzVYLEtBQUtDLEdBQUcsQ0FBQ3dVLEtBQUt6VCxDQUFDLEVBQUUwVCxLQUFLMVQsQ0FBQztRQUNsQyxJQUFJMlcsT0FBT0QsTUFBTTtZQUFFLE9BQU87UUFBTTtRQUNoQyxJQUFJRSxPQUFPSCxNQUFNO1lBQUUsT0FBTztRQUFNO1FBQ2hDQSxPQUFPelgsS0FBS0UsR0FBRyxDQUFDd1IsR0FBR3pPLENBQUMsRUFBRTBPLEdBQUcxTyxDQUFDO1FBQzFCeVUsT0FBTzFYLEtBQUtDLEdBQUcsQ0FBQ3lSLEdBQUd6TyxDQUFDLEVBQUUwTyxHQUFHMU8sQ0FBQztRQUMxQjBVLE9BQU8zWCxLQUFLRSxHQUFHLENBQUN1VSxLQUFLeFIsQ0FBQyxFQUFFeVIsS0FBS3pSLENBQUM7UUFDOUIyVSxPQUFPNVgsS0FBS0MsR0FBRyxDQUFDd1UsS0FBS3hSLENBQUMsRUFBRXlSLEtBQUt6UixDQUFDO1FBQzlCLElBQUkwVSxPQUFPRCxNQUFNO1lBQUUsT0FBTztRQUFNO1FBQ2hDLElBQUlFLE9BQU9ILE1BQU07WUFBRSxPQUFPO1FBQU07UUFDaEMsT0FBTztJQUNUO0FBQ0Y7QUFDQTVCLGtCQUFrQnRTLGdCQUFnQixDQUFDYixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQW9CO0FBRWxGbkQsT0FBT29ELGdCQUFnQixDQUFFNlMsVUFBVUs7QUFFbkMsSUFBSWdDLFVBQVU7SUFDWixXQUFXO0lBQ1gsZ0JBQWdCO0lBQ2hCLFVBQVU7SUFDVixjQUFjO0lBQ2Qsb0JBQW9CO0lBQ3BCLGNBQWM7QUFDaEI7QUFFQTs7OztDQUlDLEdBRUQ7Ozs7OztDQU1DLEdBQ0QsSUFBSUMsWUFBWSxTQUFTQSxVQUFXQyxlQUFlO0lBQ2pELElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxtQkFBbUIsSUFBSUM7QUFDaEQ7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNERixVQUFVeFksU0FBUyxDQUFDMlksSUFBSSxHQUFHLFNBQVNBLEtBQU1DLEdBQUc7SUFDM0MsSUFBSUMsVUFBVUMsTUFBTW5RO0lBQ3BCaVEsTUFBTUEsSUFBSUcsT0FBTyxDQUFDLFdBQVc7SUFDN0IsSUFBSUMsVUFBVVQsUUFBUVUsT0FBTyxDQUFDQyxJQUFJLENBQUNOO0lBQ25DLElBQUlBLElBQUlPLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRztRQUM5QkgsVUFBVVQsUUFBUWEsWUFBWSxDQUFDRixJQUFJLENBQUNOO1FBQ3BDSSxPQUFPLENBQUMsRUFBRSxHQUFHMVk7SUFDZjtJQUNBLElBQUkwWSxTQUFTO1FBQ1hGLE9BQU9FLE9BQU8sQ0FBQyxFQUFFLENBQUNLLFdBQVc7UUFDN0IxUSxNQUFNcVEsT0FBTyxDQUFDLEVBQUU7UUFDaEIsSUFBSU0sT0FBTyxDQUFDUixLQUFLLEVBQUU7WUFDakJELFdBQVdTLE9BQU8sQ0FBQ1IsS0FBSyxDQUFDUyxLQUFLLENBQUMsSUFBSSxFQUFFO2dCQUFDNVE7YUFBSTtRQUM1QztJQUNGO0lBRUEsSUFBSWtRLGFBQWF2WSxXQUFXO1FBQUUsTUFBTSxJQUFJK0IsTUFBTSx5QkFBeUJ1VztJQUFLO0lBRTVFLE9BQU9DO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDREwsVUFBVXhZLFNBQVMsQ0FBQ3daLEtBQUssR0FBRyxTQUFTQSxNQUFPWCxRQUFRO0lBQ2xELE9BQU8sSUFBSSxDQUFDWSxlQUFlLENBQUNaO0FBQzlCO0FBRUE7Ozs7OztDQU1DLEdBQ0RMLFVBQVV4WSxTQUFTLENBQUN5WixlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCWixRQUFRO0lBQ3RFLElBQUlDLE9BQU9ELFNBQVNhLGVBQWUsR0FBR0wsV0FBVztJQUNqRCxJQUFJLENBQUNNLFNBQVMsQ0FBQ2IsS0FBSyxFQUFFO1FBQ3BCLE9BQU87SUFDVDtJQUNBLElBQUljLFVBQVVkLEtBQUsxUCxXQUFXO0lBQzlCLElBQUl5UTtJQUNKLElBQUloQixTQUFTaUIsT0FBTyxJQUFJO1FBQ3RCRCxPQUFPRCxVQUFVO0lBQ25CLE9BQU87UUFDTEMsT0FBT0QsVUFBVSxNQUFNRCxTQUFTLENBQUNiLEtBQUssQ0FBQ1MsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDVjtTQUFTLElBQUk7SUFDbkU7SUFDQSxPQUFPZ0I7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRCxJQUFJRixZQUFZO0lBQ2RJLFlBQVksU0FBU0EsV0FBWUMsWUFBWTtRQUMzQyxPQUFPQSxhQUFhdFksQ0FBQyxHQUFHLE1BQU1zWSxhQUFhclcsQ0FBQztJQUM5QztJQUVBOzs7Ozs7R0FNQyxHQUNEc1csT0FBTyxTQUFTQSxNQUFPQyxPQUFPO1FBQzVCLE9BQU9QLFVBQVVJLFVBQVUsQ0FBQ3hYLElBQUksQ0FBQyxJQUFJLEVBQUUyWCxRQUFRQyxZQUFZLENBQUNBLFlBQVksQ0FBQyxFQUFFO0lBQzdFO0lBRUE7Ozs7Ozs7R0FPQyxHQUNEQyxZQUFZLFNBQVNBLFdBQVlDLFlBQVk7UUFDM0MsSUFBSUMsU0FBUyxJQUFJO1FBRWpCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSW5ULElBQUksR0FBRzhKLE1BQU1tSixhQUFhRyxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUNuRW1ULE1BQU1FLElBQUksQ0FBQyxNQUFNZCxVQUFVTSxLQUFLLENBQUNWLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ0QsYUFBYUcsV0FBVyxDQUFDcFQsRUFBRTthQUFDLElBQUk7UUFDbEY7UUFDQSxPQUFPbVQsTUFBTUcsSUFBSSxDQUFDO0lBQ3BCO0lBRUE7Ozs7O0dBS0MsR0FDREMsWUFBWSxTQUFTQSxXQUFZQyxZQUFZO1FBQzNDLElBQUlOLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluVCxJQUFJLEdBQUc4SixNQUFNMEosYUFBYUMsT0FBTyxDQUFDVixZQUFZLENBQUMxWixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUM1RW1ULE1BQU1FLElBQUksQ0FBQ2QsVUFBVUksVUFBVSxDQUFDUixLQUFLLENBQUNlLFFBQVE7Z0JBQUNNLGFBQWFDLE9BQU8sQ0FBQ1YsWUFBWSxDQUFDL1MsRUFBRTthQUFDO1FBQ3RGO1FBQ0EsT0FBT21ULE1BQU1HLElBQUksQ0FBQztJQUNwQjtJQUVBSSxZQUFZLFNBQVNBLFdBQVlDLFlBQVk7UUFDM0MsSUFBSVQsU0FBUyxJQUFJO1FBRWpCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSW5ULElBQUksR0FBRzhKLE1BQU02SixhQUFhRixPQUFPLENBQUNWLFlBQVksQ0FBQzFaLE1BQU0sRUFBRTJHLElBQUk4SixLQUFLLEVBQUU5SixFQUFHO1lBQzVFbVQsTUFBTUUsSUFBSSxDQUFDZCxVQUFVSSxVQUFVLENBQUNSLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ1MsYUFBYUYsT0FBTyxDQUFDVixZQUFZLENBQUMvUyxFQUFFO2FBQUM7UUFDdEY7UUFDQSxPQUFPbVQsTUFBTUcsSUFBSSxDQUFDO0lBQ3BCO0lBRUE7Ozs7OztHQU1DLEdBQ0RNLGlCQUFpQixTQUFTQSxnQkFBaUJDLGlCQUFpQjtRQUMxRCxJQUFJWCxTQUFTLElBQUk7UUFFakIsSUFBSUMsUUFBUSxFQUFFO1FBQ2QsSUFBSyxJQUFJblQsSUFBSSxHQUFHOEosTUFBTStKLGtCQUFrQlQsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSThKLEtBQUssRUFBRTlKLEVBQUc7WUFDeEVtVCxNQUFNRSxJQUFJLENBQUMsTUFDVGQsVUFBVWdCLFVBQVUsQ0FBQ3BCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ1csa0JBQWtCVCxXQUFXLENBQUNwVCxFQUFFO2FBQUMsSUFDckU7UUFDSjtRQUNBLE9BQU9tVCxNQUFNRyxJQUFJLENBQUM7SUFDcEI7SUFFQTs7Ozs7R0FLQyxHQUNEUSxTQUFTLFNBQVNBLFFBQVNDLFNBQVM7UUFDbEMsSUFBSWIsU0FBUyxJQUFJO1FBRWpCLElBQUlDLFFBQVEsRUFBRTtRQUNkQSxNQUFNRSxJQUFJLENBQUMsTUFBTWQsVUFBVWdCLFVBQVUsQ0FBQ3BCLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQzRCLFVBQVVDLE1BQU07U0FBQyxJQUFJO1FBQ3hFLElBQUssSUFBSWhVLElBQUksR0FBRzhKLE1BQU1pSyxVQUFVRSxNQUFNLENBQUM1YSxNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUMzRG1ULE1BQU1FLElBQUksQ0FBQyxNQUFNZCxVQUFVZ0IsVUFBVSxDQUFDcEIsS0FBSyxDQUFDZSxRQUFRO2dCQUFDYSxVQUFVRSxNQUFNLENBQUNqVSxFQUFFO2FBQUMsSUFBSTtRQUMvRTtRQUNBLE9BQU9tVCxNQUFNRyxJQUFJLENBQUM7SUFDcEI7SUFFQTs7Ozs7R0FLQyxHQUNEWSxjQUFjLFNBQVNBLGFBQWNDLGNBQWM7UUFDakQsSUFBSWpCLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluVCxJQUFJLEdBQUc4SixNQUFNcUssZUFBZWYsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSThKLEtBQUssRUFBRTlKLEVBQUc7WUFDckVtVCxNQUFNRSxJQUFJLENBQUMsTUFBTWQsVUFBVXVCLE9BQU8sQ0FBQzNCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ2lCLGVBQWVmLFdBQVcsQ0FBQ3BULEVBQUU7YUFBQyxJQUFJO1FBQ3RGO1FBQ0EsT0FBT21ULE1BQU1HLElBQUksQ0FBQztJQUNwQjtJQUVBOzs7Ozs7R0FNQyxHQUNEYyxvQkFBb0IsU0FBU0EsbUJBQW9CQyxVQUFVO1FBQ3pELElBQUluQixTQUFTLElBQUk7UUFFakIsSUFBSUMsUUFBUSxFQUFFO1FBQ2QsSUFBSyxJQUFJblQsSUFBSSxHQUFHOEosTUFBTXVLLFdBQVdqQixXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUNqRW1ULE1BQU1FLElBQUksQ0FBQ0gsT0FBT2IsZUFBZSxDQUFDZ0MsV0FBV2pCLFdBQVcsQ0FBQ3BULEVBQUU7UUFDN0Q7UUFDQSxPQUFPbVQsTUFBTUcsSUFBSSxDQUFDO0lBQ3BCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsSUFBSXBCLFVBQVU7SUFDWjs7Ozs7O0dBTUMsR0FDRFcsT0FBTyxTQUFTQSxNQUFPdFIsR0FBRztRQUN4QixJQUFJQSxRQUFRckksV0FBVztZQUNyQixPQUFPLElBQUksQ0FBQ21ZLGVBQWUsQ0FBQ2lELFdBQVc7UUFDekM7UUFFQSxJQUFJQyxTQUFTaFQsSUFBSWlULElBQUksR0FBR0MsS0FBSyxDQUFDdEQsUUFBUXVELE1BQU07UUFDNUMsT0FBTyxJQUFJLENBQUNyRCxlQUFlLENBQUNpRCxXQUFXLENBQUMsSUFBSWhZLFdBQVcxQyxPQUFPTyxVQUFVLENBQUNvYSxNQUFNLENBQUMsRUFBRSxHQUNoRjNhLE9BQU9PLFVBQVUsQ0FBQ29hLE1BQU0sQ0FBQyxFQUFFO0lBQy9CO0lBRUE7Ozs7OztHQU1DLEdBQ0R2QixZQUFZLFNBQVNBLFdBQVl6UixHQUFHO1FBQ2xDLElBQUkyUixTQUFTLElBQUk7UUFFakIsSUFBSTNSLFFBQVFySSxXQUFXO1lBQ3JCLE9BQU8sSUFBSSxDQUFDbVksZUFBZSxDQUFDc0QsZ0JBQWdCO1FBQzlDO1FBRUEsSUFBSTlCO1FBQ0osSUFBSStCLFNBQVNyVCxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUM7UUFDOUIsSUFBSUksYUFBYSxFQUFFO1FBQ25CLElBQUssSUFBSTdVLElBQUksR0FBRzhKLE1BQU04SyxPQUFPdmIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUssRUFBRTlKLEVBQUc7WUFDakQ2UyxRQUFRK0IsTUFBTSxDQUFDNVUsRUFBRSxDQUFDMlIsT0FBTyxDQUFDUixRQUFRMkQsVUFBVSxFQUFFO1lBQzlDRCxXQUFXeEIsSUFBSSxDQUFDbkIsUUFBUVcsS0FBSyxDQUFDVixLQUFLLENBQUNlLFFBQVE7Z0JBQUNMO2FBQU07UUFDckQ7UUFDQSxPQUFPLElBQUksQ0FBQ3hCLGVBQWUsQ0FBQ3NELGdCQUFnQixDQUFDRTtJQUMvQztJQUVBOzs7Ozs7R0FNQyxHQUNEdEIsWUFBWSxTQUFTQSxXQUFZaFMsR0FBRztRQUNsQyxJQUFJQSxRQUFRckksV0FBVztZQUNyQixPQUFPLElBQUksQ0FBQ21ZLGVBQWUsQ0FBQzBELGdCQUFnQjtRQUM5QztRQUVBLElBQUlILFNBQVNyVCxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUM7UUFDOUIsSUFBSUksYUFBYSxFQUFFO1FBQ25CLElBQUlOO1FBQ0osSUFBSyxJQUFJdlUsSUFBSSxHQUFHOEosTUFBTThLLE9BQU92YixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUNqRHVVLFNBQVNLLE1BQU0sQ0FBQzVVLEVBQUUsQ0FBQ3dVLElBQUksR0FBR0MsS0FBSyxDQUFDdEQsUUFBUXVELE1BQU07WUFDOUNHLFdBQVd4QixJQUFJLENBQUMsSUFBSS9XLFdBQVcxQyxPQUFPTyxVQUFVLENBQUNvYSxNQUFNLENBQUMsRUFBRSxHQUFHM2EsT0FBT08sVUFBVSxDQUFDb2EsTUFBTSxDQUFDLEVBQUU7UUFDMUY7UUFDQSxPQUFPLElBQUksQ0FBQ2xELGVBQWUsQ0FBQzBELGdCQUFnQixDQUFDRjtJQUMvQztJQUVBOzs7Ozs7R0FNQyxHQUNEbkIsWUFBWSxTQUFTQSxXQUFZblMsR0FBRztRQUNsQyxJQUFJQSxRQUFRckksV0FBVztZQUNyQixPQUFPLElBQUksQ0FBQ21ZLGVBQWUsQ0FBQzJELGdCQUFnQjtRQUM5QztRQUVBLElBQUlKLFNBQVNyVCxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUM7UUFDOUIsSUFBSUksYUFBYSxFQUFFO1FBQ25CLElBQUlOO1FBQ0osSUFBSyxJQUFJdlUsSUFBSSxHQUFHOEosTUFBTThLLE9BQU92YixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUNqRHVVLFNBQVNLLE1BQU0sQ0FBQzVVLEVBQUUsQ0FBQ3dVLElBQUksR0FBR0MsS0FBSyxDQUFDdEQsUUFBUXVELE1BQU07WUFDOUNHLFdBQVd4QixJQUFJLENBQUMsSUFBSS9XLFdBQVcxQyxPQUFPTyxVQUFVLENBQUNvYSxNQUFNLENBQUMsRUFBRSxHQUFHM2EsT0FBT08sVUFBVSxDQUFDb2EsTUFBTSxDQUFDLEVBQUU7UUFDMUY7UUFDQSxPQUFPLElBQUksQ0FBQ2xELGVBQWUsQ0FBQzJELGdCQUFnQixDQUFDSDtJQUMvQztJQUVBOzs7Ozs7R0FNQyxHQUNEakIsaUJBQWlCLFNBQVNBLGdCQUFpQnJTLEdBQUc7UUFDNUMsSUFBSTJSLFNBQVMsSUFBSTtRQUVqQixJQUFJM1IsUUFBUXJJLFdBQVc7WUFDckIsT0FBTyxJQUFJLENBQUNtWSxlQUFlLENBQUM0RCxxQkFBcUI7UUFDbkQ7UUFFQSxJQUFJQztRQUNKLElBQUlDLFFBQVE1VCxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUN0RCxRQUFRaUUsVUFBVTtRQUMvQyxJQUFJUCxhQUFhLEVBQUU7UUFDbkIsSUFBSyxJQUFJN1UsSUFBSSxHQUFHOEosTUFBTXFMLE1BQU05YixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSyxFQUFFOUosRUFBRztZQUNoRGtWLE9BQU9DLEtBQUssQ0FBQ25WLEVBQUUsQ0FBQzJSLE9BQU8sQ0FBQ1IsUUFBUTJELFVBQVUsRUFBRTtZQUM1Q0QsV0FBV3hCLElBQUksQ0FBQ25CLFFBQVFxQixVQUFVLENBQUNwQixLQUFLLENBQUNlLFFBQVE7Z0JBQUNnQzthQUFLO1FBQ3pEO1FBQ0EsT0FBTyxJQUFJLENBQUM3RCxlQUFlLENBQUM0RCxxQkFBcUIsQ0FBQ0o7SUFDcEQ7SUFFQTs7Ozs7O0dBTUMsR0FDRGYsU0FBUyxTQUFTQSxRQUFTdlMsR0FBRztRQUM1QixJQUFJMlIsU0FBUyxJQUFJO1FBRWpCLElBQUkzUixRQUFRckksV0FBVztZQUNyQixPQUFPLElBQUksQ0FBQ21ZLGVBQWUsQ0FBQ2dFLGFBQWE7UUFDM0M7UUFFQSxJQUFJQyxNQUFNL0IsWUFBWUc7UUFDdEIsSUFBSTZCLFFBQVFoVSxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUN0RCxRQUFRaUUsVUFBVTtRQUMvQyxJQUFJSTtRQUNKLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSXpWLElBQUksR0FBRzhKLE1BQU15TCxNQUFNbGMsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUssRUFBRTlKLEVBQUc7WUFDaERzVixPQUFPQyxLQUFLLENBQUN2VixFQUFFLENBQUMyUixPQUFPLENBQUNSLFFBQVEyRCxVQUFVLEVBQUU7WUFDNUN2QixhQUFhckIsUUFBUXFCLFVBQVUsQ0FBQ3BCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ29DO2FBQUs7WUFDcEQ1QixhQUFhUixPQUFPN0IsZUFBZSxDQUFDMkQsZ0JBQWdCLENBQUN6QixXQUFXRSxPQUFPO1lBQ3ZFLElBQUl6VCxNQUFNLEdBQUc7Z0JBQ1h3VixRQUFROUI7WUFDVixPQUFPO2dCQUNMK0IsTUFBTXBDLElBQUksQ0FBQ0s7WUFDYjtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNyQyxlQUFlLENBQUNnRSxhQUFhLENBQUNHLE9BQU9DO0lBQ25EO0lBRUE7Ozs7OztHQU1DLEdBQ0R2QixjQUFjLFNBQVNBLGFBQWMzUyxHQUFHO1FBQ3RDLElBQUkyUixTQUFTLElBQUk7UUFFakIsSUFBSTNSLFFBQVFySSxXQUFXO1lBQ3JCLE9BQU8sSUFBSSxDQUFDbVksZUFBZSxDQUFDcUUsa0JBQWtCO1FBQ2hEO1FBRUEsSUFBSTVCO1FBQ0osSUFBSTZCLFdBQVdwVSxJQUFJaVQsSUFBSSxHQUFHQyxLQUFLLENBQUN0RCxRQUFReUUsZ0JBQWdCO1FBQ3hELElBQUlmLGFBQWEsRUFBRTtRQUNuQixJQUFLLElBQUk3VSxJQUFJLEdBQUc4SixNQUFNNkwsU0FBU3RjLE1BQU0sRUFBRTJHLElBQUk4SixLQUFLLEVBQUU5SixFQUFHO1lBQ25EOFQsVUFBVTZCLFFBQVEsQ0FBQzNWLEVBQUUsQ0FBQzJSLE9BQU8sQ0FBQ1IsUUFBUTJELFVBQVUsRUFBRTtZQUNsREQsV0FBV3hCLElBQUksQ0FBQ25CLFFBQVE0QixPQUFPLENBQUMzQixLQUFLLENBQUNlLFFBQVE7Z0JBQUNZO2FBQVE7UUFDekQ7UUFDQSxPQUFPLElBQUksQ0FBQ3pDLGVBQWUsQ0FBQ3FFLGtCQUFrQixDQUFDYjtJQUNqRDtJQUVBOzs7Ozs7R0FNQyxHQUNEVCxvQkFBb0IsU0FBU0EsbUJBQW9CN1MsR0FBRztRQUNsRCxJQUFJMlIsU0FBUyxJQUFJO1FBRWpCLElBQUkzUixRQUFRckksV0FBVztZQUNyQixPQUFPLElBQUksQ0FBQ21ZLGVBQWUsQ0FBQ3dFLHdCQUF3QjtRQUN0RDtRQUVBLCtDQUErQztRQUMvQ3RVLE1BQU1BLElBQUlvUSxPQUFPLENBQUMsbUJBQW1CO1FBQ3JDLElBQUltRSxXQUFXdlUsSUFBSWlULElBQUksR0FBR0MsS0FBSyxDQUFDO1FBQ2hDLElBQUlJLGFBQWEsRUFBRTtRQUNuQixJQUFLLElBQUk3VSxJQUFJLEdBQUc4SixNQUFNZ00sU0FBU3pjLE1BQU0sRUFBRTJHLElBQUk4SixLQUFLLEVBQUU5SixFQUFHO1lBQ25ENlUsV0FBV3hCLElBQUksQ0FBQ0gsT0FBTzNCLElBQUksQ0FBQ3VFLFFBQVEsQ0FBQzlWLEVBQUU7UUFDekM7UUFDQSxPQUFPLElBQUksQ0FBQ3FSLGVBQWUsQ0FBQ3dFLHdCQUF3QixDQUFDaEI7SUFDdkQ7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVEOzs7Q0FHQyxHQUNELElBQUlrQixZQUFZLFNBQVNBLFVBQVcxRSxlQUFlO0lBQ2pELElBQUksQ0FBQzJFLE1BQU0sR0FBRyxJQUFJNUUsVUFBVUM7QUFDOUI7QUFFQTs7Ozs7OztDQU9DLEdBQ0QwRSxVQUFVbmQsU0FBUyxDQUFDd1osS0FBSyxHQUFHLFNBQVNBLE1BQU9YLFFBQVE7SUFDbEQsT0FBTyxJQUFJLENBQUN1RSxNQUFNLENBQUM1RCxLQUFLLENBQUNYO0FBQzNCO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0RzRSxVQUFVRSxZQUFZLEdBQUcsU0FBU0EsYUFBY0MsRUFBRSxFQUFFL0wsRUFBRTtJQUNwRCxJQUFJelEsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsTUFBTSxJQUFJNEIsTUFBTTtJQUNsQjtJQUNBLE9BQU8sa0JBQWtCaWIsR0FBRzViLENBQUMsR0FBRyxNQUFNNGIsR0FBRzNaLENBQUMsR0FBRyxPQUFPNE4sR0FBRzdQLENBQUMsR0FBRyxNQUFNNlAsR0FBRzVOLENBQUMsR0FBRztBQUMxRTtBQUVBLElBQUk0WixtQkFBb0IsU0FBVWxiLE1BQUs7SUFDckMsU0FBU2tiLGlCQUFrQmpiLE9BQU87UUFDaENELE9BQU1FLElBQUksQ0FBQyxJQUFJLEVBQUVEO1FBQ2pCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBS0osU0FBU0ksS0FBSztJQUNsQztJQUVBLElBQUtKLFFBQVFrYixpQkFBaUI3YSxTQUFTLEdBQUdMO0lBQzFDa2IsaUJBQWlCdmQsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFTixVQUFTQSxPQUFNckMsU0FBUztJQUNwRXVkLGlCQUFpQnZkLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzJhO0lBRXpDLE9BQU9BO0FBQ1QsRUFBRWxiO0FBRUYsSUFBSW1iLDJCQUE0QixTQUFVQyxtQkFBbUI7SUFDM0QsU0FBU0Q7UUFDUEMsb0JBQW9CbGIsSUFBSSxDQUFDLElBQUk7UUFDN0IsSUFBSXpCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCZ2Qsb0JBQW9CbGIsSUFBSSxDQUFDLElBQUk7UUFDL0IsT0FBTyxJQUFJekIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSTZCLFVBQVV4QixTQUFTLENBQUMsRUFBRTtZQUMxQjJjLG9CQUFvQmxiLElBQUksQ0FBQyxJQUFJLEVBQUVEO1FBQ2pDO0lBQ0Y7SUFFQSxJQUFLbWIscUJBQXNCRCx5QkFBeUI5YSxTQUFTLEdBQUcrYTtJQUNoRUQseUJBQXlCeGQsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFOGEsdUJBQXVCQSxvQkFBb0J6ZCxTQUFTO0lBQ3hHd2QseUJBQXlCeGQsU0FBUyxDQUFDNEMsV0FBVyxHQUFHNGE7SUFDakRBLHlCQUF5QnhkLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUN4RCxPQUFPLEVBQUU7SUFDWDtJQUNBMmIseUJBQXlCeGQsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ3JELE9BQU8wYjtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFRDtBQUVGLElBQUlHLFNBQVMsU0FBU0EsVUFBVztBQUVqQ0EsT0FBTzFkLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN0QyxPQUFPLEVBQUU7QUFDWDtBQUNBNmIsT0FBTzFkLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuQyxPQUFPNGI7QUFDVDtBQUNBQSxPQUFPQyxvQkFBb0IsR0FBRyxTQUFTQTtJQUNyQyxJQUFJN2MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUJpZCxPQUFPQyxvQkFBb0IsQ0FBQztJQUM5QixPQUFPLElBQUk3YyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNkIsVUFBVXhCLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLE1BQU0sSUFBSTBjLHlCQUF5Qiw0QkFBNkJsYixDQUFBQSxZQUFZLE9BQU8sT0FBT0EsVUFBVSxFQUFDO0lBQ3ZHO0FBQ0Y7QUFDQW9iLE9BQU9FLE1BQU0sR0FBRyxTQUFTQTtJQUN2QixJQUFJQztJQUNKLElBQUl2YjtJQUNKLElBQUl4QixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQm9kLFlBQVkvYyxTQUFTLENBQUMsRUFBRTtRQUN4QjRjLE9BQU9FLE1BQU0sQ0FBQ0MsV0FBVztJQUMzQixPQUFPLElBQUkvYyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQ29kLFlBQVkvYyxTQUFTLENBQUMsRUFBRTtRQUN4QndCLFVBQVV4QixTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJLENBQUMrYyxXQUFXO1lBQ2QsSUFBSXZiLFlBQVksTUFBTTtnQkFDcEIsTUFBTSxJQUFJa2I7WUFDWixPQUFPO2dCQUNMLE1BQU0sSUFBSUEseUJBQXlCbGI7WUFDckM7UUFDRjtJQUNGO0FBQ0Y7QUFDQW9iLE9BQU8vWSxNQUFNLEdBQUcsU0FBU0E7SUFDdkIsSUFBSW1aO0lBQ0osSUFBSUM7SUFDSixJQUFJemI7SUFDSixJQUFJeEIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUJxZCxnQkFBZ0JoZCxTQUFTLENBQUMsRUFBRTtRQUM1QmlkLGNBQWNqZCxTQUFTLENBQUMsRUFBRTtRQUMxQjRjLE9BQU8vWSxNQUFNLENBQUNtWixlQUFlQyxhQUFhO0lBQzVDLE9BQU8sSUFBSWpkLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDcWQsZ0JBQWdCaGQsU0FBUyxDQUFDLEVBQUU7UUFDNUJpZCxjQUFjamQsU0FBUyxDQUFDLEVBQUU7UUFDMUJ3QixVQUFVeEIsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxDQUFDaWQsWUFBWXBaLE1BQU0sQ0FBQ21aLGdCQUFnQjtZQUN0QyxNQUFNLElBQUlOLHlCQUF5QixjQUFjTSxnQkFBZ0Isc0JBQXNCQyxjQUFlemIsQ0FBQUEsWUFBWSxPQUFPLE9BQU9BLFVBQVUsRUFBQztRQUM3STtJQUNGO0FBQ0Y7QUFFQSxJQUFJMGIsa0JBQWtCLFNBQVNBO0lBQzdCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUduZSxNQUFNLEdBQUdNLElBQUksR0FBRzhkLEdBQUcsQ0FBQztRQUFjLE9BQU9wZSxNQUFNO0lBQUk7SUFDdEUsSUFBSSxDQUFDcWUsTUFBTSxHQUFHLElBQUlyZSxNQUFNLEdBQUdNLElBQUksQ0FBQztJQUNoQyxJQUFJLENBQUNnZSxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0wsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJMWE7SUFDckIsSUFBSSxDQUFDMGEsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJMWE7SUFDckIsSUFBSSxDQUFDNmEsR0FBRyxHQUFHLElBQUksQ0FBQ0gsTUFBTSxDQUFDLEVBQUU7SUFDekIsSUFBSSxDQUFDSSxHQUFHLEdBQUcsSUFBSSxDQUFDSixNQUFNLENBQUMsRUFBRTtJQUN6QixJQUFJLENBQUNILE9BQU8sR0FBRztBQUNqQjtBQUVBLElBQUlTLHFCQUFxQjtJQUFFQyxnQkFBZ0I7UUFBRXhlLGNBQWM7SUFBSztJQUFFeWUsY0FBYztRQUFFemUsY0FBYztJQUFLO0lBQUUwZSxXQUFXO1FBQUUxZSxjQUFjO0lBQUs7SUFBRTJlLGlCQUFpQjtRQUFFM2UsY0FBYztJQUFLO0lBQUU0ZSxvQkFBb0I7UUFBRTVlLGNBQWM7SUFBSztJQUFFNmUsd0JBQXdCO1FBQUU3ZSxjQUFjO0lBQUs7QUFBRTtBQUMzUTZkLGdCQUFnQmhlLFNBQVMsQ0FBQ2lmLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQkMsWUFBWSxFQUFFQyxRQUFRO0lBQ3BHLElBQUksQ0FBQ0MsbUJBQW1CO0lBQ3hCLE9BQU8sSUFBSSxDQUFDZixhQUFhLENBQUNhLGFBQWEsQ0FBQ0MsU0FBUztBQUNuRDtBQUNBbkIsZ0JBQWdCaGUsU0FBUyxDQUFDcWYsa0JBQWtCLEdBQUcsU0FBU0E7SUFDdEQsSUFBSUMsU0FBUyxJQUFJNVc7SUFDakIsSUFBSSxJQUFJLENBQUM2VyxVQUFVLElBQUk7UUFBRUQsT0FBTzFXLE1BQU0sQ0FBQztJQUFjO0lBQ3JELElBQUksSUFBSSxDQUFDMFYsU0FBUyxFQUFFO1FBQUVnQixPQUFPMVcsTUFBTSxDQUFDO0lBQVk7SUFDaEQsSUFBSSxJQUFJLENBQUM0VyxXQUFXLElBQUk7UUFBRUYsT0FBTzFXLE1BQU0sQ0FBQztJQUFlO0lBQ3ZELE9BQU8wVyxPQUFPcmEsUUFBUTtBQUN4QjtBQUNBK1ksZ0JBQWdCaGUsU0FBUyxDQUFDeWYsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCbE8sRUFBRSxFQUFFQyxFQUFFLEVBQUVrTyxFQUFFLEVBQUVDLEVBQUU7SUFDMUYsSUFBSSxDQUFDekIsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUczTTtJQUN6QixJQUFJLENBQUMyTSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRzFNO0lBQ3pCLElBQUksQ0FBQzBNLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHd0I7SUFDekIsSUFBSSxDQUFDeEIsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUd5QjtJQUN6QixJQUFJLENBQUMxQixPQUFPLEdBQUcsSUFBSSxDQUFDMkIsZ0JBQWdCLENBQUNyTyxJQUFJQyxJQUFJa08sSUFBSUM7QUFDbkQ7QUFDQTNCLGdCQUFnQmhlLFNBQVMsQ0FBQzZmLGtCQUFrQixHQUFHLFNBQVNBO0lBQ3RELE9BQU8sSUFBSSxDQUFDNUIsT0FBTztBQUNyQjtBQUNBRCxnQkFBZ0JoZSxTQUFTLENBQUNvZixtQkFBbUIsR0FBRyxTQUFTQTtJQUN2RCxJQUFJdGUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSxJQUFJLENBQUM0ZCxhQUFhLEtBQUssTUFBTTtZQUMvQixJQUFJLENBQUNBLGFBQWEsR0FBR3RlLE1BQU0sR0FBR00sSUFBSSxHQUFHOGQsR0FBRyxDQUFDO2dCQUFjLE9BQU9wZSxNQUFNO1lBQUk7WUFDeEUsSUFBSSxDQUFDcWYsbUJBQW1CLENBQUM7WUFDekIsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQztRQUMzQjtJQUNGLE9BQU8sSUFBSXRlLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUl5ZSxlQUFlcGUsU0FBUyxDQUFDLEVBQUU7UUFDL0IsSUFBSWdmLFFBQVEsSUFBSSxDQUFDQyxlQUFlLENBQUNiLGNBQWM7UUFDL0MsSUFBSWMsUUFBUSxJQUFJLENBQUNELGVBQWUsQ0FBQ2IsY0FBYztRQUMvQyxJQUFJWSxRQUFRRSxPQUFPO1lBQ2pCLElBQUksQ0FBQzNCLGFBQWEsQ0FBQ2EsYUFBYSxDQUFDLEVBQUUsR0FBRztZQUN0QyxJQUFJLENBQUNiLGFBQWEsQ0FBQ2EsYUFBYSxDQUFDLEVBQUUsR0FBRztRQUN4QyxPQUFPO1lBQ0wsSUFBSSxDQUFDYixhQUFhLENBQUNhLGFBQWEsQ0FBQyxFQUFFLEdBQUc7WUFDdEMsSUFBSSxDQUFDYixhQUFhLENBQUNhLGFBQWEsQ0FBQyxFQUFFLEdBQUc7UUFDeEM7SUFDRjtBQUNGO0FBQ0FsQixnQkFBZ0JoZSxTQUFTLENBQUNpZ0IsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU8sSUFBSSxDQUFDQyxlQUFlLE1BQU0sSUFBSSxDQUFDNUIsU0FBUztBQUNqRDtBQUNBTixnQkFBZ0JoZSxTQUFTLENBQUNtZ0IsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CQyxjQUFjO0lBQ3RGLElBQUksQ0FBQzNCLGVBQWUsR0FBRzJCO0FBQ3pCO0FBQ0FwQyxnQkFBZ0JoZSxTQUFTLENBQUNxZ0Isc0JBQXNCLEdBQUcsU0FBU0E7SUFDeEQsSUFBSS9GLFNBQVMsSUFBSTtJQUVuQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSxJQUFJLENBQUM0ZixzQkFBc0IsQ0FBQyxJQUFJO1lBQUUsT0FBTztRQUFLO1FBQ2xELElBQUksSUFBSSxDQUFDQSxzQkFBc0IsQ0FBQyxJQUFJO1lBQUUsT0FBTztRQUFLO1FBQ2xELE9BQU87SUFDVCxPQUFPLElBQUl2ZixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNmYsaUJBQWlCeGYsU0FBUyxDQUFDLEVBQUU7UUFDakMsSUFBSyxJQUFJc0csSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZXLE9BQU8sRUFBRTdXLElBQUs7WUFDckMsSUFBSSxDQUFFa1QsQ0FBQUEsT0FBTzhELE1BQU0sQ0FBQ2hYLEVBQUUsQ0FBQzdDLFFBQVEsQ0FBQytWLE9BQU80RCxXQUFXLENBQUNvQyxlQUFlLENBQUMsRUFBRSxLQUFLaEcsT0FBTzhELE1BQU0sQ0FBQ2hYLEVBQUUsQ0FBQzdDLFFBQVEsQ0FBQytWLE9BQU80RCxXQUFXLENBQUNvQyxlQUFlLENBQUMsRUFBRSxJQUFJO2dCQUMzSSxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGO0FBQ0F0QyxnQkFBZ0JoZSxTQUFTLENBQUN1Z0IsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQnBCLFFBQVE7SUFDNUUsT0FBTyxJQUFJLENBQUNmLE1BQU0sQ0FBQ2UsU0FBUztBQUM5QjtBQUNBbkIsZ0JBQWdCaGUsU0FBUyxDQUFDdWYsVUFBVSxHQUFHLFNBQVNBO0lBQzlDLE9BQU8sSUFBSSxDQUFDVyxlQUFlLE1BQU0sQ0FBQyxJQUFJLENBQUM1QixTQUFTO0FBQ2xEO0FBQ0FOLGdCQUFnQmhlLFNBQVMsQ0FBQ2tnQixlQUFlLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxJQUFJLENBQUNqQyxPQUFPLEtBQUtELGdCQUFnQmMsZUFBZTtBQUN6RDtBQUNBZCxnQkFBZ0JoZSxTQUFTLENBQUMrZixlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCYixZQUFZLEVBQUVDLFFBQVE7SUFDMUYsSUFBSXFCLE9BQU94QyxnQkFBZ0J5QyxtQkFBbUIsQ0FBQyxJQUFJLENBQUNyQyxNQUFNLENBQUNlLFNBQVMsRUFBRSxJQUFJLENBQUNqQixXQUFXLENBQUNnQixhQUFhLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ2hCLFdBQVcsQ0FBQ2dCLGFBQWEsQ0FBQyxFQUFFO0lBQzFJLE9BQU9zQjtBQUNUO0FBQ0F4QyxnQkFBZ0JoZSxTQUFTLENBQUN3ZixXQUFXLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxJQUFJLENBQUN2QixPQUFPLEtBQUtELGdCQUFnQmdCLHNCQUFzQjtBQUNoRTtBQUNBaEIsZ0JBQWdCaGUsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU9rWSxVQUFVRSxZQUFZLENBQUMsSUFBSSxDQUFDYSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLFFBQVFmLFVBQVVFLFlBQVksQ0FBQyxJQUFJLENBQUNhLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDbUIsa0JBQWtCO0FBQzFMO0FBQ0FyQixnQkFBZ0JoZSxTQUFTLENBQUMwZ0IsV0FBVyxHQUFHLFNBQVNBLFlBQWF4QixZQUFZLEVBQUV5QixPQUFPO0lBQ2pGLE9BQU8sSUFBSSxDQUFDekMsV0FBVyxDQUFDZ0IsYUFBYSxDQUFDeUIsUUFBUTtBQUNoRDtBQUNBM0MsZ0JBQWdCaGUsU0FBUyxDQUFDNGdCLGNBQWMsR0FBRyxTQUFTQSxlQUFnQkMsRUFBRTtJQUNsRSxJQUFJdkcsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2VyxPQUFPLEVBQUU3VyxJQUFLO1FBQ3JDLElBQUlrVCxPQUFPOEQsTUFBTSxDQUFDaFgsRUFBRSxDQUFDN0MsUUFBUSxDQUFDc2MsS0FBSztZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBN0MsZ0JBQWdCaGUsU0FBUyxDQUFDOGdCLDJCQUEyQixHQUFHLFNBQVNBLDRCQUE2QjVCLFlBQVksRUFBRUMsUUFBUTtJQUNsSCxJQUFJLENBQUNDLG1CQUFtQjtJQUN4QixPQUFPLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2EsYUFBYSxDQUFDQyxTQUFTLENBQUM7QUFDaEU7QUFDQW5CLGdCQUFnQmhlLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMvQyxPQUFPLEVBQUU7QUFDWDtBQUNBbWMsZ0JBQWdCaGUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU9rYztBQUNUO0FBQ0FBLGdCQUFnQnlDLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQnpMLENBQUMsRUFBRXNJLEVBQUUsRUFBRS9MLEVBQUU7SUFDM0UsSUFBSXBNLEtBQUt6RSxLQUFLeUIsR0FBRyxDQUFDb1AsR0FBRzdQLENBQUMsR0FBRzRiLEdBQUc1YixDQUFDO0lBQzdCLElBQUkwRCxLQUFLMUUsS0FBS3lCLEdBQUcsQ0FBQ29QLEdBQUc1TixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQztJQUM3QixJQUFJNmMsT0FBTyxDQUFDO0lBQ1osSUFBSXhMLEVBQUVyUSxNQUFNLENBQUMyWSxLQUFLO1FBQ2hCa0QsT0FBTztJQUNULE9BQU8sSUFBSXhMLEVBQUVyUSxNQUFNLENBQUM0TSxLQUFLO1FBQ3ZCLElBQUlwTSxLQUFLQyxJQUFJO1lBQUVvYixPQUFPcmI7UUFBSSxPQUFPO1lBQUVxYixPQUFPcGI7UUFBSTtJQUNoRCxPQUFPO1FBQ0wsSUFBSTJiLE1BQU1yZ0IsS0FBS3lCLEdBQUcsQ0FBQzZTLEVBQUV0VCxDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQztRQUM3QixJQUFJc2YsTUFBTXRnQixLQUFLeUIsR0FBRyxDQUFDNlMsRUFBRXJSLENBQUMsR0FBRzJaLEdBQUczWixDQUFDO1FBQzdCLElBQUl3QixLQUFLQyxJQUFJO1lBQUVvYixPQUFPTztRQUFLLE9BQU87WUFBRVAsT0FBT1E7UUFBSztRQUNoRCxJQUFJUixTQUFTLE9BQU8sQ0FBQ3hMLEVBQUVyUSxNQUFNLENBQUMyWSxLQUFLO1lBQ2pDa0QsT0FBTzlmLEtBQUtDLEdBQUcsQ0FBQ29nQixLQUFLQztRQUN2QjtJQUNGO0lBQ0F0RCxPQUFPRSxNQUFNLENBQUMsQ0FBRTRDLENBQUFBLFNBQVMsT0FBTyxDQUFDeEwsRUFBRXJRLE1BQU0sQ0FBQzJZLEdBQUUsR0FBSTtJQUNoRCxPQUFPa0Q7QUFDVDtBQUNBeEMsZ0JBQWdCaUQsNEJBQTRCLEdBQUcsU0FBU0EsNkJBQThCak0sQ0FBQyxFQUFFekQsRUFBRSxFQUFFQyxFQUFFO0lBQzdGLElBQUlyTSxLQUFLNlAsRUFBRXRULENBQUMsR0FBRzZQLEdBQUc3UCxDQUFDO0lBQ25CLElBQUkwRCxLQUFLNFAsRUFBRXJSLENBQUMsR0FBRzROLEdBQUc1TixDQUFDO0lBQ25CLElBQUk2YyxPQUFPOWYsS0FBSzRFLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0E7SUFDcENzWSxPQUFPRSxNQUFNLENBQUMsQ0FBRTRDLENBQUFBLFNBQVMsT0FBTyxDQUFDeEwsRUFBRXJRLE1BQU0sQ0FBQzRNLEdBQUUsR0FBSTtJQUNoRCxPQUFPaVA7QUFDVDtBQUNBOUIsbUJBQW1CQyxjQUFjLENBQUN2YixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDL0RzYixtQkFBbUJFLFlBQVksQ0FBQ3hiLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUM3RHNiLG1CQUFtQkcsU0FBUyxDQUFDemIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQzFEc2IsbUJBQW1CSSxlQUFlLENBQUMxYixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDaEVzYixtQkFBbUJLLGtCQUFrQixDQUFDM2IsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ25Fc2IsbUJBQW1CTSxzQkFBc0IsQ0FBQzViLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUV2RW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRTJhLGlCQUFpQlU7QUFFMUMsSUFBSXdDLHdCQUF5QixTQUFVQyxrQkFBa0I7SUFDdkQsU0FBU0Q7UUFDUEMsbUJBQW1CNUgsS0FBSyxDQUFDLElBQUksRUFBRXpZO0lBQ2pDO0lBRUEsSUFBS3FnQixvQkFBcUJELHNCQUFzQnhlLFNBQVMsR0FBR3llO0lBQzVERCxzQkFBc0JsaEIsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFd2Usc0JBQXNCQSxtQkFBbUJuaEIsU0FBUztJQUNuR2toQixzQkFBc0JsaEIsU0FBUyxDQUFDNEMsV0FBVyxHQUFHc2U7SUFFOUNBLHNCQUFzQmxoQixTQUFTLENBQUNvaEIsb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCQyxLQUFLO1FBQ3pGLElBQUlDLE9BQU8sSUFBSXBMLFNBQVMsSUFBSSxDQUFDZ0ksV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDdEUsSUFBSXFELE9BQU8sSUFBSXJMLFNBQVMsSUFBSSxDQUFDZ0ksV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDdEUsT0FBT29ELEtBQUtySixRQUFRLENBQUNvSixVQUFVRSxLQUFLdEosUUFBUSxDQUFDb0o7SUFDL0M7SUFDQUgsc0JBQXNCbGhCLFNBQVMsQ0FBQ3lmLG1CQUFtQixHQUFHLFNBQVNBO1FBQzdELElBQUkzZSxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJdVUsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUl5USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7WUFDckIsSUFBSTBRLEtBQUsxUSxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJLENBQUN3ZCxTQUFTLEdBQUc7WUFDakIsSUFBSXBJLFNBQVNlLFVBQVUsQ0FBQzFGLElBQUlDLElBQUl3RCxJQUFJO2dCQUNsQyxJQUFJd00sYUFBYWxRLGdCQUFnQixDQUFDQyxJQUFJQyxJQUFJd0QsT0FBTyxLQUFLd00sYUFBYWxRLGdCQUFnQixDQUFDRSxJQUFJRCxJQUFJeUQsT0FBTyxHQUFHO29CQUNwRyxJQUFJLENBQUNzSixTQUFTLEdBQUc7b0JBQ2pCLElBQUl0SixFQUFFclEsTUFBTSxDQUFDNE0sT0FBT3lELEVBQUVyUSxNQUFNLENBQUM2TSxLQUFLO3dCQUNoQyxJQUFJLENBQUM4TSxTQUFTLEdBQUc7b0JBQ25CO29CQUNBLElBQUksQ0FBQ0wsT0FBTyxHQUFHa0QsbUJBQW1CcEMsa0JBQWtCO29CQUNwRCxPQUFPO2dCQUNUO1lBQ0Y7WUFDQSxJQUFJLENBQUNkLE9BQU8sR0FBR2tELG1CQUFtQnJDLGVBQWU7UUFDbkQsT0FBTztZQUFFLE9BQU9xQyxtQkFBbUJuaEIsU0FBUyxDQUFDeWYsbUJBQW1CLENBQUNsRyxLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUMxRjtJQUNBb2dCLHNCQUFzQmxoQixTQUFTLENBQUN5aEIsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07UUFDdEdBLE9BQU9wZ0IsQ0FBQyxHQUFHLElBQUksQ0FBQ3FnQixrQkFBa0IsQ0FBQ0wsR0FBR2hnQixDQUFDLEVBQUVpZ0IsR0FBR2pnQixDQUFDLEVBQUVrZ0IsR0FBR2xnQixDQUFDLEVBQUVtZ0IsR0FBR25nQixDQUFDO1FBQ3pEb2dCLE9BQU9uZSxDQUFDLEdBQUcsSUFBSSxDQUFDb2Usa0JBQWtCLENBQUNMLEdBQUcvZCxDQUFDLEVBQUVnZSxHQUFHaGUsQ0FBQyxFQUFFaWUsR0FBR2plLENBQUMsRUFBRWtlLEdBQUdsZSxDQUFDO1FBQ3pEK2QsR0FBR2hnQixDQUFDLElBQUlvZ0IsT0FBT3BnQixDQUFDO1FBQ2hCZ2dCLEdBQUcvZCxDQUFDLElBQUltZSxPQUFPbmUsQ0FBQztRQUNoQmdlLEdBQUdqZ0IsQ0FBQyxJQUFJb2dCLE9BQU9wZ0IsQ0FBQztRQUNoQmlnQixHQUFHaGUsQ0FBQyxJQUFJbWUsT0FBT25lLENBQUM7UUFDaEJpZSxHQUFHbGdCLENBQUMsSUFBSW9nQixPQUFPcGdCLENBQUM7UUFDaEJrZ0IsR0FBR2plLENBQUMsSUFBSW1lLE9BQU9uZSxDQUFDO1FBQ2hCa2UsR0FBR25nQixDQUFDLElBQUlvZ0IsT0FBT3BnQixDQUFDO1FBQ2hCbWdCLEdBQUdsZSxDQUFDLElBQUltZSxPQUFPbmUsQ0FBQztJQUNsQjtJQUNBdWQsc0JBQXNCbGhCLFNBQVMsQ0FBQ2dpQiwyQkFBMkIsR0FBRyxTQUFTQSw0QkFBNkJ6USxFQUFFLEVBQUVDLEVBQUUsRUFBRVksRUFBRSxFQUFFQyxFQUFFO1FBQ2hILElBQUlnUCxRQUFRO1FBQ1osSUFBSTtZQUNGQSxRQUFRdk0sWUFBWTNDLFlBQVksQ0FBQ1osSUFBSUMsSUFBSVksSUFBSUM7UUFDL0MsRUFBRSxPQUFPeEosR0FBRztZQUNWLElBQUlBLGFBQWF3TCwyQkFBMkI7Z0JBQzFDZ04sUUFBUUgsc0JBQXNCZSxlQUFlLENBQUMxUSxJQUFJQyxJQUFJWSxJQUFJQztZQUM1RCxPQUFPO2dCQUFFLE1BQU14SjtZQUFFO1FBQ25CLFNBQVUsQ0FBQztRQUNYLE9BQU93WTtJQUNUO0lBQ0FILHNCQUFzQmxoQixTQUFTLENBQUNtUyxZQUFZLEdBQUcsU0FBU0EsYUFBY1osRUFBRSxFQUFFQyxFQUFFLEVBQUVZLEVBQUUsRUFBRUMsRUFBRTtRQUNsRixJQUFJZ1AsUUFBUSxJQUFJLENBQUNhLDZCQUE2QixDQUFDM1EsSUFBSUMsSUFBSVksSUFBSUM7UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQytPLG9CQUFvQixDQUFDQyxRQUFRO1lBQ3JDQSxRQUFRLElBQUkzZCxXQUFXd2Qsc0JBQXNCZSxlQUFlLENBQUMxUSxJQUFJQyxJQUFJWSxJQUFJQztRQUMzRTtRQUNBLElBQUksSUFBSSxDQUFDb00sZUFBZSxLQUFLLE1BQU07WUFDakMsSUFBSSxDQUFDQSxlQUFlLENBQUMwRCxXQUFXLENBQUNkO1FBQ25DO1FBQ0EsT0FBT0E7SUFDVDtJQUNBSCxzQkFBc0JsaEIsU0FBUyxDQUFDK2hCLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQi9mLEVBQUUsRUFBRUMsRUFBRSxFQUFFbWdCLEVBQUUsRUFBRUMsRUFBRTtRQUM5RixJQUFJM2dCLElBQUlNO1FBQ1IsSUFBSXNnQixPQUFPNWhCLEtBQUt5QixHQUFHLENBQUNUO1FBQ3BCLElBQUloQixLQUFLeUIsR0FBRyxDQUFDRixNQUFNcWdCLE1BQU07WUFDdkI1Z0IsSUFBSU87WUFDSnFnQixPQUFPNWhCLEtBQUt5QixHQUFHLENBQUNGO1FBQ2xCO1FBQ0EsSUFBSXZCLEtBQUt5QixHQUFHLENBQUNpZ0IsTUFBTUUsTUFBTTtZQUN2QjVnQixJQUFJMGdCO1lBQ0pFLE9BQU81aEIsS0FBS3lCLEdBQUcsQ0FBQ2lnQjtRQUNsQjtRQUNBLElBQUkxaEIsS0FBS3lCLEdBQUcsQ0FBQ2tnQixNQUFNQyxNQUFNO1lBQ3ZCNWdCLElBQUkyZ0I7UUFDTjtRQUNBLE9BQU8zZ0I7SUFDVDtJQUNBd2Ysc0JBQXNCbGhCLFNBQVMsQ0FBQ3VpQixPQUFPLEdBQUcsU0FBU0EsUUFBU2hSLEVBQUUsRUFBRUMsRUFBRSxFQUFFWSxFQUFFLEVBQUVDLEVBQUUsRUFBRWdQLEtBQUs7UUFDL0UsSUFBSW1CLFVBQVVyUixlQUFlZ0IsWUFBWSxDQUFDWixJQUFJQyxJQUFJWSxJQUFJQztRQUN0RCxJQUFJb1EsT0FBTyxJQUFJLENBQUNyQixvQkFBb0IsQ0FBQ29CO1FBQ3JDak8sT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLGlCQUFpQkYsT0FBTyw2QkFBNkJEO1FBQ3hFLElBQUluQixNQUFNOWIsUUFBUSxDQUFDaWQsV0FBVyxRQUFRO1lBQ3BDak8sT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQnRCLE1BQU05YixRQUFRLENBQUNpZDtRQUNwRDtJQUNGO0lBQ0F0QixzQkFBc0JsaEIsU0FBUyxDQUFDa2lCLDZCQUE2QixHQUFHLFNBQVNBLDhCQUErQjNRLEVBQUUsRUFBRUMsRUFBRSxFQUFFWSxFQUFFLEVBQUVDLEVBQUU7UUFDcEgsSUFBSXFQLEtBQUssSUFBSWhlLFdBQVc2TjtRQUN4QixJQUFJb1EsS0FBSyxJQUFJamUsV0FBVzhOO1FBQ3hCLElBQUlvUSxLQUFLLElBQUlsZSxXQUFXME87UUFDeEIsSUFBSXlQLEtBQUssSUFBSW5lLFdBQVcyTztRQUN4QixJQUFJeVAsU0FBUyxJQUFJcGU7UUFDakIsSUFBSSxDQUFDa2Ysb0JBQW9CLENBQUNsQixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUMxQyxJQUFJVCxRQUFRLElBQUksQ0FBQ1csMkJBQTJCLENBQUNOLElBQUlDLElBQUlDLElBQUlDO1FBQ3pEUixNQUFNM2YsQ0FBQyxJQUFJb2dCLE9BQU9wZ0IsQ0FBQztRQUNuQjJmLE1BQU0xZCxDQUFDLElBQUltZSxPQUFPbmUsQ0FBQztRQUNuQixPQUFPMGQ7SUFDVDtJQUNBSCxzQkFBc0JsaEIsU0FBUyxDQUFDNmlCLDRCQUE0QixHQUFHLFNBQVNBLDZCQUE4QnRSLEVBQUUsRUFBRUMsRUFBRSxFQUFFWSxFQUFFLEVBQUVDLEVBQUU7UUFDbEgsSUFBSXlRLFNBQVM1TSxTQUFTZSxVQUFVLENBQUMxRixJQUFJQyxJQUFJWTtRQUN6QyxJQUFJMlEsU0FBUzdNLFNBQVNlLFVBQVUsQ0FBQzFGLElBQUlDLElBQUlhO1FBQ3pDLElBQUkyUSxTQUFTOU0sU0FBU2UsVUFBVSxDQUFDN0UsSUFBSUMsSUFBSWQ7UUFDekMsSUFBSTBSLFNBQVMvTSxTQUFTZSxVQUFVLENBQUM3RSxJQUFJQyxJQUFJYjtRQUN6QyxJQUFJc1IsVUFBVUMsUUFBUTtZQUNwQixJQUFJLENBQUMzRSxNQUFNLENBQUMsRUFBRSxHQUFHaE07WUFDakIsSUFBSSxDQUFDZ00sTUFBTSxDQUFDLEVBQUUsR0FBRy9MO1lBQ2pCLE9BQU84TyxtQkFBbUJuQyxzQkFBc0I7UUFDbEQ7UUFDQSxJQUFJZ0UsVUFBVUMsUUFBUTtZQUNwQixJQUFJLENBQUM3RSxNQUFNLENBQUMsRUFBRSxHQUFHN007WUFDakIsSUFBSSxDQUFDNk0sTUFBTSxDQUFDLEVBQUUsR0FBRzVNO1lBQ2pCLE9BQU8yUCxtQkFBbUJuQyxzQkFBc0I7UUFDbEQ7UUFDQSxJQUFJOEQsVUFBVUUsUUFBUTtZQUNwQixJQUFJLENBQUM1RSxNQUFNLENBQUMsRUFBRSxHQUFHaE07WUFDakIsSUFBSSxDQUFDZ00sTUFBTSxDQUFDLEVBQUUsR0FBRzdNO1lBQ2pCLE9BQU9hLEdBQUd6TixNQUFNLENBQUM0TSxPQUFPLENBQUN3UixVQUFVLENBQUNFLFNBQVM5QixtQkFBbUJwQyxrQkFBa0IsR0FBR29DLG1CQUFtQm5DLHNCQUFzQjtRQUNoSTtRQUNBLElBQUk4RCxVQUFVRyxRQUFRO1lBQ3BCLElBQUksQ0FBQzdFLE1BQU0sQ0FBQyxFQUFFLEdBQUdoTTtZQUNqQixJQUFJLENBQUNnTSxNQUFNLENBQUMsRUFBRSxHQUFHNU07WUFDakIsT0FBT1ksR0FBR3pOLE1BQU0sQ0FBQzZNLE9BQU8sQ0FBQ3VSLFVBQVUsQ0FBQ0MsU0FBUzdCLG1CQUFtQnBDLGtCQUFrQixHQUFHb0MsbUJBQW1CbkMsc0JBQXNCO1FBQ2hJO1FBQ0EsSUFBSStELFVBQVVDLFFBQVE7WUFDcEIsSUFBSSxDQUFDNUUsTUFBTSxDQUFDLEVBQUUsR0FBRy9MO1lBQ2pCLElBQUksQ0FBQytMLE1BQU0sQ0FBQyxFQUFFLEdBQUc3TTtZQUNqQixPQUFPYyxHQUFHMU4sTUFBTSxDQUFDNE0sT0FBTyxDQUFDdVIsVUFBVSxDQUFDRyxTQUFTOUIsbUJBQW1CcEMsa0JBQWtCLEdBQUdvQyxtQkFBbUJuQyxzQkFBc0I7UUFDaEk7UUFDQSxJQUFJK0QsVUFBVUUsUUFBUTtZQUNwQixJQUFJLENBQUM3RSxNQUFNLENBQUMsRUFBRSxHQUFHL0w7WUFDakIsSUFBSSxDQUFDK0wsTUFBTSxDQUFDLEVBQUUsR0FBRzVNO1lBQ2pCLE9BQU9hLEdBQUcxTixNQUFNLENBQUM2TSxPQUFPLENBQUNzUixVQUFVLENBQUNFLFNBQVM3QixtQkFBbUJwQyxrQkFBa0IsR0FBR29DLG1CQUFtQm5DLHNCQUFzQjtRQUNoSTtRQUNBLE9BQU9tQyxtQkFBbUJyQyxlQUFlO0lBQzNDO0lBQ0FvQyxzQkFBc0JsaEIsU0FBUyxDQUFDNGlCLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQk0sR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFdkIsTUFBTTtRQUM5RyxJQUFJd0IsUUFBUUosSUFBSXhoQixDQUFDLEdBQUd5aEIsSUFBSXpoQixDQUFDLEdBQUd3aEIsSUFBSXhoQixDQUFDLEdBQUd5aEIsSUFBSXpoQixDQUFDO1FBQ3pDLElBQUk2aEIsUUFBUUwsSUFBSXZmLENBQUMsR0FBR3dmLElBQUl4ZixDQUFDLEdBQUd1ZixJQUFJdmYsQ0FBQyxHQUFHd2YsSUFBSXhmLENBQUM7UUFDekMsSUFBSTZmLFFBQVFOLElBQUl4aEIsQ0FBQyxHQUFHeWhCLElBQUl6aEIsQ0FBQyxHQUFHd2hCLElBQUl4aEIsQ0FBQyxHQUFHeWhCLElBQUl6aEIsQ0FBQztRQUN6QyxJQUFJK2hCLFFBQVFQLElBQUl2ZixDQUFDLEdBQUd3ZixJQUFJeGYsQ0FBQyxHQUFHdWYsSUFBSXZmLENBQUMsR0FBR3dmLElBQUl4ZixDQUFDO1FBQ3pDLElBQUkrZixRQUFRTixJQUFJMWhCLENBQUMsR0FBRzJoQixJQUFJM2hCLENBQUMsR0FBRzBoQixJQUFJMWhCLENBQUMsR0FBRzJoQixJQUFJM2hCLENBQUM7UUFDekMsSUFBSWlpQixRQUFRUCxJQUFJemYsQ0FBQyxHQUFHMGYsSUFBSTFmLENBQUMsR0FBR3lmLElBQUl6ZixDQUFDLEdBQUcwZixJQUFJMWYsQ0FBQztRQUN6QyxJQUFJaWdCLFFBQVFSLElBQUkxaEIsQ0FBQyxHQUFHMmhCLElBQUkzaEIsQ0FBQyxHQUFHMGhCLElBQUkxaEIsQ0FBQyxHQUFHMmhCLElBQUkzaEIsQ0FBQztRQUN6QyxJQUFJbWlCLFFBQVFULElBQUl6ZixDQUFDLEdBQUcwZixJQUFJMWYsQ0FBQyxHQUFHeWYsSUFBSXpmLENBQUMsR0FBRzBmLElBQUkxZixDQUFDO1FBQ3pDLElBQUl1VCxVQUFVb00sUUFBUUksUUFBUUosUUFBUUk7UUFDdEMsSUFBSXRNLFVBQVVvTSxRQUFRSSxRQUFRSixRQUFRSTtRQUN0QyxJQUFJek0sVUFBVW9NLFFBQVFJLFFBQVFKLFFBQVFJO1FBQ3RDLElBQUl0TSxVQUFVb00sUUFBUUksUUFBUUosUUFBUUk7UUFDdEMsSUFBSUMsVUFBVSxDQUFDNU0sVUFBVUUsT0FBTSxJQUFLO1FBQ3BDLElBQUkyTSxVQUFVLENBQUM1TSxVQUFVRSxPQUFNLElBQUs7UUFDcEN5SyxPQUFPcGdCLENBQUMsR0FBR29pQjtRQUNYaEMsT0FBT25lLENBQUMsR0FBR29nQjtRQUNYYixJQUFJeGhCLENBQUMsSUFBSW9nQixPQUFPcGdCLENBQUM7UUFDakJ3aEIsSUFBSXZmLENBQUMsSUFBSW1lLE9BQU9uZSxDQUFDO1FBQ2pCd2YsSUFBSXpoQixDQUFDLElBQUlvZ0IsT0FBT3BnQixDQUFDO1FBQ2pCeWhCLElBQUl4ZixDQUFDLElBQUltZSxPQUFPbmUsQ0FBQztRQUNqQnlmLElBQUkxaEIsQ0FBQyxJQUFJb2dCLE9BQU9wZ0IsQ0FBQztRQUNqQjBoQixJQUFJemYsQ0FBQyxJQUFJbWUsT0FBT25lLENBQUM7UUFDakIwZixJQUFJM2hCLENBQUMsSUFBSW9nQixPQUFPcGdCLENBQUM7UUFDakIyaEIsSUFBSTFmLENBQUMsSUFBSW1lLE9BQU9uZSxDQUFDO0lBQ25CO0lBQ0F1ZCxzQkFBc0JsaEIsU0FBUyxDQUFDNGYsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCck8sRUFBRSxFQUFFQyxFQUFFLEVBQUVZLEVBQUUsRUFBRUMsRUFBRTtRQUMxRixJQUFJLENBQUNpTSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDcEksU0FBU2UsVUFBVSxDQUFDMUYsSUFBSUMsSUFBSVksSUFBSUMsS0FBSztZQUFFLE9BQU84TyxtQkFBbUJyQyxlQUFlO1FBQUM7UUFDdEYsSUFBSWtGLE1BQU14QyxhQUFhbFEsZ0JBQWdCLENBQUNDLElBQUlDLElBQUlZO1FBQ2hELElBQUk2UixNQUFNekMsYUFBYWxRLGdCQUFnQixDQUFDQyxJQUFJQyxJQUFJYTtRQUNoRCxJQUFJLE1BQU8sS0FBSzRSLE1BQU0sS0FBT0QsTUFBTSxLQUFLQyxNQUFNLEdBQUk7WUFDaEQsT0FBTzlDLG1CQUFtQnJDLGVBQWU7UUFDM0M7UUFDQSxJQUFJb0YsTUFBTTFDLGFBQWFsUSxnQkFBZ0IsQ0FBQ2MsSUFBSUMsSUFBSWQ7UUFDaEQsSUFBSTRTLE1BQU0zQyxhQUFhbFEsZ0JBQWdCLENBQUNjLElBQUlDLElBQUliO1FBQ2hELElBQUksTUFBTyxLQUFLMlMsTUFBTSxLQUFPRCxNQUFNLEtBQUtDLE1BQU0sR0FBSTtZQUNoRCxPQUFPaEQsbUJBQW1CckMsZUFBZTtRQUMzQztRQUNBLElBQUlzRixZQUFZSixRQUFRLEtBQUtDLFFBQVEsS0FBS0MsUUFBUSxLQUFLQyxRQUFRO1FBQy9ELElBQUlDLFdBQVc7WUFDYixPQUFPLElBQUksQ0FBQ3ZCLDRCQUE0QixDQUFDdFIsSUFBSUMsSUFBSVksSUFBSUM7UUFDdkQ7UUFDQSxJQUFJMlIsUUFBUSxLQUFLQyxRQUFRLEtBQUtDLFFBQVEsS0FBS0MsUUFBUSxHQUFHO1lBQ3BELElBQUksQ0FBQzdGLFNBQVMsR0FBRztZQUNqQixJQUFJL00sR0FBR2hOLFFBQVEsQ0FBQzZOLE9BQU9iLEdBQUdoTixRQUFRLENBQUM4TixLQUFLO2dCQUN0QyxJQUFJLENBQUMrTCxNQUFNLENBQUMsRUFBRSxHQUFHN007WUFDbkIsT0FBTyxJQUFJQyxHQUFHak4sUUFBUSxDQUFDNk4sT0FBT1osR0FBR2pOLFFBQVEsQ0FBQzhOLEtBQUs7Z0JBQzdDLElBQUksQ0FBQytMLE1BQU0sQ0FBQyxFQUFFLEdBQUc1TTtZQUNuQixPQUFPLElBQUl3UyxRQUFRLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQzVGLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSTFhLFdBQVcwTztZQUNsQyxPQUFPLElBQUk2UixRQUFRLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQzdGLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSTFhLFdBQVcyTztZQUNsQyxPQUFPLElBQUk2UixRQUFRLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQzlGLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSTFhLFdBQVc2TjtZQUNsQyxPQUFPLElBQUk0UyxRQUFRLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQy9GLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSTFhLFdBQVc4TjtZQUNsQztRQUNGLE9BQU87WUFDTCxJQUFJLENBQUM4TSxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRixNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ2pNLFlBQVksQ0FBQ1osSUFBSUMsSUFBSVksSUFBSUM7UUFDakQ7UUFDQSxPQUFPOE8sbUJBQW1CcEMsa0JBQWtCO0lBQzlDO0lBQ0FtQyxzQkFBc0JsaEIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ3JELE9BQU8sRUFBRTtJQUNYO0lBQ0FxZixzQkFBc0JsaEIsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ2xELE9BQU9vZjtJQUNUO0lBQ0FBLHNCQUFzQmUsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQjFRLEVBQUUsRUFBRUMsRUFBRSxFQUFFWSxFQUFFLEVBQUVDLEVBQUU7UUFDOUUsSUFBSWdTLFlBQVk5UztRQUNoQixJQUFJK1MsVUFBVTlDLGFBQWErQyxpQkFBaUIsQ0FBQ2hULElBQUlhLElBQUlDO1FBQ3JELElBQUltTyxPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDL1MsSUFBSVksSUFBSUM7UUFDbEQsSUFBSW1PLE9BQU84RCxTQUFTO1lBQ2xCQSxVQUFVOUQ7WUFDVjZELFlBQVk3UztRQUNkO1FBQ0FnUCxPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDblMsSUFBSWIsSUFBSUM7UUFDOUMsSUFBSWdQLE9BQU84RCxTQUFTO1lBQ2xCQSxVQUFVOUQ7WUFDVjZELFlBQVlqUztRQUNkO1FBQ0FvTyxPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDbFMsSUFBSWQsSUFBSUM7UUFDOUMsSUFBSWdQLE9BQU84RCxTQUFTO1lBQ2xCQSxVQUFVOUQ7WUFDVjZELFlBQVloUztRQUNkO1FBQ0EsT0FBT2dTO0lBQ1Q7SUFFQSxPQUFPbkQ7QUFDVCxFQUFFbEQ7QUFFRixJQUFJd0csb0JBQW9CLFNBQVNBLHFCQUFzQjtBQUV2REEsa0JBQWtCeGtCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNqRCxPQUFPLEVBQUU7QUFDWDtBQUNBMmlCLGtCQUFrQnhrQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDOUMsT0FBTzBpQjtBQUNUO0FBQ0FBLGtCQUFrQmxULGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQkMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLENBQUM7SUFDdkUsSUFBSUUsTUFBTUgsR0FBRzlQLENBQUMsR0FBRzZQLEdBQUc3UCxDQUFDO0lBQ3JCLElBQUlrUSxNQUFNSixHQUFHN04sQ0FBQyxHQUFHNE4sR0FBRzVOLENBQUM7SUFDckIsSUFBSWtPLE1BQU1KLEVBQUUvUCxDQUFDLEdBQUc4UCxHQUFHOVAsQ0FBQztJQUNwQixJQUFJb1EsTUFBTUwsRUFBRTlOLENBQUMsR0FBRzZOLEdBQUc3TixDQUFDO0lBQ3BCLE9BQU82Z0Isa0JBQWtCelMsWUFBWSxDQUFDSixLQUFLQyxLQUFLQyxLQUFLQztBQUN2RDtBQUNBMFMsa0JBQWtCelMsWUFBWSxHQUFHLFNBQVNBLGFBQWMvUCxFQUFFLEVBQUVnUSxFQUFFLEVBQUUvUCxFQUFFLEVBQUVnUSxFQUFFO0lBQ3BFLElBQUl3UyxPQUFPO0lBQ1gsSUFBSUMsT0FBTztJQUNYLElBQUlDLElBQUk7SUFDUkYsT0FBTztJQUNQLElBQUl6aUIsT0FBTyxPQUFPaVEsT0FBTyxLQUFLO1FBQzVCLElBQUlELE9BQU8sT0FBTy9QLE9BQU8sS0FBSztZQUM1QixPQUFPO1FBQ1QsT0FBTyxJQUFJK1AsS0FBSyxHQUFHO1lBQ2pCLElBQUkvUCxLQUFLLEdBQUc7Z0JBQ1YsT0FBTyxDQUFDd2lCO1lBQ1YsT0FBTztnQkFDTCxPQUFPQTtZQUNUO1FBQ0YsT0FBTztZQUNMLElBQUl4aUIsS0FBSyxHQUFHO2dCQUNWLE9BQU93aUI7WUFDVCxPQUFPO2dCQUNMLE9BQU8sQ0FBQ0E7WUFDVjtRQUNGO0lBQ0Y7SUFDQSxJQUFJelMsT0FBTyxPQUFPL1AsT0FBTyxLQUFLO1FBQzVCLElBQUlnUSxLQUFLLEdBQUc7WUFDVixJQUFJalEsS0FBSyxHQUFHO2dCQUNWLE9BQU95aUI7WUFDVCxPQUFPO2dCQUNMLE9BQU8sQ0FBQ0E7WUFDVjtRQUNGLE9BQU87WUFDTCxJQUFJemlCLEtBQUssR0FBRztnQkFDVixPQUFPLENBQUN5aUI7WUFDVixPQUFPO2dCQUNMLE9BQU9BO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsSUFBSXpTLEtBQUssS0FBSztRQUNaLElBQUlDLEtBQUssS0FBSztZQUNaLElBQUlELE1BQU1DLElBQUksQ0FFZCxPQUFPO2dCQUNMd1MsT0FBTyxDQUFDQTtnQkFDUkMsT0FBTzFpQjtnQkFDUEEsS0FBS0M7Z0JBQ0xBLEtBQUt5aUI7Z0JBQ0xBLE9BQU8xUztnQkFDUEEsS0FBS0M7Z0JBQ0xBLEtBQUt5UztZQUNQO1FBQ0YsT0FBTztZQUNMLElBQUkxUyxNQUFNLENBQUNDLElBQUk7Z0JBQ2J3UyxPQUFPLENBQUNBO2dCQUNSeGlCLEtBQUssQ0FBQ0E7Z0JBQ05nUSxLQUFLLENBQUNBO1lBQ1IsT0FBTztnQkFDTHlTLE9BQU8xaUI7Z0JBQ1BBLEtBQUssQ0FBQ0M7Z0JBQ05BLEtBQUt5aUI7Z0JBQ0xBLE9BQU8xUztnQkFDUEEsS0FBSyxDQUFDQztnQkFDTkEsS0FBS3lTO1lBQ1A7UUFDRjtJQUNGLE9BQU87UUFDTCxJQUFJelMsS0FBSyxLQUFLO1lBQ1osSUFBSSxDQUFDRCxNQUFNQyxJQUFJO2dCQUNid1MsT0FBTyxDQUFDQTtnQkFDUnppQixLQUFLLENBQUNBO2dCQUNOZ1EsS0FBSyxDQUFDQTtZQUNSLE9BQU87Z0JBQ0wwUyxPQUFPLENBQUMxaUI7Z0JBQ1JBLEtBQUtDO2dCQUNMQSxLQUFLeWlCO2dCQUNMQSxPQUFPLENBQUMxUztnQkFDUkEsS0FBS0M7Z0JBQ0xBLEtBQUt5UztZQUNQO1FBQ0YsT0FBTztZQUNMLElBQUkxUyxNQUFNQyxJQUFJO2dCQUNaalEsS0FBSyxDQUFDQTtnQkFDTmdRLEtBQUssQ0FBQ0E7Z0JBQ04vUCxLQUFLLENBQUNBO2dCQUNOZ1EsS0FBSyxDQUFDQTtZQUNSLE9BQU87Z0JBQ0x3UyxPQUFPLENBQUNBO2dCQUNSQyxPQUFPLENBQUMxaUI7Z0JBQ1JBLEtBQUssQ0FBQ0M7Z0JBQ05BLEtBQUt5aUI7Z0JBQ0xBLE9BQU8sQ0FBQzFTO2dCQUNSQSxLQUFLLENBQUNDO2dCQUNOQSxLQUFLeVM7WUFDUDtRQUNGO0lBQ0Y7SUFDQSxJQUFJMWlCLEtBQUssS0FBSztRQUNaLElBQUlDLEtBQUssS0FBSztZQUNaLElBQUlELE1BQU1DLElBQUksQ0FFZCxPQUFPO2dCQUNMLE9BQU93aUI7WUFDVDtRQUNGLE9BQU87WUFDTCxPQUFPQTtRQUNUO0lBQ0YsT0FBTztRQUNMLElBQUl4aUIsS0FBSyxLQUFLO1lBQ1osT0FBTyxDQUFDd2lCO1FBQ1YsT0FBTztZQUNMLElBQUl6aUIsTUFBTUMsSUFBSTtnQkFDWndpQixPQUFPLENBQUNBO2dCQUNSemlCLEtBQUssQ0FBQ0E7Z0JBQ05DLEtBQUssQ0FBQ0E7WUFDUixPQUFPO2dCQUNMLE9BQU8sQ0FBQ3dpQjtZQUNWO1FBQ0Y7SUFDRjtJQUNBLE1BQU8sS0FBTTtRQUNYRSxJQUFJamtCLEtBQUtZLEtBQUssQ0FBQ1csS0FBS0Q7UUFDcEJDLEtBQUtBLEtBQUswaUIsSUFBSTNpQjtRQUNkaVEsS0FBS0EsS0FBSzBTLElBQUkzUztRQUNkLElBQUlDLEtBQUssS0FBSztZQUNaLE9BQU8sQ0FBQ3dTO1FBQ1Y7UUFDQSxJQUFJeFMsS0FBS0QsSUFBSTtZQUNYLE9BQU95UztRQUNUO1FBQ0EsSUFBSXppQixLQUFLQyxLQUFLQSxJQUFJO1lBQ2hCLElBQUkrUCxLQUFLQyxLQUFLQSxJQUFJO2dCQUNoQixPQUFPd1M7WUFDVDtRQUNGLE9BQU87WUFDTCxJQUFJelMsS0FBS0MsS0FBS0EsSUFBSTtnQkFDaEIsT0FBTyxDQUFDd1M7WUFDVixPQUFPO2dCQUNMeGlCLEtBQUtELEtBQUtDO2dCQUNWZ1EsS0FBS0QsS0FBS0M7Z0JBQ1Z3UyxPQUFPLENBQUNBO1lBQ1Y7UUFDRjtRQUNBLElBQUl4UyxPQUFPLEtBQUs7WUFDZCxJQUFJaFEsT0FBTyxLQUFLO2dCQUNkLE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU8sQ0FBQ3dpQjtZQUNWO1FBQ0Y7UUFDQSxJQUFJeGlCLE9BQU8sS0FBSztZQUNkLE9BQU93aUI7UUFDVDtRQUNBRSxJQUFJamtCLEtBQUtZLEtBQUssQ0FBQ1UsS0FBS0M7UUFDcEJELEtBQUtBLEtBQUsyaUIsSUFBSTFpQjtRQUNkK1AsS0FBS0EsS0FBSzJTLElBQUkxUztRQUNkLElBQUlELEtBQUssS0FBSztZQUNaLE9BQU95UztRQUNUO1FBQ0EsSUFBSXpTLEtBQUtDLElBQUk7WUFDWCxPQUFPLENBQUN3UztRQUNWO1FBQ0EsSUFBSXhpQixLQUFLRCxLQUFLQSxJQUFJO1lBQ2hCLElBQUlpUSxLQUFLRCxLQUFLQSxJQUFJO2dCQUNoQixPQUFPLENBQUN5UztZQUNWO1FBQ0YsT0FBTztZQUNMLElBQUl4UyxLQUFLRCxLQUFLQSxJQUFJO2dCQUNoQixPQUFPeVM7WUFDVCxPQUFPO2dCQUNMemlCLEtBQUtDLEtBQUtEO2dCQUNWZ1EsS0FBS0MsS0FBS0Q7Z0JBQ1Z5UyxPQUFPLENBQUNBO1lBQ1Y7UUFDRjtRQUNBLElBQUl6UyxPQUFPLEtBQUs7WUFDZCxJQUFJaFEsT0FBTyxLQUFLO2dCQUNkLE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU95aUI7WUFDVDtRQUNGO1FBQ0EsSUFBSXppQixPQUFPLEtBQUs7WUFDZCxPQUFPLENBQUN5aUI7UUFDVjtJQUNGO0FBQ0Y7QUFFQSxJQUFJRyxxQkFBcUIsU0FBU0E7SUFDaEMsSUFBSSxDQUFDQyxFQUFFLEdBQUc7SUFDVixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQ3pCLElBQUkvUCxJQUFJbFUsU0FBUyxDQUFDLEVBQUU7SUFDcEIsSUFBSSxDQUFDK2pCLEVBQUUsR0FBRzdQO0FBQ1o7QUFDQTRQLG1CQUFtQjVrQixTQUFTLENBQUNnbEIsWUFBWSxHQUFHLFNBQVNBLGFBQWN6VCxFQUFFLEVBQUVDLEVBQUU7SUFDdkUsSUFBSUQsR0FBRzdQLENBQUMsR0FBRyxJQUFJLENBQUNtakIsRUFBRSxDQUFDbmpCLENBQUMsSUFBSThQLEdBQUc5UCxDQUFDLEdBQUcsSUFBSSxDQUFDbWpCLEVBQUUsQ0FBQ25qQixDQUFDLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDeEQsSUFBSSxJQUFJLENBQUNtakIsRUFBRSxDQUFDbmpCLENBQUMsS0FBSzhQLEdBQUc5UCxDQUFDLElBQUksSUFBSSxDQUFDbWpCLEVBQUUsQ0FBQ2xoQixDQUFDLEtBQUs2TixHQUFHN04sQ0FBQyxFQUFFO1FBQzVDLElBQUksQ0FBQ29oQixpQkFBaUIsR0FBRztRQUN6QixPQUFPO0lBQ1Q7SUFDQSxJQUFJeFQsR0FBRzVOLENBQUMsS0FBSyxJQUFJLENBQUNraEIsRUFBRSxDQUFDbGhCLENBQUMsSUFBSTZOLEdBQUc3TixDQUFDLEtBQUssSUFBSSxDQUFDa2hCLEVBQUUsQ0FBQ2xoQixDQUFDLEVBQUU7UUFDNUMsSUFBSXNoQixPQUFPMVQsR0FBRzdQLENBQUM7UUFDZixJQUFJd2pCLE9BQU8xVCxHQUFHOVAsQ0FBQztRQUNmLElBQUl1akIsT0FBT0MsTUFBTTtZQUNmRCxPQUFPelQsR0FBRzlQLENBQUM7WUFDWHdqQixPQUFPM1QsR0FBRzdQLENBQUM7UUFDYjtRQUNBLElBQUksSUFBSSxDQUFDbWpCLEVBQUUsQ0FBQ25qQixDQUFDLElBQUl1akIsUUFBUSxJQUFJLENBQUNKLEVBQUUsQ0FBQ25qQixDQUFDLElBQUl3akIsTUFBTTtZQUMxQyxJQUFJLENBQUNILGlCQUFpQixHQUFHO1FBQzNCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSSxHQUFJcGhCLENBQUMsR0FBRyxJQUFJLENBQUNraEIsRUFBRSxDQUFDbGhCLENBQUMsSUFBSTZOLEdBQUc3TixDQUFDLElBQUksSUFBSSxDQUFDa2hCLEVBQUUsQ0FBQ2xoQixDQUFDLElBQU02TixHQUFHN04sQ0FBQyxHQUFHLElBQUksQ0FBQ2toQixFQUFFLENBQUNsaEIsQ0FBQyxJQUFJNE4sR0FBRzVOLENBQUMsSUFBSSxJQUFJLENBQUNraEIsRUFBRSxDQUFDbGhCLENBQUMsRUFBRztRQUN0RixJQUFJM0IsS0FBS3VQLEdBQUc3UCxDQUFDLEdBQUcsSUFBSSxDQUFDbWpCLEVBQUUsQ0FBQ25qQixDQUFDO1FBQ3pCLElBQUlzUSxLQUFLVCxHQUFHNU4sQ0FBQyxHQUFHLElBQUksQ0FBQ2toQixFQUFFLENBQUNsaEIsQ0FBQztRQUN6QixJQUFJMUIsS0FBS3VQLEdBQUc5UCxDQUFDLEdBQUcsSUFBSSxDQUFDbWpCLEVBQUUsQ0FBQ25qQixDQUFDO1FBQ3pCLElBQUl1USxLQUFLVCxHQUFHN04sQ0FBQyxHQUFHLElBQUksQ0FBQ2toQixFQUFFLENBQUNsaEIsQ0FBQztRQUN6QixJQUFJd2hCLFdBQVdYLGtCQUFrQnpTLFlBQVksQ0FBQy9QLElBQUlnUSxJQUFJL1AsSUFBSWdRO1FBQzFELElBQUlrVCxhQUFhLEtBQUs7WUFDcEIsSUFBSSxDQUFDSixpQkFBaUIsR0FBRztZQUN6QixPQUFPO1FBQ1Q7UUFDQSxJQUFJOVMsS0FBS0QsSUFBSTtZQUFFbVQsV0FBVyxDQUFDQTtRQUFVO1FBQ3JDLElBQUlBLFdBQVcsS0FBSztZQUNsQixJQUFJLENBQUNMLGNBQWM7UUFDckI7SUFDRjtBQUNGO0FBQ0FGLG1CQUFtQjVrQixTQUFTLENBQUNvbEIsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDdkQsT0FBTyxJQUFJLENBQUNDLFdBQVcsT0FBTzFlLFNBQVNJLFFBQVE7QUFDakQ7QUFDQTZkLG1CQUFtQjVrQixTQUFTLENBQUNxbEIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xELElBQUksSUFBSSxDQUFDTixpQkFBaUIsRUFBRTtRQUFFLE9BQU9wZSxTQUFTRyxRQUFRO0lBQUM7SUFDdkQsSUFBSSxJQUFJLENBQUNnZSxjQUFjLEdBQUcsTUFBTSxHQUFHO1FBQ2pDLE9BQU9uZSxTQUFTRSxRQUFRO0lBQzFCO0lBQ0EsT0FBT0YsU0FBU0ksUUFBUTtBQUMxQjtBQUNBNmQsbUJBQW1CNWtCLFNBQVMsQ0FBQ3NsQixXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTyxJQUFJLENBQUNQLGlCQUFpQjtBQUMvQjtBQUNBSCxtQkFBbUI1a0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xELE9BQU8sRUFBRTtBQUNYO0FBQ0EraUIsbUJBQW1CNWtCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMvQyxPQUFPOGlCO0FBQ1Q7QUFDQUEsbUJBQW1CVyxpQkFBaUIsR0FBRyxTQUFTQTtJQUM5QyxJQUFJemtCLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxjQUFjeUQsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUUwUyxxQkFBcUI7UUFDeEYsSUFBSXdCLElBQUlsVSxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJNGIsT0FBTzViLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUkwa0IsVUFBVSxJQUFJWixtQkFBbUI1UDtRQUNyQyxJQUFJekQsS0FBSyxJQUFJN047UUFDYixJQUFJOE4sS0FBSyxJQUFJOU47UUFDYixJQUFLLElBQUkwRCxJQUFJLEdBQUdBLElBQUlzVixLQUFLL0ksSUFBSSxJQUFJdk0sSUFBSztZQUNwQ3NWLEtBQUs5SSxhQUFhLENBQUN4TSxHQUFHbUs7WUFDdEJtTCxLQUFLOUksYUFBYSxDQUFDeE0sSUFBSSxHQUFHb0s7WUFDMUJnVSxRQUFRUixZQUFZLENBQUN6VCxJQUFJQztZQUN6QixJQUFJZ1UsUUFBUUYsV0FBVyxJQUFJO2dCQUFFLE9BQU9FLFFBQVFILFdBQVc7WUFBRztRQUM1RDtRQUNBLE9BQU9HLFFBQVFILFdBQVc7SUFDNUIsT0FBTyxJQUFJdmtCLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxjQUFjNUMsU0FBUyxDQUFDLEVBQUUsWUFBWWYsT0FBTztRQUM5RSxJQUFJMGxCLE1BQU0za0IsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTRrQixTQUFTNWtCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUk2a0IsWUFBWSxJQUFJZixtQkFBbUJhO1FBQ3ZDLElBQUssSUFBSUcsTUFBTSxHQUFHQSxNQUFNRixPQUFPamxCLE1BQU0sRUFBRW1sQixNQUFPO1lBQzVDLElBQUl6USxPQUFPdVEsTUFBTSxDQUFDRSxJQUFJO1lBQ3RCLElBQUl4USxPQUFPc1EsTUFBTSxDQUFDRSxNQUFNLEVBQUU7WUFDMUJELFVBQVVYLFlBQVksQ0FBQzdQLE1BQU1DO1lBQzdCLElBQUl1USxVQUFVTCxXQUFXLElBQUk7Z0JBQUUsT0FBT0ssVUFBVU4sV0FBVztZQUFHO1FBQ2hFO1FBQ0EsT0FBT00sVUFBVU4sV0FBVztJQUM5QjtBQUNGO0FBRUEsSUFBSTdELGVBQWUsU0FBU0EsZ0JBQWlCO0FBRTdDLElBQUlxRSxvQkFBb0I7SUFBRUMsV0FBVztRQUFFM2xCLGNBQWM7SUFBSztJQUFFNGxCLE9BQU87UUFBRTVsQixjQUFjO0lBQUs7SUFBRTZsQixrQkFBa0I7UUFBRTdsQixjQUFjO0lBQUs7SUFBRThsQixNQUFNO1FBQUU5bEIsY0FBYztJQUFLO0lBQUUwZSxXQUFXO1FBQUUxZSxjQUFjO0lBQUs7SUFBRStsQixVQUFVO1FBQUUvbEIsY0FBYztJQUFLO0FBQUU7QUFFbk9xaEIsYUFBYXhoQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxFQUFFO0FBQ1g7QUFDQTJmLGFBQWF4aEIsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3pDLE9BQU8wZjtBQUNUO0FBQ0FBLGFBQWFsUSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxDQUFDO0lBQ2xFLE9BQU9OLGVBQWVHLGdCQUFnQixDQUFDQyxJQUFJQyxJQUFJQztBQUNqRDtBQUNBK1AsYUFBYTJFLFVBQVUsR0FBRyxTQUFTQTtJQUNqQyxJQUFJcmxCLFNBQVMsQ0FBQyxFQUFFLFlBQVlmLE9BQU87UUFDakMsSUFBSTJjLE9BQU81YixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJNGIsS0FBS2pjLE1BQU0sR0FBRyxHQUFHO1lBQUUsT0FBTztRQUFJO1FBQ2xDLElBQUkybEIsTUFBTTtRQUNWLElBQUlDLEtBQUszSixJQUFJLENBQUMsRUFBRSxDQUFDaGIsQ0FBQztRQUNsQixJQUFLLElBQUkwRixJQUFJLEdBQUdBLElBQUlzVixLQUFLamMsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1lBQ3hDLElBQUkxRixJQUFJZ2IsSUFBSSxDQUFDdFYsRUFBRSxDQUFDMUYsQ0FBQyxHQUFHMmtCO1lBQ3BCLElBQUlyVSxLQUFLMEssSUFBSSxDQUFDdFYsSUFBSSxFQUFFLENBQUN6RCxDQUFDO1lBQ3RCLElBQUlzTyxLQUFLeUssSUFBSSxDQUFDdFYsSUFBSSxFQUFFLENBQUN6RCxDQUFDO1lBQ3RCeWlCLE9BQU8xa0IsSUFBS3VRLENBQUFBLEtBQUtELEVBQUM7UUFDcEI7UUFDQSxPQUFPb1UsTUFBTTtJQUNmLE9BQU8sSUFBSWpmLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFMFMscUJBQXFCO1FBQ3pELElBQUlrUyxTQUFTNWtCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlrQyxJQUFJMGlCLE9BQU8vUixJQUFJO1FBQ25CLElBQUkzUSxJQUFJLEdBQUc7WUFBRSxPQUFPO1FBQUk7UUFDeEIsSUFBSXNhLEtBQUssSUFBSTVaO1FBQ2IsSUFBSTZOLEtBQUssSUFBSTdOO1FBQ2IsSUFBSThOLEtBQUssSUFBSTlOO1FBQ2JnaUIsT0FBTzlSLGFBQWEsQ0FBQyxHQUFHckM7UUFDeEJtVSxPQUFPOVIsYUFBYSxDQUFDLEdBQUdwQztRQUN4QixJQUFJOFUsT0FBTy9VLEdBQUc3UCxDQUFDO1FBQ2Y4UCxHQUFHOVAsQ0FBQyxJQUFJNGtCO1FBQ1IsSUFBSUMsUUFBUTtRQUNaLElBQUssSUFBSVgsTUFBTSxHQUFHQSxNQUFNNWlCLElBQUksR0FBRzRpQixNQUFPO1lBQ3BDdEksR0FBRzNaLENBQUMsR0FBRzROLEdBQUc1TixDQUFDO1lBQ1g0TixHQUFHN1AsQ0FBQyxHQUFHOFAsR0FBRzlQLENBQUM7WUFDWDZQLEdBQUc1TixDQUFDLEdBQUc2TixHQUFHN04sQ0FBQztZQUNYK2hCLE9BQU85UixhQUFhLENBQUNnUyxNQUFNLEdBQUdwVTtZQUM5QkEsR0FBRzlQLENBQUMsSUFBSTRrQjtZQUNSQyxTQUFTaFYsR0FBRzdQLENBQUMsR0FBSTRiLENBQUFBLEdBQUczWixDQUFDLEdBQUc2TixHQUFHN04sQ0FBQztRQUM5QjtRQUNBLE9BQU80aUIsUUFBUTtJQUNqQjtBQUNGO0FBQ0EvRSxhQUFhZ0YsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCQyxDQUFDLEVBQUVDLENBQUMsRUFBRTVaLENBQUMsRUFBRTZaLENBQUM7SUFDbkUsSUFBSUYsRUFBRTloQixNQUFNLENBQUMraEIsSUFBSTtRQUFFLE9BQU9sRixhQUFhK0MsaUJBQWlCLENBQUNrQyxHQUFHM1osR0FBRzZaO0lBQUc7SUFDbEUsSUFBSTdaLEVBQUVuSSxNQUFNLENBQUNnaUIsSUFBSTtRQUFFLE9BQU9uRixhQUFhK0MsaUJBQWlCLENBQUNvQyxHQUFHRixHQUFHQztJQUFHO0lBQ2xFLElBQUlFLGlCQUFpQjtJQUNyQixJQUFJLENBQUMxUSxTQUFTZSxVQUFVLENBQUN3UCxHQUFHQyxHQUFHNVosR0FBRzZaLElBQUk7UUFDcENDLGlCQUFpQjtJQUNuQixPQUFPO1FBQ0wsSUFBSXBVLFFBQVEsQ0FBQ2tVLEVBQUVobEIsQ0FBQyxHQUFHK2tCLEVBQUUva0IsQ0FBQyxJQUFLaWxCLENBQUFBLEVBQUVoakIsQ0FBQyxHQUFHbUosRUFBRW5KLENBQUMsSUFBSSxDQUFDK2lCLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQyxJQUFLZ2pCLENBQUFBLEVBQUVqbEIsQ0FBQyxHQUFHb0wsRUFBRXBMLENBQUM7UUFDaEUsSUFBSThRLFVBQVUsR0FBRztZQUNmb1UsaUJBQWlCO1FBQ25CLE9BQU87WUFDTCxJQUFJQyxRQUFRLENBQUNKLEVBQUU5aUIsQ0FBQyxHQUFHbUosRUFBRW5KLENBQUMsSUFBS2dqQixDQUFBQSxFQUFFamxCLENBQUMsR0FBR29MLEVBQUVwTCxDQUFDLElBQUksQ0FBQytrQixFQUFFL2tCLENBQUMsR0FBR29MLEVBQUVwTCxDQUFDLElBQUtpbEIsQ0FBQUEsRUFBRWhqQixDQUFDLEdBQUdtSixFQUFFbkosQ0FBQztZQUNoRSxJQUFJbWpCLE9BQU8sQ0FBQ0wsRUFBRTlpQixDQUFDLEdBQUdtSixFQUFFbkosQ0FBQyxJQUFLK2lCLENBQUFBLEVBQUVobEIsQ0FBQyxHQUFHK2tCLEVBQUUva0IsQ0FBQyxJQUFJLENBQUMra0IsRUFBRS9rQixDQUFDLEdBQUdvTCxFQUFFcEwsQ0FBQyxJQUFLZ2xCLENBQUFBLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQztZQUMvRCxJQUFJNkosSUFBSXNaLE9BQU90VTtZQUNmLElBQUlqRixJQUFJc1osUUFBUXJVO1lBQ2hCLElBQUlqRixJQUFJLEtBQUtBLElBQUksS0FBS0MsSUFBSSxLQUFLQSxJQUFJLEdBQUc7Z0JBQ3BDb1osaUJBQWlCO1lBQ25CO1FBQ0Y7SUFDRjtJQUNBLElBQUlBLGdCQUFnQjtRQUNsQixPQUFPdGYsU0FBUzFHLEdBQUcsQ0FBQzRnQixhQUFhK0MsaUJBQWlCLENBQUNrQyxHQUFHM1osR0FBRzZaLElBQUluRixhQUFhK0MsaUJBQWlCLENBQUNtQyxHQUFHNVosR0FBRzZaLElBQUluRixhQUFhK0MsaUJBQWlCLENBQUN6WCxHQUFHMlosR0FBR0MsSUFBSWxGLGFBQWErQyxpQkFBaUIsQ0FBQ29DLEdBQUdGLEdBQUdDO0lBQ3RMO0lBQ0EsT0FBTztBQUNUO0FBQ0FsRixhQUFhdUYsYUFBYSxHQUFHLFNBQVNBLGNBQWUvUixDQUFDLEVBQUUwSCxJQUFJO0lBQzFELE9BQU84RSxhQUFhK0QsaUJBQWlCLENBQUN2USxHQUFHMEgsVUFBVS9WLFNBQVNJLFFBQVE7QUFDdEU7QUFDQXlhLGFBQWF3RixhQUFhLEdBQUcsU0FBU0EsY0FBZUMsR0FBRztJQUN0RCxJQUFJamtCLElBQUlpa0IsSUFBSXRULElBQUk7SUFDaEIsSUFBSTNRLEtBQUssR0FBRztRQUFFLE9BQU87SUFBSTtJQUN6QixJQUFJa08sTUFBTTtJQUNWLElBQUk4RCxJQUFJLElBQUl0UjtJQUNadWpCLElBQUlyVCxhQUFhLENBQUMsR0FBR29CO0lBQ3JCLElBQUlxUixLQUFLclIsRUFBRXRULENBQUM7SUFDWixJQUFJd2xCLEtBQUtsUyxFQUFFclIsQ0FBQztJQUNaLElBQUssSUFBSXlELElBQUksR0FBR0EsSUFBSXBFLEdBQUdvRSxJQUFLO1FBQzFCNmYsSUFBSXJULGFBQWEsQ0FBQ3hNLEdBQUc0TjtRQUNyQixJQUFJaFQsS0FBS2dULEVBQUV0VCxDQUFDO1FBQ1osSUFBSXNRLEtBQUtnRCxFQUFFclIsQ0FBQztRQUNaLElBQUl3QixLQUFLbkQsS0FBS3FrQjtRQUNkLElBQUlqaEIsS0FBSzRNLEtBQUtrVjtRQUNkaFcsT0FBT3hRLEtBQUs0RSxJQUFJLENBQUNILEtBQUtBLEtBQUtDLEtBQUtBO1FBQ2hDaWhCLEtBQUtya0I7UUFDTGtsQixLQUFLbFY7SUFDUDtJQUNBLE9BQU9kO0FBQ1Q7QUFDQXNRLGFBQWEyRixLQUFLLEdBQUcsU0FBU0EsTUFBT3pLLElBQUk7SUFDdkMsSUFBSTBLLE9BQU8xSyxLQUFLamMsTUFBTSxHQUFHO0lBQ3pCLElBQUkybUIsT0FBTyxHQUFHO1FBQUUsTUFBTSxJQUFJaGxCLHlCQUF5QjtJQUFxRTtJQUN4SCxJQUFJaWxCLE9BQU8zSyxJQUFJLENBQUMsRUFBRTtJQUNsQixJQUFJNEssVUFBVTtJQUNkLElBQUssSUFBSWxnQixJQUFJLEdBQUdBLEtBQUtnZ0IsTUFBTWhnQixJQUFLO1FBQzlCLElBQUk0TixJQUFJMEgsSUFBSSxDQUFDdFYsRUFBRTtRQUNmLElBQUk0TixFQUFFclIsQ0FBQyxHQUFHMGpCLEtBQUsxakIsQ0FBQyxFQUFFO1lBQ2hCMGpCLE9BQU9yUztZQUNQc1MsVUFBVWxnQjtRQUNaO0lBQ0Y7SUFDQSxJQUFJbWdCLFFBQVFEO0lBQ1osR0FBRztRQUNEQyxRQUFRQSxRQUFRO1FBQ2hCLElBQUlBLFFBQVEsR0FBRztZQUFFQSxRQUFRSDtRQUFNO0lBQ2pDLFFBQVMxSyxJQUFJLENBQUM2SyxNQUFNLENBQUNoakIsUUFBUSxDQUFDOGlCLFNBQVNFLFVBQVVELFNBQVE7SUFDekQsSUFBSUUsUUFBUUY7SUFDWixHQUFHO1FBQ0RFLFFBQVEsQ0FBQ0EsUUFBUSxLQUFLSjtJQUN4QixRQUFTMUssSUFBSSxDQUFDOEssTUFBTSxDQUFDampCLFFBQVEsQ0FBQzhpQixTQUFTRyxVQUFVRixTQUFRO0lBQ3pELElBQUlHLE9BQU8vSyxJQUFJLENBQUM2SyxNQUFNO0lBQ3RCLElBQUlHLE9BQU9oTCxJQUFJLENBQUM4SyxNQUFNO0lBQ3RCLElBQUlDLEtBQUtsakIsUUFBUSxDQUFDOGlCLFNBQVNLLEtBQUtuakIsUUFBUSxDQUFDOGlCLFNBQVNJLEtBQUtsakIsUUFBUSxDQUFDbWpCLE9BQU87UUFBRSxPQUFPO0lBQU07SUFDdEYsSUFBSUMsT0FBT25HLGFBQWFvRyxrQkFBa0IsQ0FBQ0gsTUFBTUosTUFBTUs7SUFDdkQsSUFBSVAsUUFBUTtJQUNaLElBQUlRLFNBQVMsR0FBRztRQUNkUixRQUFRTSxLQUFLL2xCLENBQUMsR0FBR2dtQixLQUFLaG1CLENBQUM7SUFDekIsT0FBTztRQUNMeWxCLFFBQVFRLE9BQU87SUFDakI7SUFDQSxPQUFPUjtBQUNUO0FBQ0EzRixhQUFhK0QsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CdlEsQ0FBQyxFQUFFMEgsSUFBSTtJQUNsRSxPQUFPa0ksbUJBQW1CVyxpQkFBaUIsQ0FBQ3ZRLEdBQUcwSDtBQUNqRDtBQUNBOEUsYUFBYXFHLDhCQUE4QixHQUFHLFNBQVNBLCtCQUFnQzdTLENBQUMsRUFBRXlSLENBQUMsRUFBRUMsQ0FBQztJQUM1RixJQUFJb0IsT0FBTyxDQUFDcEIsRUFBRWhsQixDQUFDLEdBQUcra0IsRUFBRS9rQixDQUFDLElBQUtnbEIsQ0FBQUEsRUFBRWhsQixDQUFDLEdBQUcra0IsRUFBRS9rQixDQUFDLElBQUksQ0FBQ2dsQixFQUFFL2lCLENBQUMsR0FBRzhpQixFQUFFOWlCLENBQUMsSUFBSytpQixDQUFBQSxFQUFFL2lCLENBQUMsR0FBRzhpQixFQUFFOWlCLENBQUM7SUFDL0QsSUFBSTZKLElBQUksQ0FBQyxDQUFDaVosRUFBRTlpQixDQUFDLEdBQUdxUixFQUFFclIsQ0FBQyxJQUFLK2lCLENBQUFBLEVBQUVobEIsQ0FBQyxHQUFHK2tCLEVBQUUva0IsQ0FBQyxJQUFJLENBQUMra0IsRUFBRS9rQixDQUFDLEdBQUdzVCxFQUFFdFQsQ0FBQyxJQUFLZ2xCLENBQUFBLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQyxLQUFLbWtCO0lBQ2xFLE9BQU9wbkIsS0FBS3lCLEdBQUcsQ0FBQ3FMLEtBQUs5TSxLQUFLNEUsSUFBSSxDQUFDd2lCO0FBQ2pDO0FBQ0F0RyxhQUFhb0csa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CclcsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLENBQUM7SUFDdEUsT0FBTytQLGFBQWFsUSxnQkFBZ0IsQ0FBQ0MsSUFBSUMsSUFBSUM7QUFDL0M7QUFDQStQLGFBQWErQyxpQkFBaUIsR0FBRyxTQUFTQTtJQUN4QyxJQUFJempCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUl1VSxJQUFJbFUsU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSXdiLE9BQU94YixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJd2IsS0FBSzdiLE1BQU0sS0FBSyxHQUFHO1lBQUUsTUFBTSxJQUFJMkIseUJBQXlCO1FBQStDO1FBQzNHLElBQUkybEIsY0FBYy9TLEVBQUV6UCxRQUFRLENBQUMrVyxJQUFJLENBQUMsRUFBRTtRQUNwQyxJQUFLLElBQUlsVixJQUFJLEdBQUdBLElBQUlrVixLQUFLN2IsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1lBQ3hDLElBQUlvWixPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDdlAsR0FBR3NILElBQUksQ0FBQ2xWLEVBQUUsRUFBRWtWLElBQUksQ0FBQ2xWLElBQUksRUFBRTtZQUNqRSxJQUFJb1osT0FBT3VILGFBQWE7Z0JBQ3RCQSxjQUFjdkg7WUFDaEI7UUFDRjtRQUNBLE9BQU91SDtJQUNULE9BQU8sSUFBSWpuQixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJZ2xCLE1BQU0za0IsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTJsQixJQUFJM2xCLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUk0bEIsSUFBSTVsQixTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJMmxCLEVBQUUva0IsQ0FBQyxLQUFLZ2xCLEVBQUVobEIsQ0FBQyxJQUFJK2tCLEVBQUU5aUIsQ0FBQyxLQUFLK2lCLEVBQUUvaUIsQ0FBQyxFQUFFO1lBQUUsT0FBTzhoQixJQUFJbGdCLFFBQVEsQ0FBQ2toQjtRQUFHO1FBQ3pELElBQUlxQixPQUFPLENBQUNwQixFQUFFaGxCLENBQUMsR0FBRytrQixFQUFFL2tCLENBQUMsSUFBS2dsQixDQUFBQSxFQUFFaGxCLENBQUMsR0FBRytrQixFQUFFL2tCLENBQUMsSUFBSSxDQUFDZ2xCLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQyxJQUFLK2lCLENBQUFBLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQztRQUMvRCxJQUFJNEosSUFBSSxDQUFDLENBQUNrWSxJQUFJL2pCLENBQUMsR0FBRytrQixFQUFFL2tCLENBQUMsSUFBS2dsQixDQUFBQSxFQUFFaGxCLENBQUMsR0FBRytrQixFQUFFL2tCLENBQUMsSUFBSSxDQUFDK2pCLElBQUk5aEIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQyxJQUFLK2lCLENBQUFBLEVBQUUvaUIsQ0FBQyxHQUFHOGlCLEVBQUU5aUIsQ0FBQyxLQUFLbWtCO1FBQ3RFLElBQUl2YSxLQUFLLEtBQUs7WUFBRSxPQUFPa1ksSUFBSWxnQixRQUFRLENBQUNraEI7UUFBRztRQUN2QyxJQUFJbFosS0FBSyxLQUFLO1lBQUUsT0FBT2tZLElBQUlsZ0IsUUFBUSxDQUFDbWhCO1FBQUc7UUFDdkMsSUFBSWxaLElBQUksQ0FBQyxDQUFDaVosRUFBRTlpQixDQUFDLEdBQUc4aEIsSUFBSTloQixDQUFDLElBQUsraUIsQ0FBQUEsRUFBRWhsQixDQUFDLEdBQUcra0IsRUFBRS9rQixDQUFDLElBQUksQ0FBQytrQixFQUFFL2tCLENBQUMsR0FBRytqQixJQUFJL2pCLENBQUMsSUFBS2dsQixDQUFBQSxFQUFFL2lCLENBQUMsR0FBRzhpQixFQUFFOWlCLENBQUMsS0FBS21rQjtRQUN0RSxPQUFPcG5CLEtBQUt5QixHQUFHLENBQUNxTCxLQUFLOU0sS0FBSzRFLElBQUksQ0FBQ3dpQjtJQUNqQztBQUNGO0FBQ0F0RyxhQUFhd0csUUFBUSxHQUFHLFNBQVNBLFNBQVVoVCxDQUFDLEVBQUU2TCxFQUFFO0lBQzlDLElBQUlvSCxrQkFBa0IsSUFBSS9HO0lBQzFCLElBQUssSUFBSTlaLElBQUksR0FBR0EsSUFBSXlaLEdBQUdwZ0IsTUFBTSxFQUFFMkcsSUFBSztRQUNsQyxJQUFJa1csS0FBS3VELEVBQUUsQ0FBQ3paLElBQUksRUFBRTtRQUNsQixJQUFJbUssS0FBS3NQLEVBQUUsQ0FBQ3paLEVBQUU7UUFDZDZnQixnQkFBZ0J4SSxtQkFBbUIsQ0FBQ3pLLEdBQUdzSSxJQUFJL0w7UUFDM0MsSUFBSTBXLGdCQUFnQi9ILGVBQWUsSUFBSTtZQUNyQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBMkYsa0JBQWtCQyxTQUFTLENBQUMxaUIsR0FBRyxHQUFHO0lBQWMsT0FBTyxDQUFDO0FBQUU7QUFDMUR5aUIsa0JBQWtCRSxLQUFLLENBQUMzaUIsR0FBRyxHQUFHO0lBQWMsT0FBT29lLGFBQWFzRSxTQUFTO0FBQUM7QUFDMUVELGtCQUFrQkcsZ0JBQWdCLENBQUM1aUIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ2hFeWlCLGtCQUFrQkksSUFBSSxDQUFDN2lCLEdBQUcsR0FBRztJQUFjLE9BQU9vZSxhQUFhd0UsZ0JBQWdCO0FBQUM7QUFDaEZILGtCQUFrQmhILFNBQVMsQ0FBQ3piLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUN6RHlpQixrQkFBa0JLLFFBQVEsQ0FBQzlpQixHQUFHLEdBQUc7SUFBYyxPQUFPb2UsYUFBYTNDLFNBQVM7QUFBQztBQUU3RTVlLE9BQU9vRCxnQkFBZ0IsQ0FBRW1lLGNBQWNxRTtBQUV2QyxJQUFJcUMsMEJBQTBCLFNBQVNBLDJCQUE0QjtBQUVuRUEsd0JBQXdCbG9CLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUUMsSUFBSSxHQUFHO0FBQ25FRix3QkFBd0Jsb0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3ZELE9BQU8sRUFBRTtBQUNYO0FBQ0FxbUIsd0JBQXdCbG9CLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNwRCxPQUFPb21CO0FBQ1Q7QUFFQSxJQUFJRyxXQUFXLFNBQVNBO0lBQ3RCLElBQUlDLFVBQVV4bkIsU0FBUyxDQUFDLEVBQUU7SUFFMUIsSUFBSSxDQUFDeW5CLFNBQVMsR0FBRztJQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0YsUUFBUSxHQUFHRjtJQUNoQixJQUFJLENBQUNHLEtBQUssR0FBR0gsUUFBUUssT0FBTztBQUM5QjtBQUVBLElBQUlDLHFCQUFxQjtJQUFFM2tCLGtCQUFrQjtRQUFFOUQsY0FBYztJQUFLO0lBQUUwb0IsaUJBQWlCO1FBQUUxb0IsY0FBYztJQUFLO0lBQUUyb0Isc0JBQXNCO1FBQUUzb0IsY0FBYztJQUFLO0lBQUU0b0Isc0JBQXNCO1FBQUU1b0IsY0FBYztJQUFLO0lBQUU2b0Isc0JBQXNCO1FBQUU3b0IsY0FBYztJQUFLO0lBQUU4b0IsMkJBQTJCO1FBQUU5b0IsY0FBYztJQUFLO0lBQUUrb0IsbUJBQW1CO1FBQUUvb0IsY0FBYztJQUFLO0lBQUVncEIsd0JBQXdCO1FBQUVocEIsY0FBYztJQUFLO0lBQUVpcEIsOEJBQThCO1FBQUVqcEIsY0FBYztJQUFLO0lBQUVrcEIsdUJBQXVCO1FBQUVscEIsY0FBYztJQUFLO0FBQUU7QUFDamVrb0IsU0FBU3JvQixTQUFTLENBQUNzcEIsb0JBQW9CLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxJQUFJLENBQUNDLFlBQVksT0FBT2xCLFNBQVNlLDRCQUE0QjtBQUN0RTtBQUNBZixTQUFTcm9CLFNBQVMsQ0FBQ3dwQixVQUFVLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxJQUFJLENBQUNoQixRQUFRO0FBQ3RCO0FBQ0FILFNBQVNyb0IsU0FBUyxDQUFDeXBCLFlBQVksR0FBRyxTQUFTQSxhQUFjem1CLENBQUM7SUFDeEQsT0FBTyxJQUFJO0FBQ2I7QUFDQXFsQixTQUFTcm9CLFNBQVMsQ0FBQ3dXLE9BQU8sR0FBRyxTQUFTQTtJQUNwQyxPQUFPO0FBQ1Q7QUFDQTZSLFNBQVNyb0IsU0FBUyxDQUFDMHBCLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxPQUFPO0FBQ1Q7QUFDQXJCLFNBQVNyb0IsU0FBUyxDQUFDMkUsTUFBTSxHQUFHLFNBQVNBO0lBQ25DLElBQUk3RCxTQUFTLENBQUMsRUFBRSxZQUFZdW5CLFVBQVU7UUFDcEMsSUFBSXNCLE1BQU03b0IsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTZvQixRQUFRLE1BQU07WUFBRSxPQUFPO1FBQU07UUFDakMsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0Q7SUFDekIsT0FBTyxJQUFJN29CLFNBQVMsQ0FBQyxFQUFFLFlBQVliLFFBQVE7UUFDekMsSUFBSTZFLElBQUloRSxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJLENBQUVnRSxDQUFBQSxhQUFhdWpCLFFBQU8sR0FBSTtZQUFFLE9BQU87UUFBTTtRQUM3QyxJQUFJd0IsSUFBSS9rQjtRQUNSLE9BQU8sSUFBSSxDQUFDZ2xCLFdBQVcsQ0FBQ0Q7SUFDMUI7QUFDRjtBQUNBeEIsU0FBU3JvQixTQUFTLENBQUM4cEIsV0FBVyxHQUFHLFNBQVNBLFlBQWF0bEIsS0FBSztJQUMxRCxPQUFPLElBQUksS0FBS0EsU0FBUyxJQUFJLENBQUNzbEIsV0FBVyxDQUFDdGxCLE9BQU87QUFDbkQ7QUFDQTZqQixTQUFTcm9CLFNBQVMsQ0FBQytwQixlQUFlLEdBQUcsU0FBU0E7SUFDNUMsSUFBSSxDQUFDeFEsS0FBSyxDQUFDOE8sU0FBU2dCLHFCQUFxQjtBQUMzQztBQUNBaEIsU0FBU3JvQixTQUFTLENBQUNncUIscUJBQXFCLEdBQUcsU0FBU0E7SUFDbEQsSUFBSSxDQUFDekIsU0FBUyxHQUFHO0FBQ25CO0FBQ0FGLFNBQVNyb0IsU0FBUyxDQUFDaXFCLFVBQVUsR0FBRyxTQUFTQSxXQUFZSixDQUFDO0lBQ3BELElBQUlBLE1BQU0sTUFBTTtRQUFFLE9BQU87SUFBTTtJQUMvQixPQUFPLElBQUksQ0FBQ0ssSUFBSSxHQUFHSixXQUFXLENBQUNELEVBQUVLLElBQUk7QUFDdkM7QUFDQTdCLFNBQVNyb0IsU0FBUyxDQUFDbXFCLFNBQVMsR0FBRyxTQUFTQTtJQUN0QyxPQUFPO0FBQ1Q7QUFDQTlCLFNBQVNyb0IsU0FBUyxDQUFDb3FCLGdCQUFnQixHQUFHLFNBQVNBO0lBQzdDLE9BQU87QUFDVDtBQUNBL0IsU0FBU3JvQixTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0E7SUFDdEMsSUFBSS9ELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlxRSxJQUFJaEUsU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSTBELFFBQVFNO1FBQ1osSUFBSSxJQUFJLENBQUN5a0IsWUFBWSxPQUFPL2tCLE1BQU0ra0IsWUFBWSxJQUFJO1lBQ2hELE9BQU8sSUFBSSxDQUFDQSxZQUFZLEtBQUsva0IsTUFBTStrQixZQUFZO1FBQ2pEO1FBQ0EsSUFBSSxJQUFJLENBQUN6UCxPQUFPLE1BQU10VixNQUFNc1YsT0FBTyxJQUFJO1lBQ3JDLE9BQU87UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDQSxPQUFPLElBQUk7WUFDbEIsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxJQUFJdFYsTUFBTXNWLE9BQU8sSUFBSTtZQUNuQixPQUFPO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQ3VRLGtCQUFrQixDQUFDdmxCO0lBQ2pDLE9BQU8sSUFBSWhFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk2cEIsVUFBVXhwQixTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJeXBCLE9BQU96cEIsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUN5b0IsWUFBWSxPQUFPZSxRQUFRZixZQUFZLElBQUk7WUFDbEQsT0FBTyxJQUFJLENBQUNBLFlBQVksS0FBS2UsUUFBUWYsWUFBWTtRQUNuRDtRQUNBLElBQUksSUFBSSxDQUFDelAsT0FBTyxNQUFNd1EsUUFBUXhRLE9BQU8sSUFBSTtZQUN2QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1lBQ2xCLE9BQU8sQ0FBQztRQUNWO1FBQ0EsSUFBSXdRLFFBQVF4USxPQUFPLElBQUk7WUFDckIsT0FBTztRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUN1USxrQkFBa0IsQ0FBQ0MsU0FBU0M7SUFDMUM7QUFDRjtBQUNBbEMsU0FBU3JvQixTQUFTLENBQUN3cUIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sSUFBSSxDQUFDOUIsU0FBUztBQUN2QjtBQUNBTCxTQUFTcm9CLFNBQVMsQ0FBQzJvQixPQUFPLEdBQUcsU0FBU0E7SUFDcEMsT0FBTyxJQUFJLENBQUNGLEtBQUs7QUFDbkI7QUFDQUosU0FBU3JvQixTQUFTLENBQUN5cUIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sSUFBSSxDQUFDakIsVUFBVSxHQUFHa0IsVUFBVSxDQUFDLElBQUksQ0FBQ0MsbUJBQW1CO0FBQzlEO0FBQ0F0QyxTQUFTcm9CLFNBQVMsQ0FBQzRxQiwwQkFBMEIsR0FBRyxTQUFTQSwyQkFBNEJmLENBQUM7SUFDcEYsSUFBSUEsRUFBRU4sWUFBWSxPQUFPbEIsU0FBU2UsNEJBQTRCLEVBQUU7UUFDOUQsTUFBTSxJQUFJaG5CLHlCQUF5QjtJQUNyQztBQUNGO0FBQ0FpbUIsU0FBU3JvQixTQUFTLENBQUM2cUIsS0FBSyxHQUFHLFNBQVNBLE1BQU9ya0IsQ0FBQyxFQUFFQyxDQUFDLEVBQUV2RSxTQUFTO0lBQ3hELElBQUlBLGNBQWMsR0FBRztRQUNuQixPQUFPc0UsRUFBRTdCLE1BQU0sQ0FBQzhCO0lBQ2xCO0lBQ0EsT0FBT0QsRUFBRWpCLFFBQVEsQ0FBQ2tCLE1BQU12RTtBQUMxQjtBQUNBbW1CLFNBQVNyb0IsU0FBUyxDQUFDa3FCLElBQUksR0FBRyxTQUFTQTtJQUNqQyxJQUFJbGxCLE9BQU8sSUFBSSxDQUFDQSxJQUFJO0lBQ3BCQSxLQUFLOGxCLFNBQVM7SUFDZCxPQUFPOWxCO0FBQ1Q7QUFDQXFqQixTQUFTcm9CLFNBQVMsQ0FBQytxQixpQkFBaUIsR0FBRyxTQUFTQTtJQUM5QyxPQUFPLElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQ3VDLGlCQUFpQjtBQUN4QztBQUNBMUMsU0FBU3JvQixTQUFTLENBQUMycUIsbUJBQW1CLEdBQUcsU0FBU0E7SUFDaEQsSUFBSSxJQUFJLENBQUNwQyxTQUFTLEtBQUssTUFBTTtRQUMzQixJQUFJLENBQUNBLFNBQVMsR0FBRyxJQUFJLENBQUN5Qyx1QkFBdUI7SUFDL0M7SUFDQSxPQUFPLElBQUk5VSxTQUFTLElBQUksQ0FBQ3FTLFNBQVM7QUFDcEM7QUFDQUYsU0FBU3JvQixTQUFTLENBQUNpckIsT0FBTyxHQUFHLFNBQVNBLFFBQVNDLElBQUk7SUFDakQsSUFBSSxDQUFDekMsS0FBSyxHQUFHeUM7QUFDZjtBQUNBN0MsU0FBU3JvQixTQUFTLENBQUNtckIsV0FBVyxHQUFHLFNBQVNBLFlBQWFDLFFBQVE7SUFDN0QsSUFBSSxDQUFDMUMsU0FBUyxHQUFHMEM7QUFDbkI7QUFDQS9DLFNBQVNyb0IsU0FBUyxDQUFDZ0csT0FBTyxHQUFHLFNBQVNBLFFBQVNRLENBQUMsRUFBRUMsQ0FBQztJQUNqRCxJQUFJVyxJQUFJWixFQUFFNmtCLFFBQVE7SUFDbEIsSUFBSUMsSUFBSTdrQixFQUFFNGtCLFFBQVE7SUFDbEIsTUFBT2prQixFQUFFbWtCLE9BQU8sTUFBTUQsRUFBRUMsT0FBTyxHQUFJO1FBQ2pDLElBQUlDLFdBQVdwa0IsRUFBRXNnQixJQUFJO1FBQ3JCLElBQUkrRCxXQUFXSCxFQUFFNUQsSUFBSTtRQUNyQixJQUFJZ0UsYUFBYUYsU0FBUzNtQixTQUFTLENBQUM0bUI7UUFDcEMsSUFBSUMsZUFBZSxHQUFHO1lBQ3BCLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLElBQUl0a0IsRUFBRW1rQixPQUFPLElBQUk7UUFDZixPQUFPO0lBQ1Q7SUFDQSxJQUFJRCxFQUFFQyxPQUFPLElBQUk7UUFDZixPQUFPLENBQUM7SUFDVjtJQUNBLE9BQU87QUFDVDtBQUNBbEQsU0FBU3JvQixTQUFTLENBQUN3RixRQUFRLEdBQUcsU0FBU0E7SUFDckMsT0FBTyxJQUFJLENBQUNtbEIsbUJBQW1CLEdBQUdubEIsUUFBUTtBQUM1QztBQUNBNmlCLFNBQVNyb0IsU0FBUyxDQUFDMnJCLDZCQUE2QixHQUFHLFNBQVNBO0lBQzFELElBQUksSUFBSSxDQUFDcEMsWUFBWSxPQUFPbEIsU0FBU2UsNEJBQTRCLElBQUksSUFBSSxDQUFDRyxZQUFZLE9BQU9sQixTQUFTUyxvQkFBb0IsSUFBSSxJQUFJLENBQUNTLFlBQVksT0FBT2xCLFNBQVNZLHlCQUF5QixJQUFJLElBQUksQ0FBQ00sWUFBWSxPQUFPbEIsU0FBU2Msc0JBQXNCLEVBQUU7UUFDblAsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0FkLFNBQVNyb0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU87UUFBQzBCO1FBQVVEO1FBQVlHO0tBQWE7QUFDN0M7QUFDQTRrQixTQUFTcm9CLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPdW1CO0FBQ1Q7QUFDQUEsU0FBU3VELG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQkMsVUFBVTtJQUNyRSxJQUFLLElBQUl6a0IsSUFBSSxHQUFHQSxJQUFJeWtCLFdBQVdwckIsTUFBTSxFQUFFMkcsSUFBSztRQUMxQyxJQUFJLENBQUN5a0IsVUFBVSxDQUFDemtCLEVBQUUsQ0FBQzBTLE9BQU8sSUFBSTtZQUM1QixPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBdU8sU0FBU3lELGVBQWUsR0FBRyxTQUFTQSxnQkFBaUJ2UixLQUFLO0lBQ3hELElBQUssSUFBSW5ULElBQUksR0FBR0EsSUFBSW1ULE1BQU05WixNQUFNLEVBQUUyRyxJQUFLO1FBQ3JDLElBQUltVCxLQUFLLENBQUNuVCxFQUFFLEtBQUssTUFBTTtZQUNyQixPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBd2hCLG1CQUFtQjNrQixnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFvQjtBQUNuRndsQixtQkFBbUJDLGVBQWUsQ0FBQ3psQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDaEV3bEIsbUJBQW1CRSxvQkFBb0IsQ0FBQzFsQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDckV3bEIsbUJBQW1CRyxvQkFBb0IsQ0FBQzNsQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDckV3bEIsbUJBQW1CSSxvQkFBb0IsQ0FBQzVsQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDckV3bEIsbUJBQW1CSyx5QkFBeUIsQ0FBQzdsQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDMUV3bEIsbUJBQW1CTSxpQkFBaUIsQ0FBQzlsQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDbEV3bEIsbUJBQW1CTyxzQkFBc0IsQ0FBQy9sQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDdkV3bEIsbUJBQW1CUSw0QkFBNEIsQ0FBQ2htQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDN0V3bEIsbUJBQW1CUyxxQkFBcUIsQ0FBQ2ptQixHQUFHLEdBQUc7SUFBYyxPQUFPaW1CO0FBQXNCO0FBRTFGcHBCLE9BQU9vRCxnQkFBZ0IsQ0FBRWdsQixVQUFVTztBQUVuQyxJQUFJUyx3QkFBd0IsU0FBU0EseUJBQTBCO0FBRS9EQSxzQkFBc0J4bkIsV0FBVyxHQUFHLFNBQVNBO0lBQzNDLE9BQU87UUFBQ3FtQjtLQUF3QjtBQUNsQztBQUNBbUIsc0JBQXNCbEIsTUFBTSxHQUFHLFNBQVNBLE9BQVFDLElBQUk7SUFDbERBLEtBQUs0QixxQkFBcUI7QUFDNUI7QUFFQSxJQUFJK0IsbUJBQW1CLFNBQVNBLG9CQUFxQjtBQUVyREEsaUJBQWlCL3JCLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUTZELEtBQUssR0FBRztBQUM3REQsaUJBQWlCL3JCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNoRCxPQUFPLEVBQUU7QUFDWDtBQUNBa3FCLGlCQUFpQi9yQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDN0MsT0FBT2lxQjtBQUNUO0FBRUEsSUFBSUUsbUJBQW1CLFNBQVNBLG9CQUFxQjtBQUVyRCxJQUFJQyxxQkFBcUI7SUFBRUMsc0JBQXNCO1FBQUVoc0IsY0FBYztJQUFLO0lBQUVpc0IsMEJBQTBCO1FBQUVqc0IsY0FBYztJQUFLO0lBQUVrc0IscUNBQXFDO1FBQUVsc0IsY0FBYztJQUFLO0lBQUVtc0Isb0NBQW9DO1FBQUVuc0IsY0FBYztJQUFLO0lBQUVvc0Isb0JBQW9CO1FBQUVwc0IsY0FBYztJQUFLO0lBQUVxc0Isd0JBQXdCO1FBQUVyc0IsY0FBYztJQUFLO0lBQUVzc0Isb0NBQW9DO1FBQUV0c0IsY0FBYztJQUFLO0lBQUV1c0IsbUNBQW1DO1FBQUV2c0IsY0FBYztJQUFLO0lBQUV3c0IsdUJBQXVCO1FBQUV4c0IsY0FBYztJQUFLO0FBQUU7QUFFN2U4ckIsaUJBQWlCanNCLFNBQVMsQ0FBQzRzQixZQUFZLEdBQUcsU0FBU0EsYUFBY0MsYUFBYSxHQUFHO0FBQ2pGWixpQkFBaUJqc0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2hELE9BQU8sRUFBRTtBQUNYO0FBQ0FvcUIsaUJBQWlCanNCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM3QyxPQUFPbXFCO0FBQ1Q7QUFDQUMsbUJBQW1CQyxvQkFBb0IsQ0FBQy9vQixHQUFHLEdBQUc7SUFBYyxPQUFPK29CO0FBQXFCO0FBQ3hGRCxtQkFBbUJFLHdCQUF3QixDQUFDaHBCLEdBQUcsR0FBRztJQUFjLE9BQU9ncEI7QUFBeUI7QUFDaEdGLG1CQUFtQkcsbUNBQW1DLENBQUNqcEIsR0FBRyxHQUFHO0lBQWMsT0FBT2lwQjtBQUFvQztBQUN0SEgsbUJBQW1CSSxrQ0FBa0MsQ0FBQ2xwQixHQUFHLEdBQUc7SUFBYyxPQUFPa3BCO0FBQW1DO0FBQ3BISixtQkFBbUJLLGtCQUFrQixDQUFDbnBCLEdBQUcsR0FBRztJQUFjLE9BQU8sSUFBSStvQjtBQUF1QjtBQUM1RkQsbUJBQW1CTSxzQkFBc0IsQ0FBQ3BwQixHQUFHLEdBQUc7SUFBYyxPQUFPLElBQUlncEI7QUFBMkI7QUFDcEdGLG1CQUFtQk8sa0NBQWtDLENBQUNycEIsR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJaXBCO0FBQXNDO0FBQzNISCxtQkFBbUJRLGlDQUFpQyxDQUFDdHBCLEdBQUcsR0FBRztJQUFjLE9BQU8sSUFBSWtwQjtBQUFxQztBQUN6SEosbUJBQW1CUyxxQkFBcUIsQ0FBQ3ZwQixHQUFHLEdBQUc7SUFBYyxPQUFPNm9CLGlCQUFpQk0sa0JBQWtCO0FBQUM7QUFFeEd0c0IsT0FBT29ELGdCQUFnQixDQUFFNG9CLGtCQUFrQkM7QUFFM0MsSUFBSUMsdUJBQXVCLFNBQVNBLHdCQUF5QjtBQUU3REEscUJBQXFCbnNCLFNBQVMsQ0FBQzRzQixZQUFZLEdBQUcsU0FBU0EsYUFBY0MsYUFBYTtJQUNoRixPQUFPQSxnQkFBZ0IsTUFBTTtBQUMvQjtBQUNBVixxQkFBcUJuc0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3BELE9BQU87UUFBQ29xQjtLQUFpQjtBQUMzQjtBQUNBRSxxQkFBcUJuc0IsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pELE9BQU9xcUI7QUFDVDtBQUVBLElBQUlDLDJCQUEyQixTQUFTQSw0QkFBNkI7QUFFckVBLHlCQUF5QnBzQixTQUFTLENBQUM0c0IsWUFBWSxHQUFHLFNBQVNBLGFBQWNDLGFBQWE7SUFDcEYsT0FBT0EsZ0JBQWdCO0FBQ3pCO0FBQ0FULHlCQUF5QnBzQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDeEQsT0FBTztRQUFDb3FCO0tBQWlCO0FBQzNCO0FBQ0FHLHlCQUF5QnBzQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDckQsT0FBT3NxQjtBQUNUO0FBRUEsSUFBSUMsc0NBQXNDLFNBQVNBLHVDQUF3QztBQUUzRkEsb0NBQW9DcnNCLFNBQVMsQ0FBQzRzQixZQUFZLEdBQUcsU0FBU0EsYUFBY0MsYUFBYTtJQUMvRixPQUFPQSxnQkFBZ0I7QUFDekI7QUFDQVIsb0NBQW9DcnNCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNuRSxPQUFPO1FBQUNvcUI7S0FBaUI7QUFDM0I7QUFDQUksb0NBQW9DcnNCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNoRSxPQUFPdXFCO0FBQ1Q7QUFFQSxJQUFJQyxxQ0FBcUMsU0FBU0Esc0NBQXVDO0FBRXpGQSxtQ0FBbUN0c0IsU0FBUyxDQUFDNHNCLFlBQVksR0FBRyxTQUFTQSxhQUFjQyxhQUFhO0lBQzlGLE9BQU9BLGtCQUFrQjtBQUMzQjtBQUNBUCxtQ0FBbUN0c0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xFLE9BQU87UUFBQ29xQjtLQUFpQjtBQUMzQjtBQUNBSyxtQ0FBbUN0c0IsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQy9ELE9BQU93cUI7QUFDVDtBQUVBLG9DQUFvQztBQUVwQzs7Ozs7Q0FLQyxHQUNELElBQUlRLGFBQWEsU0FBU0EsY0FBZTtBQUV6Q0EsV0FBVzlzQixTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsT0FBUTtBQUU1Qzs7Ozs7O0NBTUMsR0FDRDZnQixXQUFXOXNCLFNBQVMsQ0FBQytzQixNQUFNLEdBQUcsU0FBU0EsVUFBVztBQUVsRDs7O0NBR0MsR0FDREQsV0FBVzlzQixTQUFTLENBQUM4WixPQUFPLEdBQUcsU0FBU0EsV0FBWTtBQUVwRDs7O0NBR0MsR0FDRGdULFdBQVc5c0IsU0FBUyxDQUFDcXJCLFFBQVEsR0FBRyxTQUFTQSxZQUFhO0FBRXREOzs7Q0FHQyxHQUNEeUIsV0FBVzlzQixTQUFTLENBQUMyVCxJQUFJLEdBQUcsU0FBU0EsUUFBUztBQUU5Qzs7O0NBR0MsR0FDRG1aLFdBQVc5c0IsU0FBUyxDQUFDZ3RCLE9BQU8sR0FBRyxTQUFTQSxXQUFZO0FBRXBEOzs7OztDQUtDLEdBQ0RGLFdBQVc5c0IsU0FBUyxDQUFDaXRCLE1BQU0sR0FBRyxTQUFTQSxVQUFXO0FBRWxEOzs7OztDQUtDLEdBQ0QsU0FBU0MsMEJBQTJCNXFCLE9BQU87SUFDekMsSUFBSSxDQUFDQSxPQUFPLEdBQUdBLFdBQVc7QUFDNUI7QUFDQTRxQiwwQkFBMEJsdEIsU0FBUyxHQUFHLElBQUlxQztBQUUxQzs7Q0FFQyxHQUNENnFCLDBCQUEwQmx0QixTQUFTLENBQUN3QyxJQUFJLEdBQUc7QUFFM0M7Ozs7Q0FJQyxHQUNELElBQUkycUIsV0FBVyxTQUFTQSxZQUFhO0FBRXJDQSxTQUFTbnRCLFNBQVMsQ0FBQ3VyQixPQUFPLEdBQUcsU0FBU0EsV0FBWTtBQUVsRDs7O0NBR0MsR0FDRDRCLFNBQVNudEIsU0FBUyxDQUFDMG5CLElBQUksR0FBRyxTQUFTQSxRQUFTO0FBRTVDOzs7Q0FHQyxHQUNEeUYsU0FBU250QixTQUFTLENBQUNpdEIsTUFBTSxHQUFHLFNBQVNBLFVBQVc7QUFFaEQ7Ozs7OztDQU1DLEdBQ0QsSUFBSUcsT0FBUSxTQUFVQyxhQUFhO0lBQ2pDLFNBQVNEO1FBQ1BDLGNBQWM5VCxLQUFLLENBQUMsSUFBSSxFQUFFelk7SUFDNUI7SUFFQSxJQUFLdXNCLGVBQWdCRCxLQUFLMXFCLFNBQVMsR0FBRzJxQjtJQUN0Q0QsS0FBS3B0QixTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUUwcUIsaUJBQWlCQSxjQUFjcnRCLFNBQVM7SUFDeEVvdEIsS0FBS3B0QixTQUFTLENBQUM0QyxXQUFXLEdBQUd3cUI7SUFFN0JBLEtBQUtwdEIsU0FBUyxDQUFDb0QsR0FBRyxHQUFHLFNBQVNBLE9BQVM7SUFFdkM7Ozs7OztHQU1DLEdBQ0RncUIsS0FBS3B0QixTQUFTLENBQUNzdEIsR0FBRyxHQUFHLFNBQVNBLE9BQVM7SUFFdkM7OztHQUdDLEdBQ0RGLEtBQUtwdEIsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBLFdBQWE7SUFFL0MsT0FBT3NUO0FBQ1QsRUFBRU47QUFFRjs7Ozs7Q0FLQyxHQUNELFNBQVNTLHVCQUF3QmpyQixPQUFPO0lBQ3RDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQSxXQUFXO0FBQzVCO0FBQ0FpckIsdUJBQXVCdnRCLFNBQVMsR0FBRyxJQUFJcUM7QUFFdkM7O0NBRUMsR0FDRGtyQix1QkFBdUJ2dEIsU0FBUyxDQUFDd0MsSUFBSSxHQUFHO0FBRXhDLDhEQUE4RDtBQUU5RDs7Ozs7Q0FLQyxHQUNELElBQUlnckIsWUFBYSxTQUFVQyxPQUFPO0lBQ2hDLFNBQVNEO1FBQ1BDLFFBQVFsckIsSUFBSSxDQUFDLElBQUk7UUFDakIsSUFBSSxDQUFDbXJCLE1BQU0sR0FBRyxFQUFFO1FBRWhCLElBQUk1c0IsU0FBUyxDQUFDLEVBQUUsWUFBWWdzQixZQUFZO1lBQ3RDLElBQUksQ0FBQ0MsTUFBTSxDQUFDanNCLFNBQVMsQ0FBQyxFQUFFO1FBQzFCO0lBQ0Y7SUFFQSxJQUFLMnNCLFNBQVVELFVBQVU5cUIsU0FBUyxHQUFHK3FCO0lBQ3JDRCxVQUFVeHRCLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRThxQixXQUFXQSxRQUFRenRCLFNBQVM7SUFDakV3dEIsVUFBVXh0QixTQUFTLENBQUM0QyxXQUFXLEdBQUc0cUI7SUFFbENBLFVBQVV4dEIsU0FBUyxDQUFDMnRCLGNBQWMsR0FBRyxTQUFTQSxrQkFBbUI7SUFDakVILFVBQVV4dEIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQWlCLE9BQU87WUFBQzRyQjtZQUFTWDtTQUFXO0lBQUM7SUFFekY7O0dBRUMsR0FDRFUsVUFBVXh0QixTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsSUFBS3BELENBQUM7UUFDdkMsSUFBSS9ILFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ2l0QixNQUFNLENBQUNqVCxJQUFJLENBQUM1UjtRQUNuQixPQUFPO1lBQ0wsSUFBSSxDQUFDNmtCLE1BQU0sQ0FBQ0UsTUFBTSxDQUFDOXNCLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1FBQy9DO1FBQ0EsT0FBTztJQUNUO0lBRUEwc0IsVUFBVXh0QixTQUFTLENBQUM2dEIsS0FBSyxHQUFHLFNBQVNBO1FBQ25DLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEVBQUU7SUFDbEI7SUFFQTs7R0FFQyxHQUNERixVQUFVeHRCLFNBQVMsQ0FBQytzQixNQUFNLEdBQUcsU0FBU0EsT0FBUWpwQixDQUFDO1FBQzdDLElBQUl3VyxTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSXRELEVBQUV1bkIsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1lBQ3ZDalIsT0FBT3JPLEdBQUcsQ0FBQzdFLEVBQUVzZ0IsSUFBSTtRQUNuQjtRQUNBLE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0Q4RixVQUFVeHRCLFNBQVMsQ0FBQ3N0QixHQUFHLEdBQUcsU0FBU0EsSUFBS2psQixLQUFLLEVBQUV5bEIsT0FBTztRQUNwRCxJQUFJQyxhQUFhLElBQUksQ0FBQ0wsTUFBTSxDQUFDcmxCLE1BQU07UUFDbkMsSUFBSSxDQUFDcWxCLE1BQU0sQ0FBQ3JsQixNQUFNLEdBQUd5bEI7UUFDckIsT0FBT0M7SUFDVDtJQUVBOztHQUVDLEdBQ0RQLFVBQVV4dEIsU0FBUyxDQUFDcXJCLFFBQVEsR0FBRyxTQUFTQTtRQUN0QyxPQUFPLElBQUkyQyxVQUFVLElBQUk7SUFDM0I7SUFFQTs7R0FFQyxHQUNEUixVQUFVeHRCLFNBQVMsQ0FBQ29ELEdBQUcsR0FBRyxTQUFTQSxJQUFLaUYsS0FBSztRQUMzQyxJQUFJQSxRQUFRLEtBQUtBLFNBQVMsSUFBSSxDQUFDc0wsSUFBSSxJQUFJO1lBQ3JDLE1BQU0sSUFBSXVaO1FBQ1o7UUFFQSxPQUFPLElBQUksQ0FBQ1EsTUFBTSxDQUFDcmxCLE1BQU07SUFDM0I7SUFFQTs7R0FFQyxHQUNEbWxCLFVBQVV4dEIsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBO1FBQ3JDLE9BQU8sSUFBSSxDQUFDNFQsTUFBTSxDQUFDanRCLE1BQU0sS0FBSztJQUNoQztJQUVBOztHQUVDLEdBQ0Qrc0IsVUFBVXh0QixTQUFTLENBQUMyVCxJQUFJLEdBQUcsU0FBU0E7UUFDbEMsT0FBTyxJQUFJLENBQUMrWixNQUFNLENBQUNqdEIsTUFBTTtJQUMzQjtJQUVBOztHQUVDLEdBQ0Qrc0IsVUFBVXh0QixTQUFTLENBQUNndEIsT0FBTyxHQUFHLFNBQVNBO1FBQ3JDLElBQUkxUyxTQUFTLElBQUk7UUFFakIsSUFBSUMsUUFBUSxFQUFFO1FBRWQsSUFBSyxJQUFJblQsSUFBSSxHQUFHOEosTUFBTSxJQUFJLENBQUN3YyxNQUFNLENBQUNqdEIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUs5SixJQUFLO1lBQ3REbVQsTUFBTUUsSUFBSSxDQUFDSCxPQUFPb1QsTUFBTSxDQUFDdG1CLEVBQUU7UUFDN0I7UUFFQSxPQUFPbVQ7SUFDVDtJQUVBOztHQUVDLEdBQ0RpVCxVQUFVeHRCLFNBQVMsQ0FBQ2l0QixNQUFNLEdBQUcsU0FBU0EsT0FBUW5vQixDQUFDO1FBQzdDLElBQUl3VixTQUFTLElBQUk7UUFFakIsSUFBSTJULFFBQVE7UUFFWixJQUFLLElBQUk3bUIsSUFBSSxHQUFHOEosTUFBTSxJQUFJLENBQUN3YyxNQUFNLENBQUNqdEIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUs5SixJQUFLO1lBQ3RELElBQUlrVCxPQUFPb1QsTUFBTSxDQUFDdG1CLEVBQUUsS0FBS3RDLEdBQUc7Z0JBQzFCd1YsT0FBT29ULE1BQU0sQ0FBQ0UsTUFBTSxDQUFDeG1CLEdBQUc7Z0JBQ3hCNm1CLFFBQVE7Z0JBQ1I7WUFDRjtRQUNGO1FBRUEsT0FBT0E7SUFDVDtJQUVBLE9BQU9UO0FBQ1QsRUFBRUo7QUFFRjs7Ozs7Q0FLQyxHQUNELElBQUlZLFlBQWEsU0FBVUUsV0FBVztJQUNwQyxTQUFTRixVQUFXRyxTQUFTO1FBQzNCRCxZQUFZM3JCLElBQUksQ0FBQyxJQUFJO1FBQ3JCOzs7SUFHQSxHQUNBLElBQUksQ0FBQzZyQixVQUFVLEdBQUdEO1FBQ2xCOzs7SUFHQSxHQUNBLElBQUksQ0FBQ0UsU0FBUyxHQUFHO0lBQ25CO0lBRUEsSUFBS0gsYUFBY0YsVUFBVXRyQixTQUFTLEdBQUd3ckI7SUFDekNGLFVBQVVodUIsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFdXJCLGVBQWVBLFlBQVlsdUIsU0FBUztJQUN6RWd1QixVQUFVaHVCLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR29yQjtJQUVsQzs7R0FFQyxHQUNEQSxVQUFVaHVCLFNBQVMsQ0FBQzBuQixJQUFJLEdBQUcsU0FBU0E7UUFDbEMsSUFBSSxJQUFJLENBQUMyRyxTQUFTLEtBQUssSUFBSSxDQUFDRCxVQUFVLENBQUN6YSxJQUFJLElBQUk7WUFDN0MsTUFBTSxJQUFJNFo7UUFDWjtRQUNBLE9BQU8sSUFBSSxDQUFDYSxVQUFVLENBQUNockIsR0FBRyxDQUFDLElBQUksQ0FBQ2lyQixTQUFTO0lBQzNDO0lBRUE7O0dBRUMsR0FDREwsVUFBVWh1QixTQUFTLENBQUN1ckIsT0FBTyxHQUFHLFNBQVNBO1FBQ3JDLElBQUksSUFBSSxDQUFDOEMsU0FBUyxHQUFHLElBQUksQ0FBQ0QsVUFBVSxDQUFDemEsSUFBSSxJQUFJO1lBQzNDLE9BQU87UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRHFhLFVBQVVodUIsU0FBUyxDQUFDc3RCLEdBQUcsR0FBRyxTQUFTQSxJQUFLUSxPQUFPO1FBQzdDLE9BQU8sSUFBSSxDQUFDTSxVQUFVLENBQUNkLEdBQUcsQ0FBQyxJQUFJLENBQUNlLFNBQVMsR0FBRyxHQUFHUDtJQUNqRDtJQUVBOztHQUVDLEdBQ0RFLFVBQVVodUIsU0FBUyxDQUFDaXRCLE1BQU0sR0FBRyxTQUFTQTtRQUNwQyxJQUFJLENBQUNtQixVQUFVLENBQUNuQixNQUFNLENBQUMsSUFBSSxDQUFDbUIsVUFBVSxDQUFDaHJCLEdBQUcsQ0FBQyxJQUFJLENBQUNpckIsU0FBUztJQUMzRDtJQUVBLE9BQU9MO0FBQ1QsRUFBRWI7QUFFRixJQUFJbUIsaUJBQWtCLFNBQVVDLFlBQVk7SUFDMUMsU0FBU0Q7UUFDUEMsYUFBYWhzQixJQUFJLENBQUMsSUFBSTtRQUN0QixJQUFJekIsVUFBVUwsTUFBTSxLQUFLLEdBQUcsQ0FDNUIsT0FBTyxJQUFJSyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJdXJCLFFBQVFsckIsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSSxDQUFDNnNCLGNBQWMsQ0FBQzNCLE1BQU12ckIsTUFBTTtZQUNoQyxJQUFJLENBQUN3TCxHQUFHLENBQUMrZixPQUFPO1FBQ2xCLE9BQU8sSUFBSWxyQixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJK3RCLFVBQVUxdEIsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSTJ0QixnQkFBZ0IzdEIsU0FBUyxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDNnNCLGNBQWMsQ0FBQ2EsUUFBUS90QixNQUFNO1lBQ2xDLElBQUksQ0FBQ3dMLEdBQUcsQ0FBQ3VpQixTQUFTQztRQUNwQjtJQUNGO0lBRUEsSUFBS0YsY0FBZUQsZUFBZTVyQixTQUFTLEdBQUc2ckI7SUFDL0NELGVBQWV0dUIsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFNHJCLGdCQUFnQkEsYUFBYXZ1QixTQUFTO0lBQ2hGc3VCLGVBQWV0dUIsU0FBUyxDQUFDNEMsV0FBVyxHQUFHMHJCO0lBRXZDLElBQUl2cUIsa0JBQWtCO1FBQUUycUIsZ0JBQWdCO1lBQUV2dUIsY0FBYztRQUFLO0lBQUU7SUFDL0Q0RCxnQkFBZ0IycUIsY0FBYyxDQUFDdHJCLEdBQUcsR0FBRztRQUFjLE9BQU8sSUFBSXJELE1BQU0sR0FBR00sSUFBSSxDQUFDO0lBQU07SUFDbEZpdUIsZUFBZXR1QixTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0EsY0FBZXhNLENBQUM7UUFDaEUsT0FBTyxJQUFJLENBQUNoRSxHQUFHLENBQUNnRTtJQUNsQjtJQUNBa25CLGVBQWV0dUIsU0FBUyxDQUFDK3NCLE1BQU0sR0FBRyxTQUFTQTtRQUN6QyxJQUFJelMsU0FBUyxJQUFJO1FBRWpCLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJa3VCLE9BQU83dEIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSTJ0QixnQkFBZ0IzdEIsU0FBUyxDQUFDLEVBQUU7WUFDaEMsSUFBSTh0QixZQUFZO1lBQ2hCLElBQUssSUFBSXhuQixJQUFJdW5CLEtBQUt0RCxRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7Z0JBQzFDalIsT0FBT3JPLEdBQUcsQ0FBQzdFLEVBQUVzZ0IsSUFBSSxJQUFJK0c7Z0JBQ3JCRyxZQUFZO1lBQ2Q7WUFDQSxPQUFPQTtRQUNULE9BQU87WUFBRSxPQUFPTCxhQUFhdnVCLFNBQVMsQ0FBQytzQixNQUFNLENBQUN4VCxLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUN2RTtJQUNBd3RCLGVBQWV0dUIsU0FBUyxDQUFDK0UsS0FBSyxHQUFHLFNBQVNBO1FBQ3hDLElBQUl1VixTQUFTLElBQUk7UUFFakIsSUFBSXZWLFFBQVF3cEIsYUFBYXZ1QixTQUFTLENBQUMrRSxLQUFLLENBQUN4QyxJQUFJLENBQUMsSUFBSTtRQUNsRCxJQUFLLElBQUk2RSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdU0sSUFBSSxJQUFJdk0sSUFBSztZQUNwQ3JDLE1BQU1rSCxHQUFHLENBQUM3RSxHQUFHa1QsT0FBT2xYLEdBQUcsQ0FBQ2dFLEdBQUdwQyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDVDtJQUNBdXBCLGVBQWV0dUIsU0FBUyxDQUFDbVUsaUJBQWlCLEdBQUcsU0FBU0E7UUFDcEQsT0FBTyxJQUFJLENBQUM2WSxPQUFPLENBQUNzQixlQUFlSSxjQUFjO0lBQ25EO0lBQ0FKLGVBQWV0dUIsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBO1FBQ3RDLElBQUlxTyxTQUFTLElBQUk7UUFFakIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUl1ckIsUUFBUWxyQixTQUFTLENBQUMsRUFBRTtZQUN4Qnl0QixhQUFhdnVCLFNBQVMsQ0FBQ2lNLEdBQUcsQ0FBQzFKLElBQUksQ0FBQyxJQUFJLEVBQUV5cEI7UUFDeEMsT0FBTyxJQUFJbHJCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVlmLFNBQVMsT0FBT2UsU0FBUyxDQUFDLEVBQUUsS0FBSyxXQUFXO2dCQUN0RSxJQUFJMHRCLFVBQVUxdEIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUkydEIsZ0JBQWdCM3RCLFNBQVMsQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLENBQUNtTCxHQUFHLENBQUN1aUIsU0FBU0MsZUFBZTtnQkFDakMsT0FBTztZQUNULE9BQU8sSUFBSTN0QixTQUFTLENBQUMsRUFBRSxZQUFZNEMsY0FBYyxPQUFPNUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxXQUFXO2dCQUNsRixJQUFJK3RCLFVBQVUvdEIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUlndUIsa0JBQWtCaHVCLFNBQVMsQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLENBQUNndUIsaUJBQWlCO29CQUNwQixJQUFJLElBQUksQ0FBQ25iLElBQUksTUFBTSxHQUFHO3dCQUNwQixJQUFJb2IsT0FBTyxJQUFJLENBQUMzckIsR0FBRyxDQUFDLElBQUksQ0FBQ3VRLElBQUksS0FBSzt3QkFDbEMsSUFBSW9iLEtBQUt4cUIsUUFBUSxDQUFDc3FCLFVBQVU7NEJBQUUsT0FBTzt3QkFBSztvQkFDNUM7Z0JBQ0Y7Z0JBQ0FOLGFBQWF2dUIsU0FBUyxDQUFDaU0sR0FBRyxDQUFDMUosSUFBSSxDQUFDLElBQUksRUFBRXNzQjtZQUN4QyxPQUFPLElBQUkvdEIsU0FBUyxDQUFDLEVBQUUsWUFBWWIsVUFBVSxPQUFPYSxTQUFTLENBQUMsRUFBRSxLQUFLLFdBQVc7Z0JBQzlFLElBQUlrdUIsTUFBTWx1QixTQUFTLENBQUMsRUFBRTtnQkFDdEIsSUFBSW11QixrQkFBa0JudUIsU0FBUyxDQUFDLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQ21MLEdBQUcsQ0FBQytpQixLQUFLQztnQkFDZCxPQUFPO1lBQ1Q7UUFDRixPQUFPLElBQUludUIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSSxPQUFPSyxTQUFTLENBQUMsRUFBRSxLQUFLLGFBQWNBLFNBQVMsQ0FBQyxFQUFFLFlBQVlmLFNBQVMsT0FBT2UsU0FBUyxDQUFDLEVBQUUsS0FBSyxXQUFZO2dCQUM3RyxJQUFJb3VCLFVBQVVwdUIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUlxdUIsa0JBQWtCcnVCLFNBQVMsQ0FBQyxFQUFFO2dCQUNsQyxJQUFJc3VCLFlBQVl0dUIsU0FBUyxDQUFDLEVBQUU7Z0JBQzVCLElBQUlzdUIsV0FBVztvQkFDYixJQUFLLElBQUl4SixNQUFNLEdBQUdBLE1BQU1zSixRQUFRenVCLE1BQU0sRUFBRW1sQixNQUFPO3dCQUM3Q3RMLE9BQU9yTyxHQUFHLENBQUNpakIsT0FBTyxDQUFDdEosSUFBSSxFQUFFdUo7b0JBQzNCO2dCQUNGLE9BQU87b0JBQ0wsSUFBSyxJQUFJRSxNQUFNSCxRQUFRenVCLE1BQU0sR0FBRyxHQUFHNHVCLE9BQU8sR0FBR0EsTUFBTzt3QkFDbEQvVSxPQUFPck8sR0FBRyxDQUFDaWpCLE9BQU8sQ0FBQ0csSUFBSSxFQUFFRjtvQkFDM0I7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNULE9BQU8sSUFBSSxPQUFPcnVCLFNBQVMsQ0FBQyxFQUFFLEtBQUssYUFBY0UsT0FBT0ksU0FBUyxDQUFDTixTQUFTLENBQUMsRUFBRSxLQUFLQSxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBYTtnQkFDdEgsSUFBSTRyQixNQUFNeHVCLFNBQVMsQ0FBQyxFQUFFO2dCQUN0QixJQUFJeXVCLFVBQVV6dUIsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUkwdUIsa0JBQWtCMXVCLFNBQVMsQ0FBQyxFQUFFO2dCQUNsQyxJQUFJLENBQUMwdUIsaUJBQWlCO29CQUNwQixJQUFJN2IsT0FBTyxJQUFJLENBQUNBLElBQUk7b0JBQ3BCLElBQUlBLE9BQU8sR0FBRzt3QkFDWixJQUFJMmIsTUFBTSxHQUFHOzRCQUNYLElBQUk3SCxPQUFPLElBQUksQ0FBQ3JrQixHQUFHLENBQUNrc0IsTUFBTTs0QkFDMUIsSUFBSTdILEtBQUtsakIsUUFBUSxDQUFDZ3JCLFVBQVU7Z0NBQUUsT0FBTzs0QkFBSzt3QkFDNUM7d0JBQ0EsSUFBSUQsTUFBTTNiLE1BQU07NEJBQ2QsSUFBSStULE9BQU8sSUFBSSxDQUFDdGtCLEdBQUcsQ0FBQ2tzQjs0QkFDcEIsSUFBSTVILEtBQUtuakIsUUFBUSxDQUFDZ3JCLFVBQVU7Z0NBQUUsT0FBTzs0QkFBSzt3QkFDNUM7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FoQixhQUFhdnVCLFNBQVMsQ0FBQ2lNLEdBQUcsQ0FBQzFKLElBQUksQ0FBQyxJQUFJLEVBQUUrc0IsS0FBS0M7WUFDN0M7UUFDRixPQUFPLElBQUl6dUIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSWd2QixVQUFVM3VCLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLElBQUk0dUIsa0JBQWtCNXVCLFNBQVMsQ0FBQyxFQUFFO1lBQ2xDLElBQUk2dUIsUUFBUTd1QixTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJOHVCLE1BQU05dUIsU0FBUyxDQUFDLEVBQUU7WUFDdEIsSUFBSSt1QixNQUFNO1lBQ1YsSUFBSUYsUUFBUUMsS0FBSztnQkFBRUMsTUFBTSxDQUFDO1lBQUc7WUFDN0IsSUFBSyxJQUFJem9CLElBQUl1b0IsT0FBT3ZvQixNQUFNd29CLEtBQUt4b0IsS0FBS3lvQixJQUFLO2dCQUN2Q3ZWLE9BQU9yTyxHQUFHLENBQUN3akIsT0FBTyxDQUFDcm9CLEVBQUUsRUFBRXNvQjtZQUN6QjtZQUNBLE9BQU87UUFDVDtJQUNGO0lBQ0FwQixlQUFldHVCLFNBQVMsQ0FBQzh2QixTQUFTLEdBQUcsU0FBU0E7UUFDNUMsSUFBSSxJQUFJLENBQUNuYyxJQUFJLEtBQUssR0FBRztZQUFFLElBQUksQ0FBQzFILEdBQUcsQ0FBQyxJQUFJdkksV0FBVyxJQUFJLENBQUNOLEdBQUcsQ0FBQyxLQUFLO1FBQVE7SUFDdkU7SUFDQWtyQixlQUFldHVCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUM5QyxPQUFPLEVBQUU7SUFDWDtJQUNBeXNCLGVBQWV0dUIsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQzNDLE9BQU93c0I7SUFDVDtJQUVBcnVCLE9BQU9vRCxnQkFBZ0IsQ0FBRWlyQixnQkFBZ0J2cUI7SUFFekMsT0FBT3VxQjtBQUNULEVBQUVkO0FBRUYsSUFBSXVDLG1CQUFtQixTQUFTQSxvQkFBcUI7QUFFckQsSUFBSUMscUJBQXFCO0lBQUVDLG1CQUFtQjtRQUFFOXZCLGNBQWM7SUFBSztJQUFFK3ZCLHlCQUF5QjtRQUFFL3ZCLGNBQWM7SUFBSztJQUFFdXVCLGdCQUFnQjtRQUFFdnVCLGNBQWM7SUFBSztBQUFFO0FBRTVKNnZCLG1CQUFtQkMsaUJBQWlCLENBQUM3c0IsR0FBRyxHQUFHO0lBQWMsT0FBTzZzQjtBQUFrQjtBQUNsRkQsbUJBQW1CRSx1QkFBdUIsQ0FBQzlzQixHQUFHLEdBQUc7SUFBYyxPQUFPOHNCO0FBQXdCO0FBQzlGRixtQkFBbUJ0QixjQUFjLENBQUN0ckIsR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJckQsTUFBTSxHQUFHTSxJQUFJLENBQUM7QUFBTTtBQUVyRjB2QixpQkFBaUIvdkIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2hELE9BQU8sRUFBRTtBQUNYO0FBQ0FrdUIsaUJBQWlCL3ZCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM3QyxPQUFPaXVCO0FBQ1Q7QUFDQUEsaUJBQWlCSSxNQUFNLEdBQUcsU0FBU0EsT0FBUWxKLEdBQUc7SUFDNUMsSUFBSUEsSUFBSXhtQixNQUFNLEdBQUcsR0FBRztRQUFFLE9BQU87SUFBTTtJQUNuQyxJQUFJLENBQUN3bUIsR0FBRyxDQUFDLEVBQUUsQ0FBQzFpQixRQUFRLENBQUMwaUIsR0FBRyxDQUFDQSxJQUFJeG1CLE1BQU0sR0FBRyxFQUFFLEdBQUc7UUFBRSxPQUFPO0lBQU07SUFDMUQsT0FBTztBQUNUO0FBQ0FzdkIsaUJBQWlCSyxXQUFXLEdBQUcsU0FBU0EsWUFBYUMsT0FBTyxFQUFFcEosR0FBRztJQUMvRCxJQUFLLElBQUk3ZixJQUFJLEdBQUdBLElBQUlpcEIsUUFBUTV2QixNQUFNLEVBQUUyRyxJQUFLO1FBQ3ZDLElBQUlrcEIsU0FBU0QsT0FBTyxDQUFDanBCLEVBQUU7UUFDdkIsSUFBSTJvQixpQkFBaUIxb0IsT0FBTyxDQUFDaXBCLFFBQVFySixPQUFPLEdBQUc7WUFBRSxPQUFPcUo7UUFBTztJQUNqRTtJQUNBLE9BQU87QUFDVDtBQUNBUCxpQkFBaUJRLE1BQU0sR0FBRyxTQUFTQSxPQUFRQyxXQUFXLEVBQUVDLGVBQWU7SUFDckUsSUFBSXJwQixJQUFJMm9CLGlCQUFpQjFvQixPQUFPLENBQUNvcEIsaUJBQWlCRDtJQUNsRCxJQUFJcHBCLElBQUksR0FBRztRQUFFLE9BQU87SUFBSztJQUN6QixJQUFJc3BCLGlCQUFpQixJQUFJM3dCLE1BQU15d0IsWUFBWS92QixNQUFNLEVBQUVKLElBQUksQ0FBQztJQUN4RGtVLE9BQU9DLFNBQVMsQ0FBQ2djLGFBQWFwcEIsR0FBR3NwQixnQkFBZ0IsR0FBR0YsWUFBWS92QixNQUFNLEdBQUcyRztJQUN6RW1OLE9BQU9DLFNBQVMsQ0FBQ2djLGFBQWEsR0FBR0UsZ0JBQWdCRixZQUFZL3ZCLE1BQU0sR0FBRzJHLEdBQUdBO0lBQ3pFbU4sT0FBT0MsU0FBUyxDQUFDa2MsZ0JBQWdCLEdBQUdGLGFBQWEsR0FBR0EsWUFBWS92QixNQUFNO0FBQ3hFO0FBQ0FzdkIsaUJBQWlCcHJCLE1BQU0sR0FBRyxTQUFTQTtJQUNqQyxJQUFJN0QsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSWt3QixTQUFTN3ZCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUk4dkIsU0FBUzl2QixTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJNnZCLFdBQVdDLFFBQVE7WUFBRSxPQUFPO1FBQUs7UUFDckMsSUFBSUQsV0FBVyxRQUFRQyxXQUFXLE1BQU07WUFBRSxPQUFPO1FBQU07UUFDdkQsSUFBSUQsT0FBT2x3QixNQUFNLEtBQUttd0IsT0FBT253QixNQUFNLEVBQUU7WUFBRSxPQUFPO1FBQU07UUFDcEQsSUFBSyxJQUFJMkcsSUFBSSxHQUFHQSxJQUFJdXBCLE9BQU9sd0IsTUFBTSxFQUFFMkcsSUFBSztZQUN0QyxJQUFJLENBQUN1cEIsTUFBTSxDQUFDdnBCLEVBQUUsQ0FBQ3pDLE1BQU0sQ0FBQ2lzQixNQUFNLENBQUN4cEIsRUFBRSxHQUFHO2dCQUFFLE9BQU87WUFBTTtRQUNuRDtRQUNBLE9BQU87SUFDVCxPQUFPLElBQUl0RyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJb3dCLFdBQVcvdkIsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSWd3QixXQUFXaHdCLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUlpd0IsdUJBQXVCandCLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZDLElBQUkrdkIsYUFBYUMsVUFBVTtZQUFFLE9BQU87UUFBSztRQUN6QyxJQUFJRCxhQUFhLFFBQVFDLGFBQWEsTUFBTTtZQUFFLE9BQU87UUFBTTtRQUMzRCxJQUFJRCxTQUFTcHdCLE1BQU0sS0FBS3F3QixTQUFTcndCLE1BQU0sRUFBRTtZQUFFLE9BQU87UUFBTTtRQUN4RCxJQUFLLElBQUltbEIsTUFBTSxHQUFHQSxNQUFNaUwsU0FBU3B3QixNQUFNLEVBQUVtbEIsTUFBTztZQUM5QyxJQUFJbUwscUJBQXFCL3FCLE9BQU8sQ0FBQzZxQixRQUFRLENBQUNqTCxJQUFJLEVBQUVrTCxRQUFRLENBQUNsTCxJQUFJLE1BQU0sR0FBRztnQkFBRSxPQUFPO1lBQU07UUFDdkY7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBbUssaUJBQWlCNWQsWUFBWSxHQUFHLFNBQVNBLGFBQWNxZSxXQUFXLEVBQUV2YyxHQUFHO0lBQ3JFLElBQUkrYyxZQUFZLElBQUkxQztJQUNwQixJQUFLLElBQUlsbkIsSUFBSSxHQUFHQSxJQUFJb3BCLFlBQVkvdkIsTUFBTSxFQUFFMkcsSUFBSztRQUMzQyxJQUFJNk0sSUFBSWdELFVBQVUsQ0FBQ3VaLFdBQVcsQ0FBQ3BwQixFQUFFLEdBQUc7WUFBRTRwQixVQUFVL2tCLEdBQUcsQ0FBQ3VrQixXQUFXLENBQUNwcEIsRUFBRSxFQUFFO1FBQU87SUFDN0U7SUFDQSxPQUFPNHBCLFVBQVU3YyxpQkFBaUI7QUFDcEM7QUFDQTRiLGlCQUFpQmtCLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQmpGLEtBQUs7SUFDcEUsSUFBSyxJQUFJNWtCLElBQUksR0FBR0EsSUFBSTRrQixNQUFNdnJCLE1BQU0sRUFBRTJHLElBQUs7UUFDckMsSUFBSTRrQixLQUFLLENBQUM1a0IsSUFBSSxFQUFFLENBQUN6QyxNQUFNLENBQUNxbkIsS0FBSyxDQUFDNWtCLEVBQUUsR0FBRztZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBMm9CLGlCQUFpQm1CLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQmxGLEtBQUs7SUFDMUUsSUFBSSxDQUFDK0QsaUJBQWlCa0IsaUJBQWlCLENBQUNqRixRQUFRO1FBQUUsT0FBT0E7SUFBTTtJQUMvRCxJQUFJZ0YsWUFBWSxJQUFJMUMsZUFBZXRDLE9BQU87SUFDMUMsT0FBT2dGLFVBQVU3YyxpQkFBaUI7QUFDcEM7QUFDQTRiLGlCQUFpQm9CLE9BQU8sR0FBRyxTQUFTQSxRQUFTbkYsS0FBSztJQUNoRCxJQUFJK0MsT0FBTy9DLE1BQU12ckIsTUFBTSxHQUFHO0lBQzFCLElBQUkyd0IsTUFBTTF3QixLQUFLZSxLQUFLLENBQUNzdEIsT0FBTztJQUM1QixJQUFLLElBQUkzbkIsSUFBSSxHQUFHQSxLQUFLZ3FCLEtBQUtocUIsSUFBSztRQUM3QixJQUFJaXFCLE1BQU1yRixLQUFLLENBQUM1a0IsRUFBRTtRQUNsQjRrQixLQUFLLENBQUM1a0IsRUFBRSxHQUFHNGtCLEtBQUssQ0FBQytDLE9BQU8zbkIsRUFBRTtRQUMxQjRrQixLQUFLLENBQUMrQyxPQUFPM25CLEVBQUUsR0FBR2lxQjtJQUNwQjtBQUNGO0FBQ0F0QixpQkFBaUJ1QixVQUFVLEdBQUcsU0FBU0EsV0FBWXRGLEtBQUs7SUFDdEQsSUFBSXVGLFVBQVU7SUFDZCxJQUFLLElBQUlucUIsSUFBSSxHQUFHQSxJQUFJNGtCLE1BQU12ckIsTUFBTSxFQUFFMkcsSUFBSztRQUNyQyxJQUFJNGtCLEtBQUssQ0FBQzVrQixFQUFFLEtBQUssTUFBTTtZQUFFbXFCO1FBQVc7SUFDdEM7SUFDQSxJQUFJQyxXQUFXLElBQUl6eEIsTUFBTXd4QixTQUFTbHhCLElBQUksQ0FBQztJQUN2QyxJQUFJa3hCLFlBQVksR0FBRztRQUFFLE9BQU9DO0lBQVM7SUFDckMsSUFBSWxHLElBQUk7SUFDUixJQUFLLElBQUkxRixNQUFNLEdBQUdBLE1BQU1vRyxNQUFNdnJCLE1BQU0sRUFBRW1sQixNQUFPO1FBQzNDLElBQUlvRyxLQUFLLENBQUNwRyxJQUFJLEtBQUssTUFBTTtZQUFFNEwsUUFBUSxDQUFDbEcsSUFBSSxHQUFHVSxLQUFLLENBQUNwRyxJQUFJO1FBQUU7SUFDekQ7SUFDQSxPQUFPNEw7QUFDVDtBQUNBekIsaUJBQWlCMEIsUUFBUSxHQUFHLFNBQVNBO0lBQ25DLElBQUkzd0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSt2QixjQUFjMXZCLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUlrRSxPQUFPLElBQUlqRixNQUFNeXdCLFlBQVkvdkIsTUFBTSxFQUFFSixJQUFJLENBQUM7UUFDOUMsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJb3BCLFlBQVkvdkIsTUFBTSxFQUFFMkcsSUFBSztZQUMzQ3BDLElBQUksQ0FBQ29DLEVBQUUsR0FBRyxJQUFJMUQsV0FBVzhzQixXQUFXLENBQUNwcEIsRUFBRTtRQUN6QztRQUNBLE9BQU9wQztJQUNULE9BQU8sSUFBSWxFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlnVSxNQUFNM1QsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTR3QixXQUFXNXdCLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUk2VCxPQUFPN1QsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTZ3QixZQUFZN3dCLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUlMLFNBQVNLLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUssSUFBSThrQixNQUFNLEdBQUdBLE1BQU1ubEIsUUFBUW1sQixNQUFPO1lBQ3JDalIsSUFBSSxDQUFDZ2QsWUFBWS9MLElBQUksR0FBRyxJQUFJbGlCLFdBQVcrUSxHQUFHLENBQUNpZCxXQUFXOUwsSUFBSTtRQUM1RDtJQUNGO0FBQ0Y7QUFDQW1LLGlCQUFpQjZCLGVBQWUsR0FBRyxTQUFTQSxnQkFBaUJDLElBQUksRUFBRUMsSUFBSTtJQUNyRSxJQUFLLElBQUkxcUIsSUFBSSxHQUFHQSxJQUFJeXFCLEtBQUtweEIsTUFBTSxFQUFFMkcsSUFBSztRQUNwQyxJQUFJbUssS0FBS3NnQixJQUFJLENBQUN6cUIsRUFBRTtRQUNoQixJQUFJb0ssS0FBS3NnQixJQUFJLENBQUNELEtBQUtweEIsTUFBTSxHQUFHMkcsSUFBSSxFQUFFO1FBQ2xDLElBQUltSyxHQUFHMU0sU0FBUyxDQUFDMk0sUUFBUSxHQUFHO1lBQUUsT0FBTztRQUFNO0lBQzdDO0lBQ0EsT0FBTztBQUNUO0FBQ0F1ZSxpQkFBaUJnQyxRQUFRLEdBQUcsU0FBU0EsU0FBVXZCLFdBQVc7SUFDeEQsSUFBSXZjLE1BQU0sSUFBSWlDO0lBQ2QsSUFBSyxJQUFJOU8sSUFBSSxHQUFHQSxJQUFJb3BCLFlBQVkvdkIsTUFBTSxFQUFFMkcsSUFBSztRQUMzQzZNLElBQUlzRCxlQUFlLENBQUNpWixXQUFXLENBQUNwcEIsRUFBRTtJQUNwQztJQUNBLE9BQU82TTtBQUNUO0FBQ0E4YixpQkFBaUI1YixpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUI2YyxTQUFTO0lBQ3hFLE9BQU9BLFVBQVVoRSxPQUFPLENBQUMrQyxpQkFBaUJyQixjQUFjO0FBQzFEO0FBQ0FxQixpQkFBaUJpQyw0QkFBNEIsR0FBRyxTQUFTQSw2QkFBOEJodkIsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGLE9BQU9BLEVBQUVyRCxNQUFNLElBQUl1QyxJQUFJYyxJQUFJLEVBQUU7QUFDL0I7QUFDQWlzQixpQkFBaUIxb0IsT0FBTyxHQUFHLFNBQVNBLFFBQVMwUyxVQUFVLEVBQUV5VyxXQUFXO0lBQ2xFLElBQUssSUFBSXBwQixJQUFJLEdBQUdBLElBQUlvcEIsWUFBWS92QixNQUFNLEVBQUUyRyxJQUFLO1FBQzNDLElBQUkyUyxXQUFXcFYsTUFBTSxDQUFDNnJCLFdBQVcsQ0FBQ3BwQixFQUFFLEdBQUc7WUFDckMsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBTyxDQUFDO0FBQ1Y7QUFDQTJvQixpQkFBaUJrQyxtQkFBbUIsR0FBRyxTQUFTQSxvQkFBcUJoTCxHQUFHO0lBQ3RFLElBQUssSUFBSTdmLElBQUksR0FBR0EsSUFBSTFHLEtBQUtlLEtBQUssQ0FBQ3dsQixJQUFJeG1CLE1BQU0sR0FBRyxJQUFJMkcsSUFBSztRQUNuRCxJQUFJa2tCLElBQUlyRSxJQUFJeG1CLE1BQU0sR0FBRyxJQUFJMkc7UUFDekIsSUFBSW1qQixPQUFPdEQsR0FBRyxDQUFDN2YsRUFBRSxDQUFDdkMsU0FBUyxDQUFDb2lCLEdBQUcsQ0FBQ3FFLEVBQUU7UUFDbEMsSUFBSWYsU0FBUyxHQUFHO1lBQUUsT0FBT0E7UUFBSztJQUNoQztJQUNBLE9BQU87QUFDVDtBQUNBd0YsaUJBQWlCL3BCLE9BQU8sR0FBRyxTQUFTQSxRQUFTNnJCLElBQUksRUFBRUMsSUFBSTtJQUNyRCxJQUFJMXFCLElBQUk7SUFDUixNQUFPQSxJQUFJeXFCLEtBQUtweEIsTUFBTSxJQUFJMkcsSUFBSTBxQixLQUFLcnhCLE1BQU0sQ0FBRTtRQUN6QyxJQUFJdUYsVUFBVTZyQixJQUFJLENBQUN6cUIsRUFBRSxDQUFDdkMsU0FBUyxDQUFDaXRCLElBQUksQ0FBQzFxQixFQUFFO1FBQ3ZDLElBQUlwQixZQUFZLEdBQUc7WUFBRSxPQUFPQTtRQUFRO1FBQ3BDb0I7SUFDRjtJQUNBLElBQUlBLElBQUkwcUIsS0FBS3J4QixNQUFNLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUNqQyxJQUFJMkcsSUFBSXlxQixLQUFLcHhCLE1BQU0sRUFBRTtRQUFFLE9BQU87SUFBRTtJQUNoQyxPQUFPO0FBQ1Q7QUFDQXN2QixpQkFBaUJtQyxhQUFhLEdBQUcsU0FBU0EsY0FBZTFCLFdBQVc7SUFDbEUsSUFBSTJCLFdBQVc7SUFDZixJQUFLLElBQUkvcUIsSUFBSSxHQUFHQSxJQUFJb3BCLFlBQVkvdkIsTUFBTSxFQUFFMkcsSUFBSztRQUMzQyxJQUFJK3FCLGFBQWEsUUFBUUEsU0FBU3R0QixTQUFTLENBQUMyckIsV0FBVyxDQUFDcHBCLEVBQUUsSUFBSSxHQUFHO1lBQy9EK3FCLFdBQVczQixXQUFXLENBQUNwcEIsRUFBRTtRQUMzQjtJQUNGO0lBQ0EsT0FBTytxQjtBQUNUO0FBQ0FwQyxpQkFBaUJxQyxPQUFPLEdBQUcsU0FBU0EsUUFBU25MLEdBQUcsRUFBRTBJLEtBQUssRUFBRUMsR0FBRztJQUMxREQsUUFBUXJvQixTQUFTVSxLQUFLLENBQUMybkIsT0FBTyxHQUFHMUksSUFBSXhtQixNQUFNO0lBQzNDbXZCLE1BQU10b0IsU0FBU1UsS0FBSyxDQUFDNG5CLEtBQUssQ0FBQyxHQUFHM0ksSUFBSXhtQixNQUFNO0lBQ3hDLElBQUk0eEIsT0FBT3pDLE1BQU1ELFFBQVE7SUFDekIsSUFBSUMsTUFBTSxHQUFHO1FBQUV5QyxPQUFPO0lBQUc7SUFDekIsSUFBSTFDLFNBQVMxSSxJQUFJeG1CLE1BQU0sRUFBRTtRQUFFNHhCLE9BQU87SUFBRztJQUNyQyxJQUFJekMsTUFBTUQsT0FBTztRQUFFMEMsT0FBTztJQUFHO0lBQzdCLElBQUlDLGFBQWEsSUFBSXZ5QixNQUFNc3lCLE1BQU1oeUIsSUFBSSxDQUFDO0lBQ3RDLElBQUlneUIsU0FBUyxHQUFHO1FBQUUsT0FBT0M7SUFBVztJQUNwQyxJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJbnJCLElBQUl1b0IsT0FBT3ZvQixLQUFLd29CLEtBQUt4b0IsSUFBSztRQUNqQ2tyQixVQUFVLENBQUNDLE9BQU8sR0FBR3RMLEdBQUcsQ0FBQzdmLEVBQUU7SUFDN0I7SUFDQSxPQUFPa3JCO0FBQ1Q7QUFFQXJ5QixPQUFPb0QsZ0JBQWdCLENBQUUwc0Isa0JBQWtCQztBQUUzQyxJQUFJQyxvQkFBb0IsU0FBU0EscUJBQXNCO0FBRXZEQSxrQkFBa0Jqd0IsU0FBUyxDQUFDZ0csT0FBTyxHQUFHLFNBQVNBLFFBQVNDLEVBQUUsRUFBRUMsRUFBRTtJQUM1RCxJQUFJMnJCLE9BQU81ckI7SUFDWCxJQUFJNnJCLE9BQU81ckI7SUFDWCxPQUFPNnBCLGlCQUFpQi9wQixPQUFPLENBQUM2ckIsTUFBTUM7QUFDeEM7QUFDQTdCLGtCQUFrQmp3QixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDakQsT0FBTztRQUFDMkI7S0FBVztBQUNyQjtBQUNBeXNCLGtCQUFrQmp3QixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDOUMsT0FBT211QjtBQUNUO0FBRUEsSUFBSUMsMEJBQTBCLFNBQVNBLDJCQUE0QjtBQUVuRUEsd0JBQXdCbHdCLFNBQVMsQ0FBQ2dHLE9BQU8sR0FBRyxTQUFTQSxRQUFTQyxFQUFFLEVBQUVDLEVBQUU7SUFDbEUsSUFBSTJyQixPQUFPNXJCO0lBQ1gsSUFBSTZyQixPQUFPNXJCO0lBQ1gsSUFBSTJyQixLQUFLcHhCLE1BQU0sR0FBR3F4QixLQUFLcnhCLE1BQU0sRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzNDLElBQUlveEIsS0FBS3B4QixNQUFNLEdBQUdxeEIsS0FBS3J4QixNQUFNLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDMUMsSUFBSW94QixLQUFLcHhCLE1BQU0sS0FBSyxHQUFHO1FBQUUsT0FBTztJQUFFO0lBQ2xDLElBQUkreEIsY0FBY3pDLGlCQUFpQi9wQixPQUFPLENBQUM2ckIsTUFBTUM7SUFDakQsSUFBSVcsYUFBYTFDLGlCQUFpQjZCLGVBQWUsQ0FBQ0MsTUFBTUM7SUFDeEQsSUFBSVcsWUFBWTtRQUFFLE9BQU87SUFBRTtJQUMzQixPQUFPRDtBQUNUO0FBQ0F0Qyx3QkFBd0Jsd0IsU0FBUyxDQUFDMHlCLFVBQVUsR0FBRyxTQUFTQSxXQUFZenNCLEVBQUUsRUFBRUMsRUFBRTtJQUN4RSxJQUFJMnJCLE9BQU81ckI7SUFDWCxJQUFJNnJCLE9BQU81ckI7SUFDWCxJQUFJMnJCLEtBQUtweEIsTUFBTSxHQUFHcXhCLEtBQUtyeEIsTUFBTSxFQUFFO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDM0MsSUFBSW94QixLQUFLcHhCLE1BQU0sR0FBR3F4QixLQUFLcnhCLE1BQU0sRUFBRTtRQUFFLE9BQU87SUFBRTtJQUMxQyxJQUFJb3hCLEtBQUtweEIsTUFBTSxLQUFLLEdBQUc7UUFBRSxPQUFPO0lBQUU7SUFDbEMsSUFBSWt5QixPQUFPNUMsaUJBQWlCa0MsbUJBQW1CLENBQUNKO0lBQ2hELElBQUllLE9BQU83QyxpQkFBaUJrQyxtQkFBbUIsQ0FBQ0g7SUFDaEQsSUFBSWUsS0FBS0YsT0FBTyxJQUFJLElBQUlkLEtBQUtweEIsTUFBTSxHQUFHO0lBQ3RDLElBQUlxeUIsS0FBS0YsT0FBTyxJQUFJLElBQUlmLEtBQUtweEIsTUFBTSxHQUFHO0lBQ3RDLElBQUssSUFBSTJHLElBQUksR0FBR0EsSUFBSXlxQixLQUFLcHhCLE1BQU0sRUFBRTJHLElBQUs7UUFDcEMsSUFBSTJyQixZQUFZbEIsSUFBSSxDQUFDZ0IsR0FBRyxDQUFDaHVCLFNBQVMsQ0FBQ2l0QixJQUFJLENBQUNnQixHQUFHO1FBQzNDLElBQUlDLGNBQWMsR0FBRztZQUFFLE9BQU9BO1FBQVU7UUFDeENGLE1BQU1GO1FBQ05HLE1BQU1GO0lBQ1I7SUFDQSxPQUFPO0FBQ1Q7QUFDQTFDLHdCQUF3Qmx3QixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkQsT0FBTztRQUFDMkI7S0FBVztBQUNyQjtBQUNBMHNCLHdCQUF3Qmx3QixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDcEQsT0FBT291QjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxJQUFJOEMsUUFBUSxTQUFTQyxRQUFRO0FBRTdCRCxNQUFNaHpCLFNBQVMsQ0FBQ29ELEdBQUcsR0FBRyxTQUFTQSxPQUFRO0FBQ3ZDOzs7Ozs7Q0FNQyxHQUNENHZCLE1BQU1oekIsU0FBUyxDQUFDa3pCLEdBQUcsR0FBRyxTQUFTQSxPQUFRO0FBRXZDOzs7Q0FHQyxHQUNERixNQUFNaHpCLFNBQVMsQ0FBQzJULElBQUksR0FBRyxTQUFTQSxRQUFTO0FBRXpDOzs7Q0FHQyxHQUNEcWYsTUFBTWh6QixTQUFTLENBQUNtekIsTUFBTSxHQUFHLFNBQVNBLFVBQVc7QUFFN0M7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RILE1BQU1oekIsU0FBUyxDQUFDb3pCLFFBQVEsR0FBRyxTQUFTQSxZQUFhO0FBRWpEOzs7Ozs7Q0FNQyxHQUNELElBQUlDLFlBQWEsU0FBVUosSUFBRztJQUM3QixTQUFTSTtRQUNSSixLQUFJMVosS0FBSyxDQUFDLElBQUksRUFBRXpZO0lBQ2pCO0lBQUMsSUFBS215QixNQUFNSSxVQUFVM3dCLFNBQVMsR0FBR3V3QjtJQUNsQ0ksVUFBVXJ6QixTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUVzd0IsUUFBT0EsS0FBSWp6QixTQUFTO0lBQ3pEcXpCLFVBQVVyekIsU0FBUyxDQUFDNEMsV0FBVyxHQUFHeXdCO0lBSWxDLE9BQU9BO0FBQ1IsRUFBRUw7QUFFRjs7Ozs7Q0FLQyxHQUNELFNBQVNNLHNCQUF1Qmh4QixPQUFPO0lBQ3JDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQSxXQUFXO0FBQzVCO0FBQ0FneEIsc0JBQXNCdHpCLFNBQVMsR0FBRyxJQUFJcUM7QUFFdEM7O0NBRUMsR0FDRGl4QixzQkFBc0J0ekIsU0FBUyxDQUFDd0MsSUFBSSxHQUFHO0FBRXZDOzs7Ozs7Q0FNQyxHQUNELFNBQVMrd0IsT0FBTztBQUNoQkEsSUFBSXZ6QixTQUFTLEdBQUcsSUFBSThzQjtBQUdwQjs7Ozs7O0NBTUMsR0FDRHlHLElBQUl2ekIsU0FBUyxDQUFDaVksUUFBUSxHQUFHLFlBQVk7QUFFckM7Ozs7OztDQU1DLEdBQ0QsSUFBSXViLFVBQVcsU0FBVUMsTUFBTTtJQUM3QixTQUFTRDtRQUNQQyxPQUFPbHhCLElBQUksQ0FBQyxJQUFJO1FBQ2hCLElBQUksQ0FBQ21yQixNQUFNLEdBQUcsRUFBRTtRQUVoQixJQUFJNXNCLFNBQVMsQ0FBQyxFQUFFLFlBQVlnc0IsWUFBWTtZQUN0QyxJQUFJLENBQUNDLE1BQU0sQ0FBQ2pzQixTQUFTLENBQUMsRUFBRTtRQUMxQjtJQUNGO0lBRUEsSUFBSzJ5QixRQUFTRCxRQUFROXdCLFNBQVMsR0FBRyt3QjtJQUNsQ0QsUUFBUXh6QixTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUU4d0IsVUFBVUEsT0FBT3p6QixTQUFTO0lBQzdEd3pCLFFBQVF4ekIsU0FBUyxDQUFDNEMsV0FBVyxHQUFHNHdCO0lBRWhDOztHQUVDLEdBQ0RBLFFBQVF4ekIsU0FBUyxDQUFDaVksUUFBUSxHQUFHLFNBQVNBLFNBQVVuVCxDQUFDO1FBQy9DLElBQUl3VixTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHOEosTUFBTSxJQUFJLENBQUN3YyxNQUFNLENBQUNqdEIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUs5SixJQUFLO1lBQ3RELElBQUl5QixJQUFJeVIsT0FBT29ULE1BQU0sQ0FBQ3RtQixFQUFFO1lBQ3hCLElBQUl5QixNQUFNL0QsR0FBRztnQkFDWCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0QwdUIsUUFBUXh6QixTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsSUFBS25ILENBQUM7UUFDckMsSUFBSSxJQUFJLENBQUNtVCxRQUFRLENBQUNuVCxJQUFJO1lBQ3BCLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQzRvQixNQUFNLENBQUNqVCxJQUFJLENBQUMzVjtRQUVqQixPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEMHVCLFFBQVF4ekIsU0FBUyxDQUFDK3NCLE1BQU0sR0FBRyxTQUFTQSxPQUFRanBCLENBQUM7UUFDM0MsSUFBSXdXLFNBQVMsSUFBSTtRQUVqQixJQUFLLElBQUlsVCxJQUFJdEQsRUFBRXVuQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDdkNqUixPQUFPck8sR0FBRyxDQUFDN0UsRUFBRXNnQixJQUFJO1FBQ25CO1FBQ0EsT0FBTztJQUNUO0lBRUE7O0dBRUMsR0FDRDhMLFFBQVF4ekIsU0FBUyxDQUFDaXRCLE1BQU0sR0FBRyxTQUFTQSxPQUFRbm9CLENBQUM7UUFDM0Msb0RBQW9EO1FBQ3BELE1BQU0sSUFBSXpDO0lBQ1o7SUFFQTs7R0FFQyxHQUNEbXhCLFFBQVF4ekIsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO1FBQ2hDLE9BQU8sSUFBSSxDQUFDK1osTUFBTSxDQUFDanRCLE1BQU07SUFDM0I7SUFFQTs7R0FFQyxHQUNEK3lCLFFBQVF4ekIsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBO1FBQ25DLE9BQU8sSUFBSSxDQUFDNFQsTUFBTSxDQUFDanRCLE1BQU0sS0FBSztJQUNoQztJQUVBOztHQUVDLEdBQ0QreUIsUUFBUXh6QixTQUFTLENBQUNndEIsT0FBTyxHQUFHLFNBQVNBO1FBQ25DLElBQUkxUyxTQUFTLElBQUk7UUFFakIsSUFBSUMsUUFBUSxFQUFFO1FBRWQsSUFBSyxJQUFJblQsSUFBSSxHQUFHOEosTUFBTSxJQUFJLENBQUN3YyxNQUFNLENBQUNqdEIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUs5SixJQUFLO1lBQ3REbVQsTUFBTUUsSUFBSSxDQUFDSCxPQUFPb1QsTUFBTSxDQUFDdG1CLEVBQUU7UUFDN0I7UUFFQSxPQUFPbVQ7SUFDVDtJQUVBOztHQUVDLEdBQ0RpWixRQUFReHpCLFNBQVMsQ0FBQ3FyQixRQUFRLEdBQUcsU0FBU0E7UUFDcEMsT0FBTyxJQUFJcUksWUFBWSxJQUFJO0lBQzdCO0lBRUEsT0FBT0Y7QUFDVCxFQUFFRDtBQUVGOzs7OztHQUtHLEdBQ0gsSUFBSUcsY0FBZSxTQUFVeEYsV0FBVztJQUN0QyxTQUFTRixVQUFXMkYsT0FBTztRQUN6QnpGLFlBQVkzckIsSUFBSSxDQUFDLElBQUk7UUFDckI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDcXhCLFFBQVEsR0FBR0Q7UUFDaEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDdEYsU0FBUyxHQUFHO0lBQ25CO0lBRUEsSUFBS0gsYUFBY0YsVUFBVXRyQixTQUFTLEdBQUd3ckI7SUFDekNGLFVBQVVodUIsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFdXJCLGVBQWVBLFlBQVlsdUIsU0FBUztJQUN6RWd1QixVQUFVaHVCLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR29yQjtJQUVsQzs7R0FFQyxHQUNEQSxVQUFVaHVCLFNBQVMsQ0FBQzBuQixJQUFJLEdBQUcsU0FBU0E7UUFDbEMsSUFBSSxJQUFJLENBQUMyRyxTQUFTLEtBQUssSUFBSSxDQUFDdUYsUUFBUSxDQUFDamdCLElBQUksSUFBSTtZQUMzQyxNQUFNLElBQUk0WjtRQUNaO1FBQ0EsT0FBTyxJQUFJLENBQUNxRyxRQUFRLENBQUNsRyxNQUFNLENBQUMsSUFBSSxDQUFDVyxTQUFTLEdBQUc7SUFDL0M7SUFFQTs7R0FFQyxHQUNETCxVQUFVaHVCLFNBQVMsQ0FBQ3VyQixPQUFPLEdBQUcsU0FBU0E7UUFDckMsSUFBSSxJQUFJLENBQUM4QyxTQUFTLEdBQUcsSUFBSSxDQUFDdUYsUUFBUSxDQUFDamdCLElBQUksSUFBSTtZQUN6QyxPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRHFhLFVBQVVodUIsU0FBUyxDQUFDaXRCLE1BQU0sR0FBRyxTQUFTQTtRQUNwQyxNQUFNLElBQUlxRztJQUNaO0lBRUEsT0FBT3RGO0FBQ1QsRUFBRWI7QUFFRixJQUFJMEcsUUFBUTtBQUNaLElBQUlDLE1BQU07QUFDVixTQUFTQyxRQUFTL2UsQ0FBQztJQUFJLE9BQVFBLE1BQU0sT0FBTzZlLFFBQVE3ZSxFQUFFZ2YsS0FBSztBQUFFO0FBQzdELFNBQVNDLFNBQVVqZixDQUFDO0lBQUksT0FBUUEsTUFBTSxPQUFPLE9BQU9BLEVBQUVrZixNQUFNO0FBQUU7QUFDOUQsU0FBU0MsU0FBVW5mLENBQUMsRUFBRWxSLENBQUM7SUFBSSxJQUFJa1IsTUFBTSxNQUFNO1FBQUVBLEVBQUVnZixLQUFLLEdBQUdsd0I7SUFBRztBQUFFO0FBQzVELFNBQVNzd0IsT0FBUXBmLENBQUM7SUFBSSxPQUFRQSxNQUFNLE9BQU8sT0FBT0EsRUFBRXFmLElBQUk7QUFBRTtBQUMxRCxTQUFTQyxRQUFTdGYsQ0FBQztJQUFJLE9BQVFBLE1BQU0sT0FBTyxPQUFPQSxFQUFFdWYsS0FBSztBQUFFO0FBRTVEOzs7Ozs7Q0FNQyxHQUNELFNBQVNDO0lBQ1A7OztHQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYjs7O0VBR0EsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztBQUNmO0FBQ0FGLFFBQVF4MEIsU0FBUyxHQUFHLElBQUlxekI7QUFFeEI7O0NBRUMsR0FDRG1CLFFBQVF4MEIsU0FBUyxDQUFDb0QsR0FBRyxHQUFHLFNBQVV1eEIsR0FBRztJQUNuQyxJQUFJM2YsSUFBSSxJQUFJLENBQUN5ZixLQUFLO0lBQ2xCLE1BQU96ZixNQUFNLEtBQU07UUFDakIsSUFBSTRmLE1BQU1ELEdBQUcsQ0FBQyxZQUFZLENBQUMzZixFQUFFMmYsR0FBRztRQUNoQyxJQUFJQyxNQUFNLEdBQUc7WUFBRTVmLElBQUlBLEVBQUVxZixJQUFJO1FBQUUsT0FDdEIsSUFBSU8sTUFBTSxHQUFHO1lBQUU1ZixJQUFJQSxFQUFFdWYsS0FBSztRQUFFLE9BQzVCO1lBQUUsT0FBT3ZmLEVBQUU1VSxLQUFLO1FBQUM7SUFDeEI7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNEbzBCLFFBQVF4MEIsU0FBUyxDQUFDa3pCLEdBQUcsR0FBRyxTQUFVeUIsR0FBRyxFQUFFdjBCLEtBQUs7SUFDMUMsSUFBSSxJQUFJLENBQUNxMEIsS0FBSyxLQUFLLE1BQU07UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUc7WUFDWEUsS0FBS0E7WUFDTHYwQixPQUFPQTtZQUNQaTBCLE1BQU07WUFDTkUsT0FBTztZQUNQTCxRQUFRO1lBQ1JGLE9BQU9IO1lBQ1BnQixVQUFVLFNBQVNBO2dCQUFjLE9BQU8sSUFBSSxDQUFDejBCLEtBQUs7WUFBQztZQUNuRDAwQixRQUFRLFNBQVNBO2dCQUFZLE9BQU8sSUFBSSxDQUFDSCxHQUFHO1lBQUM7UUFDL0M7UUFDQSxJQUFJLENBQUNELEtBQUssR0FBRztRQUNiLE9BQU87SUFDVDtJQUNBLElBQUk5bEIsSUFBSSxJQUFJLENBQUM2bEIsS0FBSztJQUNsQixJQUFJUDtJQUNKLElBQUlVO0lBQ0osR0FBRztRQUNEVixTQUFTdGxCO1FBQ1RnbUIsTUFBTUQsR0FBRyxDQUFDLFlBQVksQ0FBQy9sQixFQUFFK2xCLEdBQUc7UUFDNUIsSUFBSUMsTUFBTSxHQUFHO1lBQ1hobUIsSUFBSUEsRUFBRXlsQixJQUFJO1FBQ1osT0FBTyxJQUFJTyxNQUFNLEdBQUc7WUFDbEJobUIsSUFBSUEsRUFBRTJsQixLQUFLO1FBQ2IsT0FBTztZQUNMLElBQUlRLFdBQVdubUIsRUFBRXhPLEtBQUs7WUFDdEJ3TyxFQUFFeE8sS0FBSyxHQUFHQTtZQUNWLE9BQU8yMEI7UUFDVDtJQUNGLFFBQVNubUIsTUFBTSxNQUFLO0lBQ3BCLElBQUkvRixJQUFJO1FBQ044ckIsS0FBS0E7UUFDTE4sTUFBTTtRQUNORSxPQUFPO1FBQ1BuMEIsT0FBT0E7UUFDUDh6QixRQUFRQTtRQUNSRixPQUFPSDtRQUNQZ0IsVUFBVSxTQUFTQTtZQUFjLE9BQU8sSUFBSSxDQUFDejBCLEtBQUs7UUFBQztRQUNuRDAwQixRQUFRLFNBQVNBO1lBQVksT0FBTyxJQUFJLENBQUNILEdBQUc7UUFBQztJQUMvQztJQUNBLElBQUlDLE1BQU0sR0FBRztRQUNYVixPQUFPRyxJQUFJLEdBQUd4ckI7SUFDaEIsT0FBTztRQUNMcXJCLE9BQU9LLEtBQUssR0FBRzFyQjtJQUNqQjtJQUNBLElBQUksQ0FBQ21zQixpQkFBaUIsQ0FBQ25zQjtJQUN2QixJQUFJLENBQUM2ckIsS0FBSztJQUNWLE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ0RGLFFBQVF4MEIsU0FBUyxDQUFDZzFCLGlCQUFpQixHQUFHLFNBQVV0ekIsQ0FBQztJQUMvQyxJQUFJNFksU0FBUyxJQUFJO0lBRWpCNVksRUFBRXN5QixLQUFLLEdBQUdGO0lBQ1YsTUFBT3B5QixLQUFLLFFBQVFBLE1BQU0sSUFBSSxDQUFDK3lCLEtBQUssSUFBSS95QixFQUFFd3lCLE1BQU0sQ0FBQ0YsS0FBSyxLQUFLRixJQUFLO1FBQzlELElBQUlHLFNBQVN2eUIsT0FBTzB5QixPQUFPSCxTQUFTQSxTQUFTdnlCLE1BQU07WUFDakQsSUFBSWlDLElBQUkyd0IsUUFBUUwsU0FBU0EsU0FBU3Z5QjtZQUNsQyxJQUFJcXlCLFFBQVFwd0IsT0FBT213QixLQUFLO2dCQUN0QkssU0FBU0YsU0FBU3Z5QixJQUFJbXlCO2dCQUN0Qk0sU0FBU3h3QixHQUFHa3dCO2dCQUNaTSxTQUFTRixTQUFTQSxTQUFTdnlCLEtBQUtveUI7Z0JBQ2hDcHlCLElBQUl1eUIsU0FBU0EsU0FBU3Z5QjtZQUN4QixPQUFPO2dCQUNMLElBQUlBLE1BQU00eUIsUUFBUUwsU0FBU3Z5QixLQUFLO29CQUM5QkEsSUFBSXV5QixTQUFTdnlCO29CQUNiNFksT0FBTzJhLFVBQVUsQ0FBQ3Z6QjtnQkFDcEI7Z0JBQ0F5eUIsU0FBU0YsU0FBU3Z5QixJQUFJbXlCO2dCQUN0Qk0sU0FBU0YsU0FBU0EsU0FBU3Z5QixLQUFLb3lCO2dCQUNoQ3haLE9BQU80YSxXQUFXLENBQUNqQixTQUFTQSxTQUFTdnlCO1lBQ3ZDO1FBQ0YsT0FBTztZQUNMLElBQUl5SyxNQUFNaW9CLE9BQU9ILFNBQVNBLFNBQVN2eUI7WUFDbkMsSUFBSXF5QixRQUFRNW5CLFNBQVMybkIsS0FBSztnQkFDeEJLLFNBQVNGLFNBQVN2eUIsSUFBSW15QjtnQkFDdEJNLFNBQVNob0IsS0FBSzBuQjtnQkFDZE0sU0FBU0YsU0FBU0EsU0FBU3Z5QixLQUFLb3lCO2dCQUNoQ3B5QixJQUFJdXlCLFNBQVNBLFNBQVN2eUI7WUFDeEIsT0FBTztnQkFDTCxJQUFJQSxNQUFNMHlCLE9BQU9ILFNBQVN2eUIsS0FBSztvQkFDN0JBLElBQUl1eUIsU0FBU3Z5QjtvQkFDYjRZLE9BQU80YSxXQUFXLENBQUN4ekI7Z0JBQ3JCO2dCQUNBeXlCLFNBQVNGLFNBQVN2eUIsSUFBSW15QjtnQkFDdEJNLFNBQVNGLFNBQVNBLFNBQVN2eUIsS0FBS295QjtnQkFDaEN4WixPQUFPMmEsVUFBVSxDQUFDaEIsU0FBU0EsU0FBU3Z5QjtZQUN0QztRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUMreUIsS0FBSyxDQUFDVCxLQUFLLEdBQUdIO0FBQ3JCO0FBRUE7O0NBRUMsR0FDRFcsUUFBUXgwQixTQUFTLENBQUNtekIsTUFBTSxHQUFHO0lBQ3pCLElBQUloRixZQUFZLElBQUlYO0lBQ3BCLElBQUl4WSxJQUFJLElBQUksQ0FBQ21nQixhQUFhO0lBQzFCLElBQUluZ0IsTUFBTSxNQUFNO1FBQ2RtWixVQUFVbGlCLEdBQUcsQ0FBQytJLEVBQUU1VSxLQUFLO1FBQ3JCLE1BQU8sQ0FBQzRVLElBQUl3ZixRQUFRWSxTQUFTLENBQUNwZ0IsRUFBQyxNQUFPLEtBQU07WUFDMUNtWixVQUFVbGlCLEdBQUcsQ0FBQytJLEVBQUU1VSxLQUFLO1FBQ3ZCO0lBQ0Y7SUFDQSxPQUFPK3RCO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNEcUcsUUFBUXgwQixTQUFTLENBQUNvekIsUUFBUSxHQUFHO0lBQzNCLElBQUlPLFVBQVUsSUFBSUg7SUFDbEIsSUFBSXhlLElBQUksSUFBSSxDQUFDbWdCLGFBQWE7SUFDMUIsSUFBSW5nQixNQUFNLE1BQU07UUFDZDJlLFFBQVExbkIsR0FBRyxDQUFDK0k7UUFDWixNQUFPLENBQUNBLElBQUl3ZixRQUFRWSxTQUFTLENBQUNwZ0IsRUFBQyxNQUFPLEtBQU07WUFDMUMyZSxRQUFRMW5CLEdBQUcsQ0FBQytJO1FBQ2Q7SUFDRjtJQUNBLE9BQU8yZTtBQUNUO0FBRUE7O0NBRUMsR0FDRGEsUUFBUXgwQixTQUFTLENBQUNpMUIsVUFBVSxHQUFHLFNBQVVqZ0IsQ0FBQztJQUN4QyxJQUFJQSxLQUFLLE1BQU07UUFDYixJQUFJekgsSUFBSXlILEVBQUV1ZixLQUFLO1FBQ2Z2ZixFQUFFdWYsS0FBSyxHQUFHaG5CLEVBQUU4bUIsSUFBSTtRQUNoQixJQUFJOW1CLEVBQUU4bUIsSUFBSSxJQUFJLE1BQU07WUFBRTltQixFQUFFOG1CLElBQUksQ0FBQ0gsTUFBTSxHQUFHbGY7UUFBRztRQUN6Q3pILEVBQUUybUIsTUFBTSxHQUFHbGYsRUFBRWtmLE1BQU07UUFDbkIsSUFBSWxmLEVBQUVrZixNQUFNLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQ08sS0FBSyxHQUFHbG5CO1FBQUcsT0FBTyxJQUFJeUgsRUFBRWtmLE1BQU0sQ0FBQ0csSUFBSSxLQUFLcmYsR0FBRztZQUFFQSxFQUFFa2YsTUFBTSxDQUFDRyxJQUFJLEdBQUc5bUI7UUFBRyxPQUFPO1lBQUV5SCxFQUFFa2YsTUFBTSxDQUFDSyxLQUFLLEdBQUdobkI7UUFBRztRQUMzSEEsRUFBRThtQixJQUFJLEdBQUdyZjtRQUNUQSxFQUFFa2YsTUFBTSxHQUFHM21CO0lBQ2I7QUFDRjtBQUVBOztDQUVDLEdBQ0RpbkIsUUFBUXgwQixTQUFTLENBQUNrMUIsV0FBVyxHQUFHLFNBQVVsZ0IsQ0FBQztJQUN6QyxJQUFJQSxLQUFLLE1BQU07UUFDYixJQUFJcWdCLElBQUlyZ0IsRUFBRXFmLElBQUk7UUFDZHJmLEVBQUVxZixJQUFJLEdBQUdnQixFQUFFZCxLQUFLO1FBQ2hCLElBQUljLEVBQUVkLEtBQUssSUFBSSxNQUFNO1lBQUVjLEVBQUVkLEtBQUssQ0FBQ0wsTUFBTSxHQUFHbGY7UUFBRztRQUMzQ3FnQixFQUFFbkIsTUFBTSxHQUFHbGYsRUFBRWtmLE1BQU07UUFDbkIsSUFBSWxmLEVBQUVrZixNQUFNLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQ08sS0FBSyxHQUFHWTtRQUFHLE9BQU8sSUFBSXJnQixFQUFFa2YsTUFBTSxDQUFDSyxLQUFLLEtBQUt2ZixHQUFHO1lBQUVBLEVBQUVrZixNQUFNLENBQUNLLEtBQUssR0FBR2M7UUFBRyxPQUFPO1lBQUVyZ0IsRUFBRWtmLE1BQU0sQ0FBQ0csSUFBSSxHQUFHZ0I7UUFBRztRQUM1SEEsRUFBRWQsS0FBSyxHQUFHdmY7UUFDVkEsRUFBRWtmLE1BQU0sR0FBR21CO0lBQ2I7QUFDRjtBQUVBOztDQUVDLEdBQ0RiLFFBQVF4MEIsU0FBUyxDQUFDbTFCLGFBQWEsR0FBRztJQUNoQyxJQUFJbmdCLElBQUksSUFBSSxDQUFDeWYsS0FBSztJQUNsQixJQUFJemYsS0FBSyxNQUFNO1FBQ2IsTUFBT0EsRUFBRXFmLElBQUksSUFBSSxLQUFNO1lBQ3JCcmYsSUFBSUEsRUFBRXFmLElBQUk7UUFDWjtJQUNGO0lBQ0EsT0FBT3JmO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0R3ZixRQUFRWSxTQUFTLEdBQUcsU0FBVXhtQixDQUFDO0lBQzdCLElBQUlBLE1BQU0sTUFBTTtRQUFFLE9BQU87SUFBSyxPQUFPLElBQUlBLEVBQUUybEIsS0FBSyxLQUFLLE1BQU07UUFDekQsSUFBSXZmLElBQUlwRyxFQUFFMmxCLEtBQUs7UUFDZixNQUFPdmYsRUFBRXFmLElBQUksS0FBSyxLQUFNO1lBQ3RCcmYsSUFBSUEsRUFBRXFmLElBQUk7UUFDWjtRQUNBLE9BQU9yZjtJQUNULE9BQU87UUFDTCxJQUFJeVEsTUFBTTdXLEVBQUVzbEIsTUFBTTtRQUNsQixJQUFJM2pCLEtBQUszQjtRQUNULE1BQU82VyxRQUFRLFFBQVFsVixPQUFPa1YsSUFBSThPLEtBQUssQ0FBRTtZQUN2Q2hrQixLQUFLa1Y7WUFDTEEsTUFBTUEsSUFBSXlPLE1BQU07UUFDbEI7UUFDQSxPQUFPek87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRCtPLFFBQVF4MEIsU0FBUyxDQUFDMlQsSUFBSSxHQUFHO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDK2dCLEtBQUs7QUFDbkI7QUFFQSxJQUFJWSxTQUFTLFNBQVNBLFVBQVc7QUFFakNBLE9BQU90MUIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3RDLE9BQU8sRUFBRTtBQUNYO0FBQ0F5ekIsT0FBT3QxQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbkMsT0FBT3d6QjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsYUFBYztBQUN2QkEsVUFBVXYxQixTQUFTLEdBQUcsSUFBSXV6QjtBQUUxQixvQ0FBb0M7QUFDcEM7Ozs7OztDQU1DLEdBQ0QsU0FBU2lDO0lBQ1A7OztFQUdBLEdBQ0EsSUFBSSxDQUFDOUgsTUFBTSxHQUFHLEVBQUU7SUFFaEIsSUFBSTVzQixTQUFTLENBQUMsRUFBRSxZQUFZZ3NCLFlBQVk7UUFDdEMsSUFBSSxDQUFDQyxNQUFNLENBQUNqc0IsU0FBUyxDQUFDLEVBQUU7SUFDMUI7QUFDRjtBQUNBMDBCLFFBQVF4MUIsU0FBUyxHQUFHLElBQUl1MUI7QUFFeEI7O0NBRUMsR0FDREMsUUFBUXgxQixTQUFTLENBQUNpWSxRQUFRLEdBQUcsU0FBVW5ULENBQUM7SUFDdEMsSUFBSXdWLFNBQVMsSUFBSTtJQUVqQixJQUFLLElBQUlsVCxJQUFJLEdBQUc4SixNQUFNLElBQUksQ0FBQ3djLE1BQU0sQ0FBQ2p0QixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSzlKLElBQUs7UUFDdEQsSUFBSXlCLElBQUl5UixPQUFPb1QsTUFBTSxDQUFDdG1CLEVBQUU7UUFDeEIsSUFBSXlCLENBQUMsQ0FBQyxZQUFZLENBQUMvRCxPQUFPLEdBQUc7WUFDM0IsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNEMHdCLFFBQVF4MUIsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVVuSCxDQUFDO0lBQ2pDLElBQUl3VixTQUFTLElBQUk7SUFFakIsSUFBSSxJQUFJLENBQUNyQyxRQUFRLENBQUNuVCxJQUFJO1FBQ3BCLE9BQU87SUFDVDtJQUVBLElBQUssSUFBSXNDLElBQUksR0FBRzhKLE1BQU0sSUFBSSxDQUFDd2MsTUFBTSxDQUFDanRCLE1BQU0sRUFBRTJHLElBQUk4SixLQUFLOUosSUFBSztRQUN0RCxJQUFJeUIsSUFBSXlSLE9BQU9vVCxNQUFNLENBQUN0bUIsRUFBRTtRQUN4QixJQUFJeUIsQ0FBQyxDQUFDLFlBQVksQ0FBQy9ELE9BQU8sR0FBRztZQUMzQndWLE9BQU9vVCxNQUFNLENBQUNFLE1BQU0sQ0FBQ3htQixHQUFHLEdBQUd0QztZQUMzQixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUksQ0FBQzRvQixNQUFNLENBQUNqVCxJQUFJLENBQUMzVjtJQUVqQixPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNEMHdCLFFBQVF4MUIsU0FBUyxDQUFDK3NCLE1BQU0sR0FBRyxTQUFVanBCLENBQUM7SUFDcEMsSUFBSXdXLFNBQVMsSUFBSTtJQUVqQixJQUFLLElBQUlsVCxJQUFJdEQsRUFBRXVuQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDdkNqUixPQUFPck8sR0FBRyxDQUFDN0UsRUFBRXNnQixJQUFJO0lBQ25CO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDRDhOLFFBQVF4MUIsU0FBUyxDQUFDaXRCLE1BQU0sR0FBRyxTQUFVcGtCLENBQUM7SUFDcEMsTUFBTSxJQUFJeXFCO0FBQ1o7QUFFQTs7Q0FFQyxHQUNEa0MsUUFBUXgxQixTQUFTLENBQUMyVCxJQUFJLEdBQUc7SUFDdkIsT0FBTyxJQUFJLENBQUMrWixNQUFNLENBQUNqdEIsTUFBTTtBQUMzQjtBQUVBOztDQUVDLEdBQ0QrMEIsUUFBUXgxQixTQUFTLENBQUM4WixPQUFPLEdBQUc7SUFDMUIsT0FBTyxJQUFJLENBQUM0VCxNQUFNLENBQUNqdEIsTUFBTSxLQUFLO0FBQ2hDO0FBRUE7O0NBRUMsR0FDRCswQixRQUFReDFCLFNBQVMsQ0FBQ2d0QixPQUFPLEdBQUc7SUFDMUIsSUFBSTFTLFNBQVMsSUFBSTtJQUVqQixJQUFJQyxRQUFRLEVBQUU7SUFFZCxJQUFLLElBQUluVCxJQUFJLEdBQUc4SixNQUFNLElBQUksQ0FBQ3djLE1BQU0sQ0FBQ2p0QixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSzlKLElBQUs7UUFDdERtVCxNQUFNRSxJQUFJLENBQUNILE9BQU9vVCxNQUFNLENBQUN0bUIsRUFBRTtJQUM3QjtJQUVBLE9BQU9tVDtBQUNUO0FBRUE7O0NBRUMsR0FDRGliLFFBQVF4MUIsU0FBUyxDQUFDcXJCLFFBQVEsR0FBRztJQUMzQixPQUFPLElBQUlvSyxZQUFZLElBQUk7QUFDN0I7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlBLGNBQWMsU0FBVUMsT0FBTztJQUNqQzs7O0dBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBR0Q7SUFDaEI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDckgsU0FBUyxHQUFHO0FBQ25CO0FBRUE7O0NBRUMsR0FDRG9ILFlBQVl6MUIsU0FBUyxDQUFDMG5CLElBQUksR0FBRztJQUMzQixJQUFJLElBQUksQ0FBQzJHLFNBQVMsS0FBSyxJQUFJLENBQUNzSCxRQUFRLENBQUNoaUIsSUFBSSxJQUFJO1FBQzNDLE1BQU0sSUFBSTRaO0lBQ1o7SUFDQSxPQUFPLElBQUksQ0FBQ29JLFFBQVEsQ0FBQ2pJLE1BQU0sQ0FBQyxJQUFJLENBQUNXLFNBQVMsR0FBRztBQUMvQztBQUVBOztDQUVDLEdBQ0RvSCxZQUFZejFCLFNBQVMsQ0FBQ3VyQixPQUFPLEdBQUc7SUFDOUIsSUFBSSxJQUFJLENBQUM4QyxTQUFTLEdBQUcsSUFBSSxDQUFDc0gsUUFBUSxDQUFDaGlCLElBQUksSUFBSTtRQUN6QyxPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRDhoQixZQUFZejFCLFNBQVMsQ0FBQ2l0QixNQUFNLEdBQUc7SUFDN0IsTUFBTSxJQUFJcUc7QUFDWjtBQUVBOzs7OztDQUtDLEdBQ0QsSUFBSXNDLFNBQVMsU0FBU0EsVUFBVztBQUVqQ0EsT0FBT0MsSUFBSSxHQUFHLFNBQVNBO0lBQ3JCLElBQUlydkIsSUFBSTFGLFNBQVMsQ0FBQyxFQUFFO0lBQ3BCLElBQUlzRztJQUNKLElBQUl3SDtJQUNKLElBQUlrbkI7SUFDSixJQUFJOXZCO0lBQ0osSUFBSWxGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCdUYsVUFBVSxTQUFVUSxDQUFDLEVBQUVDLENBQUM7WUFDdEIsT0FBT0QsRUFBRTNCLFNBQVMsQ0FBQzRCO1FBQ3JCO1FBQ0FELEVBQUVxdkIsSUFBSSxDQUFDN3ZCO0lBQ1QsT0FBTyxJQUFJbEYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakNxMUIsYUFBYWgxQixTQUFTLENBQUMsRUFBRTtRQUN6QmtGLFVBQVUsU0FBVVEsQ0FBQyxFQUFFQyxDQUFDO1lBQ3RCLE9BQU9xdkIsVUFBVSxDQUFDLFVBQVUsQ0FBQ3R2QixHQUFHQztRQUNsQztRQUNBRCxFQUFFcXZCLElBQUksQ0FBQzd2QjtJQUNULE9BQU8sSUFBSWxGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDbU8sSUFBSXBJLEVBQUV1dkIsS0FBSyxDQUFDajFCLFNBQVMsQ0FBQyxFQUFFLEVBQUVBLFNBQVMsQ0FBQyxFQUFFO1FBQ3RDOE4sRUFBRWluQixJQUFJO1FBQ04sSUFBSXRvQixJQUFJL0csRUFBRXV2QixLQUFLLENBQUMsR0FBR2oxQixTQUFTLENBQUMsRUFBRSxFQUFFazFCLE1BQU0sQ0FBQ3BuQixHQUFHcEksRUFBRXV2QixLQUFLLENBQUNqMUIsU0FBUyxDQUFDLEVBQUUsRUFBRTBGLEVBQUUvRixNQUFNO1FBQ3pFK0YsRUFBRW9uQixNQUFNLENBQUMsR0FBR3BuQixFQUFFL0YsTUFBTTtRQUNwQixJQUFLMkcsSUFBSSxHQUFHQSxJQUFJbUcsRUFBRTlNLE1BQU0sRUFBRTJHLElBQUs7WUFDN0JaLEVBQUVpVSxJQUFJLENBQUNsTixDQUFDLENBQUNuRyxFQUFFO1FBQ2I7SUFDRixPQUFPLElBQUl0RyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQ21PLElBQUlwSSxFQUFFdXZCLEtBQUssQ0FBQ2oxQixTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRTtRQUN0Q2cxQixhQUFhaDFCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCa0YsVUFBVSxTQUFVUSxDQUFDLEVBQUVDLENBQUM7WUFDdEIsT0FBT3F2QixVQUFVLENBQUMsVUFBVSxDQUFDdHZCLEdBQUdDO1FBQ2xDO1FBQ0FtSSxFQUFFaW5CLElBQUksQ0FBQzd2QjtRQUNQdUgsSUFBSS9HLEVBQUV1dkIsS0FBSyxDQUFDLEdBQUdqMUIsU0FBUyxDQUFDLEVBQUUsRUFBRWsxQixNQUFNLENBQUNwbkIsR0FBR3BJLEVBQUV1dkIsS0FBSyxDQUFDajFCLFNBQVMsQ0FBQyxFQUFFLEVBQUUwRixFQUFFL0YsTUFBTTtRQUNyRStGLEVBQUVvbkIsTUFBTSxDQUFDLEdBQUdwbkIsRUFBRS9GLE1BQU07UUFDcEIsSUFBSzJHLElBQUksR0FBR0EsSUFBSW1HLEVBQUU5TSxNQUFNLEVBQUUyRyxJQUFLO1lBQzdCWixFQUFFaVUsSUFBSSxDQUFDbE4sQ0FBQyxDQUFDbkcsRUFBRTtRQUNiO0lBQ0Y7QUFDRjtBQUNBOzs7Q0FHQyxHQUNEd3VCLE9BQU9LLE1BQU0sR0FBRyxTQUFTQSxPQUFRMWIsS0FBSztJQUNwQyxJQUFJNFQsWUFBWSxJQUFJWDtJQUNwQixJQUFLLElBQUlwbUIsSUFBSSxHQUFHOEosTUFBTXFKLE1BQU05WixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSzlKLElBQUs7UUFDaEQrbUIsVUFBVWxpQixHQUFHLENBQUNzTyxLQUFLLENBQUNuVCxFQUFFO0lBQ3hCO0lBQ0EsT0FBTyttQjtBQUNUO0FBRUEsSUFBSStILFlBQVksU0FBU0EsYUFBYztBQUV2QyxJQUFJQyxxQkFBcUI7SUFBRUMsR0FBRztRQUFFajJCLGNBQWM7SUFBSztJQUFFazJCLEdBQUc7UUFBRWwyQixjQUFjO0lBQUs7SUFBRXNtQixHQUFHO1FBQUV0bUIsY0FBYztJQUFLO0lBQUVtMkIsT0FBTztRQUFFbjJCLGNBQWM7SUFBSztJQUFFbzJCLE1BQU07UUFBRXAyQixjQUFjO0lBQUs7SUFBRXEyQixVQUFVO1FBQUVyMkIsY0FBYztJQUFLO0lBQUVzMkIsV0FBVztRQUFFdDJCLGNBQWM7SUFBSztJQUFFdTJCLFVBQVU7UUFBRXYyQixjQUFjO0lBQUs7SUFBRXcyQixjQUFjO1FBQUV4MkIsY0FBYztJQUFLO0lBQUV5MkIsT0FBTztRQUFFejJCLGNBQWM7SUFBSztJQUFFMDJCLE9BQU87UUFBRTEyQixjQUFjO0lBQUs7SUFBRTIyQixPQUFPO1FBQUUzMkIsY0FBYztJQUFLO0FBQUU7QUFFdllnMkIsbUJBQW1CQyxDQUFDLENBQUNoekIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ2xEK3lCLG1CQUFtQkUsQ0FBQyxDQUFDanpCLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUNsRCt5QixtQkFBbUIxUCxDQUFDLENBQUNyakIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ2xEK3lCLG1CQUFtQkcsS0FBSyxDQUFDbHpCLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFFO0FBQ3ZEK3lCLG1CQUFtQkksSUFBSSxDQUFDbnpCLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFFO0FBQ3REK3lCLG1CQUFtQkssUUFBUSxDQUFDcHpCLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFFO0FBQzFEK3lCLG1CQUFtQk0sU0FBUyxDQUFDcnpCLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBSTtBQUM1RCt5QixtQkFBbUJPLFFBQVEsQ0FBQ3R6QixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUk7QUFDM0QreUIsbUJBQW1CUSxZQUFZLENBQUN2ekIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQy9EK3lCLG1CQUFtQlMsS0FBSyxDQUFDeHpCLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBSTtBQUN4RCt5QixtQkFBbUJVLEtBQUssQ0FBQ3p6QixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUk7QUFDeEQreUIsbUJBQW1CVyxLQUFLLENBQUMxekIsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBRXhEOHlCLFVBQVVsMkIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3pDLE9BQU8sRUFBRTtBQUNYO0FBQ0FxMEIsVUFBVWwyQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdEMsT0FBT28wQjtBQUNUO0FBQ0FBLFVBQVVhLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQkMsY0FBYztJQUN0RSxPQUFRQTtRQUNOLEtBQUtkLFVBQVVJLEtBQUs7WUFDbEIsT0FBT0osVUFBVU8sU0FBUztRQUM1QixLQUFLUCxVQUFVSyxJQUFJO1lBQ2pCLE9BQU9MLFVBQVVRLFFBQVE7UUFDM0IsS0FBS1IsVUFBVU0sUUFBUTtZQUNyQixPQUFPTixVQUFVUyxZQUFZO1FBQy9CLEtBQUtULFVBQVVFLENBQUM7WUFDZCxPQUFPRixVQUFVVSxLQUFLO1FBQ3hCLEtBQUtWLFVBQVVHLENBQUM7WUFDZCxPQUFPSCxVQUFVVyxLQUFLO1FBQ3hCLEtBQUtYLFVBQVV6UCxDQUFDO1lBQ2QsT0FBT3lQLFVBQVVZLEtBQUs7UUFDeEI7SUFDRjtJQUNBLE1BQU0sSUFBSTEwQix5QkFBeUIsOEJBQThCNDBCO0FBQ25FO0FBQ0FkLFVBQVVlLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQkMsZUFBZTtJQUNyRSxPQUFRaHVCLFVBQVVFLFdBQVcsQ0FBQzh0QjtRQUM1QixLQUFLaEIsVUFBVU8sU0FBUztZQUN0QixPQUFPUCxVQUFVSSxLQUFLO1FBQ3hCLEtBQUtKLFVBQVVRLFFBQVE7WUFDckIsT0FBT1IsVUFBVUssSUFBSTtRQUN2QixLQUFLTCxVQUFVUyxZQUFZO1lBQ3pCLE9BQU9ULFVBQVVNLFFBQVE7UUFDM0IsS0FBS04sVUFBVVUsS0FBSztZQUNsQixPQUFPVixVQUFVRSxDQUFDO1FBQ3BCLEtBQUtGLFVBQVVXLEtBQUs7WUFDbEIsT0FBT1gsVUFBVUcsQ0FBQztRQUNwQixLQUFLSCxVQUFVWSxLQUFLO1lBQ2xCLE9BQU9aLFVBQVV6UCxDQUFDO1FBQ3BCO0lBQ0Y7SUFDQSxNQUFNLElBQUlya0IseUJBQXlCLCtCQUErQjgwQjtBQUNwRTtBQUVBajNCLE9BQU9vRCxnQkFBZ0IsQ0FBRTZ5QixXQUFXQztBQUVwQyxJQUFJZ0IsaUJBQWlCLFNBQVNBLGtCQUFtQjtBQUVqREEsZUFBZW4zQixTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVFDLElBQUksR0FBRztBQUMxRCtPLGVBQWVuM0IsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlDLE9BQU8sRUFBRTtBQUNYO0FBQ0FzMUIsZUFBZW4zQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDM0MsT0FBT3ExQjtBQUNUO0FBRUEsSUFBSUMsMkJBQTJCLFNBQVNBLDRCQUE2QjtBQUVyRUEseUJBQXlCcDNCLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUWtQLEdBQUcsRUFBRWp3QixDQUFDLEdBQUc7QUFDdEVnd0IseUJBQXlCcDNCLFNBQVMsQ0FBQ3MzQixNQUFNLEdBQUcsU0FBU0EsVUFBVztBQUNoRUYseUJBQXlCcDNCLFNBQVMsQ0FBQ3UzQixpQkFBaUIsR0FBRyxTQUFTQSxxQkFBc0I7QUFDdEZILHlCQUF5QnAzQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDeEQsT0FBTyxFQUFFO0FBQ1g7QUFDQXUxQix5QkFBeUJwM0IsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JELE9BQU9zMUI7QUFDVDtBQUVBLElBQUlJLHFCQUFzQixTQUFVQyxXQUFXO0lBQzdDLFNBQVNELG1CQUFvQjNMLFVBQVUsRUFBRXZELE9BQU87UUFDOUNtUCxZQUFZbDFCLElBQUksQ0FBQyxJQUFJLEVBQUUrbEI7UUFDdkIsSUFBSSxDQUFDOU4sV0FBVyxHQUFHcVIsY0FBYyxFQUFFO1FBRW5DLElBQUk0TCxZQUFZM0wsZUFBZSxDQUFDLElBQUksQ0FBQ3RSLFdBQVcsR0FBRztZQUNqRCxNQUFNLElBQUlwWSx5QkFBeUI7UUFDckM7SUFDRjtJQUVBLElBQUtxMUIsYUFBY0QsbUJBQW1COTBCLFNBQVMsR0FBRyswQjtJQUNsREQsbUJBQW1CeDNCLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRTgwQixlQUFlQSxZQUFZejNCLFNBQVM7SUFDbEZ3M0IsbUJBQW1CeDNCLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzQwQjtJQUUzQyxJQUFJenpCLGtCQUFrQjtRQUFFRSxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztJQUFFO0lBQ2pFcTNCLG1CQUFtQngzQixTQUFTLENBQUNnckIsdUJBQXVCLEdBQUcsU0FBU0E7UUFDOUQsSUFBSTFRLFNBQVMsSUFBSTtRQUVqQixJQUFJeVgsV0FBVyxJQUFJN2I7UUFDbkIsSUFBSyxJQUFJOU8sSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ29ULFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTJHLElBQUs7WUFDaEQycUIsU0FBU3hhLGVBQWUsQ0FBQytDLE9BQU9FLFdBQVcsQ0FBQ3BULEVBQUUsQ0FBQ3VqQixtQkFBbUI7UUFDcEU7UUFDQSxPQUFPb0g7SUFDVDtJQUNBeUYsbUJBQW1CeDNCLFNBQVMsQ0FBQ3lwQixZQUFZLEdBQUcsU0FBU0EsYUFBY3ptQixDQUFDO1FBQ2xFLE9BQU8sSUFBSSxDQUFDd1gsV0FBVyxDQUFDeFgsRUFBRTtJQUM1QjtJQUNBdzBCLG1CQUFtQngzQixTQUFTLENBQUN1cEIsWUFBWSxHQUFHLFNBQVNBO1FBQ25ELE9BQU9rTyxZQUFZck8sNEJBQTRCO0lBQ2pEO0lBQ0FvTyxtQkFBbUJ4M0IsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQTtRQUNyRCxJQUFJcGQsU0FBUyxJQUFJO1FBRWpCLElBQUlrVyxjQUFjLElBQUl6d0IsTUFBTSxJQUFJLENBQUM0M0IsWUFBWSxJQUFJdDNCLElBQUksQ0FBQztRQUN0RCxJQUFJc2tCLElBQUksQ0FBQztRQUNULElBQUssSUFBSXZkLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvVCxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFLO1lBQ2hELElBQUl3d0IsbUJBQW1CdGQsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDc3dCLGNBQWM7WUFDM0QsSUFBSyxJQUFJcE0sSUFBSSxHQUFHQSxJQUFJc00saUJBQWlCbjNCLE1BQU0sRUFBRTZxQixJQUFLO2dCQUNoRDNHO2dCQUNBNkwsV0FBVyxDQUFDN0wsRUFBRSxHQUFHaVQsZ0JBQWdCLENBQUN0TSxFQUFFO1lBQ3RDO1FBQ0Y7UUFDQSxPQUFPa0Y7SUFDVDtJQUNBZ0gsbUJBQW1CeDNCLFNBQVMsQ0FBQ3dXLE9BQU8sR0FBRyxTQUFTQTtRQUM5QyxJQUFJOEQsU0FBUyxJQUFJO1FBRWpCLElBQUl1ZCxPQUFPO1FBQ1gsSUFBSyxJQUFJendCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvVCxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFLO1lBQ2hEeXdCLFFBQVF2ZCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUNvUCxPQUFPO1FBQ3ZDO1FBQ0EsT0FBT3FoQjtJQUNUO0lBQ0FMLG1CQUFtQngzQixTQUFTLENBQUM4cEIsV0FBVyxHQUFHLFNBQVNBO1FBQ2xELElBQUl4UCxTQUFTLElBQUk7UUFFakIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUkrRCxRQUFRMUQsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSW9CLFlBQVlwQixTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDZzNCLGlCQUFpQixDQUFDdHpCLFFBQVE7Z0JBQ2xDLE9BQU87WUFDVDtZQUNBLElBQUl1ekIsa0JBQWtCdnpCO1lBQ3RCLElBQUksSUFBSSxDQUFDZ1csV0FBVyxDQUFDL1osTUFBTSxLQUFLczNCLGdCQUFnQnZkLFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTtnQkFDbEUsT0FBTztZQUNUO1lBQ0EsSUFBSyxJQUFJMkcsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ29ULFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTJHLElBQUs7Z0JBQ2hELElBQUksQ0FBQ2tULE9BQU9FLFdBQVcsQ0FBQ3BULEVBQUUsQ0FBQzBpQixXQUFXLENBQUNpTyxnQkFBZ0J2ZCxXQUFXLENBQUNwVCxFQUFFLEVBQUVsRixZQUFZO29CQUNqRixPQUFPO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPO1FBQ1QsT0FBTztZQUFFLE9BQU91MUIsWUFBWXozQixTQUFTLENBQUM4cEIsV0FBVyxDQUFDdlEsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDM0U7SUFDQTAyQixtQkFBbUJ4M0IsU0FBUyxDQUFDOHFCLFNBQVMsR0FBRyxTQUFTQTtRQUNoRCxJQUFJeFEsU0FBUyxJQUFJO1FBRWpCLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvVCxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFLO1lBQ2hEa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDMGpCLFNBQVM7UUFDakM7UUFDQThLLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNyYixXQUFXO0lBQzlCO0lBQ0FnZCxtQkFBbUJ4M0IsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBO1FBQ3BELElBQUksSUFBSSxDQUFDa0csT0FBTyxJQUFJO1lBQUUsT0FBTztRQUFLO1FBQ2xDLE9BQU8sSUFBSSxDQUFDVSxXQUFXLENBQUMsRUFBRSxDQUFDNUcsYUFBYTtJQUMxQztJQUNBNGpCLG1CQUFtQngzQixTQUFTLENBQUNnNEIsb0JBQW9CLEdBQUcsU0FBU0E7UUFDM0QsSUFBSTFkLFNBQVMsSUFBSTtRQUVqQixJQUFJMmQsWUFBWS9CLFVBQVVJLEtBQUs7UUFDL0IsSUFBSyxJQUFJbHZCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvVCxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFLO1lBQ2hENndCLFlBQVl2M0IsS0FBS0MsR0FBRyxDQUFDczNCLFdBQVczZCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUM0d0Isb0JBQW9CO1FBQzVFO1FBQ0EsT0FBT0M7SUFDVDtJQUNBVCxtQkFBbUJ4M0IsU0FBUyxDQUFDOFQsWUFBWSxHQUFHLFNBQVNBO1FBQ25ELElBQUl3RyxTQUFTLElBQUk7UUFFakIsSUFBSTJkLFlBQVkvQixVQUFVSSxLQUFLO1FBQy9CLElBQUssSUFBSWx2QixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRDZ3QixZQUFZdjNCLEtBQUtDLEdBQUcsQ0FBQ3MzQixXQUFXM2QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDME0sWUFBWTtRQUNwRTtRQUNBLE9BQU9ta0I7SUFDVDtJQUNBVCxtQkFBbUJ4M0IsU0FBUyxDQUFDbXFCLFNBQVMsR0FBRyxTQUFTQTtRQUNoRCxJQUFJN1AsU0FBUyxJQUFJO1FBRWpCLElBQUk4TCxNQUFNO1FBQ1YsSUFBSyxJQUFJaGYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ29ULFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTJHLElBQUs7WUFDaERnZixPQUFPOUwsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDK2lCLFNBQVM7UUFDeEM7UUFDQSxPQUFPL0Q7SUFDVDtJQUNBb1IsbUJBQW1CeDNCLFNBQVMsQ0FBQzIzQixZQUFZLEdBQUcsU0FBU0E7UUFDbkQsSUFBSXJkLFNBQVMsSUFBSTtRQUVqQixJQUFJNGQsWUFBWTtRQUNoQixJQUFLLElBQUk5d0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ29ULFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTJHLElBQUs7WUFDaEQ4d0IsYUFBYTVkLE9BQU9FLFdBQVcsQ0FBQ3BULEVBQUUsQ0FBQ3V3QixZQUFZO1FBQ2pEO1FBQ0EsT0FBT087SUFDVDtJQUNBVixtQkFBbUJ4M0IsU0FBUyxDQUFDb3FCLGdCQUFnQixHQUFHLFNBQVNBO1FBQ3ZELE9BQU8sSUFBSSxDQUFDNVAsV0FBVyxDQUFDL1osTUFBTTtJQUNoQztJQUNBKzJCLG1CQUFtQngzQixTQUFTLENBQUNteEIsT0FBTyxHQUFHLFNBQVNBO1FBQzlDLElBQUk3VyxTQUFTLElBQUk7UUFFakIsSUFBSXRYLElBQUksSUFBSSxDQUFDd1gsV0FBVyxDQUFDL1osTUFBTTtRQUMvQixJQUFJMDNCLFdBQVcsSUFBSXA0QixNQUFNaUQsR0FBRzNDLElBQUksQ0FBQztRQUNqQyxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRCt3QixRQUFRLENBQUMvd0IsRUFBRSxHQUFHa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDK3BCLE9BQU87UUFDN0M7UUFDQSxPQUFPLElBQUksQ0FBQzNILFVBQVUsR0FBR3ZNLHdCQUF3QixDQUFDa2I7SUFDcEQ7SUFDQVgsbUJBQW1CeDNCLFNBQVMsQ0FBQ3FxQixrQkFBa0IsR0FBRyxTQUFTQTtRQUN6RCxJQUFJL1AsU0FBUyxJQUFJO1FBRWpCLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJcUUsSUFBSWhFLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUlzM0IsZ0JBQWdCLElBQUk1QyxRQUFRSSxPQUFPSyxNQUFNLENBQUMsSUFBSSxDQUFDemIsV0FBVztZQUM5RCxJQUFJNmQsZ0JBQWdCLElBQUk3QyxRQUFRSSxPQUFPSyxNQUFNLENBQUNueEIsRUFBRTBWLFdBQVc7WUFDM0QsT0FBTyxJQUFJLENBQUN4VSxPQUFPLENBQUNveUIsZUFBZUM7UUFDckMsT0FBTyxJQUFJdjNCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUk2M0IsTUFBTXgzQixTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJeXBCLE9BQU96cEIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSXkzQixLQUFLRDtZQUNULElBQUk1VyxLQUFLLElBQUksQ0FBQzBJLGdCQUFnQjtZQUM5QixJQUFJekksS0FBSzRXLEdBQUduTyxnQkFBZ0I7WUFDNUIsSUFBSWhqQixJQUFJO1lBQ1IsTUFBT0EsSUFBSXNhLE1BQU10YSxJQUFJdWEsR0FBSTtnQkFDdkIsSUFBSTZXLFdBQVdsZSxPQUFPbVAsWUFBWSxDQUFDcmlCO2dCQUNuQyxJQUFJcXhCLFlBQVlGLEdBQUc5TyxZQUFZLENBQUNyaUI7Z0JBQ2hDLElBQUlzeEIsV0FBV0YsU0FBU25PLGtCQUFrQixDQUFDb08sV0FBV2xPO2dCQUN0RCxJQUFJbU8sYUFBYSxHQUFHO29CQUFFLE9BQU9BO2dCQUFTO2dCQUN0Q3R4QjtZQUNGO1lBQ0EsSUFBSUEsSUFBSXNhLElBQUk7Z0JBQUUsT0FBTztZQUFFO1lBQ3ZCLElBQUl0YSxJQUFJdWEsSUFBSTtnQkFBRSxPQUFPLENBQUM7WUFBRTtZQUN4QixPQUFPO1FBQ1Q7SUFDRjtJQUNBNlYsbUJBQW1CeDNCLFNBQVMsQ0FBQ3VaLEtBQUssR0FBRyxTQUFTQTtRQUM1QyxJQUFJZSxTQUFTLElBQUk7UUFFakIsSUFBSW5ULGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFaXJCLG1CQUFtQjtZQUNoRCxJQUFJNUQsU0FBU3JuQixTQUFTLENBQUMsRUFBRTtZQUN6QixJQUFLLElBQUlzRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztnQkFDaERrVCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUNtUyxLQUFLLENBQUM0TztZQUM5QjtRQUNGLE9BQU8sSUFBSWhoQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRXMyQiwyQkFBMkI7WUFDL0QsSUFBSXVCLFdBQVc3M0IsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxJQUFJLENBQUMwWixXQUFXLENBQUMvWixNQUFNLEtBQUssR0FBRztnQkFBRSxPQUFPO1lBQUs7WUFDakQsSUFBSyxJQUFJbWxCLE1BQU0sR0FBR0EsTUFBTSxJQUFJLENBQUNwTCxXQUFXLENBQUMvWixNQUFNLEVBQUVtbEIsTUFBTztnQkFDdER0TCxPQUFPRSxXQUFXLENBQUNvTCxJQUFJLENBQUNyTSxLQUFLLENBQUNvZjtnQkFDOUIsSUFBSUEsU0FBU3JCLE1BQU0sSUFBSTtvQkFDckI7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlxQixTQUFTcEIsaUJBQWlCLElBQUk7Z0JBQUUsSUFBSSxDQUFDeE4sZUFBZTtZQUFJO1FBQzlELE9BQU8sSUFBSTVpQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRXEyQixpQkFBaUI7WUFDckQsSUFBSXlCLFdBQVc5M0IsU0FBUyxDQUFDLEVBQUU7WUFDM0I4M0IsU0FBU3pRLE1BQU0sQ0FBQyxJQUFJO1lBQ3BCLElBQUssSUFBSWtILE1BQU0sR0FBR0EsTUFBTSxJQUFJLENBQUM3VSxXQUFXLENBQUMvWixNQUFNLEVBQUU0dUIsTUFBTztnQkFDdEQvVSxPQUFPRSxXQUFXLENBQUM2VSxJQUFJLENBQUM5VixLQUFLLENBQUNxZjtZQUNoQztRQUNGLE9BQU8sSUFBSXp4QixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRW9uQiwwQkFBMEI7WUFDOUQsSUFBSTJRLFdBQVcvM0IsU0FBUyxDQUFDLEVBQUU7WUFDM0IrM0IsU0FBUzFRLE1BQU0sQ0FBQyxJQUFJO1lBQ3BCLElBQUssSUFBSW1ILE1BQU0sR0FBR0EsTUFBTSxJQUFJLENBQUM5VSxXQUFXLENBQUMvWixNQUFNLEVBQUU2dUIsTUFBTztnQkFDdERoVixPQUFPRSxXQUFXLENBQUM4VSxJQUFJLENBQUMvVixLQUFLLENBQUNzZjtZQUNoQztRQUNGO0lBQ0Y7SUFDQXJCLG1CQUFtQngzQixTQUFTLENBQUM4NEIsV0FBVyxHQUFHLFNBQVNBO1FBQ2xELElBQUksQ0FBQ2xPLDBCQUEwQixDQUFDLElBQUk7UUFDcENsTixPQUFPQyxvQkFBb0I7UUFDM0IsT0FBTztJQUNUO0lBQ0E2WixtQkFBbUJ4M0IsU0FBUyxDQUFDK0UsS0FBSyxHQUFHLFNBQVNBO1FBQzVDLElBQUl1VixTQUFTLElBQUk7UUFFakIsSUFBSWllLEtBQUtkLFlBQVl6M0IsU0FBUyxDQUFDK0UsS0FBSyxDQUFDeEMsSUFBSSxDQUFDLElBQUk7UUFDOUNnMkIsR0FBRy9kLFdBQVcsR0FBRyxJQUFJemEsTUFBTSxJQUFJLENBQUN5YSxXQUFXLENBQUMvWixNQUFNLEVBQUVKLElBQUksQ0FBQztRQUN6RCxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRG14QixHQUFHL2QsV0FBVyxDQUFDcFQsRUFBRSxHQUFHa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDckMsS0FBSztRQUNqRDtRQUNBLE9BQU93ekI7SUFDVDtJQUNBZixtQkFBbUJ4M0IsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVNBO1FBQ3RELE9BQU87SUFDVDtJQUNBOGQsbUJBQW1CeDNCLFNBQVMsQ0FBQ2dGLElBQUksR0FBRyxTQUFTQTtRQUMzQyxJQUFJc1YsU0FBUyxJQUFJO1FBRWpCLElBQUl1UixhQUFhLElBQUk5ckIsTUFBTSxJQUFJLENBQUN5YSxXQUFXLENBQUMvWixNQUFNLEVBQUVKLElBQUksQ0FBQztRQUN6RCxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUl5a0IsV0FBV3ByQixNQUFNLEVBQUUyRyxJQUFLO1lBQzFDeWtCLFVBQVUsQ0FBQ3prQixFQUFFLEdBQUdrVCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUNwQyxJQUFJO1FBQzVDO1FBQ0EsT0FBTyxJQUFJd3lCLG1CQUFtQjNMLFlBQVksSUFBSSxDQUFDckQsUUFBUTtJQUN6RDtJQUNBZ1AsbUJBQW1CeDNCLFNBQVMsQ0FBQzhaLE9BQU8sR0FBRyxTQUFTQTtRQUM5QyxJQUFJUSxTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ29ULFdBQVcsQ0FBQy9aLE1BQU0sRUFBRTJHLElBQUs7WUFDaEQsSUFBSSxDQUFDa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDMFMsT0FBTyxJQUFJO2dCQUNwQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBMGQsbUJBQW1CeDNCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUNsRCxPQUFPLEVBQUU7SUFDWDtJQUNBMjFCLG1CQUFtQngzQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDL0MsT0FBTzAxQjtJQUNUO0lBQ0F6ekIsZ0JBQWdCRSxnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO1FBQWMsT0FBTyxDQUFDO0lBQW9CO0lBRWpGbkQsT0FBT29ELGdCQUFnQixDQUFFbTBCLG9CQUFvQnp6QjtJQUU3QyxPQUFPeXpCO0FBQ1QsRUFBRW5QO0FBRUYsSUFBSTBRLGtCQUFtQixTQUFVQyxxQkFBcUI7SUFDcEQsU0FBU0Q7UUFDUEMsc0JBQXNCemYsS0FBSyxDQUFDLElBQUksRUFBRXpZO0lBQ3BDO0lBRUEsSUFBS2s0Qix1QkFBd0JELGdCQUFnQnIyQixTQUFTLEdBQUdzMkI7SUFDekRELGdCQUFnQi80QixTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUVxMkIseUJBQXlCQSxzQkFBc0JoNUIsU0FBUztJQUNuRys0QixnQkFBZ0IvNEIsU0FBUyxDQUFDNEMsV0FBVyxHQUFHbTJCO0lBRXhDLElBQUloMUIsa0JBQWtCO1FBQUVFLGtCQUFrQjtZQUFFOUQsY0FBYztRQUFLO0lBQUU7SUFFakU0NEIsZ0JBQWdCLzRCLFNBQVMsQ0FBQ3VwQixZQUFZLEdBQUcsU0FBU0E7UUFDaEQsT0FBT2xCLFNBQVNZLHlCQUF5QjtJQUMzQztJQUNBOFAsZ0JBQWdCLzRCLFNBQVMsQ0FBQzhwQixXQUFXLEdBQUcsU0FBU0E7UUFDL0MsSUFBSWhwQixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJK0QsUUFBUTFELFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUlvQixZQUFZcEIsU0FBUyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQ2czQixpQkFBaUIsQ0FBQ3R6QixRQUFRO2dCQUNsQyxPQUFPO1lBQ1Q7WUFDQSxPQUFPdzBCLHNCQUFzQmg1QixTQUFTLENBQUM4cEIsV0FBVyxDQUFDdm5CLElBQUksQ0FBQyxJQUFJLEVBQUVpQyxPQUFPdEM7UUFDdkUsT0FBTztZQUFFLE9BQU84MkIsc0JBQXNCaDVCLFNBQVMsQ0FBQzhwQixXQUFXLENBQUN2USxLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUNyRjtJQUNBaTRCLGdCQUFnQi80QixTQUFTLENBQUNnNEIsb0JBQW9CLEdBQUcsU0FBU0E7UUFDeEQsSUFBSSxJQUFJLENBQUNpQixRQUFRLElBQUk7WUFDbkIsT0FBTy9DLFVBQVVJLEtBQUs7UUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQXlDLGdCQUFnQi80QixTQUFTLENBQUNpNUIsUUFBUSxHQUFHLFNBQVNBO1FBQzVDLElBQUkzZSxTQUFTLElBQUk7UUFFakIsSUFBSSxJQUFJLENBQUNSLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxJQUFLLElBQUkxUyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRCxJQUFJLENBQUNrVCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUM2eEIsUUFBUSxJQUFJO2dCQUNyQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBRixnQkFBZ0IvNEIsU0FBUyxDQUFDOFQsWUFBWSxHQUFHLFNBQVNBO1FBQ2hELE9BQU87SUFDVDtJQUNBaWxCLGdCQUFnQi80QixTQUFTLENBQUNteEIsT0FBTyxHQUFHLFNBQVNBO1FBQzNDLElBQUk3VyxTQUFTLElBQUk7UUFFakIsSUFBSTRlLFNBQVMsSUFBSSxDQUFDMWUsV0FBVyxDQUFDL1osTUFBTTtRQUNwQyxJQUFJMDRCLFdBQVcsSUFBSXA1QixNQUFNbTVCLFFBQVE3NEIsSUFBSSxDQUFDO1FBQ3RDLElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvVCxXQUFXLENBQUMvWixNQUFNLEVBQUUyRyxJQUFLO1lBQ2hEK3hCLFFBQVEsQ0FBQ0QsU0FBUyxJQUFJOXhCLEVBQUUsR0FBR2tULE9BQU9FLFdBQVcsQ0FBQ3BULEVBQUUsQ0FBQytwQixPQUFPO1FBQzFEO1FBQ0EsT0FBTyxJQUFJLENBQUMzSCxVQUFVLEdBQUduTixxQkFBcUIsQ0FBQzhjO0lBQ2pEO0lBQ0FKLGdCQUFnQi80QixTQUFTLENBQUM4NEIsV0FBVyxHQUFHLFNBQVNBO1FBQy9DLE9BQU8sSUFBSU0sV0FBVyxJQUFJLEVBQUVOLFdBQVc7SUFDekM7SUFDQUMsZ0JBQWdCLzRCLFNBQVMsQ0FBQzBaLGVBQWUsR0FBRyxTQUFTQTtRQUNuRCxPQUFPO0lBQ1Q7SUFDQXFmLGdCQUFnQi80QixTQUFTLENBQUNnRixJQUFJLEdBQUcsU0FBU0E7UUFDeEMsSUFBSXNWLFNBQVMsSUFBSTtRQUVqQixJQUFJK2UsY0FBYyxJQUFJdDVCLE1BQU0sSUFBSSxDQUFDeWEsV0FBVyxDQUFDL1osTUFBTSxFQUFFSixJQUFJLENBQUM7UUFDMUQsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJaXlCLFlBQVk1NEIsTUFBTSxFQUFFMkcsSUFBSztZQUMzQ2l5QixXQUFXLENBQUNqeUIsRUFBRSxHQUFHa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDcEMsSUFBSTtRQUM3QztRQUNBLE9BQU8sSUFBSSt6QixnQkFBZ0JNLGFBQWEsSUFBSSxDQUFDN1EsUUFBUTtJQUN2RDtJQUNBdVEsZ0JBQWdCLzRCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUMvQyxPQUFPO1lBQUN5ekI7U0FBTztJQUNqQjtJQUNBeUQsZ0JBQWdCLzRCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUM1QyxPQUFPaTNCO0lBQ1Q7SUFDQWgxQixnQkFBZ0JFLGdCQUFnQixDQUFDYixHQUFHLEdBQUc7UUFBYyxPQUFPO0lBQW9CO0lBRWhGbkQsT0FBT29ELGdCQUFnQixDQUFFMDFCLGlCQUFpQmgxQjtJQUUxQyxPQUFPZzFCO0FBQ1QsRUFBRXZCO0FBRUYsSUFBSTRCLGFBQWEsU0FBU0E7SUFDeEIsSUFBSSxDQUFDRSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFNBQVMsR0FBRztJQUNqQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUkzNEIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSTJuQixPQUFPdG5CLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk0NEIsU0FBU3pOLGlCQUFpQk0sa0JBQWtCO1FBQ2hELElBQUksQ0FBQytNLEtBQUssR0FBR2xSO1FBQ2IsSUFBSSxDQUFDbVIsU0FBUyxHQUFHblIsS0FBS29CLFVBQVU7UUFDaEMsSUFBSSxDQUFDZ1EsT0FBTyxHQUFHRTtJQUNqQixPQUFPLElBQUk1NEIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWs1QixTQUFTNzRCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUk4NEIsV0FBVzk0QixTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJLENBQUN3NEIsS0FBSyxHQUFHSztRQUNiLElBQUksQ0FBQ0osU0FBUyxHQUFHSSxPQUFPblEsVUFBVTtRQUNsQyxJQUFJLENBQUNnUSxPQUFPLEdBQUdJO0lBQ2pCO0FBQ0Y7QUFDQVIsV0FBV3A1QixTQUFTLENBQUM2NUIsdUJBQXVCLEdBQUcsU0FBU0Esd0JBQXlCQyxLQUFLO0lBQ3BGLElBQUksSUFBSSxDQUFDUixLQUFLLENBQUN4ZixPQUFPLElBQUk7UUFDeEIsT0FBTyxJQUFJLENBQUNpZ0Isa0JBQWtCO0lBQ2hDO0lBQ0EsSUFBSUMsU0FBUyxJQUFJLENBQUNDLDBCQUEwQixDQUFDSDtJQUM3QyxJQUFJRSxPQUFPdjVCLE1BQU0sS0FBSyxHQUFHO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDODRCLFNBQVMsQ0FBQzdkLFdBQVcsQ0FBQ3NlLE1BQU0sQ0FBQyxFQUFFO0lBQzdDO0lBQ0EsT0FBTyxJQUFJLENBQUNULFNBQVMsQ0FBQ1csMEJBQTBCLENBQUNGO0FBQ25EO0FBQ0FaLFdBQVdwNUIsU0FBUyxDQUFDODRCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxJQUFJLElBQUksQ0FBQ1EsS0FBSyxZQUFZYSxZQUFZO1FBQUUsT0FBTyxJQUFJLENBQUNDLGtCQUFrQixDQUFDLElBQUksQ0FBQ2QsS0FBSztJQUFFO0lBQ25GLElBQUksSUFBSSxDQUFDQSxLQUFLLFlBQVlQLGlCQUFpQjtRQUFFLE9BQU8sSUFBSSxDQUFDYyx1QkFBdUIsQ0FBQyxJQUFJLENBQUNQLEtBQUs7SUFBRTtJQUM3RixPQUFPLElBQUksQ0FBQ0EsS0FBSyxDQUFDUixXQUFXO0FBQy9CO0FBQ0FNLFdBQVdwNUIsU0FBUyxDQUFDbzZCLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQjlkLElBQUk7SUFDekUsSUFBSSxJQUFJLENBQUNnZCxLQUFLLENBQUN4ZixPQUFPLElBQUk7UUFDeEIsT0FBTyxJQUFJLENBQUNpZ0Isa0JBQWtCO0lBQ2hDO0lBQ0EsSUFBSXpkLEtBQUsyYyxRQUFRLElBQUk7UUFDbkIsSUFBSW9CLDJCQUEyQixJQUFJLENBQUNiLE9BQU8sQ0FBQzVNLFlBQVksQ0FBQztRQUN6RCxJQUFJeU4sMEJBQTBCO1lBQzVCLE9BQU8vZCxLQUFLZ2UsYUFBYTtRQUMzQixPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUNmLFNBQVMsQ0FBQ3hkLGdCQUFnQjtRQUN4QztJQUNGO0lBQ0EsT0FBTyxJQUFJLENBQUN3ZCxTQUFTLENBQUN4ZCxnQkFBZ0IsQ0FBQztRQUFDTyxLQUFLZ2UsYUFBYTtRQUFJaGUsS0FBS2llLFdBQVc7S0FBRztBQUNuRjtBQUNBbkIsV0FBV3A1QixTQUFTLENBQUMrNUIsa0JBQWtCLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxJQUFJLENBQUNSLFNBQVMsQ0FBQ3hkLGdCQUFnQjtBQUN4QztBQUNBcWQsV0FBV3A1QixTQUFTLENBQUNpNkIsMEJBQTBCLEdBQUcsU0FBU0EsMkJBQTRCSCxLQUFLO0lBQ3hGLElBQUl4ZixTQUFTLElBQUk7SUFFbkIsSUFBSTBmLFNBQVMsSUFBSXhNO0lBQ2pCLElBQUksQ0FBQ2lNLFlBQVksR0FBRyxJQUFJakY7SUFDeEIsSUFBSyxJQUFJcHRCLElBQUksR0FBR0EsSUFBSTB5QixNQUFNMVAsZ0JBQWdCLElBQUloakIsSUFBSztRQUNqRCxJQUFJa1YsT0FBT3dkLE1BQU1yUSxZQUFZLENBQUNyaUI7UUFDOUIsSUFBSWtWLEtBQUtxYixZQUFZLE9BQU8sR0FBRztZQUFFO1FBQVM7UUFDMUNyZCxPQUFPa2dCLFdBQVcsQ0FBQ2xlLEtBQUttZSxjQUFjLENBQUM7UUFDdkNuZ0IsT0FBT2tnQixXQUFXLENBQUNsZSxLQUFLbWUsY0FBYyxDQUFDbmUsS0FBS3FiLFlBQVksS0FBSztJQUMvRDtJQUNBLElBQUssSUFBSStDLEtBQUssSUFBSSxDQUFDakIsWUFBWSxDQUFDckcsUUFBUSxHQUFHL0gsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUNwRSxJQUFJb1AsUUFBUUQsR0FBR2hULElBQUk7UUFDbkIsSUFBSWxDLFVBQVVtVixNQUFNOUYsUUFBUTtRQUM1QixJQUFJK0YsVUFBVXBWLFFBQVFxVixLQUFLO1FBQzNCLElBQUl2Z0IsT0FBT2tmLE9BQU8sQ0FBQzVNLFlBQVksQ0FBQ2dPLFVBQVU7WUFDeENaLE9BQU8vdEIsR0FBRyxDQUFDMHVCLE1BQU03RixNQUFNO1FBQ3pCO0lBQ0Y7SUFDQSxPQUFPL0UsaUJBQWlCNWIsaUJBQWlCLENBQUM2bEI7QUFDNUM7QUFDQVosV0FBV3A1QixTQUFTLENBQUN3NkIsV0FBVyxHQUFHLFNBQVNBLFlBQWEzWixFQUFFO0lBQ3pELElBQUkyRSxVQUFVLElBQUksQ0FBQ2lVLFlBQVksQ0FBQ3IyQixHQUFHLENBQUN5ZDtJQUNwQyxJQUFJMkUsWUFBWSxNQUFNO1FBQ3BCQSxVQUFVLElBQUlzVjtRQUNkLElBQUksQ0FBQ3JCLFlBQVksQ0FBQ3ZHLEdBQUcsQ0FBQ3JTLElBQUkyRTtJQUM1QjtJQUNBQSxRQUFRcVYsS0FBSztBQUNmO0FBQ0F6QixXQUFXcDVCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxPQUFPLEVBQUU7QUFDWDtBQUNBdTNCLFdBQVdwNUIsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3ZDLE9BQU9zM0I7QUFDVDtBQUNBQSxXQUFXTixXQUFXLEdBQUcsU0FBU0E7SUFDaEMsSUFBSWg0QixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJb3BCLElBQUkvb0IsU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSWk2QixNQUFNLElBQUkzQixXQUFXdlA7UUFDekIsT0FBT2tSLElBQUlqQyxXQUFXO0lBQ3hCLE9BQU8sSUFBSWg0QixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJa3BCLE1BQU03b0IsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTQ0QixTQUFTNTRCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlrNkIsUUFBUSxJQUFJNUIsV0FBV3pQLEtBQUsrUDtRQUNoQyxPQUFPc0IsTUFBTWxDLFdBQVc7SUFDMUI7QUFDRjtBQUVBLElBQUlnQyxVQUFVLFNBQVNBO0lBQ3JCLElBQUksQ0FBQ0QsS0FBSyxHQUFHO0FBQ2Y7QUFDQUMsUUFBUTk2QixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxFQUFFO0FBQ1g7QUFDQWk1QixRQUFROTZCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxPQUFPZzVCO0FBQ1Q7QUFFQSxXQUFXO0FBRVgsU0FBU0csZUFBZ0I7QUFFekIsU0FBU0MsZ0JBQWlCO0FBRTFCLElBQUlDLGdCQUFnQixTQUFTQSxpQkFBa0I7QUFFL0MsU0FBU0MseUJBQTBCO0FBRW5DLFNBQVNDLGVBQWdCO0FBRXpCLFNBQVNDLG9CQUFxQjtBQUU5QixJQUFJQyxhQUFhLFNBQVNBLGNBQWU7QUFFekMsSUFBSUMscUJBQXFCO0lBQUVDLFNBQVM7UUFBRXQ3QixjQUFjO0lBQUs7SUFBRXU3Qix3QkFBd0I7UUFBRXY3QixjQUFjO0lBQUs7QUFBRTtBQUUxR283QixXQUFXdjdCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxPQUFPLEVBQUU7QUFDWDtBQUNBMDVCLFdBQVd2N0IsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3ZDLE9BQU95NUI7QUFDVDtBQUNBQSxXQUFXSSxLQUFLLEdBQUcsU0FBU0EsTUFBTzczQixDQUFDLEVBQUVkLENBQUM7SUFDckMsSUFBSXVOLEtBQUssSUFBSXhRLE1BQU1pRCxHQUFHM0MsSUFBSSxDQUFDO0lBQzNCLElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSXBFLEdBQUdvRSxJQUFLO1FBQzFCbUosRUFBRSxDQUFDbkosRUFBRSxHQUFHdEQ7SUFDVjtJQUNBLE9BQU84M0IsT0FBT3JyQjtBQUNoQjtBQUNBZ3JCLFdBQVdNLGFBQWEsR0FBRyxTQUFTQTtJQUNsQyxJQUFJLzZCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUltTyxJQUFJOU4sU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSWc3QixLQUFLLElBQUlWO1FBQ2IsSUFBSVcsS0FBSyxJQUFJZCxZQUFZYTtRQUN6Qmx0QixFQUFFb3RCLGVBQWUsQ0FBQ0Q7UUFDbEIsT0FBT0QsR0FBRzcyQixRQUFRO0lBQ3BCLE9BQU8sSUFBSW5FLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUl3N0IsTUFBTW43QixTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJbzdCLFFBQVFwN0IsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSXE3QixhQUFhO1FBQ2pCLElBQUlDLGVBQWUsSUFBSWxCLGFBQWFLLFdBQVdNLGFBQWEsQ0FBQ0k7UUFDN0QsSUFBSUksbUJBQW1CLElBQUlmLGlCQUFpQmM7UUFDNUMsSUFBSyxJQUFJaDFCLElBQUksR0FBR0EsSUFBSTgwQixPQUFPOTBCLElBQUs7WUFDOUIsSUFBSTtnQkFDRiswQixjQUFjRSxpQkFBaUJDLFFBQVEsS0FBS2YsV0FBV0UsT0FBTztZQUNoRSxFQUFFLE9BQU81eUIsR0FBRztnQkFDVixJQUFJQSxhQUFhd3lCLGFBQWE7b0JBQzVCM2QsT0FBT0Msb0JBQW9CO2dCQUM3QixPQUFPO29CQUFFLE1BQU05VTtnQkFBRTtZQUNuQixTQUFVLENBQUM7UUFDYjtRQUNBLE9BQU9zekI7SUFDVDtBQUNGO0FBQ0FaLFdBQVcxZixLQUFLLEdBQUcsU0FBU0EsTUFBT3JPLENBQUMsRUFBRSt1QixTQUFTO0lBQzdDLElBQUlDLGVBQWVELFVBQVU5N0IsTUFBTTtJQUNuQyxJQUFJZzhCLFlBQVksSUFBSWpQO0lBQ3BCLElBQUlrUCxZQUFZLEtBQUtsdkI7SUFDckIsSUFBSW12QixNQUFNRCxVQUFVcjFCLE9BQU8sQ0FBQ2sxQjtJQUM1QixNQUFPSSxPQUFPLEVBQUc7UUFDZixJQUFJQyxRQUFRRixVQUFVMXNCLFNBQVMsQ0FBQyxHQUFHMnNCO1FBQ25DRixVQUFVeHdCLEdBQUcsQ0FBQzJ3QjtRQUNkRixZQUFZQSxVQUFVMXNCLFNBQVMsQ0FBQzJzQixNQUFNSDtRQUN0Q0csTUFBTUQsVUFBVXIxQixPQUFPLENBQUNrMUI7SUFDMUI7SUFDQSxJQUFJRyxVQUFVajhCLE1BQU0sR0FBRyxHQUFHO1FBQUVnOEIsVUFBVXh3QixHQUFHLENBQUN5d0I7SUFBWTtJQUN0RCxJQUFJRyxNQUFNLElBQUk5OEIsTUFBTTA4QixVQUFVOW9CLElBQUksSUFBSXRULElBQUksQ0FBQztJQUMzQyxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUl5MUIsSUFBSXA4QixNQUFNLEVBQUUyRyxJQUFLO1FBQ25DeTFCLEdBQUcsQ0FBQ3oxQixFQUFFLEdBQUdxMUIsVUFBVXI1QixHQUFHLENBQUNnRTtJQUN6QjtJQUNBLE9BQU95MUI7QUFDVDtBQUNBdEIsV0FBV3QyQixRQUFRLEdBQUcsU0FBU0E7SUFDN0IsSUFBSW5FLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlnUSxJQUFJM1AsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBT3k2QixXQUFXRyxzQkFBc0IsQ0FBQ29CLE1BQU0sQ0FBQ3JzQjtJQUNsRDtBQUNGO0FBQ0E4cUIsV0FBV3pmLE1BQU0sR0FBRyxTQUFTQSxPQUFROVksQ0FBQztJQUNwQyxPQUFPdTRCLFdBQVdJLEtBQUssQ0FBQyxLQUFLMzRCO0FBQy9CO0FBQ0F3NEIsbUJBQW1CQyxPQUFPLENBQUNyNEIsR0FBRyxHQUFHO0lBQWMsT0FBT21SLE9BQU9NLFdBQVcsQ0FBQztBQUFrQjtBQUMzRjJtQixtQkFBbUJFLHNCQUFzQixDQUFDdDRCLEdBQUcsR0FBRztJQUFjLE9BQU8sSUFBSSszQixjQUFjO0FBQU87QUFFOUZsN0IsT0FBT29ELGdCQUFnQixDQUFFazRCLFlBQVlDO0FBRXJDLElBQUl1QixzQkFBc0IsU0FBU0EsdUJBQXdCO0FBRTNEQSxvQkFBb0IvOEIsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ25ELE9BQU8sRUFBRTtBQUNYO0FBQ0FrN0Isb0JBQW9CLzhCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNoRCxPQUFPaTdCO0FBQ1Q7QUFDQUEsb0JBQW9CQyxTQUFTLEdBQUcsU0FBU0EsVUFBV3ZvQixHQUFHLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxPQUFPO0lBQzVFLElBQUlxb0IsU0FBU3Y4QixLQUFLRSxHQUFHLENBQUM2VCxJQUFJWCxZQUFZLElBQUlhLEtBQUtiLFlBQVk7SUFDM0QsSUFBSyxJQUFJb3BCLE1BQU0sR0FBR0EsTUFBTUQsUUFBUUMsTUFBTztRQUNyQ3ZvQixLQUFLdFEsV0FBVyxDQUFDdVEsU0FBU3NvQixLQUFLem9CLElBQUloUSxXQUFXLENBQUNpUSxRQUFRd29CO0lBQ3pEO0FBQ0Y7QUFDQUgsb0JBQW9CNU0sTUFBTSxHQUFHLFNBQVNBLE9BQVFrSCxHQUFHO0lBQy9DLElBQUlyMEIsSUFBSXEwQixJQUFJMWpCLElBQUk7SUFDaEIsSUFBSTNRLE1BQU0sR0FBRztRQUFFLE9BQU87SUFBSztJQUMzQixJQUFJQSxLQUFLLEdBQUc7UUFBRSxPQUFPO0lBQU07SUFDM0IsT0FBT3EwQixJQUFJNXlCLFdBQVcsQ0FBQyxHQUFHK08sbUJBQW1CdFAsQ0FBQyxNQUFNbXpCLElBQUk1eUIsV0FBVyxDQUFDekIsSUFBSSxHQUFHd1EsbUJBQW1CdFAsQ0FBQyxLQUFLbXpCLElBQUk1eUIsV0FBVyxDQUFDLEdBQUcrTyxtQkFBbUJyUCxDQUFDLE1BQU1rekIsSUFBSTV5QixXQUFXLENBQUN6QixJQUFJLEdBQUd3USxtQkFBbUJyUCxDQUFDO0FBQzlMO0FBQ0E0NEIsb0JBQW9CSSxPQUFPLEdBQUcsU0FBU0EsUUFBU0MsR0FBRyxFQUFFQyxHQUFHO0lBQ3RELElBQUlDLFVBQVVGLElBQUl6cEIsSUFBSTtJQUN0QixJQUFJNHBCLFVBQVVGLElBQUkxcEIsSUFBSTtJQUN0QixJQUFJMnBCLFlBQVlDLFNBQVM7UUFBRSxPQUFPO0lBQU07SUFDeEMsSUFBSUwsTUFBTXg4QixLQUFLRSxHQUFHLENBQUN3OEIsSUFBSXRwQixZQUFZLElBQUl1cEIsSUFBSXZwQixZQUFZO0lBQ3ZELElBQUssSUFBSTFNLElBQUksR0FBR0EsSUFBSWsyQixTQUFTbDJCLElBQUs7UUFDaEMsSUFBSyxJQUFJcUosSUFBSSxHQUFHQSxJQUFJeXNCLEtBQUt6c0IsSUFBSztZQUM1QixJQUFJN0ksS0FBS3cxQixJQUFJMzRCLFdBQVcsQ0FBQzJDLEdBQUdxSjtZQUM1QixJQUFJNUksS0FBS3cxQixJQUFJNTRCLFdBQVcsQ0FBQzJDLEdBQUdxSjtZQUM1QixJQUFJMnNCLElBQUkzNEIsV0FBVyxDQUFDMkMsR0FBR3FKLE9BQU80c0IsSUFBSTU0QixXQUFXLENBQUMyQyxHQUFHcUosSUFBSTtnQkFBRTtZQUFTO1lBQ2hFLElBQUk1TixPQUFPckIsS0FBSyxDQUFDb0csT0FBTy9FLE9BQU9yQixLQUFLLENBQUNxRyxLQUFLO2dCQUFFO1lBQVM7WUFDckQsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQWsxQixvQkFBb0JTLE1BQU0sR0FBRyxTQUFTQSxPQUFRQyxJQUFJLEVBQUVwRyxHQUFHLEVBQUUxakIsSUFBSTtJQUMzRCxJQUFJK3BCLFNBQVNELEtBQUs5NkIsTUFBTSxDQUFDZ1IsTUFBTTBqQixJQUFJdmpCLFlBQVk7SUFDL0MsSUFBSTlRLElBQUlxMEIsSUFBSTFqQixJQUFJO0lBQ2hCb3BCLG9CQUFvQi8zQixJQUFJLENBQUNxeUIsS0FBSyxHQUFHcUcsUUFBUSxHQUFHMTZCO0lBQzVDLElBQUlBLElBQUksR0FBRztRQUNULElBQUssSUFBSW9FLElBQUlwRSxHQUFHb0UsSUFBSXVNLE1BQU12TSxJQUFLO1lBQUUyMUIsb0JBQW9CLzNCLElBQUksQ0FBQ3F5QixLQUFLcjBCLElBQUksR0FBRzA2QixRQUFRdDJCLEdBQUc7UUFBSTtJQUN2RjtJQUNBLE9BQU9zMkI7QUFDVDtBQUNBWCxvQkFBb0I1TCxPQUFPLEdBQUcsU0FBU0EsUUFBU2tHLEdBQUc7SUFDakQsSUFBSXRJLE9BQU9zSSxJQUFJMWpCLElBQUksS0FBSztJQUN4QixJQUFJeWQsTUFBTTF3QixLQUFLZSxLQUFLLENBQUNzdEIsT0FBTztJQUM1QixJQUFLLElBQUkzbkIsSUFBSSxHQUFHQSxLQUFLZ3FCLEtBQUtocUIsSUFBSztRQUM3QjIxQixvQkFBb0JyWSxJQUFJLENBQUMyUyxLQUFLandCLEdBQUcybkIsT0FBTzNuQjtJQUMxQztBQUNGO0FBQ0EyMUIsb0JBQW9CclksSUFBSSxHQUFHLFNBQVNBLEtBQU0yUyxHQUFHLEVBQUVqd0IsQ0FBQyxFQUFFa2tCLENBQUM7SUFDakQsSUFBSWxrQixNQUFNa2tCLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDM0IsSUFBSyxJQUFJNFIsTUFBTSxHQUFHQSxNQUFNN0YsSUFBSXZqQixZQUFZLElBQUlvcEIsTUFBTztRQUNqRCxJQUFJN0wsTUFBTWdHLElBQUk1eUIsV0FBVyxDQUFDMkMsR0FBRzgxQjtRQUM3QjdGLElBQUloekIsV0FBVyxDQUFDK0MsR0FBRzgxQixLQUFLN0YsSUFBSTV5QixXQUFXLENBQUM2bUIsR0FBRzRSO1FBQzNDN0YsSUFBSWh6QixXQUFXLENBQUNpbkIsR0FBRzRSLEtBQUs3TDtJQUMxQjtBQUNGO0FBQ0EwTCxvQkFBb0IvM0IsSUFBSSxHQUFHLFNBQVNBLEtBQU15UCxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVuVSxNQUFNO0lBQzFFLElBQUssSUFBSTJHLElBQUksR0FBR0EsSUFBSTNHLFFBQVEyRyxJQUFLO1FBQy9CMjFCLG9CQUFvQkMsU0FBUyxDQUFDdm9CLEtBQUtDLFNBQVN0TixHQUFHdU4sTUFBTUMsVUFBVXhOO0lBQ2pFO0FBQ0Y7QUFDQTIxQixvQkFBb0I5M0IsUUFBUSxHQUFHLFNBQVNBO0lBQ3RDLElBQUluRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJazlCLEtBQUs3OEIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSTZTLE9BQU9ncUIsR0FBR2hxQixJQUFJO1FBQ2xCLElBQUlBLFNBQVMsR0FBRztZQUFFLE9BQU87UUFBSztRQUM5QixJQUFJdXBCLE1BQU1TLEdBQUc3cEIsWUFBWTtRQUN6QixJQUFJekksTUFBTSxJQUFJM0M7UUFDZDJDLElBQUl6QyxNQUFNLENBQUM7UUFDWCxJQUFLLElBQUl4QixJQUFJLEdBQUdBLElBQUl1TSxNQUFNdk0sSUFBSztZQUM3QixJQUFJQSxJQUFJLEdBQUc7Z0JBQUVpRSxJQUFJekMsTUFBTSxDQUFDO1lBQU07WUFDOUIsSUFBSyxJQUFJNkgsSUFBSSxHQUFHQSxJQUFJeXNCLEtBQUt6c0IsSUFBSztnQkFDNUIsSUFBSUEsSUFBSSxHQUFHO29CQUFFcEYsSUFBSXpDLE1BQU0sQ0FBQztnQkFBTTtnQkFDOUJ5QyxJQUFJekMsTUFBTSxDQUFDMnlCLFdBQVd0MkIsUUFBUSxDQUFDMDRCLEdBQUdsNUIsV0FBVyxDQUFDMkMsR0FBR3FKO1lBQ25EO1FBQ0Y7UUFDQXBGLElBQUl6QyxNQUFNLENBQUM7UUFDWCxPQUFPeUMsSUFBSXBHLFFBQVE7SUFDckI7QUFDRjtBQUNBODNCLG9CQUFvQmEsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQkgsSUFBSSxFQUFFcEcsR0FBRztJQUN2RSxJQUFJcjBCLElBQUlxMEIsSUFBSTFqQixJQUFJO0lBQ2hCLElBQUkzUSxNQUFNLEdBQUc7UUFBRSxPQUFPcTBCO0lBQUk7SUFDMUIsSUFBSXIwQixLQUFLLEdBQUc7UUFBRSxPQUFPKzVCLG9CQUFvQmMsZ0JBQWdCLENBQUNKLE1BQU1wRyxLQUFLO0lBQUc7SUFDeEUsSUFBSTRCLFdBQVc1QixJQUFJNXlCLFdBQVcsQ0FBQyxHQUFHK08sbUJBQW1CdFAsQ0FBQyxNQUFNbXpCLElBQUk1eUIsV0FBVyxDQUFDekIsSUFBSSxHQUFHd1EsbUJBQW1CdFAsQ0FBQyxLQUFLbXpCLElBQUk1eUIsV0FBVyxDQUFDLEdBQUcrTyxtQkFBbUJyUCxDQUFDLE1BQU1rekIsSUFBSTV5QixXQUFXLENBQUN6QixJQUFJLEdBQUd3USxtQkFBbUJyUCxDQUFDO0lBQ3BNLElBQUk4MEIsVUFBVTtRQUFFLE9BQU81QjtJQUFJO0lBQzNCLE9BQU8wRixvQkFBb0JjLGdCQUFnQixDQUFDSixNQUFNcEcsS0FBS3IwQixJQUFJO0FBQzdEO0FBQ0ErNUIsb0JBQW9CYyxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JKLElBQUksRUFBRXBHLEdBQUcsRUFBRTFqQixJQUFJO0lBQy9FLElBQUkrcEIsU0FBU0QsS0FBSzk2QixNQUFNLENBQUNnUixNQUFNMGpCLElBQUl2akIsWUFBWTtJQUMvQyxJQUFJOVEsSUFBSXEwQixJQUFJMWpCLElBQUk7SUFDaEJvcEIsb0JBQW9CLzNCLElBQUksQ0FBQ3F5QixLQUFLLEdBQUdxRyxRQUFRLEdBQUcxNkI7SUFDNUMsSUFBSyxJQUFJb0UsSUFBSXBFLEdBQUdvRSxJQUFJdU0sTUFBTXZNLElBQUs7UUFBRTIxQixvQkFBb0IvM0IsSUFBSSxDQUFDcXlCLEtBQUssR0FBR3FHLFFBQVF0MkIsR0FBRztJQUFJO0lBQ2pGLE9BQU9zMkI7QUFDVDtBQUVBLElBQUl2RCxhQUFjLFNBQVUxQyxXQUFXO0lBQ3JDLFNBQVMwQyxXQUFZbmUsTUFBTSxFQUFFc00sT0FBTztRQUNsQ21QLFlBQVlsMUIsSUFBSSxDQUFDLElBQUksRUFBRStsQjtRQUN2QixJQUFJLENBQUN6TixPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNyUixJQUFJLENBQUN3UztJQUNaO0lBRUEsSUFBS3liLGFBQWMwQyxXQUFXejNCLFNBQVMsR0FBRyswQjtJQUMxQzBDLFdBQVduNkIsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFODBCLGVBQWVBLFlBQVl6M0IsU0FBUztJQUMxRW02QixXQUFXbjZCLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3UzQjtJQUVuQyxJQUFJcDJCLGtCQUFrQjtRQUFFRSxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztJQUFFO0lBQ2pFZzZCLFdBQVduNkIsU0FBUyxDQUFDZ3JCLHVCQUF1QixHQUFHLFNBQVNBO1FBQ3RELElBQUksSUFBSSxDQUFDbFIsT0FBTyxJQUFJO1lBQ2xCLE9BQU8sSUFBSTVEO1FBQ2I7UUFDQSxPQUFPLElBQUksQ0FBQzJFLE9BQU8sQ0FBQzdHLGNBQWMsQ0FBQyxJQUFJa0M7SUFDekM7SUFDQWlrQixXQUFXbjZCLFNBQVMsQ0FBQ213QixNQUFNLEdBQUcsU0FBU0E7UUFDckMsT0FBTyxJQUFJLENBQUM4SSxRQUFRLE1BQU0sSUFBSSxDQUFDNkUsUUFBUTtJQUN6QztJQUNBM0QsV0FBV242QixTQUFTLENBQUN1cEIsWUFBWSxHQUFHLFNBQVNBO1FBQzNDLE9BQU9rTyxZQUFZMU8sb0JBQW9CO0lBQ3pDO0lBQ0FvUixXQUFXbjZCLFNBQVMsQ0FBQzAzQixjQUFjLEdBQUcsU0FBU0E7UUFDN0MsT0FBTyxJQUFJLENBQUM3YyxPQUFPLENBQUMxRyxpQkFBaUI7SUFDdkM7SUFDQWdtQixXQUFXbjZCLFNBQVMsQ0FBQzhwQixXQUFXLEdBQUcsU0FBU0E7UUFDMUMsSUFBSXhQLFNBQVMsSUFBSTtRQUVqQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSStELFFBQVExRCxTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJb0IsWUFBWXBCLFNBQVMsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUNnM0IsaUJBQWlCLENBQUN0ekIsUUFBUTtnQkFDbEMsT0FBTztZQUNUO1lBQ0EsSUFBSXU1QixrQkFBa0J2NUI7WUFDdEIsSUFBSSxJQUFJLENBQUNxVyxPQUFPLENBQUNsSCxJQUFJLE9BQU9vcUIsZ0JBQWdCbGpCLE9BQU8sQ0FBQ2xILElBQUksSUFBSTtnQkFDMUQsT0FBTztZQUNUO1lBQ0EsSUFBSyxJQUFJdk0sSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3lULE9BQU8sQ0FBQ2xILElBQUksSUFBSXZNLElBQUs7Z0JBQzVDLElBQUksQ0FBQ2tULE9BQU91USxLQUFLLENBQUN2USxPQUFPTyxPQUFPLENBQUNqSCxhQUFhLENBQUN4TSxJQUFJMjJCLGdCQUFnQmxqQixPQUFPLENBQUNqSCxhQUFhLENBQUN4TSxJQUFJbEYsWUFBWTtvQkFDdkcsT0FBTztnQkFDVDtZQUNGO1lBQ0EsT0FBTztRQUNULE9BQU87WUFBRSxPQUFPdTFCLFlBQVl6M0IsU0FBUyxDQUFDOHBCLFdBQVcsQ0FBQ3ZRLEtBQUssQ0FBQyxJQUFJLEVBQUV6WTtRQUFXO0lBQzNFO0lBQ0FxNUIsV0FBV242QixTQUFTLENBQUM4cUIsU0FBUyxHQUFHLFNBQVNBO1FBQ3hDLElBQUl4USxTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJMUcsS0FBS2UsS0FBSyxDQUFDLElBQUksQ0FBQ29aLE9BQU8sQ0FBQ2xILElBQUksS0FBSyxJQUFJdk0sSUFBSztZQUM1RCxJQUFJa2tCLElBQUloUixPQUFPTyxPQUFPLENBQUNsSCxJQUFJLEtBQUssSUFBSXZNO1lBQ3BDLElBQUksQ0FBQ2tULE9BQU9PLE9BQU8sQ0FBQ2pILGFBQWEsQ0FBQ3hNLEdBQUd6QyxNQUFNLENBQUMyVixPQUFPTyxPQUFPLENBQUNqSCxhQUFhLENBQUMwWCxLQUFLO2dCQUM1RSxJQUFJaFIsT0FBT08sT0FBTyxDQUFDakgsYUFBYSxDQUFDeE0sR0FBR3ZDLFNBQVMsQ0FBQ3lWLE9BQU9PLE9BQU8sQ0FBQ2pILGFBQWEsQ0FBQzBYLE1BQU0sR0FBRztvQkFDbEZ5UixvQkFBb0I1TCxPQUFPLENBQUM3VyxPQUFPTyxPQUFPO2dCQUM1QztnQkFDQSxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0FzZixXQUFXbjZCLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQTtRQUM1QyxJQUFJLElBQUksQ0FBQ2tHLE9BQU8sSUFBSTtZQUFFLE9BQU87UUFBSztRQUNsQyxPQUFPLElBQUksQ0FBQ2UsT0FBTyxDQUFDakgsYUFBYSxDQUFDO0lBQ3BDO0lBQ0F1bUIsV0FBV242QixTQUFTLENBQUNnNEIsb0JBQW9CLEdBQUcsU0FBU0E7UUFDbkQsSUFBSSxJQUFJLENBQUNpQixRQUFRLElBQUk7WUFDbkIsT0FBTy9DLFVBQVVJLEtBQUs7UUFDeEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQTZELFdBQVduNkIsU0FBUyxDQUFDaTVCLFFBQVEsR0FBRyxTQUFTQTtRQUN2QyxJQUFJLElBQUksQ0FBQ25mLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQzJnQixjQUFjLENBQUMsR0FBR2wyQixRQUFRLENBQUMsSUFBSSxDQUFDazJCLGNBQWMsQ0FBQyxJQUFJLENBQUM5QyxZQUFZLEtBQUs7SUFDbkY7SUFDQXdDLFdBQVduNkIsU0FBUyxDQUFDdTZCLFdBQVcsR0FBRyxTQUFTQTtRQUMxQyxJQUFJLElBQUksQ0FBQ3pnQixPQUFPLElBQUk7WUFDbEIsT0FBTztRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUNra0IsU0FBUyxDQUFDLElBQUksQ0FBQ3JHLFlBQVksS0FBSztJQUM5QztJQUNBd0MsV0FBV242QixTQUFTLENBQUM4VCxZQUFZLEdBQUcsU0FBU0E7UUFDM0MsT0FBTztJQUNUO0lBQ0FxbUIsV0FBV242QixTQUFTLENBQUNtcUIsU0FBUyxHQUFHLFNBQVNBO1FBQ3hDLE9BQU8zSSxhQUFhd0YsYUFBYSxDQUFDLElBQUksQ0FBQ25NLE9BQU87SUFDaEQ7SUFDQXNmLFdBQVduNkIsU0FBUyxDQUFDMjNCLFlBQVksR0FBRyxTQUFTQTtRQUMzQyxPQUFPLElBQUksQ0FBQzljLE9BQU8sQ0FBQ2xILElBQUk7SUFDMUI7SUFDQXdtQixXQUFXbjZCLFNBQVMsQ0FBQ214QixPQUFPLEdBQUcsU0FBU0E7UUFDdEMsSUFBSWtHLE1BQU0sSUFBSSxDQUFDeGMsT0FBTyxDQUFDN1YsSUFBSTtRQUMzQiszQixvQkFBb0I1TCxPQUFPLENBQUNrRztRQUM1QixJQUFJNEcsVUFBVSxJQUFJLENBQUN6VSxVQUFVLEdBQUdyTixnQkFBZ0IsQ0FBQ2tiO1FBQ2pELE9BQU80RztJQUNUO0lBQ0E5RCxXQUFXbjZCLFNBQVMsQ0FBQ3FxQixrQkFBa0IsR0FBRyxTQUFTQTtRQUNqRCxJQUFJL1AsU0FBUyxJQUFJO1FBRWpCLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJcUUsSUFBSWhFLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUl3YixPQUFPeFg7WUFDWCxJQUFJc0MsSUFBSTtZQUNSLElBQUlra0IsSUFBSTtZQUNSLE1BQU9sa0IsSUFBSSxJQUFJLENBQUN5VCxPQUFPLENBQUNsSCxJQUFJLE1BQU0yWCxJQUFJaFAsS0FBS3pCLE9BQU8sQ0FBQ2xILElBQUksR0FBSTtnQkFDekQsSUFBSStYLGFBQWFwUixPQUFPTyxPQUFPLENBQUNqSCxhQUFhLENBQUN4TSxHQUFHdkMsU0FBUyxDQUFDeVgsS0FBS3pCLE9BQU8sQ0FBQ2pILGFBQWEsQ0FBQzBYO2dCQUN0RixJQUFJSSxlQUFlLEdBQUc7b0JBQ3BCLE9BQU9BO2dCQUNUO2dCQUNBdGtCO2dCQUNBa2tCO1lBQ0Y7WUFDQSxJQUFJbGtCLElBQUksSUFBSSxDQUFDeVQsT0FBTyxDQUFDbEgsSUFBSSxJQUFJO2dCQUMzQixPQUFPO1lBQ1Q7WUFDQSxJQUFJMlgsSUFBSWhQLEtBQUt6QixPQUFPLENBQUNsSCxJQUFJLElBQUk7Z0JBQzNCLE9BQU8sQ0FBQztZQUNWO1lBQ0EsT0FBTztRQUNULE9BQU8sSUFBSTdTLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUk2M0IsTUFBTXgzQixTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJeXBCLE9BQU96cEIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSW85QixTQUFTNUY7WUFDYixPQUFPL04sS0FBS3ZrQixPQUFPLENBQUMsSUFBSSxDQUFDNlUsT0FBTyxFQUFFcWpCLE9BQU9yakIsT0FBTztRQUNsRDtJQUNGO0lBQ0FzZixXQUFXbjZCLFNBQVMsQ0FBQ3VaLEtBQUssR0FBRyxTQUFTQTtRQUNwQyxJQUFJZSxTQUFTLElBQUk7UUFFakIsSUFBSW5ULGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFaXJCLG1CQUFtQjtZQUNoRCxJQUFJNUQsU0FBU3JuQixTQUFTLENBQUMsRUFBRTtZQUN6QixJQUFLLElBQUlzRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDeVQsT0FBTyxDQUFDbEgsSUFBSSxJQUFJdk0sSUFBSztnQkFDNUMrZ0IsT0FBT0EsTUFBTSxDQUFDN04sT0FBT08sT0FBTyxDQUFDakgsYUFBYSxDQUFDeE07WUFDN0M7UUFDRixPQUFPLElBQUlELGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFczJCLDJCQUEyQjtZQUMvRCxJQUFJdUIsV0FBVzczQixTQUFTLENBQUMsRUFBRTtZQUMzQixJQUFJLElBQUksQ0FBQytaLE9BQU8sQ0FBQ2xILElBQUksT0FBTyxHQUFHO2dCQUFFLE9BQU87WUFBSztZQUM3QyxJQUFLLElBQUlpUyxNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDL0ssT0FBTyxDQUFDbEgsSUFBSSxJQUFJaVMsTUFBTztnQkFDbEQrUyxTQUFTeFEsTUFBTSxDQUFDN04sT0FBT08sT0FBTyxFQUFFK0s7Z0JBQ2hDLElBQUkrUyxTQUFTckIsTUFBTSxJQUFJO29CQUFFO2dCQUFNO1lBQ2pDO1lBQ0EsSUFBSXFCLFNBQVNwQixpQkFBaUIsSUFBSTtnQkFBRSxJQUFJLENBQUN4TixlQUFlO1lBQUk7UUFDOUQsT0FBTyxJQUFJNWlCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFcTJCLGlCQUFpQjtZQUNyRCxJQUFJeUIsV0FBVzkzQixTQUFTLENBQUMsRUFBRTtZQUMzQjgzQixTQUFTelEsTUFBTSxDQUFDLElBQUk7UUFDdEIsT0FBTyxJQUFJaGhCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFb25CLDBCQUEwQjtZQUM5RCxJQUFJMlEsV0FBVy8zQixTQUFTLENBQUMsRUFBRTtZQUMzQiszQixTQUFTMVEsTUFBTSxDQUFDLElBQUk7UUFDdEI7SUFDRjtJQUNBZ1MsV0FBV242QixTQUFTLENBQUM4NEIsV0FBVyxHQUFHLFNBQVNBO1FBQzFDLE9BQU8sSUFBSU0sV0FBVyxJQUFJLEVBQUVOLFdBQVc7SUFDekM7SUFDQXFCLFdBQVduNkIsU0FBUyxDQUFDODNCLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQnR6QixLQUFLO1FBQ3hFLE9BQU9BLGlCQUFpQjIxQjtJQUMxQjtJQUNBQSxXQUFXbjZCLFNBQVMsQ0FBQytFLEtBQUssR0FBRyxTQUFTQTtRQUNwQyxJQUFJbzVCLEtBQUsxRyxZQUFZejNCLFNBQVMsQ0FBQytFLEtBQUssQ0FBQ3hDLElBQUksQ0FBQyxJQUFJO1FBQzlDNDdCLEdBQUd0akIsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDOVYsS0FBSztRQUMvQixPQUFPbzVCO0lBQ1Q7SUFDQWhFLFdBQVduNkIsU0FBUyxDQUFDeTZCLGNBQWMsR0FBRyxTQUFTQSxlQUFnQnozQixDQUFDO1FBQzlELE9BQU8sSUFBSSxDQUFDNlgsT0FBTyxDQUFDakgsYUFBYSxDQUFDNVE7SUFDcEM7SUFDQW0zQixXQUFXbjZCLFNBQVMsQ0FBQzBaLGVBQWUsR0FBRyxTQUFTQTtRQUM5QyxPQUFPO0lBQ1Q7SUFDQXlnQixXQUFXbjZCLFNBQVMsQ0FBQ2dGLElBQUksR0FBRyxTQUFTQTtRQUNuQyxPQUFPLElBQUltMUIsV0FBVyxJQUFJLENBQUN0ZixPQUFPLENBQUM3VixJQUFJLElBQUksSUFBSSxDQUFDd2pCLFFBQVE7SUFDMUQ7SUFDQTJSLFdBQVduNkIsU0FBUyxDQUFDbytCLHFCQUFxQixHQUFHLFNBQVNBO1FBQ3BELE9BQU8sSUFBSSxDQUFDdmpCLE9BQU87SUFDckI7SUFDQXNmLFdBQVduNkIsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBO1FBQ3RDLE9BQU8sSUFBSSxDQUFDZSxPQUFPLENBQUNsSCxJQUFJLE9BQU87SUFDakM7SUFDQXdtQixXQUFXbjZCLFNBQVMsQ0FBQ3dKLElBQUksR0FBRyxTQUFTQSxLQUFNd1MsTUFBTTtRQUMvQyxJQUFJQSxXQUFXLE1BQU07WUFDbkJBLFNBQVMsSUFBSSxDQUFDd04sVUFBVSxHQUFHNlUsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDLEVBQUU7UUFDckU7UUFDQSxJQUFJcVosT0FBT3JJLElBQUksT0FBTyxHQUFHO1lBQ3ZCLE1BQU0sSUFBSXZSLHlCQUF5QixtREFBbUQ0WixPQUFPckksSUFBSSxLQUFLO1FBQ3hHO1FBQ0EsSUFBSSxDQUFDa0gsT0FBTyxHQUFHbUI7SUFDakI7SUFDQW1lLFdBQVduNkIsU0FBUyxDQUFDcytCLFlBQVksR0FBRyxTQUFTQSxhQUFjemQsRUFBRTtRQUMzRCxJQUFJdkcsU0FBUyxJQUFJO1FBRWpCLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN5VCxPQUFPLENBQUNsSCxJQUFJLElBQUl2TSxJQUFLO1lBQzVDLElBQUlrVCxPQUFPTyxPQUFPLENBQUNqSCxhQUFhLENBQUN4TSxHQUFHekMsTUFBTSxDQUFDa2MsS0FBSztnQkFDOUMsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQXNaLFdBQVduNkIsU0FBUyxDQUFDczZCLGFBQWEsR0FBRyxTQUFTQTtRQUM1QyxJQUFJLElBQUksQ0FBQ3hnQixPQUFPLElBQUk7WUFDbEIsT0FBTztRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUNra0IsU0FBUyxDQUFDO0lBQ3hCO0lBQ0E3RCxXQUFXbjZCLFNBQVMsQ0FBQ2crQixTQUFTLEdBQUcsU0FBU0EsVUFBV2g3QixDQUFDO1FBQ3BELE9BQU8sSUFBSSxDQUFDd21CLFVBQVUsR0FBRzlOLFdBQVcsQ0FBQyxJQUFJLENBQUNiLE9BQU8sQ0FBQ2pILGFBQWEsQ0FBQzVRO0lBQ2xFO0lBQ0FtM0IsV0FBV242QixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDMUMsT0FBTztZQUFDeXpCO1NBQU87SUFDakI7SUFDQTZFLFdBQVduNkIsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ3ZDLE9BQU9xNEI7SUFDVDtJQUNBcDJCLGdCQUFnQkUsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztRQUFjLE9BQU87SUFBb0I7SUFFaEZuRCxPQUFPb0QsZ0JBQWdCLENBQUU4MkIsWUFBWXAyQjtJQUVyQyxPQUFPbzJCO0FBQ1QsRUFBRTlSO0FBRUYsSUFBSWtXLFNBQVMsU0FBU0EsVUFBVztBQUVqQ0EsT0FBT3YrQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdEMsT0FBTyxFQUFFO0FBQ1g7QUFDQTA4QixPQUFPditCLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuQyxPQUFPeThCO0FBQ1Q7QUFFQSxJQUFJQyxRQUFTLFNBQVUvRyxXQUFXO0lBQ2hDLFNBQVMrRyxNQUFPaE8sV0FBVyxFQUFFbEksT0FBTztRQUNsQ21QLFlBQVlsMUIsSUFBSSxDQUFDLElBQUksRUFBRStsQjtRQUN2QixJQUFJLENBQUNuTyxZQUFZLEdBQUdxVyxlQUFlO1FBQ25DLElBQUksQ0FBQ2huQixJQUFJLENBQUMsSUFBSSxDQUFDMlEsWUFBWTtJQUM3QjtJQUVBLElBQUtzZCxhQUFjK0csTUFBTTk3QixTQUFTLEdBQUcrMEI7SUFDckMrRyxNQUFNeCtCLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRTgwQixlQUFlQSxZQUFZejNCLFNBQVM7SUFDckV3K0IsTUFBTXgrQixTQUFTLENBQUM0QyxXQUFXLEdBQUc0N0I7SUFFOUIsSUFBSXo2QixrQkFBa0I7UUFBRUUsa0JBQWtCO1lBQUU5RCxjQUFjO1FBQUs7SUFBRTtJQUNqRXErQixNQUFNeCtCLFNBQVMsQ0FBQ2dyQix1QkFBdUIsR0FBRyxTQUFTQTtRQUNqRCxJQUFJLElBQUksQ0FBQ2xSLE9BQU8sSUFBSTtZQUNsQixPQUFPLElBQUk1RDtRQUNiO1FBQ0EsSUFBSWpDLE1BQU0sSUFBSWlDO1FBQ2RqQyxJQUFJc0QsZUFBZSxDQUFDLElBQUksQ0FBQzRDLFlBQVksQ0FBQ3BHLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQ29HLFlBQVksQ0FBQ2pHLElBQUksQ0FBQztRQUN0RSxPQUFPRDtJQUNUO0lBQ0F1cUIsTUFBTXgrQixTQUFTLENBQUN1cEIsWUFBWSxHQUFHLFNBQVNBO1FBQ3RDLE9BQU9rTyxZQUFZNU8sZUFBZTtJQUNwQztJQUNBMlYsTUFBTXgrQixTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO1FBQ3hDLE9BQU8sSUFBSSxDQUFDNWQsT0FBTyxLQUFLLEVBQUUsR0FBRztZQUFDLElBQUksQ0FBQ2xHLGFBQWE7U0FBRztJQUNyRDtJQUNBNHFCLE1BQU14K0IsU0FBUyxDQUFDOHBCLFdBQVcsR0FBRyxTQUFTQTtRQUNyQyxJQUFJaHBCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUkrRCxRQUFRMUQsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSW9CLFlBQVlwQixTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDZzNCLGlCQUFpQixDQUFDdHpCLFFBQVE7Z0JBQ2xDLE9BQU87WUFDVDtZQUNBLElBQUksSUFBSSxDQUFDc1YsT0FBTyxNQUFNdFYsTUFBTXNWLE9BQU8sSUFBSTtnQkFDckMsT0FBTztZQUNUO1lBQ0EsSUFBSSxJQUFJLENBQUNBLE9BQU8sT0FBT3RWLE1BQU1zVixPQUFPLElBQUk7Z0JBQ3RDLE9BQU87WUFDVDtZQUNBLE9BQU8sSUFBSSxDQUFDK1EsS0FBSyxDQUFDcm1CLE1BQU1vUCxhQUFhLElBQUksSUFBSSxDQUFDQSxhQUFhLElBQUkxUjtRQUNqRSxPQUFPO1lBQUUsT0FBT3UxQixZQUFZejNCLFNBQVMsQ0FBQzhwQixXQUFXLENBQUN2USxLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUMzRTtJQUNBMDlCLE1BQU14K0IsU0FBUyxDQUFDOHFCLFNBQVMsR0FBRyxTQUFTQSxhQUFjO0lBQ25EMFQsTUFBTXgrQixTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7UUFDdkMsT0FBTyxJQUFJLENBQUN1RyxZQUFZLENBQUN4RyxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUN3RyxZQUFZLENBQUN2RyxhQUFhLENBQUMsS0FBSztJQUMvRTtJQUNBNHFCLE1BQU14K0IsU0FBUyxDQUFDZzRCLG9CQUFvQixHQUFHLFNBQVNBO1FBQzlDLE9BQU85QixVQUFVSSxLQUFLO0lBQ3hCO0lBQ0FrSSxNQUFNeCtCLFNBQVMsQ0FBQzhULFlBQVksR0FBRyxTQUFTQTtRQUN0QyxPQUFPO0lBQ1Q7SUFDQTBxQixNQUFNeCtCLFNBQVMsQ0FBQzIzQixZQUFZLEdBQUcsU0FBU0E7UUFDdEMsT0FBTyxJQUFJLENBQUM3ZCxPQUFPLEtBQUssSUFBSTtJQUM5QjtJQUNBMGtCLE1BQU14K0IsU0FBUyxDQUFDbXhCLE9BQU8sR0FBRyxTQUFTQTtRQUNqQyxPQUFPLElBQUksQ0FBQ25zQixJQUFJO0lBQ2xCO0lBQ0F3NUIsTUFBTXgrQixTQUFTLENBQUMrVCxJQUFJLEdBQUcsU0FBU0E7UUFDOUIsSUFBSSxJQUFJLENBQUNILGFBQWEsT0FBTyxNQUFNO1lBQ2pDLE1BQU0sSUFBSXZSLE1BQU07UUFDbEI7UUFDQSxPQUFPLElBQUksQ0FBQ3VSLGFBQWEsR0FBR2xTLENBQUM7SUFDL0I7SUFDQTg4QixNQUFNeCtCLFNBQVMsQ0FBQ3FxQixrQkFBa0IsR0FBRyxTQUFTQTtRQUM1QyxJQUFJdnBCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUkrRCxRQUFRMUQsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSW9aLFVBQVUxVjtZQUNkLE9BQU8sSUFBSSxDQUFDb1AsYUFBYSxHQUFHL08sU0FBUyxDQUFDcVYsUUFBUXRHLGFBQWE7UUFDN0QsT0FBTyxJQUFJOVMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSTZwQixVQUFVeHBCLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLElBQUl5cEIsT0FBT3pwQixTQUFTLENBQUMsRUFBRTtZQUN2QixJQUFJbVosUUFBUXFRO1lBQ1osT0FBT0MsS0FBS3ZrQixPQUFPLENBQUMsSUFBSSxDQUFDbVUsWUFBWSxFQUFFRixNQUFNRSxZQUFZO1FBQzNEO0lBQ0Y7SUFDQXFrQixNQUFNeCtCLFNBQVMsQ0FBQ3VaLEtBQUssR0FBRyxTQUFTQTtRQUMvQixJQUFJcFMsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVpckIsbUJBQW1CO1lBQ2hELElBQUk1RCxTQUFTcm5CLFNBQVMsQ0FBQyxFQUFFO1lBQ3pCLElBQUksSUFBSSxDQUFDZ1osT0FBTyxJQUFJO2dCQUNsQixPQUFPO1lBQ1Q7WUFDQXFPLE9BQU9BLE1BQU0sQ0FBQyxJQUFJLENBQUN2VSxhQUFhO1FBQ2xDLE9BQU8sSUFBSXpNLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFczJCLDJCQUEyQjtZQUMvRCxJQUFJdUIsV0FBVzczQixTQUFTLENBQUMsRUFBRTtZQUMzQixJQUFJLElBQUksQ0FBQ2daLE9BQU8sSUFBSTtnQkFBRSxPQUFPO1lBQUs7WUFDbEM2ZSxTQUFTeFEsTUFBTSxDQUFDLElBQUksQ0FBQ2hPLFlBQVksRUFBRTtZQUNuQyxJQUFJd2UsU0FBU3BCLGlCQUFpQixJQUFJO2dCQUFFLElBQUksQ0FBQ3hOLGVBQWU7WUFBSTtRQUM5RCxPQUFPLElBQUk1aUIsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVxMkIsaUJBQWlCO1lBQ3JELElBQUl5QixXQUFXOTNCLFNBQVMsQ0FBQyxFQUFFO1lBQzNCODNCLFNBQVN6USxNQUFNLENBQUMsSUFBSTtRQUN0QixPQUFPLElBQUloaEIsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVvbkIsMEJBQTBCO1lBQzlELElBQUkyUSxXQUFXLzNCLFNBQVMsQ0FBQyxFQUFFO1lBQzNCKzNCLFNBQVMxUSxNQUFNLENBQUMsSUFBSTtRQUN0QjtJQUNGO0lBQ0FxVyxNQUFNeCtCLFNBQVMsQ0FBQzg0QixXQUFXLEdBQUcsU0FBU0E7UUFDckMsT0FBTyxJQUFJLENBQUN0UCxVQUFVLEdBQUd2TSx3QkFBd0IsQ0FBQztJQUNwRDtJQUNBdWhCLE1BQU14K0IsU0FBUyxDQUFDK0UsS0FBSyxHQUFHLFNBQVNBO1FBQy9CLElBQUlpUSxJQUFJeWlCLFlBQVl6M0IsU0FBUyxDQUFDK0UsS0FBSyxDQUFDeEMsSUFBSSxDQUFDLElBQUk7UUFDN0N5UyxFQUFFbUYsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxDQUFDcFYsS0FBSztRQUN4QyxPQUFPaVE7SUFDVDtJQUNBd3BCLE1BQU14K0IsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVNBO1FBQ3pDLE9BQU87SUFDVDtJQUNBOGtCLE1BQU14K0IsU0FBUyxDQUFDZ0YsSUFBSSxHQUFHLFNBQVNBO1FBQzlCLE9BQU8sSUFBSXc1QixNQUFNLElBQUksQ0FBQ3JrQixZQUFZLENBQUNuVixJQUFJLElBQUksSUFBSSxDQUFDd2pCLFFBQVE7SUFDMUQ7SUFDQWdXLE1BQU14K0IsU0FBUyxDQUFDbytCLHFCQUFxQixHQUFHLFNBQVNBO1FBQy9DLE9BQU8sSUFBSSxDQUFDamtCLFlBQVk7SUFDMUI7SUFDQXFrQixNQUFNeCtCLFNBQVMsQ0FBQ2tVLElBQUksR0FBRyxTQUFTQTtRQUM5QixJQUFJLElBQUksQ0FBQ04sYUFBYSxPQUFPLE1BQU07WUFDakMsTUFBTSxJQUFJdlIsTUFBTTtRQUNsQjtRQUNBLE9BQU8sSUFBSSxDQUFDdVIsYUFBYSxHQUFHalEsQ0FBQztJQUMvQjtJQUNBNjZCLE1BQU14K0IsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBO1FBQ2pDLE9BQU8sSUFBSSxDQUFDSyxZQUFZLENBQUN4RyxJQUFJLE9BQU87SUFDdEM7SUFDQTZxQixNQUFNeCtCLFNBQVMsQ0FBQ3dKLElBQUksR0FBRyxTQUFTQSxLQUFNZ25CLFdBQVc7UUFDL0MsSUFBSUEsZ0JBQWdCLE1BQU07WUFDeEJBLGNBQWMsSUFBSSxDQUFDaEgsVUFBVSxHQUFHNlUsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDLEVBQUU7UUFDMUU7UUFDQSthLE9BQU9FLE1BQU0sQ0FBQzRTLFlBQVk3YyxJQUFJLE1BQU07UUFDcEMsSUFBSSxDQUFDd0csWUFBWSxHQUFHcVc7SUFDdEI7SUFDQWdPLE1BQU14K0IsU0FBUyxDQUFDODlCLFFBQVEsR0FBRyxTQUFTQTtRQUNsQyxPQUFPO0lBQ1Q7SUFDQVUsTUFBTXgrQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDckMsT0FBTztZQUFDMDhCO1NBQU87SUFDakI7SUFDQUMsTUFBTXgrQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDbEMsT0FBTzA4QjtJQUNUO0lBQ0F6NkIsZ0JBQWdCRSxnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO1FBQWMsT0FBTztJQUFvQjtJQUVoRm5ELE9BQU9vRCxnQkFBZ0IsQ0FBRW03QixPQUFPejZCO0lBRWhDLE9BQU95NkI7QUFDVCxFQUFFblc7QUFFRixJQUFJb1csWUFBWSxTQUFTQSxhQUFjO0FBRXZDQSxVQUFVeitCLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN6QyxPQUFPLEVBQUU7QUFDWDtBQUNBNDhCLFVBQVV6K0IsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3RDLE9BQU8yOEI7QUFDVDtBQUVBLElBQUlDLFVBQVcsU0FBVWpILFdBQVc7SUFDbEMsU0FBU2lILFFBQVM5aEIsS0FBSyxFQUFFQyxLQUFLLEVBQUV5TCxPQUFPO1FBQ3JDbVAsWUFBWWwxQixJQUFJLENBQUMsSUFBSSxFQUFFK2xCO1FBQ3ZCLElBQUksQ0FBQ2xOLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSXVCLFVBQVUsTUFBTTtZQUNsQkEsUUFBUSxJQUFJLENBQUM0TSxVQUFVLEdBQUdwTixnQkFBZ0I7UUFDNUM7UUFDQSxJQUFJUyxVQUFVLE1BQU07WUFDbEJBLFFBQVEsRUFBRTtRQUNaO1FBQ0EsSUFBSTRhLFlBQVkzTCxlQUFlLENBQUNqUCxRQUFRO1lBQ3RDLE1BQU0sSUFBSXphLHlCQUF5QjtRQUNyQztRQUNBLElBQUl3YSxNQUFNOUMsT0FBTyxNQUFNMmQsWUFBWTdMLG1CQUFtQixDQUFDL08sUUFBUTtZQUM3RCxNQUFNLElBQUl6YSx5QkFBeUI7UUFDckM7UUFDQSxJQUFJLENBQUNnWixNQUFNLEdBQUd3QjtRQUNkLElBQUksQ0FBQ3ZCLE1BQU0sR0FBR3dCO0lBQ2hCO0lBRUEsSUFBSzRhLGFBQWNpSCxRQUFRaDhCLFNBQVMsR0FBRyswQjtJQUN2Q2lILFFBQVExK0IsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFODBCLGVBQWVBLFlBQVl6M0IsU0FBUztJQUN2RTArQixRQUFRMStCLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzg3QjtJQUVoQyxJQUFJMzZCLGtCQUFrQjtRQUFFRSxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztJQUFFO0lBQ2pFdStCLFFBQVExK0IsU0FBUyxDQUFDZ3JCLHVCQUF1QixHQUFHLFNBQVNBO1FBQ25ELE9BQU8sSUFBSSxDQUFDNVAsTUFBTSxDQUFDdVAsbUJBQW1CO0lBQ3hDO0lBQ0ErVCxRQUFRMStCLFNBQVMsQ0FBQ3VwQixZQUFZLEdBQUcsU0FBU0E7UUFDeEMsT0FBT2tPLFlBQVl2TyxpQkFBaUI7SUFDdEM7SUFDQXdWLFFBQVExK0IsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQTtRQUMxQyxJQUFJcGQsU0FBUyxJQUFJO1FBRWpCLElBQUksSUFBSSxDQUFDUixPQUFPLElBQUk7WUFDbEIsT0FBTyxFQUFFO1FBQ1g7UUFDQSxJQUFJMFcsY0FBYyxJQUFJendCLE1BQU0sSUFBSSxDQUFDNDNCLFlBQVksSUFBSXQzQixJQUFJLENBQUM7UUFDdEQsSUFBSXNrQixJQUFJLENBQUM7UUFDVCxJQUFJZ2EsbUJBQW1CLElBQUksQ0FBQ3ZqQixNQUFNLENBQUNzYyxjQUFjO1FBQ2pELElBQUssSUFBSWgyQixJQUFJLEdBQUdBLElBQUlpOUIsaUJBQWlCbCtCLE1BQU0sRUFBRWlCLElBQUs7WUFDaERpakI7WUFDQTZMLFdBQVcsQ0FBQzdMLEVBQUUsR0FBR2dhLGdCQUFnQixDQUFDajlCLEVBQUU7UUFDdEM7UUFDQSxJQUFLLElBQUkwRixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsTUFBTSxDQUFDNWEsTUFBTSxFQUFFMkcsSUFBSztZQUMzQyxJQUFJd3dCLG1CQUFtQnRkLE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsQ0FBQ3N3QixjQUFjO1lBQ3RELElBQUssSUFBSXBNLElBQUksR0FBR0EsSUFBSXNNLGlCQUFpQm4zQixNQUFNLEVBQUU2cUIsSUFBSztnQkFDaEQzRztnQkFDQTZMLFdBQVcsQ0FBQzdMLEVBQUUsR0FBR2lULGdCQUFnQixDQUFDdE0sRUFBRTtZQUN0QztRQUNGO1FBQ0EsT0FBT2tGO0lBQ1Q7SUFDQWtPLFFBQVExK0IsU0FBUyxDQUFDd1csT0FBTyxHQUFHLFNBQVNBO1FBQ25DLElBQUk4RCxTQUFTLElBQUk7UUFFakIsSUFBSXVkLE9BQU87UUFDWEEsUUFBUW4zQixLQUFLeUIsR0FBRyxDQUFDcWYsYUFBYTJFLFVBQVUsQ0FBQyxJQUFJLENBQUMvSyxNQUFNLENBQUNnakIscUJBQXFCO1FBQzFFLElBQUssSUFBSWgzQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsTUFBTSxDQUFDNWEsTUFBTSxFQUFFMkcsSUFBSztZQUMzQ3l3QixRQUFRbjNCLEtBQUt5QixHQUFHLENBQUNxZixhQUFhMkUsVUFBVSxDQUFDN0wsT0FBT2UsTUFBTSxDQUFDalUsRUFBRSxDQUFDZzNCLHFCQUFxQjtRQUNqRjtRQUNBLE9BQU92RztJQUNUO0lBQ0E2RyxRQUFRMStCLFNBQVMsQ0FBQzBwQixXQUFXLEdBQUcsU0FBU0E7UUFDdkMsSUFBSSxJQUFJLENBQUNrVixrQkFBa0IsT0FBTyxHQUFHO1lBQUUsT0FBTztRQUFNO1FBQ3BELElBQUksSUFBSSxDQUFDeGpCLE1BQU0sS0FBSyxNQUFNO1lBQUUsT0FBTztRQUFNO1FBQ3pDLElBQUksSUFBSSxDQUFDQSxNQUFNLENBQUN1YyxZQUFZLE9BQU8sR0FBRztZQUFFLE9BQU87UUFBTTtRQUNyRCxJQUFJTixNQUFNLElBQUksQ0FBQ2pjLE1BQU0sQ0FBQ2dqQixxQkFBcUI7UUFDM0MsSUFBSW5xQixNQUFNLElBQUksQ0FBQzBXLG1CQUFtQjtRQUNsQyxJQUFLLElBQUl2akIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUIsSUFBSTFGLElBQUkyMUIsSUFBSXRqQixJQUFJLENBQUMzTTtZQUNqQixJQUFJLENBQUUxRixDQUFBQSxNQUFNdVMsSUFBSThDLE9BQU8sTUFBTXJWLE1BQU11UyxJQUFJNEMsT0FBTyxFQUFDLEdBQUk7Z0JBQUUsT0FBTztZQUFNO1lBQ2xFLElBQUlsVCxJQUFJMHpCLElBQUluakIsSUFBSSxDQUFDOU07WUFDakIsSUFBSSxDQUFFekQsQ0FBQUEsTUFBTXNRLElBQUkrQyxPQUFPLE1BQU1yVCxNQUFNc1EsSUFBSTZDLE9BQU8sRUFBQyxHQUFJO2dCQUFFLE9BQU87WUFBTTtRQUNwRTtRQUNBLElBQUkrbkIsUUFBUXhILElBQUl0akIsSUFBSSxDQUFDO1FBQ3JCLElBQUkrcUIsUUFBUXpILElBQUluakIsSUFBSSxDQUFDO1FBQ3JCLElBQUssSUFBSTBSLE1BQU0sR0FBR0EsT0FBTyxHQUFHQSxNQUFPO1lBQ2pDLElBQUkzZCxNQUFNb3ZCLElBQUl0akIsSUFBSSxDQUFDNlI7WUFDbkIsSUFBSXpaLE1BQU1rckIsSUFBSW5qQixJQUFJLENBQUMwUjtZQUNuQixJQUFJbVosV0FBVzkyQixRQUFRNDJCO1lBQ3ZCLElBQUlHLFdBQVc3eUIsUUFBUTJ5QjtZQUN2QixJQUFJQyxhQUFhQyxVQUFVO2dCQUFFLE9BQU87WUFBTTtZQUMxQ0gsUUFBUTUyQjtZQUNSNjJCLFFBQVEzeUI7UUFDVjtRQUNBLE9BQU87SUFDVDtJQUNBdXlCLFFBQVExK0IsU0FBUyxDQUFDOHBCLFdBQVcsR0FBRyxTQUFTQTtRQUN2QyxJQUFJeFAsU0FBUyxJQUFJO1FBRWpCLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJK0QsUUFBUTFELFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUlvQixZQUFZcEIsU0FBUyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQ2czQixpQkFBaUIsQ0FBQ3R6QixRQUFRO2dCQUNsQyxPQUFPO1lBQ1Q7WUFDQSxJQUFJeTZCLGVBQWV6NkI7WUFDbkIsSUFBSTA2QixZQUFZLElBQUksQ0FBQzlqQixNQUFNO1lBQzNCLElBQUkrakIsb0JBQW9CRixhQUFhN2pCLE1BQU07WUFDM0MsSUFBSSxDQUFDOGpCLFVBQVVwVixXQUFXLENBQUNxVixtQkFBbUJqOUIsWUFBWTtnQkFDeEQsT0FBTztZQUNUO1lBQ0EsSUFBSSxJQUFJLENBQUNtWixNQUFNLENBQUM1YSxNQUFNLEtBQUt3K0IsYUFBYTVqQixNQUFNLENBQUM1YSxNQUFNLEVBQUU7Z0JBQ3JELE9BQU87WUFDVDtZQUNBLElBQUssSUFBSTJHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpVSxNQUFNLENBQUM1YSxNQUFNLEVBQUUyRyxJQUFLO2dCQUMzQyxJQUFJLENBQUNrVCxPQUFPZSxNQUFNLENBQUNqVSxFQUFFLENBQUMwaUIsV0FBVyxDQUFDbVYsYUFBYTVqQixNQUFNLENBQUNqVSxFQUFFLEVBQUVsRixZQUFZO29CQUNwRSxPQUFPO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPO1FBQ1QsT0FBTztZQUFFLE9BQU91MUIsWUFBWXozQixTQUFTLENBQUM4cEIsV0FBVyxDQUFDdlEsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDM0U7SUFDQTQ5QixRQUFRMStCLFNBQVMsQ0FBQzhxQixTQUFTLEdBQUcsU0FBU0E7UUFDckMsSUFBSXhRLFNBQVMsSUFBSTtRQUVqQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSSxDQUFDcXFCLFNBQVMsQ0FBQyxJQUFJLENBQUMxUCxNQUFNLEVBQUU7WUFDNUIsSUFBSyxJQUFJaFUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lVLE1BQU0sQ0FBQzVhLE1BQU0sRUFBRTJHLElBQUs7Z0JBQzNDa1QsT0FBT3dRLFNBQVMsQ0FBQ3hRLE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsRUFBRTtZQUNyQztZQUNBd3VCLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUN4YSxNQUFNO1FBQ3pCLE9BQU8sSUFBSXZhLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUlpYyxPQUFPNWIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSXMrQixZQUFZdCtCLFNBQVMsQ0FBQyxFQUFFO1lBQzVCLElBQUk0YixLQUFLNUMsT0FBTyxJQUFJO2dCQUNsQixPQUFPO1lBQ1Q7WUFDQSxJQUFJdWxCLG9CQUFvQixJQUFJdC9CLE1BQU0yYyxLQUFLZ2IsY0FBYyxHQUFHajNCLE1BQU0sR0FBRyxHQUFHSixJQUFJLENBQUM7WUFDekVrVSxPQUFPQyxTQUFTLENBQUNrSSxLQUFLZ2IsY0FBYyxJQUFJLEdBQUcySCxtQkFBbUIsR0FBR0Esa0JBQWtCNStCLE1BQU07WUFDekYsSUFBSXl4QixnQkFBZ0JuQyxpQkFBaUJtQyxhQUFhLENBQUN4VixLQUFLZ2IsY0FBYztZQUN0RTNILGlCQUFpQlEsTUFBTSxDQUFDOE8sbUJBQW1Cbk47WUFDM0MzZCxPQUFPQyxTQUFTLENBQUM2cUIsbUJBQW1CLEdBQUczaUIsS0FBS2diLGNBQWMsSUFBSSxHQUFHMkgsa0JBQWtCNStCLE1BQU07WUFDekZpYyxLQUFLZ2IsY0FBYyxFQUFFLENBQUMySCxrQkFBa0I1K0IsTUFBTSxDQUFDLEdBQUc0K0IsaUJBQWlCLENBQUMsRUFBRTtZQUN0RSxJQUFJN2QsYUFBYTJGLEtBQUssQ0FBQ3pLLEtBQUtnYixjQUFjLFFBQVEwSCxXQUFXO2dCQUMzRHJQLGlCQUFpQm9CLE9BQU8sQ0FBQ3pVLEtBQUtnYixjQUFjO1lBQzlDO1FBQ0Y7SUFDRjtJQUNBZ0gsUUFBUTErQixTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7UUFDekMsT0FBTyxJQUFJLENBQUN3SCxNQUFNLENBQUN4SCxhQUFhO0lBQ2xDO0lBQ0E4cUIsUUFBUTErQixTQUFTLENBQUM0K0Isa0JBQWtCLEdBQUcsU0FBU0E7UUFDOUMsT0FBTyxJQUFJLENBQUN2akIsTUFBTSxDQUFDNWEsTUFBTTtJQUMzQjtJQUNBaStCLFFBQVExK0IsU0FBUyxDQUFDZzRCLG9CQUFvQixHQUFHLFNBQVNBO1FBQ2hELE9BQU87SUFDVDtJQUNBMEcsUUFBUTErQixTQUFTLENBQUM4VCxZQUFZLEdBQUcsU0FBU0E7UUFDeEMsT0FBTztJQUNUO0lBQ0E0cUIsUUFBUTErQixTQUFTLENBQUNtcUIsU0FBUyxHQUFHLFNBQVNBO1FBQ3JDLElBQUk3UCxTQUFTLElBQUk7UUFFakIsSUFBSXBKLE1BQU07UUFDVkEsT0FBTyxJQUFJLENBQUNrSyxNQUFNLENBQUMrTyxTQUFTO1FBQzVCLElBQUssSUFBSS9pQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsTUFBTSxDQUFDNWEsTUFBTSxFQUFFMkcsSUFBSztZQUMzQzhKLE9BQU9vSixPQUFPZSxNQUFNLENBQUNqVSxFQUFFLENBQUMraUIsU0FBUztRQUNuQztRQUNBLE9BQU9qWjtJQUNUO0lBQ0F3dEIsUUFBUTErQixTQUFTLENBQUMyM0IsWUFBWSxHQUFHLFNBQVNBO1FBQ3hDLElBQUlyZCxTQUFTLElBQUk7UUFFakIsSUFBSTRkLFlBQVksSUFBSSxDQUFDOWMsTUFBTSxDQUFDdWMsWUFBWTtRQUN4QyxJQUFLLElBQUl2d0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lVLE1BQU0sQ0FBQzVhLE1BQU0sRUFBRTJHLElBQUs7WUFDM0M4d0IsYUFBYTVkLE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsQ0FBQ3V3QixZQUFZO1FBQzVDO1FBQ0EsT0FBT087SUFDVDtJQUNBd0csUUFBUTErQixTQUFTLENBQUNteEIsT0FBTyxHQUFHLFNBQVNBO1FBQ25DLElBQUk3VyxTQUFTLElBQUk7UUFFakIsSUFBSWdsQixPQUFPLElBQUksQ0FBQ3Q2QixJQUFJO1FBQ3BCczZCLEtBQUtsa0IsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDcFcsSUFBSSxHQUFHbXNCLE9BQU87UUFDeENtTyxLQUFLamtCLE1BQU0sR0FBRyxJQUFJdGIsTUFBTSxJQUFJLENBQUNzYixNQUFNLENBQUM1YSxNQUFNLEVBQUVKLElBQUksQ0FBQztRQUNqRCxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsTUFBTSxDQUFDNWEsTUFBTSxFQUFFMkcsSUFBSztZQUMzQ2s0QixLQUFLamtCLE1BQU0sQ0FBQ2pVLEVBQUUsR0FBR2tULE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsQ0FBQ3BDLElBQUksR0FBR21zQixPQUFPO1FBQ2xEO1FBQ0EsT0FBT21PO0lBQ1Q7SUFDQVosUUFBUTErQixTQUFTLENBQUN1L0IsVUFBVSxHQUFHLFNBQVNBO1FBQ3RDLE9BQU8sSUFBSSxDQUFDQyxlQUFlLEdBQUdELFVBQVU7SUFDMUM7SUFDQWIsUUFBUTErQixTQUFTLENBQUNxcUIsa0JBQWtCLEdBQUcsU0FBU0E7UUFDOUMsSUFBSS9QLFNBQVMsSUFBSTtRQUVqQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSXFFLElBQUloRSxTQUFTLENBQUMsRUFBRTtZQUNwQixJQUFJbytCLFlBQVksSUFBSSxDQUFDOWpCLE1BQU07WUFDM0IsSUFBSXFrQixhQUFhMzZCLEVBQUVzVyxNQUFNO1lBQ3pCLE9BQU84akIsVUFBVTdVLGtCQUFrQixDQUFDb1Y7UUFDdEMsT0FBTyxJQUFJMytCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUk2M0IsTUFBTXgzQixTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJeXBCLE9BQU96cEIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSXcrQixPQUFPaEg7WUFDWCxJQUFJb0gsY0FBYyxJQUFJLENBQUN0a0IsTUFBTTtZQUM3QixJQUFJdWtCLGVBQWVMLEtBQUtsa0IsTUFBTTtZQUM5QixJQUFJd2tCLFlBQVlGLFlBQVlyVixrQkFBa0IsQ0FBQ3NWLGNBQWNwVjtZQUM3RCxJQUFJcVYsY0FBYyxHQUFHO2dCQUFFLE9BQU9BO1lBQVU7WUFDeEMsSUFBSUMsU0FBUyxJQUFJLENBQUNqQixrQkFBa0I7WUFDcEMsSUFBSWtCLFNBQVNSLEtBQUtWLGtCQUFrQjtZQUNwQyxJQUFJeDNCLElBQUk7WUFDUixNQUFPQSxJQUFJeTRCLFVBQVV6NEIsSUFBSTA0QixPQUFRO2dCQUMvQixJQUFJQyxXQUFXemxCLE9BQU8wbEIsZ0JBQWdCLENBQUM1NEI7Z0JBQ3ZDLElBQUk2NEIsWUFBWVgsS0FBS1UsZ0JBQWdCLENBQUM1NEI7Z0JBQ3RDLElBQUlzeEIsV0FBV3FILFNBQVMxVixrQkFBa0IsQ0FBQzRWLFdBQVcxVjtnQkFDdEQsSUFBSW1PLGFBQWEsR0FBRztvQkFBRSxPQUFPQTtnQkFBUztnQkFDdEN0eEI7WUFDRjtZQUNBLElBQUlBLElBQUl5NEIsUUFBUTtnQkFBRSxPQUFPO1lBQUU7WUFDM0IsSUFBSXo0QixJQUFJMDRCLFFBQVE7Z0JBQUUsT0FBTyxDQUFDO1lBQUU7WUFDNUIsT0FBTztRQUNUO0lBQ0Y7SUFDQXBCLFFBQVExK0IsU0FBUyxDQUFDdVosS0FBSyxHQUFHLFNBQVNBLE1BQU80TyxNQUFNO1FBQzlDLElBQUk3TixTQUFTLElBQUk7UUFFakIsSUFBSW5ULGFBQWFnaEIsUUFBUTRELG1CQUFtQjtZQUMxQyxJQUFJLENBQUMzUSxNQUFNLENBQUM3QixLQUFLLENBQUM0TztZQUNsQixJQUFLLElBQUl2QyxNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDdkssTUFBTSxDQUFDNWEsTUFBTSxFQUFFbWxCLE1BQU87Z0JBQ2pEdEwsT0FBT2UsTUFBTSxDQUFDdUssSUFBSSxDQUFDck0sS0FBSyxDQUFDNE87WUFDM0I7UUFDRixPQUFPLElBQUloaEIsYUFBYWdoQixRQUFRaVAsMkJBQTJCO1lBQ3pELElBQUksQ0FBQ2hjLE1BQU0sQ0FBQzdCLEtBQUssQ0FBQzRPO1lBQ2xCLElBQUksQ0FBQ0EsT0FBT21QLE1BQU0sSUFBSTtnQkFDcEIsSUFBSyxJQUFJakksTUFBTSxHQUFHQSxNQUFNLElBQUksQ0FBQ2hVLE1BQU0sQ0FBQzVhLE1BQU0sRUFBRTR1QixNQUFPO29CQUNqRC9VLE9BQU9lLE1BQU0sQ0FBQ2dVLElBQUksQ0FBQzlWLEtBQUssQ0FBQzRPO29CQUN6QixJQUFJQSxPQUFPbVAsTUFBTSxJQUFJO3dCQUFFO29CQUFNO2dCQUMvQjtZQUNGO1lBQ0EsSUFBSW5QLE9BQU9vUCxpQkFBaUIsSUFBSTtnQkFBRSxJQUFJLENBQUN4TixlQUFlO1lBQUk7UUFDNUQsT0FBTyxJQUFJNWlCLGFBQWFnaEIsUUFBUWdQLGlCQUFpQjtZQUMvQ2hQLE9BQU9BLE1BQU0sQ0FBQyxJQUFJO1FBQ3BCLE9BQU8sSUFBSWhoQixhQUFhZ2hCLFFBQVFELDBCQUEwQjtZQUN4REMsT0FBT0EsTUFBTSxDQUFDLElBQUk7WUFDbEIsSUFBSSxDQUFDL00sTUFBTSxDQUFDN0IsS0FBSyxDQUFDNE87WUFDbEIsSUFBSyxJQUFJL2dCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpVSxNQUFNLENBQUM1YSxNQUFNLEVBQUUyRyxJQUFLO2dCQUMzQ2tULE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsQ0FBQ21TLEtBQUssQ0FBQzRPO1lBQ3pCO1FBQ0Y7SUFDRjtJQUNBdVcsUUFBUTErQixTQUFTLENBQUM4NEIsV0FBVyxHQUFHLFNBQVNBO1FBQ3ZDLElBQUl4ZSxTQUFTLElBQUk7UUFFakIsSUFBSSxJQUFJLENBQUNSLE9BQU8sSUFBSTtZQUNsQixPQUFPLElBQUksQ0FBQzBQLFVBQVUsR0FBR25OLHFCQUFxQjtRQUNoRDtRQUNBLElBQUlNLFFBQVEsSUFBSTVjLE1BQU0sSUFBSSxDQUFDc2IsTUFBTSxDQUFDNWEsTUFBTSxHQUFHLEdBQUdKLElBQUksQ0FBQztRQUNuRHNjLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDdkIsTUFBTTtRQUN0QixJQUFLLElBQUloVSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsTUFBTSxDQUFDNWEsTUFBTSxFQUFFMkcsSUFBSztZQUMzQ3VWLEtBQUssQ0FBQ3ZWLElBQUksRUFBRSxHQUFHa1QsT0FBT2UsTUFBTSxDQUFDalUsRUFBRTtRQUNqQztRQUNBLElBQUl1VixNQUFNbGMsTUFBTSxJQUFJLEdBQUc7WUFBRSxPQUFPLElBQUksQ0FBQytvQixVQUFVLEdBQUdwTixnQkFBZ0IsQ0FBQ08sS0FBSyxDQUFDLEVBQUUsQ0FBQ3loQixxQkFBcUI7UUFBSTtRQUNyRyxPQUFPLElBQUksQ0FBQzVVLFVBQVUsR0FBR25OLHFCQUFxQixDQUFDTTtJQUNqRDtJQUNBK2hCLFFBQVExK0IsU0FBUyxDQUFDK0UsS0FBSyxHQUFHLFNBQVNBO1FBQ2pDLElBQUl1VixTQUFTLElBQUk7UUFFakIsSUFBSWdsQixPQUFPN0gsWUFBWXozQixTQUFTLENBQUMrRSxLQUFLLENBQUN4QyxJQUFJLENBQUMsSUFBSTtRQUNoRCs4QixLQUFLbGtCLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ3JXLEtBQUs7UUFDL0J1NkIsS0FBS2prQixNQUFNLEdBQUcsSUFBSXRiLE1BQU0sSUFBSSxDQUFDc2IsTUFBTSxDQUFDNWEsTUFBTSxFQUFFSixJQUFJLENBQUM7UUFDakQsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lVLE1BQU0sQ0FBQzVhLE1BQU0sRUFBRTJHLElBQUs7WUFDM0NrNEIsS0FBS2prQixNQUFNLENBQUNqVSxFQUFFLEdBQUdrVCxPQUFPZSxNQUFNLENBQUNqVSxFQUFFLENBQUNyQyxLQUFLO1FBQ3pDO1FBQ0EsT0FBT3U2QjtJQUNUO0lBQ0FaLFFBQVExK0IsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVNBO1FBQzNDLE9BQU87SUFDVDtJQUNBZ2xCLFFBQVExK0IsU0FBUyxDQUFDZ0YsSUFBSSxHQUFHLFNBQVNBO1FBQ2hDLElBQUlzVixTQUFTLElBQUk7UUFFakIsSUFBSXNDLFFBQVEsSUFBSSxDQUFDeEIsTUFBTSxDQUFDcFcsSUFBSTtRQUM1QixJQUFJNlgsUUFBUSxJQUFJOWMsTUFBTSxJQUFJLENBQUNzYixNQUFNLENBQUM1YSxNQUFNLEVBQUVKLElBQUksQ0FBQztRQUMvQyxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUl5VixNQUFNcGMsTUFBTSxFQUFFMkcsSUFBSztZQUNyQ3lWLEtBQUssQ0FBQ3pWLEVBQUUsR0FBR2tULE9BQU9lLE1BQU0sQ0FBQ2pVLEVBQUUsQ0FBQ3BDLElBQUk7UUFDbEM7UUFDQSxPQUFPLElBQUkwNUIsUUFBUTloQixPQUFPQyxPQUFPLElBQUksQ0FBQzJMLFFBQVE7SUFDaEQ7SUFDQWtXLFFBQVExK0IsU0FBUyxDQUFDdy9CLGVBQWUsR0FBRyxTQUFTQTtRQUMzQyxPQUFPLElBQUksQ0FBQ3BrQixNQUFNO0lBQ3BCO0lBQ0FzakIsUUFBUTErQixTQUFTLENBQUM4WixPQUFPLEdBQUcsU0FBU0E7UUFDbkMsT0FBTyxJQUFJLENBQUNzQixNQUFNLENBQUN0QixPQUFPO0lBQzVCO0lBQ0E0a0IsUUFBUTErQixTQUFTLENBQUNnZ0MsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCaDlCLENBQUM7UUFDL0QsT0FBTyxJQUFJLENBQUNxWSxNQUFNLENBQUNyWSxFQUFFO0lBQ3ZCO0lBQ0EwN0IsUUFBUTErQixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDdkMsT0FBTztZQUFDNDhCO1NBQVU7SUFDcEI7SUFDQUMsUUFBUTErQixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDcEMsT0FBTzQ4QjtJQUNUO0lBQ0EzNkIsZ0JBQWdCRSxnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO1FBQWMsT0FBTyxDQUFDO0lBQW9CO0lBRWpGbkQsT0FBT29ELGdCQUFnQixDQUFFcTdCLFNBQVMzNkI7SUFFbEMsT0FBTzI2QjtBQUNULEVBQUVyVztBQUVGLElBQUk2WCxhQUFjLFNBQVVsSCxxQkFBcUI7SUFDL0MsU0FBU2tIO1FBQ1BsSCxzQkFBc0J6ZixLQUFLLENBQUMsSUFBSSxFQUFFelk7SUFDcEM7SUFFQSxJQUFLazRCLHVCQUF3QmtILFdBQVd4OUIsU0FBUyxHQUFHczJCO0lBQ3BEa0gsV0FBV2xnQyxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUVxMkIseUJBQXlCQSxzQkFBc0JoNUIsU0FBUztJQUM5RmtnQyxXQUFXbGdDLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3M5QjtJQUVuQyxJQUFJbjhCLGtCQUFrQjtRQUFFRSxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztJQUFFO0lBRWpFKy9CLFdBQVdsZ0MsU0FBUyxDQUFDdXBCLFlBQVksR0FBRyxTQUFTQTtRQUMzQyxPQUFPbEIsU0FBU1Msb0JBQW9CO0lBQ3RDO0lBQ0FvWCxXQUFXbGdDLFNBQVMsQ0FBQ21nQyxPQUFPLEdBQUcsU0FBU0E7UUFDdEMsT0FBTztJQUNUO0lBQ0FELFdBQVdsZ0MsU0FBUyxDQUFDOHBCLFdBQVcsR0FBRyxTQUFTQTtRQUMxQyxJQUFJaHBCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUkrRCxRQUFRMUQsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSW9CLFlBQVlwQixTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDZzNCLGlCQUFpQixDQUFDdHpCLFFBQVE7Z0JBQ2xDLE9BQU87WUFDVDtZQUNBLE9BQU93MEIsc0JBQXNCaDVCLFNBQVMsQ0FBQzhwQixXQUFXLENBQUN2bkIsSUFBSSxDQUFDLElBQUksRUFBRWlDLE9BQU90QztRQUN2RSxPQUFPO1lBQUUsT0FBTzgyQixzQkFBc0JoNUIsU0FBUyxDQUFDOHBCLFdBQVcsQ0FBQ3ZRLEtBQUssQ0FBQyxJQUFJLEVBQUV6WTtRQUFXO0lBQ3JGO0lBQ0FvL0IsV0FBV2xnQyxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7UUFDNUMsSUFBSTlTLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUl1QyxJQUFJbEMsU0FBUyxDQUFDLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUMwWixXQUFXLENBQUN4WCxFQUFFLENBQUM0USxhQUFhO1FBQzFDLE9BQU87WUFBRSxPQUFPb2xCLHNCQUFzQmg1QixTQUFTLENBQUM0VCxhQUFhLENBQUMyRixLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUN2RjtJQUNBby9CLFdBQVdsZ0MsU0FBUyxDQUFDZzRCLG9CQUFvQixHQUFHLFNBQVNBO1FBQ25ELE9BQU85QixVQUFVSSxLQUFLO0lBQ3hCO0lBQ0E0SixXQUFXbGdDLFNBQVMsQ0FBQzhULFlBQVksR0FBRyxTQUFTQTtRQUMzQyxPQUFPO0lBQ1Q7SUFDQW9zQixXQUFXbGdDLFNBQVMsQ0FBQzg0QixXQUFXLEdBQUcsU0FBU0E7UUFDMUMsT0FBTyxJQUFJLENBQUN0UCxVQUFVLEdBQUd2TSx3QkFBd0IsQ0FBQztJQUNwRDtJQUNBaWpCLFdBQVdsZ0MsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVNBO1FBQzlDLE9BQU87SUFDVDtJQUNBd21CLFdBQVdsZ0MsU0FBUyxDQUFDZ0YsSUFBSSxHQUFHLFNBQVNBO1FBQ25DLElBQUlzVixTQUFTLElBQUk7UUFFakIsSUFBSTBCLFNBQVMsSUFBSWpjLE1BQU0sSUFBSSxDQUFDeWEsV0FBVyxDQUFDL1osTUFBTSxFQUFFSixJQUFJLENBQUM7UUFDckQsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJNFUsT0FBT3ZiLE1BQU0sRUFBRTJHLElBQUs7WUFDdEM0VSxNQUFNLENBQUM1VSxFQUFFLEdBQUdrVCxPQUFPRSxXQUFXLENBQUNwVCxFQUFFLENBQUNwQyxJQUFJO1FBQ3hDO1FBQ0EsT0FBTyxJQUFJazdCLFdBQVdsa0IsUUFBUSxJQUFJLENBQUN3TSxRQUFRO0lBQzdDO0lBQ0EwWCxXQUFXbGdDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUMxQyxPQUFPO1lBQUMwOEI7U0FBTztJQUNqQjtJQUNBMkIsV0FBV2xnQyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDdkMsT0FBT28rQjtJQUNUO0lBQ0FuOEIsZ0JBQWdCRSxnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO1FBQWMsT0FBTyxDQUFDO0lBQW9CO0lBRWpGbkQsT0FBT29ELGdCQUFnQixDQUFFNjhCLFlBQVluOEI7SUFFckMsT0FBT204QjtBQUNULEVBQUUxSTtBQUVGLElBQUk0SSxhQUFjLFNBQVVDLGFBQWE7SUFDdkMsU0FBU0QsV0FBWXBrQixNQUFNLEVBQUVzTSxPQUFPO1FBQ2xDLElBQUl0TSxrQkFBa0J0WSxjQUFjNGtCLG1CQUFtQjVQLGlCQUFpQjtZQUN0RXNELFNBQVNzTSxRQUFRK1YsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDcVo7UUFDekQ7UUFDQXFrQixjQUFjOTlCLElBQUksQ0FBQyxJQUFJLEVBQUV5WixRQUFRc007UUFDakMsSUFBSSxDQUFDZ1ksb0JBQW9CO0lBQzNCO0lBRUEsSUFBS0QsZUFBZ0JELFdBQVcxOUIsU0FBUyxHQUFHMjlCO0lBQzVDRCxXQUFXcGdDLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRTA5QixpQkFBaUJBLGNBQWNyZ0MsU0FBUztJQUM5RW9nQyxXQUFXcGdDLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3c5QjtJQUVuQyxJQUFJcjhCLGtCQUFrQjtRQUFFdzhCLG9CQUFvQjtZQUFFcGdDLGNBQWM7UUFBSztRQUFFOEQsa0JBQWtCO1lBQUU5RCxjQUFjO1FBQUs7SUFBRTtJQUM1R2lnQyxXQUFXcGdDLFNBQVMsQ0FBQ3VwQixZQUFZLEdBQUcsU0FBU0E7UUFDM0MsT0FBT2xCLFNBQVNXLG9CQUFvQjtJQUN0QztJQUNBb1gsV0FBV3BnQyxTQUFTLENBQUNnNEIsb0JBQW9CLEdBQUcsU0FBU0E7UUFDbkQsT0FBTzlCLFVBQVVJLEtBQUs7SUFDeEI7SUFDQThKLFdBQVdwZ0MsU0FBUyxDQUFDaTVCLFFBQVEsR0FBRyxTQUFTQTtRQUN2QyxJQUFJLElBQUksQ0FBQ25mLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxPQUFPdW1CLGNBQWNyZ0MsU0FBUyxDQUFDaTVCLFFBQVEsQ0FBQzEyQixJQUFJLENBQUMsSUFBSTtJQUNuRDtJQUNBNjlCLFdBQVdwZ0MsU0FBUyxDQUFDbXhCLE9BQU8sR0FBRyxTQUFTQTtRQUN0QyxJQUFJa0csTUFBTSxJQUFJLENBQUN4YyxPQUFPLENBQUM3VixJQUFJO1FBQzNCKzNCLG9CQUFvQjVMLE9BQU8sQ0FBQ2tHO1FBQzVCLElBQUltSixNQUFNLElBQUksQ0FBQ2hYLFVBQVUsR0FBR3BOLGdCQUFnQixDQUFDaWI7UUFDN0MsT0FBT21KO0lBQ1Q7SUFDQUosV0FBV3BnQyxTQUFTLENBQUNzZ0Msb0JBQW9CLEdBQUcsU0FBU0E7UUFDbkQsSUFBSSxDQUFDLElBQUksQ0FBQ3htQixPQUFPLE1BQU0sQ0FBQ3VtQixjQUFjcmdDLFNBQVMsQ0FBQ2k1QixRQUFRLENBQUMxMkIsSUFBSSxDQUFDLElBQUksR0FBRztZQUNuRSxNQUFNLElBQUlILHlCQUF5QjtRQUNyQztRQUNBLElBQUksSUFBSSxDQUFDZzhCLHFCQUFxQixHQUFHenFCLElBQUksTUFBTSxLQUFLLElBQUksQ0FBQ3lxQixxQkFBcUIsR0FBR3pxQixJQUFJLEtBQUt5c0IsV0FBV0csa0JBQWtCLEVBQUU7WUFDbkgsTUFBTSxJQUFJbitCLHlCQUF5QixtREFBbUQsSUFBSSxDQUFDZzhCLHFCQUFxQixHQUFHenFCLElBQUksS0FBSztRQUM5SDtJQUNGO0lBQ0F5c0IsV0FBV3BnQyxTQUFTLENBQUMwWixlQUFlLEdBQUcsU0FBU0E7UUFDOUMsT0FBTztJQUNUO0lBQ0EwbUIsV0FBV3BnQyxTQUFTLENBQUNnRixJQUFJLEdBQUcsU0FBU0E7UUFDbkMsT0FBTyxJQUFJbzdCLFdBQVcsSUFBSSxDQUFDdmxCLE9BQU8sQ0FBQzdWLElBQUksSUFBSSxJQUFJLENBQUN3akIsUUFBUTtJQUMxRDtJQUNBNFgsV0FBV3BnQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDMUMsT0FBTyxFQUFFO0lBQ1g7SUFDQXUrQixXQUFXcGdDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUN2QyxPQUFPcytCO0lBQ1Q7SUFDQXI4QixnQkFBZ0J3OEIsa0JBQWtCLENBQUNuOUIsR0FBRyxHQUFHO1FBQWMsT0FBTztJQUFFO0lBQ2hFVyxnQkFBZ0JFLGdCQUFnQixDQUFDYixHQUFHLEdBQUc7UUFBYyxPQUFPLENBQUM7SUFBb0I7SUFFakZuRCxPQUFPb0QsZ0JBQWdCLENBQUUrOEIsWUFBWXI4QjtJQUVyQyxPQUFPcThCO0FBQ1QsRUFBRWpHO0FBRUYsSUFBSXNHLGVBQWdCLFNBQVV6SCxxQkFBcUI7SUFDakQsU0FBU3lIO1FBQ1B6SCxzQkFBc0J6ZixLQUFLLENBQUMsSUFBSSxFQUFFelk7SUFDcEM7SUFFQSxJQUFLazRCLHVCQUF3QnlILGFBQWEvOUIsU0FBUyxHQUFHczJCO0lBQ3REeUgsYUFBYXpnQyxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUVxMkIseUJBQXlCQSxzQkFBc0JoNUIsU0FBUztJQUNoR3lnQyxhQUFhemdDLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzY5QjtJQUVyQyxJQUFJMThCLGtCQUFrQjtRQUFFRSxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztJQUFFO0lBRWpFc2dDLGFBQWF6Z0MsU0FBUyxDQUFDdXBCLFlBQVksR0FBRyxTQUFTQTtRQUM3QyxPQUFPbEIsU0FBU2Msc0JBQXNCO0lBQ3hDO0lBQ0FzWCxhQUFhemdDLFNBQVMsQ0FBQzhwQixXQUFXLEdBQUcsU0FBU0E7UUFDNUMsSUFBSWhwQixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJK0QsUUFBUTFELFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUlvQixZQUFZcEIsU0FBUyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQ2czQixpQkFBaUIsQ0FBQ3R6QixRQUFRO2dCQUNsQyxPQUFPO1lBQ1Q7WUFDQSxPQUFPdzBCLHNCQUFzQmg1QixTQUFTLENBQUM4cEIsV0FBVyxDQUFDdm5CLElBQUksQ0FBQyxJQUFJLEVBQUVpQyxPQUFPdEM7UUFDdkUsT0FBTztZQUFFLE9BQU84MkIsc0JBQXNCaDVCLFNBQVMsQ0FBQzhwQixXQUFXLENBQUN2USxLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUNyRjtJQUNBMi9CLGFBQWF6Z0MsU0FBUyxDQUFDZzRCLG9CQUFvQixHQUFHLFNBQVNBO1FBQ3JELE9BQU87SUFDVDtJQUNBeUksYUFBYXpnQyxTQUFTLENBQUM4VCxZQUFZLEdBQUcsU0FBU0E7UUFDN0MsT0FBTztJQUNUO0lBQ0Eyc0IsYUFBYXpnQyxTQUFTLENBQUNteEIsT0FBTyxHQUFHLFNBQVNBO1FBQ3hDLElBQUk3VyxTQUFTLElBQUk7UUFFakIsSUFBSXRYLElBQUksSUFBSSxDQUFDd1gsV0FBVyxDQUFDL1osTUFBTTtRQUMvQixJQUFJMDNCLFdBQVcsSUFBSXA0QixNQUFNaUQsR0FBRzNDLElBQUksQ0FBQztRQUNqQyxJQUFLLElBQUkrRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRCt3QixRQUFRLENBQUMvd0IsRUFBRSxHQUFHa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDK3BCLE9BQU87UUFDN0M7UUFDQSxPQUFPLElBQUksQ0FBQzNILFVBQVUsR0FBRzFNLGtCQUFrQixDQUFDcWI7SUFDOUM7SUFDQXNJLGFBQWF6Z0MsU0FBUyxDQUFDODRCLFdBQVcsR0FBRyxTQUFTQTtRQUM1QyxJQUFJeGUsU0FBUyxJQUFJO1FBRWpCLElBQUksSUFBSSxDQUFDUixPQUFPLElBQUk7WUFDbEIsT0FBTyxJQUFJLENBQUMwUCxVQUFVLEdBQUduTixxQkFBcUI7UUFDaEQ7UUFDQSxJQUFJcWtCLFdBQVcsSUFBSWxUO1FBQ25CLElBQUssSUFBSXBtQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDb1QsV0FBVyxDQUFDL1osTUFBTSxFQUFFMkcsSUFBSztZQUNoRCxJQUFJOFQsVUFBVVosT0FBT0UsV0FBVyxDQUFDcFQsRUFBRTtZQUNuQyxJQUFJdVYsUUFBUXpCLFFBQVE0ZCxXQUFXO1lBQy9CLElBQUssSUFBSXhOLElBQUksR0FBR0EsSUFBSTNPLE1BQU15TixnQkFBZ0IsSUFBSWtCLElBQUs7Z0JBQ2pEb1YsU0FBU3owQixHQUFHLENBQUMwUSxNQUFNOE0sWUFBWSxDQUFDNkI7WUFDbEM7UUFDRjtRQUNBLElBQUlxVixnQkFBZ0IsSUFBSTVnQyxNQUFNMmdDLFNBQVMvc0IsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO1FBQ3BELE9BQU8sSUFBSSxDQUFDbXBCLFVBQVUsR0FBR25OLHFCQUFxQixDQUFDcWtCLFNBQVMxVCxPQUFPLENBQUMyVDtJQUNsRTtJQUNBRixhQUFhemdDLFNBQVMsQ0FBQzBaLGVBQWUsR0FBRyxTQUFTQTtRQUNoRCxPQUFPO0lBQ1Q7SUFDQSttQixhQUFhemdDLFNBQVMsQ0FBQ2dGLElBQUksR0FBRyxTQUFTQTtRQUNyQyxJQUFJc1YsU0FBUyxJQUFJO1FBRWpCLElBQUl5QyxXQUFXLElBQUloZCxNQUFNLElBQUksQ0FBQ3lhLFdBQVcsQ0FBQy9aLE1BQU0sRUFBRUosSUFBSSxDQUFDO1FBQ3ZELElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSTJWLFNBQVN0YyxNQUFNLEVBQUUyRyxJQUFLO1lBQ3hDMlYsUUFBUSxDQUFDM1YsRUFBRSxHQUFHa1QsT0FBT0UsV0FBVyxDQUFDcFQsRUFBRSxDQUFDcEMsSUFBSTtRQUMxQztRQUNBLE9BQU8sSUFBSXk3QixhQUFhMWpCLFVBQVUsSUFBSSxDQUFDeUwsUUFBUTtJQUNqRDtJQUNBaVksYUFBYXpnQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDNUMsT0FBTztZQUFDNDhCO1NBQVU7SUFDcEI7SUFDQWdDLGFBQWF6Z0MsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ3pDLE9BQU8yK0I7SUFDVDtJQUNBMThCLGdCQUFnQkUsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztRQUFjLE9BQU8sQ0FBQztJQUFtQjtJQUVoRm5ELE9BQU9vRCxnQkFBZ0IsQ0FBRW85QixjQUFjMThCO0lBRXZDLE9BQU8wOEI7QUFDVCxFQUFFako7QUFFRixJQUFJb0osaUJBQWlCLFNBQVNBLGVBQWdCdFksT0FBTztJQUNuRCxJQUFJLENBQUNFLFFBQVEsR0FBR0YsV0FBVztJQUMzQixJQUFJLENBQUN1WSxpQkFBaUIsR0FBRztBQUMzQjtBQUVBLElBQUlDLHFCQUFxQjtJQUFFQyx1QkFBdUI7UUFBRTVnQyxjQUFjO0lBQUs7SUFBRTZnQyxxQkFBcUI7UUFBRTdnQyxjQUFjO0lBQUs7SUFBRThnQyw2QkFBNkI7UUFBRTlnQyxjQUFjO0lBQUs7QUFBRTtBQUN6S3lnQyxlQUFlNWdDLFNBQVMsQ0FBQ2toQyxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCQyxnQkFBZ0I7SUFDbkYsSUFBSSxDQUFDTixpQkFBaUIsR0FBR007QUFDM0I7QUFDQVAsZUFBZTVnQyxTQUFTLENBQUNvaEMsSUFBSSxHQUFHLFNBQVNBLEtBQU12b0IsUUFBUSxFQUFFd29CLFNBQVM7SUFDaEUsSUFBSXhvQixhQUFhLE1BQU07UUFBRSxPQUFPO0lBQUs7SUFDckMsSUFBSXBULFNBQVMsSUFBSSxDQUFDNjdCLFlBQVksQ0FBQ3pvQixVQUFVd29CO0lBQ3pDLElBQUksSUFBSSxDQUFDUixpQkFBaUIsRUFBRTtRQUMxQnA3QixPQUFPMGxCLFdBQVcsQ0FBQ3RTLFNBQVMyUixXQUFXO0lBQ3pDO0lBQ0EsT0FBTy9rQjtBQUNUO0FBQ0FtN0IsZUFBZTVnQyxTQUFTLENBQUNzaEMsWUFBWSxHQUFHLFNBQVNBLGFBQWN6b0IsUUFBUSxFQUFFd29CLFNBQVM7SUFDaEYsSUFBSSxJQUFJLENBQUM3WSxRQUFRLEtBQUssTUFBTTtRQUFFLElBQUksQ0FBQ0EsUUFBUSxHQUFHM1AsU0FBUzJRLFVBQVU7SUFBSTtJQUNyRSxJQUFJM1Esb0JBQW9CMmUsb0JBQW9CO1FBQzFDLE9BQU8sSUFBSSxDQUFDK0osc0JBQXNCLENBQUMxb0IsVUFBVXdvQjtJQUMvQztJQUNBLElBQUl4b0Isb0JBQW9CNmxCLFNBQVM7UUFDL0IsT0FBTyxJQUFJLENBQUM4QyxXQUFXLENBQUMzb0IsVUFBVXdvQjtJQUNwQztJQUNBLElBQUl4b0Isb0JBQW9CMmxCLE9BQU87UUFDN0IsT0FBTzZDLFVBQVVELElBQUksQ0FBQ3ZvQixVQUFVLElBQUksQ0FBQzJQLFFBQVE7SUFDL0M7SUFDQSxJQUFJM1Asb0JBQW9Cc2hCLFlBQVk7UUFDbEMsT0FBT2tILFVBQVVELElBQUksQ0FBQ3ZvQixVQUFVLElBQUksQ0FBQzJQLFFBQVE7SUFDL0M7SUFDQTlLLE9BQU9DLG9CQUFvQixDQUFDLGlDQUFpQzlFLFNBQVMvVyxRQUFRLEdBQUcyL0IsT0FBTztJQUN4RixPQUFPO0FBQ1Q7QUFDQWIsZUFBZTVnQyxTQUFTLENBQUN1aEMsc0JBQXNCLEdBQUcsU0FBU0EsdUJBQXdCOWxCLFVBQVUsRUFBRTRsQixTQUFTO0lBQ3BHLElBQUkvbUIsU0FBUyxJQUFJO0lBRW5CLElBQUlvbkIsb0JBQW9CTCxVQUFVRCxJQUFJLENBQUMzbEIsWUFBWSxJQUFJLENBQUMrTSxRQUFRO0lBQ2hFLElBQUlxRCxhQUFhLElBQUkyQjtJQUNyQixJQUFLLElBQUlwbUIsSUFBSSxHQUFHQSxJQUFJczZCLGtCQUFrQnRYLGdCQUFnQixJQUFJaGpCLElBQUs7UUFDN0QsSUFBSXlSLFdBQVd5QixPQUFPOG1CLElBQUksQ0FBQ00sa0JBQWtCalksWUFBWSxDQUFDcmlCLElBQUlpNkI7UUFDOUQsSUFBSXhvQixhQUFhLFFBQVFBLFNBQVNpQixPQUFPLElBQUk7WUFDM0M7UUFDRjtRQUNBK1IsV0FBVzVmLEdBQUcsQ0FBQzRNO0lBQ2pCO0lBQ0EsSUFBSTZvQixrQkFBa0I1L0IsUUFBUSxPQUFPbytCLFlBQVk7UUFDL0MsT0FBTyxJQUFJLENBQUMxWCxRQUFRLENBQUN6TSxnQkFBZ0IsQ0FBQzhQLFdBQVdtQixPQUFPLENBQUMsRUFBRTtJQUM3RDtJQUNBLElBQUkwVSxrQkFBa0I1L0IsUUFBUSxPQUFPaTNCLGlCQUFpQjtRQUNwRCxPQUFPLElBQUksQ0FBQ3ZRLFFBQVEsQ0FBQ25NLHFCQUFxQixDQUFDd1AsV0FBV21CLE9BQU8sQ0FBQyxFQUFFO0lBQ2xFO0lBQ0EsSUFBSTBVLGtCQUFrQjUvQixRQUFRLE9BQU8yK0IsY0FBYztRQUNqRCxPQUFPLElBQUksQ0FBQ2pZLFFBQVEsQ0FBQzFMLGtCQUFrQixDQUFDK08sV0FBV21CLE9BQU8sQ0FBQyxFQUFFO0lBQy9EO0lBQ0EsT0FBTyxJQUFJLENBQUN4RSxRQUFRLENBQUN2TCx3QkFBd0IsQ0FBQzRPLFdBQVdtQixPQUFPLENBQUMsRUFBRTtBQUNyRTtBQUNBNFQsZUFBZTVnQyxTQUFTLENBQUN3aEMsV0FBVyxHQUFHLFNBQVNBLFlBQWF0bUIsT0FBTyxFQUFFbW1CLFNBQVM7SUFDM0UsSUFBSS9tQixTQUFTLElBQUk7SUFFbkIsSUFBSXFuQixhQUFhTixVQUFVRCxJQUFJLENBQUNsbUIsU0FBUyxJQUFJLENBQUNzTixRQUFRO0lBQ3RELElBQUltWixlQUFlLE1BQU07UUFBRUEsYUFBYSxJQUFJLENBQUNuWixRQUFRLENBQUMvTCxhQUFhLENBQUM7SUFBTztJQUMzRSxJQUFJa2xCLFdBQVc3bkIsT0FBTyxJQUFJO1FBQ3hCLE9BQU82bkI7SUFDVDtJQUNBLElBQUkva0IsUUFBUSxJQUFJLENBQUN3a0IsSUFBSSxDQUFDTyxXQUFXbkMsZUFBZSxJQUFJNkI7SUFDcEQsSUFBSXprQixVQUFVLFFBQVFBLE1BQU05QyxPQUFPLElBQUk7UUFDckMsT0FBTyxJQUFJLENBQUMwTyxRQUFRLENBQUMvTCxhQUFhO0lBQ3BDO0lBQ0EsSUFBSUksUUFBUSxJQUFJMlE7SUFDaEIsSUFBSyxJQUFJcG1CLElBQUksR0FBR0EsSUFBSXU2QixXQUFXL0Msa0JBQWtCLElBQUl4M0IsSUFBSztRQUN4RCxJQUFJdzZCLE9BQU90bkIsT0FBTzhtQixJQUFJLENBQUNPLFdBQVczQixnQkFBZ0IsQ0FBQzU0QixJQUFJaTZCO1FBQ3ZELElBQUlPLFNBQVMsUUFBUUEsS0FBSzluQixPQUFPLElBQUk7WUFDbkM7UUFDRjtRQUNBK0MsTUFBTTVRLEdBQUcsQ0FBQzIxQjtJQUNaO0lBQ0EsT0FBTyxJQUFJLENBQUNwWixRQUFRLENBQUMvTCxhQUFhLENBQUNHLE9BQU9DLE1BQU1tUSxPQUFPLENBQUMsRUFBRTtBQUM1RDtBQUNBNFQsZUFBZTVnQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDOUMsT0FBTyxFQUFFO0FBQ1g7QUFDQSsrQixlQUFlNWdDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPOCtCO0FBQ1Q7QUFDQUEsZUFBZWlCLHVCQUF1QixHQUFHLFNBQVNBLDJCQUE0QjtBQUM5RWYsbUJBQW1CQyxxQkFBcUIsQ0FBQzM5QixHQUFHLEdBQUc7SUFBYyxPQUFPMjlCO0FBQXNCO0FBQzFGRCxtQkFBbUJFLG1CQUFtQixDQUFDNTlCLEdBQUcsR0FBRztJQUFjLE9BQU80OUI7QUFBb0I7QUFDdEZGLG1CQUFtQkcsMkJBQTJCLENBQUM3OUIsR0FBRyxHQUFHO0lBQWMsT0FBTzY5QjtBQUE0QjtBQUV0R2hoQyxPQUFPb0QsZ0JBQWdCLENBQUV1OUIsZ0JBQWdCRTtBQUV6QyxJQUFJQyx3QkFBd0IsU0FBU0EseUJBQTBCO0FBRS9EQSxzQkFBc0IvZ0MsU0FBUyxDQUFDb2hDLElBQUksR0FBRyxTQUFTQSxLQUFNdm9CLFFBQVEsRUFBRXlQLE9BQU87SUFDckUsT0FBT3pQO0FBQ1Q7QUFDQWtvQixzQkFBc0IvZ0MsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3JELE9BQU87UUFBQysrQixlQUFlaUIsdUJBQXVCO0tBQUM7QUFDakQ7QUFDQWQsc0JBQXNCL2dDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNsRCxPQUFPaS9CO0FBQ1Q7QUFFQSxJQUFJQyxzQkFBc0IsU0FBU0EsdUJBQXdCO0FBRTNEQSxvQkFBb0JoaEMsU0FBUyxDQUFDb2hDLElBQUksR0FBRyxTQUFTQSxLQUFNdm9CLFFBQVEsRUFBRXlQLE9BQU87SUFDbkUsSUFBSTNNLFNBQVMsSUFBSSxDQUFDbW1CLGVBQWUsQ0FBQ2pwQixTQUFTNmUsY0FBYyxJQUFJN2U7SUFDN0QsSUFBSThDLFdBQVcsTUFBTTtRQUFFLE9BQU85QztJQUFTO0lBQ3ZDLElBQUlBLG9CQUFvQnVuQixZQUFZO1FBQ2xDLE9BQU85WCxRQUFRbE0sZ0JBQWdCLENBQUNUO0lBQ2xDO0lBQ0EsSUFBSTlDLG9CQUFvQnNoQixZQUFZO1FBQ2xDLE9BQU83UixRQUFRbk0sZ0JBQWdCLENBQUNSO0lBQ2xDO0lBQ0EsSUFBSTlDLG9CQUFvQjJsQixPQUFPO1FBQzdCLElBQUk3aUIsT0FBT2xiLE1BQU0sR0FBRyxHQUFHO1lBQ3JCLE9BQU82bkIsUUFBUTVNLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDLEVBQUU7UUFDdEMsT0FBTztZQUNMLE9BQU8yTSxRQUFRNU0sV0FBVztRQUM1QjtJQUNGO0lBQ0EsT0FBTzdDO0FBQ1Q7QUFDQW1vQixvQkFBb0JoaEMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ25ELE9BQU87UUFBQysrQixlQUFlaUIsdUJBQXVCO0tBQUM7QUFDakQ7QUFDQWIsb0JBQW9CaGhDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNoRCxPQUFPay9CO0FBQ1Q7QUFFQSxJQUFJQyw4QkFBOEIsU0FBU0EsK0JBQWdDO0FBRTNFQSw0QkFBNEJqaEMsU0FBUyxDQUFDb2hDLElBQUksR0FBRyxTQUFTQSxLQUFNdm9CLFFBQVEsRUFBRXlQLE9BQU87SUFDM0UsSUFBSXpQLG9CQUFvQnVuQixZQUFZO1FBQ2xDLE9BQU85WCxRQUFRbE0sZ0JBQWdCLENBQUMsSUFBSSxDQUFDZ2xCLElBQUksQ0FBQ3ZvQixTQUFTdWxCLHFCQUFxQixJQUFJdmxCO0lBQzlFO0lBQ0EsSUFBSUEsb0JBQW9Cc2hCLFlBQVk7UUFDbEMsT0FBTzdSLFFBQVFuTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNpbEIsSUFBSSxDQUFDdm9CLFNBQVN1bEIscUJBQXFCLElBQUl2bEI7SUFDOUU7SUFDQSxJQUFJQSxvQkFBb0IybEIsT0FBTztRQUM3QixPQUFPbFcsUUFBUTVNLFdBQVcsQ0FBQyxJQUFJLENBQUMwbEIsSUFBSSxDQUFDdm9CLFNBQVN1bEIscUJBQXFCLElBQUl2bEI7SUFDekU7SUFDQSxPQUFPQTtBQUNUO0FBQ0Fvb0IsNEJBQTRCamhDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMzRCxPQUFPO1FBQUMrK0IsZUFBZWlCLHVCQUF1QjtLQUFDO0FBQ2pEO0FBQ0FaLDRCQUE0QmpoQyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDeEQsT0FBT20vQjtBQUNUO0FBRUEsSUFBSWMsMEJBQTBCLFNBQVNBO0lBQ3JDLElBQUl6bkIsU0FBUyxJQUFJO0lBRWpCLElBQUksQ0FBQzBuQixVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDN25CLFlBQVksR0FBRztJQUNwQixJQUFJclosVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWWYsT0FBTztZQUNqQyxJQUFJLENBQUNvYSxZQUFZLEdBQUdyWixTQUFTLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUNraEMsVUFBVSxHQUFHO1FBQ3BCLE9BQU8sSUFBSWhoQyxPQUFPSSxTQUFTLENBQUNOLFNBQVMsQ0FBQyxFQUFFLEdBQUc7WUFDekMsSUFBSTZTLE9BQU83UyxTQUFTLENBQUMsRUFBRTtZQUN2QixJQUFJLENBQUNxWixZQUFZLEdBQUcsSUFBSXBhLE1BQU00VCxNQUFNdFQsSUFBSSxDQUFDO1lBQ3pDLElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSXVNLE1BQU12TSxJQUFLO2dCQUM3QmtULE9BQU9ILFlBQVksQ0FBQy9TLEVBQUUsR0FBRyxJQUFJMUQ7WUFDL0I7UUFDRixPQUFPLElBQUl5RCxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRTBTLHFCQUFxQjtZQUN6RCxJQUFJeXVCLFdBQVduaEMsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSW1oQyxhQUFhLE1BQU07Z0JBQ3JCLElBQUksQ0FBQzluQixZQUFZLEdBQUcsSUFBSXBhLE1BQU0sR0FBR00sSUFBSSxDQUFDO2dCQUN0QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJLENBQUMyaEMsVUFBVSxHQUFHQyxTQUFTbnVCLFlBQVk7WUFDdkMsSUFBSSxDQUFDcUcsWUFBWSxHQUFHLElBQUlwYSxNQUFNa2lDLFNBQVN0dUIsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO1lBQ3BELElBQUssSUFBSXVsQixNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDekwsWUFBWSxDQUFDMVosTUFBTSxFQUFFbWxCLE1BQU87Z0JBQ3ZEdEwsT0FBT0gsWUFBWSxDQUFDeUwsSUFBSSxHQUFHcWMsU0FBU3B1QixpQkFBaUIsQ0FBQytSO1lBQ3hEO1FBQ0Y7SUFDRixPQUFPLElBQUk5a0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWWYsU0FBU2lCLE9BQU9JLFNBQVMsQ0FBQ04sU0FBUyxDQUFDLEVBQUUsR0FBRztZQUNuRSxJQUFJMHZCLGNBQWMxdkIsU0FBUyxDQUFDLEVBQUU7WUFDOUIsSUFBSW0zQixZQUFZbjNCLFNBQVMsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQ3FaLFlBQVksR0FBR3FXO1lBQ3BCLElBQUksQ0FBQ3dSLFVBQVUsR0FBRy9KO1lBQ2xCLElBQUl6SCxnQkFBZ0IsTUFBTTtnQkFBRSxJQUFJLENBQUNyVyxZQUFZLEdBQUcsSUFBSXBhLE1BQU0sR0FBR00sSUFBSSxDQUFDO1lBQU87UUFDM0UsT0FBTyxJQUFJVyxPQUFPSSxTQUFTLENBQUNOLFNBQVMsQ0FBQyxFQUFFLEtBQUtFLE9BQU9JLFNBQVMsQ0FBQ04sU0FBUyxDQUFDLEVBQUUsR0FBRztZQUMzRSxJQUFJb2hDLFNBQVNwaEMsU0FBUyxDQUFDLEVBQUU7WUFDekIsSUFBSXFoQyxjQUFjcmhDLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQ3FaLFlBQVksR0FBRyxJQUFJcGEsTUFBTW1pQyxRQUFRN2hDLElBQUksQ0FBQztZQUMzQyxJQUFJLENBQUMyaEMsVUFBVSxHQUFHRztZQUNsQixJQUFLLElBQUk5UyxNQUFNLEdBQUdBLE1BQU02UyxRQUFRN1MsTUFBTztnQkFDckMvVSxPQUFPSCxZQUFZLENBQUNrVixJQUFJLEdBQUcsSUFBSTNyQjtZQUNqQztRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUkwK0IscUJBQXFCO0lBQUVuK0Isa0JBQWtCO1FBQUU5RCxjQUFjO0lBQUs7QUFBRTtBQUNwRTRoQyx3QkFBd0IvaEMsU0FBUyxDQUFDcUUsV0FBVyxHQUFHLFNBQVNBLFlBQWFnRSxLQUFLLEVBQUUvRCxhQUFhLEVBQUVsRSxLQUFLO0lBQy9GLE9BQVFrRTtRQUNOLEtBQUtrUCxtQkFBbUJ0UCxDQUFDO1lBQ3ZCLElBQUksQ0FBQ2lXLFlBQVksQ0FBQzlSLE1BQU0sQ0FBQzNHLENBQUMsR0FBR3RCO1lBQzdCO1FBQ0YsS0FBS29ULG1CQUFtQnJQLENBQUM7WUFDdkIsSUFBSSxDQUFDZ1csWUFBWSxDQUFDOVIsTUFBTSxDQUFDMUUsQ0FBQyxHQUFHdkQ7WUFDN0I7UUFDRixLQUFLb1QsbUJBQW1CcFAsQ0FBQztZQUN2QixJQUFJLENBQUMrVixZQUFZLENBQUM5UixNQUFNLENBQUN6RSxDQUFDLEdBQUd4RDtZQUM3QjtRQUNGO1lBQ0UsTUFBTSxJQUFJZ0MseUJBQXlCO0lBQ3ZDO0FBQ0Y7QUFDQTIvQix3QkFBd0IvaEMsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO0lBQ2hELE9BQU8sSUFBSSxDQUFDd0csWUFBWSxDQUFDMVosTUFBTTtBQUNqQztBQUNBc2hDLHdCQUF3Qi9oQyxTQUFTLENBQUN5RSxXQUFXLEdBQUcsU0FBU0EsWUFBYTRELEtBQUssRUFBRS9ELGFBQWE7SUFDeEYsT0FBUUE7UUFDTixLQUFLa1AsbUJBQW1CdFAsQ0FBQztZQUN2QixPQUFPLElBQUksQ0FBQ2lXLFlBQVksQ0FBQzlSLE1BQU0sQ0FBQzNHLENBQUM7UUFDbkMsS0FBSzhSLG1CQUFtQnJQLENBQUM7WUFDdkIsT0FBTyxJQUFJLENBQUNnVyxZQUFZLENBQUM5UixNQUFNLENBQUMxRSxDQUFDO1FBQ25DLEtBQUs2UCxtQkFBbUJwUCxDQUFDO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDK1YsWUFBWSxDQUFDOVIsTUFBTSxDQUFDekUsQ0FBQztRQUNuQztJQUNGO0lBQ0EsT0FBT2YsT0FBTytDLEdBQUc7QUFDbkI7QUFDQW04Qix3QkFBd0IvaEMsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBO0lBQ3pELElBQUk5UyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJMkcsSUFBSXRHLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDcVosWUFBWSxDQUFDL1MsRUFBRTtJQUM3QixPQUFPLElBQUl0RyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNEgsUUFBUXZILFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUlrckIsUUFBUWxyQixTQUFTLENBQUMsRUFBRTtRQUN4QmtyQixNQUFNdHFCLENBQUMsR0FBRyxJQUFJLENBQUN5WSxZQUFZLENBQUM5UixNQUFNLENBQUMzRyxDQUFDO1FBQ3BDc3FCLE1BQU1yb0IsQ0FBQyxHQUFHLElBQUksQ0FBQ3dXLFlBQVksQ0FBQzlSLE1BQU0sQ0FBQzFFLENBQUM7UUFDcENxb0IsTUFBTXBvQixDQUFDLEdBQUcsSUFBSSxDQUFDdVcsWUFBWSxDQUFDOVIsTUFBTSxDQUFDekUsQ0FBQztJQUN0QztBQUNGO0FBQ0FtK0Isd0JBQXdCL2hDLFNBQVMsQ0FBQzZULGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQnpNLENBQUM7SUFDakYsT0FBTyxJQUFJMUQsV0FBVyxJQUFJLENBQUN5VyxZQUFZLENBQUMvUyxFQUFFO0FBQzVDO0FBQ0EyNkIsd0JBQXdCL2hDLFNBQVMsQ0FBQzhULFlBQVksR0FBRyxTQUFTQTtJQUN4RCxPQUFPLElBQUksQ0FBQ2t1QixVQUFVO0FBQ3hCO0FBQ0FELHdCQUF3Qi9oQyxTQUFTLENBQUMrVCxJQUFJLEdBQUcsU0FBU0EsS0FBTTFMLEtBQUs7SUFDM0QsT0FBTyxJQUFJLENBQUM4UixZQUFZLENBQUM5UixNQUFNLENBQUMzRyxDQUFDO0FBQ25DO0FBQ0FxZ0Msd0JBQXdCL2hDLFNBQVMsQ0FBQytFLEtBQUssR0FBRyxTQUFTQTtJQUMvQyxJQUFJdVYsU0FBUyxJQUFJO0lBRW5CLElBQUkrbkIsbUJBQW1CLElBQUl0aUMsTUFBTSxJQUFJLENBQUM0VCxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDbkQsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQytTLFlBQVksQ0FBQzFaLE1BQU0sRUFBRTJHLElBQUs7UUFDakRpN0IsZ0JBQWdCLENBQUNqN0IsRUFBRSxHQUFHa1QsT0FBT0gsWUFBWSxDQUFDL1MsRUFBRSxDQUFDckMsS0FBSztJQUNwRDtJQUNBLE9BQU8sSUFBSWc5Qix3QkFBd0JNLGtCQUFrQixJQUFJLENBQUNMLFVBQVU7QUFDdEU7QUFDQUQsd0JBQXdCL2hDLFNBQVMsQ0FBQ2dVLGNBQWMsR0FBRyxTQUFTQSxlQUFnQkMsR0FBRztJQUMzRSxJQUFJcUcsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrUyxZQUFZLENBQUMxWixNQUFNLEVBQUUyRyxJQUFLO1FBQ2pENk0sSUFBSXNELGVBQWUsQ0FBQytDLE9BQU9ILFlBQVksQ0FBQy9TLEVBQUU7SUFDNUM7SUFDQSxPQUFPNk07QUFDVDtBQUNBOHRCLHdCQUF3Qi9oQyxTQUFTLENBQUNnRixJQUFJLEdBQUcsU0FBU0E7SUFDOUMsSUFBSXNWLFNBQVMsSUFBSTtJQUVuQixJQUFJK25CLG1CQUFtQixJQUFJdGlDLE1BQU0sSUFBSSxDQUFDNFQsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO0lBQ25ELElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUMrUyxZQUFZLENBQUMxWixNQUFNLEVBQUUyRyxJQUFLO1FBQ2pEaTdCLGdCQUFnQixDQUFDajdCLEVBQUUsR0FBR2tULE9BQU9ILFlBQVksQ0FBQy9TLEVBQUUsQ0FBQ3BDLElBQUk7SUFDbkQ7SUFDQSxPQUFPLElBQUkrOEIsd0JBQXdCTSxrQkFBa0IsSUFBSSxDQUFDTCxVQUFVO0FBQ3RFO0FBQ0FELHdCQUF3Qi9oQyxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDbEQsSUFBSXFWLFNBQVMsSUFBSTtJQUVuQixJQUFJLElBQUksQ0FBQ0gsWUFBWSxDQUFDMVosTUFBTSxHQUFHLEdBQUc7UUFDaEMsSUFBSTZoQyxTQUFTLElBQUk1NUIsYUFBYSxLQUFLLElBQUksQ0FBQ3lSLFlBQVksQ0FBQzFaLE1BQU07UUFDM0Q2aEMsT0FBTzE1QixNQUFNLENBQUM7UUFDZDA1QixPQUFPMTVCLE1BQU0sQ0FBQyxJQUFJLENBQUN1UixZQUFZLENBQUMsRUFBRTtRQUNsQyxJQUFLLElBQUkvUyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDK1MsWUFBWSxDQUFDMVosTUFBTSxFQUFFMkcsSUFBSztZQUNqRGs3QixPQUFPMTVCLE1BQU0sQ0FBQztZQUNkMDVCLE9BQU8xNUIsTUFBTSxDQUFDMFIsT0FBT0gsWUFBWSxDQUFDL1MsRUFBRTtRQUN0QztRQUNBazdCLE9BQU8xNUIsTUFBTSxDQUFDO1FBQ2QsT0FBTzA1QixPQUFPcjlCLFFBQVE7SUFDeEIsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBQ0E4OEIsd0JBQXdCL2hDLFNBQVMsQ0FBQ2tVLElBQUksR0FBRyxTQUFTQSxLQUFNN0wsS0FBSztJQUMzRCxPQUFPLElBQUksQ0FBQzhSLFlBQVksQ0FBQzlSLE1BQU0sQ0FBQzFFLENBQUM7QUFDbkM7QUFDQW8rQix3QkFBd0IvaEMsU0FBUyxDQUFDbVUsaUJBQWlCLEdBQUcsU0FBU0E7SUFDN0QsT0FBTyxJQUFJLENBQUNnRyxZQUFZO0FBQzFCO0FBQ0E0bkIsd0JBQXdCL2hDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN2RCxPQUFPO1FBQUMyUjtRQUFvQi9QO0tBQWE7QUFDM0M7QUFDQXMrQix3QkFBd0IvaEMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3BELE9BQU9pZ0M7QUFDVDtBQUNBSyxtQkFBbUJuK0IsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFtQjtBQUVuRm5ELE9BQU9vRCxnQkFBZ0IsQ0FBRTArQix5QkFBeUJLO0FBRWxELElBQUlHLGlDQUFpQyxTQUFTQSxrQ0FBbUM7QUFFakYsSUFBSUMscUJBQXFCO0lBQUV2K0Isa0JBQWtCO1FBQUU5RCxjQUFjO0lBQUs7SUFBRXNpQyxnQkFBZ0I7UUFBRXRpQyxjQUFjO0lBQUs7QUFBRTtBQUUzR29pQywrQkFBK0J2aUMsU0FBUyxDQUFDMGlDLFdBQVcsR0FBRyxTQUFTQTtJQUM5RCxPQUFPSCwrQkFBK0JJLFFBQVE7QUFDaEQ7QUFDQUosK0JBQStCdmlDLFNBQVMsQ0FBQzJDLE1BQU0sR0FBRyxTQUFTQTtJQUN6RCxJQUFJN0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWWYsT0FBTztZQUNqQyxJQUFJeXdCLGNBQWMxdkIsU0FBUyxDQUFDLEVBQUU7WUFDOUIsT0FBTyxJQUFJaWhDLHdCQUF3QnZSO1FBQ3JDLE9BQU8sSUFBSXJwQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRTBTLHFCQUFxQjtZQUN6RCxJQUFJeXVCLFdBQVduaEMsU0FBUyxDQUFDLEVBQUU7WUFDM0IsT0FBTyxJQUFJaWhDLHdCQUF3QkU7UUFDckM7SUFDRixPQUFPLElBQUluaEMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWtULE9BQU83UyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJbTNCLFlBQVluM0IsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSW0zQixZQUFZLEdBQUc7WUFBRUEsWUFBWTtRQUFHO1FBQ3BDLElBQUlBLFlBQVksR0FBRztZQUFFLE9BQU8sSUFBSThKLHdCQUF3QnB1QjtRQUFNO1FBQzlELE9BQU8sSUFBSW91Qix3QkFBd0JwdUIsTUFBTXNrQjtJQUMzQztBQUNGO0FBQ0FzSywrQkFBK0J2aUMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlELE9BQU87UUFBQzZFO1FBQTJCakQ7S0FBYTtBQUNsRDtBQUNBOCtCLCtCQUErQnZpQyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDM0QsT0FBT3lnQztBQUNUO0FBQ0FBLCtCQUErQkksUUFBUSxHQUFHLFNBQVNBO0lBQ2pELE9BQU9KLCtCQUErQkUsY0FBYztBQUN0RDtBQUVBRCxtQkFBbUJ2K0IsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFvQjtBQUNwRm8vQixtQkFBbUJDLGNBQWMsQ0FBQ3IvQixHQUFHLEdBQUc7SUFBYyxPQUFPLElBQUltL0I7QUFBaUM7QUFFbEd0aUMsT0FBT29ELGdCQUFnQixDQUFFay9CLGdDQUFnQ0M7QUFFekQ7Ozs7OztDQU1DLEdBQ0QsSUFBSUksVUFBVyxTQUFVQyxZQUFZO0lBQ25DLFNBQVNEO1FBQ1BDLGFBQWF0Z0MsSUFBSSxDQUFDLElBQUk7UUFDdEIsSUFBSSxDQUFDdWdDLElBQUksR0FBRyxJQUFJN1A7SUFDbEI7SUFFQSxJQUFLNFAsY0FBZUQsUUFBUWxnQyxTQUFTLEdBQUdtZ0M7SUFDeENELFFBQVE1aUMsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFa2dDLGdCQUFnQkEsYUFBYTdpQyxTQUFTO0lBQ3pFNGlDLFFBQVE1aUMsU0FBUyxDQUFDNEMsV0FBVyxHQUFHZ2dDO0lBQ2hDOztHQUVDLEdBQ0RBLFFBQVE1aUMsU0FBUyxDQUFDb0QsR0FBRyxHQUFHLFNBQVNBLElBQUt1eEIsR0FBRztRQUN2QyxPQUFPLElBQUksQ0FBQ21PLElBQUksQ0FBQzEvQixHQUFHLENBQUN1eEIsUUFBUTtJQUMvQjtJQUVBOztHQUVDLEdBQ0RpTyxRQUFRNWlDLFNBQVMsQ0FBQ2t6QixHQUFHLEdBQUcsU0FBU0EsSUFBS3lCLEdBQUcsRUFBRXYwQixLQUFLO1FBQzlDLElBQUksQ0FBQzBpQyxJQUFJLENBQUN4VixHQUFHLENBQUNxSCxLQUFLdjBCO1FBQ25CLE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEd2lDLFFBQVE1aUMsU0FBUyxDQUFDbXpCLE1BQU0sR0FBRyxTQUFTQTtRQUNsQyxJQUFJaEYsWUFBWSxJQUFJWDtRQUNwQixJQUFJa04sS0FBSyxJQUFJLENBQUNvSSxJQUFJLENBQUMzUCxNQUFNO1FBQ3pCLElBQUlydUIsSUFBSTQxQixHQUFHaFQsSUFBSTtRQUNmLE1BQU8sQ0FBQzVpQixFQUFFaStCLElBQUksQ0FBRTtZQUNkNVUsVUFBVWxpQixHQUFHLENBQUNuSCxFQUFFMUUsS0FBSztZQUNyQjBFLElBQUk0MUIsR0FBR2hULElBQUk7UUFDYjtRQUNBLE9BQU95RztJQUNUO0lBRUE7O0dBRUMsR0FDRHlVLFFBQVE1aUMsU0FBUyxDQUFDb3pCLFFBQVEsR0FBRyxTQUFTQTtRQUNwQyxJQUFJTyxVQUFVLElBQUlIO1FBQ2xCLElBQUksQ0FBQ3NQLElBQUksQ0FBQ0UsT0FBTyxHQUFHQyxPQUFPLENBQUMsU0FBVXRJLEtBQUs7WUFBSSxPQUFPaEgsUUFBUTFuQixHQUFHLENBQUMwdUI7UUFBUTtRQUMxRSxPQUFPaEg7SUFDVDtJQUVBOztHQUVDLEdBQ0RpUCxRQUFRNWlDLFNBQVMsQ0FBQzJULElBQUksR0FBRyxTQUFTQTtRQUNoQyxPQUFPLElBQUksQ0FBQ212QixJQUFJLENBQUNudkIsSUFBSTtJQUN2QjtJQUVBLE9BQU9pdkI7QUFDVCxFQUFFNVA7QUFFRixJQUFJa1EsaUJBQWlCLFNBQVNBO0lBQzVCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2QsSUFBSXRpQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUMwaUMsVUFBVSxHQUFHRCxlQUFlRyxRQUFRO0lBQzNDLE9BQU8sSUFBSXZpQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZd2lDLE1BQU07WUFDaEMsSUFBSUMsWUFBWXppQyxTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUNxaUMsVUFBVSxHQUFHSTtZQUNsQixJQUFJQSxjQUFjTCxlQUFlTSxLQUFLLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQ0MsUUFBUSxDQUFDO1lBQ2hCO1FBQ0YsT0FBTyxJQUFJLE9BQU8zaUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQzNDLElBQUlnSyxRQUFRaEssU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSSxDQUFDcWlDLFVBQVUsR0FBR0QsZUFBZU0sS0FBSztZQUN0QyxJQUFJLENBQUNDLFFBQVEsQ0FBQzM0QjtRQUNoQixPQUFPLElBQUloSyxTQUFTLENBQUMsRUFBRSxZQUFZb2lDLGdCQUFnQjtZQUNqRCxJQUFJUSxLQUFLNWlDLFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQ3FpQyxVQUFVLEdBQUdPLEdBQUdQLFVBQVU7WUFDL0IsSUFBSSxDQUFDQyxNQUFNLEdBQUdNLEdBQUdOLE1BQU07UUFDekI7SUFDRjtBQUNGO0FBRUEsSUFBSU8scUJBQXFCO0lBQUUxL0Isa0JBQWtCO1FBQUU5RCxjQUFjO0lBQUs7SUFBRXlqQyxxQkFBcUI7UUFBRXpqQyxjQUFjO0lBQUs7QUFBRTtBQUNoSCtpQyxlQUFlbGpDLFNBQVMsQ0FBQzJFLE1BQU0sR0FBRyxTQUFTQSxPQUFRSCxLQUFLO0lBQ3RELElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCMCtCLGNBQWEsR0FBSTtRQUN0QyxPQUFPO0lBQ1Q7SUFDQSxJQUFJVyxzQkFBc0JyL0I7SUFDMUIsT0FBTyxJQUFJLENBQUMyK0IsVUFBVSxLQUFLVSxvQkFBb0JWLFVBQVUsSUFBSSxJQUFJLENBQUNDLE1BQU0sS0FBS1Msb0JBQW9CVCxNQUFNO0FBQ3pHO0FBQ0FGLGVBQWVsakMsU0FBUyxDQUFDNkUsU0FBUyxHQUFHLFNBQVNBLFVBQVdDLENBQUM7SUFDeEQsSUFBSU4sUUFBUU07SUFDWixJQUFJeUssWUFBWSxJQUFJLENBQUN1MEIsMkJBQTJCO0lBQ2hELElBQUlDLGlCQUFpQnYvQixNQUFNcy9CLDJCQUEyQjtJQUN0RCxPQUFPLElBQUk5NkIsUUFBUXVHLFdBQVcxSyxTQUFTLENBQUMsSUFBSW1FLFFBQVErNkI7QUFDdEQ7QUFDQWIsZUFBZWxqQyxTQUFTLENBQUNna0MsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sSUFBSSxDQUFDWixNQUFNO0FBQ3BCO0FBQ0FGLGVBQWVsakMsU0FBUyxDQUFDaWtDLFVBQVUsR0FBRyxTQUFTQTtJQUM3QyxPQUFPLElBQUksQ0FBQ2QsVUFBVSxLQUFLRCxlQUFlRyxRQUFRLElBQUksSUFBSSxDQUFDRixVQUFVLEtBQUtELGVBQWVnQixlQUFlO0FBQzFHO0FBQ0FoQixlQUFlbGpDLFNBQVMsQ0FBQ21rQyxPQUFPLEdBQUcsU0FBU0E7SUFDMUMsT0FBTyxJQUFJLENBQUNoQixVQUFVO0FBQ3hCO0FBQ0FELGVBQWVsakMsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLElBQUltL0IsY0FBYztJQUNsQixJQUFJLElBQUksQ0FBQ2pCLFVBQVUsS0FBS0QsZUFBZUcsUUFBUSxFQUFFO1FBQy9DZSxjQUFjO0lBQ2hCLE9BQU8sSUFBSSxJQUFJLENBQUNqQixVQUFVLEtBQUtELGVBQWVnQixlQUFlLEVBQUU7UUFDN0RFLGNBQWM7SUFDaEIsT0FBTyxJQUFJLElBQUksQ0FBQ2pCLFVBQVUsS0FBS0QsZUFBZU0sS0FBSyxFQUFFO1FBQ25EWSxjQUFjLGtCQUFrQixJQUFJLENBQUNKLFFBQVEsS0FBSztJQUNwRDtJQUNBLE9BQU9JO0FBQ1Q7QUFDQWxCLGVBQWVsakMsU0FBUyxDQUFDbWlCLFdBQVcsR0FBRyxTQUFTQTtJQUM5QyxJQUFJLE9BQU9yaEIsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQ3BDLElBQUlPLE1BQU1QLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUkrQixPQUFPckIsS0FBSyxDQUFDSCxNQUFNO1lBQUUsT0FBT0E7UUFBSTtRQUNwQyxJQUFJLElBQUksQ0FBQzhoQyxVQUFVLEtBQUtELGVBQWVnQixlQUFlLEVBQUU7WUFDdEQsSUFBSUcsaUJBQWlCaGpDO1lBQ3JCLE9BQU9nakM7UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDbEIsVUFBVSxLQUFLRCxlQUFlTSxLQUFLLEVBQUU7WUFDNUMsT0FBTzlpQyxLQUFLNGpDLEtBQUssQ0FBQ2pqQyxNQUFNLElBQUksQ0FBQytoQyxNQUFNLElBQUksSUFBSSxDQUFDQSxNQUFNO1FBQ3BEO1FBQ0EsT0FBTy9oQztJQUNULE9BQU8sSUFBSVAsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7UUFDN0MsSUFBSXNvQixRQUFRbHJCLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUksSUFBSSxDQUFDcWlDLFVBQVUsS0FBS0QsZUFBZUcsUUFBUSxFQUFFO1lBQUUsT0FBTztRQUFLO1FBQy9EclgsTUFBTXRxQixDQUFDLEdBQUcsSUFBSSxDQUFDeWdCLFdBQVcsQ0FBQzZKLE1BQU10cUIsQ0FBQztRQUNsQ3NxQixNQUFNcm9CLENBQUMsR0FBRyxJQUFJLENBQUN3ZSxXQUFXLENBQUM2SixNQUFNcm9CLENBQUM7SUFDcEM7QUFDRjtBQUNBdS9CLGVBQWVsakMsU0FBUyxDQUFDOGpDLDJCQUEyQixHQUFHLFNBQVNBO0lBQzlELElBQUlTLGVBQWU7SUFDbkIsSUFBSSxJQUFJLENBQUNwQixVQUFVLEtBQUtELGVBQWVHLFFBQVEsRUFBRTtRQUMvQ2tCLGVBQWU7SUFDakIsT0FBTyxJQUFJLElBQUksQ0FBQ3BCLFVBQVUsS0FBS0QsZUFBZWdCLGVBQWUsRUFBRTtRQUM3REssZUFBZTtJQUNqQixPQUFPLElBQUksSUFBSSxDQUFDcEIsVUFBVSxLQUFLRCxlQUFlTSxLQUFLLEVBQUU7UUFDbkRlLGVBQWUsSUFBSTdqQyxLQUFLZSxLQUFLLENBQUNmLEtBQUtpQixJQUFJLENBQUNqQixLQUFLaUgsR0FBRyxDQUFDLElBQUksQ0FBQ3E4QixRQUFRLE1BQU10akMsS0FBS2lILEdBQUcsQ0FBQztJQUMvRTtJQUNBLE9BQU80OEI7QUFDVDtBQUNBckIsZUFBZWxqQyxTQUFTLENBQUN5akMsUUFBUSxHQUFHLFNBQVNBLFNBQVUzNEIsS0FBSztJQUMxRCxJQUFJLENBQUNzNEIsTUFBTSxHQUFHMWlDLEtBQUt5QixHQUFHLENBQUMySTtBQUN6QjtBQUNBbzRCLGVBQWVsakMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlDLE9BQU87UUFBQzRCO1FBQWNIO0tBQVc7QUFDbkM7QUFDQTQvQixlQUFlbGpDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPb2hDO0FBQ1Q7QUFDQUEsZUFBZXNCLFdBQVcsR0FBRyxTQUFTQSxZQUFhQyxHQUFHLEVBQUVDLEdBQUc7SUFDekQsSUFBSUQsSUFBSTUvQixTQUFTLENBQUM2L0IsUUFBUSxHQUFHO1FBQUUsT0FBT0Q7SUFBSTtJQUMxQyxPQUFPQztBQUNUO0FBQ0FmLG1CQUFtQjEvQixnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFvQjtBQUNuRnVnQyxtQkFBbUJDLG1CQUFtQixDQUFDeGdDLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBbUI7QUFFckZuRCxPQUFPb0QsZ0JBQWdCLENBQUU2L0IsZ0JBQWdCUztBQUV6QyxJQUFJTCxPQUFPLFNBQVNBLEtBQU05Z0MsSUFBSTtJQUM1QixJQUFJLENBQUNtaUMsS0FBSyxHQUFHbmlDLFFBQVE7SUFDckI4Z0MsS0FBS3NCLGFBQWEsQ0FBQzFSLEdBQUcsQ0FBQzF3QixNQUFNLElBQUk7QUFDbkM7QUFFQSxJQUFJcWlDLHNCQUFzQjtJQUFFNWdDLGtCQUFrQjtRQUFFOUQsY0FBYztJQUFLO0lBQUV5a0MsZUFBZTtRQUFFemtDLGNBQWM7SUFBSztBQUFFO0FBQzNHbWpDLEtBQUt0akMsU0FBUyxDQUFDMGlDLFdBQVcsR0FBRyxTQUFTQTtJQUNwQyxPQUFPWSxLQUFLc0IsYUFBYSxDQUFDeGhDLEdBQUcsQ0FBQyxJQUFJLENBQUN1aEMsS0FBSztBQUMxQztBQUNBckIsS0FBS3RqQyxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDakMsT0FBTyxJQUFJLENBQUMwL0IsS0FBSztBQUNuQjtBQUNBckIsS0FBS3RqQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDcEMsT0FBTztRQUFDNEI7S0FBYTtBQUN2QjtBQUNBNi9CLEtBQUt0akMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pDLE9BQU93aEM7QUFDVDtBQUNBdUIsb0JBQW9CNWdDLGdCQUFnQixDQUFDYixHQUFHLEdBQUc7SUFBYyxPQUFPLENBQUM7QUFBb0I7QUFDckZ5aEMsb0JBQW9CRCxhQUFhLENBQUN4aEMsR0FBRyxHQUFHO0lBQWMsT0FBTyxJQUFJdy9CO0FBQVU7QUFFM0UzaUMsT0FBT29ELGdCQUFnQixDQUFFaWdDLE1BQU11QjtBQUUvQjNCLGVBQWVJLElBQUksR0FBR0E7QUFDdEJKLGVBQWVNLEtBQUssR0FBRyxJQUFJRixLQUFLO0FBQ2hDSixlQUFlRyxRQUFRLEdBQUcsSUFBSUMsS0FBSztBQUNuQ0osZUFBZWdCLGVBQWUsR0FBRyxJQUFJWixLQUFLO0FBRTFDLElBQUk1cUIsa0JBQWtCLFNBQVNBO0lBQzdCLElBQUksQ0FBQytGLGVBQWUsR0FBRyxJQUFJeWtCO0lBQzNCLElBQUksQ0FBQ3phLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ3FjLDBCQUEwQixHQUFHcHNCLGdCQUFnQnFzQixtQ0FBbUM7SUFFckYsSUFBSWprQyxVQUFVTCxNQUFNLEtBQUssR0FBRyxDQUM1QixPQUFPLElBQUlLLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkwRyxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRTRGLDRCQUE0QjtZQUN6RCxJQUFJLENBQUNvK0IsMEJBQTBCLEdBQUdoa0MsU0FBUyxDQUFDLEVBQUU7UUFDaEQsT0FBTyxJQUFJQSxTQUFTLENBQUMsRUFBRSxZQUFZb2lDLGdCQUFnQjtZQUNqRCxJQUFJLENBQUN6a0IsZUFBZSxHQUFHM2QsU0FBUyxDQUFDLEVBQUU7UUFDckM7SUFDRixPQUFPLElBQUlBLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUksQ0FBQ2dlLGVBQWUsR0FBRzNkLFNBQVMsQ0FBQyxFQUFFO1FBQ25DLElBQUksQ0FBQzJuQixLQUFLLEdBQUczbkIsU0FBUyxDQUFDLEVBQUU7SUFDM0IsT0FBTyxJQUFJQSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJLENBQUNnZSxlQUFlLEdBQUczZCxTQUFTLENBQUMsRUFBRTtRQUNuQyxJQUFJLENBQUMybkIsS0FBSyxHQUFHM25CLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUksQ0FBQ2drQywwQkFBMEIsR0FBR2hrQyxTQUFTLENBQUMsRUFBRTtJQUNoRDtBQUNGO0FBRUEsSUFBSWtrQyxvQkFBb0I7SUFBRS9nQyxrQkFBa0I7UUFBRTlELGNBQWM7SUFBSztBQUFFO0FBQ25FdVksZ0JBQWdCMVksU0FBUyxDQUFDMHFCLFVBQVUsR0FBRyxTQUFTQSxXQUFZcUgsUUFBUTtJQUNsRSxJQUFJQSxTQUFTbmIsTUFBTSxJQUFJO1FBQ3JCLE9BQU8sSUFBSSxDQUFDOEUsV0FBVyxDQUFDO0lBQzFCO0lBQ0EsSUFBSXFXLFNBQVNoYixPQUFPLE9BQU9nYixTQUFTbGIsT0FBTyxNQUFNa2IsU0FBUy9hLE9BQU8sT0FBTythLFNBQVNqYixPQUFPLElBQUk7UUFDMUYsT0FBTyxJQUFJLENBQUM0RSxXQUFXLENBQUMsSUFBSWhZLFdBQVdxdUIsU0FBU2hiLE9BQU8sSUFBSWdiLFNBQVMvYSxPQUFPO0lBQzdFO0lBQ0EsSUFBSSthLFNBQVNoYixPQUFPLE9BQU9nYixTQUFTbGIsT0FBTyxNQUFNa2IsU0FBUy9hLE9BQU8sT0FBTythLFNBQVNqYixPQUFPLElBQUk7UUFDMUYsT0FBTyxJQUFJLENBQUNxRixnQkFBZ0IsQ0FBQztZQUFDLElBQUl6WSxXQUFXcXVCLFNBQVNoYixPQUFPLElBQUlnYixTQUFTL2EsT0FBTztZQUFLLElBQUl0VCxXQUFXcXVCLFNBQVNsYixPQUFPLElBQUlrYixTQUFTamIsT0FBTztTQUFJO0lBQy9JO0lBQ0EsT0FBTyxJQUFJLENBQUMyRixhQUFhLENBQUMsSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQztRQUFDLElBQUkxWSxXQUFXcXVCLFNBQVNoYixPQUFPLElBQUlnYixTQUFTL2EsT0FBTztRQUFLLElBQUl0VCxXQUFXcXVCLFNBQVNoYixPQUFPLElBQUlnYixTQUFTamIsT0FBTztRQUFLLElBQUlwVCxXQUFXcXVCLFNBQVNsYixPQUFPLElBQUlrYixTQUFTamIsT0FBTztRQUFLLElBQUlwVCxXQUFXcXVCLFNBQVNsYixPQUFPLElBQUlrYixTQUFTL2EsT0FBTztRQUFLLElBQUl0VCxXQUFXcXVCLFNBQVNoYixPQUFPLElBQUlnYixTQUFTL2EsT0FBTztLQUFJLEdBQUc7QUFDN1U7QUFDQTBCLGdCQUFnQjFZLFNBQVMsQ0FBQ21jLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQnFVLFdBQVc7SUFDakYsSUFBSSxDQUFDQSxhQUFhO1FBQUUsT0FBTyxJQUFJMkosV0FBVyxJQUFJLENBQUNrRSw0QkFBNEIsR0FBRzE3QixNQUFNLENBQUMsRUFBRSxHQUFHLElBQUk7SUFBRSxPQUMzRixJQUFJNnRCLHVCQUF1Qnp3QixPQUFPO1FBQUUsT0FBTyxJQUFJbzZCLFdBQVcsSUFBSSxDQUFDa0UsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDNnRCLGNBQWMsSUFBSTtJQUFFLE9BQ3pILElBQUlycEIsYUFBYXFwQixhQUFhaGQscUJBQXFCO1FBQUUsT0FBTyxJQUFJMm1CLFdBQVczSixhQUFhLElBQUk7SUFBRTtBQUNyRztBQUNBOVgsZ0JBQWdCMVksU0FBUyxDQUFDcWMscUJBQXFCLEdBQUcsU0FBU0E7SUFDekQsSUFBSXZiLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE9BQU8sSUFBSXM0QixnQkFBZ0IsTUFBTSxJQUFJO0lBQ3ZDLE9BQU8sSUFBSWo0QixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNDRCLGNBQWN2NEIsU0FBUyxDQUFDLEVBQUU7UUFDOUIsT0FBTyxJQUFJaTRCLGdCQUFnQk0sYUFBYSxJQUFJO0lBQzlDO0FBQ0Y7QUFDQTNnQixnQkFBZ0IxWSxTQUFTLENBQUNpbEMsYUFBYSxHQUFHLFNBQVNBLGNBQWVDLFFBQVE7SUFDeEUsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxrQkFBa0I7SUFDdEIsSUFBSUMsd0JBQXdCO0lBQzVCLElBQUssSUFBSWorQixJQUFJODlCLFNBQVM3WixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDOUMsSUFBSW5ELE9BQU9oaEIsRUFBRXNnQixJQUFJO1FBQ2pCLElBQUk0ZCxZQUFZbGQsS0FBS3RtQixRQUFRO1FBQzdCLElBQUlxakMsY0FBYyxNQUFNO1lBQ3RCQSxZQUFZRztRQUNkO1FBQ0EsSUFBSUEsY0FBY0gsV0FBVztZQUMzQkMsa0JBQWtCO1FBQ3BCO1FBQ0EsSUFBSWhkLEtBQUt1RCw2QkFBNkIsSUFBSTtZQUFFMFosd0JBQXdCO1FBQU07SUFDNUU7SUFDQSxJQUFJRixjQUFjLE1BQU07UUFDdEIsT0FBTyxJQUFJLENBQUNsb0Isd0JBQXdCO0lBQ3RDO0lBQ0EsSUFBSW1vQixtQkFBbUJDLHVCQUF1QjtRQUM1QyxPQUFPLElBQUksQ0FBQ3BvQix3QkFBd0IsQ0FBQ3ZFLGdCQUFnQjZzQixlQUFlLENBQUNMO0lBQ3ZFO0lBQ0EsSUFBSU0sUUFBUU4sU0FBUzdaLFFBQVEsR0FBRzNELElBQUk7SUFDcEMsSUFBSStkLGVBQWVQLFNBQVN2eEIsSUFBSSxLQUFLO0lBQ3JDLElBQUk4eEIsY0FBYztRQUNoQixJQUFJRCxpQkFBaUI5RyxTQUFTO1lBQzVCLE9BQU8sSUFBSSxDQUFDNWhCLGtCQUFrQixDQUFDcEUsZ0JBQWdCZ3RCLGNBQWMsQ0FBQ1I7UUFDaEUsT0FBTyxJQUFJTSxpQkFBaUJyTCxZQUFZO1lBQ3RDLE9BQU8sSUFBSSxDQUFDOWQscUJBQXFCLENBQUMzRCxnQkFBZ0JpdEIsaUJBQWlCLENBQUNUO1FBQ3RFLE9BQU8sSUFBSU0saUJBQWlCaEgsT0FBTztZQUNqQyxPQUFPLElBQUksQ0FBQ3ppQixnQkFBZ0IsQ0FBQ3JELGdCQUFnQmt0QixZQUFZLENBQUNWO1FBQzVEO1FBQ0F4bkIsT0FBT0Msb0JBQW9CLENBQUMsc0JBQXNCNm5CLE1BQU0xakMsUUFBUSxHQUFHMi9CLE9BQU87SUFDNUU7SUFDQSxPQUFPK0Q7QUFDVDtBQUNBOXNCLGdCQUFnQjFZLFNBQVMsQ0FBQ2s2QiwwQkFBMEIsR0FBRyxTQUFTQSwyQkFBNEIxSixXQUFXO0lBQ3JHLE9BQU8sSUFBSSxDQUFDelUsZ0JBQWdCLENBQUN5VSxnQkFBZ0IsT0FBTyxJQUFJLENBQUM2Tiw0QkFBNEIsR0FBRzE3QixNQUFNLENBQUM2dEIsZUFBZTtBQUNoSDtBQUNBOVgsZ0JBQWdCMVksU0FBUyxDQUFDMGIsV0FBVyxHQUFHLFNBQVNBO0lBQy9DLElBQUk1YSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPLElBQUksQ0FBQ2liLFdBQVcsQ0FBQyxJQUFJLENBQUMyaUIsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDLEVBQUU7SUFDdkUsT0FBTyxJQUFJN0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7WUFDdEMsSUFBSXFXLGFBQWFqWixTQUFTLENBQUMsRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQzRhLFdBQVcsQ0FBQzNCLGVBQWUsT0FBTyxJQUFJLENBQUNza0IsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDO2dCQUFDb1g7YUFBVyxJQUFJO1FBQzNHLE9BQU8sSUFBSTVTLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFMFMscUJBQXFCO1lBQ3pELElBQUlnZCxjQUFjMXZCLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLE9BQU8sSUFBSTA5QixNQUFNaE8sYUFBYSxJQUFJO1FBQ3BDO0lBQ0Y7QUFDRjtBQUNBOVgsZ0JBQWdCMVksU0FBUyxDQUFDcStCLDRCQUE0QixHQUFHLFNBQVNBO0lBQ2hFLE9BQU8sSUFBSSxDQUFDeUcsMEJBQTBCO0FBQ3hDO0FBQ0Fwc0IsZ0JBQWdCMVksU0FBUyxDQUFDeWMsYUFBYSxHQUFHLFNBQVNBO0lBQ2pELElBQUkzYixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPLElBQUlpK0IsUUFBUSxNQUFNLE1BQU0sSUFBSTtJQUNyQyxPQUFPLElBQUk1OUIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTBHLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFMFMscUJBQXFCO1lBQ2xELElBQUlnZCxjQUFjMXZCLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDMmIsYUFBYSxDQUFDLElBQUksQ0FBQ0wsZ0JBQWdCLENBQUNvVTtRQUNsRCxPQUFPLElBQUkxdkIsU0FBUyxDQUFDLEVBQUUsWUFBWWYsT0FBTztZQUN4QyxJQUFJOGxDLGdCQUFnQi9rQyxTQUFTLENBQUMsRUFBRTtZQUNoQyxPQUFPLElBQUksQ0FBQzJiLGFBQWEsQ0FBQyxJQUFJLENBQUNMLGdCQUFnQixDQUFDeXBCO1FBQ2xELE9BQU8sSUFBSS9rQyxTQUFTLENBQUMsRUFBRSxZQUFZcy9CLFlBQVk7WUFDN0MsSUFBSXhqQixRQUFROWIsU0FBUyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxJQUFJLENBQUMyYixhQUFhLENBQUNHLE9BQU87UUFDbkM7SUFDRixPQUFPLElBQUk5YixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJcWxDLFVBQVVobEMsU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSStiLFFBQVEvYixTQUFTLENBQUMsRUFBRTtRQUN4QixPQUFPLElBQUk0OUIsUUFBUW9ILFNBQVNqcEIsT0FBTyxJQUFJO0lBQ3pDO0FBQ0Y7QUFDQW5FLGdCQUFnQjFZLFNBQVMsQ0FBQzJvQixPQUFPLEdBQUcsU0FBU0E7SUFDM0MsT0FBTyxJQUFJLENBQUNGLEtBQUs7QUFDbkI7QUFDQS9QLGdCQUFnQjFZLFNBQVMsQ0FBQ2lkLHdCQUF3QixHQUFHLFNBQVNBO0lBQzVELElBQUluYyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPLElBQUkrMkIsbUJBQW1CLE1BQU0sSUFBSTtJQUMxQyxPQUFPLElBQUkxMkIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSW9yQixhQUFhL3FCLFNBQVMsQ0FBQyxFQUFFO1FBQzdCLE9BQU8sSUFBSTAyQixtQkFBbUIzTCxZQUFZLElBQUk7SUFDaEQ7QUFDRjtBQUNBblQsZ0JBQWdCMVksU0FBUyxDQUFDK2xDLGNBQWMsR0FBRyxTQUFTQSxlQUFnQmxjLENBQUM7SUFDbkUsSUFBSW1jLFNBQVMsSUFBSXBGLGVBQWUsSUFBSTtJQUNwQyxPQUFPb0YsT0FBTzVFLElBQUksQ0FBQ3ZYLEdBQUc7UUFDcEJ1WCxNQUFNO1lBQ0osSUFBSXRnQyxVQUFVTCxNQUFNLEtBQUssR0FBRztnQkFDMUIsSUFBSXdoQyxXQUFXbmhDLFNBQVMsQ0FBQyxFQUFFO2dCQUMzQixnQ0FBZ0M7Z0JBQ2hDLE9BQU8sSUFBSSxDQUFDZ2tDLDBCQUEwQixDQUFDbmlDLE1BQU0sQ0FBQ3MvQjtZQUNoRDtRQUNGO0lBQ0Y7QUFDRjtBQUNBdnBCLGdCQUFnQjFZLFNBQVMsQ0FBQytxQixpQkFBaUIsR0FBRyxTQUFTQTtJQUNyRCxPQUFPLElBQUksQ0FBQ3RNLGVBQWU7QUFDN0I7QUFDQS9GLGdCQUFnQjFZLFNBQVMsQ0FBQ29jLGdCQUFnQixHQUFHLFNBQVNBO0lBQ3BELElBQUl0YixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPLElBQUksQ0FBQzJiLGdCQUFnQixDQUFDLElBQUksQ0FBQ2lpQiw0QkFBNEIsR0FBRzE3QixNQUFNLENBQUMsRUFBRTtJQUM1RSxPQUFPLElBQUk3QixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZZixPQUFPO1lBQ2pDLElBQUl5d0IsY0FBYzF2QixTQUFTLENBQUMsRUFBRTtZQUM5QixPQUFPLElBQUksQ0FBQ3NiLGdCQUFnQixDQUFDb1UsZ0JBQWdCLE9BQU8sSUFBSSxDQUFDNk4sNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDNnRCLGVBQWU7UUFDaEgsT0FBTyxJQUFJcnBCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFMFMscUJBQXFCO1lBQ3pELElBQUlxeUIsZ0JBQWdCL2tDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sSUFBSXMvQixXQUFXeUYsZUFBZSxJQUFJO1FBQzNDO0lBQ0Y7QUFDRjtBQUNBbnRCLGdCQUFnQjFZLFNBQVMsQ0FBQzhjLGtCQUFrQixHQUFHLFNBQVNBO0lBQ3RELElBQUloYyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPLElBQUlnZ0MsYUFBYSxNQUFNLElBQUk7SUFDcEMsT0FBTyxJQUFJMy9CLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlzYyxXQUFXamMsU0FBUyxDQUFDLEVBQUU7UUFDM0IsT0FBTyxJQUFJMi9CLGFBQWExakIsVUFBVSxJQUFJO0lBQ3hDO0FBQ0Y7QUFDQXJFLGdCQUFnQjFZLFNBQVMsQ0FBQytiLGdCQUFnQixHQUFHLFNBQVNBO0lBQ2xELElBQUl6QixTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE9BQU8sSUFBSXkvQixXQUFXLE1BQU0sSUFBSTtJQUNsQyxPQUFPLElBQUlwL0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWWYsT0FBTztZQUNqQyxJQUFJa2EsUUFBUW5aLFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLE9BQU8sSUFBSW8vQixXQUFXam1CLE9BQU8sSUFBSTtRQUNuQyxPQUFPLElBQUluWixTQUFTLENBQUMsRUFBRSxZQUFZZixPQUFPO1lBQ3hDLElBQUl5d0IsY0FBYzF2QixTQUFTLENBQUMsRUFBRTtZQUM5QixPQUFPLElBQUksQ0FBQ2liLGdCQUFnQixDQUFDeVUsZ0JBQWdCLE9BQU8sSUFBSSxDQUFDNk4sNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDNnRCLGVBQWU7UUFDaEgsT0FBTyxJQUFJcnBCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFMFMscUJBQXFCO1lBQ3pELElBQUlxeUIsZ0JBQWdCL2tDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLElBQUkra0Msa0JBQWtCLE1BQU07Z0JBQzFCLE9BQU8sSUFBSSxDQUFDOXBCLGdCQUFnQixDQUFDLElBQUloYyxNQUFNLEdBQUdNLElBQUksQ0FBQztZQUNqRDtZQUNBLElBQUkyYixTQUFTLElBQUlqYyxNQUFNOGxDLGNBQWNseUIsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO1lBQ2xELElBQUssSUFBSStHLElBQUksR0FBR0EsSUFBSXkrQixjQUFjbHlCLElBQUksSUFBSXZNLElBQUs7Z0JBQzdDLElBQUk2K0IsUUFBUTNyQixPQUFPK2pCLDRCQUE0QixHQUFHMTdCLE1BQU0sQ0FBQyxHQUFHa2pDLGNBQWMveEIsWUFBWTtnQkFDdEZpcEIsb0JBQW9CLzNCLElBQUksQ0FBQzZnQyxlQUFleitCLEdBQUc2K0IsT0FBTyxHQUFHO2dCQUNyRGpxQixNQUFNLENBQUM1VSxFQUFFLEdBQUdrVCxPQUFPb0IsV0FBVyxDQUFDdXFCO1lBQ2pDO1lBQ0EsT0FBTyxJQUFJLENBQUNscUIsZ0JBQWdCLENBQUNDO1FBQy9CO0lBQ0Y7QUFDRjtBQUNBdEQsZ0JBQWdCMVksU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQy9DLE9BQU87UUFBQzRCO0tBQWE7QUFDdkI7QUFDQWlWLGdCQUFnQjFZLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM1QyxPQUFPNFc7QUFDVDtBQUNBQSxnQkFBZ0J3dEIsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCQyxhQUFhO0lBQy9FLElBQUlDLG9CQUFvQixJQUFJcm1DLE1BQU1vbUMsY0FBY3h5QixJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDN0QsT0FBTzhsQyxjQUFjblosT0FBTyxDQUFDb1o7QUFDL0I7QUFDQTF0QixnQkFBZ0I2c0IsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQjFaLFVBQVU7SUFDcEUsSUFBSUEsZUFBZSxNQUFNO1FBQUUsT0FBTztJQUFLO0lBQ3ZDLElBQUl3YSxnQkFBZ0IsSUFBSXRtQyxNQUFNOHJCLFdBQVdsWSxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDdEQsT0FBT3dyQixXQUFXbUIsT0FBTyxDQUFDcVo7QUFDNUI7QUFDQTN0QixnQkFBZ0Jxc0IsbUNBQW1DLEdBQUcsU0FBU0E7SUFDN0QsT0FBT3hDLCtCQUErQkksUUFBUTtBQUNoRDtBQUNBanFCLGdCQUFnQjR0QixzQkFBc0IsR0FBRyxTQUFTQSx1QkFBd0JDLGdCQUFnQjtJQUN4RixJQUFJQyx1QkFBdUIsSUFBSXptQyxNQUFNd21DLGlCQUFpQjV5QixJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDbkUsT0FBT2ttQyxpQkFBaUJ2WixPQUFPLENBQUN3WjtBQUNsQztBQUNBOXRCLGdCQUFnQml0QixpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJ0TSxXQUFXO0lBQ3pFLElBQUlvTixrQkFBa0IsSUFBSTFtQyxNQUFNczVCLFlBQVkxbEIsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO0lBQ3pELE9BQU9nNUIsWUFBWXJNLE9BQU8sQ0FBQ3laO0FBQzdCO0FBQ0EvdEIsZ0JBQWdCZ3VCLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQkMsV0FBVztJQUN6RSxJQUFJQyxrQkFBa0IsSUFBSTdtQyxNQUFNNG1DLFlBQVloekIsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO0lBQ3pELE9BQU9zbUMsWUFBWTNaLE9BQU8sQ0FBQzRaO0FBQzdCO0FBQ0FsdUIsZ0JBQWdCbXVCLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQkMsV0FBVztJQUN6RSxJQUFJQyxrQkFBa0IsSUFBSWhuQyxNQUFNK21DLFlBQVluekIsSUFBSSxJQUFJdFQsSUFBSSxDQUFDO0lBQ3pELE9BQU95bUMsWUFBWTlaLE9BQU8sQ0FBQytaO0FBQzdCO0FBQ0FydUIsZ0JBQWdCa3RCLFlBQVksR0FBRyxTQUFTQSxhQUFjNXBCLE1BQU07SUFDMUQsSUFBSWdyQixhQUFhLElBQUlqbkMsTUFBTWljLE9BQU9ySSxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDL0MsT0FBTzJiLE9BQU9nUixPQUFPLENBQUNnYTtBQUN4QjtBQUNBdHVCLGdCQUFnQmd0QixjQUFjLEdBQUcsU0FBU0EsZUFBZ0Izb0IsUUFBUTtJQUNoRSxJQUFJa3FCLGVBQWUsSUFBSWxuQyxNQUFNZ2QsU0FBU3BKLElBQUksSUFBSXRULElBQUksQ0FBQztJQUNuRCxPQUFPMGMsU0FBU2lRLE9BQU8sQ0FBQ2lhO0FBQzFCO0FBQ0F2dUIsZ0JBQWdCd3VCLDRCQUE0QixHQUFHLFNBQVNBLDZCQUE4QmxiLEtBQUssRUFBRW1iLFFBQVE7SUFDbkdBLFNBQVNwYyxpQkFBaUIsR0FBRzVJLFdBQVcsQ0FBQzZKO0lBQ3pDLE9BQU9tYixTQUFTM2QsVUFBVSxHQUFHOU4sV0FBVyxDQUFDc1E7QUFDM0M7QUFDQWdaLGtCQUFrQi9nQyxnQkFBZ0IsQ0FBQ2IsR0FBRyxHQUFHO0lBQWMsT0FBTyxDQUFDO0FBQW9CO0FBRW5GbkQsT0FBT29ELGdCQUFnQixDQUFFcVYsaUJBQWlCc3NCO0FBRTFDLElBQUlvQyxnQkFBZ0I7SUFBQztJQUFTO0lBQWM7SUFBYztJQUFtQjtJQUFXO0NBQWU7QUFFdkc7OztDQUdDLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUNELElBQUlDLGdCQUFnQixTQUFTQSxjQUFlNXVCLGVBQWU7SUFDekQsSUFBSSxDQUFDQSxlQUFlLEdBQUdBLG1CQUFtQixJQUFJQztBQUNoRDtBQUNBOzs7Ozs7O0NBT0MsR0FDRDJ1QixjQUFjcm5DLFNBQVMsQ0FBQzJZLElBQUksR0FBRyxTQUFTQSxLQUFNMnVCLElBQUk7SUFDaEQsSUFBSXRZO0lBQ0osSUFBSSxPQUFPc1ksU0FBUyxVQUFVO1FBQzVCdFksTUFBTXVZLEtBQUs3OUIsS0FBSyxDQUFDNDlCO0lBQ25CLE9BQU87UUFDTHRZLE1BQU1zWTtJQUNSO0lBRUEsSUFBSXh1QixPQUFPa1csSUFBSWxXLElBQUk7SUFFbkIsSUFBSSxDQUFDcFAsS0FBSyxDQUFDb1AsS0FBSyxFQUFFO1FBQ2hCLE1BQU0sSUFBSXpXLE1BQU0sMkJBQTJCMnNCLElBQUlsVyxJQUFJO0lBQ3JEO0lBRUEsSUFBSXN1QixjQUFjLy9CLE9BQU8sQ0FBQ3lSLFVBQVUsQ0FBQyxHQUFHO1FBQ3RDLE9BQU9wUCxLQUFLLENBQUNvUCxLQUFLLENBQUNTLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQ3lWLElBQUl3QixXQUFXO1NBQUM7SUFDbEQsT0FBTyxJQUFJMVgsU0FBUyxzQkFBc0I7UUFDeEMsT0FBT3BQLEtBQUssQ0FBQ29QLEtBQUssQ0FBQ1MsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDeVYsSUFBSW5ELFVBQVU7U0FBQztJQUNqRDtJQUVBLGdDQUFnQztJQUNoQyxPQUFPbmlCLEtBQUssQ0FBQ29QLEtBQUssQ0FBQ1MsS0FBSyxDQUFDLElBQUksRUFBRTtRQUFDeVY7S0FBSTtBQUN0QztBQUVBOzs7Ozs7O0NBT0MsR0FDRHFZLGNBQWNybkMsU0FBUyxDQUFDd1osS0FBSyxHQUFHLFNBQVNBLE1BQU9YLFFBQVE7SUFDdEQsSUFBSUMsT0FBT0QsU0FBU2EsZUFBZTtJQUVuQyxJQUFJLENBQUMwWSxPQUFPLENBQUN0WixLQUFLLEVBQUU7UUFDbEIsTUFBTSxJQUFJelcsTUFBTTtJQUNsQjtJQUVBLE9BQU8rdkIsT0FBTyxDQUFDdFosS0FBSyxDQUFDUyxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQUNWO0tBQVM7QUFDN0M7QUFFQSxJQUFJblAsUUFBUTtJQUNWOzs7Ozs7O0dBT0MsR0FDRDg5QixTQUFTLFNBQVV4WSxHQUFHO1FBQ3BCLElBQUl5WSxVQUFVLENBQUM7UUFFZixnQkFBZ0I7UUFDaEIsSUFBSyxJQUFJOVMsT0FBTzNGLElBQUs7WUFDbkJ5WSxPQUFPLENBQUM5UyxJQUFJLEdBQUczRixHQUFHLENBQUMyRixJQUFJO1FBQ3pCO1FBRUEsaUJBQWlCO1FBQ2pCLElBQUkzRixJQUFJblcsUUFBUSxFQUFFO1lBQ2hCLElBQUlDLE9BQU9rVyxJQUFJblcsUUFBUSxDQUFDQyxJQUFJO1lBQzVCLElBQUksQ0FBQ3BQLEtBQUssQ0FBQ29QLEtBQUssRUFBRTtnQkFDaEIsTUFBTSxJQUFJelcsTUFBTSwyQkFBMkIyc0IsSUFBSWxXLElBQUk7WUFDckQ7WUFDQTJ1QixRQUFRNXVCLFFBQVEsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ3FXLElBQUluVyxRQUFRO1FBQzNDO1FBRUEsT0FBTztRQUNQLElBQUltVyxJQUFJMFksSUFBSSxFQUFFO1lBQ1pELFFBQVFDLElBQUksR0FBR2grQixNQUFNZytCLElBQUksQ0FBQ251QixLQUFLLENBQUMsSUFBSSxFQUFFO2dCQUFDeVYsSUFBSTBZLElBQUk7YUFBQztRQUNsRDtRQUVBLE9BQU9EO0lBQ1Q7SUFFQTs7Ozs7OztHQU9DLEdBQ0RFLG1CQUFtQixTQUFVM1ksR0FBRztRQUM5QixJQUFJMVUsU0FBUyxJQUFJO1FBRWpCLElBQUlzdEIsb0JBQW9CLENBQUM7UUFFekIsSUFBSTVZLElBQUk2WSxRQUFRLEVBQUU7WUFDaEJELGtCQUFrQkMsUUFBUSxHQUFHLEVBQUU7WUFFL0IsSUFBSyxJQUFJemdDLElBQUksR0FBR0EsSUFBSTRuQixJQUFJNlksUUFBUSxDQUFDcG5DLE1BQU0sRUFBRSxFQUFFMkcsRUFBRztnQkFDNUN3Z0Msa0JBQWtCQyxRQUFRLENBQUNwdEIsSUFBSSxDQUFDSCxPQUFPM0IsSUFBSSxDQUFDcVcsSUFBSTZZLFFBQVEsQ0FBQ3pnQyxFQUFFO1lBQzdEO1FBQ0Y7UUFFQSxJQUFJNG5CLElBQUkwWSxJQUFJLEVBQUU7WUFDWkUsa0JBQWtCRixJQUFJLEdBQUcsSUFBSSxDQUFDaCtCLEtBQUssQ0FBQ2crQixJQUFJLENBQUNudUIsS0FBSyxDQUFDLElBQUksRUFBRTtnQkFBQ3lWLElBQUkwWSxJQUFJO2FBQUM7UUFDakU7UUFFQSxPQUFPRTtJQUNUO0lBRUE7Ozs7Ozs7R0FPQyxHQUNEcFgsYUFBYSxTQUFValcsS0FBSztRQUMxQixJQUFJaVcsY0FBYyxFQUFFO1FBQ3BCLElBQUssSUFBSXBwQixJQUFJLEdBQUdBLElBQUltVCxNQUFNOVosTUFBTSxFQUFFLEVBQUUyRyxFQUFHO1lBQ3JDLElBQUkwZ0MsTUFBTXZ0QixLQUFLLENBQUNuVCxFQUFFO1lBQ2xCb3BCLFlBQVkvVixJQUFJLENBQUMsSUFBSS9XLFdBQVdva0MsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7UUFDaEQ7UUFDQSxPQUFPdFg7SUFDVDtJQUVBOzs7Ozs7O0dBT0MsR0FDRGtYLE1BQU0sU0FBVW50QixLQUFLO1FBQ25CLE9BQU8sSUFBSSxDQUFDOUIsZUFBZSxDQUFDMkQsZ0JBQWdCLENBQUM7WUFDM0MsSUFBSTFZLFdBQVc2VyxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtZQUNqQyxJQUFJN1csV0FBVzZXLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1lBQ2pDLElBQUk3VyxXQUFXNlcsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUU7WUFDakMsSUFBSTdXLFdBQVc2VyxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtZQUNqQyxJQUFJN1csV0FBVzZXLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1NBQ2xDO0lBQ0g7SUFFQTs7Ozs7OztHQU9DLEdBQ0Rpa0IsT0FBTyxTQUFVamtCLEtBQUs7UUFDcEIsSUFBSVIsYUFBYSxJQUFJclcsV0FBVzZXLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1FBQ2xELE9BQU8sSUFBSSxDQUFDOUIsZUFBZSxDQUFDaUQsV0FBVyxDQUFDM0I7SUFDMUM7SUFFQTs7Ozs7OztHQU9DLEdBQ0RtbUIsWUFBWSxTQUFVM2xCLEtBQUs7UUFDekIsSUFBSUQsU0FBUyxJQUFJO1FBRWpCLElBQUkwQixTQUFTLEVBQUU7UUFDZixJQUFLLElBQUk1VSxJQUFJLEdBQUdBLElBQUltVCxNQUFNOVosTUFBTSxFQUFFLEVBQUUyRyxFQUFHO1lBQ3JDNFUsT0FBT3ZCLElBQUksQ0FBQy9RLE1BQU04MEIsS0FBSyxDQUFDamxCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ0MsS0FBSyxDQUFDblQsRUFBRTthQUFDO1FBQ2xEO1FBQ0EsT0FBTyxJQUFJLENBQUNxUixlQUFlLENBQUNzRCxnQkFBZ0IsQ0FBQ0M7SUFDL0M7SUFFQTs7Ozs7OztHQU9DLEdBQ0RtZSxZQUFZLFNBQVU1ZixLQUFLO1FBQ3pCLElBQUlpVyxjQUFjOW1CLE1BQU04bUIsV0FBVyxDQUFDalgsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDZ0I7U0FBTTtRQUN2RCxPQUFPLElBQUksQ0FBQzlCLGVBQWUsQ0FBQzBELGdCQUFnQixDQUFDcVU7SUFDL0M7SUFFQTs7Ozs7OztHQU9DLEdBQ0R1SSxpQkFBaUIsU0FBVXhlLEtBQUs7UUFDOUIsSUFBSUQsU0FBUyxJQUFJO1FBRWpCLElBQUkrZSxjQUFjLEVBQUU7UUFDcEIsSUFBSyxJQUFJanlCLElBQUksR0FBR0EsSUFBSW1ULE1BQU05WixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDckNpeUIsWUFBWTVlLElBQUksQ0FBQy9RLE1BQU15d0IsVUFBVSxDQUFDNWdCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ0MsS0FBSyxDQUFDblQsRUFBRTthQUFDO1FBQzVEO1FBQ0EsT0FBTyxJQUFJLENBQUNxUixlQUFlLENBQUM0RCxxQkFBcUIsQ0FBQ2dkO0lBQ3BEO0lBRUE7Ozs7Ozs7R0FPQyxHQUNEcUYsU0FBUyxTQUFVbmtCLEtBQUs7UUFDdEIsSUFBSUQsU0FBUyxJQUFJO1FBRWpCLElBQUlxa0IsbUJBQW1CajFCLE1BQU04bUIsV0FBVyxDQUFDalgsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDZ0IsS0FBSyxDQUFDLEVBQUU7U0FBQztRQUMvRCxJQUFJcUMsUUFBUSxJQUFJLENBQUNuRSxlQUFlLENBQUMyRCxnQkFBZ0IsQ0FBQ3VpQjtRQUNsRCxJQUFJOWhCLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSXpWLElBQUksR0FBR0EsSUFBSW1ULE1BQU05WixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDckMsSUFBSXc2QixPQUFPcm5CLEtBQUssQ0FBQ25ULEVBQUU7WUFDbkIsSUFBSW9wQixjQUFjOW1CLE1BQU04bUIsV0FBVyxDQUFDalgsS0FBSyxDQUFDZSxRQUFRO2dCQUFDc25CO2FBQUs7WUFDeEQsSUFBSW1HLGFBQWF6dEIsT0FBTzdCLGVBQWUsQ0FBQzJELGdCQUFnQixDQUFDb1U7WUFDekQzVCxNQUFNcEMsSUFBSSxDQUFDc3RCO1FBQ2I7UUFDQSxPQUFPLElBQUksQ0FBQ3R2QixlQUFlLENBQUNnRSxhQUFhLENBQUNHLE9BQU9DO0lBQ25EO0lBRUE7Ozs7Ozs7R0FPQyxHQUNENGpCLGNBQWMsU0FBVWxtQixLQUFLO1FBQzNCLElBQUlELFNBQVMsSUFBSTtRQUVqQixJQUFJeUMsV0FBVyxFQUFFO1FBQ2pCLElBQUssSUFBSTNWLElBQUksR0FBR0EsSUFBSW1ULE1BQU05WixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDckMsSUFBSThULFVBQVVYLEtBQUssQ0FBQ25ULEVBQUU7WUFDdEIyVixTQUFTdEMsSUFBSSxDQUFDL1EsTUFBTWcxQixPQUFPLENBQUNubEIsS0FBSyxDQUFDZSxRQUFRO2dCQUFDWTthQUFRO1FBQ3JEO1FBQ0EsT0FBTyxJQUFJLENBQUN6QyxlQUFlLENBQUNxRSxrQkFBa0IsQ0FBQ0M7SUFDakQ7SUFFQTs7Ozs7OztHQU9DLEdBQ0R5YSxvQkFBb0IsU0FBVWpkLEtBQUs7UUFDakMsSUFBSUQsU0FBUyxJQUFJO1FBRWpCLElBQUl1UixhQUFhLEVBQUU7UUFDbkIsSUFBSyxJQUFJemtCLElBQUksR0FBR0EsSUFBSW1ULE1BQU05WixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDckMsSUFBSXlSLFdBQVcwQixLQUFLLENBQUNuVCxFQUFFO1lBQ3ZCeWtCLFdBQVdwUixJQUFJLENBQUNILE9BQU8zQixJQUFJLENBQUNFO1FBQzlCO1FBQ0EsT0FBTyxJQUFJLENBQUNKLGVBQWUsQ0FBQ3dFLHdCQUF3QixDQUFDNE87SUFDdkQ7QUFDRjtBQUVBLElBQUl1RyxVQUFVO0lBQ1o7Ozs7Ozs7R0FPQyxHQUNEclksWUFBWSxTQUFVQSxVQUFVO1FBQzlCLE9BQU87WUFBQ0EsV0FBV3JZLENBQUM7WUFBRXFZLFdBQVdwVyxDQUFDO1NBQUM7SUFDckM7SUFFQTs7Ozs7OztHQU9DLEdBQ0Q2NkIsT0FBTyxTQUFVdmtCLEtBQUs7UUFDcEIsSUFBSU0sUUFBUTZYLFFBQVFyWSxVQUFVLENBQUNSLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFBQ1UsTUFBTXJHLGFBQWE7U0FBRztRQUNsRSxPQUFPO1lBQ0xrRixNQUFNO1lBQ04wWCxhQUFhalc7UUFDZjtJQUNGO0lBRUE7Ozs7Ozs7R0FPQyxHQUNEMmxCLFlBQVksU0FBVTlsQixVQUFVO1FBQzlCLElBQUlFLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluVCxJQUFJLEdBQUdBLElBQUlnVCxXQUFXSSxXQUFXLENBQUMvWixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDdEQsSUFBSTZTLFFBQVFHLFdBQVdJLFdBQVcsQ0FBQ3BULEVBQUU7WUFDckMsSUFBSTRnQyxVQUFVNVYsUUFBUW9NLEtBQUssQ0FBQ2psQixLQUFLLENBQUNlLFFBQVE7Z0JBQUNMO2FBQU07WUFDakRNLE1BQU1FLElBQUksQ0FBQ3V0QixRQUFReFgsV0FBVztRQUNoQztRQUNBLE9BQU87WUFDTDFYLE1BQU07WUFDTjBYLGFBQWFqVztRQUNmO0lBQ0Y7SUFFQTs7Ozs7OztHQU9DLEdBQ0Q0ZixZQUFZLFNBQVV4ZixVQUFVO1FBQzlCLElBQUlMLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFJaVcsY0FBYzdWLFdBQVcrYyxjQUFjO1FBQzNDLElBQUssSUFBSXR3QixJQUFJLEdBQUdBLElBQUlvcEIsWUFBWS92QixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDM0MsSUFBSTJTLGFBQWF5VyxXQUFXLENBQUNwcEIsRUFBRTtZQUMvQm1ULE1BQU1FLElBQUksQ0FBQzJYLFFBQVFyWSxVQUFVLENBQUNSLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ1A7YUFBVztRQUMxRDtRQUNBLE9BQU87WUFDTGpCLE1BQU07WUFDTjBYLGFBQWFqVztRQUNmO0lBQ0Y7SUFFQTs7Ozs7OztHQU9DLEdBQ0R3ZSxpQkFBaUIsU0FBVS9kLGVBQWU7UUFDeEMsSUFBSVYsU0FBUyxJQUFJO1FBRWpCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSW5ULElBQUksR0FBR0EsSUFBSTRULGdCQUFnQlIsV0FBVyxDQUFDL1osTUFBTSxFQUFFLEVBQUUyRyxFQUFHO1lBQzNELElBQUl1VCxhQUFhSyxnQkFBZ0JSLFdBQVcsQ0FBQ3BULEVBQUU7WUFDL0MsSUFBSTRnQyxVQUFVNVYsUUFBUStILFVBQVUsQ0FBQzVnQixLQUFLLENBQUNlLFFBQVE7Z0JBQUNLO2FBQVc7WUFDM0RKLE1BQU1FLElBQUksQ0FBQ3V0QixRQUFReFgsV0FBVztRQUNoQztRQUNBLE9BQU87WUFDTDFYLE1BQU07WUFDTjBYLGFBQWFqVztRQUNmO0lBQ0Y7SUFFQTs7Ozs7OztHQU9DLEdBQ0Rta0IsU0FBUyxTQUFVeGpCLE9BQU87UUFDeEIsSUFBSVosU0FBUyxJQUFJO1FBRWpCLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUkwdEIsZUFBZTdWLFFBQVErSCxVQUFVLENBQUM1Z0IsS0FBSyxDQUFDLElBQUksRUFBRTtZQUFDMkIsUUFBUUUsTUFBTTtTQUFDO1FBQ2xFYixNQUFNRSxJQUFJLENBQUN3dEIsYUFBYXpYLFdBQVc7UUFDbkMsSUFBSyxJQUFJcHBCLElBQUksR0FBR0EsSUFBSThULFFBQVFHLE1BQU0sQ0FBQzVhLE1BQU0sRUFBRSxFQUFFMkcsRUFBRztZQUM5QyxJQUFJdzZCLE9BQU8xbUIsUUFBUUcsTUFBTSxDQUFDalUsRUFBRTtZQUM1QixJQUFJOGdDLGNBQWM5VixRQUFRK0gsVUFBVSxDQUFDNWdCLEtBQUssQ0FBQ2UsUUFBUTtnQkFBQ3NuQjthQUFLO1lBQ3pEcm5CLE1BQU1FLElBQUksQ0FBQ3l0QixZQUFZMVgsV0FBVztRQUNwQztRQUNBLE9BQU87WUFDTDFYLE1BQU07WUFDTjBYLGFBQWFqVztRQUNmO0lBQ0Y7SUFFQTs7Ozs7OztHQU9DLEdBQ0RrbUIsY0FBYyxTQUFVbmxCLFlBQVk7UUFDbEMsSUFBSWhCLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluVCxJQUFJLEdBQUdBLElBQUlrVSxhQUFhZCxXQUFXLENBQUMvWixNQUFNLEVBQUUsRUFBRTJHLEVBQUc7WUFDeEQsSUFBSThULFVBQVVJLGFBQWFkLFdBQVcsQ0FBQ3BULEVBQUU7WUFDekMsSUFBSTRnQyxVQUFVNVYsUUFBUXNNLE9BQU8sQ0FBQ25sQixLQUFLLENBQUNlLFFBQVE7Z0JBQUNZO2FBQVE7WUFDckRYLE1BQU1FLElBQUksQ0FBQ3V0QixRQUFReFgsV0FBVztRQUNoQztRQUNBLE9BQU87WUFDTDFYLE1BQU07WUFDTjBYLGFBQWFqVztRQUNmO0lBQ0Y7SUFFQTs7Ozs7OztHQU9DLEdBQ0RpZCxvQkFBb0IsU0FBVS9iLFVBQVU7UUFDdEMsSUFBSW5CLFNBQVMsSUFBSTtRQUVqQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluVCxJQUFJLEdBQUdBLElBQUlxVSxXQUFXakIsV0FBVyxDQUFDL1osTUFBTSxFQUFFLEVBQUUyRyxFQUFHO1lBQ3RELElBQUl5UixXQUFXNEMsV0FBV2pCLFdBQVcsQ0FBQ3BULEVBQUU7WUFDeEMsSUFBSTBSLE9BQU9ELFNBQVNhLGVBQWU7WUFDbkNhLE1BQU1FLElBQUksQ0FBQzJYLE9BQU8sQ0FBQ3RaLEtBQUssQ0FBQ1MsS0FBSyxDQUFDZSxRQUFRO2dCQUFDekI7YUFBUztRQUNuRDtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNOK1MsWUFBWXRSO1FBQ2Q7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUNELElBQUk0dEIsZ0JBQWdCLFNBQVNBLGNBQWUxdkIsZUFBZTtJQUN6RCxJQUFJLENBQUNBLGVBQWUsR0FBR0EsbUJBQW1CLElBQUlDO0lBQzlDLElBQUksQ0FBQzBILGNBQWMsR0FBRyxJQUFJLENBQUMzSCxlQUFlLENBQUNzUyxpQkFBaUI7SUFDNUQsSUFBSSxDQUFDM04sTUFBTSxHQUFHLElBQUlpcUIsY0FBYyxJQUFJLENBQUM1dUIsZUFBZTtBQUN0RDtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QwdkIsY0FBY25vQyxTQUFTLENBQUMyWSxJQUFJLEdBQUcsU0FBU0EsS0FBTXF2QixPQUFPO0lBQ25ELElBQUludkIsV0FBVyxJQUFJLENBQUN1RSxNQUFNLENBQUN6RSxJQUFJLENBQUNxdkI7SUFFaEMsSUFBSSxJQUFJLENBQUM1bkIsY0FBYyxDQUFDK2pCLE9BQU8sT0FBT2pCLGVBQWVNLEtBQUssRUFBRTtRQUMxRCxJQUFJLENBQUM0RSxlQUFlLENBQUN2dkI7SUFDdkI7SUFFQSxPQUFPQTtBQUNUO0FBRUEsdUJBQXVCO0FBQ3ZCc3ZCLGNBQWNub0MsU0FBUyxDQUFDb29DLGVBQWUsR0FBRyxTQUFTQSxnQkFBaUJ2dkIsUUFBUTtJQUN4RSxJQUFJeUIsU0FBUyxJQUFJO0lBRW5CLElBQUlsVCxHQUFHOEo7SUFFUCxJQUFJMkgsU0FBU2tCLFVBQVUsRUFBRTtRQUN2QixJQUFJLENBQUNxRyxjQUFjLENBQUMrQixXQUFXLENBQUN0SixTQUFTa0IsVUFBVTtJQUNyRCxPQUFPLElBQUlsQixTQUFTbUQsTUFBTSxFQUFFO1FBQzFCLElBQUs1VSxJQUFJLEdBQUc4SixNQUFNMkgsU0FBU21ELE1BQU0sQ0FBQ3ZiLE1BQU0sRUFBRTJHLElBQUk4SixLQUFLOUosSUFBSztZQUN0RGtULE9BQU84RixjQUFjLENBQUMrQixXQUFXLENBQUN0SixTQUFTbUQsTUFBTSxDQUFDNVUsRUFBRTtRQUN0RDtJQUNGLE9BQU8sSUFBSXlSLFNBQVNnVCxVQUFVLEVBQUU7UUFDOUIsSUFBS3prQixJQUFJLEdBQUc4SixNQUFNMkgsU0FBU2dULFVBQVUsQ0FBQ3ByQixNQUFNLEVBQUUyRyxJQUFJOEosS0FBSzlKLElBQUs7WUFDMURrVCxPQUFPOHRCLGVBQWUsQ0FBQ3Z2QixTQUFTZ1QsVUFBVSxDQUFDemtCLEVBQUU7UUFDL0M7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUNELElBQUlpaEMsZ0JBQWdCLFNBQVNBO0lBQzNCLElBQUksQ0FBQ2pyQixNQUFNLEdBQUcsSUFBSWlxQixjQUFjLElBQUksQ0FBQzV1QixlQUFlO0FBQ3REO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNENHZCLGNBQWNyb0MsU0FBUyxDQUFDd1osS0FBSyxHQUFHLFNBQVNBLE1BQU9YLFFBQVE7SUFDdEQsT0FBTyxJQUFJLENBQUN1RSxNQUFNLENBQUM1RCxLQUFLLENBQUNYO0FBQzNCO0FBRUEsMkJBQTJCLEdBRTNCLEtBQUs7QUFFTCxJQUFJeXZCLFdBQVcsU0FBU0EsWUFBYTtBQUVyQyxJQUFJQyxxQkFBcUI7SUFBRUMsSUFBSTtRQUFFcm9DLGNBQWM7SUFBSztJQUFFOGxCLE1BQU07UUFBRTlsQixjQUFjO0lBQUs7SUFBRTRsQixPQUFPO1FBQUU1bEIsY0FBYztJQUFLO0FBQUU7QUFFakhtb0MsU0FBU3RvQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDeEMsT0FBTyxFQUFFO0FBQ1g7QUFDQXltQyxTQUFTdG9DLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPd21DO0FBQ1Q7QUFDQUEsU0FBU0csUUFBUSxHQUFHLFNBQVNBLFNBQVVDLFFBQVE7SUFDN0MsSUFBSUEsYUFBYUosU0FBU3JpQixJQUFJLEVBQUU7UUFBRSxPQUFPcWlCLFNBQVN2aUIsS0FBSztJQUFDO0lBQ3hELElBQUkyaUIsYUFBYUosU0FBU3ZpQixLQUFLLEVBQUU7UUFBRSxPQUFPdWlCLFNBQVNyaUIsSUFBSTtJQUFDO0lBQ3hELE9BQU95aUI7QUFDVDtBQUNBSCxtQkFBbUJDLEVBQUUsQ0FBQ3BsQyxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDbkRtbEMsbUJBQW1CdGlCLElBQUksQ0FBQzdpQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDckRtbEMsbUJBQW1CeGlCLEtBQUssQ0FBQzNpQixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFFdERuRCxPQUFPb0QsZ0JBQWdCLENBQUVpbEMsVUFBVUM7QUFFbkM7Ozs7O0NBS0MsR0FDRCxTQUFTSSxvQkFBcUJybUMsT0FBTztJQUNuQyxJQUFJLENBQUNBLE9BQU8sR0FBR0EsV0FBVztBQUM1QjtBQUNBcW1DLG9CQUFvQjNvQyxTQUFTLEdBQUcsSUFBSXFDO0FBRXBDOztDQUVDLEdBQ0RzbUMsb0JBQW9CM29DLFNBQVMsQ0FBQ3dDLElBQUksR0FBRztBQUVyQzs7Ozs7O0NBTUMsR0FDRCxTQUFTb21DO0lBQ1A7OztHQUdDLEdBQ0QsSUFBSSxDQUFDbGIsTUFBTSxHQUFHLEVBQUU7QUFDbEI7QUFDQWtiLE1BQU01b0MsU0FBUyxHQUFHLElBQUlvdEI7QUFFdEI7O0NBRUMsR0FDRHdiLE1BQU01b0MsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVVwRCxDQUFDO0lBQy9CLElBQUksQ0FBQzZrQixNQUFNLENBQUNqVCxJQUFJLENBQUM1UjtJQUNqQixPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNEKy9CLE1BQU01b0MsU0FBUyxDQUFDb0QsR0FBRyxHQUFHLFNBQVVpRixLQUFLO0lBQ25DLElBQUlBLFFBQVEsS0FBS0EsU0FBUyxJQUFJLENBQUNzTCxJQUFJLElBQUk7UUFDckMsTUFBTSxJQUFJdFI7SUFDWjtJQUVBLE9BQU8sSUFBSSxDQUFDcXJCLE1BQU0sQ0FBQ3JsQixNQUFNO0FBQzNCO0FBRUE7Ozs7Q0FJQyxHQUNEdWdDLE1BQU01b0MsU0FBUyxDQUFDeWEsSUFBSSxHQUFHLFNBQVU1UixDQUFDO0lBQ2hDLElBQUksQ0FBQzZrQixNQUFNLENBQUNqVCxJQUFJLENBQUM1UjtJQUNqQixPQUFPQTtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNEKy9CLE1BQU01b0MsU0FBUyxDQUFDNm9DLEdBQUcsR0FBRyxTQUFVaGdDLENBQUM7SUFDL0IsSUFBSSxJQUFJLENBQUM2a0IsTUFBTSxDQUFDanRCLE1BQU0sS0FBSyxHQUFHO1FBQzVCLE1BQU0sSUFBSWtvQztJQUNaO0lBRUEsT0FBTyxJQUFJLENBQUNqYixNQUFNLENBQUNtYixHQUFHO0FBQ3hCO0FBRUE7Ozs7Q0FJQyxHQUNERCxNQUFNNW9DLFNBQVMsQ0FBQzhvQyxJQUFJLEdBQUc7SUFDckIsSUFBSSxJQUFJLENBQUNwYixNQUFNLENBQUNqdEIsTUFBTSxLQUFLLEdBQUc7UUFDNUIsTUFBTSxJQUFJa29DO0lBQ1o7SUFFQSxPQUFPLElBQUksQ0FBQ2piLE1BQU0sQ0FBQyxJQUFJLENBQUNBLE1BQU0sQ0FBQ2p0QixNQUFNLEdBQUcsRUFBRTtBQUM1QztBQUVBOzs7O0NBSUMsR0FDRG1vQyxNQUFNNW9DLFNBQVMsQ0FBQytvQyxLQUFLLEdBQUc7SUFDdEIsSUFBSSxJQUFJLENBQUNyYixNQUFNLENBQUNqdEIsTUFBTSxLQUFLLEdBQUc7UUFDNUIsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVBOztDQUVDLEdBQ0Rtb0MsTUFBTTVvQyxTQUFTLENBQUM4WixPQUFPLEdBQUc7SUFDeEIsT0FBTyxJQUFJLENBQUNpdkIsS0FBSztBQUNuQjtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDREgsTUFBTTVvQyxTQUFTLENBQUNtWixNQUFNLEdBQUcsU0FBVXJVLENBQUM7SUFDbEMsT0FBTyxJQUFJLENBQUM0b0IsTUFBTSxDQUFDcm1CLE9BQU8sQ0FBQ3ZDO0FBQzdCO0FBRUE7OztDQUdDLEdBQ0Q4akMsTUFBTTVvQyxTQUFTLENBQUMyVCxJQUFJLEdBQUc7SUFDckIsT0FBTyxJQUFJLENBQUMrWixNQUFNLENBQUNqdEIsTUFBTTtBQUMzQjtBQUVBOztDQUVDLEdBQ0Rtb0MsTUFBTTVvQyxTQUFTLENBQUNndEIsT0FBTyxHQUFHO0lBQ3hCLElBQUkxUyxTQUFTLElBQUk7SUFFakIsSUFBSUMsUUFBUSxFQUFFO0lBRWQsSUFBSyxJQUFJblQsSUFBSSxHQUFHOEosTUFBTSxJQUFJLENBQUN3YyxNQUFNLENBQUNqdEIsTUFBTSxFQUFFMkcsSUFBSThKLEtBQUs5SixJQUFLO1FBQ3REbVQsTUFBTUUsSUFBSSxDQUFDSCxPQUFPb1QsTUFBTSxDQUFDdG1CLEVBQUU7SUFDN0I7SUFFQSxPQUFPbVQ7QUFDVDtBQUVBLElBQUl5dUIsc0JBQXNCLFNBQVNBO0lBQ2pDLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUM7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7SUFDZCxJQUFJLENBQUNDLFdBQVcsR0FBRztBQUNyQjtBQUNBSixvQkFBb0JocEMsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBO0lBQ3JELE9BQU8sSUFBSSxDQUFDczFCLFNBQVM7QUFDdkI7QUFDQUYsb0JBQW9CaHBDLFNBQVMsQ0FBQ3FwQyxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JDLEVBQUUsRUFBRWpoQyxLQUFLO0lBQ25GLElBQUlraEMsT0FBTyxJQUFJLENBQUNDLHlCQUF5QixDQUFDRixJQUFJamhDO0lBQzlDLElBQUlraEMsT0FBTyxHQUFHO1FBQUVBLE9BQU8sSUFBSSxDQUFDQyx5QkFBeUIsQ0FBQ0YsSUFBSWpoQyxRQUFRO0lBQUk7SUFDdEUsSUFBSWtoQyxPQUFPLEdBQUc7UUFDWixJQUFJLENBQUNMLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNPLDJCQUEyQixDQUFDSDtJQUNuQztJQUNBLE9BQU9DO0FBQ1Q7QUFDQVAsb0JBQW9CaHBDLFNBQVMsQ0FBQzBwQyx5QkFBeUIsR0FBRyxTQUFTQTtJQUNqRSxJQUFJemlCLE1BQU0sSUFBSSxDQUFDa2lCLE1BQU0sQ0FBQ1EsT0FBTyxHQUFHalMsY0FBYztJQUM5Q2hhLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUNxckIsU0FBUyxHQUFHLEtBQUssSUFBSSxDQUFDQSxTQUFTLEdBQUdoaUIsSUFBSXhtQixNQUFNLEVBQUU7SUFDakUsSUFBSW1wQyxRQUFRM2lCLEdBQUcsQ0FBQyxJQUFJLENBQUNnaUIsU0FBUyxHQUFHLEVBQUU7SUFDbkMsSUFBSVksUUFBUTVpQixHQUFHLENBQUMsSUFBSSxDQUFDZ2lCLFNBQVMsR0FBRyxFQUFFO0lBQ25DLElBQUlhLGNBQWN0b0IsYUFBYW9HLGtCQUFrQixDQUFDLElBQUksQ0FBQ3NoQixTQUFTLEVBQUVXLE9BQU9EO0lBQ3pFLElBQUlHLFVBQVU7SUFDZCxJQUFJSCxNQUFNam1DLENBQUMsR0FBRyxJQUFJLENBQUN1bEMsU0FBUyxDQUFDdmxDLENBQUMsSUFBSWttQyxNQUFNbG1DLENBQUMsR0FBRyxJQUFJLENBQUN1bEMsU0FBUyxDQUFDdmxDLENBQUMsSUFBSW1tQyxnQkFBZ0J0b0IsYUFBYXdFLGdCQUFnQixFQUFFO1FBQzdHK2pCLFVBQVU7SUFDWixPQUFPLElBQUlILE1BQU1qbUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3VsQyxTQUFTLENBQUN2bEMsQ0FBQyxJQUFJa21DLE1BQU1sbUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3VsQyxTQUFTLENBQUN2bEMsQ0FBQyxJQUFJbW1DLGdCQUFnQnRvQixhQUFhc0UsU0FBUyxFQUFFO1FBQzdHaWtCLFVBQVU7SUFDWjtJQUNBLElBQUlBLFNBQVM7UUFDWCxJQUFJLENBQUNkLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsR0FBRztJQUNwQztBQUNGO0FBQ0FELG9CQUFvQmhwQyxTQUFTLENBQUN3cEMseUJBQXlCLEdBQUcsU0FBU0EsMEJBQTJCRixFQUFFLEVBQUVsaUMsQ0FBQztJQUNqRyxJQUFJeUIsSUFBSXlnQyxHQUFHSyxPQUFPO0lBQ2xCLElBQUkzZCxRQUFRbmpCLEVBQUU2dUIsY0FBYztJQUM1QixJQUFJdHdCLElBQUksS0FBS0EsSUFBSSxLQUFLNGtCLE1BQU12ckIsTUFBTSxFQUFFO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDaEQsSUFBSXVyQixLQUFLLENBQUM1a0IsRUFBRSxDQUFDekQsQ0FBQyxLQUFLcW9CLEtBQUssQ0FBQzVrQixJQUFJLEVBQUUsQ0FBQ3pELENBQUMsRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQy9DLElBQUlnNUIsTUFBTTJMLFNBQVNyaUIsSUFBSTtJQUN2QixJQUFJK0YsS0FBSyxDQUFDNWtCLEVBQUUsQ0FBQ3pELENBQUMsR0FBR3FvQixLQUFLLENBQUM1a0IsSUFBSSxFQUFFLENBQUN6RCxDQUFDLEVBQUU7UUFBRWc1QixNQUFNMkwsU0FBU3ZpQixLQUFLO0lBQUU7SUFDekQsT0FBTzRXO0FBQ1Q7QUFDQXFNLG9CQUFvQmhwQyxTQUFTLENBQUMycEMsT0FBTyxHQUFHLFNBQVNBO0lBQy9DLE9BQU8sSUFBSSxDQUFDUCxXQUFXO0FBQ3pCO0FBQ0FKLG9CQUFvQmhwQyxTQUFTLENBQUN5cEMsMkJBQTJCLEdBQUcsU0FBU0EsNEJBQTZCSCxFQUFFO0lBQ2hHLElBQUlodkIsU0FBUyxJQUFJO0lBRW5CLElBQUkwUixRQUFRc2QsR0FBR0ssT0FBTyxHQUFHalMsY0FBYztJQUN2QyxJQUFLLElBQUl0d0IsSUFBSSxHQUFHQSxJQUFJNGtCLE1BQU12ckIsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1FBQ3pDLElBQUlrVCxPQUFPNHVCLFNBQVMsS0FBSyxRQUFRbGQsS0FBSyxDQUFDNWtCLEVBQUUsQ0FBQzFGLENBQUMsR0FBRzRZLE9BQU80dUIsU0FBUyxDQUFDeG5DLENBQUMsRUFBRTtZQUNoRTRZLE9BQU82dUIsTUFBTSxHQUFHRztZQUNoQmh2QixPQUFPMnVCLFNBQVMsR0FBRzdoQztZQUNuQmtULE9BQU80dUIsU0FBUyxHQUFHbGQsS0FBSyxDQUFDNWtCLEVBQUU7UUFDN0I7SUFDRjtBQUNGO0FBQ0E0aEMsb0JBQW9CaHBDLFNBQVMsQ0FBQ2dxQyx1QkFBdUIsR0FBRyxTQUFTQTtJQUMvRCxJQUFJQyxPQUFPLElBQUksQ0FBQ2QsTUFBTSxDQUFDZSxPQUFPO0lBQzlCLElBQUlDLE9BQU9GLEtBQUtHLFFBQVE7SUFDeEIsSUFBSSxDQUFDakIsTUFBTSxHQUFHZ0IsS0FBS0UsZ0JBQWdCO0lBQ25DLElBQUksQ0FBQyxJQUFJLENBQUNsQixNQUFNLENBQUNtQixTQUFTLElBQUk7UUFDNUIsSUFBSSxDQUFDbkIsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDb0IsTUFBTTtRQUNoQyxJQUFJLENBQUN0QixTQUFTLEdBQUcsSUFBSSxDQUFDRSxNQUFNLENBQUNRLE9BQU8sR0FBR2pTLGNBQWMsR0FBR2ozQixNQUFNLEdBQUc7SUFDbkU7QUFDRjtBQUNBdW9DLG9CQUFvQmhwQyxTQUFTLENBQUN3cUMsUUFBUSxHQUFHLFNBQVNBLFNBQVVDLFdBQVc7SUFDbkUsSUFBSW53QixTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSXFqQyxZQUFZcGYsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQ2pELElBQUkrZCxLQUFLbGlDLEVBQUVzZ0IsSUFBSTtRQUNmLElBQUksQ0FBQzRoQixHQUFHZ0IsU0FBUyxJQUFJO1lBQUU7UUFBUztRQUNoQ2h3QixPQUFPbXZCLDJCQUEyQixDQUFDSDtJQUNyQztJQUNBNXJCLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUNxckIsU0FBUyxLQUFLLEtBQUssSUFBSSxDQUFDQyxTQUFTLENBQUN2a0MsTUFBTSxDQUFDLElBQUksQ0FBQ3drQyxNQUFNLENBQUN2MUIsYUFBYSxLQUFLO0lBQzFGLElBQUksSUFBSSxDQUFDcTFCLFNBQVMsS0FBSyxHQUFHO1FBQ3hCLElBQUksQ0FBQ2UsdUJBQXVCO0lBQzlCLE9BQU87UUFDTCxJQUFJLENBQUNOLHlCQUF5QjtJQUNoQztJQUNBLElBQUksQ0FBQ04sV0FBVyxHQUFHLElBQUksQ0FBQ0QsTUFBTTtJQUM5QixJQUFJdUIsZ0JBQWdCLElBQUksQ0FBQ3JCLGdCQUFnQixDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFLElBQUksQ0FBQ0YsU0FBUztJQUNyRSxJQUFJeUIsa0JBQWtCcEMsU0FBU3JpQixJQUFJLEVBQUU7UUFDbkMsSUFBSSxDQUFDbWpCLFdBQVcsR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQ29CLE1BQU07SUFDdkM7QUFDRjtBQUNBdkIsb0JBQW9CaHBDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNuRCxPQUFPLEVBQUU7QUFDWDtBQUNBbW5DLG9CQUFvQmhwQyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDaEQsT0FBT2tuQztBQUNUO0FBRUEsSUFBSTJCLG9CQUFxQixTQUFVbHRCLG1CQUFtQjtJQUNwRCxTQUFTa3RCLGtCQUFtQkMsR0FBRyxFQUFFL3BCLEVBQUU7UUFDakNwRCxvQkFBb0JsYixJQUFJLENBQUMsSUFBSSxFQUFFb29DLGtCQUFrQkUsWUFBWSxDQUFDRCxLQUFLL3BCO1FBQ25FLElBQUksQ0FBQ0EsRUFBRSxHQUFHQSxLQUFLLElBQUluZCxXQUFXbWQsTUFBTTtRQUNwQyxJQUFJLENBQUNyZSxJQUFJLEdBQUc7SUFDZDtJQUVBLElBQUtpYixxQkFBc0JrdEIsa0JBQWtCam9DLFNBQVMsR0FBRythO0lBQ3pEa3RCLGtCQUFrQjNxQyxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUU4YSx1QkFBdUJBLG9CQUFvQnpkLFNBQVM7SUFDakcycUMsa0JBQWtCM3FDLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRytuQztJQUMxQ0Esa0JBQWtCM3FDLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQTtRQUNuRCxPQUFPLElBQUksQ0FBQ2lOLEVBQUU7SUFDaEI7SUFDQThwQixrQkFBa0IzcUMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ2pELE9BQU8sRUFBRTtJQUNYO0lBQ0E4b0Msa0JBQWtCM3FDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUM5QyxPQUFPNm9DO0lBQ1Q7SUFDQUEsa0JBQWtCRSxZQUFZLEdBQUcsU0FBU0EsYUFBY0QsR0FBRyxFQUFFL3BCLEVBQUU7UUFDN0QsSUFBSSxDQUFDQSxJQUFJO1lBQUUsT0FBTytwQixNQUFNLFFBQVEvcEIsS0FBSztRQUFLO1FBQzFDLE9BQU8rcEI7SUFDVDtJQUVBLE9BQU9EO0FBQ1QsRUFBRXB0QjtBQUVGLElBQUl1dEIsYUFBYSxTQUFTQTtJQUN4QixJQUFJLENBQUNwZCxNQUFNLEdBQUcsRUFBRTtBQUNsQjtBQUNBb2QsV0FBVzlxQyxTQUFTLENBQUMrcUMsT0FBTyxHQUFHLFNBQVNBLFFBQVNsaUMsQ0FBQztJQUNoRCxJQUFJLENBQUM2a0IsTUFBTSxDQUFDalQsSUFBSSxDQUFDNVI7QUFDbkI7QUFDQWlpQyxXQUFXOXFDLFNBQVMsQ0FBQ2dyQyxXQUFXLEdBQUcsU0FBU0E7SUFDMUMsT0FBTyxJQUFJLENBQUN0ZCxNQUFNLENBQUN1ZCxLQUFLO0FBQzFCO0FBQ0FILFdBQVc5cUMsU0FBUyxDQUFDOFosT0FBTyxHQUFHLFNBQVNBO0lBQ3RDLE9BQU8sSUFBSSxDQUFDNFQsTUFBTSxDQUFDanRCLE1BQU0sS0FBSztBQUNoQztBQUVBLElBQUl5cUMsaUJBQWlCLFNBQVNBO0lBQzVCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSTVkO0lBQ3hCLElBQUksQ0FBQzZkLE1BQU0sR0FBRyxJQUFJN2Q7SUFDbEIsSUFBSSxDQUFDOGQsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDSixPQUFPLEdBQUcsSUFBSW5DO0FBQ3JCO0FBQ0FrQyxlQUFlbHJDLFNBQVMsQ0FBQ3dyQyxpQkFBaUIsR0FBRyxTQUFTQTtJQUNwRCxJQUFLLElBQUk5USxLQUFLLElBQUksQ0FBQzBRLFlBQVksQ0FBQy9mLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDekQsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtRQUNoQjRoQixHQUFHbUMsVUFBVSxDQUFDO0lBQ2hCO0FBQ0Y7QUFDQVAsZUFBZWxyQyxTQUFTLENBQUMwckMsc0JBQXNCLEdBQUcsU0FBU0E7SUFDekQsT0FBTyxJQUFJLENBQUNKLGVBQWU7QUFDN0I7QUFDQUosZUFBZWxyQyxTQUFTLENBQUMyckMsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCM29DLENBQUM7SUFDcEUsSUFBSXNYLFNBQVMsSUFBSTtJQUVuQixJQUFJc3hCLFlBQVk7SUFDaEIsSUFBSyxJQUFJeGtDLElBQUlwRSxFQUFFb25DLFFBQVEsR0FBRy9lLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUNsRCxJQUFJK2QsS0FBS2xpQyxFQUFFc2dCLElBQUk7UUFDZixJQUFJNGhCLEdBQUd1QyxTQUFTLE1BQU12QyxHQUFHaUIsTUFBTSxHQUFHc0IsU0FBUyxJQUFJO1lBQzdDRCxZQUFZdEM7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxJQUFJc0MsY0FBYyxNQUFNO1FBQUUsTUFBTSxJQUFJakIsa0JBQWtCLDhDQUE4QzNuQyxFQUFFNFEsYUFBYTtJQUFJO0lBQ3ZINVEsRUFBRW9uQyxRQUFRLEdBQUcwQixhQUFhLENBQUNGO0lBQzNCLElBQUssSUFBSWhtQixNQUFNNWlCLEVBQUVvbkMsUUFBUSxHQUFHL2UsUUFBUSxJQUFJekYsSUFBSTJGLE9BQU8sSUFBSztRQUN0RCxJQUFJd2dCLE9BQU9ubUIsSUFBSThCLElBQUk7UUFDbkJxa0IsS0FBS04sVUFBVSxDQUFDO1FBQ2hCbnhCLE9BQU8weEIsYUFBYSxDQUFDRDtJQUN2QjtBQUNGO0FBQ0FiLGVBQWVsckMsU0FBUyxDQUFDaXNDLFlBQVksR0FBRyxTQUFTQSxhQUFjQyxZQUFZO0lBQ3pFLElBQUksQ0FBQ1YsaUJBQWlCO0lBQ3RCLElBQUlsQyxLQUFLLElBQUksQ0FBQzZCLE9BQU8sQ0FBQ3hCLE9BQU87SUFDN0IseUJBQXlCO0lBQ3pCLDhCQUE4QjtJQUM5QkwsR0FBRzZDLGFBQWEsQ0FBQzdELFNBQVN2aUIsS0FBSyxFQUFFbW1CO0lBQ2pDLElBQUksQ0FBQ0YsYUFBYSxDQUFDMUM7SUFDbkIsSUFBSSxDQUFDd0MsYUFBYSxDQUFDeEM7QUFDckI7QUFDQTRCLGVBQWVsckMsU0FBUyxDQUFDMkMsTUFBTSxHQUFHLFNBQVNBLE9BQVFzbkMsSUFBSTtJQUNyRCxJQUFJLENBQUNtQyxZQUFZLENBQUNuQztJQUNsQixJQUFJLENBQUNrQixPQUFPLENBQUNYLFFBQVEsQ0FBQyxJQUFJLENBQUNZLFlBQVk7SUFDdkMsSUFBSSxDQUFDRSxlQUFlLEdBQUcsSUFBSSxDQUFDSCxPQUFPLENBQUN2M0IsYUFBYTtBQUNuRDtBQUNBczNCLGVBQWVsckMsU0FBUyxDQUFDcXNDLGVBQWUsR0FBRyxTQUFTQTtJQUNsRCxJQUFLLElBQUkzUixLQUFLLElBQUksQ0FBQzBRLFlBQVksQ0FBQy9mLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDekQsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtRQUNoQixJQUFJNGhCLEdBQUdnRCxRQUFRLENBQUNoRSxTQUFTdmlCLEtBQUssS0FBSyxLQUFLdWpCLEdBQUdnRCxRQUFRLENBQUNoRSxTQUFTcmlCLElBQUksS0FBSyxLQUFLLENBQUNxakIsR0FBR2lELGtCQUFrQixJQUFJO1lBQ25HakQsR0FBR2tELFdBQVcsQ0FBQztRQUNqQjtJQUNGO0FBQ0Y7QUFDQXRCLGVBQWVsckMsU0FBUyxDQUFDOHJDLGFBQWEsR0FBRyxTQUFTQSxjQUFlRixTQUFTO0lBQ3RFLElBQUl0eEIsU0FBUyxJQUFJO0lBRW5CLElBQUlteUIsZUFBZSxJQUFJalo7SUFDdkIsSUFBSWtaLFlBQVksSUFBSTVCO0lBQ3BCLElBQUk2QixZQUFZZixVQUFVMUIsT0FBTztJQUNqQ3dDLFVBQVUzQixPQUFPLENBQUM0QjtJQUNsQkYsYUFBYXhnQyxHQUFHLENBQUMwZ0M7SUFDakJmLFVBQVVILFVBQVUsQ0FBQztJQUNyQixNQUFPLENBQUNpQixVQUFVNXlCLE9BQU8sR0FBSTtRQUMzQixJQUFJOVcsSUFBSTBwQyxVQUFVMUIsV0FBVztRQUM3QnlCLGFBQWF4Z0MsR0FBRyxDQUFDako7UUFDakJzWCxPQUFPcXhCLGdCQUFnQixDQUFDM29DO1FBQ3hCLElBQUssSUFBSW9FLElBQUlwRSxFQUFFb25DLFFBQVEsR0FBRy9lLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUNsRCxJQUFJK2QsS0FBS2xpQyxFQUFFc2dCLElBQUk7WUFDZixJQUFJa2xCLE1BQU10RCxHQUFHaUIsTUFBTTtZQUNuQixJQUFJcUMsSUFBSWYsU0FBUyxJQUFJO2dCQUFFO1lBQVM7WUFDaEMsSUFBSWdCLFVBQVVELElBQUkxQyxPQUFPO1lBQ3pCLElBQUksQ0FBQ3VDLGFBQWF4MEIsUUFBUSxDQUFDNDBCLFVBQVU7Z0JBQ25DSCxVQUFVM0IsT0FBTyxDQUFDOEI7Z0JBQ2xCSixhQUFheGdDLEdBQUcsQ0FBQzRnQztZQUNuQjtRQUNGO0lBQ0Y7QUFDRjtBQUNBM0IsZUFBZWxyQyxTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV0MsQ0FBQztJQUN4RCxJQUFJZ29DLFFBQVFob0M7SUFDWixJQUFJLElBQUksQ0FBQ3dtQyxlQUFlLENBQUM1cEMsQ0FBQyxHQUFHb3JDLE1BQU14QixlQUFlLENBQUM1cEMsQ0FBQyxFQUFFO1FBQ3BELE9BQU8sQ0FBQztJQUNWO0lBQ0EsSUFBSSxJQUFJLENBQUM0cEMsZUFBZSxDQUFDNXBDLENBQUMsR0FBR29yQyxNQUFNeEIsZUFBZSxDQUFDNXBDLENBQUMsRUFBRTtRQUNwRCxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQXdwQyxlQUFlbHJDLFNBQVMsQ0FBQ3lxQixXQUFXLEdBQUcsU0FBU0E7SUFDOUMsSUFBSSxJQUFJLENBQUM4Z0IsSUFBSSxLQUFLLE1BQU07UUFDdEIsSUFBSXdCLFVBQVUsSUFBSTcyQjtRQUNsQixJQUFLLElBQUl3a0IsS0FBSyxJQUFJLENBQUMwUSxZQUFZLENBQUMvZixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1lBQ3pELElBQUl5aEIsVUFBVXRTLEdBQUdoVCxJQUFJO1lBQ3JCLElBQUlULE1BQU0rbEIsUUFBUXJELE9BQU8sR0FBR2pTLGNBQWM7WUFDMUMsSUFBSyxJQUFJdHdCLElBQUksR0FBR0EsSUFBSTZmLElBQUl4bUIsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO2dCQUN2QzJsQyxRQUFReDFCLGVBQWUsQ0FBQzBQLEdBQUcsQ0FBQzdmLEVBQUU7WUFDaEM7UUFDRjtRQUNBLElBQUksQ0FBQ21rQyxJQUFJLEdBQUd3QjtJQUNkO0lBQ0EsT0FBTyxJQUFJLENBQUN4QixJQUFJO0FBQ2xCO0FBQ0FMLGVBQWVsckMsU0FBUyxDQUFDb3NDLFlBQVksR0FBRyxTQUFTQSxhQUFjTyxTQUFTO0lBQ3BFLElBQUlyeUIsU0FBUyxJQUFJO0lBRW5CLElBQUkyeUIsWUFBWSxJQUFJckU7SUFDcEJxRSxVQUFVaGhDLEdBQUcsQ0FBQzBnQztJQUNkLE1BQU8sQ0FBQ00sVUFBVWxFLEtBQUssR0FBSTtRQUN6QixJQUFJa0IsT0FBT2dELFVBQVVwRSxHQUFHO1FBQ3hCdnVCLE9BQU9yTyxHQUFHLENBQUNnK0IsTUFBTWdEO0lBQ25CO0FBQ0Y7QUFDQS9CLGVBQWVsckMsU0FBUyxDQUFDZ3NDLGFBQWEsR0FBRyxTQUFTQSxjQUFlMUMsRUFBRTtJQUNqRSxJQUFJc0QsTUFBTXRELEdBQUdpQixNQUFNO0lBQ25CcUMsSUFBSU0sUUFBUSxDQUFDNUUsU0FBU3JpQixJQUFJLEVBQUVxakIsR0FBR2dELFFBQVEsQ0FBQ2hFLFNBQVN2aUIsS0FBSztJQUN0RDZtQixJQUFJTSxRQUFRLENBQUM1RSxTQUFTdmlCLEtBQUssRUFBRXVqQixHQUFHZ0QsUUFBUSxDQUFDaEUsU0FBU3JpQixJQUFJO0FBQ3hEO0FBQ0FpbEIsZUFBZWxyQyxTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsSUFBS2crQixJQUFJLEVBQUVnRCxTQUFTO0lBQ3hELElBQUkzeUIsU0FBUyxJQUFJO0lBRW5CMnZCLEtBQUt3QixVQUFVLENBQUM7SUFDaEIsSUFBSSxDQUFDSixNQUFNLENBQUNwL0IsR0FBRyxDQUFDZytCO0lBQ2hCLElBQUssSUFBSTdpQyxJQUFJNmlDLEtBQUtHLFFBQVEsR0FBRy9lLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUNyRCxJQUFJK2QsS0FBS2xpQyxFQUFFc2dCLElBQUk7UUFDZnBOLE9BQU84d0IsWUFBWSxDQUFDbi9CLEdBQUcsQ0FBQ3E5QjtRQUN4QixJQUFJc0QsTUFBTXRELEdBQUdpQixNQUFNO1FBQ25CLElBQUk0QyxVQUFVUCxJQUFJMUMsT0FBTztRQUN6QixJQUFJLENBQUNpRCxRQUFRdEIsU0FBUyxJQUFJO1lBQUVvQixVQUFVeHlCLElBQUksQ0FBQzB5QjtRQUFVO0lBQ3ZEO0FBQ0Y7QUFDQWpDLGVBQWVsckMsU0FBUyxDQUFDb3RDLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQy9CLE1BQU07QUFDcEI7QUFDQUgsZUFBZWxyQyxTQUFTLENBQUNxdEMsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxJQUFJLENBQUNqQyxZQUFZO0FBQzFCO0FBQ0FGLGVBQWVsckMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlDLE9BQU87UUFBQ3lCO0tBQVc7QUFDckI7QUFDQTRuQyxlQUFlbHJDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPb3BDO0FBQ1Q7QUFFQSxJQUFJb0MsbUJBQW1CLFNBQVNBO0lBQzlCLElBQUloekIsU0FBUyxJQUFJO0lBRWpCLElBQUksQ0FBQ2l6QixRQUFRLEdBQUc7SUFDaEIsSUFBSXpzQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZZixPQUFPO1lBQ2pDLElBQUl3dEMsV0FBV3pzQyxTQUFTLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMwSSxJQUFJLENBQUMrakMsU0FBUzlzQyxNQUFNO1FBQzNCLE9BQU8sSUFBSU8sT0FBT0ksU0FBUyxDQUFDTixTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ3pDLElBQUkwc0MsS0FBSzFzQyxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJLENBQUMwSSxJQUFJLENBQUM7WUFDVixJQUFJLENBQUMrakMsUUFBUSxDQUFDakYsU0FBU0UsRUFBRSxDQUFDLEdBQUdnRjtRQUMvQixPQUFPLElBQUkxc0MsU0FBUyxDQUFDLEVBQUUsWUFBWXdzQyxrQkFBa0I7WUFDbkQsSUFBSUcsS0FBSzNzQyxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJLENBQUMwSSxJQUFJLENBQUNpa0MsR0FBR0YsUUFBUSxDQUFDOXNDLE1BQU07WUFDNUIsSUFBSWd0QyxPQUFPLE1BQU07Z0JBQ2YsSUFBSyxJQUFJcm1DLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNtbUMsUUFBUSxDQUFDOXNDLE1BQU0sRUFBRTJHLElBQUs7b0JBQzdDa1QsT0FBT2l6QixRQUFRLENBQUNubUMsRUFBRSxHQUFHcW1DLEdBQUdGLFFBQVEsQ0FBQ25tQyxFQUFFO2dCQUNyQztZQUNGO1FBQ0Y7SUFDRixPQUFPLElBQUl0RyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJaXRDLE9BQU81c0MsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXV6QixPQUFPdnpCLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUl5ekIsUUFBUXp6QixTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUMwSSxJQUFJLENBQUM7UUFDVixJQUFJLENBQUMrakMsUUFBUSxDQUFDakYsU0FBU0UsRUFBRSxDQUFDLEdBQUdrRjtRQUM3QixJQUFJLENBQUNILFFBQVEsQ0FBQ2pGLFNBQVNyaUIsSUFBSSxDQUFDLEdBQUdvTztRQUMvQixJQUFJLENBQUNrWixRQUFRLENBQUNqRixTQUFTdmlCLEtBQUssQ0FBQyxHQUFHd087SUFDbEM7QUFDRjtBQUNBK1ksaUJBQWlCdHRDLFNBQVMsQ0FBQzJ0QyxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCQyxRQUFRO0lBQzNFLElBQUl0ekIsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNtbUMsUUFBUSxDQUFDOXNDLE1BQU0sRUFBRTJHLElBQUs7UUFDN0NrVCxPQUFPaXpCLFFBQVEsQ0FBQ25tQyxFQUFFLEdBQUd3bUM7SUFDdkI7QUFDRjtBQUNBTixpQkFBaUJ0dEMsU0FBUyxDQUFDNFcsTUFBTSxHQUFHLFNBQVNBO0lBQ3pDLElBQUkwRCxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ21tQyxRQUFRLENBQUM5c0MsTUFBTSxFQUFFMkcsSUFBSztRQUM3QyxJQUFJa1QsT0FBT2l6QixRQUFRLENBQUNubUMsRUFBRSxLQUFLVCxTQUFTSyxJQUFJLEVBQUU7WUFBRSxPQUFPO1FBQU07SUFDM0Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQXNtQyxpQkFBaUJ0dEMsU0FBUyxDQUFDNnRDLHFCQUFxQixHQUFHLFNBQVNBLHNCQUF1QkQsUUFBUTtJQUN2RixJQUFJdHpCLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDbW1DLFFBQVEsQ0FBQzlzQyxNQUFNLEVBQUUyRyxJQUFLO1FBQzdDLElBQUlrVCxPQUFPaXpCLFFBQVEsQ0FBQ25tQyxFQUFFLEtBQUtULFNBQVNLLElBQUksRUFBRTtZQUFFc1QsT0FBT2l6QixRQUFRLENBQUNubUMsRUFBRSxHQUFHd21DO1FBQVU7SUFDN0U7QUFDRjtBQUNBTixpQkFBaUJ0dEMsU0FBUyxDQUFDOHRDLE1BQU0sR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDOXNDLE1BQU0sS0FBSztBQUNsQztBQUNBNnNDLGlCQUFpQnR0QyxTQUFTLENBQUMrdEMsS0FBSyxHQUFHLFNBQVNBLE1BQU9OLEVBQUU7SUFDakQsSUFBSW56QixTQUFTLElBQUk7SUFFbkIsSUFBSW16QixHQUFHRixRQUFRLENBQUM5c0MsTUFBTSxHQUFHLElBQUksQ0FBQzhzQyxRQUFRLENBQUM5c0MsTUFBTSxFQUFFO1FBQzdDLElBQUl1dEMsU0FBUyxJQUFJanVDLE1BQU0sR0FBR00sSUFBSSxDQUFDO1FBQy9CMnRDLE1BQU0sQ0FBQzFGLFNBQVNFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQytFLFFBQVEsQ0FBQ2pGLFNBQVNFLEVBQUUsQ0FBQztRQUNoRHdGLE1BQU0sQ0FBQzFGLFNBQVNyaUIsSUFBSSxDQUFDLEdBQUd0ZixTQUFTSyxJQUFJO1FBQ3JDZ25DLE1BQU0sQ0FBQzFGLFNBQVN2aUIsS0FBSyxDQUFDLEdBQUdwZixTQUFTSyxJQUFJO1FBQ3RDLElBQUksQ0FBQ3VtQyxRQUFRLEdBQUdTO0lBQ2xCO0lBQ0EsSUFBSyxJQUFJNW1DLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNtbUMsUUFBUSxDQUFDOXNDLE1BQU0sRUFBRTJHLElBQUs7UUFDN0MsSUFBSWtULE9BQU9pekIsUUFBUSxDQUFDbm1DLEVBQUUsS0FBS1QsU0FBU0ssSUFBSSxJQUFJSSxJQUFJcW1DLEdBQUdGLFFBQVEsQ0FBQzlzQyxNQUFNLEVBQUU7WUFBRTZaLE9BQU9pekIsUUFBUSxDQUFDbm1DLEVBQUUsR0FBR3FtQyxHQUFHRixRQUFRLENBQUNubUMsRUFBRTtRQUFFO0lBQzdHO0FBQ0Y7QUFDQWttQyxpQkFBaUJ0dEMsU0FBUyxDQUFDaXVDLFlBQVksR0FBRyxTQUFTQTtJQUNqRCxPQUFPLElBQUksQ0FBQ1YsUUFBUTtBQUN0QjtBQUNBRCxpQkFBaUJ0dEMsU0FBUyxDQUFDa3VDLElBQUksR0FBRyxTQUFTQTtJQUN6QyxJQUFJLElBQUksQ0FBQ1gsUUFBUSxDQUFDOXNDLE1BQU0sSUFBSSxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQzdDLElBQUkwdEMsT0FBTyxJQUFJLENBQUNaLFFBQVEsQ0FBQ2pGLFNBQVNyaUIsSUFBSSxDQUFDO0lBQ3ZDLElBQUksQ0FBQ3NuQixRQUFRLENBQUNqRixTQUFTcmlCLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ3NuQixRQUFRLENBQUNqRixTQUFTdmlCLEtBQUssQ0FBQztJQUM1RCxJQUFJLENBQUN3bkIsUUFBUSxDQUFDakYsU0FBU3ZpQixLQUFLLENBQUMsR0FBR29vQjtBQUNsQztBQUNBYixpQkFBaUJ0dEMsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLElBQUlvRyxNQUFNLElBQUkzQztJQUNkLElBQUksSUFBSSxDQUFDNmtDLFFBQVEsQ0FBQzlzQyxNQUFNLEdBQUcsR0FBRztRQUFFNEssSUFBSXpDLE1BQU0sQ0FBQ2pDLFNBQVNNLGdCQUFnQixDQUFDLElBQUksQ0FBQ3NtQyxRQUFRLENBQUNqRixTQUFTcmlCLElBQUksQ0FBQztJQUFJO0lBQ3JHNWEsSUFBSXpDLE1BQU0sQ0FBQ2pDLFNBQVNNLGdCQUFnQixDQUFDLElBQUksQ0FBQ3NtQyxRQUFRLENBQUNqRixTQUFTRSxFQUFFLENBQUM7SUFDL0QsSUFBSSxJQUFJLENBQUMrRSxRQUFRLENBQUM5c0MsTUFBTSxHQUFHLEdBQUc7UUFBRTRLLElBQUl6QyxNQUFNLENBQUNqQyxTQUFTTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNzbUMsUUFBUSxDQUFDakYsU0FBU3ZpQixLQUFLLENBQUM7SUFBSTtJQUN0RyxPQUFPMWEsSUFBSXBHLFFBQVE7QUFDckI7QUFDQXFvQyxpQkFBaUJ0dEMsU0FBUyxDQUFDb3VDLFlBQVksR0FBRyxTQUFTQSxhQUFjWixFQUFFLEVBQUVuWixJQUFJLEVBQUVFLEtBQUs7SUFDOUUsSUFBSSxDQUFDZ1osUUFBUSxDQUFDakYsU0FBU0UsRUFBRSxDQUFDLEdBQUdnRjtJQUM3QixJQUFJLENBQUNELFFBQVEsQ0FBQ2pGLFNBQVNyaUIsSUFBSSxDQUFDLEdBQUdvTztJQUMvQixJQUFJLENBQUNrWixRQUFRLENBQUNqRixTQUFTdmlCLEtBQUssQ0FBQyxHQUFHd087QUFDbEM7QUFDQStZLGlCQUFpQnR0QyxTQUFTLENBQUNvRCxHQUFHLEdBQUcsU0FBU0EsSUFBS2lyQyxRQUFRO0lBQ3JELElBQUlBLFdBQVcsSUFBSSxDQUFDZCxRQUFRLENBQUM5c0MsTUFBTSxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUM4c0MsUUFBUSxDQUFDYyxTQUFTO0lBQUM7SUFDdEUsT0FBTzFuQyxTQUFTSyxJQUFJO0FBQ3RCO0FBQ0FzbUMsaUJBQWlCdHRDLFNBQVMsQ0FBQ3N1QyxNQUFNLEdBQUcsU0FBU0E7SUFDM0MsT0FBTyxJQUFJLENBQUNmLFFBQVEsQ0FBQzlzQyxNQUFNLEdBQUc7QUFDaEM7QUFDQTZzQyxpQkFBaUJ0dEMsU0FBUyxDQUFDdXVDLFNBQVMsR0FBRyxTQUFTQTtJQUM1QyxJQUFJajBCLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDbW1DLFFBQVEsQ0FBQzlzQyxNQUFNLEVBQUUyRyxJQUFLO1FBQzdDLElBQUlrVCxPQUFPaXpCLFFBQVEsQ0FBQ25tQyxFQUFFLEtBQUtULFNBQVNLLElBQUksRUFBRTtZQUFFLE9BQU87UUFBSztJQUMxRDtJQUNBLE9BQU87QUFDVDtBQUNBc21DLGlCQUFpQnR0QyxTQUFTLENBQUN3dUMsV0FBVyxHQUFHLFNBQVNBO0lBQ2hELElBQUkxdEMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSW10QyxXQUFXOXNDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUksQ0FBQzB0QyxXQUFXLENBQUNsRyxTQUFTRSxFQUFFLEVBQUVvRjtJQUNoQyxPQUFPLElBQUk5c0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWd1QyxXQUFXM3RDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUk0dEMsYUFBYTV0QyxTQUFTLENBQUMsRUFBRTtRQUM3QixJQUFJLENBQUN5c0MsUUFBUSxDQUFDa0IsU0FBUyxHQUFHQztJQUM1QjtBQUNGO0FBQ0FwQixpQkFBaUJ0dEMsU0FBUyxDQUFDd0osSUFBSSxHQUFHLFNBQVNBLEtBQU1tSyxJQUFJO0lBQ25ELElBQUksQ0FBQzQ1QixRQUFRLEdBQUcsSUFBSXh0QyxNQUFNNFQsTUFBTXRULElBQUksQ0FBQztJQUNyQyxJQUFJLENBQUNzdEMsZUFBZSxDQUFDaG5DLFNBQVNLLElBQUk7QUFDcEM7QUFDQXNtQyxpQkFBaUJ0dEMsU0FBUyxDQUFDMnVDLGFBQWEsR0FBRyxTQUFTQSxjQUFlbGtDLEVBQUUsRUFBRWdrQyxRQUFRO0lBQzdFLE9BQU8sSUFBSSxDQUFDbEIsUUFBUSxDQUFDa0IsU0FBUyxLQUFLaGtDLEdBQUc4aUMsUUFBUSxDQUFDa0IsU0FBUztBQUMxRDtBQUNBbkIsaUJBQWlCdHRDLFNBQVMsQ0FBQzR1QyxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJDLEdBQUc7SUFDMUUsSUFBSXYwQixTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ21tQyxRQUFRLENBQUM5c0MsTUFBTSxFQUFFMkcsSUFBSztRQUM3QyxJQUFJa1QsT0FBT2l6QixRQUFRLENBQUNubUMsRUFBRSxLQUFLeW5DLEtBQUs7WUFBRSxPQUFPO1FBQU07SUFDakQ7SUFDQSxPQUFPO0FBQ1Q7QUFDQXZCLGlCQUFpQnR0QyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDaEQsT0FBTyxFQUFFO0FBQ1g7QUFDQXlyQyxpQkFBaUJ0dEMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLE9BQU93ckM7QUFDVDtBQUVBLElBQUl3QixRQUFRLFNBQVNBO0lBQ25CLElBQUksQ0FBQ0MsR0FBRyxHQUFHLElBQUlodkMsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDN0IsSUFBSVMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSU8sT0FBT0ksU0FBUyxDQUFDTixTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ2xDLElBQUlrdUMsUUFBUWx1QyxTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUNpdUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJekIsaUJBQWlCMEI7WUFDbkMsSUFBSSxDQUFDRCxHQUFHLENBQUMsRUFBRSxHQUFHLElBQUl6QixpQkFBaUIwQjtRQUNyQyxPQUFPLElBQUlsdUMsU0FBUyxDQUFDLEVBQUUsWUFBWWd1QyxPQUFPO1lBQ3hDLElBQUlHLE1BQU1udUMsU0FBUyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSXpCLGlCQUFpQjJCLElBQUlGLEdBQUcsQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQ0EsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJekIsaUJBQWlCMkIsSUFBSUYsR0FBRyxDQUFDLEVBQUU7UUFDL0M7SUFDRixPQUFPLElBQUlqdUMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXl1QyxZQUFZcHVDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUlxdUMsVUFBVXJ1QyxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUNpdUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJekIsaUJBQWlCM21DLFNBQVNLLElBQUk7UUFDaEQsSUFBSSxDQUFDK25DLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSXpCLGlCQUFpQjNtQyxTQUFTSyxJQUFJO1FBQ2hELElBQUksQ0FBQytuQyxHQUFHLENBQUNHLFVBQVUsQ0FBQ1YsV0FBVyxDQUFDVztJQUNsQyxPQUFPLElBQUlydUMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTJ1QyxVQUFVdHVDLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLElBQUl1dUMsVUFBVXZ1QyxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJd3VDLFdBQVd4dUMsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSXpCLGlCQUFpQjhCLFNBQVNDLFNBQVNDO1FBQ3JELElBQUksQ0FBQ1AsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJekIsaUJBQWlCOEIsU0FBU0MsU0FBU0M7SUFDdkQsT0FBTyxJQUFJeHVDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk4dUMsY0FBY3p1QyxTQUFTLENBQUMsRUFBRTtRQUM5QixJQUFJMHVDLFVBQVUxdUMsU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSTJ1QyxZQUFZM3VDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUk0dUMsYUFBYTV1QyxTQUFTLENBQUMsRUFBRTtRQUM3QixJQUFJLENBQUNpdUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJekIsaUJBQWlCM21DLFNBQVNLLElBQUksRUFBRUwsU0FBU0ssSUFBSSxFQUFFTCxTQUFTSyxJQUFJO1FBQzlFLElBQUksQ0FBQytuQyxHQUFHLENBQUMsRUFBRSxHQUFHLElBQUl6QixpQkFBaUIzbUMsU0FBU0ssSUFBSSxFQUFFTCxTQUFTSyxJQUFJLEVBQUVMLFNBQVNLLElBQUk7UUFDOUUsSUFBSSxDQUFDK25DLEdBQUcsQ0FBQ1EsWUFBWSxDQUFDbkIsWUFBWSxDQUFDb0IsU0FBU0MsV0FBV0M7SUFDekQ7QUFDRjtBQUNBWixNQUFNOXVDLFNBQVMsQ0FBQzJ2QyxnQkFBZ0IsR0FBRyxTQUFTQTtJQUMxQyxJQUFJOVUsUUFBUTtJQUNaLElBQUksQ0FBQyxJQUFJLENBQUNrVSxHQUFHLENBQUMsRUFBRSxDQUFDbjRCLE1BQU0sSUFBSTtRQUFFaWtCO0lBQVM7SUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ2tVLEdBQUcsQ0FBQyxFQUFFLENBQUNuNEIsTUFBTSxJQUFJO1FBQUVpa0I7SUFBUztJQUN0QyxPQUFPQTtBQUNUO0FBQ0FpVSxNQUFNOXVDLFNBQVMsQ0FBQzJ0QyxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCdUIsU0FBUyxFQUFFM0IsUUFBUTtJQUM3RSxJQUFJLENBQUN3QixHQUFHLENBQUNHLFVBQVUsQ0FBQ3ZCLGVBQWUsQ0FBQ0o7QUFDdEM7QUFDQXVCLE1BQU05dUMsU0FBUyxDQUFDNFcsTUFBTSxHQUFHLFNBQVNBLE9BQVFzNEIsU0FBUztJQUNqRCxPQUFPLElBQUksQ0FBQ0gsR0FBRyxDQUFDRyxVQUFVLENBQUN0NEIsTUFBTTtBQUNuQztBQUNBazRCLE1BQU05dUMsU0FBUyxDQUFDNnRDLHFCQUFxQixHQUFHLFNBQVNBO0lBQy9DLElBQUkvc0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSThzQyxXQUFXenNDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUksQ0FBQytzQyxxQkFBcUIsQ0FBQyxHQUFHTjtRQUM5QixJQUFJLENBQUNNLHFCQUFxQixDQUFDLEdBQUdOO0lBQ2hDLE9BQU8sSUFBSXpzQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJeXVDLFlBQVlwdUMsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSTh1QyxhQUFhOXVDLFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUksQ0FBQ2l1QyxHQUFHLENBQUNHLFVBQVUsQ0FBQ3JCLHFCQUFxQixDQUFDK0I7SUFDNUM7QUFDRjtBQUNBZCxNQUFNOXVDLFNBQVMsQ0FBQzh0QyxNQUFNLEdBQUcsU0FBU0EsT0FBUW9CLFNBQVM7SUFDakQsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBQ0csVUFBVSxDQUFDcEIsTUFBTTtBQUNuQztBQUNBZ0IsTUFBTTl1QyxTQUFTLENBQUMrdEMsS0FBSyxHQUFHLFNBQVNBLE1BQU9rQixHQUFHO0lBQ3ZDLElBQUkzMEIsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQzFCLElBQUlrVCxPQUFPeTBCLEdBQUcsQ0FBQzNuQyxFQUFFLEtBQUssUUFBUTZuQyxJQUFJRixHQUFHLENBQUMzbkMsRUFBRSxLQUFLLE1BQU07WUFDakRrVCxPQUFPeTBCLEdBQUcsQ0FBQzNuQyxFQUFFLEdBQUcsSUFBSWttQyxpQkFBaUIyQixJQUFJRixHQUFHLENBQUMzbkMsRUFBRTtRQUNqRCxPQUFPO1lBQ0xrVCxPQUFPeTBCLEdBQUcsQ0FBQzNuQyxFQUFFLENBQUMybUMsS0FBSyxDQUFDa0IsSUFBSUYsR0FBRyxDQUFDM25DLEVBQUU7UUFDaEM7SUFDRjtBQUNGO0FBQ0EwbkMsTUFBTTl1QyxTQUFTLENBQUNrdUMsSUFBSSxHQUFHLFNBQVNBO0lBQzlCLElBQUksQ0FBQ2EsR0FBRyxDQUFDLEVBQUUsQ0FBQ2IsSUFBSTtJQUNoQixJQUFJLENBQUNhLEdBQUcsQ0FBQyxFQUFFLENBQUNiLElBQUk7QUFDbEI7QUFDQVksTUFBTTl1QyxTQUFTLENBQUNxbEIsV0FBVyxHQUFHLFNBQVNBO0lBQ3JDLElBQUl2a0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSXl1QyxZQUFZcHVDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQ0csVUFBVSxDQUFDOXJDLEdBQUcsQ0FBQ2tsQyxTQUFTRSxFQUFFO0lBQzVDLE9BQU8sSUFBSTFuQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJOHVDLGNBQWN6dUMsU0FBUyxDQUFDLEVBQUU7UUFDOUIsSUFBSXV0QyxXQUFXdnRDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQ1EsWUFBWSxDQUFDbnNDLEdBQUcsQ0FBQ2lyQztJQUNuQztBQUNGO0FBQ0FTLE1BQU05dUMsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQ2xDLElBQUlvRyxNQUFNLElBQUkzQztJQUNkLElBQUksSUFBSSxDQUFDcW1DLEdBQUcsQ0FBQyxFQUFFLEtBQUssTUFBTTtRQUN4QjFqQyxJQUFJekMsTUFBTSxDQUFDO1FBQ1h5QyxJQUFJekMsTUFBTSxDQUFDLElBQUksQ0FBQ21tQyxHQUFHLENBQUMsRUFBRSxDQUFDOXBDLFFBQVE7SUFDakM7SUFDQSxJQUFJLElBQUksQ0FBQzhwQyxHQUFHLENBQUMsRUFBRSxLQUFLLE1BQU07UUFDeEIxakMsSUFBSXpDLE1BQU0sQ0FBQztRQUNYeUMsSUFBSXpDLE1BQU0sQ0FBQyxJQUFJLENBQUNtbUMsR0FBRyxDQUFDLEVBQUUsQ0FBQzlwQyxRQUFRO0lBQ2pDO0lBQ0EsT0FBT29HLElBQUlwRyxRQUFRO0FBQ3JCO0FBQ0E2cEMsTUFBTTl1QyxTQUFTLENBQUNzdUMsTUFBTSxHQUFHLFNBQVNBO0lBQ2hDLElBQUl4dEMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBTyxJQUFJLENBQUNzdUMsR0FBRyxDQUFDLEVBQUUsQ0FBQ1QsTUFBTSxNQUFNLElBQUksQ0FBQ1MsR0FBRyxDQUFDLEVBQUUsQ0FBQ1QsTUFBTTtJQUNuRCxPQUFPLElBQUl4dEMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXl1QyxZQUFZcHVDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQ0csVUFBVSxDQUFDWixNQUFNO0lBQ25DO0FBQ0Y7QUFDQVEsTUFBTTl1QyxTQUFTLENBQUN1dUMsU0FBUyxHQUFHLFNBQVNBLFVBQVdXLFNBQVM7SUFDdkQsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBQ0csVUFBVSxDQUFDWCxTQUFTO0FBQ3RDO0FBQ0FPLE1BQU05dUMsU0FBUyxDQUFDd3VDLFdBQVcsR0FBRyxTQUFTQTtJQUNyQyxJQUFJMXRDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUl5dUMsWUFBWXB1QyxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFJeXNDLFdBQVd6c0MsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQ0csVUFBVSxDQUFDVixXQUFXLENBQUNsRyxTQUFTRSxFQUFFLEVBQUUrRTtJQUMvQyxPQUFPLElBQUl6c0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTh1QyxjQUFjenVDLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUl1dEMsV0FBV3Z0QyxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJOHVDLGFBQWE5dUMsU0FBUyxDQUFDLEVBQUU7UUFDN0IsSUFBSSxDQUFDaXVDLEdBQUcsQ0FBQ1EsWUFBWSxDQUFDZixXQUFXLENBQUNILFVBQVV1QjtJQUM5QztBQUNGO0FBQ0FkLE1BQU05dUMsU0FBUyxDQUFDMnVDLGFBQWEsR0FBRyxTQUFTQSxjQUFlTSxHQUFHLEVBQUUxRixJQUFJO0lBQy9ELE9BQU8sSUFBSSxDQUFDd0YsR0FBRyxDQUFDLEVBQUUsQ0FBQ0osYUFBYSxDQUFDTSxJQUFJRixHQUFHLENBQUMsRUFBRSxFQUFFeEYsU0FBUyxJQUFJLENBQUN3RixHQUFHLENBQUMsRUFBRSxDQUFDSixhQUFhLENBQUNNLElBQUlGLEdBQUcsQ0FBQyxFQUFFLEVBQUV4RjtBQUM5RjtBQUNBdUYsTUFBTTl1QyxTQUFTLENBQUM0dUMsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CTSxTQUFTLEVBQUVMLEdBQUc7SUFDNUUsT0FBTyxJQUFJLENBQUNFLEdBQUcsQ0FBQ0csVUFBVSxDQUFDTixpQkFBaUIsQ0FBQ0M7QUFDL0M7QUFDQUMsTUFBTTl1QyxTQUFTLENBQUM2dkMsTUFBTSxHQUFHLFNBQVNBLE9BQVFYLFNBQVM7SUFDakQsSUFBSSxJQUFJLENBQUNILEdBQUcsQ0FBQ0csVUFBVSxDQUFDWixNQUFNLElBQUk7UUFBRSxJQUFJLENBQUNTLEdBQUcsQ0FBQ0csVUFBVSxHQUFHLElBQUk1QixpQkFBaUIsSUFBSSxDQUFDeUIsR0FBRyxDQUFDRyxVQUFVLENBQUMzQixRQUFRLENBQUMsRUFBRTtJQUFHO0FBQ25IO0FBQ0F1QixNQUFNOXVDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNyQyxPQUFPLEVBQUU7QUFDWDtBQUNBaXRDLE1BQU05dUMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2xDLE9BQU9ndEM7QUFDVDtBQUNBQSxNQUFNZ0IsV0FBVyxHQUFHLFNBQVNBLFlBQWFDLEtBQUs7SUFDN0MsSUFBSUMsWUFBWSxJQUFJbEIsTUFBTW5vQyxTQUFTSyxJQUFJO0lBQ3ZDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDMUI0b0MsVUFBVXhCLFdBQVcsQ0FBQ3BuQyxHQUFHMm9DLE1BQU0xcUIsV0FBVyxDQUFDamU7SUFDN0M7SUFDQSxPQUFPNG9DO0FBQ1Q7QUFFQSxJQUFJQyxXQUFXLFNBQVNBO0lBQ3RCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7SUFDdkIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTVpQjtJQUNsQixJQUFJLENBQUM2aUIsSUFBSSxHQUFHLElBQUk3aUI7SUFDaEIsSUFBSSxDQUFDOGlCLE1BQU0sR0FBRyxJQUFJeEIsTUFBTW5vQyxTQUFTSyxJQUFJO0lBQ3JDLElBQUksQ0FBQ3VwQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ3AxQixNQUFNLEdBQUc7SUFDZCxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJbVM7SUFDbEIsSUFBSSxDQUFDaWpCLGdCQUFnQixHQUFHO0lBQ3hCLElBQUk5Z0IsUUFBUTd1QixTQUFTLENBQUMsRUFBRTtJQUN4QixJQUFJMlgsa0JBQWtCM1gsU0FBUyxDQUFDLEVBQUU7SUFDbEMsSUFBSSxDQUFDMnZDLGdCQUFnQixHQUFHaDRCO0lBQ3hCLElBQUksQ0FBQ2k0QixhQUFhLENBQUMvZ0I7SUFDbkIsSUFBSSxDQUFDZ2hCLFdBQVc7QUFDbEI7QUFDQVYsU0FBU2p3QyxTQUFTLENBQUMyd0MsV0FBVyxHQUFHLFNBQVNBO0lBQ3RDLElBQUlyMkIsU0FBUyxJQUFJO0lBRW5CLElBQUksSUFBSSxDQUFDaTJCLEtBQUssS0FBSyxNQUFNO1FBQUUsT0FBTztJQUFLO0lBQ3ZDLElBQUl2a0IsUUFBUSxJQUFJanNCLE1BQU0sSUFBSSxDQUFDc3dDLElBQUksQ0FBQzE4QixJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDN0MsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lwQyxJQUFJLENBQUMxOEIsSUFBSSxJQUFJdk0sSUFBSztRQUN6QzRrQixLQUFLLENBQUM1a0IsRUFBRSxHQUFHa1QsT0FBTysxQixJQUFJLENBQUNqdEMsR0FBRyxDQUFDZ0U7SUFDN0I7SUFDQSxJQUFJLENBQUNtcEMsS0FBSyxHQUFHLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUNyMEIsZ0JBQWdCLENBQUM0UDtJQUNwRCxJQUFJLENBQUN3a0IsT0FBTyxHQUFHaHZCLGFBQWEyRixLQUFLLENBQUMsSUFBSSxDQUFDb3BCLEtBQUssQ0FBQzdZLGNBQWM7QUFDN0Q7QUFDQXVZLFNBQVNqd0MsU0FBUyxDQUFDNHdDLFVBQVUsR0FBRyxTQUFTQTtJQUN2QyxPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDWCxnQkFBZ0IsT0FBTztBQUM1QztBQUNBTSxTQUFTandDLFNBQVMsQ0FBQzB3QyxhQUFhLEdBQUcsU0FBU0EsY0FBZS9nQixLQUFLO0lBQzVELElBQUlyVixTQUFTLElBQUk7SUFFbkIsSUFBSSxDQUFDNDFCLFFBQVEsR0FBR3ZnQjtJQUNoQixJQUFJMlosS0FBSzNaO0lBQ1QsSUFBSWtoQixjQUFjO0lBQ2xCLEdBQUc7UUFDRCxJQUFJdkgsT0FBTyxNQUFNO1lBQUUsTUFBTSxJQUFJcUIsa0JBQWtCO1FBQTJCO1FBQzFFLElBQUlyQixHQUFHd0gsV0FBVyxPQUFPeDJCLFFBQVE7WUFBRSxNQUFNLElBQUlxd0Isa0JBQWtCLHlEQUF5RHJCLEdBQUcxMUIsYUFBYTtRQUFJO1FBQzVJMEcsT0FBTzgxQixNQUFNLENBQUNua0MsR0FBRyxDQUFDcTlCO1FBQ2xCLElBQUl5RyxRQUFRekcsR0FBR3lILFFBQVE7UUFDdkJyekIsT0FBT0UsTUFBTSxDQUFDbXlCLE1BQU16QixNQUFNO1FBQzFCaDBCLE9BQU8wMkIsVUFBVSxDQUFDakI7UUFDbEJ6MUIsT0FBTzIyQixTQUFTLENBQUMzSCxHQUFHSyxPQUFPLElBQUlMLEdBQUdnQixTQUFTLElBQUl1RztRQUMvQ0EsY0FBYztRQUNkdjJCLE9BQU80MkIsV0FBVyxDQUFDNUgsSUFBSWh2QjtRQUN2Qmd2QixLQUFLaHZCLE9BQU82MkIsT0FBTyxDQUFDN0g7SUFDdEIsUUFBU0EsT0FBTyxJQUFJLENBQUM0RyxRQUFRLEVBQUM7QUFDaEM7QUFDQUQsU0FBU2p3QyxTQUFTLENBQUNveEMsYUFBYSxHQUFHLFNBQVNBO0lBQzFDLE9BQU8sSUFBSSxDQUFDYixLQUFLO0FBQ25CO0FBQ0FOLFNBQVNqd0MsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBLGNBQWV4TSxDQUFDO0lBQzFELE9BQU8sSUFBSSxDQUFDaXBDLElBQUksQ0FBQ2p0QyxHQUFHLENBQUNnRTtBQUN2QjtBQUNBNm9DLFNBQVNqd0MsU0FBUyxDQUFDcXhDLG9CQUFvQixHQUFHLFNBQVNBO0lBQy9DLElBQUkvMkIsU0FBUyxJQUFJO0lBRW5CLElBQUksQ0FBQzYxQixjQUFjLEdBQUc7SUFDdEIsSUFBSTdHLEtBQUssSUFBSSxDQUFDNEcsUUFBUTtJQUN0QixHQUFHO1FBQ0QsSUFBSWpHLE9BQU9YLEdBQUdZLE9BQU87UUFDckIsSUFBSW9ILFNBQVNySCxLQUFLRyxRQUFRLEdBQUdtSCxpQkFBaUIsQ0FBQ2ozQjtRQUMvQyxJQUFJZzNCLFNBQVNoM0IsT0FBTzYxQixjQUFjLEVBQUU7WUFBRTcxQixPQUFPNjFCLGNBQWMsR0FBR21CO1FBQVE7UUFDdEVoSSxLQUFLaHZCLE9BQU82MkIsT0FBTyxDQUFDN0g7SUFDdEIsUUFBU0EsT0FBTyxJQUFJLENBQUM0RyxRQUFRLEVBQUM7SUFDOUIsSUFBSSxDQUFDQyxjQUFjLElBQUk7QUFDekI7QUFDQUYsU0FBU2p3QyxTQUFTLENBQUNpeEMsU0FBUyxHQUFHLFNBQVNBLFVBQVdPLElBQUksRUFBRWxILFNBQVMsRUFBRXVHLFdBQVc7SUFDM0UsSUFBSXYyQixTQUFTLElBQUk7SUFFbkIsSUFBSW0zQixVQUFVRCxLQUFLOVosY0FBYztJQUNqQyxJQUFJNFMsV0FBVztRQUNiLElBQUlvSCxhQUFhO1FBQ2pCLElBQUliLGFBQWE7WUFBRWEsYUFBYTtRQUFHO1FBQ25DLElBQUssSUFBSXRxQyxJQUFJc3FDLFlBQVl0cUMsSUFBSXFxQyxRQUFRaHhDLE1BQU0sRUFBRTJHLElBQUs7WUFDaERrVCxPQUFPKzFCLElBQUksQ0FBQ3BrQyxHQUFHLENBQUN3bEMsT0FBTyxDQUFDcnFDLEVBQUU7UUFDNUI7SUFDRixPQUFPO1FBQ0wsSUFBSXVxQyxlQUFlRixRQUFRaHhDLE1BQU0sR0FBRztRQUNwQyxJQUFJb3dDLGFBQWE7WUFBRWMsZUFBZUYsUUFBUWh4QyxNQUFNLEdBQUc7UUFBRztRQUN0RCxJQUFLLElBQUltbEIsTUFBTStyQixjQUFjL3JCLE9BQU8sR0FBR0EsTUFBTztZQUM1Q3RMLE9BQU8rMUIsSUFBSSxDQUFDcGtDLEdBQUcsQ0FBQ3dsQyxPQUFPLENBQUM3ckIsSUFBSTtRQUM5QjtJQUNGO0FBQ0Y7QUFDQXFxQixTQUFTandDLFNBQVMsQ0FBQzR4QyxNQUFNLEdBQUcsU0FBU0E7SUFDbkMsT0FBTyxJQUFJLENBQUNwQixPQUFPO0FBQ3JCO0FBQ0FQLFNBQVNqd0MsU0FBUyxDQUFDd3NDLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxJQUFJbEQsS0FBSyxJQUFJLENBQUM0RyxRQUFRO0lBQ3RCLEdBQUc7UUFDRDVHLEdBQUdLLE9BQU8sR0FBRzZDLFdBQVcsQ0FBQztRQUN6QmxELEtBQUtBLEdBQUc2SCxPQUFPO0lBQ2pCLFFBQVM3SCxPQUFPLElBQUksQ0FBQzRHLFFBQVEsRUFBQztBQUNoQztBQUNBRCxTQUFTandDLFNBQVMsQ0FBQzZ4QyxhQUFhLEdBQUcsU0FBU0EsY0FBZTc4QixDQUFDO0lBQzFELElBQUk0SCxRQUFRLElBQUksQ0FBQ3cwQixhQUFhO0lBQzlCLElBQUluOUIsTUFBTTJJLE1BQU0rTixtQkFBbUI7SUFDbkMsSUFBSSxDQUFDMVcsSUFBSWdFLFFBQVEsQ0FBQ2pELElBQUk7UUFBRSxPQUFPO0lBQU07SUFDckMsSUFBSSxDQUFDd00sYUFBYXVGLGFBQWEsQ0FBQy9SLEdBQUc0SCxNQUFNOGEsY0FBYyxLQUFLO1FBQUUsT0FBTztJQUFNO0lBQzNFLElBQUssSUFBSXR3QixJQUFJLElBQUksQ0FBQ2lVLE1BQU0sQ0FBQ2dRLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUNqRCxJQUFJcVcsT0FBT3g2QixFQUFFc2dCLElBQUk7UUFDakIsSUFBSWthLEtBQUtpUSxhQUFhLENBQUM3OEIsSUFBSTtZQUFFLE9BQU87UUFBTTtJQUM1QztJQUNBLE9BQU87QUFDVDtBQUNBaTdCLFNBQVNqd0MsU0FBUyxDQUFDOHhDLE9BQU8sR0FBRyxTQUFTQSxRQUFTcDFCLElBQUk7SUFDakQsSUFBSSxDQUFDckIsTUFBTSxDQUFDcFAsR0FBRyxDQUFDeVE7QUFDbEI7QUFDQXV6QixTQUFTandDLFNBQVMsQ0FBQyt4QyxPQUFPLEdBQUcsU0FBU0E7SUFDcEMsT0FBTyxJQUFJLENBQUMzMkIsTUFBTSxLQUFLO0FBQ3pCO0FBQ0E2MEIsU0FBU2p3QyxTQUFTLENBQUMrd0MsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sSUFBSSxDQUFDVCxNQUFNO0FBQ3BCO0FBQ0FMLFNBQVNqd0MsU0FBUyxDQUFDb3FDLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPLElBQUksQ0FBQ2dHLE1BQU07QUFDcEI7QUFDQUgsU0FBU2p3QyxTQUFTLENBQUNneUMsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDN0MsSUFBSSxJQUFJLENBQUM3QixjQUFjLEdBQUcsR0FBRztRQUFFLElBQUksQ0FBQ2tCLG9CQUFvQjtJQUFJO0lBQzVELE9BQU8sSUFBSSxDQUFDbEIsY0FBYztBQUM1QjtBQUNBRixTQUFTandDLFNBQVMsQ0FBQ2l5QyxRQUFRLEdBQUcsU0FBU0E7SUFDckMsT0FBTyxJQUFJLENBQUM3MkIsTUFBTTtBQUNwQjtBQUNBNjBCLFNBQVNqd0MsU0FBUyxDQUFDZ3hDLFVBQVUsR0FBRyxTQUFTQTtJQUN2QyxJQUFJbHdDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUl5eEMsVUFBVXB4QyxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUNrd0MsVUFBVSxDQUFDa0IsU0FBUztRQUN6QixJQUFJLENBQUNsQixVQUFVLENBQUNrQixTQUFTO0lBQzNCLE9BQU8sSUFBSXB4QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJMHhDLFlBQVlyeEMsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSW91QyxZQUFZcHVDLFNBQVMsQ0FBQyxFQUFFO1FBQzVCLElBQUkrdEMsTUFBTXNELFVBQVU5c0IsV0FBVyxDQUFDNnBCLFdBQVc1RyxTQUFTdmlCLEtBQUs7UUFDekQsSUFBSThvQixRQUFRbG9DLFNBQVNLLElBQUksRUFBRTtZQUFFLE9BQU87UUFBSztRQUN6QyxJQUFJLElBQUksQ0FBQ3NwQyxNQUFNLENBQUNqckIsV0FBVyxDQUFDNnBCLGVBQWV2b0MsU0FBU0ssSUFBSSxFQUFFO1lBQ3hELElBQUksQ0FBQ3NwQyxNQUFNLENBQUM5QixXQUFXLENBQUNVLFdBQVdMO1lBQ25DLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFDQW9CLFNBQVNqd0MsU0FBUyxDQUFDb3lDLFFBQVEsR0FBRyxTQUFTQSxTQUFVeDFCLEtBQUs7SUFDcEQsSUFBSSxDQUFDeEIsTUFBTSxHQUFHd0I7SUFDZCxJQUFJQSxVQUFVLE1BQU07UUFBRUEsTUFBTWsxQixPQUFPLENBQUMsSUFBSTtJQUFHO0FBQzdDO0FBQ0E3QixTQUFTandDLFNBQVMsQ0FBQ3F5QyxTQUFTLEdBQUcsU0FBU0EsVUFBVzU1QixlQUFlO0lBQzlELElBQUk2QixTQUFTLElBQUk7SUFFbkIsSUFBSWc0QixTQUFTLElBQUl2eUMsTUFBTSxJQUFJLENBQUNzYixNQUFNLENBQUMxSCxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDaEQsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lVLE1BQU0sQ0FBQzFILElBQUksSUFBSXZNLElBQUs7UUFDM0NrckMsTUFBTSxDQUFDbHJDLEVBQUUsR0FBR2tULE9BQU9lLE1BQU0sQ0FBQ2pZLEdBQUcsQ0FBQ2dFLEdBQUdncUMsYUFBYTtJQUNoRDtJQUNBLElBQUk5UixPQUFPN21CLGdCQUFnQmdFLGFBQWEsQ0FBQyxJQUFJLENBQUMyMEIsYUFBYSxJQUFJa0I7SUFDL0QsT0FBT2hUO0FBQ1Q7QUFDQTJRLFNBQVNqd0MsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sRUFBRTtBQUNYO0FBQ0FvdUMsU0FBU2p3QyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDckMsT0FBT211QztBQUNUO0FBRUEsSUFBSXNDLGtCQUFtQixTQUFVQyxXQUFXO0lBQzFDLFNBQVNEO1FBQ1AsSUFBSTVpQixRQUFRN3VCLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUkyWCxrQkFBa0IzWCxTQUFTLENBQUMsRUFBRTtRQUNsQzB4QyxZQUFZandDLElBQUksQ0FBQyxJQUFJLEVBQUVvdEIsT0FBT2xYO0lBQ2hDO0lBRUEsSUFBSys1QixhQUFjRCxnQkFBZ0I3dkMsU0FBUyxHQUFHOHZDO0lBQy9DRCxnQkFBZ0J2eUMsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFNnZDLGVBQWVBLFlBQVl4eUMsU0FBUztJQUMvRXV5QyxnQkFBZ0J2eUMsU0FBUyxDQUFDNEMsV0FBVyxHQUFHMnZDO0lBQ3hDQSxnQkFBZ0J2eUMsU0FBUyxDQUFDa3hDLFdBQVcsR0FBRyxTQUFTQSxZQUFhNUgsRUFBRSxFQUFFbUosRUFBRTtRQUNsRW5KLEdBQUdvSixjQUFjLENBQUNEO0lBQ3BCO0lBQ0FGLGdCQUFnQnZ5QyxTQUFTLENBQUNteEMsT0FBTyxHQUFHLFNBQVNBLFFBQVM3SCxFQUFFO1FBQ3RELE9BQU9BLEdBQUdxSixVQUFVO0lBQ3RCO0lBQ0FKLGdCQUFnQnZ5QyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDL0MsT0FBTyxFQUFFO0lBQ1g7SUFDQTB3QyxnQkFBZ0J2eUMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQzVDLE9BQU95d0M7SUFDVDtJQUVBLE9BQU9BO0FBQ1QsRUFBRXRDO0FBRUYsSUFBSTJDLGtCQUFtQixTQUFVSixXQUFXO0lBQzFDLFNBQVNJO1FBQ1AsSUFBSWpqQixRQUFRN3VCLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUkyWCxrQkFBa0IzWCxTQUFTLENBQUMsRUFBRTtRQUNsQzB4QyxZQUFZandDLElBQUksQ0FBQyxJQUFJLEVBQUVvdEIsT0FBT2xYO0lBQ2hDO0lBRUEsSUFBSys1QixhQUFjSSxnQkFBZ0Jsd0MsU0FBUyxHQUFHOHZDO0lBQy9DSSxnQkFBZ0I1eUMsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFNnZDLGVBQWVBLFlBQVl4eUMsU0FBUztJQUMvRTR5QyxnQkFBZ0I1eUMsU0FBUyxDQUFDNEMsV0FBVyxHQUFHZ3dDO0lBQ3hDQSxnQkFBZ0I1eUMsU0FBUyxDQUFDNnlDLGlCQUFpQixHQUFHLFNBQVNBO1FBQ3JELElBQUl2NEIsU0FBUyxJQUFJO1FBRWpCLElBQUl3NEIsZUFBZSxJQUFJdGxCO1FBQ3ZCLElBQUk4YixLQUFLLElBQUksQ0FBQzRHLFFBQVE7UUFDdEIsR0FBRztZQUNELElBQUk1RyxHQUFHeUosY0FBYyxPQUFPLE1BQU07Z0JBQ2hDLElBQUlDLFFBQVEsSUFBSVQsZ0JBQWdCakosSUFBSWh2QixPQUFPbTJCLGdCQUFnQjtnQkFDM0RxQyxhQUFhN21DLEdBQUcsQ0FBQyttQztZQUNuQjtZQUNBMUosS0FBS0EsR0FBRzZILE9BQU87UUFDakIsUUFBUzdILE9BQU8sSUFBSSxDQUFDNEcsUUFBUSxFQUFDO1FBQzlCLE9BQU80QztJQUNUO0lBQ0FGLGdCQUFnQjV5QyxTQUFTLENBQUNreEMsV0FBVyxHQUFHLFNBQVNBLFlBQWE1SCxFQUFFLEVBQUVtSixFQUFFO1FBQ2xFbkosR0FBRzRILFdBQVcsQ0FBQ3VCO0lBQ2pCO0lBQ0FHLGdCQUFnQjV5QyxTQUFTLENBQUNpekMsb0NBQW9DLEdBQUcsU0FBU0E7UUFDeEUsSUFBSTM0QixTQUFTLElBQUk7UUFFakIsSUFBSWd2QixLQUFLLElBQUksQ0FBQzRHLFFBQVE7UUFDdEIsR0FBRztZQUNELElBQUlqRyxPQUFPWCxHQUFHWSxPQUFPO1lBQ3JCRCxLQUFLRyxRQUFRLEdBQUc4SSx3QkFBd0IsQ0FBQzU0QjtZQUN6Q2d2QixLQUFLQSxHQUFHNkgsT0FBTztRQUNqQixRQUFTN0gsT0FBTyxJQUFJLENBQUM0RyxRQUFRLEVBQUM7SUFDaEM7SUFDQTBDLGdCQUFnQjV5QyxTQUFTLENBQUNteEMsT0FBTyxHQUFHLFNBQVNBLFFBQVM3SCxFQUFFO1FBQ3RELE9BQU9BLEdBQUc2SCxPQUFPO0lBQ25CO0lBQ0F5QixnQkFBZ0I1eUMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQy9DLE9BQU8sRUFBRTtJQUNYO0lBQ0Erd0MsZ0JBQWdCNXlDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUM1QyxPQUFPOHdDO0lBQ1Q7SUFFQSxPQUFPQTtBQUNULEVBQUUzQztBQUVGLElBQUlrRCxpQkFBaUIsU0FBU0E7SUFDNUIsSUFBSSxDQUFDN0MsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDOEMsV0FBVyxHQUFHO0lBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3JCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUl6eUMsVUFBVUwsTUFBTSxLQUFLLEdBQUcsQ0FBQyxPQUFPLElBQUlLLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzlELElBQUlzdkMsUUFBUWp2QyxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUN3dkMsTUFBTSxHQUFHUDtJQUNoQjtBQUNGO0FBQ0FvRCxlQUFlbnpDLFNBQVMsQ0FBQ3lyQyxVQUFVLEdBQUcsU0FBU0EsV0FBWUksU0FBUztJQUNsRSxJQUFJLENBQUMwSCxVQUFVLEdBQUcxSDtBQUNwQjtBQUNBc0gsZUFBZW56QyxTQUFTLENBQUN3c0MsV0FBVyxHQUFHLFNBQVNBLFlBQWFnSCxVQUFVO0lBQ3JFLElBQUksQ0FBQ0osV0FBVyxHQUFHSTtBQUNyQjtBQUNBTCxlQUFlbnpDLFNBQVMsQ0FBQ3l6QyxTQUFTLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxJQUFJLENBQUNKLFVBQVU7QUFDeEI7QUFDQUYsZUFBZW56QyxTQUFTLENBQUMwekMsWUFBWSxHQUFHLFNBQVNBO0lBQy9DLE9BQU8sSUFBSSxDQUFDSixhQUFhO0FBQzNCO0FBQ0FILGVBQWVuekMsU0FBUyxDQUFDMnpDLFFBQVEsR0FBRyxTQUFTQSxTQUFVNUQsS0FBSztJQUMxRCxJQUFJLENBQUNPLE1BQU0sR0FBR1A7QUFDaEI7QUFDQW9ELGVBQWVuekMsU0FBUyxDQUFDK3dDLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQ1QsTUFBTTtBQUNwQjtBQUNBNkMsZUFBZW56QyxTQUFTLENBQUM0ekMsVUFBVSxHQUFHLFNBQVNBLFdBQVlILFNBQVM7SUFDbEUsSUFBSSxDQUFDSixVQUFVLEdBQUdJO0lBQ2xCLElBQUksQ0FBQ0gsYUFBYSxHQUFHO0FBQ3ZCO0FBQ0FILGVBQWVuekMsU0FBUyxDQUFDNnpDLFFBQVEsR0FBRyxTQUFTQSxTQUFVQyxFQUFFO0lBQ3ZEcDJCLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUMweUIsTUFBTSxDQUFDWCxnQkFBZ0IsTUFBTSxHQUFHO0lBQ25ELElBQUksQ0FBQ29FLFNBQVMsQ0FBQ0Q7QUFDakI7QUFDQVgsZUFBZW56QyxTQUFTLENBQUN3ekMsVUFBVSxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sSUFBSSxDQUFDSixXQUFXO0FBQ3pCO0FBQ0FELGVBQWVuekMsU0FBUyxDQUFDNnJDLFNBQVMsR0FBRyxTQUFTQTtJQUM1QyxPQUFPLElBQUksQ0FBQzBILFVBQVU7QUFDeEI7QUFDQUosZUFBZW56QyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDOUMsT0FBTyxFQUFFO0FBQ1g7QUFDQXN4QyxlQUFlbnpDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPcXhDO0FBQ1Q7QUFFQSxJQUFJYSxPQUFRLFNBQVVDLGlCQUFpQjtJQUNyQyxTQUFTRDtRQUNQQyxrQkFBa0IxeEMsSUFBSSxDQUFDLElBQUk7UUFDM0IsSUFBSSxDQUFDMnhDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzlELE1BQU0sR0FBRztRQUNkLElBQUlwa0IsUUFBUWxyQixTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJcXpDLFFBQVFyekMsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSSxDQUFDb3pDLE1BQU0sR0FBR2xvQjtRQUNkLElBQUksQ0FBQ29rQixNQUFNLEdBQUcrRDtRQUNkLElBQUksQ0FBQzdELE1BQU0sR0FBRyxJQUFJeEIsTUFBTSxHQUFHbm9DLFNBQVNLLElBQUk7SUFDMUM7SUFFQSxJQUFLaXRDLG1CQUFvQkQsS0FBS3R4QyxTQUFTLEdBQUd1eEM7SUFDMUNELEtBQUtoMEMsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFc3hDLHFCQUFxQkEsa0JBQWtCajBDLFNBQVM7SUFDaEZnMEMsS0FBS2gwQyxTQUFTLENBQUM0QyxXQUFXLEdBQUdveEM7SUFDN0JBLEtBQUtoMEMsU0FBUyxDQUFDbzBDLHNCQUFzQixHQUFHLFNBQVNBO1FBQy9DLElBQUssSUFBSTFaLEtBQUssSUFBSSxDQUFDMFAsUUFBUSxHQUFHQSxRQUFRLEdBQUcvZSxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1lBQ2xFLElBQUkrZCxLQUFLNU8sR0FBR2hULElBQUk7WUFDaEIsSUFBSTRoQixHQUFHSyxPQUFPLEdBQUc2SixVQUFVLElBQUk7Z0JBQUUsT0FBTztZQUFLO1FBQy9DO1FBQ0EsT0FBTztJQUNUO0lBQ0FRLEtBQUtoMEMsU0FBUyxDQUFDNHdDLFVBQVUsR0FBRyxTQUFTQTtRQUNuQyxPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDWCxnQkFBZ0IsT0FBTztJQUM1QztJQUNBcUUsS0FBS2gwQyxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7UUFDdEMsT0FBTyxJQUFJLENBQUNzZ0MsTUFBTTtJQUNwQjtJQUNBRixLQUFLaDBDLFNBQVMsQ0FBQ3EwQyxLQUFLLEdBQUcsU0FBU0EsTUFBTzN4QixHQUFHO1FBQ3hDQSxJQUFJQyxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUN1eEIsTUFBTSxHQUFHLFdBQVcsSUFBSSxDQUFDNUQsTUFBTTtJQUM1RDtJQUNBMEQsS0FBS2gwQyxTQUFTLENBQUMrekMsU0FBUyxHQUFHLFNBQVNBLFVBQVdELEVBQUUsR0FBRztJQUNwREUsS0FBS2gwQyxTQUFTLENBQUNzMEMscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXVCQyxNQUFNLEVBQUVDLFFBQVE7UUFDckYsSUFBSTNGLE1BQU1sb0MsU0FBU0ssSUFBSTtRQUN2QjZuQyxNQUFNLElBQUksQ0FBQ3lCLE1BQU0sQ0FBQ2pyQixXQUFXLENBQUNtdkI7UUFDOUIsSUFBSSxDQUFDRCxPQUFPMzlCLE1BQU0sQ0FBQzQ5QixXQUFXO1lBQzVCLElBQUlDLE9BQU9GLE9BQU9sdkIsV0FBVyxDQUFDbXZCO1lBQzlCLElBQUkzRixRQUFRbG9DLFNBQVNHLFFBQVEsRUFBRTtnQkFBRStuQyxNQUFNNEY7WUFBTTtRQUMvQztRQUNBLE9BQU81RjtJQUNUO0lBQ0FtRixLQUFLaDBDLFNBQVMsQ0FBQzJ6QyxRQUFRLEdBQUcsU0FBU0E7UUFDakMsSUFBSTd5QyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJaTBDLFdBQVc1ekMsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSTZ6QyxhQUFhN3pDLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLElBQUksSUFBSSxDQUFDd3ZDLE1BQU0sS0FBSyxNQUFNO2dCQUN4QixJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJeEIsTUFBTTRGLFVBQVVDO1lBQ3BDLE9BQU87Z0JBQUUsSUFBSSxDQUFDckUsTUFBTSxDQUFDOUIsV0FBVyxDQUFDa0csVUFBVUM7WUFBYTtRQUMxRCxPQUFPO1lBQUUsT0FBT1Ysa0JBQWtCajBDLFNBQVMsQ0FBQzJ6QyxRQUFRLENBQUNwNkIsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDOUU7SUFDQWt6QyxLQUFLaDBDLFNBQVMsQ0FBQ29xQyxRQUFRLEdBQUcsU0FBU0E7UUFDakMsT0FBTyxJQUFJLENBQUNnRyxNQUFNO0lBQ3BCO0lBQ0E0RCxLQUFLaDBDLFNBQVMsQ0FBQ2d4QyxVQUFVLEdBQUcsU0FBU0E7UUFDbkMsSUFBSTEyQixTQUFTLElBQUk7UUFFakIsSUFBSXhaLFNBQVMsQ0FBQyxFQUFFLFlBQVlrekMsTUFBTTtZQUNoQyxJQUFJaHhDLElBQUlsQyxTQUFTLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUNrd0MsVUFBVSxDQUFDaHVDLEVBQUVzdEMsTUFBTTtRQUMxQixPQUFPLElBQUl4dkMsU0FBUyxDQUFDLEVBQUUsWUFBWWd1QyxPQUFPO1lBQ3hDLElBQUl5RixTQUFTenpDLFNBQVMsQ0FBQyxFQUFFO1lBQ3pCLElBQUssSUFBSXNHLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQixJQUFJeW5DLE1BQU12MEIsT0FBT2c2QixxQkFBcUIsQ0FBQ0MsUUFBUW50QztnQkFDL0MsSUFBSXd0QyxVQUFVdDZCLE9BQU9nMkIsTUFBTSxDQUFDanJCLFdBQVcsQ0FBQ2plO2dCQUN4QyxJQUFJd3RDLFlBQVlqdUMsU0FBU0ssSUFBSSxFQUFFO29CQUFFc1QsT0FBT2cyQixNQUFNLENBQUM5QixXQUFXLENBQUNwbkMsR0FBR3luQztnQkFBTTtZQUN0RTtRQUNGO0lBQ0Y7SUFDQW1GLEtBQUtoMEMsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBLElBQUtwRCxDQUFDO1FBQ2xDLElBQUksQ0FBQ3VuQyxNQUFNLENBQUN5RSxNQUFNLENBQUNoc0M7UUFDbkJBLEVBQUVpc0MsT0FBTyxDQUFDLElBQUk7SUFDaEI7SUFDQWQsS0FBS2gwQyxTQUFTLENBQUMrMEMsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCTCxRQUFRO1FBQ25FLElBQUksSUFBSSxDQUFDcEUsTUFBTSxLQUFLLE1BQU07WUFBRSxPQUFPO1FBQUs7UUFDeEMsSUFBSXpCLE1BQU1sb0MsU0FBU0ssSUFBSTtRQUN2QixJQUFJLElBQUksQ0FBQ3NwQyxNQUFNLEtBQUssTUFBTTtZQUFFekIsTUFBTSxJQUFJLENBQUN5QixNQUFNLENBQUNqckIsV0FBVyxDQUFDcXZCO1FBQVc7UUFDckUsSUFBSTFHLFNBQVM7UUFDYixPQUFRYTtZQUNOLEtBQUtsb0MsU0FBU0csUUFBUTtnQkFDcEJrbkMsU0FBU3JuQyxTQUFTRSxRQUFRO2dCQUMxQjtZQUNGLEtBQUtGLFNBQVNFLFFBQVE7Z0JBQ3BCbW5DLFNBQVNybkMsU0FBU0csUUFBUTtnQkFDMUI7WUFDRjtnQkFDRWtuQyxTQUFTcm5DLFNBQVNHLFFBQVE7Z0JBQzFCO1FBQ0o7UUFDQSxJQUFJLENBQUN3cEMsTUFBTSxDQUFDOUIsV0FBVyxDQUFDa0csVUFBVTFHO0lBQ3BDO0lBQ0FnRyxLQUFLaDBDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUNwQyxPQUFPLEVBQUU7SUFDWDtJQUNBbXlDLEtBQUtoMEMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ2pDLE9BQU9reUM7SUFDVDtJQUVBLE9BQU9BO0FBQ1QsRUFBRWI7QUFFRixJQUFJNkIsVUFBVSxTQUFTQTtJQUNyQixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJemdCO0lBQ25CLElBQUksQ0FBQzBnQixRQUFRLEdBQUc7SUFDaEIsSUFBSUEsV0FBV3AwQyxTQUFTLENBQUMsRUFBRTtJQUMzQixJQUFJLENBQUNvMEMsUUFBUSxHQUFHQTtBQUNsQjtBQUNBRixRQUFRaDFDLFNBQVMsQ0FBQ20xQyxJQUFJLEdBQUcsU0FBU0EsS0FBTW5wQixLQUFLO0lBQzNDLE9BQU8sSUFBSSxDQUFDaXBCLE9BQU8sQ0FBQzd4QyxHQUFHLENBQUM0b0I7QUFDMUI7QUFDQWdwQixRQUFRaDFDLFNBQVMsQ0FBQ28xQyxPQUFPLEdBQUcsU0FBU0E7SUFDbkMsSUFBSXQwQyxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtRQUN0QyxJQUFJc29CLFFBQVFsckIsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSW1wQyxPQUFPLElBQUksQ0FBQ2dMLE9BQU8sQ0FBQzd4QyxHQUFHLENBQUM0b0I7UUFDNUIsSUFBSWllLFNBQVMsTUFBTTtZQUNqQkEsT0FBTyxJQUFJLENBQUNpTCxRQUFRLENBQUNHLFVBQVUsQ0FBQ3JwQjtZQUNoQyxJQUFJLENBQUNpcEIsT0FBTyxDQUFDL2hCLEdBQUcsQ0FBQ2xILE9BQU9pZTtRQUMxQjtRQUNBLE9BQU9BO0lBQ1QsT0FBTyxJQUFJbnBDLFNBQVMsQ0FBQyxFQUFFLFlBQVlrekMsTUFBTTtRQUN2QyxJQUFJaHhDLElBQUlsQyxTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJdzBDLFNBQVMsSUFBSSxDQUFDTCxPQUFPLENBQUM3eEMsR0FBRyxDQUFDSixFQUFFNFEsYUFBYTtRQUM3QyxJQUFJMGhDLFdBQVcsTUFBTTtZQUNuQixJQUFJLENBQUNMLE9BQU8sQ0FBQy9oQixHQUFHLENBQUNsd0IsRUFBRTRRLGFBQWEsSUFBSTVRO1lBQ3BDLE9BQU9BO1FBQ1Q7UUFDQXN5QyxPQUFPdEUsVUFBVSxDQUFDaHVDO1FBQ2xCLE9BQU9zeUM7SUFDVDtBQUNGO0FBQ0FOLFFBQVFoMUMsU0FBUyxDQUFDcTBDLEtBQUssR0FBRyxTQUFTQSxNQUFPM3hCLEdBQUc7SUFDM0MsSUFBSyxJQUFJZ1ksS0FBSyxJQUFJLENBQUNyUCxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQzVDLElBQUl2b0IsSUFBSTAzQixHQUFHaFQsSUFBSTtRQUNmMWtCLEVBQUVxeEMsS0FBSyxDQUFDM3hCO0lBQ1Y7QUFDRjtBQUNBc3lCLFFBQVFoMUMsU0FBUyxDQUFDcXJCLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxPQUFPLElBQUksQ0FBQzRwQixPQUFPLENBQUM5aEIsTUFBTSxHQUFHOUgsUUFBUTtBQUN2QztBQUNBMnBCLFFBQVFoMUMsU0FBUyxDQUFDbXpCLE1BQU0sR0FBRyxTQUFTQTtJQUNsQyxPQUFPLElBQUksQ0FBQzhoQixPQUFPLENBQUM5aEIsTUFBTTtBQUM1QjtBQUNBNmhCLFFBQVFoMUMsU0FBUyxDQUFDdTFDLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQnJHLFNBQVM7SUFDdkUsSUFBSXNHLFdBQVcsSUFBSWhvQjtJQUNuQixJQUFLLElBQUlwbUIsSUFBSSxJQUFJLENBQUNpa0IsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzFDLElBQUkwZSxPQUFPN2lDLEVBQUVzZ0IsSUFBSTtRQUNqQixJQUFJdWlCLEtBQUs4RyxRQUFRLEdBQUcxckIsV0FBVyxDQUFDNnBCLGVBQWV2b0MsU0FBU0csUUFBUSxFQUFFO1lBQUUwdUMsU0FBU3ZwQyxHQUFHLENBQUNnK0I7UUFBTztJQUMxRjtJQUNBLE9BQU91TDtBQUNUO0FBQ0FSLFFBQVFoMUMsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBLElBQUtwRCxDQUFDO0lBQ3JDLElBQUltTSxJQUFJbk0sRUFBRStLLGFBQWE7SUFDdkIsSUFBSTVRLElBQUksSUFBSSxDQUFDb3lDLE9BQU8sQ0FBQ3BnQztJQUNyQmhTLEVBQUVpSixHQUFHLENBQUNwRDtBQUNSO0FBQ0Ftc0MsUUFBUWgxQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxFQUFFO0FBQ1g7QUFDQW16QyxRQUFRaDFDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxPQUFPa3pDO0FBQ1Q7QUFFQSxJQUFJUyxXQUFXLFNBQVNBLFlBQWE7QUFFckMsSUFBSUMscUJBQXFCO0lBQUVDLElBQUk7UUFBRXgxQyxjQUFjO0lBQUs7SUFBRXkxQyxJQUFJO1FBQUV6MUMsY0FBYztJQUFLO0lBQUUwMUMsSUFBSTtRQUFFMTFDLGNBQWM7SUFBSztJQUFFMjFDLElBQUk7UUFBRTMxQyxjQUFjO0lBQUs7QUFBRTtBQUV2SXMxQyxTQUFTejFDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxPQUFPLEVBQUU7QUFDWDtBQUNBNHpDLFNBQVN6MUMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8yekM7QUFDVDtBQUNBQSxTQUFTTSxVQUFVLEdBQUcsU0FBU0EsV0FBWUMsSUFBSTtJQUM3QyxPQUFPQSxTQUFTUCxTQUFTRSxFQUFFLElBQUlLLFNBQVNQLFNBQVNHLEVBQUU7QUFDckQ7QUFDQUgsU0FBU1EsVUFBVSxHQUFHLFNBQVNBLFdBQVlDLEtBQUssRUFBRUMsS0FBSztJQUNyRCxJQUFJRCxVQUFVQyxPQUFPO1FBQUUsT0FBTztJQUFNO0lBQ3BDLElBQUlDLE9BQU8sQ0FBQ0YsUUFBUUMsUUFBUSxLQUFLO0lBQ2pDLElBQUlDLFNBQVMsR0FBRztRQUFFLE9BQU87SUFBSztJQUM5QixPQUFPO0FBQ1Q7QUFDQVgsU0FBU1ksZUFBZSxHQUFHLFNBQVNBLGdCQUFpQkgsS0FBSyxFQUFFQyxLQUFLO0lBQy9ELElBQUlELFVBQVVDLE9BQU87UUFBRSxPQUFPRDtJQUFNO0lBQ3BDLElBQUlFLE9BQU8sQ0FBQ0YsUUFBUUMsUUFBUSxLQUFLO0lBQ2pDLElBQUlDLFNBQVMsR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzVCLElBQUl4MUMsTUFBTXMxQyxRQUFRQyxRQUFRRCxRQUFRQztJQUNsQyxJQUFJeDFDLE1BQU11MUMsUUFBUUMsUUFBUUQsUUFBUUM7SUFDbEMsSUFBSXYxQyxRQUFRLEtBQUtELFFBQVEsR0FBRztRQUFFLE9BQU87SUFBRTtJQUN2QyxPQUFPQztBQUNUO0FBQ0E2MEMsU0FBU2EsYUFBYSxHQUFHLFNBQVNBLGNBQWVOLElBQUksRUFBRU8sU0FBUztJQUM5RCxJQUFJQSxjQUFjZCxTQUFTSyxFQUFFLEVBQUU7UUFDN0IsT0FBT0UsU0FBU1AsU0FBU0ssRUFBRSxJQUFJRSxTQUFTUCxTQUFTSSxFQUFFO0lBQ3JEO0lBQ0EsT0FBT0csU0FBU08sYUFBYVAsU0FBU08sWUFBWTtBQUNwRDtBQUNBZCxTQUFTZSxRQUFRLEdBQUcsU0FBU0E7SUFDM0IsSUFBSSxPQUFPMTFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBWSxPQUFPQSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7UUFDeEUsSUFBSXFFLEtBQUtyRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJc0UsS0FBS3RFLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlxRSxPQUFPLE9BQU9DLE9BQU8sS0FBSztZQUFFLE1BQU0sSUFBSWhELHlCQUF5Qiw2Q0FBNkMrQyxLQUFLLE9BQU9DLEtBQUs7UUFBTTtRQUN2SSxJQUFJRCxNQUFNLEtBQUs7WUFDYixJQUFJQyxNQUFNLEtBQUs7Z0JBQUUsT0FBT3F3QyxTQUFTRSxFQUFFO1lBQUUsT0FBTztnQkFBRSxPQUFPRixTQUFTSyxFQUFFO1lBQUM7UUFDbkUsT0FBTztZQUNMLElBQUkxd0MsTUFBTSxLQUFLO2dCQUFFLE9BQU9xd0MsU0FBU0csRUFBRTtZQUFFLE9BQU87Z0JBQUUsT0FBT0gsU0FBU0ksRUFBRTtZQUFDO1FBQ25FO0lBQ0YsT0FBTyxJQUFJLzBDLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxjQUFjNUMsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7UUFDbkYsSUFBSTRaLEtBQUt4YyxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJeVEsS0FBS3pRLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl5USxHQUFHN1AsQ0FBQyxLQUFLNGIsR0FBRzViLENBQUMsSUFBSTZQLEdBQUc1TixDQUFDLEtBQUsyWixHQUFHM1osQ0FBQyxFQUFFO1lBQUUsTUFBTSxJQUFJdkIseUJBQXlCLDBEQUEwRGtiO1FBQUk7UUFDdkksSUFBSS9MLEdBQUc3UCxDQUFDLElBQUk0YixHQUFHNWIsQ0FBQyxFQUFFO1lBQ2hCLElBQUk2UCxHQUFHNU4sQ0FBQyxJQUFJMlosR0FBRzNaLENBQUMsRUFBRTtnQkFBRSxPQUFPOHhDLFNBQVNFLEVBQUU7WUFBRSxPQUFPO2dCQUFFLE9BQU9GLFNBQVNLLEVBQUU7WUFBQztRQUN0RSxPQUFPO1lBQ0wsSUFBSXZrQyxHQUFHNU4sQ0FBQyxJQUFJMlosR0FBRzNaLENBQUMsRUFBRTtnQkFBRSxPQUFPOHhDLFNBQVNHLEVBQUU7WUFBRSxPQUFPO2dCQUFFLE9BQU9ILFNBQVNJLEVBQUU7WUFBQztRQUN0RTtJQUNGO0FBQ0Y7QUFDQUgsbUJBQW1CQyxFQUFFLENBQUN2eUMsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ25Ec3lDLG1CQUFtQkUsRUFBRSxDQUFDeHlDLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUNuRHN5QyxtQkFBbUJHLEVBQUUsQ0FBQ3p5QyxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDbkRzeUMsbUJBQW1CSSxFQUFFLENBQUMxeUMsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBRW5EbkQsT0FBT29ELGdCQUFnQixDQUFFb3lDLFVBQVVDO0FBRW5DLElBQUllLFVBQVUsU0FBU0E7SUFDckIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNwRyxNQUFNLEdBQUc7SUFDZCxJQUFJLENBQUNxRyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUlsMkMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSt3QyxPQUFPMXdDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzQxQyxLQUFLLEdBQUdsRjtJQUNmLE9BQU8sSUFBSTF3QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJdzJDLFNBQVNuMkMsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSXdjLEtBQUt4YyxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJeVEsS0FBS3pRLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlpdkMsUUFBUTtRQUNaLElBQUksQ0FBQzJHLEtBQUssR0FBR087UUFDYixJQUFJLENBQUN6dEMsSUFBSSxDQUFDOFQsSUFBSS9MO1FBQ2QsSUFBSSxDQUFDKytCLE1BQU0sR0FBR1A7SUFDaEIsT0FBTyxJQUFJanZDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUl5MkMsU0FBU3AyQyxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJcTJDLE9BQU9yMkMsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXFVLE9BQU9yVSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJczJDLFVBQVV0MkMsU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSSxDQUFDNDFDLEtBQUssR0FBR1E7UUFDYixJQUFJLENBQUMxdEMsSUFBSSxDQUFDMnRDLE1BQU1oaUM7UUFDaEIsSUFBSSxDQUFDbTdCLE1BQU0sR0FBRzhHO0lBQ2hCO0FBQ0Y7QUFDQVgsUUFBUXoyQyxTQUFTLENBQUNxM0MsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCeHVDLENBQUM7SUFDL0QsSUFBSSxJQUFJLENBQUNpdUMsR0FBRyxLQUFLanVDLEVBQUVpdUMsR0FBRyxJQUFJLElBQUksQ0FBQ0MsR0FBRyxLQUFLbHVDLEVBQUVrdUMsR0FBRyxFQUFFO1FBQUUsT0FBTztJQUFFO0lBQ3pELElBQUksSUFBSSxDQUFDQyxTQUFTLEdBQUdudUMsRUFBRW11QyxTQUFTLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDN0MsSUFBSSxJQUFJLENBQUNBLFNBQVMsR0FBR251QyxFQUFFbXVDLFNBQVMsRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzlDLE9BQU94MUIsYUFBYW9HLGtCQUFrQixDQUFDL2UsRUFBRSt0QyxHQUFHLEVBQUUvdEMsRUFBRWd1QyxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHO0FBQy9EO0FBQ0FKLFFBQVF6MkMsU0FBUyxDQUFDczNDLEtBQUssR0FBRyxTQUFTQTtJQUNqQyxPQUFPLElBQUksQ0FBQ1AsR0FBRztBQUNqQjtBQUNBTixRQUFRejJDLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPLElBQUksQ0FBQ2dqQyxHQUFHO0FBQ2pCO0FBQ0FILFFBQVF6MkMsU0FBUyxDQUFDODBDLE9BQU8sR0FBRyxTQUFTQSxRQUFTN0ssSUFBSTtJQUNoRCxJQUFJLENBQUMwTSxLQUFLLEdBQUcxTTtBQUNmO0FBQ0F3TSxRQUFRejJDLFNBQVMsQ0FBQ3EwQyxLQUFLLEdBQUcsU0FBU0EsTUFBTzN4QixHQUFHO0lBQzNDLElBQUk2MEIsUUFBUTcyQyxLQUFLODJDLEtBQUssQ0FBQyxJQUFJLENBQUNULEdBQUcsRUFBRSxJQUFJLENBQUNELEdBQUc7SUFDekMsSUFBSVcsWUFBWSxJQUFJLENBQUMzMUMsUUFBUSxHQUFHMi9CLE9BQU87SUFDdkMsSUFBSWlXLGFBQWFELFVBQVVFLFdBQVcsQ0FBQztJQUN2QyxJQUFJbjFDLE9BQU9pMUMsVUFBVXpuQyxTQUFTLENBQUMwbkMsYUFBYTtJQUM1Q2gxQixJQUFJMnhCLEtBQUssQ0FBQyxPQUFPN3hDLE9BQU8sT0FBTyxJQUFJLENBQUNvMEMsR0FBRyxHQUFHLFFBQVEsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUNHLFNBQVMsR0FBRyxNQUFNTyxRQUFRLFFBQVEsSUFBSSxDQUFDakgsTUFBTTtBQUN2SDtBQUNBbUcsUUFBUXoyQyxTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV21xQixHQUFHO0lBQ25ELElBQUlubUIsSUFBSW1tQjtJQUNSLE9BQU8sSUFBSSxDQUFDcW9CLGdCQUFnQixDQUFDeHVDO0FBQy9CO0FBQ0E0dEMsUUFBUXoyQyxTQUFTLENBQUM0M0MscUJBQXFCLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxJQUFJLENBQUNmLEdBQUc7QUFDakI7QUFDQUosUUFBUXoyQyxTQUFTLENBQUM2M0MsS0FBSyxHQUFHLFNBQVNBO0lBQ2pDLE9BQU8sSUFBSSxDQUFDZixHQUFHO0FBQ2pCO0FBQ0FMLFFBQVF6MkMsU0FBUyxDQUFDK3dDLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxPQUFPLElBQUksQ0FBQ1QsTUFBTTtBQUNwQjtBQUNBbUcsUUFBUXoyQyxTQUFTLENBQUMycEMsT0FBTyxHQUFHLFNBQVNBO0lBQ25DLE9BQU8sSUFBSSxDQUFDK00sS0FBSztBQUNuQjtBQUNBRCxRQUFRejJDLFNBQVMsQ0FBQzgzQyxXQUFXLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxJQUFJLENBQUNkLFNBQVM7QUFDdkI7QUFDQVAsUUFBUXoyQyxTQUFTLENBQUNrcUMsT0FBTyxHQUFHLFNBQVNBO0lBQ25DLE9BQU8sSUFBSSxDQUFDeU0sS0FBSztBQUNuQjtBQUNBRixRQUFRejJDLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxJQUFJc3lDLFFBQVE3MkMsS0FBSzgyQyxLQUFLLENBQUMsSUFBSSxDQUFDVCxHQUFHLEVBQUUsSUFBSSxDQUFDRCxHQUFHO0lBQ3pDLElBQUlXLFlBQVksSUFBSSxDQUFDMzFDLFFBQVEsR0FBRzIvQixPQUFPO0lBQ3ZDLElBQUlpVyxhQUFhRCxVQUFVRSxXQUFXLENBQUM7SUFDdkMsSUFBSW4xQyxPQUFPaTFDLFVBQVV6bkMsU0FBUyxDQUFDMG5DLGFBQWE7SUFDNUMsT0FBTyxPQUFPbDFDLE9BQU8sT0FBTyxJQUFJLENBQUNvMEMsR0FBRyxHQUFHLFFBQVEsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUNHLFNBQVMsR0FBRyxNQUFNTyxRQUFRLFFBQVEsSUFBSSxDQUFDakgsTUFBTTtBQUNwSDtBQUNBbUcsUUFBUXoyQyxTQUFTLENBQUMrM0MsWUFBWSxHQUFHLFNBQVNBLGFBQWNDLGdCQUFnQixHQUFHO0FBQzNFdkIsUUFBUXoyQyxTQUFTLENBQUN3SixJQUFJLEdBQUcsU0FBU0EsS0FBTThULEVBQUUsRUFBRS9MLEVBQUU7SUFDNUMsSUFBSSxDQUFDcWxDLEdBQUcsR0FBR3Q1QjtJQUNYLElBQUksQ0FBQ3U1QixHQUFHLEdBQUd0bEM7SUFDWCxJQUFJLENBQUN1bEMsR0FBRyxHQUFHdmxDLEdBQUc3UCxDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQztJQUN0QixJQUFJLENBQUNxMUMsR0FBRyxHQUFHeGxDLEdBQUc1TixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQztJQUN0QixJQUFJLENBQUNxekMsU0FBUyxHQUFHdkIsU0FBU2UsUUFBUSxDQUFDLElBQUksQ0FBQ00sR0FBRyxFQUFFLElBQUksQ0FBQ0MsR0FBRztJQUNyRHI1QixPQUFPRSxNQUFNLENBQUMsQ0FBRSxLQUFJLENBQUNrNUIsR0FBRyxLQUFLLEtBQUssSUFBSSxDQUFDQyxHQUFHLEtBQUssSUFBSTtBQUNyRDtBQUNBTixRQUFRejJDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN2QyxPQUFPO1FBQUN5QjtLQUFXO0FBQ3JCO0FBQ0FtekMsUUFBUXoyQyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDcEMsT0FBTzIwQztBQUNUO0FBRUEsSUFBSXdCLGVBQWdCLFNBQVVDLFVBQVU7SUFDdEMsU0FBU0Q7UUFDUCxJQUFJekcsT0FBTzF3QyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJd3BDLFlBQVl4cEMsU0FBUyxDQUFDLEVBQUU7UUFDNUJvM0MsV0FBVzMxQyxJQUFJLENBQUMsSUFBSSxFQUFFaXZDO1FBQ3RCLElBQUksQ0FBQzJHLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUMvRSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNkUsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLE1BQU0sR0FBRztZQUFDO1lBQUcsQ0FBQztZQUFLLENBQUM7U0FBSTtRQUM3QixJQUFJLENBQUNOLFVBQVUsR0FBRzdOO1FBQ2xCLElBQUlBLFdBQVc7WUFDYixJQUFJLENBQUM5Z0MsSUFBSSxDQUFDZ29DLEtBQUs1OUIsYUFBYSxDQUFDLElBQUk0OUIsS0FBSzU5QixhQUFhLENBQUM7UUFDdEQsT0FBTztZQUNMLElBQUk1USxJQUFJd3VDLEtBQUs3WixZQUFZLEtBQUs7WUFDOUIsSUFBSSxDQUFDbnVCLElBQUksQ0FBQ2dvQyxLQUFLNTlCLGFBQWEsQ0FBQzVRLElBQUl3dUMsS0FBSzU5QixhQUFhLENBQUM1USxJQUFJO1FBQzFEO1FBQ0EsSUFBSSxDQUFDMDFDLG9CQUFvQjtJQUMzQjtJQUVBLElBQUtSLFlBQWFELGFBQWF2MUMsU0FBUyxHQUFHdzFDO0lBQzNDRCxhQUFhajRDLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRXUxQyxjQUFjQSxXQUFXbDRDLFNBQVM7SUFDMUVpNEMsYUFBYWo0QyxTQUFTLENBQUM0QyxXQUFXLEdBQUdxMUM7SUFDckNBLGFBQWFqNEMsU0FBUyxDQUFDMnlDLFVBQVUsR0FBRyxTQUFTQTtRQUMzQyxPQUFPLElBQUksQ0FBQzJGLFFBQVE7SUFDdEI7SUFDQUwsYUFBYWo0QyxTQUFTLENBQUNzc0MsUUFBUSxHQUFHLFNBQVNBLFNBQVU1RCxRQUFRO1FBQzNELE9BQU8sSUFBSSxDQUFDK1AsTUFBTSxDQUFDL1AsU0FBUztJQUM5QjtJQUNBdVAsYUFBYWo0QyxTQUFTLENBQUN5ckMsVUFBVSxHQUFHLFNBQVNBLFdBQVlJLFNBQVM7UUFDaEUsSUFBSSxDQUFDMEgsVUFBVSxHQUFHMUg7SUFDcEI7SUFDQW9NLGFBQWFqNEMsU0FBUyxDQUFDMDRDLG9CQUFvQixHQUFHLFNBQVNBO1FBQ3JELElBQUksQ0FBQ3BJLE1BQU0sR0FBRyxJQUFJeEIsTUFBTSxJQUFJLENBQUM0SCxLQUFLLENBQUMzRixRQUFRO1FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUNvSCxVQUFVLEVBQUU7WUFBRSxJQUFJLENBQUM3SCxNQUFNLENBQUNwQyxJQUFJO1FBQUk7SUFDOUM7SUFDQStKLGFBQWFqNEMsU0FBUyxDQUFDbXhDLE9BQU8sR0FBRyxTQUFTQTtRQUN4QyxPQUFPLElBQUksQ0FBQ2tILEtBQUs7SUFDbkI7SUFDQUosYUFBYWo0QyxTQUFTLENBQUNrdEMsUUFBUSxHQUFHLFNBQVNBLFNBQVV4RSxRQUFRLEVBQUVpUSxRQUFRO1FBQ3JFLElBQUksSUFBSSxDQUFDRixNQUFNLENBQUMvUCxTQUFTLEtBQUssQ0FBQyxLQUFLO1lBQ2xDLElBQUksSUFBSSxDQUFDK1AsTUFBTSxDQUFDL1AsU0FBUyxLQUFLaVEsVUFBVTtnQkFBRSxNQUFNLElBQUloTyxrQkFBa0IsZ0NBQWdDLElBQUksQ0FBQy8yQixhQUFhO1lBQUk7UUFDOUg7UUFDQSxJQUFJLENBQUM2a0MsTUFBTSxDQUFDL1AsU0FBUyxHQUFHaVE7SUFDMUI7SUFDQVYsYUFBYWo0QyxTQUFTLENBQUN1c0Msa0JBQWtCLEdBQUcsU0FBU0E7UUFDbkQsSUFBSWp5QixTQUFTLElBQUk7UUFFakIsSUFBSWl5QixxQkFBcUI7UUFDekIsSUFBSyxJQUFJbmxDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCLElBQUksQ0FBRWtULENBQUFBLE9BQU9nMkIsTUFBTSxDQUFDaEMsTUFBTSxDQUFDbG5DLE1BQU1rVCxPQUFPZzJCLE1BQU0sQ0FBQ2pyQixXQUFXLENBQUNqZSxHQUFHa2hDLFNBQVNyaUIsSUFBSSxNQUFNdGYsU0FBU0UsUUFBUSxJQUFJeVQsT0FBT2cyQixNQUFNLENBQUNqckIsV0FBVyxDQUFDamUsR0FBR2toQyxTQUFTdmlCLEtBQUssTUFBTXBmLFNBQVNFLFFBQVEsR0FBRztnQkFDekswbEMscUJBQXFCO1lBQ3ZCO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0lBQ0EwTCxhQUFhajRDLFNBQVMsQ0FBQzQ0QyxVQUFVLEdBQUcsU0FBU0EsV0FBWUMsT0FBTztRQUM5RCxJQUFJLENBQUNQLFFBQVEsR0FBR087SUFDbEI7SUFDQVosYUFBYWo0QyxTQUFTLENBQUNxMEMsS0FBSyxHQUFHLFNBQVNBLE1BQU8zeEIsR0FBRztRQUNoRHcxQixXQUFXbDRDLFNBQVMsQ0FBQ3EwQyxLQUFLLENBQUM5eEMsSUFBSSxDQUFDLElBQUksRUFBRW1nQjtRQUN0Q0EsSUFBSTJ4QixLQUFLLENBQUMsTUFBTSxJQUFJLENBQUNvRSxNQUFNLENBQUNuUSxTQUFTcmlCLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDd3lCLE1BQU0sQ0FBQ25RLFNBQVN2aUIsS0FBSyxDQUFDO1FBQzlFckQsSUFBSTJ4QixLQUFLLENBQUMsT0FBTyxJQUFJLENBQUN5RSxhQUFhLEtBQUs7UUFDeEMsSUFBSSxJQUFJLENBQUMxRixXQUFXLEVBQUU7WUFBRTF3QixJQUFJMnhCLEtBQUssQ0FBQztRQUFjO0lBQ2xEO0lBQ0E0RCxhQUFhajRDLFNBQVMsQ0FBQzB5QyxjQUFjLEdBQUcsU0FBU0EsZUFBZ0JxRyxXQUFXO1FBQzFFLElBQUksQ0FBQ1AsWUFBWSxHQUFHTztJQUN0QjtJQUNBZCxhQUFhajRDLFNBQVMsQ0FBQ2c1QyxVQUFVLEdBQUcsU0FBU0E7UUFDM0MsSUFBSWxMLFNBQVMsSUFBSSxDQUFDd0MsTUFBTSxDQUFDeEMsTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDd0MsTUFBTSxDQUFDeEMsTUFBTSxDQUFDO1FBQ3pELElBQUltTCxvQkFBb0IsQ0FBQyxJQUFJLENBQUMzSSxNQUFNLENBQUNoQyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUNnQyxNQUFNLENBQUMxQixpQkFBaUIsQ0FBQyxHQUFHam9DLFNBQVNJLFFBQVE7UUFDcEcsSUFBSW15QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUM1SSxNQUFNLENBQUNoQyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUNnQyxNQUFNLENBQUMxQixpQkFBaUIsQ0FBQyxHQUFHam9DLFNBQVNJLFFBQVE7UUFDcEcsT0FBTyttQyxVQUFVbUwscUJBQXFCQztJQUN4QztJQUNBakIsYUFBYWo0QyxTQUFTLENBQUNreEMsV0FBVyxHQUFHLFNBQVNBLFlBQWFpSSxRQUFRO1FBQ2pFLElBQUksQ0FBQ1osU0FBUyxHQUFHWTtJQUNuQjtJQUNBbEIsYUFBYWo0QyxTQUFTLENBQUMreUMsY0FBYyxHQUFHLFNBQVNBO1FBQy9DLE9BQU8sSUFBSSxDQUFDeUYsWUFBWTtJQUMxQjtJQUNBUCxhQUFhajRDLFNBQVMsQ0FBQzg0QyxhQUFhLEdBQUcsU0FBU0E7UUFDOUMsSUFBSU0sYUFBYSxJQUFJLENBQUMxQyxLQUFLLENBQUNvQyxhQUFhO1FBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUNYLFVBQVUsRUFBRTtZQUFFaUIsYUFBYSxDQUFDQTtRQUFZO1FBQ2xELE9BQU9BO0lBQ1Q7SUFDQW5CLGFBQWFqNEMsU0FBUyxDQUFDd3NDLFdBQVcsR0FBRyxTQUFTQSxZQUFhZ0gsVUFBVTtRQUNuRSxJQUFJLENBQUNKLFdBQVcsR0FBR0k7SUFDckI7SUFDQXlFLGFBQWFqNEMsU0FBUyxDQUFDdXFDLE1BQU0sR0FBRyxTQUFTQTtRQUN2QyxPQUFPLElBQUksQ0FBQzZOLElBQUk7SUFDbEI7SUFDQUgsYUFBYWo0QyxTQUFTLENBQUNzcUMsU0FBUyxHQUFHLFNBQVNBO1FBQzFDLE9BQU8sSUFBSSxDQUFDNk4sVUFBVTtJQUN4QjtJQUNBRixhQUFhajRDLFNBQVMsQ0FBQzJwQyxPQUFPLEdBQUcsU0FBU0E7UUFDeEMsT0FBTyxJQUFJLENBQUMrTSxLQUFLO0lBQ25CO0lBQ0F1QixhQUFhajRDLFNBQVMsQ0FBQ3E1QyxTQUFTLEdBQUcsU0FBU0EsVUFBVzMyQixHQUFHO1FBQ3hELElBQUksQ0FBQzJ4QixLQUFLLENBQUMzeEI7UUFDWEEsSUFBSTJ4QixLQUFLLENBQUM7UUFDVixJQUFJLElBQUksQ0FBQzhELFVBQVUsRUFBRTtZQUFFLElBQUksQ0FBQ3pCLEtBQUssQ0FBQ3JDLEtBQUssQ0FBQzN4QjtRQUFNLE9BQU87WUFBRSxJQUFJLENBQUNnMEIsS0FBSyxDQUFDNEMsWUFBWSxDQUFDNTJCO1FBQU07SUFDdkY7SUFDQXUxQixhQUFhajRDLFNBQVMsQ0FBQ3U1QyxNQUFNLEdBQUcsU0FBU0EsT0FBUWpRLEVBQUU7UUFDakQsSUFBSSxDQUFDOE8sSUFBSSxHQUFHOU87SUFDZDtJQUNBMk8sYUFBYWo0QyxTQUFTLENBQUN3NUMsY0FBYyxHQUFHLFNBQVNBLGVBQWdCM04sU0FBUztRQUN4RSxJQUFJLENBQUNKLFVBQVUsQ0FBQ0k7UUFDaEIsSUFBSSxDQUFDdU0sSUFBSSxDQUFDM00sVUFBVSxDQUFDSTtJQUN2QjtJQUNBb00sYUFBYWo0QyxTQUFTLENBQUNtc0MsYUFBYSxHQUFHLFNBQVNBLGNBQWV6RCxRQUFRLEVBQUV4TSxLQUFLO1FBQzVFLElBQUlrZCxhQUFhLElBQUksQ0FBQ3pQLE9BQU8sR0FBR21QLGFBQWE7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ1gsVUFBVSxFQUFFO1lBQUVpQixhQUFhLENBQUNBO1FBQVk7UUFDbEQsSUFBSUssa0JBQWtCO1FBQ3RCLElBQUkvUSxhQUFhSixTQUFTcmlCLElBQUksRUFBRTtZQUFFd3pCLGtCQUFrQixDQUFDO1FBQUc7UUFDeEQsSUFBSUMsY0FBY3BSLFNBQVNHLFFBQVEsQ0FBQ0M7UUFDcEMsSUFBSWlSLFFBQVFQLGFBQWFLO1FBQ3pCLElBQUlHLGdCQUFnQjFkLFFBQVF5ZDtRQUM1QixJQUFJLENBQUN6TSxRQUFRLENBQUN4RSxVQUFVeE07UUFDeEIsSUFBSSxDQUFDZ1IsUUFBUSxDQUFDd00sYUFBYUU7SUFDN0I7SUFDQTNCLGFBQWFqNEMsU0FBUyxDQUFDOHdDLFdBQVcsR0FBRyxTQUFTQTtRQUM1QyxPQUFPLElBQUksQ0FBQ3lILFNBQVM7SUFDdkI7SUFDQU4sYUFBYWo0QyxTQUFTLENBQUN3ekMsVUFBVSxHQUFHLFNBQVNBO1FBQzNDLE9BQU8sSUFBSSxDQUFDSixXQUFXO0lBQ3pCO0lBQ0E2RSxhQUFhajRDLFNBQVMsQ0FBQzY1QyxPQUFPLEdBQUcsU0FBU0EsUUFBU255QixJQUFJO1FBQ3JELElBQUksQ0FBQzJ3QixLQUFLLEdBQUczd0I7SUFDZjtJQUNBdXdCLGFBQWFqNEMsU0FBUyxDQUFDNnJDLFNBQVMsR0FBRyxTQUFTQTtRQUMxQyxPQUFPLElBQUksQ0FBQzBILFVBQVU7SUFDeEI7SUFDQTBFLGFBQWFqNEMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQzVDLE9BQU8sRUFBRTtJQUNYO0lBQ0FvMkMsYUFBYWo0QyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDekMsT0FBT20yQztJQUNUO0lBQ0FBLGFBQWE2QixXQUFXLEdBQUcsU0FBU0EsWUFBYUMsWUFBWSxFQUFFQyxZQUFZO1FBQ3pFLElBQUlELGlCQUFpQnB6QyxTQUFTSSxRQUFRLElBQUlpekMsaUJBQWlCcnpDLFNBQVNFLFFBQVEsRUFBRTtZQUFFLE9BQU87UUFBRyxPQUFPLElBQUlrekMsaUJBQWlCcHpDLFNBQVNFLFFBQVEsSUFBSW16QyxpQkFBaUJyekMsU0FBU0ksUUFBUSxFQUFFO1lBQUUsT0FBTyxDQUFDO1FBQUU7UUFDM0wsT0FBTztJQUNUO0lBRUEsT0FBT2t4QztBQUNULEVBQUV4QjtBQUVGLElBQUl3RCxjQUFjLFNBQVNBLGVBQWdCO0FBRTNDQSxZQUFZajZDLFNBQVMsQ0FBQ3ExQyxVQUFVLEdBQUcsU0FBU0EsV0FBWXJwQixLQUFLO0lBQzNELE9BQU8sSUFBSWdvQixLQUFLaG9CLE9BQU87QUFDekI7QUFDQWl1QixZQUFZajZDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLEVBQUU7QUFDWDtBQUNBbzRDLFlBQVlqNkMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU9tNEM7QUFDVDtBQUVBLElBQUlDLGNBQWMsU0FBU0E7SUFDekIsSUFBSSxDQUFDOUosTUFBTSxHQUFHLElBQUk1aUI7SUFDbEIsSUFBSSxDQUFDNmQsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDOE8sWUFBWSxHQUFHLElBQUkzc0I7SUFDeEIsSUFBSTFzQixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUM0cUMsTUFBTSxHQUFHLElBQUkySixRQUFRLElBQUlpRjtJQUNoQyxPQUFPLElBQUluNUMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXkwQyxXQUFXcDBDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUksQ0FBQ3VxQyxNQUFNLEdBQUcsSUFBSTJKLFFBQVFFO0lBQzVCO0FBQ0Y7QUFDQWdGLFlBQVlsNkMsU0FBUyxDQUFDbzZDLFVBQVUsR0FBRyxTQUFTQSxXQUFZMTNCLEdBQUc7SUFDdkQsSUFBSXBJLFNBQVMsSUFBSTtJQUVuQm9JLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSXZiLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNncEMsTUFBTSxDQUFDejhCLElBQUksSUFBSXZNLElBQUs7UUFDM0NzYixJQUFJQyxPQUFPLENBQUMsVUFBVXZiLElBQUk7UUFDMUIsSUFBSXlCLElBQUl5UixPQUFPODFCLE1BQU0sQ0FBQ2h0QyxHQUFHLENBQUNnRTtRQUMxQnlCLEVBQUV3ckMsS0FBSyxDQUFDM3hCO1FBQ1I3WixFQUFFd3hDLE1BQU0sQ0FBQ2hHLEtBQUssQ0FBQzN4QjtJQUNqQjtBQUNGO0FBQ0F3M0IsWUFBWWw2QyxTQUFTLENBQUNtMUMsSUFBSSxHQUFHLFNBQVNBLEtBQU1ucEIsS0FBSztJQUMvQyxPQUFPLElBQUksQ0FBQ3FmLE1BQU0sQ0FBQzhKLElBQUksQ0FBQ25wQjtBQUMxQjtBQUNBa3VCLFlBQVlsNkMsU0FBUyxDQUFDbzFDLE9BQU8sR0FBRyxTQUFTQTtJQUN2QyxJQUFJdDBDLFNBQVMsQ0FBQyxFQUFFLFlBQVlrekMsTUFBTTtRQUNoQyxJQUFJL0osT0FBT25wQyxTQUFTLENBQUMsRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ3VxQyxNQUFNLENBQUMrSixPQUFPLENBQUNuTDtJQUM3QixPQUFPLElBQUlucEMsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQVk7UUFDN0MsSUFBSXNvQixRQUFRbHJCLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDdXFDLE1BQU0sQ0FBQytKLE9BQU8sQ0FBQ3BwQjtJQUM3QjtBQUNGO0FBQ0FrdUIsWUFBWWw2QyxTQUFTLENBQUNzNkMsZUFBZSxHQUFHLFNBQVNBO0lBQy9DLE9BQU8sSUFBSSxDQUFDalAsTUFBTSxDQUFDaGdCLFFBQVE7QUFDN0I7QUFDQTZ1QixZQUFZbDZDLFNBQVMsQ0FBQ3U2Qyx1QkFBdUIsR0FBRyxTQUFTQTtJQUN2RCxJQUFLLElBQUlDLFNBQVMsSUFBSSxDQUFDblAsTUFBTSxDQUFDaGdCLFFBQVEsSUFBSW12QixPQUFPanZCLE9BQU8sSUFBSztRQUMzRCxJQUFJMGUsT0FBT3VRLE9BQU85eUIsSUFBSTtRQUN0QnVpQixLQUFLRyxRQUFRLEdBQUdtUSx1QkFBdUI7SUFDekM7QUFDRjtBQUNBTCxZQUFZbDZDLFNBQVMsQ0FBQ3k2QyxZQUFZLEdBQUcsU0FBU0EsYUFBYzMxQyxDQUFDO0lBQzNEeVAsT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDN2Q7QUFDckI7QUFDQW8xQyxZQUFZbDZDLFNBQVMsQ0FBQzA2QyxjQUFjLEdBQUcsU0FBU0EsZUFBZ0J4TCxTQUFTLEVBQUVsakIsS0FBSztJQUM5RSxJQUFJaWUsT0FBTyxJQUFJLENBQUNvQixNQUFNLENBQUM4SixJQUFJLENBQUNucEI7SUFDNUIsSUFBSWllLFNBQVMsTUFBTTtRQUFFLE9BQU87SUFBTTtJQUNsQyxJQUFJOEYsUUFBUTlGLEtBQUs4RyxRQUFRO0lBQ3pCLElBQUloQixVQUFVLFFBQVFBLE1BQU0xcUIsV0FBVyxDQUFDNnBCLGVBQWV2b0MsU0FBU0csUUFBUSxFQUFFO1FBQUUsT0FBTztJQUFLO0lBQ3hGLE9BQU87QUFDVDtBQUNBb3pDLFlBQVlsNkMsU0FBUyxDQUFDMjZDLG9CQUFvQixHQUFHLFNBQVNBO0lBQ3BELElBQUssSUFBSUgsU0FBUyxJQUFJLENBQUNuUCxNQUFNLENBQUNoZ0IsUUFBUSxJQUFJbXZCLE9BQU9qdkIsT0FBTyxJQUFLO1FBQzNELElBQUkwZSxPQUFPdVEsT0FBTzl5QixJQUFJO1FBQ3RCdWlCLEtBQUtHLFFBQVEsR0FBR3VRLG9CQUFvQjtJQUN0QztBQUNGO0FBQ0FULFlBQVlsNkMsU0FBUyxDQUFDNDZDLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQnQ5QixFQUFFLEVBQUUvTCxFQUFFLEVBQUVzcEMsR0FBRyxFQUFFQyxHQUFHO0lBQzFGLElBQUksQ0FBQ3g5QixHQUFHM1ksTUFBTSxDQUFDazJDLE1BQU07UUFBRSxPQUFPO0lBQU07SUFDcEMsSUFBSXI1QixhQUFhb0csa0JBQWtCLENBQUN0SyxJQUFJL0wsSUFBSXVwQyxTQUFTdDVCLGFBQWEzQyxTQUFTLElBQUk0MkIsU0FBU2UsUUFBUSxDQUFDbDVCLElBQUkvTCxRQUFRa2tDLFNBQVNlLFFBQVEsQ0FBQ3FFLEtBQUtDLE1BQU07UUFBRSxPQUFPO0lBQUs7SUFDeEosT0FBTztBQUNUO0FBQ0FaLFlBQVlsNkMsU0FBUyxDQUFDKzZDLFdBQVcsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQ1osWUFBWTtBQUMxQjtBQUNBRCxZQUFZbDZDLFNBQVMsQ0FBQ2c3QyxVQUFVLEdBQUcsU0FBU0EsV0FBWWwyQyxDQUFDO0lBQ3ZEeVAsT0FBT21PLEdBQUcsQ0FBQzJ4QixLQUFLLENBQUN2dkM7QUFDbkI7QUFDQW8xQyxZQUFZbDZDLFNBQVMsQ0FBQ2k3QyxlQUFlLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxJQUFJLENBQUM3SyxNQUFNLENBQUMva0IsUUFBUTtBQUM3QjtBQUNBNnVCLFlBQVlsNkMsU0FBUyxDQUFDazdDLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QjU5QixFQUFFLEVBQUUvTCxFQUFFO0lBQ3BGLElBQUkrSSxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2dwQyxNQUFNLENBQUN6OEIsSUFBSSxJQUFJdk0sSUFBSztRQUMzQyxJQUFJeUIsSUFBSXlSLE9BQU84MUIsTUFBTSxDQUFDaHRDLEdBQUcsQ0FBQ2dFO1FBQzFCLElBQUkrekMsU0FBU3R5QyxFQUFFNnVCLGNBQWM7UUFDN0IsSUFBSXBkLE9BQU9zZ0Msb0JBQW9CLENBQUN0OUIsSUFBSS9MLElBQUk0cEMsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsR0FBRztZQUFFLE9BQU90eUM7UUFBRTtRQUMxRSxJQUFJeVIsT0FBT3NnQyxvQkFBb0IsQ0FBQ3Q5QixJQUFJL0wsSUFBSTRwQyxNQUFNLENBQUNBLE9BQU8xNkMsTUFBTSxHQUFHLEVBQUUsRUFBRTA2QyxNQUFNLENBQUNBLE9BQU8xNkMsTUFBTSxHQUFHLEVBQUUsR0FBRztZQUFFLE9BQU9vSTtRQUFFO0lBQzVHO0lBQ0EsT0FBTztBQUNUO0FBQ0FxeEMsWUFBWWw2QyxTQUFTLENBQUNvN0MsVUFBVSxHQUFHLFNBQVNBLFdBQVl2eUMsQ0FBQztJQUN2RCxJQUFJLENBQUN1bkMsTUFBTSxDQUFDbmtDLEdBQUcsQ0FBQ3BEO0FBQ2xCO0FBQ0FxeEMsWUFBWWw2QyxTQUFTLENBQUNxN0MsV0FBVyxHQUFHLFNBQVNBLFlBQWF4eUMsQ0FBQztJQUN6RCxJQUFLLElBQUl6QixJQUFJLElBQUksQ0FBQzJ6QyxXQUFXLEdBQUcxdkIsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQ3hELElBQUkrdkIsS0FBS2wwQyxFQUFFc2dCLElBQUk7UUFDZixJQUFJNHpCLEdBQUczUixPQUFPLE9BQU85Z0MsR0FBRztZQUFFLE9BQU95eUM7UUFBRztJQUN0QztJQUNBLE9BQU87QUFDVDtBQUNBcEIsWUFBWWw2QyxTQUFTLENBQUN1N0MsUUFBUSxHQUFHLFNBQVNBLFNBQVVDLFVBQVU7SUFDMUQsSUFBSWxoQyxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJb2dCLEtBQUs4Z0IsV0FBV253QixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQ2xELElBQUkxaUIsSUFBSTZ4QixHQUFHaFQsSUFBSTtRQUNmcE4sT0FBTzgxQixNQUFNLENBQUNua0MsR0FBRyxDQUFDcEQ7UUFDbEIsSUFBSTR5QyxNQUFNLElBQUl4RCxhQUFhcHZDLEdBQUc7UUFDOUIsSUFBSTZ5QyxNQUFNLElBQUl6RCxhQUFhcHZDLEdBQUc7UUFDOUI0eUMsSUFBSWxDLE1BQU0sQ0FBQ21DO1FBQ1hBLElBQUluQyxNQUFNLENBQUNrQztRQUNYbmhDLE9BQU9yTyxHQUFHLENBQUN3dkM7UUFDWG5oQyxPQUFPck8sR0FBRyxDQUFDeXZDO0lBQ2I7QUFDRjtBQUNBeEIsWUFBWWw2QyxTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsSUFBS3BELENBQUM7SUFDekMsSUFBSSxDQUFDd2lDLE1BQU0sQ0FBQ3AvQixHQUFHLENBQUNwRDtJQUNoQixJQUFJLENBQUNzeEMsWUFBWSxDQUFDbHVDLEdBQUcsQ0FBQ3BEO0FBQ3hCO0FBQ0FxeEMsWUFBWWw2QyxTQUFTLENBQUNvdEMsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sSUFBSSxDQUFDL0IsTUFBTSxDQUFDbFksTUFBTTtBQUMzQjtBQUNBK21CLFlBQVlsNkMsU0FBUyxDQUFDd3FDLFFBQVEsR0FBRyxTQUFTQSxTQUFVbHRCLEVBQUUsRUFBRS9MLEVBQUU7SUFDdEQsSUFBSStJLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDZ3BDLE1BQU0sQ0FBQ3o4QixJQUFJLElBQUl2TSxJQUFLO1FBQzNDLElBQUl5QixJQUFJeVIsT0FBTzgxQixNQUFNLENBQUNodEMsR0FBRyxDQUFDZ0U7UUFDMUIsSUFBSSt6QyxTQUFTdHlDLEVBQUU2dUIsY0FBYztRQUM3QixJQUFJcGEsR0FBRzNZLE1BQU0sQ0FBQ3cyQyxNQUFNLENBQUMsRUFBRSxLQUFLNXBDLEdBQUc1TSxNQUFNLENBQUN3MkMsTUFBTSxDQUFDLEVBQUUsR0FBRztZQUFFLE9BQU90eUM7UUFBRTtJQUMvRDtJQUNBLE9BQU87QUFDVDtBQUNBcXhDLFlBQVlsNkMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sRUFBRTtBQUNYO0FBQ0FxNEMsWUFBWWw2QyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDeEMsT0FBT280QztBQUNUO0FBQ0FBLFlBQVlLLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5Qm9CLEtBQUs7SUFDM0UsSUFBSyxJQUFJbkIsU0FBU21CLE1BQU10d0IsUUFBUSxJQUFJbXZCLE9BQU9qdkIsT0FBTyxJQUFLO1FBQ3JELElBQUkwZSxPQUFPdVEsT0FBTzl5QixJQUFJO1FBQ3RCdWlCLEtBQUtHLFFBQVEsR0FBR21RLHVCQUF1QjtJQUN6QztBQUNGO0FBRUEsSUFBSXFCLGlCQUFpQixTQUFTQTtJQUM1QixJQUFJLENBQUNuTCxnQkFBZ0IsR0FBRztJQUN4QixJQUFJLENBQUNvTCxVQUFVLEdBQUcsSUFBSXJ1QjtJQUN0QixJQUFJL1Usa0JBQWtCM1gsU0FBUyxDQUFDLEVBQUU7SUFDbEMsSUFBSSxDQUFDMnZDLGdCQUFnQixHQUFHaDRCO0FBQzFCO0FBQ0FtakMsZUFBZTU3QyxTQUFTLENBQUM4N0Msa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsWUFBWTtJQUMzRyxJQUFLLElBQUl2aEIsS0FBS3FoQixVQUFVMXdCLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDakQsSUFBSWtuQixLQUFLL1gsR0FBR2hULElBQUk7UUFDaEIsSUFBSStxQixHQUFHYixNQUFNLElBQUk7WUFDZnFLLGFBQWFod0MsR0FBRyxDQUFDd21DO1FBQ25CLE9BQU87WUFDTHVKLFVBQVUvdkMsR0FBRyxDQUFDd21DO1FBQ2hCO0lBQ0Y7QUFDRjtBQUNBbUosZUFBZTU3QyxTQUFTLENBQUNrOEMsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQkYsU0FBUztJQUMxRSxJQUFJMWhDLFNBQVMsSUFBSTtJQUVuQixJQUFJNmhDLGlCQUFpQixJQUFJM3VCO0lBQ3pCLElBQUssSUFBSWtOLEtBQUtzaEIsVUFBVTN3QixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQ2pELElBQUlrbkIsS0FBSy9YLEdBQUdoVCxJQUFJO1FBQ2hCLElBQUk0WCxPQUFPbVQsR0FBR0osU0FBUyxDQUFDLzNCLE9BQU9tMkIsZ0JBQWdCO1FBQy9DMEwsZUFBZWx3QyxHQUFHLENBQUNxekI7SUFDckI7SUFDQSxPQUFPNmM7QUFDVDtBQUNBUCxlQUFlNTdDLFNBQVMsQ0FBQ284QyxjQUFjLEdBQUcsU0FBU0EsZUFBZ0JKLFNBQVMsRUFBRUMsWUFBWTtJQUN0RixJQUFJM2hDLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlvZ0IsS0FBS3VoQixhQUFhNXdCLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDcEQsSUFBSXFXLE9BQU9sSCxHQUFHaFQsSUFBSTtRQUNsQixJQUFJa2EsS0FBS3FRLFFBQVEsT0FBTyxNQUFNO1lBQzVCLElBQUlyMUIsUUFBUXRDLE9BQU8raEMsc0JBQXNCLENBQUN6YSxNQUFNb2E7WUFDaEQsSUFBSXAvQixVQUFVLE1BQU07Z0JBQUUsTUFBTSxJQUFJK3RCLGtCQUFrQixvQ0FBb0MvSSxLQUFLaHVCLGFBQWEsQ0FBQztZQUFJO1lBQzdHZ3VCLEtBQUt3USxRQUFRLENBQUN4MUI7UUFDaEI7SUFDRjtBQUNGO0FBQ0FnL0IsZUFBZTU3QyxTQUFTLENBQUNzOEMscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXVCQyxZQUFZLEVBQUVQLFNBQVMsRUFBRUMsWUFBWTtJQUNsSCxJQUFJM2hDLFNBQVMsSUFBSTtJQUVuQixJQUFJeWhDLFlBQVksSUFBSXZ1QjtJQUNwQixJQUFLLElBQUlrTixLQUFLNmhCLGFBQWFseEIsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUNwRCxJQUFJa25CLEtBQUsvWCxHQUFHaFQsSUFBSTtRQUNoQixJQUFJK3FCLEdBQUdULGdCQUFnQixLQUFLLEdBQUc7WUFDN0JTLEdBQUdRLG9DQUFvQztZQUN2QyxJQUFJSCxlQUFlTCxHQUFHSSxpQkFBaUI7WUFDdkMsSUFBSWoyQixRQUFRdEMsT0FBT2tpQyxTQUFTLENBQUMxSjtZQUM3QixJQUFJbDJCLFVBQVUsTUFBTTtnQkFDbEJ0QyxPQUFPbWlDLGlCQUFpQixDQUFDNy9CLE9BQU9rMkI7Z0JBQ2hDa0osVUFBVS92QyxHQUFHLENBQUMyUTtZQUNoQixPQUFPO2dCQUNMcS9CLGFBQWFsdkIsTUFBTSxDQUFDK2xCO1lBQ3RCO1FBQ0YsT0FBTztZQUNMaUosVUFBVTl2QyxHQUFHLENBQUN3bUM7UUFDaEI7SUFDRjtJQUNBLE9BQU9zSjtBQUNUO0FBQ0FILGVBQWU1N0MsU0FBUyxDQUFDNnhDLGFBQWEsR0FBRyxTQUFTQSxjQUFlNzhCLENBQUM7SUFDaEUsSUFBSyxJQUFJMGxCLEtBQUssSUFBSSxDQUFDbWhCLFVBQVUsQ0FBQ3h3QixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQ3ZELElBQUlrbkIsS0FBSy9YLEdBQUdoVCxJQUFJO1FBQ2hCLElBQUkrcUIsR0FBR1osYUFBYSxDQUFDNzhCLElBQUk7WUFBRSxPQUFPO1FBQUs7SUFDekM7SUFDQSxPQUFPO0FBQ1Q7QUFDQTRtQyxlQUFlNTdDLFNBQVMsQ0FBQzA4QyxxQkFBcUIsR0FBRyxTQUFTQSxzQkFBdUJDLFFBQVE7SUFDckYsSUFBSXJpQyxTQUFTLElBQUk7SUFFbkIsSUFBSWlpQyxlQUFlLElBQUkvdUI7SUFDdkIsSUFBSyxJQUFJa04sS0FBS2lpQixTQUFTdHhCLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDaEQsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtRQUNoQixJQUFJNGhCLEdBQUdrSyxVQUFVLE1BQU1sSyxHQUFHeUgsUUFBUSxHQUFHekMsTUFBTSxJQUFJO1lBQzdDLElBQUloRixHQUFHd0gsV0FBVyxPQUFPLE1BQU07Z0JBQzdCLElBQUkyQixLQUFLLElBQUlHLGdCQUFnQnRKLElBQUlodkIsT0FBT20yQixnQkFBZ0I7Z0JBQ3hEOEwsYUFBYXR3QyxHQUFHLENBQUN3bUM7Z0JBQ2pCQSxHQUFHakcsV0FBVztZQUNoQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPK1A7QUFDVDtBQUNBWCxlQUFlNTdDLFNBQVMsQ0FBQ3k4QyxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUI3L0IsS0FBSyxFQUFFazJCLFlBQVk7SUFDMUYsSUFBSyxJQUFJcFksS0FBS29ZLGFBQWF6bkIsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUNwRCxJQUFJa25CLEtBQUsvWCxHQUFHaFQsSUFBSTtRQUNoQixJQUFJK3FCLEdBQUdiLE1BQU0sSUFBSTtZQUNmYSxHQUFHTCxRQUFRLENBQUN4MUI7UUFDZDtJQUNGO0FBQ0Y7QUFDQWcvQixlQUFlNTdDLFNBQVMsQ0FBQzQ4QyxXQUFXLEdBQUcsU0FBU0E7SUFDOUMsSUFBSVQsaUJBQWlCLElBQUksQ0FBQ0QsZUFBZSxDQUFDLElBQUksQ0FBQ0wsVUFBVTtJQUN6RCxPQUFPTTtBQUNUO0FBQ0FQLGVBQWU1N0MsU0FBUyxDQUFDcThDLHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3QlEsTUFBTSxFQUFFYixTQUFTO0lBQ2xHLElBQUljLFdBQVdELE9BQU96TCxhQUFhO0lBQ25DLElBQUkyTCxVQUFVRCxTQUFTbnlCLG1CQUFtQjtJQUMxQyxJQUFJMkYsU0FBU3dzQixTQUFTcmlCLGNBQWMsQ0FBQztJQUNyQyxJQUFJdWlCLFdBQVc7SUFDZixJQUFJQyxTQUFTO0lBQ2IsSUFBSyxJQUFJdmlCLEtBQUtzaEIsVUFBVTN3QixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQ2pELElBQUkyeEIsV0FBV3hpQixHQUFHaFQsSUFBSTtRQUN0QixJQUFJeTFCLFVBQVVELFNBQVM5TCxhQUFhO1FBQ3BDLElBQUlnTSxTQUFTRCxRQUFReHlCLG1CQUFtQjtRQUN4QyxJQUFJcXlCLGFBQWEsTUFBTTtZQUFFQyxTQUFTRCxTQUFTNUwsYUFBYSxHQUFHem1CLG1CQUFtQjtRQUFJO1FBQ2xGLElBQUkweUIsY0FBYztRQUNsQixJQUFJRCxPQUFPbmxDLFFBQVEsQ0FBQzhrQyxZQUFZdjdCLGFBQWF1RixhQUFhLENBQUN1SixRQUFRNnNCLFFBQVF6bEIsY0FBYyxLQUFLO1lBQUUybEIsY0FBYztRQUFNO1FBQ3BILElBQUlBLGFBQWE7WUFDZixJQUFJTCxhQUFhLFFBQVFDLE9BQU9obEMsUUFBUSxDQUFDbWxDLFNBQVM7Z0JBQ2hESixXQUFXRTtZQUNiO1FBQ0Y7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFDQXBCLGVBQWU1N0MsU0FBUyxDQUFDdzhDLFNBQVMsR0FBRyxTQUFTQSxVQUFXMUosWUFBWTtJQUNuRSxJQUFJd0ssYUFBYTtJQUNqQixJQUFJMWdDLFFBQVE7SUFDWixJQUFLLElBQUk4ZCxLQUFLb1ksYUFBYXpuQixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQ3BELElBQUlrbkIsS0FBSy9YLEdBQUdoVCxJQUFJO1FBQ2hCLElBQUksQ0FBQytxQixHQUFHYixNQUFNLElBQUk7WUFDaEJoMUIsUUFBUTYxQjtZQUNSNks7UUFDRjtJQUNGO0lBQ0E1L0IsT0FBT0UsTUFBTSxDQUFDMC9CLGNBQWMsR0FBRztJQUMvQixPQUFPMWdDO0FBQ1Q7QUFDQWcvQixlQUFlNTdDLFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQTtJQUN0QyxJQUFJbkwsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSXFzQyxRQUFRaHNDLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUksQ0FBQ21MLEdBQUcsQ0FBQzZnQyxNQUFNaU8sV0FBVyxJQUFJak8sTUFBTU0sUUFBUTtJQUM5QyxPQUFPLElBQUl0c0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWs4QyxXQUFXNzdDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUk2NkMsUUFBUTc2QyxTQUFTLENBQUMsRUFBRTtRQUN4Qm81QyxZQUFZSyx1QkFBdUIsQ0FBQ29CO1FBQ3BDLElBQUlZLGVBQWUsSUFBSSxDQUFDRyxxQkFBcUIsQ0FBQ0M7UUFDOUMsSUFBSVYsZUFBZSxJQUFJenVCO1FBQ3ZCLElBQUl1dUIsWUFBWSxJQUFJLENBQUNPLHFCQUFxQixDQUFDQyxjQUFjLElBQUksQ0FBQ1YsVUFBVSxFQUFFSTtRQUMxRSxJQUFJLENBQUNILGtCQUFrQixDQUFDQyxXQUFXLElBQUksQ0FBQ0YsVUFBVSxFQUFFSTtRQUNwRCxJQUFJLENBQUNHLGNBQWMsQ0FBQyxJQUFJLENBQUNQLFVBQVUsRUFBRUk7SUFDdkM7QUFDRjtBQUNBTCxlQUFlNTdDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM5QyxPQUFPLEVBQUU7QUFDWDtBQUNBKzVDLGVBQWU1N0MsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLE9BQU84NUM7QUFDVDtBQUVBLElBQUkyQixZQUFZLFNBQVNBLGFBQWM7QUFFdkNBLFVBQVV2OUMsU0FBUyxDQUFDdzlDLFNBQVMsR0FBRyxTQUFTQSxhQUFjO0FBQ3ZERCxVQUFVdjlDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN6QyxPQUFPLEVBQUU7QUFDWDtBQUNBMDdDLFVBQVV2OUMsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3RDLE9BQU95N0M7QUFDVDtBQUVBLElBQUlFLGdCQUFnQixTQUFTQTtJQUMzQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSUMsU0FBUzk4QyxTQUFTLENBQUMsRUFBRTtJQUN6QixJQUFJKzhDLE9BQU8vOEMsU0FBUyxDQUFDLEVBQUU7SUFDdkIsSUFBSSxDQUFDNDhDLE9BQU8sR0FBR0U7SUFDZixJQUFJLENBQUNELEtBQUssR0FBR0U7QUFDZjtBQUNBSixjQUFjejlDLFNBQVMsQ0FBQzg5QyxPQUFPLEdBQUcsU0FBU0E7SUFDekMsT0FBTyxJQUFJLENBQUNILEtBQUs7QUFDbkI7QUFDQUYsY0FBY3o5QyxTQUFTLENBQUN3OUMsU0FBUyxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sSUFBSSxDQUFDRSxPQUFPO0FBQ3JCO0FBQ0FELGNBQWN6OUMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzdDLE9BQU87UUFBQzA3QztRQUFXOTVDO0tBQWE7QUFDbEM7QUFDQWc2QyxjQUFjejlDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMxQyxPQUFPMjdDO0FBQ1Q7QUFFQSxJQUFJTSxnQkFBZ0IsU0FBU0E7SUFDM0IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0QsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSXp3QjtJQUNsQixJQUFJLENBQUN5d0IsTUFBTSxDQUFDaHlDLEdBQUcsQ0FBQztBQUNsQjtBQUNBOHhDLGNBQWMvOUMsU0FBUyxDQUFDaytDLElBQUksR0FBRyxTQUFTQTtJQUN0QyxJQUFJLElBQUksQ0FBQ3BrQyxPQUFPLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDbEMsSUFBSXFrQyxVQUFVLElBQUksQ0FBQ0YsTUFBTSxDQUFDNzZDLEdBQUcsQ0FBQztJQUM5QixJQUFJLENBQUM2NkMsTUFBTSxDQUFDM3dCLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQzJ3QixNQUFNLENBQUM3NkMsR0FBRyxDQUFDLElBQUksQ0FBQzQ2QyxLQUFLO0lBQzdDLElBQUksQ0FBQ0EsS0FBSyxJQUFJO0lBQ2QsSUFBSSxDQUFDSSxPQUFPLENBQUM7SUFDYixPQUFPRDtBQUNUO0FBQ0FKLGNBQWMvOUMsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO0lBQ3RDLE9BQU8sSUFBSSxDQUFDcXFDLEtBQUs7QUFDbkI7QUFDQUQsY0FBYy85QyxTQUFTLENBQUNvK0MsT0FBTyxHQUFHLFNBQVNBLFFBQVN4YyxJQUFJO0lBQ3BELElBQUl0bkIsU0FBUyxJQUFJO0lBRW5CLElBQUkrakMsUUFBUTtJQUNaLElBQUlodEIsTUFBTSxJQUFJLENBQUM0c0IsTUFBTSxDQUFDNzZDLEdBQUcsQ0FBQ3crQjtJQUMxQixNQUFPQSxPQUFPLEtBQUssSUFBSSxDQUFDb2MsS0FBSyxFQUFFcGMsT0FBT3ljLE1BQU87UUFDM0NBLFFBQVF6YyxPQUFPO1FBQ2YsSUFBSXljLFVBQVUvakMsT0FBTzBqQyxLQUFLLElBQUkxakMsT0FBTzJqQyxNQUFNLENBQUM3NkMsR0FBRyxDQUFDaTdDLFFBQVEsR0FBR3g1QyxTQUFTLENBQUN5VixPQUFPMmpDLE1BQU0sQ0FBQzc2QyxHQUFHLENBQUNpN0MsVUFBVSxHQUFHO1lBQUVBO1FBQVM7UUFDL0csSUFBSS9qQyxPQUFPMmpDLE1BQU0sQ0FBQzc2QyxHQUFHLENBQUNpN0MsT0FBT3g1QyxTQUFTLENBQUN3c0IsT0FBTyxHQUFHO1lBQUUvVyxPQUFPMmpDLE1BQU0sQ0FBQzN3QixHQUFHLENBQUNzVSxNQUFNdG5CLE9BQU8yakMsTUFBTSxDQUFDNzZDLEdBQUcsQ0FBQ2k3QztRQUFTLE9BQU87WUFBRTtRQUFNO0lBQ3ZIO0lBQ0EsSUFBSSxDQUFDSixNQUFNLENBQUMzd0IsR0FBRyxDQUFDc1UsTUFBTXZRO0FBQ3hCO0FBQ0Ewc0IsY0FBYy85QyxTQUFTLENBQUM2dEIsS0FBSyxHQUFHLFNBQVNBO0lBQ3ZDLElBQUksQ0FBQ213QixLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE1BQU0sQ0FBQ3B3QixLQUFLO0FBQ25CO0FBQ0Frd0IsY0FBYy85QyxTQUFTLENBQUM4WixPQUFPLEdBQUcsU0FBU0E7SUFDekMsT0FBTyxJQUFJLENBQUNra0MsS0FBSyxLQUFLO0FBQ3hCO0FBQ0FELGNBQWMvOUMsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBLElBQUt2SyxDQUFDO0lBQ3pDLElBQUk0WSxTQUFTLElBQUk7SUFFbkIsSUFBSSxDQUFDMmpDLE1BQU0sQ0FBQ2h5QyxHQUFHLENBQUM7SUFDaEIsSUFBSSxDQUFDK3hDLEtBQUssSUFBSTtJQUNkLElBQUlwYyxPQUFPLElBQUksQ0FBQ29jLEtBQUs7SUFDckIsSUFBSSxDQUFDQyxNQUFNLENBQUMzd0IsR0FBRyxDQUFDLEdBQUc1ckI7SUFDbkIsTUFBT0EsRUFBRW1ELFNBQVMsQ0FBQyxJQUFJLENBQUNvNUMsTUFBTSxDQUFDNzZDLEdBQUcsQ0FBQzFDLEtBQUtlLEtBQUssQ0FBQ21nQyxPQUFPLE9BQU8sR0FBR0EsUUFBUSxFQUFHO1FBQ3hFdG5CLE9BQU8yakMsTUFBTSxDQUFDM3dCLEdBQUcsQ0FBQ3NVLE1BQU10bkIsT0FBTzJqQyxNQUFNLENBQUM3NkMsR0FBRyxDQUFDMUMsS0FBS2UsS0FBSyxDQUFDbWdDLE9BQU87SUFDOUQ7SUFDQSxJQUFJLENBQUNxYyxNQUFNLENBQUMzd0IsR0FBRyxDQUFDc1UsTUFBTWxnQztBQUN4QjtBQUNBcThDLGNBQWMvOUMsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sRUFBRTtBQUNYO0FBQ0FrOEMsY0FBYy85QyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDMUMsT0FBT2k4QztBQUNUO0FBRUEsSUFBSU8sY0FBYyxTQUFTQSxlQUFnQjtBQUUzQ0EsWUFBWXQrQyxTQUFTLENBQUN1K0MsU0FBUyxHQUFHLFNBQVNBLFVBQVdWLElBQUksR0FBRztBQUM3RFMsWUFBWXQrQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDM0MsT0FBTyxFQUFFO0FBQ1g7QUFDQXk4QyxZQUFZdCtDLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN4QyxPQUFPdzhDO0FBQ1Q7QUFFQSxJQUFJRSxlQUFlLFNBQVNBLGdCQUFpQjtBQUU3Q0EsYUFBYXgrQyxTQUFTLENBQUM2MEMsTUFBTSxHQUFHLFNBQVNBLE9BQVE0SixPQUFPLEVBQUVaLElBQUksR0FBRztBQUNqRVcsYUFBYXgrQyxTQUFTLENBQUNpdEIsTUFBTSxHQUFHLFNBQVNBLE9BQVF3eEIsT0FBTyxFQUFFWixJQUFJLEdBQUc7QUFDakVXLGFBQWF4K0MsU0FBUyxDQUFDMCtDLEtBQUssR0FBRyxTQUFTQTtBQUN0QyxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLElBQUk7QUFDTjtBQUNBRixhQUFheCtDLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM1QyxPQUFPLEVBQUU7QUFDWDtBQUNBMjhDLGFBQWF4K0MsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3pDLE9BQU8wOEM7QUFDVDtBQUVBLElBQUlHLGVBQWUsU0FBU0E7SUFDMUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJcHhCO0lBQzVCLElBQUksQ0FBQ2t3QixPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNtQixNQUFNLEdBQUc7SUFDZCxJQUFJLzlDLFVBQVVMLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJSyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUM5RCxJQUFJcStDLFFBQVFoK0MsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSSxDQUFDKzlDLE1BQU0sR0FBR0M7SUFDaEI7QUFDRjtBQUVBLElBQUlDLHFCQUFxQjtJQUFFOTZDLGtCQUFrQjtRQUFFOUQsY0FBYztJQUFLO0FBQUU7QUFDcEV3K0MsYUFBYTMrQyxTQUFTLENBQUNnL0MsUUFBUSxHQUFHLFNBQVNBO0lBQ3pDLE9BQU8sSUFBSSxDQUFDSCxNQUFNO0FBQ3BCO0FBQ0FGLGFBQWEzK0MsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sSUFBSSxDQUFDaXJDLGdCQUFnQixDQUFDanJDLElBQUk7QUFDbkM7QUFDQWdyQyxhQUFhMytDLFNBQVMsQ0FBQ2kvQyxrQkFBa0IsR0FBRyxTQUFTQTtJQUNuRCxPQUFPLElBQUksQ0FBQ0wsZ0JBQWdCO0FBQzlCO0FBQ0FELGFBQWEzK0MsU0FBUyxDQUFDay9DLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQkMsY0FBYztJQUNuRnpoQyxPQUFPRSxNQUFNLENBQUMsSUFBSSxDQUFDOC9CLE9BQU8sS0FBSztJQUMvQixJQUFJLENBQUNrQixnQkFBZ0IsQ0FBQzN5QyxHQUFHLENBQUNrekM7QUFDNUI7QUFDQVIsYUFBYTMrQyxTQUFTLENBQUM4WixPQUFPLEdBQUcsU0FBU0E7SUFDeEMsT0FBTyxJQUFJLENBQUM4a0MsZ0JBQWdCLENBQUM5a0MsT0FBTztBQUN0QztBQUNBNmtDLGFBQWEzK0MsU0FBUyxDQUFDdzlDLFNBQVMsR0FBRyxTQUFTQTtJQUMxQyxJQUFJLElBQUksQ0FBQ0UsT0FBTyxLQUFLLE1BQU07UUFDekIsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDMEIsYUFBYTtJQUNuQztJQUNBLE9BQU8sSUFBSSxDQUFDMUIsT0FBTztBQUNyQjtBQUNBaUIsYUFBYTMrQyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDNUMsT0FBTztRQUFDMDdDO1FBQVc5NUM7S0FBYTtBQUNsQztBQUNBazdDLGFBQWEzK0MsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3pDLE9BQU82OEM7QUFDVDtBQUNBSSxtQkFBbUI5NkMsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBb0I7QUFFbkZuRCxPQUFPb0QsZ0JBQWdCLENBQUVzN0MsY0FBY0k7QUFFdkMsSUFBSU0sY0FBYyxTQUFTQSxlQUFnQjtBQUUzQ0EsWUFBWUMsWUFBWSxHQUFHLFNBQVNBO0lBQ2xDLE9BQU87UUFDTHQ1QyxTQUFTLFNBQVNBLFFBQVNRLENBQUMsRUFBRUMsQ0FBQztZQUM3QixPQUFPQSxFQUFFNUIsU0FBUyxDQUFDMkI7UUFDckI7SUFDRjtBQUNGO0FBQ0E2NEMsWUFBWXorQyxHQUFHLEdBQUcsU0FBU0EsSUFBS3kwQixDQUFDO0lBQy9CZ3FCLFlBQVl4cEIsSUFBSSxDQUFDUjtJQUNqQixPQUFPQSxFQUFFanlCLEdBQUcsQ0FBQztBQUNmO0FBQ0FpOEMsWUFBWXhwQixJQUFJLEdBQUcsU0FBU0EsS0FBTVIsQ0FBQyxFQUFFdnhCLENBQUM7SUFDcEMsSUFBSTBDLElBQUk2dUIsRUFBRXJJLE9BQU87SUFDakIsSUFBSWxwQixHQUFHO1FBQ0w4eEIsT0FBT0MsSUFBSSxDQUFDcnZCLEdBQUcxQztJQUNqQixPQUFPO1FBQ0w4eEIsT0FBT0MsSUFBSSxDQUFDcnZCO0lBQ2Q7SUFDQSxJQUFJWSxJQUFJaXVCLEVBQUVoSyxRQUFRO0lBQ2xCLElBQUssSUFBSXNSLE1BQU0sR0FBRzRpQixPQUFPLzRDLEVBQUUvRixNQUFNLEVBQUVrOEIsTUFBTTRpQixNQUFNNWlCLE1BQU87UUFDcER2MUIsRUFBRXNnQixJQUFJO1FBQ050Z0IsRUFBRWttQixHQUFHLENBQUM5bUIsQ0FBQyxDQUFDbTJCLElBQUk7SUFDZDtBQUNGO0FBQ0EwaUIsWUFBWUcsYUFBYSxHQUFHLFNBQVNBLGNBQWUxNkMsQ0FBQztJQUNuRCxJQUFJcXBCLFlBQVksSUFBSVg7SUFDcEJXLFVBQVVsaUIsR0FBRyxDQUFDbkg7SUFDZCxPQUFPcXBCO0FBQ1Q7QUFFQSxJQUFJc3hCLGdCQUFnQixTQUFTQTtJQUMzQixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRztJQUNqQixJQUFJLENBQUNDLGFBQWEsR0FBRztJQUNyQixJQUFJQyxhQUFhaC9DLFNBQVMsQ0FBQyxFQUFFO0lBQzdCLElBQUlpL0MsYUFBYWovQyxTQUFTLENBQUMsRUFBRTtJQUM3QixJQUFJay9DLGVBQWVsL0MsU0FBUyxDQUFDLEVBQUU7SUFDL0IsSUFBSSxDQUFDNCtDLFdBQVcsR0FBR0k7SUFDbkIsSUFBSSxDQUFDSCxXQUFXLEdBQUdJO0lBQ25CLElBQUksQ0FBQ0YsYUFBYSxHQUFHRztJQUNyQixJQUFJLENBQUNKLFNBQVMsR0FBRyxJQUFJLENBQUNyNkMsUUFBUTtBQUNoQztBQUNBazZDLGNBQWN6L0MsU0FBUyxDQUFDaWdELGFBQWEsR0FBRyxTQUFTQSxjQUFlQyxJQUFJLEVBQUVuNEIsV0FBVztJQUMvRSxJQUFJbzRCLFVBQVVWLGNBQWNXLFdBQVcsQ0FBQyxJQUFJLENBQUNWLFdBQVc7SUFDeEQsSUFBSVcsVUFBVVosY0FBY1csV0FBVyxDQUFDLElBQUksQ0FBQ1QsV0FBVztJQUN4RCxJQUFJUSxXQUFXRSxTQUFTO1FBQ3RCLElBQUlaLGNBQWM1bkIsSUFBSSxDQUFDLElBQUksQ0FBQzZuQixXQUFXLElBQUlELGNBQWM1bkIsSUFBSSxDQUFDLElBQUksQ0FBQzhuQixXQUFXLEdBQUc7WUFDL0UsSUFBSSxDQUFDVyxNQUFNLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsSUFBSSxDQUFDQyxXQUFXLEVBQUVPLE1BQU1uNEI7WUFDdEQsT0FBTztRQUNULE9BQU87WUFDTCxJQUFJLENBQUN1NEIsTUFBTSxDQUFDLElBQUksQ0FBQ1gsV0FBVyxFQUFFLElBQUksQ0FBQ0QsV0FBVyxFQUFFUSxNQUFNbjRCO1lBQ3RELE9BQU87UUFDVDtJQUNGLE9BQU8sSUFBSW80QixTQUFTO1FBQ2xCLElBQUksQ0FBQ0csTUFBTSxDQUFDLElBQUksQ0FBQ1osV0FBVyxFQUFFLElBQUksQ0FBQ0MsV0FBVyxFQUFFTyxNQUFNbjRCO1FBQ3RELE9BQU87SUFDVCxPQUFPLElBQUlzNEIsU0FBUztRQUNsQixJQUFJLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNYLFdBQVcsRUFBRSxJQUFJLENBQUNELFdBQVcsRUFBRVEsTUFBTW40QjtRQUN0RCxPQUFPO0lBQ1Q7SUFDQSxNQUFNLElBQUkzbEIseUJBQXlCO0FBQ3JDO0FBQ0FxOUMsY0FBY3ovQyxTQUFTLENBQUN1Z0QsUUFBUSxHQUFHLFNBQVNBO0lBQzFDLE9BQU8sQ0FBRWQsQ0FBQUEsY0FBY1csV0FBVyxDQUFDLElBQUksQ0FBQ1YsV0FBVyxLQUFLRCxjQUFjVyxXQUFXLENBQUMsSUFBSSxDQUFDVCxXQUFXO0FBQ3BHO0FBQ0FGLGNBQWN6L0MsU0FBUyxDQUFDNkUsU0FBUyxHQUFHLFNBQVNBLFVBQVdDLENBQUM7SUFDdkQsSUFBSTA3QyxLQUFLMTdDO0lBQ1QsSUFBSSxJQUFJLENBQUM4NkMsU0FBUyxHQUFHWSxHQUFHWixTQUFTLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUMvQyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxHQUFHWSxHQUFHWixTQUFTLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDOUMsT0FBTztBQUNUO0FBQ0FILGNBQWN6L0MsU0FBUyxDQUFDc2dELE1BQU0sR0FBRyxTQUFTQSxPQUFRRyxZQUFZLEVBQUVDLFFBQVEsRUFBRVIsSUFBSSxFQUFFbjRCLFdBQVc7SUFDdkYsSUFBSXpOLFNBQVMsSUFBSTtJQUVuQixJQUFJcW1DLFdBQVdGLGFBQWF4QixrQkFBa0I7SUFDOUMsSUFBSyxJQUFJNzNDLElBQUl1NUMsU0FBU3QxQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDOUMsSUFBSTh5QixRQUFRajNDLEVBQUVzZ0IsSUFBSTtRQUNsQixJQUFJazVCLEtBQUssSUFBSW5CLGNBQWNwQixPQUFPcUMsVUFBVXBtQyxPQUFPdWxDLGFBQWE7UUFDaEUsSUFBSWUsR0FBR0MsV0FBVyxLQUFLOTRCLGFBQWE7WUFDbENtNEIsS0FBS2owQyxHQUFHLENBQUMyMEM7UUFDWDtJQUNGO0FBQ0Y7QUFDQW5CLGNBQWN6L0MsU0FBUyxDQUFDOGdELFlBQVksR0FBRyxTQUFTQSxhQUFjMTVDLENBQUM7SUFDN0QsSUFBSUEsTUFBTSxHQUFHO1FBQUUsT0FBTyxJQUFJLENBQUNzNEMsV0FBVztJQUFDO0lBQ3ZDLE9BQU8sSUFBSSxDQUFDQyxXQUFXO0FBQ3pCO0FBQ0FGLGNBQWN6L0MsU0FBUyxDQUFDNmdELFdBQVcsR0FBRyxTQUFTQTtJQUM3QyxPQUFPLElBQUksQ0FBQ2pCLFNBQVM7QUFDdkI7QUFDQUgsY0FBY3ovQyxTQUFTLENBQUN1RixRQUFRLEdBQUcsU0FBU0E7SUFDMUMsSUFBSSxJQUFJLENBQUNnN0MsUUFBUSxJQUFJO1FBQ25CLE9BQU8sSUFBSSxDQUFDVixhQUFhLENBQUN0NkMsUUFBUSxDQUFDLElBQUksQ0FBQ202QyxXQUFXLEVBQUUsSUFBSSxDQUFDQyxXQUFXO0lBQ3ZFO0lBQ0EsT0FBTyxJQUFJLENBQUNELFdBQVcsQ0FBQ2xDLFNBQVMsR0FBR2o0QyxRQUFRLENBQUMsSUFBSSxDQUFDbzZDLFdBQVcsQ0FBQ25DLFNBQVM7QUFDekU7QUFDQWlDLGNBQWN6L0MsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzdDLE9BQU87UUFBQ3lCO0tBQVc7QUFDckI7QUFDQW04QyxjQUFjei9DLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMxQyxPQUFPMjlDO0FBQ1Q7QUFDQUEsY0FBYzVuQixJQUFJLEdBQUcsU0FBU0EsS0FBTXB4QixDQUFDO0lBQ25DLE9BQU9BLEVBQUUrMkMsU0FBUyxHQUFHaG5DLE9BQU87QUFDOUI7QUFDQWlwQyxjQUFjVyxXQUFXLEdBQUcsU0FBU0EsWUFBYXZDLElBQUk7SUFDcEQsT0FBT0EsZ0JBQWdCYztBQUN6QjtBQUVBLElBQUlvQyxrQkFBa0IsU0FBU0E7SUFDN0IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUkxekI7SUFDM0IsSUFBSSxDQUFDMnpCLGFBQWEsR0FBRztJQUNyQixJQUFJcmdELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkyZ0QsZUFBZUwsZ0JBQWdCTSxxQkFBcUI7UUFDeEQsSUFBSSxDQUFDRixhQUFhLEdBQUdDO0lBQ3ZCLE9BQU8sSUFBSXRnRCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNmdELGlCQUFpQnhnRCxTQUFTLENBQUMsRUFBRTtRQUNqQzRjLE9BQU9FLE1BQU0sQ0FBQzBqQyxpQkFBaUIsR0FBRztRQUNsQyxJQUFJLENBQUNILGFBQWEsR0FBR0c7SUFDdkI7QUFDRjtBQUVBLElBQUlDLHFCQUFxQjtJQUFFQyxjQUFjO1FBQUVyaEQsY0FBYztJQUFLO0lBQUU4RCxrQkFBa0I7UUFBRTlELGNBQWM7SUFBSztJQUFFa2hELHVCQUF1QjtRQUFFbGhELGNBQWM7SUFBSztBQUFFO0FBQ3ZKNGdELGdCQUFnQi9nRCxTQUFTLENBQUN5aEQsZUFBZSxHQUFHLFNBQVNBO0lBQ25ELE9BQU8sSUFBSSxDQUFDTixhQUFhO0FBQzNCO0FBQ0FKLGdCQUFnQi9nRCxTQUFTLENBQUMwaEQsUUFBUSxHQUFHLFNBQVNBLFNBQVUvRixLQUFLO0lBQzNELE9BQU9BLE1BQU12NEMsR0FBRyxDQUFDdTRDLE1BQU1ob0MsSUFBSSxLQUFLO0FBQ2xDO0FBQ0FvdEMsZ0JBQWdCL2dELFNBQVMsQ0FBQzJULElBQUksR0FBRyxTQUFTQTtJQUN0QyxJQUFJMkcsU0FBUyxJQUFJO0lBRW5CLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLElBQUksQ0FBQ3FaLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUM2bkMsS0FBSztRQUNWLE9BQU8sSUFBSSxDQUFDaHVDLElBQUksQ0FBQyxJQUFJLENBQUNxdEMsS0FBSztJQUM3QixPQUFPLElBQUlsZ0QsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXdwQyxPQUFPbnBDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk2UyxPQUFPO1FBQ1gsSUFBSyxJQUFJdk0sSUFBSTZpQyxLQUFLZ1Ysa0JBQWtCLEdBQUc1ekIsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1lBQy9ELElBQUk0ekIsaUJBQWlCLzNDLEVBQUVzZ0IsSUFBSTtZQUMzQixJQUFJeTNCLDBCQUEwQlIsY0FBYztnQkFDMUNockMsUUFBUTJHLE9BQU8zRyxJQUFJLENBQUN3ckM7WUFDdEIsT0FBTyxJQUFJQSwwQkFBMEIxQixlQUFlO2dCQUNsRDlwQyxRQUFRO1lBQ1Y7UUFDRjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBb3RDLGdCQUFnQi9nRCxTQUFTLENBQUM0aEQsVUFBVSxHQUFHLFNBQVNBLFdBQVkzWCxJQUFJLEVBQUU0VCxJQUFJO0lBQ3BFLElBQUlnRSxnQkFBZ0I7SUFDcEIsSUFBSyxJQUFJejZDLElBQUk2aUMsS0FBS2dWLGtCQUFrQixHQUFHNXpCLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUMvRCxJQUFJNHpCLGlCQUFpQi8zQyxFQUFFc2dCLElBQUk7UUFDM0IsSUFBSXkzQiwwQkFBMEIxQixlQUFlO1lBQzNDLElBQUkwQixlQUFlckIsT0FBTyxPQUFPRCxNQUFNO2dCQUFFZ0UsZ0JBQWdCMUM7WUFBZ0I7UUFDM0U7SUFDRjtJQUNBLElBQUkwQyxrQkFBa0IsTUFBTTtRQUMxQjVYLEtBQUtnVixrQkFBa0IsR0FBR2h5QixNQUFNLENBQUM0MEI7UUFDakMsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0FkLGdCQUFnQi9nRCxTQUFTLENBQUM4aEQsU0FBUyxHQUFHLFNBQVNBO0lBQzNDLElBQUl4bkMsU0FBUyxJQUFJO0lBRW5CLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUNraEQsS0FBSztRQUNWLElBQUlJLGFBQWEsSUFBSSxDQUFDRCxTQUFTLENBQUMsSUFBSSxDQUFDZCxLQUFLO1FBQzFDLElBQUllLGVBQWUsTUFBTTtZQUFFLE9BQU8sSUFBSXYwQjtRQUFZO1FBQ2xELE9BQU91MEI7SUFDVCxPQUFPLElBQUlqaEQsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXdwQyxPQUFPbnBDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlraEQsb0JBQW9CLElBQUl4MEI7UUFDNUIsSUFBSyxJQUFJcG1CLElBQUk2aUMsS0FBS2dWLGtCQUFrQixHQUFHNXpCLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUMvRCxJQUFJNHpCLGlCQUFpQi8zQyxFQUFFc2dCLElBQUk7WUFDM0IsSUFBSXkzQiwwQkFBMEJSLGNBQWM7Z0JBQzFDLElBQUlzRCxxQkFBcUIzbkMsT0FBT3duQyxTQUFTLENBQUMzQztnQkFDMUMsSUFBSThDLHVCQUF1QixNQUFNO29CQUFFRCxrQkFBa0IvMUMsR0FBRyxDQUFDZzJDO2dCQUFxQjtZQUNoRixPQUFPLElBQUk5QywwQkFBMEIxQixlQUFlO2dCQUNsRHVFLGtCQUFrQi8xQyxHQUFHLENBQUNrekMsZUFBZXJCLE9BQU87WUFDOUMsT0FBTztnQkFDTHBnQyxPQUFPQyxvQkFBb0I7WUFDN0I7UUFDRjtRQUNBLElBQUlxa0Msa0JBQWtCcnVDLElBQUksTUFBTSxHQUFHO1lBQUUsT0FBTztRQUFLO1FBQ2pELE9BQU9xdUM7SUFDVDtBQUNGO0FBQ0FqQixnQkFBZ0IvZ0QsU0FBUyxDQUFDNjBDLE1BQU0sR0FBRyxTQUFTQSxPQUFRK0ksTUFBTSxFQUFFQyxJQUFJO0lBQzlEbmdDLE9BQU9FLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQ3FqQyxNQUFNLEVBQUU7SUFDNUIsSUFBSSxDQUFDQyxlQUFlLENBQUNqMUMsR0FBRyxDQUFDLElBQUl3eEMsY0FBY0csUUFBUUM7QUFDckQ7QUFDQWtELGdCQUFnQi9nRCxTQUFTLENBQUNraUQsaUJBQWlCLEdBQUcsU0FBU0E7SUFDbkQsSUFBSTVuQyxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlxK0MsUUFBUWgrQyxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJcWhELGFBQWEsSUFBSTMwQjtRQUNyQixJQUFJLENBQUMwMEIsaUJBQWlCLENBQUNwRCxPQUFPLElBQUksQ0FBQ2tDLEtBQUssRUFBRW1CO1FBQzFDLE9BQU9BO0lBQ1QsT0FBTyxJQUFJcmhELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkyaEQsVUFBVXRoRCxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJdWhELE1BQU12aEQsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSXdoRCxlQUFleGhELFNBQVMsQ0FBQyxFQUFFO1FBQy9CNGMsT0FBT0UsTUFBTSxDQUFDd2tDLFVBQVUsQ0FBQztRQUN6QixJQUFJQyxJQUFJckQsUUFBUSxPQUFPb0QsU0FBUztZQUM5QkUsYUFBYXIyQyxHQUFHLENBQUNvMkM7WUFDakIsT0FBTztRQUNUO1FBQ0EsSUFBSyxJQUFJajdDLElBQUlpN0MsSUFBSXBELGtCQUFrQixHQUFHNXpCLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUM5RCxJQUFJZzNCLFlBQVluN0MsRUFBRXNnQixJQUFJO1lBQ3RCLElBQUk2NkIscUJBQXFCNUQsY0FBYztnQkFDckNya0MsT0FBTzRuQyxpQkFBaUIsQ0FBQ0UsU0FBU0csV0FBV0Q7WUFDL0MsT0FBTztnQkFDTDVrQyxPQUFPRSxNQUFNLENBQUMya0MscUJBQXFCOUU7Z0JBQ25DLElBQUkyRSxZQUFZLENBQUMsR0FBRztvQkFDbEJFLGFBQWFyMkMsR0FBRyxDQUFDczJDO2dCQUNuQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBeEIsZ0JBQWdCL2dELFNBQVMsQ0FBQzArQyxLQUFLLEdBQUcsU0FBU0E7SUFDdkMsSUFBSXBrQyxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkraEQsZUFBZTFoRCxTQUFTLENBQUMsRUFBRTtRQUMvQixJQUFJLENBQUM2Z0QsS0FBSztRQUNWLElBQUkzb0MsVUFBVSxJQUFJd1U7UUFDbEIsSUFBSSxJQUFJLENBQUMxVCxPQUFPLElBQUk7WUFDbEIsT0FBT2Q7UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDeXBDLGVBQWUsR0FBR3hyQyxVQUFVLENBQUMsSUFBSSxDQUFDK3BDLEtBQUssQ0FBQ3hELFNBQVMsSUFBSWdGLGVBQWU7WUFDM0UsSUFBSSxDQUFDOUQsS0FBSyxDQUFDOEQsY0FBYyxJQUFJLENBQUN4QixLQUFLLEVBQUVob0M7UUFDdkM7UUFDQSxPQUFPQTtJQUNULE9BQU8sSUFBSWxZLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlpaUQsaUJBQWlCNWhELFNBQVMsQ0FBQyxFQUFFO1FBQ2pDLElBQUk2aEQsVUFBVTdoRCxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUM2Z0QsS0FBSztRQUNWLElBQUksSUFBSSxDQUFDN25DLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLElBQUksQ0FBQzJvQyxlQUFlLEdBQUd4ckMsVUFBVSxDQUFDLElBQUksQ0FBQytwQyxLQUFLLENBQUN4RCxTQUFTLElBQUlrRixpQkFBaUI7WUFDN0UsSUFBSSxDQUFDaEUsS0FBSyxDQUFDZ0UsZ0JBQWdCLElBQUksQ0FBQzFCLEtBQUssRUFBRTJCO1FBQ3pDO0lBQ0YsT0FBTyxJQUFJN2hELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkwRyxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRXc5QyxnQkFBaUJ4OUMsU0FBUyxDQUFDLEVBQUUsWUFBWWIsVUFBVWEsU0FBUyxDQUFDLEVBQUUsWUFBWTY5QyxjQUFlO1lBQ3ZILElBQUlpRSxpQkFBaUI5aEQsU0FBUyxDQUFDLEVBQUU7WUFDakMsSUFBSW1wQyxPQUFPbnBDLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZCLElBQUkraEQsWUFBWS9oRCxTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJZ2lELGtCQUFrQjdZLEtBQUtnVixrQkFBa0I7WUFDN0MsSUFBSyxJQUFJNzNDLElBQUksR0FBR0EsSUFBSTA3QyxnQkFBZ0JudkMsSUFBSSxJQUFJdk0sSUFBSztnQkFDL0MsSUFBSSszQyxpQkFBaUIyRCxnQkFBZ0IxL0MsR0FBRyxDQUFDZ0U7Z0JBQ3pDLElBQUksQ0FBQ2tULE9BQU9tb0MsZUFBZSxHQUFHeHJDLFVBQVUsQ0FBQ2tvQyxlQUFlM0IsU0FBUyxJQUFJb0YsaUJBQWlCO29CQUNwRjtnQkFDRjtnQkFDQSxJQUFJekQsMEJBQTBCUixjQUFjO29CQUMxQ3JrQyxPQUFPb2tDLEtBQUssQ0FBQ2tFLGdCQUFnQnpELGdCQUFnQjBEO2dCQUMvQyxPQUFPLElBQUkxRCwwQkFBMEIxQixlQUFlO29CQUNsRG9GLFVBQVV0RSxTQUFTLENBQUNZLGVBQWVyQixPQUFPO2dCQUM1QyxPQUFPO29CQUNMcGdDLE9BQU9DLG9CQUFvQjtnQkFDN0I7WUFDRjtRQUNGLE9BQU8sSUFBSXhXLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFc3NCLFNBQVV0c0IsU0FBUyxDQUFDLEVBQUUsWUFBWWIsVUFBVWEsU0FBUyxDQUFDLEVBQUUsWUFBWTY5QyxjQUFlO1lBQ3ZILElBQUlvRSxpQkFBaUJqaUQsU0FBUyxDQUFDLEVBQUU7WUFDakMsSUFBSXcwQyxTQUFTeDBDLFNBQVMsQ0FBQyxFQUFFO1lBQ3pCLElBQUlraUQsWUFBWWxpRCxTQUFTLENBQUMsRUFBRTtZQUM1QixJQUFJbWlELG9CQUFvQjNOLE9BQU8ySixrQkFBa0I7WUFDakQsSUFBSyxJQUFJcjVCLE1BQU0sR0FBR0EsTUFBTXE5QixrQkFBa0J0dkMsSUFBSSxJQUFJaVMsTUFBTztnQkFDdkQsSUFBSXM5QixtQkFBbUJELGtCQUFrQjcvQyxHQUFHLENBQUN3aUI7Z0JBQzdDLElBQUksQ0FBQ3RMLE9BQU9tb0MsZUFBZSxHQUFHeHJDLFVBQVUsQ0FBQ2lzQyxpQkFBaUIxRixTQUFTLElBQUl1RixpQkFBaUI7b0JBQ3RGO2dCQUNGO2dCQUNBLElBQUlHLDRCQUE0QnZFLGNBQWM7b0JBQzVDcmtDLE9BQU9va0MsS0FBSyxDQUFDcUUsZ0JBQWdCRyxrQkFBa0JGO2dCQUNqRCxPQUFPLElBQUlFLDRCQUE0QnpGLGVBQWU7b0JBQ3BEdUYsVUFBVS8yQyxHQUFHLENBQUNpM0MsaUJBQWlCcEYsT0FBTztnQkFDeEMsT0FBTztvQkFDTHBnQyxPQUFPQyxvQkFBb0I7Z0JBQzdCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQW9qQyxnQkFBZ0IvZ0QsU0FBUyxDQUFDMmhELEtBQUssR0FBRyxTQUFTQTtJQUN6QyxJQUFJLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1FBQUUsT0FBTztJQUFLO0lBQy9CLElBQUksQ0FBQ0QsS0FBSyxHQUFHLElBQUksQ0FBQ0UsZUFBZSxDQUFDcG5DLE9BQU8sS0FBSyxJQUFJLENBQUN1N0IsVUFBVSxDQUFDLEtBQUssSUFBSSxDQUFDOE4sa0JBQWtCLENBQUMsSUFBSSxDQUFDakMsZUFBZSxFQUFFLENBQUM7SUFDbEgsSUFBSSxDQUFDQSxlQUFlLEdBQUc7SUFDdkIsSUFBSSxDQUFDRCxNQUFNLEdBQUc7QUFDaEI7QUFDQUYsZ0JBQWdCL2dELFNBQVMsQ0FBQ29qRCxPQUFPLEdBQUcsU0FBU0E7SUFDM0MsSUFBSSxDQUFDekIsS0FBSztJQUNWLE9BQU8sSUFBSSxDQUFDWCxLQUFLO0FBQ25CO0FBQ0FELGdCQUFnQi9nRCxTQUFTLENBQUNpdEIsTUFBTSxHQUFHLFNBQVNBO0lBQ3hDLElBQUkzUyxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkraEQsZUFBZTFoRCxTQUFTLENBQUMsRUFBRTtRQUMvQixJQUFJKzhDLE9BQU8vOEMsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSSxDQUFDNmdELEtBQUs7UUFDVixJQUFJLElBQUksQ0FBQ2MsZUFBZSxHQUFHeHJDLFVBQVUsQ0FBQyxJQUFJLENBQUMrcEMsS0FBSyxDQUFDeEQsU0FBUyxJQUFJZ0YsZUFBZTtZQUMzRSxPQUFPLElBQUksQ0FBQ3YxQixNQUFNLENBQUN1MUIsY0FBYyxJQUFJLENBQUN4QixLQUFLLEVBQUVuRDtRQUMvQztRQUNBLE9BQU87SUFDVCxPQUFPLElBQUkvOEMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWlpRCxpQkFBaUI1aEQsU0FBUyxDQUFDLEVBQUU7UUFDakMsSUFBSW1wQyxPQUFPbnBDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUl1aUQsU0FBU3ZpRCxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJbXRCLFFBQVEsSUFBSSxDQUFDMnpCLFVBQVUsQ0FBQzNYLE1BQU1vWjtRQUNsQyxJQUFJcDFCLE9BQU87WUFBRSxPQUFPO1FBQUs7UUFDekIsSUFBSXExQixlQUFlO1FBQ25CLElBQUssSUFBSWw4QyxJQUFJNmlDLEtBQUtnVixrQkFBa0IsR0FBRzV6QixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDL0QsSUFBSTR6QixpQkFBaUIvM0MsRUFBRXNnQixJQUFJO1lBQzNCLElBQUksQ0FBQ3BOLE9BQU9tb0MsZUFBZSxHQUFHeHJDLFVBQVUsQ0FBQ2tvQyxlQUFlM0IsU0FBUyxJQUFJa0YsaUJBQWlCO2dCQUNwRjtZQUNGO1lBQ0EsSUFBSXZELDBCQUEwQlIsY0FBYztnQkFDMUMxd0IsUUFBUTNULE9BQU8yUyxNQUFNLENBQUN5MUIsZ0JBQWdCdkQsZ0JBQWdCa0U7Z0JBQ3RELElBQUlwMUIsT0FBTztvQkFDVHExQixlQUFlbkU7b0JBQ2Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSW1FLGlCQUFpQixNQUFNO1lBQ3pCLElBQUlBLGFBQWFyRSxrQkFBa0IsR0FBR25sQyxPQUFPLElBQUk7Z0JBQy9DbXdCLEtBQUtnVixrQkFBa0IsR0FBR2h5QixNQUFNLENBQUNxMkI7WUFDbkM7UUFDRjtRQUNBLE9BQU9yMUI7SUFDVDtBQUNGO0FBQ0E4eUIsZ0JBQWdCL2dELFNBQVMsQ0FBQ21qRCxrQkFBa0IsR0FBRyxTQUFTQSxtQkFBb0JJLGtCQUFrQixFQUFFekUsS0FBSztJQUNuR3BoQyxPQUFPRSxNQUFNLENBQUMsQ0FBQzJsQyxtQkFBbUJ6cEMsT0FBTztJQUN6QyxJQUFJMHBDLG1CQUFtQixJQUFJLENBQUNDLHNCQUFzQixDQUFDRixvQkFBb0J6RSxRQUFRO0lBQy9FLElBQUkwRSxpQkFBaUI3dkMsSUFBSSxPQUFPLEdBQUc7UUFDakMsT0FBTzZ2QyxpQkFBaUJwZ0QsR0FBRyxDQUFDO0lBQzlCO0lBQ0EsT0FBTyxJQUFJLENBQUMrL0Msa0JBQWtCLENBQUNLLGtCQUFrQjFFLFFBQVE7QUFDM0Q7QUFDQWlDLGdCQUFnQi9nRCxTQUFTLENBQUNrOEIsS0FBSyxHQUFHLFNBQVNBO0lBQ3ZDLElBQUk1aEIsU0FBUyxJQUFJO0lBRW5CLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLElBQUksQ0FBQ3FaLE9BQU8sSUFBSTtZQUNsQixPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUM2bkMsS0FBSztRQUNWLE9BQU8sSUFBSSxDQUFDemxCLEtBQUssQ0FBQyxJQUFJLENBQUM4a0IsS0FBSztJQUM5QixPQUFPLElBQUlsZ0QsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXdwQyxPQUFPbnBDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk0aUQsZ0JBQWdCO1FBQ3BCLElBQUssSUFBSXQ4QyxJQUFJNmlDLEtBQUtnVixrQkFBa0IsR0FBRzV6QixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDL0QsSUFBSTR6QixpQkFBaUIvM0MsRUFBRXNnQixJQUFJO1lBQzNCLElBQUl5M0IsMEJBQTBCUixjQUFjO2dCQUMxQyxJQUFJZ0YsYUFBYXJwQyxPQUFPNGhCLEtBQUssQ0FBQ2lqQjtnQkFDOUIsSUFBSXdFLGFBQWFELGVBQWU7b0JBQUVBLGdCQUFnQkM7Z0JBQVk7WUFDaEU7UUFDRjtRQUNBLE9BQU9ELGdCQUFnQjtJQUN6QjtBQUNGO0FBQ0EzQyxnQkFBZ0IvZ0QsU0FBUyxDQUFDeWpELHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3QlgsZUFBZSxFQUFFYyxRQUFRO0lBQ3pHLElBQUl0cEMsU0FBUyxJQUFJO0lBRW5Cb0QsT0FBT0UsTUFBTSxDQUFDLENBQUNrbEMsZ0JBQWdCaHBDLE9BQU87SUFDdEMsSUFBSTBwQyxtQkFBbUIsSUFBSWgyQjtJQUMzQmcyQixpQkFBaUJ2M0MsR0FBRyxDQUFDLElBQUksQ0FBQ29wQyxVQUFVLENBQUN1TztJQUNyQyxJQUFJQyx3QkFBd0IsSUFBSXIyQixVQUFVczFCO0lBQzFDekQsWUFBWXhwQixJQUFJLENBQUNndUIsdUJBQXVCLElBQUksQ0FBQ0MsYUFBYTtJQUMxRCxJQUFLLElBQUkxOEMsSUFBSXk4QyxzQkFBc0J4NEIsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzNELElBQUk0ekIsaUJBQWlCLzNDLEVBQUVzZ0IsSUFBSTtRQUMzQixJQUFJcE4sT0FBT29uQyxRQUFRLENBQUM4QixrQkFBa0J2RSxrQkFBa0IsR0FBR3RyQyxJQUFJLE9BQU8yRyxPQUFPbW5DLGVBQWUsSUFBSTtZQUM5RitCLGlCQUFpQnYzQyxHQUFHLENBQUNxTyxPQUFPKzZCLFVBQVUsQ0FBQ3VPO1FBQ3pDO1FBQ0F0cEMsT0FBT29uQyxRQUFRLENBQUM4QixrQkFBa0J0RSxpQkFBaUIsQ0FBQ0M7SUFDdEQ7SUFDQSxPQUFPcUU7QUFDVDtBQUNBekMsZ0JBQWdCL2dELFNBQVMsQ0FBQzhaLE9BQU8sR0FBRyxTQUFTQTtJQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDbW5DLE1BQU0sRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUNwbkMsT0FBTztJQUFHO0lBQzFELE9BQU8sSUFBSSxDQUFDa25DLEtBQUssQ0FBQ2xuQyxPQUFPO0FBQzNCO0FBQ0FpbkMsZ0JBQWdCL2dELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMvQyxPQUFPO1FBQUM0QjtLQUFhO0FBQ3ZCO0FBQ0FzOUMsZ0JBQWdCL2dELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM1QyxPQUFPaS9DO0FBQ1Q7QUFDQUEsZ0JBQWdCZ0QsY0FBYyxHQUFHLFNBQVNBLGVBQWdCdjlDLENBQUMsRUFBRUMsQ0FBQztJQUM1RCxPQUFPRCxJQUFJQyxJQUFJLElBQUlELElBQUlDLElBQUksQ0FBQyxJQUFJO0FBQ2xDO0FBQ0E4NkMsbUJBQW1CQyxZQUFZLENBQUNwK0MsR0FBRyxHQUFHO0lBQWMsT0FBT28rQztBQUFhO0FBQ3hFRCxtQkFBbUJ0OUMsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztJQUFjLE9BQU8sQ0FBQztBQUFvQjtBQUNwRm0rQyxtQkFBbUJGLHFCQUFxQixDQUFDaitDLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRztBQUV2RW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRTA5QyxpQkFBaUJRO0FBRTFDLElBQUlDLGVBQWUsU0FBU0EsZ0JBQWlCO0FBRTdDLElBQUl3QyxlQUFlLFNBQVNBLGdCQUFpQjtBQUU3Q0EsYUFBYWhrRCxTQUFTLENBQUN1RixRQUFRLEdBQUcsU0FBU0EsU0FBVTArQyxLQUFLLEVBQUVDLEtBQUssR0FBRztBQUNwRUYsYUFBYWhrRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxFQUFFO0FBQ1g7QUFDQW1pRCxhQUFhaGtELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPa2lEO0FBQ1Q7QUFFQSxJQUFJRyxVQUFXLFNBQVVDLGtCQUFrQjtJQUN6QyxTQUFTRCxRQUFTL0MsWUFBWTtRQUM1QkEsZUFBZUEsZ0JBQWdCK0MsUUFBUTlDLHFCQUFxQjtRQUM1RCtDLG1CQUFtQjdoRCxJQUFJLENBQUMsSUFBSSxFQUFFNitDO0lBQ2hDO0lBRUEsSUFBS2dELG9CQUFxQkQsUUFBUXpoRCxTQUFTLEdBQUcwaEQ7SUFDOUNELFFBQVFua0QsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFeWhELHNCQUFzQkEsbUJBQW1CcGtELFNBQVM7SUFDckZta0QsUUFBUW5rRCxTQUFTLENBQUM0QyxXQUFXLEdBQUd1aEQ7SUFFaEMsSUFBSXBnRCxrQkFBa0I7UUFBRXNnRCxhQUFhO1lBQUVsa0QsY0FBYztRQUFLO1FBQUU4RCxrQkFBa0I7WUFBRTlELGNBQWM7UUFBSztRQUFFbWtELGFBQWE7WUFBRW5rRCxjQUFjO1FBQUs7UUFBRW9rRCxhQUFhO1lBQUVwa0QsY0FBYztRQUFLO1FBQUVxa0QsY0FBYztZQUFFcmtELGNBQWM7UUFBSztRQUFFa2hELHVCQUF1QjtZQUFFbGhELGNBQWM7UUFBSztJQUFFO0lBQ2hRZ2tELFFBQVFua0QsU0FBUyxDQUFDeWtELHdDQUF3QyxHQUFHLFNBQVNBLHlDQUEwQ0MsY0FBYyxFQUFFZCxRQUFRO1FBQ3RJLElBQUl0cEMsU0FBUyxJQUFJO1FBRWpCb0QsT0FBT0UsTUFBTSxDQUFDOG1DLGVBQWVqa0QsTUFBTSxHQUFHO1FBQ3RDLElBQUkraUQsbUJBQW1CLElBQUloMkI7UUFDM0IsSUFBSyxJQUFJcG1CLElBQUksR0FBR0EsSUFBSXM5QyxlQUFlamtELE1BQU0sRUFBRTJHLElBQUs7WUFDOUNvOEMsaUJBQWlCejJCLE1BQU0sQ0FBQ3pTLE9BQU9xcUMsdUNBQXVDLENBQUNELGNBQWMsQ0FBQ3Q5QyxFQUFFLEVBQUV3OEM7UUFDNUY7UUFDQSxPQUFPSjtJQUNUO0lBQ0FXLFFBQVFua0QsU0FBUyxDQUFDcTFDLFVBQVUsR0FBRyxTQUFTQSxXQUFZeUosS0FBSztRQUN2RCxPQUFPLElBQUl1RixZQUFZdkY7SUFDekI7SUFDQXFGLFFBQVFua0QsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO1FBQ2hDLElBQUk3UyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixPQUFPMmpELG1CQUFtQnBrRCxTQUFTLENBQUMyVCxJQUFJLENBQUNwUixJQUFJLENBQUMsSUFBSTtRQUNwRCxPQUFPO1lBQUUsT0FBTzZoRCxtQkFBbUJwa0QsU0FBUyxDQUFDMlQsSUFBSSxDQUFDNEYsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDM0U7SUFDQXFqRCxRQUFRbmtELFNBQVMsQ0FBQzYwQyxNQUFNLEdBQUcsU0FBU0E7UUFDbEMsSUFBSS96QyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJZytDLFVBQVUzOUMsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSSs4QyxPQUFPLzhDLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZCLElBQUkyOUMsUUFBUTduQyxNQUFNLElBQUk7Z0JBQ3BCLE9BQU87WUFDVDtZQUNBd3RDLG1CQUFtQnBrRCxTQUFTLENBQUM2MEMsTUFBTSxDQUFDdHlDLElBQUksQ0FBQyxJQUFJLEVBQUVrOEMsU0FBU1o7UUFDMUQsT0FBTztZQUFFLE9BQU91RyxtQkFBbUJwa0QsU0FBUyxDQUFDNjBDLE1BQU0sQ0FBQ3Q3QixLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUM3RTtJQUNBcWpELFFBQVFua0QsU0FBUyxDQUFDeWlELGVBQWUsR0FBRyxTQUFTQTtRQUMzQyxPQUFPMEIsUUFBUUssWUFBWTtJQUM3QjtJQUNBTCxRQUFRbmtELFNBQVMsQ0FBQzBrRCxjQUFjLEdBQUcsU0FBU0EsZUFBZ0I1QixlQUFlLEVBQUU4QixVQUFVO1FBQ3JGLElBQUlDLGdCQUFnQm5rRCxLQUFLZSxLQUFLLENBQUNmLEtBQUtpQixJQUFJLENBQUNtaEQsZ0JBQWdCbnZDLElBQUksS0FBS2l4QztRQUNsRSxJQUFJRSxTQUFTLElBQUkva0QsTUFBTTZrRCxZQUFZdmtELElBQUksQ0FBQztRQUN4QyxJQUFJK0csSUFBSTA3QyxnQkFBZ0J6M0IsUUFBUTtRQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSXM1QixZQUFZdDVCLElBQUs7WUFDbkN3NUIsTUFBTSxDQUFDeDVCLEVBQUUsR0FBRyxJQUFJa0M7WUFDaEIsSUFBSXUzQix5QkFBeUI7WUFDN0IsTUFBTzM5QyxFQUFFbWtCLE9BQU8sTUFBTXc1Qix5QkFBeUJGLGNBQWU7Z0JBQzVELElBQUkxRixpQkFBaUIvM0MsRUFBRXNnQixJQUFJO2dCQUMzQm85QixNQUFNLENBQUN4NUIsRUFBRSxDQUFDcmYsR0FBRyxDQUFDa3pDO2dCQUNkNEY7WUFDRjtRQUNGO1FBQ0EsT0FBT0Q7SUFDVDtJQUNBWCxRQUFRbmtELFNBQVMsQ0FBQzArQyxLQUFLLEdBQUcsU0FBU0E7UUFDakMsSUFBSTU5QyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJdWtELFlBQVlsa0QsU0FBUyxDQUFDLEVBQUU7WUFDNUIsT0FBT3NqRCxtQkFBbUJwa0QsU0FBUyxDQUFDMCtDLEtBQUssQ0FBQ244QyxJQUFJLENBQUMsSUFBSSxFQUFFeWlEO1FBQ3ZELE9BQU8sSUFBSWxrRCxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJd2tELGNBQWNua0QsU0FBUyxDQUFDLEVBQUU7WUFDOUIsSUFBSTZoRCxVQUFVN2hELFNBQVMsQ0FBQyxFQUFFO1lBQzFCc2pELG1CQUFtQnBrRCxTQUFTLENBQUMwK0MsS0FBSyxDQUFDbjhDLElBQUksQ0FBQyxJQUFJLEVBQUUwaUQsYUFBYXRDO1FBQzdELE9BQU8sSUFBSTdoRCxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJMEcsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUV3OUMsZ0JBQWlCeDlDLFNBQVMsQ0FBQyxFQUFFLFlBQVliLFVBQVVhLFNBQVMsQ0FBQyxFQUFFLFlBQVk2OUMsY0FBZTtnQkFDdkgsSUFBSTZELGVBQWUxaEQsU0FBUyxDQUFDLEVBQUU7Z0JBQy9CLElBQUltcEMsT0FBT25wQyxTQUFTLENBQUMsRUFBRTtnQkFDdkIsSUFBSStoRCxZQUFZL2hELFNBQVMsQ0FBQyxFQUFFO2dCQUM1QnNqRCxtQkFBbUJwa0QsU0FBUyxDQUFDMCtDLEtBQUssQ0FBQ244QyxJQUFJLENBQUMsSUFBSSxFQUFFaWdELGNBQWN2WSxNQUFNNFk7WUFDcEUsT0FBTyxJQUFJMTdDLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFc3NCLFNBQVV0c0IsU0FBUyxDQUFDLEVBQUUsWUFBWWIsVUFBVWEsU0FBUyxDQUFDLEVBQUUsWUFBWTY5QyxjQUFlO2dCQUN2SCxJQUFJK0QsaUJBQWlCNWhELFNBQVMsQ0FBQyxFQUFFO2dCQUNqQyxJQUFJdzBDLFNBQVN4MEMsU0FBUyxDQUFDLEVBQUU7Z0JBQ3pCLElBQUlrWSxVQUFVbFksU0FBUyxDQUFDLEVBQUU7Z0JBQzFCc2pELG1CQUFtQnBrRCxTQUFTLENBQUMwK0MsS0FBSyxDQUFDbjhDLElBQUksQ0FBQyxJQUFJLEVBQUVtZ0QsZ0JBQWdCcE4sUUFBUXQ4QjtZQUN4RTtRQUNGO0lBQ0Y7SUFDQW1yQyxRQUFRbmtELFNBQVMsQ0FBQzhqRCxhQUFhLEdBQUcsU0FBU0E7UUFDekMsT0FBT0ssUUFBUUksV0FBVztJQUM1QjtJQUNBSixRQUFRbmtELFNBQVMsQ0FBQzJrRCx1Q0FBdUMsR0FBRyxTQUFTQSx3Q0FBeUM3QixlQUFlLEVBQUVjLFFBQVE7UUFDckksT0FBT1EsbUJBQW1CcGtELFNBQVMsQ0FBQ3lqRCxzQkFBc0IsQ0FBQ2xoRCxJQUFJLENBQUMsSUFBSSxFQUFFdWdELGlCQUFpQmM7SUFDekY7SUFDQU8sUUFBUW5rRCxTQUFTLENBQUNpdEIsTUFBTSxHQUFHLFNBQVNBO1FBQ2xDLElBQUluc0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSWcrQyxVQUFVMzlDLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLElBQUkrOEMsT0FBTy84QyxTQUFTLENBQUMsRUFBRTtZQUN2QixPQUFPc2pELG1CQUFtQnBrRCxTQUFTLENBQUNpdEIsTUFBTSxDQUFDMXFCLElBQUksQ0FBQyxJQUFJLEVBQUVrOEMsU0FBU1o7UUFDakUsT0FBTztZQUFFLE9BQU91RyxtQkFBbUJwa0QsU0FBUyxDQUFDaXRCLE1BQU0sQ0FBQzFULEtBQUssQ0FBQyxJQUFJLEVBQUV6WTtRQUFXO0lBQzdFO0lBQ0FxakQsUUFBUW5rRCxTQUFTLENBQUNrOEIsS0FBSyxHQUFHLFNBQVNBO1FBQ2pDLElBQUlwN0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsT0FBTzJqRCxtQkFBbUJwa0QsU0FBUyxDQUFDazhCLEtBQUssQ0FBQzM1QixJQUFJLENBQUMsSUFBSTtRQUNyRCxPQUFPO1lBQUUsT0FBTzZoRCxtQkFBbUJwa0QsU0FBUyxDQUFDazhCLEtBQUssQ0FBQzNpQixLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUM1RTtJQUNBcWpELFFBQVFua0QsU0FBUyxDQUFDeWpELHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3QlgsZUFBZSxFQUFFYyxRQUFRO1FBQ25HbG1DLE9BQU9FLE1BQU0sQ0FBQyxDQUFDa2xDLGdCQUFnQmhwQyxPQUFPO1FBQ3RDLElBQUlvckMsZUFBZXhrRCxLQUFLZSxLQUFLLENBQUNmLEtBQUtpQixJQUFJLENBQUNtaEQsZ0JBQWdCbnZDLElBQUksS0FBSyxJQUFJLENBQUM4dEMsZUFBZTtRQUNyRixJQUFJb0Msd0JBQXdCLElBQUlyMkIsVUFBVXMxQjtRQUMxQ3pELFlBQVl4cEIsSUFBSSxDQUFDZ3VCLHVCQUF1Qk0sUUFBUUcsV0FBVztRQUMzRCxJQUFJSSxpQkFBaUIsSUFBSSxDQUFDQSxjQUFjLENBQUNiLHVCQUF1Qm5qRCxLQUFLZSxLQUFLLENBQUNmLEtBQUtpQixJQUFJLENBQUNqQixLQUFLNEUsSUFBSSxDQUFDNC9DO1FBQy9GLE9BQU8sSUFBSSxDQUFDVCx3Q0FBd0MsQ0FBQ0MsZ0JBQWdCZDtJQUN2RTtJQUNBTyxRQUFRbmtELFNBQVMsQ0FBQ21sRCxnQkFBZ0IsR0FBRyxTQUFTQTtRQUM1QyxJQUFJcmtELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUkwRyxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRWtqRCxlQUFlO2dCQUM1QyxJQUFJb0IsV0FBV3RrRCxTQUFTLENBQUMsRUFBRTtnQkFDM0IsSUFBSTgvQyxLQUFLLElBQUluQixjQUFjLElBQUksQ0FBQzJELE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU8sSUFBSWdDO2dCQUMzRCxPQUFPLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUN2RTtZQUMvQixPQUFPLElBQUk5L0MsU0FBUyxDQUFDLEVBQUUsWUFBWTIrQyxlQUFlO2dCQUNoRCxJQUFJNEYsY0FBY3ZrRCxTQUFTLENBQUMsRUFBRTtnQkFDOUIsT0FBTyxJQUFJLENBQUNxa0QsZ0JBQWdCLENBQUNFLGFBQWF4aUQsT0FBT3lpRCxpQkFBaUI7WUFDcEU7UUFDRixPQUFPLElBQUl4a0QsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWXFqRCxXQUFXaDlDLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFa2pELGVBQWU7Z0JBQy9FLElBQUl1QixPQUFPemtELFNBQVMsQ0FBQyxFQUFFO2dCQUN2QixJQUFJMGtELGFBQWExa0QsU0FBUyxDQUFDLEVBQUU7Z0JBQzdCLElBQUkya0QsT0FBTyxJQUFJaEcsY0FBYyxJQUFJLENBQUMyRCxPQUFPLElBQUltQyxLQUFLbkMsT0FBTyxJQUFJb0M7Z0JBQzdELE9BQU8sSUFBSSxDQUFDTCxnQkFBZ0IsQ0FBQ007WUFDL0IsT0FBTyxJQUFJM2tELFNBQVMsQ0FBQyxFQUFFLFlBQVkyK0MsaUJBQWlCLE9BQU8zK0MsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO2dCQUNwRixJQUFJNGtELGdCQUFnQjVrRCxTQUFTLENBQUMsRUFBRTtnQkFDaEMsSUFBSTZrRCxjQUFjN2tELFNBQVMsQ0FBQyxFQUFFO2dCQUM5QixJQUFJOGtELHFCQUFxQkQ7Z0JBQ3pCLElBQUlFLFVBQVU7Z0JBQ2QsSUFBSTNGLE9BQU8sSUFBSW5DO2dCQUNmbUMsS0FBS2owQyxHQUFHLENBQUN5NUM7Z0JBQ1QsTUFBTyxDQUFDeEYsS0FBS3BtQyxPQUFPLE1BQU04ckMscUJBQXFCLElBQUs7b0JBQ2xELElBQUlFLFVBQVU1RixLQUFLaEMsSUFBSTtvQkFDdkIsSUFBSTZILGtCQUFrQkQsUUFBUWpGLFdBQVc7b0JBQ3pDLElBQUlrRixtQkFBbUJILG9CQUFvQjt3QkFBRTtvQkFBTTtvQkFDbkQsSUFBSUUsUUFBUXZGLFFBQVEsSUFBSTt3QkFDdEJxRixxQkFBcUJHO3dCQUNyQkYsVUFBVUM7b0JBQ1osT0FBTzt3QkFDTEEsUUFBUTdGLGFBQWEsQ0FBQ0MsTUFBTTBGO29CQUM5QjtnQkFDRjtnQkFDQSxPQUFPO29CQUFDQyxRQUFRL0UsWUFBWSxDQUFDLEdBQUdoRCxPQUFPO29CQUFJK0gsUUFBUS9FLFlBQVksQ0FBQyxHQUFHaEQsT0FBTztpQkFBRztZQUMvRTtRQUNGLE9BQU8sSUFBSWg5QyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJd1QsTUFBTW5ULFNBQVMsQ0FBQyxFQUFFO1lBQ3RCLElBQUkrOEMsT0FBTy84QyxTQUFTLENBQUMsRUFBRTtZQUN2QixJQUFJa2xELGFBQWFsbEQsU0FBUyxDQUFDLEVBQUU7WUFDN0IsSUFBSW1sRCxNQUFNLElBQUl4SSxjQUFjeHBDLEtBQUs0cEM7WUFDakMsSUFBSXFJLE9BQU8sSUFBSXpHLGNBQWMsSUFBSSxDQUFDMkQsT0FBTyxJQUFJNkMsS0FBS0Q7WUFDbEQsT0FBTyxJQUFJLENBQUNiLGdCQUFnQixDQUFDZSxLQUFLLENBQUMsRUFBRTtRQUN2QztJQUNGO0lBQ0EvQixRQUFRbmtELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUN2QyxPQUFPO1lBQUMyOEM7WUFBYy82QztTQUFhO0lBQ3JDO0lBQ0EwZ0QsUUFBUW5rRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDcEMsT0FBT3FpRDtJQUNUO0lBQ0FBLFFBQVFnQyxPQUFPLEdBQUcsU0FBU0EsUUFBU3Q5QyxDQUFDO1FBQ25DLE9BQU9zN0MsUUFBUWlDLEdBQUcsQ0FBQ3Y5QyxFQUFFa08sT0FBTyxJQUFJbE8sRUFBRWdPLE9BQU87SUFDM0M7SUFDQXN0QyxRQUFRaUMsR0FBRyxHQUFHLFNBQVNBLElBQUs1L0MsQ0FBQyxFQUFFQyxDQUFDO1FBQzlCLE9BQU8sQ0FBQ0QsSUFBSUMsQ0FBQUEsSUFBSztJQUNuQjtJQUNBMDlDLFFBQVFrQyxPQUFPLEdBQUcsU0FBU0EsUUFBU3g5QyxDQUFDO1FBQ25DLE9BQU9zN0MsUUFBUWlDLEdBQUcsQ0FBQ3Y5QyxFQUFFbU8sT0FBTyxJQUFJbk8sRUFBRWlPLE9BQU87SUFDM0M7SUFDQS9TLGdCQUFnQnNnRCxXQUFXLENBQUNqaEQsR0FBRyxHQUFHO1FBQWMsT0FBT2loRDtJQUFZO0lBQ25FdGdELGdCQUFnQkUsZ0JBQWdCLENBQUNiLEdBQUcsR0FBRztRQUFjLE9BQU87SUFBbUI7SUFDL0VXLGdCQUFnQnVnRCxXQUFXLENBQUNsaEQsR0FBRyxHQUFHO1FBQ2hDLE9BQU87WUFDTHZCLGFBQWE7Z0JBQ1gsT0FBTztvQkFBQzJCO2lCQUFXO1lBQ3JCO1lBQ0F3QyxTQUFTLFNBQVVDLEVBQUUsRUFBRUMsRUFBRTtnQkFDdkIsT0FBT2srQyxtQkFBbUJMLGNBQWMsQ0FBQ0ksUUFBUWdDLE9BQU8sQ0FBQ2xnRCxHQUFHdTNDLFNBQVMsS0FBSzJHLFFBQVFnQyxPQUFPLENBQUNqZ0QsR0FBR3MzQyxTQUFTO1lBQ3hHO1FBQ0Y7SUFDRjtJQUNBejVDLGdCQUFnQndnRCxXQUFXLENBQUNuaEQsR0FBRyxHQUFHO1FBQ2hDLE9BQU87WUFDTHZCLGFBQWE7Z0JBQ1gsT0FBTztvQkFBQzJCO2lCQUFXO1lBQ3JCO1lBQ0F3QyxTQUFTLFNBQVVDLEVBQUUsRUFBRUMsRUFBRTtnQkFDdkIsT0FBT2srQyxtQkFBbUJMLGNBQWMsQ0FBQ0ksUUFBUWtDLE9BQU8sQ0FBQ3BnRCxHQUFHdTNDLFNBQVMsS0FBSzJHLFFBQVFrQyxPQUFPLENBQUNuZ0QsR0FBR3MzQyxTQUFTO1lBQ3hHO1FBQ0Y7SUFDRjtJQUNBejVDLGdCQUFnQnlnRCxZQUFZLENBQUNwaEQsR0FBRyxHQUFHO1FBQ2pDLE9BQU87WUFDTHZCLGFBQWE7Z0JBQ1gsT0FBTztvQkFBQ3VpRCxtQkFBbUI1QyxZQUFZO2lCQUFDO1lBQzFDO1lBQ0F2cUMsWUFBWSxTQUFVcXZDLE9BQU8sRUFBRUMsT0FBTztnQkFDcEMsT0FBT0QsUUFBUXJ2QyxVQUFVLENBQUNzdkM7WUFDNUI7UUFDRjtJQUNGO0lBQ0F4aUQsZ0JBQWdCczlDLHFCQUFxQixDQUFDaitDLEdBQUcsR0FBRztRQUFjLE9BQU87SUFBRztJQUVwRW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRThnRCxTQUFTcGdEO0lBRWxDLE9BQU9vZ0Q7QUFDVCxFQUFFcEQ7QUFFRixJQUFJc0QsY0FBZSxTQUFVbUMsZUFBZTtJQUMxQyxTQUFTbkM7UUFDUCxJQUFJdkYsUUFBUWgrQyxTQUFTLENBQUMsRUFBRTtRQUN4QjBsRCxnQkFBZ0Jqa0QsSUFBSSxDQUFDLElBQUksRUFBRXU4QztJQUM3QjtJQUVBLElBQUswSCxpQkFBa0JuQyxZQUFZM2hELFNBQVMsR0FBRzhqRDtJQUMvQ25DLFlBQVlya0QsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFNmpELG1CQUFtQkEsZ0JBQWdCeG1ELFNBQVM7SUFDbkZxa0QsWUFBWXJrRCxTQUFTLENBQUM0QyxXQUFXLEdBQUd5aEQ7SUFDcENBLFlBQVlya0QsU0FBUyxDQUFDby9DLGFBQWEsR0FBRyxTQUFTQTtRQUM3QyxJQUFJeEIsU0FBUztRQUNiLElBQUssSUFBSXgyQyxJQUFJLElBQUksQ0FBQzYzQyxrQkFBa0IsR0FBRzV6QixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDL0QsSUFBSTR6QixpQkFBaUIvM0MsRUFBRXNnQixJQUFJO1lBQzNCLElBQUlrMkIsV0FBVyxNQUFNO2dCQUNuQkEsU0FBUyxJQUFJMW5DLFNBQVNpcEMsZUFBZTNCLFNBQVM7WUFDaEQsT0FBTztnQkFDTEksT0FBT3JtQyxlQUFlLENBQUM0bkMsZUFBZTNCLFNBQVM7WUFDakQ7UUFDRjtRQUNBLE9BQU9JO0lBQ1Q7SUFDQXlHLFlBQVlya0QsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQzNDLE9BQU8sRUFBRTtJQUNYO0lBQ0F3aUQsWUFBWXJrRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDeEMsT0FBT3VpRDtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFMUY7QUFFRixJQUFJOEgseUJBQXlCLFNBQVNBLDBCQUEyQjtBQUVqRUEsdUJBQXVCem1ELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN0RCxPQUFPLEVBQUU7QUFDWDtBQUNBNGtELHVCQUF1QnptRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbkQsT0FBTzJrRDtBQUNUO0FBQ0FBLHVCQUF1QkMsWUFBWSxHQUFHLFNBQVNBLGFBQWNyZ0MsRUFBRSxFQUFFcmtCLEVBQUU7SUFDakUsSUFBSXFrQixLQUFLcmtCLElBQUk7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUN6QixJQUFJcWtCLEtBQUtya0IsSUFBSTtRQUFFLE9BQU87SUFBRTtJQUN4QixPQUFPO0FBQ1Q7QUFDQXlrRCx1QkFBdUJ6Z0QsT0FBTyxHQUFHLFNBQVNBLFFBQVMyZ0QsTUFBTSxFQUFFcnBDLEVBQUUsRUFBRS9MLEVBQUU7SUFDL0QsSUFBSStMLEdBQUcvWSxRQUFRLENBQUNnTixLQUFLO1FBQUUsT0FBTztJQUFFO0lBQ2hDLElBQUlxMUMsUUFBUUgsdUJBQXVCQyxZQUFZLENBQUNwcEMsR0FBRzViLENBQUMsRUFBRTZQLEdBQUc3UCxDQUFDO0lBQzFELElBQUltbEQsUUFBUUosdUJBQXVCQyxZQUFZLENBQUNwcEMsR0FBRzNaLENBQUMsRUFBRTROLEdBQUc1TixDQUFDO0lBQzFELE9BQVFnakQ7UUFDTixLQUFLO1lBQ0gsT0FBT0YsdUJBQXVCSyxZQUFZLENBQUNGLE9BQU9DO1FBQ3BELEtBQUs7WUFDSCxPQUFPSix1QkFBdUJLLFlBQVksQ0FBQ0QsT0FBT0Q7UUFDcEQsS0FBSztZQUNILE9BQU9ILHVCQUF1QkssWUFBWSxDQUFDRCxPQUFPLENBQUNEO1FBQ3JELEtBQUs7WUFDSCxPQUFPSCx1QkFBdUJLLFlBQVksQ0FBQyxDQUFDRixPQUFPQztRQUNyRCxLQUFLO1lBQ0gsT0FBT0osdUJBQXVCSyxZQUFZLENBQUMsQ0FBQ0YsT0FBTyxDQUFDQztRQUN0RCxLQUFLO1lBQ0gsT0FBT0osdUJBQXVCSyxZQUFZLENBQUMsQ0FBQ0QsT0FBTyxDQUFDRDtRQUN0RCxLQUFLO1lBQ0gsT0FBT0gsdUJBQXVCSyxZQUFZLENBQUMsQ0FBQ0QsT0FBT0Q7UUFDckQsS0FBSztZQUNILE9BQU9ILHVCQUF1QkssWUFBWSxDQUFDRixPQUFPLENBQUNDO1FBQ3JEO0lBQ0Y7SUFDQW5wQyxPQUFPQyxvQkFBb0IsQ0FBQztJQUM1QixPQUFPO0FBQ1Q7QUFDQThvQyx1QkFBdUJLLFlBQVksR0FBRyxTQUFTQSxhQUFjQyxZQUFZLEVBQUVDLFlBQVk7SUFDckYsSUFBSUQsZUFBZSxHQUFHO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDbEMsSUFBSUEsZUFBZSxHQUFHO1FBQUUsT0FBTztJQUFFO0lBQ2pDLElBQUlDLGVBQWUsR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ2xDLElBQUlBLGVBQWUsR0FBRztRQUFFLE9BQU87SUFBRTtJQUNqQyxPQUFPO0FBQ1Q7QUFFQSxJQUFJQyxjQUFjLFNBQVNBO0lBQ3pCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ2w3QixLQUFLLEdBQUc7SUFDYixJQUFJLENBQUM5TSxZQUFZLEdBQUc7SUFDcEIsSUFBSSxDQUFDaW9DLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJQyxZQUFZdm1ELFNBQVMsQ0FBQyxFQUFFO0lBQzVCLElBQUlrckIsUUFBUWxyQixTQUFTLENBQUMsRUFBRTtJQUN4QixJQUFJb2UsZUFBZXBlLFNBQVMsQ0FBQyxFQUFFO0lBQy9CLElBQUl3bUQsZ0JBQWdCeG1ELFNBQVMsQ0FBQyxFQUFFO0lBQ2hDLElBQUksQ0FBQ29tRCxVQUFVLEdBQUdHO0lBQ2xCLElBQUksQ0FBQ3I3QixLQUFLLEdBQUcsSUFBSXRvQixXQUFXc29CO0lBQzVCLElBQUksQ0FBQzlNLFlBQVksR0FBR0E7SUFDcEIsSUFBSSxDQUFDaW9DLGNBQWMsR0FBR0c7SUFDdEIsSUFBSSxDQUFDRixXQUFXLEdBQUcsQ0FBQ3A3QixNQUFNem5CLFFBQVEsQ0FBQzhpRCxVQUFVenpDLGFBQWEsQ0FBQ3NMO0FBQzdEO0FBQ0ErbkMsWUFBWWpuRCxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7SUFDN0MsT0FBTyxJQUFJLENBQUNvWSxLQUFLO0FBQ25CO0FBQ0FpN0IsWUFBWWpuRCxTQUFTLENBQUNxMEMsS0FBSyxHQUFHLFNBQVNBLE1BQU8zeEIsR0FBRztJQUMvQ0EsSUFBSTJ4QixLQUFLLENBQUMsSUFBSSxDQUFDcm9CLEtBQUs7SUFDcEJ0SixJQUFJMnhCLEtBQUssQ0FBQyxjQUFjLElBQUksQ0FBQ24xQixZQUFZO0FBQzNDO0FBQ0ErbkMsWUFBWWpuRCxTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV21xQixHQUFHO0lBQ3ZELElBQUl4cUIsUUFBUXdxQjtJQUNaLElBQUksSUFBSSxDQUFDOVAsWUFBWSxHQUFHMWEsTUFBTTBhLFlBQVksRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ3hELElBQUksSUFBSSxDQUFDQSxZQUFZLEdBQUcxYSxNQUFNMGEsWUFBWSxFQUFFO1FBQUUsT0FBTztJQUFFO0lBQ3ZELElBQUksSUFBSSxDQUFDOE0sS0FBSyxDQUFDem5CLFFBQVEsQ0FBQ0MsTUFBTXduQixLQUFLLEdBQUc7UUFBRSxPQUFPO0lBQUU7SUFDakQsT0FBT3k2Qix1QkFBdUJ6Z0QsT0FBTyxDQUFDLElBQUksQ0FBQ21oRCxjQUFjLEVBQUUsSUFBSSxDQUFDbjdCLEtBQUssRUFBRXhuQixNQUFNd25CLEtBQUs7QUFDcEY7QUFDQWk3QixZQUFZam5ELFNBQVMsQ0FBQ3VmLFVBQVUsR0FBRyxTQUFTQSxXQUFZZ29DLGVBQWU7SUFDckUsSUFBSSxJQUFJLENBQUNyb0MsWUFBWSxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUNrb0MsV0FBVyxFQUFFO1FBQUUsT0FBTztJQUFLO0lBQ2hFLElBQUksSUFBSSxDQUFDbG9DLFlBQVksS0FBS3FvQyxpQkFBaUI7UUFBRSxPQUFPO0lBQUs7SUFDekQsT0FBTztBQUNUO0FBQ0FOLFlBQVlqbkQsU0FBUyxDQUFDd25ELFVBQVUsR0FBRyxTQUFTQTtJQUMxQyxPQUFPLElBQUksQ0FBQ0osV0FBVztBQUN6QjtBQUNBSCxZQUFZam5ELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMzQyxPQUFPO1FBQUN5QjtLQUFXO0FBQ3JCO0FBQ0EyakQsWUFBWWpuRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDeEMsT0FBT21sRDtBQUNUO0FBRUEsd0RBQXdEO0FBQ3hELElBQUlRLGtCQUFrQixTQUFTQTtJQUM3QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJbHpCO0lBQ3BCLElBQUksQ0FBQ2tpQixLQUFLLEdBQUc7SUFDYixJQUFJbEYsT0FBTzF3QyxTQUFTLENBQUMsRUFBRTtJQUN2QixJQUFJLENBQUM0MUMsS0FBSyxHQUFHbEY7QUFDZjtBQUNBaVcsZ0JBQWdCem5ELFNBQVMsQ0FBQzJuRCxtQkFBbUIsR0FBRyxTQUFTQTtJQUNyRCxJQUFJcnRDLFNBQVMsSUFBSTtJQUVuQixJQUFJMFcsWUFBWSxJQUFJMUM7SUFDcEIsSUFBSSxDQUFDczVCLFlBQVk7SUFDakIsSUFBSWx0QixLQUFLLElBQUksQ0FBQ3JQLFFBQVE7SUFDdEIsSUFBSXc4QixTQUFTbnRCLEdBQUdoVCxJQUFJO0lBQ3BCLE1BQU9nVCxHQUFHblAsT0FBTyxHQUFJO1FBQ25CLElBQUl1OEIsS0FBS3B0QixHQUFHaFQsSUFBSTtRQUNoQnBOLE9BQU95dEMsa0JBQWtCLENBQUNGLFFBQVFDLElBQUk5MkI7UUFDdEM2MkIsU0FBU0M7SUFDWDtJQUNBLE9BQU85MkIsVUFBVTdjLGlCQUFpQjtBQUNwQztBQUNBc3pDLGdCQUFnQnpuRCxTQUFTLENBQUNnb0QsaUJBQWlCLEdBQUcsU0FBU0E7SUFDbkQsSUFBSTF0QyxTQUFTLElBQUk7SUFFbkIsSUFBSTJ0Qyx5QkFBeUIsSUFBSXo2QjtJQUNqQyxJQUFJLENBQUMwNkIsOEJBQThCLENBQUNEO0lBQ3BDLElBQUksQ0FBQ0UsaUNBQWlDLENBQUNGO0lBQ3ZDLElBQUssSUFBSXZ0QixLQUFLdXRCLHVCQUF1QjU4QixRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQzlELElBQUk2OEIsY0FBYzF0QixHQUFHaFQsSUFBSSxHQUFHemUsUUFBUTtRQUNwQ3FSLE9BQU9yTyxHQUFHLENBQUNxTyxPQUFPbzhCLEtBQUssQ0FBQzlpQyxhQUFhLENBQUN3MEMsY0FBY0E7SUFDdEQ7QUFDRjtBQUNBWCxnQkFBZ0J6bkQsU0FBUyxDQUFDcTBDLEtBQUssR0FBRyxTQUFTQSxNQUFPM3hCLEdBQUc7SUFDbkRBLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSStYLEtBQUssSUFBSSxDQUFDclAsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUM1QyxJQUFJdThCLEtBQUtwdEIsR0FBR2hULElBQUk7UUFDaEJvZ0MsR0FBR3pULEtBQUssQ0FBQzN4QjtJQUNYO0FBQ0Y7QUFDQStrQyxnQkFBZ0J6bkQsU0FBUyxDQUFDbW9ELGlDQUFpQyxHQUFHLFNBQVNBLGtDQUFtQ0Ysc0JBQXNCO0lBQzVILElBQUkzdEMsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzdkMsS0FBSyxDQUFDL2lDLElBQUksS0FBSyxHQUFHdk0sSUFBSztRQUM5QyxJQUFJa1csS0FBS2hELE9BQU9vOEIsS0FBSyxDQUFDOWlDLGFBQWEsQ0FBQ3hNO1FBQ3BDLDZDQUE2QztRQUM3QyxJQUFJb0ssS0FBSzhJLE9BQU9vOEIsS0FBSyxDQUFDOWlDLGFBQWEsQ0FBQ3hNLElBQUk7UUFDeEMsSUFBSWtXLEdBQUcvWSxRQUFRLENBQUNpTixLQUFLO1lBQ25CeTJDLHVCQUF1Qmg4QyxHQUFHLENBQUMsSUFBSWpELFFBQVE1QixJQUFJO1FBQzdDO0lBQ0Y7QUFDRjtBQUNBcWdELGdCQUFnQnpuRCxTQUFTLENBQUMrbkQsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CTSxHQUFHLEVBQUVDLEdBQUcsRUFBRXQzQixTQUFTO0lBQzNGLElBQUkxVyxTQUFTLElBQUk7SUFFbkIscURBQXFEO0lBQ3JELElBQUlpdUMsaUJBQWlCLElBQUksQ0FBQzdSLEtBQUssQ0FBQzlpQyxhQUFhLENBQUMwMEMsSUFBSXBwQyxZQUFZO0lBQzlELElBQUlzcEMsWUFBWUYsSUFBSWQsVUFBVSxNQUFNLENBQUNjLElBQUl0OEIsS0FBSyxDQUFDem5CLFFBQVEsQ0FBQ2drRDtJQUN4RCxvQkFBb0I7SUFDcEIsU0FBUztJQUNULElBQUk7SUFDSixnQkFBZ0I7SUFDaEJ2M0IsVUFBVS9rQixHQUFHLENBQUMsSUFBSXZJLFdBQVcya0QsSUFBSXI4QixLQUFLLEdBQUc7SUFDekMsSUFBSyxJQUFJNWtCLElBQUlpaEQsSUFBSW5wQyxZQUFZLEdBQUcsR0FBRzlYLEtBQUtraEQsSUFBSXBwQyxZQUFZLEVBQUU5WCxJQUFLO1FBQzdENHBCLFVBQVUva0IsR0FBRyxDQUFDcU8sT0FBT284QixLQUFLLENBQUM5aUMsYUFBYSxDQUFDeE07SUFDM0M7SUFDQSxJQUFJb2hELFdBQVc7UUFDYngzQixVQUFVL2tCLEdBQUcsQ0FBQyxJQUFJdkksV0FBVzRrRCxJQUFJdDhCLEtBQUs7SUFDeEM7QUFDRjtBQUNBeTdCLGdCQUFnQnpuRCxTQUFTLENBQUNxckIsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU8sSUFBSSxDQUFDcThCLFFBQVEsQ0FBQ3YwQixNQUFNLEdBQUc5SCxRQUFRO0FBQ3hDO0FBQ0FvOEIsZ0JBQWdCem5ELFNBQVMsQ0FBQ3lvRCxhQUFhLEdBQUcsU0FBU0EsY0FBZUMsUUFBUTtJQUN0RSxJQUFJcHVDLFNBQVMsSUFBSTtJQUVuQixJQUFJLENBQUNzdEMsWUFBWTtJQUNqQixJQUFJLENBQUNJLGlCQUFpQjtJQUN0QixJQUFJdHRCLEtBQUssSUFBSSxDQUFDclAsUUFBUTtJQUN0QixJQUFJdzhCLFNBQVNudEIsR0FBR2hULElBQUk7SUFDcEIsTUFBT2dULEdBQUduUCxPQUFPLEdBQUk7UUFDbkIsSUFBSXU4QixLQUFLcHRCLEdBQUdoVCxJQUFJO1FBQ2hCLElBQUlpaEMsVUFBVXJ1QyxPQUFPc3VDLGVBQWUsQ0FBQ2YsUUFBUUM7UUFDN0NZLFNBQVN6OEMsR0FBRyxDQUFDMDhDO1FBQ2JkLFNBQVNDO0lBQ1g7QUFDRjtBQUNBTCxnQkFBZ0J6bkQsU0FBUyxDQUFDNm9ELGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQlIsR0FBRyxFQUFFQyxHQUFHLEVBQUVRLG9CQUFvQjtJQUN0RyxJQUFJLENBQUNULElBQUlyOEIsS0FBSyxDQUFDem5CLFFBQVEsQ0FBQytqRCxJQUFJdDhCLEtBQUssR0FBRztRQUFFLE9BQU87SUFBTTtJQUNuRCxJQUFJKzhCLHFCQUFxQlQsSUFBSXBwQyxZQUFZLEdBQUdtcEMsSUFBSW5wQyxZQUFZO0lBQzVELElBQUksQ0FBQ29wQyxJQUFJZCxVQUFVLElBQUk7UUFDckJ1QjtJQUNGO0lBQ0EsSUFBSUEsdUJBQXVCLEdBQUc7UUFDNUJELG9CQUFvQixDQUFDLEVBQUUsR0FBR1QsSUFBSW5wQyxZQUFZLEdBQUc7UUFDN0MsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0F1b0MsZ0JBQWdCem5ELFNBQVMsQ0FBQ2tvRCw4QkFBOEIsR0FBRyxTQUFTQSwrQkFBZ0NELHNCQUFzQjtJQUN0SCxJQUFJM3RDLFNBQVMsSUFBSTtJQUVuQixJQUFJd3VDLHVCQUF1QixJQUFJL29ELE1BQU0sR0FBR00sSUFBSSxDQUFDO0lBQzdDLElBQUlxNkIsS0FBSyxJQUFJLENBQUNyUCxRQUFRO0lBQ3RCLElBQUl3OEIsU0FBU250QixHQUFHaFQsSUFBSTtJQUNwQixNQUFPZ1QsR0FBR25QLE9BQU8sR0FBSTtRQUNuQixJQUFJdThCLEtBQUtwdEIsR0FBR2hULElBQUk7UUFDaEIsSUFBSXNoQyxjQUFjMXVDLE9BQU91dUMsaUJBQWlCLENBQUNoQixRQUFRQyxJQUFJZ0I7UUFDdkQsSUFBSUUsYUFBYTtZQUFFZix1QkFBdUJoOEMsR0FBRyxDQUFDLElBQUlqRCxRQUFROC9DLG9CQUFvQixDQUFDLEVBQUU7UUFBSTtRQUNyRmpCLFNBQVNDO0lBQ1g7QUFDRjtBQUNBTCxnQkFBZ0J6bkQsU0FBUyxDQUFDMnBDLE9BQU8sR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQytNLEtBQUs7QUFDbkI7QUFDQStRLGdCQUFnQnpuRCxTQUFTLENBQUM0bkQsWUFBWSxHQUFHLFNBQVNBO0lBQ2hELElBQUlxQixjQUFjLElBQUksQ0FBQ3ZTLEtBQUssQ0FBQy9pQyxJQUFJLEtBQUs7SUFDdEMsSUFBSSxDQUFDMUgsR0FBRyxDQUFDLElBQUksQ0FBQ3lxQyxLQUFLLENBQUM5aUMsYUFBYSxDQUFDLElBQUk7SUFDdEMsSUFBSSxDQUFDM0gsR0FBRyxDQUFDLElBQUksQ0FBQ3lxQyxLQUFLLENBQUM5aUMsYUFBYSxDQUFDcTFDLGNBQWNBO0FBQ2xEO0FBQ0F4QixnQkFBZ0J6bkQsU0FBUyxDQUFDNG9ELGVBQWUsR0FBRyxTQUFTQSxnQkFBaUJQLEdBQUcsRUFBRUMsR0FBRztJQUMxRSxJQUFJaHVDLFNBQVMsSUFBSTtJQUVuQixJQUFJK1gsT0FBT2kyQixJQUFJcHBDLFlBQVksR0FBR21wQyxJQUFJbnBDLFlBQVksR0FBRztJQUNqRCxJQUFJcXBDLGlCQUFpQixJQUFJLENBQUM3UixLQUFLLENBQUM5aUMsYUFBYSxDQUFDMDBDLElBQUlwcEMsWUFBWTtJQUM5RCxJQUFJc3BDLFlBQVlGLElBQUlkLFVBQVUsTUFBTSxDQUFDYyxJQUFJdDhCLEtBQUssQ0FBQ3puQixRQUFRLENBQUNna0Q7SUFDeEQsSUFBSSxDQUFDQyxXQUFXO1FBQ2RuMkI7SUFDRjtJQUNBLElBQUlwTCxNQUFNLElBQUlsbkIsTUFBTXN5QixNQUFNaHlCLElBQUksQ0FBQztJQUMvQixJQUFJNm9ELE1BQU07SUFDVmppQyxHQUFHLENBQUNpaUMsTUFBTSxHQUFHLElBQUl4bEQsV0FBVzJrRCxJQUFJcjhCLEtBQUs7SUFDckMsSUFBSyxJQUFJNWtCLElBQUlpaEQsSUFBSW5wQyxZQUFZLEdBQUcsR0FBRzlYLEtBQUtraEQsSUFBSXBwQyxZQUFZLEVBQUU5WCxJQUFLO1FBQzdENmYsR0FBRyxDQUFDaWlDLE1BQU0sR0FBRzV1QyxPQUFPbzhCLEtBQUssQ0FBQzlpQyxhQUFhLENBQUN4TTtJQUMxQztJQUNBLElBQUlvaEQsV0FBVztRQUFFdmhDLEdBQUcsQ0FBQ2lpQyxJQUFJLEdBQUcsSUFBSXhsRCxXQUFXNGtELElBQUl0OEIsS0FBSztJQUFHO0lBQ3ZELE9BQU8sSUFBSW05QixtQkFBbUJsaUMsS0FBSyxJQUFJLENBQUN5dkIsS0FBSyxDQUFDMFMsT0FBTztBQUN2RDtBQUNBM0IsZ0JBQWdCem5ELFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQSxJQUFLb1YsS0FBSyxFQUFFbkMsWUFBWTtJQUMvRCxJQUFJbXFDLFFBQVEsSUFBSXBDLFlBQVksSUFBSSxDQUFDdlEsS0FBSyxFQUFFcjFCLE9BQU9uQyxjQUFjLElBQUksQ0FBQ3czQixLQUFLLENBQUM0UyxnQkFBZ0IsQ0FBQ3BxQztJQUN6RixJQUFJNG9DLEtBQUssSUFBSSxDQUFDSixRQUFRLENBQUN0a0QsR0FBRyxDQUFDaW1EO0lBQzNCLElBQUl2QixPQUFPLE1BQU07UUFDZnBxQyxPQUFPRSxNQUFNLENBQUNrcUMsR0FBRzk3QixLQUFLLENBQUN6bkIsUUFBUSxDQUFDOGMsUUFBUTtRQUN4QyxPQUFPeW1DO0lBQ1Q7SUFDQSxJQUFJLENBQUNKLFFBQVEsQ0FBQ3gwQixHQUFHLENBQUNtMkIsT0FBT0E7SUFDekIsT0FBT0E7QUFDVDtBQUNBNUIsZ0JBQWdCem5ELFNBQVMsQ0FBQ3VwRCwwQkFBMEIsR0FBRyxTQUFTQSwyQkFBNEJDLFVBQVU7SUFDcEcsSUFBSS9YLFVBQVUsSUFBSSxDQUFDaUYsS0FBSyxDQUFDaGYsY0FBYztJQUN2QyxJQUFJK3hCLFNBQVNELFdBQVdwbUQsR0FBRyxDQUFDO0lBQzVCLElBQUlzbUQsTUFBTUQsT0FBTzcxQyxhQUFhLENBQUM7SUFDL0IsSUFBSSxDQUFDODFDLElBQUlubEQsUUFBUSxDQUFDa3RDLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFBRSxNQUFNLElBQUlsMEIsaUJBQWlCLG1DQUFtQ21zQztJQUFLO0lBQ3BHLElBQUlDLFNBQVNILFdBQVdwbUQsR0FBRyxDQUFDb21ELFdBQVc3MUMsSUFBSSxLQUFLO0lBQ2hELElBQUlpMkMsWUFBWUQsT0FBT2p5QixjQUFjO0lBQ3JDLElBQUlteUIsTUFBTUQsU0FBUyxDQUFDQSxVQUFVbnBELE1BQU0sR0FBRyxFQUFFO0lBQ3pDLElBQUksQ0FBQ29wRCxJQUFJdGxELFFBQVEsQ0FBQ2t0QyxPQUFPLENBQUNBLFFBQVFoeEMsTUFBTSxHQUFHLEVBQUUsR0FBRztRQUFFLE1BQU0sSUFBSThjLGlCQUFpQixpQ0FBaUNzc0M7SUFBSztBQUNySDtBQUNBcEMsZ0JBQWdCem5ELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMvQyxPQUFPLEVBQUU7QUFDWDtBQUNBNGxELGdCQUFnQnpuRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDNUMsT0FBTzJsRDtBQUNUO0FBSUEsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsMEJBQTBCO0FBQzFCLE1BQU07QUFDTixjQUFjO0FBQ2QscUNBQXFDO0FBQ3JDLHdDQUF3QztBQUN4Qyx5REFBeUQ7QUFDekQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixRQUFRO0FBQ1IsK0NBQStDO0FBQy9DLHlFQUF5RTtBQUN6RSx3Q0FBd0M7QUFDeEMseURBQXlEO0FBQ3pELDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSLHdFQUF3RTtBQUN4RSxrQkFBa0I7QUFDbEIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQiw0RUFBNEU7QUFDNUUsTUFBTTtBQUNOLGlCQUFpQjtBQUNqQixnREFBZ0Q7QUFDaEQsa0JBQWtCO0FBQ2xCLE1BQU07QUFDTixzQkFBc0I7QUFDdEIsbUdBQW1HO0FBQ25HLE1BQU07QUFDTixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLE1BQU07QUFDTixrQkFBa0I7QUFDbEIsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTixJQUFJO0FBRUosSUFBSXFDLFNBQVMsU0FBU0EsVUFBVztBQUVqQ0EsT0FBTzlwRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdEMsT0FBTyxFQUFFO0FBQ1g7QUFDQWlvRCxPQUFPOXBELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuQyxPQUFPZ29EO0FBQ1Q7QUFDQUEsT0FBT25ELE1BQU0sR0FBRyxTQUFTQTtJQUN2QixJQUFJLE9BQU83bEQsU0FBUyxDQUFDLEVBQUUsS0FBSyxZQUFZLE9BQU9BLFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUN4RSxJQUFJcUUsS0FBS3JFLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlzRSxLQUFLdEUsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXFFLE9BQU8sT0FBT0MsT0FBTyxLQUFLO1lBQUUsTUFBTSxJQUFJaEQseUJBQXlCLDJDQUEyQytDLEtBQUssT0FBT0MsS0FBSztRQUFNO1FBQ3JJLElBQUkya0QsTUFBTXJwRCxLQUFLeUIsR0FBRyxDQUFDZ0Q7UUFDbkIsSUFBSTZrRCxNQUFNdHBELEtBQUt5QixHQUFHLENBQUNpRDtRQUNuQixJQUFJRCxNQUFNLEdBQUc7WUFDWCxJQUFJQyxNQUFNLEdBQUc7Z0JBQ1gsSUFBSTJrRCxPQUFPQyxLQUFLO29CQUFFLE9BQU87Z0JBQUcsT0FBTztvQkFBRSxPQUFPO2dCQUFFO1lBQ2hELE9BQU87Z0JBQ0wsSUFBSUQsT0FBT0MsS0FBSztvQkFBRSxPQUFPO2dCQUFHLE9BQU87b0JBQUUsT0FBTztnQkFBRTtZQUNoRDtRQUNGLE9BQU87WUFDTCxJQUFJNWtELE1BQU0sR0FBRztnQkFDWCxJQUFJMmtELE9BQU9DLEtBQUs7b0JBQUUsT0FBTztnQkFBRyxPQUFPO29CQUFFLE9BQU87Z0JBQUU7WUFDaEQsT0FBTztnQkFDTCxJQUFJRCxPQUFPQyxLQUFLO29CQUFFLE9BQU87Z0JBQUcsT0FBTztvQkFBRSxPQUFPO2dCQUFFO1lBQ2hEO1FBQ0Y7SUFDRixPQUFPLElBQUlscEQsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLGNBQWM1QyxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtRQUNuRixJQUFJNFosS0FBS3hjLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl5USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSW1wRCxPQUFPMTRDLEdBQUc3UCxDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQztRQUN0QixJQUFJd29ELE9BQU8zNEMsR0FBRzVOLENBQUMsR0FBRzJaLEdBQUczWixDQUFDO1FBQ3RCLElBQUlzbUQsU0FBUyxPQUFPQyxTQUFTLEtBQUs7WUFBRSxNQUFNLElBQUk5bkQseUJBQXlCLHdEQUF3RGtiO1FBQUk7UUFDbkksT0FBT3dzQyxPQUFPbkQsTUFBTSxDQUFDc0QsTUFBTUM7SUFDN0I7QUFDRjtBQUVBLElBQUlDLGdCQUFnQixTQUFTQSxpQkFBa0I7QUFFL0NBLGNBQWNucUQsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQSxrQkFBbUI7QUFDckV5eUIsY0FBY25xRCxTQUFTLENBQUMyVCxJQUFJLEdBQUcsU0FBU0EsUUFBUztBQUNqRHcyQyxjQUFjbnFELFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQSxjQUFleE0sQ0FBQyxHQUFHO0FBQ3BFK2lELGNBQWNucUQsU0FBUyxDQUFDaTVCLFFBQVEsR0FBRyxTQUFTQSxZQUFhO0FBQ3pEa3hCLGNBQWNucUQsU0FBUyxDQUFDb3FELE9BQU8sR0FBRyxTQUFTQSxRQUFTdndDLElBQUksR0FBRztBQUMzRHN3QyxjQUFjbnFELFNBQVMsQ0FBQ29wRCxPQUFPLEdBQUcsU0FBU0EsV0FBWTtBQUN2RGUsY0FBY25xRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDN0MsT0FBTyxFQUFFO0FBQ1g7QUFDQXNvRCxjQUFjbnFELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMxQyxPQUFPcW9EO0FBQ1Q7QUFFQSxJQUFJRSx1QkFBdUIsU0FBU0Esd0JBQXlCO0FBRTdEQSxxQkFBcUJycUQsU0FBUyxDQUFDc3FELGVBQWUsR0FBRyxTQUFTQSxnQkFBaUJqcEMsS0FBSyxFQUFFbkMsWUFBWSxHQUFHO0FBQ2pHbXJDLHFCQUFxQnJxRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDcEQsT0FBTztRQUFDc29EO0tBQWM7QUFDeEI7QUFDQUUscUJBQXFCcnFELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNqRCxPQUFPdW9EO0FBQ1Q7QUFFQSxJQUFJbEIscUJBQXFCLFNBQVNBO0lBQ2hDLElBQUksQ0FBQ29CLFNBQVMsR0FBRyxJQUFJOUMsZ0JBQWdCLElBQUk7SUFDekMsSUFBSSxDQUFDcFgsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDbWEsS0FBSyxHQUFHO0lBQ2IsSUFBSXZqQyxNQUFNbm1CLFNBQVMsQ0FBQyxFQUFFO0lBQ3RCLElBQUkrWSxPQUFPL1ksU0FBUyxDQUFDLEVBQUU7SUFDdkIsSUFBSSxDQUFDdXZDLElBQUksR0FBR3BwQjtJQUNaLElBQUksQ0FBQ3VqQyxLQUFLLEdBQUczd0M7QUFDZjtBQUNBc3ZDLG1CQUFtQm5wRCxTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO0lBQ3JELE9BQU8sSUFBSSxDQUFDMlksSUFBSTtBQUNsQjtBQUNBOFksbUJBQW1CbnBELFNBQVMsQ0FBQzJULElBQUksR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQzA4QixJQUFJLENBQUM1dkMsTUFBTTtBQUN6QjtBQUNBMG9ELG1CQUFtQm5wRCxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0EsY0FBZXhNLENBQUM7SUFDcEUsT0FBTyxJQUFJLENBQUNpcEMsSUFBSSxDQUFDanBDLEVBQUU7QUFDckI7QUFDQStoRCxtQkFBbUJucEQsU0FBUyxDQUFDaTVCLFFBQVEsR0FBRyxTQUFTQTtJQUMvQyxPQUFPLElBQUksQ0FBQ29YLElBQUksQ0FBQyxFQUFFLENBQUMxckMsTUFBTSxDQUFDLElBQUksQ0FBQzByQyxJQUFJLENBQUMsSUFBSSxDQUFDQSxJQUFJLENBQUM1dkMsTUFBTSxHQUFHLEVBQUU7QUFDNUQ7QUFDQTBvRCxtQkFBbUJucEQsU0FBUyxDQUFDc3BELGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQmpoRCxLQUFLO0lBQzlFLElBQUlBLFVBQVUsSUFBSSxDQUFDZ29DLElBQUksQ0FBQzV2QyxNQUFNLEdBQUcsR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ2hELE9BQU8sSUFBSSxDQUFDZ3FELFVBQVUsQ0FBQyxJQUFJLENBQUM3MkMsYUFBYSxDQUFDdkwsUUFBUSxJQUFJLENBQUN1TCxhQUFhLENBQUN2TCxRQUFRO0FBQy9FO0FBQ0E4Z0QsbUJBQW1CbnBELFNBQVMsQ0FBQ29xRCxPQUFPLEdBQUcsU0FBU0EsUUFBU3Z3QyxJQUFJO0lBQzNELElBQUksQ0FBQzJ3QyxLQUFLLEdBQUczd0M7QUFDZjtBQUNBc3ZDLG1CQUFtQm5wRCxTQUFTLENBQUN5cUQsVUFBVSxHQUFHLFNBQVNBLFdBQVludEMsRUFBRSxFQUFFL0wsRUFBRTtJQUNuRSxJQUFJK0wsR0FBRy9ZLFFBQVEsQ0FBQ2dOLEtBQUs7UUFBRSxPQUFPO0lBQUU7SUFDaEMsT0FBT3U0QyxPQUFPbkQsTUFBTSxDQUFDcnBDLElBQUkvTDtBQUMzQjtBQUNBNDNDLG1CQUFtQm5wRCxTQUFTLENBQUNvcEQsT0FBTyxHQUFHLFNBQVNBO0lBQzlDLE9BQU8sSUFBSSxDQUFDb0IsS0FBSztBQUNuQjtBQUNBckIsbUJBQW1CbnBELFNBQVMsQ0FBQ3NxRCxlQUFlLEdBQUcsU0FBU0E7SUFDdEQsSUFBSXhwRCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJaXFELFVBQVU1cEQsU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSW9lLGVBQWVwZSxTQUFTLENBQUMsRUFBRTtRQUMvQixJQUFJLENBQUM2cEQsbUJBQW1CLENBQUNELFNBQVN4ckM7SUFDcEMsT0FBTyxJQUFJcGUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSW1xRCxLQUFLOXBELFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUkrcEQsaUJBQWlCL3BELFNBQVMsQ0FBQyxFQUFFO1FBQ2pDLGlDQUFpQztRQUNqQyxJQUFJcWUsV0FBV3JlLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUl1Z0IsUUFBUSxJQUFJM2QsV0FBV2tuRCxHQUFHcnFDLGVBQWUsQ0FBQ3BCO1FBQzlDLElBQUksQ0FBQ21yQyxlQUFlLENBQUNqcEMsT0FBT3dwQztJQUM5QjtBQUNGO0FBQ0ExQixtQkFBbUJucEQsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU9rWSxVQUFVRSxZQUFZLENBQUMsSUFBSTBrQix3QkFBd0IsSUFBSSxDQUFDc08sSUFBSTtBQUNyRTtBQUNBOFksbUJBQW1CbnBELFNBQVMsQ0FBQzhxRCxXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTyxJQUFJLENBQUNQLFNBQVM7QUFDdkI7QUFDQXBCLG1CQUFtQm5wRCxTQUFTLENBQUMycUQsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCdHBDLEtBQUssRUFBRW5DLFlBQVk7SUFDbEcsSUFBSTZyQyx5QkFBeUI3ckM7SUFDN0IsSUFBSThyQyxlQUFlRCx5QkFBeUI7SUFDNUMsSUFBSUMsZUFBZSxJQUFJLENBQUMzYSxJQUFJLENBQUM1dkMsTUFBTSxFQUFFO1FBQ25DLElBQUl3cUQsU0FBUyxJQUFJLENBQUM1YSxJQUFJLENBQUMyYSxhQUFhO1FBQ3BDLElBQUkzcEMsTUFBTTljLFFBQVEsQ0FBQzBtRCxTQUFTO1lBQzFCRix5QkFBeUJDO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJbEQsS0FBSyxJQUFJLENBQUN5QyxTQUFTLENBQUN0K0MsR0FBRyxDQUFDb1YsT0FBTzBwQztJQUNuQyxPQUFPakQ7QUFDVDtBQUNBcUIsbUJBQW1CbnBELFNBQVMsQ0FBQ2tyRCxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JOLEVBQUUsRUFBRTFyQyxZQUFZLEVBQUVnd0IsU0FBUztJQUNsRyxJQUFJNTBCLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUl3akQsR0FBRy9xQyxrQkFBa0IsSUFBSXpZLElBQUs7UUFDaERrVCxPQUFPZ3dDLGVBQWUsQ0FBQ00sSUFBSTFyQyxjQUFjZ3dCLFdBQVc5bkM7SUFDdEQ7QUFDRjtBQUNBK2hELG1CQUFtQm5wRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTztRQUFDd29EO0tBQXFCO0FBQy9CO0FBQ0FsQixtQkFBbUJucEQsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU9xbkQ7QUFDVDtBQUNBQSxtQkFBbUJnQyxrQkFBa0IsR0FBRyxTQUFTQTtJQUMvQyxJQUFJcnFELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkycUQsYUFBYXRxRCxTQUFTLENBQUMsRUFBRTtRQUM3QixJQUFJdXFELGlCQUFpQixJQUFJNzlCO1FBQ3pCMjdCLG1CQUFtQmdDLGtCQUFrQixDQUFDQyxZQUFZQztRQUNsRCxPQUFPQTtJQUNULE9BQU8sSUFBSXZxRCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNnFELGVBQWV4cUQsU0FBUyxDQUFDLEVBQUU7UUFDL0IsSUFBSXlxRCxtQkFBbUJ6cUQsU0FBUyxDQUFDLEVBQUU7UUFDbkMsSUFBSyxJQUFJc0csSUFBSWtrRCxhQUFhamdDLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUNsRCxJQUFJaWdDLEtBQUtwa0QsRUFBRXNnQixJQUFJO1lBQ2Y4akMsR0FBR1YsV0FBVyxHQUFHckMsYUFBYSxDQUFDOEM7UUFDakM7SUFDRjtBQUNGO0FBRUEsSUFBSUUsY0FBYyxTQUFTQTtJQUN6QixJQUFJLENBQUNudUMsRUFBRSxHQUFHO0lBQ1YsSUFBSSxDQUFDL0wsRUFBRSxHQUFHO0lBQ1YsSUFBSXpRLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUksQ0FBQzZjLEVBQUUsR0FBRyxJQUFJNVo7UUFDZCxJQUFJLENBQUM2TixFQUFFLEdBQUcsSUFBSTdOO0lBQ2hCLE9BQU8sSUFBSTVDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkwOUIsS0FBS3I5QixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUN3YyxFQUFFLEdBQUcsSUFBSTVaLFdBQVd5NkIsR0FBRzdnQixFQUFFO1FBQzlCLElBQUksQ0FBQy9MLEVBQUUsR0FBRyxJQUFJN04sV0FBV3k2QixHQUFHNXNCLEVBQUU7SUFDaEMsT0FBTyxJQUFJelEsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSSxDQUFDNmMsRUFBRSxHQUFHeGMsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSSxDQUFDeVEsRUFBRSxHQUFHelEsU0FBUyxDQUFDLEVBQUU7SUFDeEIsT0FBTyxJQUFJQSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNGxCLEtBQUt2bEIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSW9tQixLQUFLcG1CLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlrQixLQUFLbEIsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSWtSLEtBQUtsUixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUN3YyxFQUFFLEdBQUcsSUFBSTVaLFdBQVcyaUIsSUFBSWE7UUFDN0IsSUFBSSxDQUFDM1YsRUFBRSxHQUFHLElBQUk3TixXQUFXMUIsSUFBSWdRO0lBQy9CO0FBQ0Y7QUFFQSxJQUFJMDVDLHFCQUFxQjtJQUFFem5ELGtCQUFrQjtRQUFFOUQsY0FBYztJQUFLO0FBQUU7QUFDcEVzckQsWUFBWXpyRCxTQUFTLENBQUMyckQsSUFBSSxHQUFHLFNBQVNBO0lBQ3BDLE9BQU9qckQsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQzBjLEVBQUUsQ0FBQzViLENBQUMsRUFBRSxJQUFJLENBQUM2UCxFQUFFLENBQUM3UCxDQUFDO0FBQ3RDO0FBQ0ErcEQsWUFBWXpyRCxTQUFTLENBQUNzUixnQkFBZ0IsR0FBRyxTQUFTQTtJQUNoRCxJQUFJeFEsU0FBUyxDQUFDLEVBQUUsWUFBWTJxRCxhQUFhO1FBQ3ZDLElBQUlHLE1BQU05cUQsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSStxRCxVQUFVcnFDLGFBQWFsUSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNnTSxFQUFFLEVBQUUsSUFBSSxDQUFDL0wsRUFBRSxFQUFFcTZDLElBQUl0dUMsRUFBRTtRQUNwRSxJQUFJd3VDLFVBQVV0cUMsYUFBYWxRLGdCQUFnQixDQUFDLElBQUksQ0FBQ2dNLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUVxNkMsSUFBSXI2QyxFQUFFO1FBQ3BFLElBQUlzNkMsV0FBVyxLQUFLQyxXQUFXLEdBQUc7WUFBRSxPQUFPcHJELEtBQUtDLEdBQUcsQ0FBQ2tyRCxTQUFTQztRQUFTO1FBQ3RFLElBQUlELFdBQVcsS0FBS0MsV0FBVyxHQUFHO1lBQUUsT0FBT3ByRCxLQUFLQyxHQUFHLENBQUNrckQsU0FBU0M7UUFBUztRQUN0RSxPQUFPO0lBQ1QsT0FBTyxJQUFJaHJELFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFZO1FBQzdDLElBQUlzUixJQUFJbFUsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBTzBnQixhQUFhbFEsZ0JBQWdCLENBQUMsSUFBSSxDQUFDZ00sRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRXlEO0lBQ3pEO0FBQ0Y7QUFDQXkyQyxZQUFZenJELFNBQVMsQ0FBQzBxQixVQUFVLEdBQUcsU0FBU0EsV0FBWXFoQyxXQUFXO0lBQ2pFLE9BQU9BLFlBQVk1dkMsZ0JBQWdCLENBQUM7UUFBQyxJQUFJLENBQUNtQixFQUFFO1FBQUUsSUFBSSxDQUFDL0wsRUFBRTtLQUFDO0FBQ3hEO0FBQ0FrNkMsWUFBWXpyRCxTQUFTLENBQUNnc0QsVUFBVSxHQUFHLFNBQVNBO0lBQzFDLE9BQU8sSUFBSSxDQUFDMXVDLEVBQUUsQ0FBQzViLENBQUMsS0FBSyxJQUFJLENBQUM2UCxFQUFFLENBQUM3UCxDQUFDO0FBQ2hDO0FBQ0ErcEQsWUFBWXpyRCxTQUFTLENBQUMyRSxNQUFNLEdBQUcsU0FBU0EsT0FBUUcsQ0FBQztJQUMvQyxJQUFJLENBQUVBLENBQUFBLGFBQWEybUQsV0FBVSxHQUFJO1FBQy9CLE9BQU87SUFDVDtJQUNBLElBQUlqbkQsUUFBUU07SUFDWixPQUFPLElBQUksQ0FBQ3dZLEVBQUUsQ0FBQzNZLE1BQU0sQ0FBQ0gsTUFBTThZLEVBQUUsS0FBSyxJQUFJLENBQUMvTCxFQUFFLENBQUM1TSxNQUFNLENBQUNILE1BQU0rTSxFQUFFO0FBQzVEO0FBQ0FrNkMsWUFBWXpyRCxTQUFTLENBQUNtUyxZQUFZLEdBQUcsU0FBU0EsYUFBY21LLElBQUk7SUFDOUQsSUFBSXN1QyxLQUFLLElBQUkxcEM7SUFDYjBwQyxHQUFHbnJDLG1CQUFtQixDQUFDLElBQUksQ0FBQ25DLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUUrSyxLQUFLZ0IsRUFBRSxFQUFFaEIsS0FBSy9LLEVBQUU7SUFDekQsSUFBSXE1QyxHQUFHMXFDLGVBQWUsSUFBSTtRQUFFLE9BQU8wcUMsR0FBR3JxQyxlQUFlLENBQUM7SUFBRztJQUN6RCxPQUFPO0FBQ1Q7QUFDQWtyQyxZQUFZenJELFNBQVMsQ0FBQ2lzRCxPQUFPLEdBQUcsU0FBU0E7SUFDdkMsSUFBSW5yRCxTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBWTtRQUN0QyxJQUFJc1IsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUlrVSxFQUFFclEsTUFBTSxDQUFDLElBQUksQ0FBQzJZLEVBQUUsS0FBS3RJLEVBQUVyUSxNQUFNLENBQUMsSUFBSSxDQUFDNE0sRUFBRSxHQUFHO1lBQUUsT0FBTyxJQUFJN04sV0FBV3NSO1FBQUc7UUFDdkUsSUFBSXpILElBQUksSUFBSSxDQUFDMitDLGdCQUFnQixDQUFDbDNDO1FBQzlCLElBQUlnWCxRQUFRLElBQUl0b0I7UUFDaEJzb0IsTUFBTXRxQixDQUFDLEdBQUcsSUFBSSxDQUFDNGIsRUFBRSxDQUFDNWIsQ0FBQyxHQUFHNkwsSUFBSyxLQUFJLENBQUNnRSxFQUFFLENBQUM3UCxDQUFDLEdBQUcsSUFBSSxDQUFDNGIsRUFBRSxDQUFDNWIsQ0FBQztRQUNoRHNxQixNQUFNcm9CLENBQUMsR0FBRyxJQUFJLENBQUMyWixFQUFFLENBQUMzWixDQUFDLEdBQUc0SixJQUFLLEtBQUksQ0FBQ2dFLEVBQUUsQ0FBQzVOLENBQUMsR0FBRyxJQUFJLENBQUMyWixFQUFFLENBQUMzWixDQUFDO1FBQ2hELE9BQU9xb0I7SUFDVCxPQUFPLElBQUlsckIsU0FBUyxDQUFDLEVBQUUsWUFBWTJxRCxhQUFhO1FBQzlDLElBQUlHLE1BQU05cUQsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSXFyRCxNQUFNLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUNOLElBQUl0dUMsRUFBRTtRQUN0QyxJQUFJOHVDLE1BQU0sSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ04sSUFBSXI2QyxFQUFFO1FBQ3RDLElBQUk0NkMsT0FBTyxPQUFPQyxPQUFPLEtBQUs7WUFBRSxPQUFPO1FBQUs7UUFDNUMsSUFBSUQsT0FBTyxPQUFPQyxPQUFPLEtBQUs7WUFBRSxPQUFPO1FBQUs7UUFDNUMsSUFBSUMsUUFBUSxJQUFJLENBQUNKLE9BQU8sQ0FBQ0wsSUFBSXR1QyxFQUFFO1FBQy9CLElBQUk2dUMsTUFBTSxLQUFLO1lBQUVFLFFBQVEsSUFBSSxDQUFDL3VDLEVBQUU7UUFBRTtRQUNsQyxJQUFJNnVDLE1BQU0sS0FBSztZQUFFRSxRQUFRLElBQUksQ0FBQzk2QyxFQUFFO1FBQUU7UUFDbEMsSUFBSSs2QyxRQUFRLElBQUksQ0FBQ0wsT0FBTyxDQUFDTCxJQUFJcjZDLEVBQUU7UUFDL0IsSUFBSTY2QyxNQUFNLEtBQUs7WUFBRUUsUUFBUSxJQUFJLENBQUNodkMsRUFBRTtRQUFFO1FBQ2xDLElBQUk4dUMsTUFBTSxLQUFLO1lBQUVFLFFBQVEsSUFBSSxDQUFDLzZDLEVBQUU7UUFBRTtRQUNsQyxPQUFPLElBQUlrNkMsWUFBWVksT0FBT0M7SUFDaEM7QUFDRjtBQUNBYixZQUFZenJELFNBQVMsQ0FBQzhxQixTQUFTLEdBQUcsU0FBU0E7SUFDekMsSUFBSSxJQUFJLENBQUN2WixFQUFFLENBQUMxTSxTQUFTLENBQUMsSUFBSSxDQUFDeVksRUFBRSxJQUFJLEdBQUc7UUFBRSxJQUFJLENBQUM2VCxPQUFPO0lBQUk7QUFDeEQ7QUFDQXM2QixZQUFZenJELFNBQVMsQ0FBQ3UzQyxLQUFLLEdBQUcsU0FBU0E7SUFDckMsT0FBTzcyQyxLQUFLODJDLEtBQUssQ0FBQyxJQUFJLENBQUNqbUMsRUFBRSxDQUFDNU4sQ0FBQyxHQUFHLElBQUksQ0FBQzJaLEVBQUUsQ0FBQzNaLENBQUMsRUFBRSxJQUFJLENBQUM0TixFQUFFLENBQUM3UCxDQUFDLEdBQUcsSUFBSSxDQUFDNGIsRUFBRSxDQUFDNWIsQ0FBQztBQUNoRTtBQUNBK3BELFlBQVl6ckQsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBLGNBQWV4TSxDQUFDO0lBQzdELElBQUlBLE1BQU0sR0FBRztRQUFFLE9BQU8sSUFBSSxDQUFDa1csRUFBRTtJQUFDO0lBQzlCLE9BQU8sSUFBSSxDQUFDL0wsRUFBRTtBQUNoQjtBQUNBazZDLFlBQVl6ckQsU0FBUyxDQUFDdXNELHFCQUFxQixHQUFHLFNBQVNBLHNCQUF1QnYzQyxDQUFDO0lBQzdFLE9BQU93TSxhQUFhcUcsOEJBQThCLENBQUM3UyxHQUFHLElBQUksQ0FBQ3NJLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFO0FBQ3hFO0FBQ0FrNkMsWUFBWXpyRCxTQUFTLENBQUN3c0QsSUFBSSxHQUFHLFNBQVNBO0lBQ3BDLE9BQU85ckQsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQzBjLEVBQUUsQ0FBQzNaLENBQUMsRUFBRSxJQUFJLENBQUM0TixFQUFFLENBQUM1TixDQUFDO0FBQ3RDO0FBQ0E4bkQsWUFBWXpyRCxTQUFTLENBQUN5c0QsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU9oQixZQUFZZ0IsUUFBUSxDQUFDLElBQUksQ0FBQ252QyxFQUFFLEVBQUUsSUFBSSxDQUFDL0wsRUFBRTtBQUM5QztBQUNBazZDLFlBQVl6ckQsU0FBUyxDQUFDa3NELGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQmwzQyxDQUFDO0lBQ25FLElBQUlBLEVBQUVyUSxNQUFNLENBQUMsSUFBSSxDQUFDMlksRUFBRSxHQUFHO1FBQUUsT0FBTztJQUFJO0lBQ3BDLElBQUl0SSxFQUFFclEsTUFBTSxDQUFDLElBQUksQ0FBQzRNLEVBQUUsR0FBRztRQUFFLE9BQU87SUFBSTtJQUNwQyxJQUFJcE0sS0FBSyxJQUFJLENBQUNvTSxFQUFFLENBQUM3UCxDQUFDLEdBQUcsSUFBSSxDQUFDNGIsRUFBRSxDQUFDNWIsQ0FBQztJQUM5QixJQUFJMEQsS0FBSyxJQUFJLENBQUNtTSxFQUFFLENBQUM1TixDQUFDLEdBQUcsSUFBSSxDQUFDMlosRUFBRSxDQUFDM1osQ0FBQztJQUM5QixJQUFJdU4sTUFBTS9MLEtBQUtBLEtBQUtDLEtBQUtBO0lBQ3pCLElBQUk4TCxPQUFPLEtBQUs7UUFBRSxPQUFPck8sT0FBTytDLEdBQUc7SUFBQztJQUNwQyxJQUFJMkgsSUFBSSxDQUFDLENBQUN5SCxFQUFFdFQsQ0FBQyxHQUFHLElBQUksQ0FBQzRiLEVBQUUsQ0FBQzViLENBQUMsSUFBSXlELEtBQUssQ0FBQzZQLEVBQUVyUixDQUFDLEdBQUcsSUFBSSxDQUFDMlosRUFBRSxDQUFDM1osQ0FBQyxJQUFJeUIsRUFBQyxJQUFLOEw7SUFDNUQsT0FBTzNEO0FBQ1Q7QUFDQWsrQyxZQUFZenJELFNBQVMsQ0FBQzBzRCxhQUFhLEdBQUcsU0FBU0EsY0FBZXB3QyxJQUFJO0lBQ2hFLElBQUkrRSxRQUFRLElBQUksQ0FBQ2xQLFlBQVksQ0FBQ21LO0lBQzlCLElBQUkrRSxVQUFVLE1BQU07UUFDbEIsT0FBTztZQUFDQTtZQUFPQTtTQUFNO0lBQ3ZCO0lBQ0EsSUFBSXNyQyxZQUFZLElBQUk1c0QsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDbEMsSUFBSTBuQixjQUFjbGxCLE9BQU9FLFNBQVM7SUFDbEMsSUFBSXlkLE9BQU87SUFDWCxJQUFJb3NDLFVBQVUsSUFBSSxDQUFDQyxZQUFZLENBQUN2d0MsS0FBS2dCLEVBQUU7SUFDdkN5SyxjQUFjNmtDLFFBQVFybkQsUUFBUSxDQUFDK1csS0FBS2dCLEVBQUU7SUFDdENxdkMsU0FBUyxDQUFDLEVBQUUsR0FBR0M7SUFDZkQsU0FBUyxDQUFDLEVBQUUsR0FBR3J3QyxLQUFLZ0IsRUFBRTtJQUN0QixJQUFJd3ZDLFVBQVUsSUFBSSxDQUFDRCxZQUFZLENBQUN2d0MsS0FBSy9LLEVBQUU7SUFDdkNpUCxPQUFPc3NDLFFBQVF2bkQsUUFBUSxDQUFDK1csS0FBSy9LLEVBQUU7SUFDL0IsSUFBSWlQLE9BQU91SCxhQUFhO1FBQ3RCQSxjQUFjdkg7UUFDZG1zQyxTQUFTLENBQUMsRUFBRSxHQUFHRztRQUNmSCxTQUFTLENBQUMsRUFBRSxHQUFHcndDLEtBQUsvSyxFQUFFO0lBQ3hCO0lBQ0EsSUFBSXc3QyxVQUFVendDLEtBQUt1d0MsWUFBWSxDQUFDLElBQUksQ0FBQ3Z2QyxFQUFFO0lBQ3ZDa0QsT0FBT3VzQyxRQUFReG5ELFFBQVEsQ0FBQyxJQUFJLENBQUMrWCxFQUFFO0lBQy9CLElBQUlrRCxPQUFPdUgsYUFBYTtRQUN0QkEsY0FBY3ZIO1FBQ2Rtc0MsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNydkMsRUFBRTtRQUN0QnF2QyxTQUFTLENBQUMsRUFBRSxHQUFHSTtJQUNqQjtJQUNBLElBQUlDLFVBQVUxd0MsS0FBS3V3QyxZQUFZLENBQUMsSUFBSSxDQUFDdDdDLEVBQUU7SUFDdkNpUCxPQUFPd3NDLFFBQVF6bkQsUUFBUSxDQUFDLElBQUksQ0FBQ2dNLEVBQUU7SUFDL0IsSUFBSWlQLE9BQU91SCxhQUFhO1FBQ3RCQSxjQUFjdkg7UUFDZG1zQyxTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3A3QyxFQUFFO1FBQ3RCbzdDLFNBQVMsQ0FBQyxFQUFFLEdBQUdLO0lBQ2pCO0lBQ0EsT0FBT0w7QUFDVDtBQUNBbEIsWUFBWXpyRCxTQUFTLENBQUM2c0QsWUFBWSxHQUFHLFNBQVNBLGFBQWM3M0MsQ0FBQztJQUMzRCxJQUFJaTRDLFNBQVMsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQ2wzQztJQUNuQyxJQUFJaTRDLFNBQVMsS0FBS0EsU0FBUyxHQUFHO1FBQzVCLE9BQU8sSUFBSSxDQUFDaEIsT0FBTyxDQUFDajNDO0lBQ3RCO0lBQ0EsSUFBSThLLFFBQVEsSUFBSSxDQUFDeEMsRUFBRSxDQUFDL1gsUUFBUSxDQUFDeVA7SUFDN0IsSUFBSWdMLFFBQVEsSUFBSSxDQUFDek8sRUFBRSxDQUFDaE0sUUFBUSxDQUFDeVA7SUFDN0IsSUFBSThLLFFBQVFFLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQzFDLEVBQUU7SUFBQztJQUNwQyxPQUFPLElBQUksQ0FBQy9MLEVBQUU7QUFDaEI7QUFDQWs2QyxZQUFZenJELFNBQVMsQ0FBQ2t0RCxJQUFJLEdBQUcsU0FBU0E7SUFDcEMsT0FBT3hzRCxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDMmMsRUFBRSxDQUFDNWIsQ0FBQyxFQUFFLElBQUksQ0FBQzZQLEVBQUUsQ0FBQzdQLENBQUM7QUFDdEM7QUFDQStwRCxZQUFZenJELFNBQVMsQ0FBQ21xQixTQUFTLEdBQUcsU0FBU0E7SUFDekMsT0FBTyxJQUFJLENBQUM3TSxFQUFFLENBQUMvWCxRQUFRLENBQUMsSUFBSSxDQUFDZ00sRUFBRTtBQUNqQztBQUNBazZDLFlBQVl6ckQsU0FBUyxDQUFDNkUsU0FBUyxHQUFHLFNBQVNBLFVBQVdDLENBQUM7SUFDckQsSUFBSU4sUUFBUU07SUFDWixJQUFJcW9ELFFBQVEsSUFBSSxDQUFDN3ZDLEVBQUUsQ0FBQ3pZLFNBQVMsQ0FBQ0wsTUFBTThZLEVBQUU7SUFDdEMsSUFBSTZ2QyxVQUFVLEdBQUc7UUFBRSxPQUFPQTtJQUFNO0lBQ2hDLE9BQU8sSUFBSSxDQUFDNTdDLEVBQUUsQ0FBQzFNLFNBQVMsQ0FBQ0wsTUFBTStNLEVBQUU7QUFDbkM7QUFDQWs2QyxZQUFZenJELFNBQVMsQ0FBQ214QixPQUFPLEdBQUcsU0FBU0E7SUFDdkMsSUFBSWdkLE9BQU8sSUFBSSxDQUFDN3dCLEVBQUU7SUFDbEIsSUFBSSxDQUFDQSxFQUFFLEdBQUcsSUFBSSxDQUFDL0wsRUFBRTtJQUNqQixJQUFJLENBQUNBLEVBQUUsR0FBRzQ4QjtBQUNaO0FBQ0FzZCxZQUFZenJELFNBQVMsQ0FBQzRwQixVQUFVLEdBQUcsU0FBU0EsV0FBWXBsQixLQUFLO0lBQzNELE9BQU8sSUFBSSxDQUFDOFksRUFBRSxDQUFDM1ksTUFBTSxDQUFDSCxNQUFNOFksRUFBRSxLQUN2QixLQUFJLENBQUMvTCxFQUFFLENBQUM1TSxNQUFNLENBQUNILE1BQU0rTSxFQUFFLEtBQUssSUFBSSxDQUFDK0wsRUFBRSxDQUFDM1ksTUFBTSxDQUFDSCxNQUFNK00sRUFBRSxNQUNuRCxJQUFJLENBQUNBLEVBQUUsQ0FBQzVNLE1BQU0sQ0FBQ0gsTUFBTThZLEVBQUU7QUFDaEM7QUFDQW11QyxZQUFZenJELFNBQVMsQ0FBQ290RCxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0I5d0MsSUFBSTtJQUN0RSxJQUFJO1FBQ0YsSUFBSStFLFFBQVF2TSxZQUFZM0MsWUFBWSxDQUFDLElBQUksQ0FBQ21MLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUUrSyxLQUFLZ0IsRUFBRSxFQUFFaEIsS0FBSy9LLEVBQUU7UUFDdkUsT0FBTzhQO0lBQ1QsRUFBRSxPQUFPM1EsSUFBSTtRQUNYLElBQUlBLGNBQWMyRCwyQkFBMkIsQ0FBQyxPQUFPO1lBQUUsTUFBTTNEO1FBQUc7SUFDbEUsU0FBVSxDQUFDO0lBQ1gsT0FBTztBQUNUO0FBQ0ErNkMsWUFBWXpyRCxTQUFTLENBQUNxdEQsSUFBSSxHQUFHLFNBQVNBO0lBQ3BDLE9BQU8zc0QsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQzJjLEVBQUUsQ0FBQzNaLENBQUMsRUFBRSxJQUFJLENBQUM0TixFQUFFLENBQUM1TixDQUFDO0FBQ3RDO0FBQ0E4bkQsWUFBWXpyRCxTQUFTLENBQUNzdEQsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCQyxxQkFBcUIsRUFBRUMsY0FBYztJQUN2RyxJQUFJQyxPQUFPLElBQUksQ0FBQ253QyxFQUFFLENBQUM1YixDQUFDLEdBQUc2ckQsd0JBQXlCLEtBQUksQ0FBQ2g4QyxFQUFFLENBQUM3UCxDQUFDLEdBQUcsSUFBSSxDQUFDNGIsRUFBRSxDQUFDNWIsQ0FBQztJQUNyRSxJQUFJZ3NELE9BQU8sSUFBSSxDQUFDcHdDLEVBQUUsQ0FBQzNaLENBQUMsR0FBRzRwRCx3QkFBeUIsS0FBSSxDQUFDaDhDLEVBQUUsQ0FBQzVOLENBQUMsR0FBRyxJQUFJLENBQUMyWixFQUFFLENBQUMzWixDQUFDO0lBQ3JFLElBQUl3QixLQUFLLElBQUksQ0FBQ29NLEVBQUUsQ0FBQzdQLENBQUMsR0FBRyxJQUFJLENBQUM0YixFQUFFLENBQUM1YixDQUFDO0lBQzlCLElBQUkwRCxLQUFLLElBQUksQ0FBQ21NLEVBQUUsQ0FBQzVOLENBQUMsR0FBRyxJQUFJLENBQUMyWixFQUFFLENBQUMzWixDQUFDO0lBQzlCLElBQUl1TixNQUFNeFEsS0FBSzRFLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0E7SUFDbkMsSUFBSXVvRCxLQUFLO0lBQ1QsSUFBSUMsS0FBSztJQUNULElBQUlKLG1CQUFtQixLQUFLO1FBQzFCLElBQUl0OEMsT0FBTyxLQUFLO1lBQUUsTUFBTSxJQUFJN08sTUFBTTtRQUF1RDtRQUN6RnNyRCxLQUFLSCxpQkFBaUJyb0QsS0FBSytMO1FBQzNCMDhDLEtBQUtKLGlCQUFpQnBvRCxLQUFLOEw7SUFDN0I7SUFDQSxJQUFJMjhDLFVBQVVKLE9BQU9HO0lBQ3JCLElBQUlFLFVBQVVKLE9BQU9DO0lBQ3JCLElBQUkzaEMsUUFBUSxJQUFJdG9CLFdBQVdtcUQsU0FBU0M7SUFDcEMsT0FBTzloQztBQUNUO0FBQ0F5L0IsWUFBWXpyRCxTQUFTLENBQUMrdEQsY0FBYyxHQUFHLFNBQVNBO0lBQzlDLElBQUlqdEQsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSTA5QixLQUFLcjlCLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQ2l0RCxjQUFjLENBQUM1dkIsR0FBRzdnQixFQUFFLEVBQUU2Z0IsR0FBRzVzQixFQUFFO0lBQ2xDLE9BQU8sSUFBSXpRLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk2YyxLQUFLeGMsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXlRLEtBQUt6USxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUN3YyxFQUFFLENBQUM1YixDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQztRQUNoQixJQUFJLENBQUM0YixFQUFFLENBQUMzWixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQztRQUNoQixJQUFJLENBQUM0TixFQUFFLENBQUM3UCxDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQztRQUNoQixJQUFJLENBQUM2UCxFQUFFLENBQUM1TixDQUFDLEdBQUc0TixHQUFHNU4sQ0FBQztJQUNsQjtBQUNGO0FBQ0E4bkQsWUFBWXpyRCxTQUFTLENBQUNndUQsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQkMsT0FBTztJQUN2RSxJQUFJQyxVQUFVLElBQUksQ0FBQ2hDLGdCQUFnQixDQUFDK0I7SUFDcEMsSUFBSUMsVUFBVSxLQUFLO1FBQUVBLFVBQVU7SUFBSyxPQUFPLElBQUlBLFVBQVUsT0FBT3JyRCxPQUFPckIsS0FBSyxDQUFDMHNELFVBQVU7UUFBRUEsVUFBVTtJQUFLO0lBQ3hHLE9BQU9BO0FBQ1Q7QUFDQXpDLFlBQVl6ckQsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8saUJBQWlCLElBQUksQ0FBQ3FZLEVBQUUsQ0FBQzViLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQzRiLEVBQUUsQ0FBQzNaLENBQUMsR0FBRyxPQUFPLElBQUksQ0FBQzROLEVBQUUsQ0FBQzdQLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQzZQLEVBQUUsQ0FBQzVOLENBQUMsR0FBRztBQUM3RjtBQUNBOG5ELFlBQVl6ckQsU0FBUyxDQUFDbXVELFlBQVksR0FBRyxTQUFTQTtJQUM1QyxPQUFPLElBQUksQ0FBQzd3QyxFQUFFLENBQUMzWixDQUFDLEtBQUssSUFBSSxDQUFDNE4sRUFBRSxDQUFDNU4sQ0FBQztBQUNoQztBQUNBOG5ELFlBQVl6ckQsU0FBUyxDQUFDdUYsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLElBQUl6RSxTQUFTLENBQUMsRUFBRSxZQUFZMnFELGFBQWE7UUFDdkMsSUFBSXR0QixLQUFLcjlCLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLE9BQU8wZ0IsYUFBYWdGLGdCQUFnQixDQUFDLElBQUksQ0FBQ2xKLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUU0c0IsR0FBRzdnQixFQUFFLEVBQUU2Z0IsR0FBRzVzQixFQUFFO0lBQ3JFLE9BQU8sSUFBSXpRLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFZO1FBQzdDLElBQUlzUixJQUFJbFUsU0FBUyxDQUFDLEVBQUU7UUFDcEIsT0FBTzBnQixhQUFhK0MsaUJBQWlCLENBQUN2UCxHQUFHLElBQUksQ0FBQ3NJLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFO0lBQzNEO0FBQ0Y7QUFDQWs2QyxZQUFZenJELFNBQVMsQ0FBQ291RCxVQUFVLEdBQUcsU0FBU0EsV0FBWWIscUJBQXFCO0lBQzNFLElBQUl2aEMsUUFBUSxJQUFJdG9CO0lBQ2hCc29CLE1BQU10cUIsQ0FBQyxHQUFHLElBQUksQ0FBQzRiLEVBQUUsQ0FBQzViLENBQUMsR0FBRzZyRCx3QkFBeUIsS0FBSSxDQUFDaDhDLEVBQUUsQ0FBQzdQLENBQUMsR0FBRyxJQUFJLENBQUM0YixFQUFFLENBQUM1YixDQUFDO0lBQ3BFc3FCLE1BQU1yb0IsQ0FBQyxHQUFHLElBQUksQ0FBQzJaLEVBQUUsQ0FBQzNaLENBQUMsR0FBRzRwRCx3QkFBeUIsS0FBSSxDQUFDaDhDLEVBQUUsQ0FBQzVOLENBQUMsR0FBRyxJQUFJLENBQUMyWixFQUFFLENBQUMzWixDQUFDO0lBQ3BFLE9BQU9xb0I7QUFDVDtBQUNBeS9CLFlBQVl6ckQsU0FBUyxDQUFDd0YsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLElBQUk2b0QsUUFBUXhyRCxPQUFPSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNxYSxFQUFFLENBQUM1YixDQUFDO0lBQzdDMnNELFNBQVN4ckQsT0FBT0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDcWEsRUFBRSxDQUFDM1osQ0FBQyxJQUFJO0lBQzlDLElBQUkycUQsUUFBUTV0RCxLQUFLZSxLQUFLLENBQUM0c0QsU0FBUzN0RCxLQUFLZSxLQUFLLENBQUM0c0QsU0FBUztJQUNwRCxJQUFJRSxRQUFRMXJELE9BQU9JLGdCQUFnQixDQUFDLElBQUksQ0FBQ3NPLEVBQUUsQ0FBQzdQLENBQUM7SUFDN0M2c0QsU0FBUzFyRCxPQUFPSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNzTyxFQUFFLENBQUM1TixDQUFDLElBQUk7SUFDOUMsSUFBSTZxRCxRQUFROXRELEtBQUtlLEtBQUssQ0FBQzhzRCxTQUFTN3RELEtBQUtlLEtBQUssQ0FBQzhzRCxTQUFTO0lBQ3BELE9BQU9ELFFBQVFFO0FBQ2pCO0FBQ0EvQyxZQUFZenJELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMzQyxPQUFPO1FBQUN5QjtRQUFZRztLQUFhO0FBQ25DO0FBQ0Fnb0QsWUFBWXpyRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDeEMsT0FBTzJwRDtBQUNUO0FBQ0FBLFlBQVlnQixRQUFRLEdBQUcsU0FBU0EsU0FBVW52QyxFQUFFLEVBQUUvTCxFQUFFO0lBQzlDLE9BQU8sSUFBSTdOLFdBQVcsQ0FBQzRaLEdBQUc1YixDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQyxJQUFJLEdBQUcsQ0FBQzRiLEdBQUczWixDQUFDLEdBQUc0TixHQUFHNU4sQ0FBQyxJQUFJO0FBQzNEO0FBQ0ErbkQsbUJBQW1Cem5ELGdCQUFnQixDQUFDYixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQW9CO0FBRW5GbkQsT0FBT29ELGdCQUFnQixDQUFFb29ELGFBQWFDO0FBRXRDLElBQUkrQyw2QkFBNkIsU0FBU0E7SUFDeEMsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSXg0QztJQUNwQixJQUFJLENBQUN5NEMsUUFBUSxHQUFHLElBQUl6NEM7SUFDcEIsSUFBSSxDQUFDMDRDLFlBQVksR0FBRyxJQUFJbkQ7SUFDeEIsSUFBSSxDQUFDb0QsWUFBWSxHQUFHLElBQUlwRDtBQUMxQjtBQUNBZ0QsMkJBQTJCenVELFNBQVMsQ0FBQzh1RCxPQUFPLEdBQUcsU0FBU0E7SUFDdEQsSUFBSWh1RCxVQUFVTCxNQUFNLEtBQUssR0FBRztJQUMxQiw0QkFBNEI7SUFDNUIsNEJBQTRCO0lBQzlCLE9BQU8sSUFBSUssVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXN1RCxNQUFNanVELFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUlrdUQsU0FBU2x1RCxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJbXVELE1BQU1udUQsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSW91RCxTQUFTcHVELFNBQVMsQ0FBQyxFQUFFO1FBQ3pCaXVELElBQUlJLGNBQWMsQ0FBQ0gsUUFBUSxJQUFJLENBQUNKLFlBQVk7UUFDNUNLLElBQUlFLGNBQWMsQ0FBQ0QsUUFBUSxJQUFJLENBQUNMLFlBQVk7UUFDNUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDRixZQUFZLEVBQUUsSUFBSSxDQUFDQyxZQUFZO0lBQ25EO0FBQ0Y7QUFDQUosMkJBQTJCenVELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxRCxPQUFPLEVBQUU7QUFDWDtBQUNBNHNELDJCQUEyQnp1RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdkQsT0FBTzJzRDtBQUNUO0FBRUEsSUFBSVcsZ0JBQWdCLFNBQVNBO0lBQzNCLElBQUksQ0FBQy9lLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ2dmLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDL2pCLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ2drQixRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJdm9DLE1BQU1ubUIsU0FBUyxDQUFDLEVBQUU7SUFDdEIsSUFBSTZ1QixRQUFRN3VCLFNBQVMsQ0FBQyxFQUFFO0lBQ3hCLElBQUk4dUIsTUFBTTl1QixTQUFTLENBQUMsRUFBRTtJQUN0QixJQUFJMnVELFVBQVUzdUQsU0FBUyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxDQUFDdXZDLElBQUksR0FBR3BwQjtJQUNaLElBQUksQ0FBQ29vQyxNQUFNLEdBQUcxL0I7SUFDZCxJQUFJLENBQUMyL0IsSUFBSSxHQUFHMS9CO0lBQ1osSUFBSSxDQUFDMi9CLFFBQVEsR0FBR0U7QUFDbEI7QUFDQUwsY0FBY3B2RCxTQUFTLENBQUNtdkQsY0FBYyxHQUFHLFNBQVNBLGVBQWdCOW1ELEtBQUssRUFBRTgxQixFQUFFO0lBQ3pFQSxHQUFHN2dCLEVBQUUsR0FBRyxJQUFJLENBQUMreUIsSUFBSSxDQUFDaG9DLE1BQU07SUFDeEI4MUIsR0FBRzVzQixFQUFFLEdBQUcsSUFBSSxDQUFDOCtCLElBQUksQ0FBQ2hvQyxRQUFRLEVBQUU7QUFDOUI7QUFDQSttRCxjQUFjcHZELFNBQVMsQ0FBQzB2RCxhQUFhLEdBQUcsU0FBU0EsY0FBZTFLLFNBQVMsRUFBRTJLLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxHQUFHO0lBQzFGLElBQUl2eUMsS0FBSyxJQUFJLENBQUMreUIsSUFBSSxDQUFDc2YsT0FBTztJQUMxQixJQUFJcCtDLEtBQUssSUFBSSxDQUFDOCtCLElBQUksQ0FBQ3VmLEtBQUs7SUFDeEJDLElBQUluQixRQUFRLENBQUNsbEQsSUFBSSxDQUFDOFQsSUFBSS9MO0lBQ3RCLElBQUlxK0MsT0FBT0QsV0FBVyxHQUFHO1FBQ3ZCRSxJQUFJQyxNQUFNLENBQUMsSUFBSSxFQUFFSDtRQUNqQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUMzSyxVQUFVL3RDLFVBQVUsQ0FBQzQ0QyxJQUFJbkIsUUFBUSxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQ3ZELElBQUl0OUIsTUFBTTF3QixLQUFLZSxLQUFLLENBQUMsQ0FBQ2t1RCxTQUFTQyxJQUFHLElBQUs7SUFDdkMsSUFBSUQsU0FBU3YrQixLQUFLO1FBQ2hCLElBQUksQ0FBQ3MrQixhQUFhLENBQUMxSyxXQUFXMkssUUFBUXYrQixLQUFLeStCO0lBQzdDO0lBQ0EsSUFBSXorQixNQUFNdytCLE1BQU07UUFDZCxJQUFJLENBQUNGLGFBQWEsQ0FBQzFLLFdBQVc1ekIsS0FBS3crQixNQUFNQztJQUMzQztBQUNGO0FBQ0FULGNBQWNwdkQsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQTtJQUM5QyxJQUFJcGQsU0FBUyxJQUFJO0lBRW5CLElBQUkwUixRQUFRLElBQUlqc0IsTUFBTSxJQUFJLENBQUN1dkQsSUFBSSxHQUFHLElBQUksQ0FBQ0QsTUFBTSxHQUFHLEdBQUdodkQsSUFBSSxDQUFDO0lBQ3hELElBQUlnSSxRQUFRO0lBQ1osSUFBSyxJQUFJakIsSUFBSSxJQUFJLENBQUNpb0QsTUFBTSxFQUFFam9ELEtBQUssSUFBSSxDQUFDa29ELElBQUksRUFBRWxvRCxJQUFLO1FBQzdDNGtCLEtBQUssQ0FBQzNqQixRQUFRLEdBQUdpUyxPQUFPKzFCLElBQUksQ0FBQ2pwQyxFQUFFO0lBQ2pDO0lBQ0EsT0FBTzRrQjtBQUNUO0FBQ0FvakMsY0FBY3B2RCxTQUFTLENBQUMrdkQsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQkMsRUFBRSxFQUFFQyxHQUFHO0lBQ3pFLElBQUksQ0FBQ0MsdUJBQXVCLENBQUMsSUFBSSxDQUFDYixNQUFNLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUVVLElBQUlBLEdBQUdYLE1BQU0sRUFBRVcsR0FBR1YsSUFBSSxFQUFFVztBQUMvRTtBQUNBYixjQUFjcHZELFNBQVMsQ0FBQ213RCxLQUFLLEdBQUcsU0FBU0EsTUFBT0MsRUFBRTtJQUNoRCxJQUFJLENBQUNaLEdBQUcsR0FBR1k7QUFDYjtBQUNBaEIsY0FBY3B2RCxTQUFTLENBQUM4dkQsTUFBTSxHQUFHLFNBQVNBLE9BQVE5SyxTQUFTLEVBQUU2SyxHQUFHO0lBQzlELElBQUksQ0FBQ0gsYUFBYSxDQUFDMUssV0FBVyxJQUFJLENBQUNxSyxNQUFNLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUVPO0FBQ3hEO0FBQ0FULGNBQWNwdkQsU0FBUyxDQUFDeXFCLFdBQVcsR0FBRyxTQUFTQTtJQUM3QyxJQUFJLElBQUksQ0FBQzhnQixJQUFJLEtBQUssTUFBTTtRQUN0QixJQUFJanVCLEtBQUssSUFBSSxDQUFDK3lCLElBQUksQ0FBQyxJQUFJLENBQUNnZixNQUFNLENBQUM7UUFDL0IsSUFBSTk5QyxLQUFLLElBQUksQ0FBQzgrQixJQUFJLENBQUMsSUFBSSxDQUFDaWYsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQy9qQixJQUFJLEdBQUcsSUFBSXIxQixTQUFTb0gsSUFBSS9MO0lBQy9CO0lBQ0EsT0FBTyxJQUFJLENBQUNnNkIsSUFBSTtBQUNsQjtBQUNBNmpCLGNBQWNwdkQsU0FBUyxDQUFDcXdELFdBQVcsR0FBRyxTQUFTQTtJQUM3QyxPQUFPLElBQUksQ0FBQ2YsSUFBSTtBQUNsQjtBQUNBRixjQUFjcHZELFNBQVMsQ0FBQ3N3RCxhQUFhLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxJQUFJLENBQUNqQixNQUFNO0FBQ3BCO0FBQ0FELGNBQWNwdkQsU0FBUyxDQUFDdXdELFVBQVUsR0FBRyxTQUFTQTtJQUM1QyxPQUFPLElBQUksQ0FBQ2hCLFFBQVE7QUFDdEI7QUFDQUgsY0FBY3B2RCxTQUFTLENBQUN3d0QsS0FBSyxHQUFHLFNBQVNBO0lBQ3ZDLE9BQU8sSUFBSSxDQUFDaEIsR0FBRztBQUNqQjtBQUNBSixjQUFjcHZELFNBQVMsQ0FBQ2t3RCx1QkFBdUIsR0FBRyxTQUFTQSx3QkFBeUJQLE1BQU0sRUFBRUMsSUFBSSxFQUFFSSxFQUFFLEVBQUVoQixNQUFNLEVBQUV5QixJQUFJLEVBQUVSLEdBQUc7SUFDckgsSUFBSVMsTUFBTSxJQUFJLENBQUNyZ0IsSUFBSSxDQUFDc2YsT0FBTztJQUMzQixJQUFJZ0IsTUFBTSxJQUFJLENBQUN0Z0IsSUFBSSxDQUFDdWYsS0FBSztJQUN6QixJQUFJZ0IsTUFBTVosR0FBRzNmLElBQUksQ0FBQzJlLE9BQU87SUFDekIsSUFBSTZCLE1BQU1iLEdBQUczZixJQUFJLENBQUNvZ0IsS0FBSztJQUN2QixJQUFJYixPQUFPRCxXQUFXLEtBQUtjLE9BQU96QixXQUFXLEdBQUc7UUFDOUNpQixJQUFJbkIsT0FBTyxDQUFDLElBQUksRUFBRWEsUUFBUUssSUFBSWhCO1FBQzlCLE9BQU87SUFDVDtJQUNBaUIsSUFBSXZCLFFBQVEsQ0FBQ2xsRCxJQUFJLENBQUNrbkQsS0FBS0M7SUFDdkJWLElBQUl0QixRQUFRLENBQUNubEQsSUFBSSxDQUFDb25ELEtBQUtDO0lBQ3ZCLElBQUksQ0FBQ1osSUFBSXZCLFFBQVEsQ0FBQ3ozQyxVQUFVLENBQUNnNUMsSUFBSXRCLFFBQVEsR0FBRztRQUFFLE9BQU87SUFBSztJQUMxRCxJQUFJbUMsT0FBT3B3RCxLQUFLZSxLQUFLLENBQUMsQ0FBQ2t1RCxTQUFTQyxJQUFHLElBQUs7SUFDeEMsSUFBSW1CLE9BQU9yd0QsS0FBS2UsS0FBSyxDQUFDLENBQUN1dEQsU0FBU3lCLElBQUcsSUFBSztJQUN4QyxJQUFJZCxTQUFTbUIsTUFBTTtRQUNqQixJQUFJOUIsU0FBUytCLE1BQU07WUFBRSxJQUFJLENBQUNiLHVCQUF1QixDQUFDUCxRQUFRbUIsTUFBTWQsSUFBSWhCLFFBQVErQixNQUFNZDtRQUFNO1FBQ3hGLElBQUljLE9BQU9OLE1BQU07WUFBRSxJQUFJLENBQUNQLHVCQUF1QixDQUFDUCxRQUFRbUIsTUFBTWQsSUFBSWUsTUFBTU4sTUFBTVI7UUFBTTtJQUN0RjtJQUNBLElBQUlhLE9BQU9sQixNQUFNO1FBQ2YsSUFBSVosU0FBUytCLE1BQU07WUFBRSxJQUFJLENBQUNiLHVCQUF1QixDQUFDWSxNQUFNbEIsTUFBTUksSUFBSWhCLFFBQVErQixNQUFNZDtRQUFNO1FBQ3RGLElBQUljLE9BQU9OLE1BQU07WUFBRSxJQUFJLENBQUNQLHVCQUF1QixDQUFDWSxNQUFNbEIsTUFBTUksSUFBSWUsTUFBTU4sTUFBTVI7UUFBTTtJQUNwRjtBQUNGO0FBQ0FiLGNBQWNwdkQsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sRUFBRTtBQUNYO0FBQ0F1dEQsY0FBY3B2RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDMUMsT0FBT3N0RDtBQUNUO0FBRUEsSUFBSTRCLHVCQUF1QixTQUFTQSx3QkFBeUI7QUFFN0RBLHFCQUFxQmh4RCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDcEQsT0FBTyxFQUFFO0FBQ1g7QUFDQW12RCxxQkFBcUJoeEQsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pELE9BQU9rdkQ7QUFDVDtBQUNBQSxxQkFBcUJDLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQmhxQyxHQUFHO0lBQzVFLElBQUkwSSxRQUFRO0lBQ1osSUFBSXVoQyxpQkFBaUIsSUFBSTFqQztJQUN6QjBqQyxlQUFlamxELEdBQUcsQ0FBQyxJQUFJakQsUUFBUTJtQjtJQUMvQixHQUFHO1FBQ0QsSUFBSVosT0FBT2lpQyxxQkFBcUJHLFlBQVksQ0FBQ2xxQyxLQUFLMEk7UUFDbER1aEMsZUFBZWpsRCxHQUFHLENBQUMsSUFBSWpELFFBQVErbEI7UUFDL0JZLFFBQVFaO0lBQ1YsUUFBU1ksUUFBUTFJLElBQUl4bUIsTUFBTSxHQUFHLEdBQUU7SUFDaEMsSUFBSWl4QyxhQUFhc2YscUJBQXFCSSxVQUFVLENBQUNGO0lBQ2pELE9BQU94ZjtBQUNUO0FBQ0FzZixxQkFBcUJHLFlBQVksR0FBRyxTQUFTQSxhQUFjbHFDLEdBQUcsRUFBRTBJLEtBQUs7SUFDbkUsSUFBSTBoQyxZQUFZMWhDO0lBQ2hCLE1BQU8waEMsWUFBWXBxQyxJQUFJeG1CLE1BQU0sR0FBRyxLQUFLd21CLEdBQUcsQ0FBQ29xQyxVQUFVLENBQUM5c0QsUUFBUSxDQUFDMGlCLEdBQUcsQ0FBQ29xQyxZQUFZLEVBQUUsRUFBRztRQUNoRkE7SUFDRjtJQUNBLElBQUlBLGFBQWFwcUMsSUFBSXhtQixNQUFNLEdBQUcsR0FBRztRQUMvQixPQUFPd21CLElBQUl4bUIsTUFBTSxHQUFHO0lBQ3RCO0lBQ0EsSUFBSTZ3RCxZQUFZN2IsU0FBU2UsUUFBUSxDQUFDdnZCLEdBQUcsQ0FBQ29xQyxVQUFVLEVBQUVwcUMsR0FBRyxDQUFDb3FDLFlBQVksRUFBRTtJQUNwRSxJQUFJdGlDLE9BQU9ZLFFBQVE7SUFDbkIsTUFBT1osT0FBTzlILElBQUl4bUIsTUFBTSxDQUFFO1FBQ3hCLElBQUksQ0FBQ3dtQixHQUFHLENBQUM4SCxPQUFPLEVBQUUsQ0FBQ3hxQixRQUFRLENBQUMwaUIsR0FBRyxDQUFDOEgsS0FBSyxHQUFHO1lBQ3RDLElBQUlpbkIsT0FBT1AsU0FBU2UsUUFBUSxDQUFDdnZCLEdBQUcsQ0FBQzhILE9BQU8sRUFBRSxFQUFFOUgsR0FBRyxDQUFDOEgsS0FBSztZQUNyRCxJQUFJaW5CLFNBQVNzYixXQUFXO2dCQUFFO1lBQU07UUFDbEM7UUFDQXZpQztJQUNGO0lBQ0EsT0FBT0EsT0FBTztBQUNoQjtBQUNBaWlDLHFCQUFxQk8sU0FBUyxHQUFHLFNBQVNBO0lBQ3hDLElBQUl6d0QsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSXdtQixNQUFNbm1CLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLE9BQU9rd0QscUJBQXFCTyxTQUFTLENBQUN0cUMsS0FBSztJQUM3QyxPQUFPLElBQUlubUIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSSt3RCxRQUFRMXdELFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUkydUQsVUFBVTN1RCxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJMndELFNBQVMsSUFBSWprQztRQUNqQixJQUFJa2tCLGFBQWFzZixxQkFBcUJDLG9CQUFvQixDQUFDTztRQUMzRCxJQUFLLElBQUlwcUQsSUFBSSxHQUFHQSxJQUFJc3FDLFdBQVdqeEMsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1lBQzlDLElBQUk0b0QsS0FBSyxJQUFJWixjQUFjb0MsT0FBTzlmLFVBQVUsQ0FBQ3RxQyxFQUFFLEVBQUVzcUMsVUFBVSxDQUFDdHFDLElBQUksRUFBRSxFQUFFcW9EO1lBQ3BFZ0MsT0FBT3hsRCxHQUFHLENBQUMrakQ7UUFDYjtRQUNBLE9BQU95QjtJQUNUO0FBQ0Y7QUFDQVQscUJBQXFCSSxVQUFVLEdBQUcsU0FBU0EsV0FBWU0sSUFBSTtJQUN6RCxJQUFJbjNDLFFBQVEsSUFBSXhhLE1BQU0yeEQsS0FBSy85QyxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDeEMsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJbVQsTUFBTTlaLE1BQU0sRUFBRTJHLElBQUs7UUFDckNtVCxLQUFLLENBQUNuVCxFQUFFLEdBQUdzcUQsS0FBS3R1RCxHQUFHLENBQUNnRSxHQUFHNkIsUUFBUTtJQUNqQztJQUNBLE9BQU9zUjtBQUNUO0FBRUEsSUFBSW8zQyxRQUFRLFNBQVNBLFNBQVU7QUFFL0JBLE1BQU0zeEQsU0FBUyxDQUFDNHhELFlBQVksR0FBRyxTQUFTQSxhQUFjeEcsVUFBVSxHQUFHO0FBQ25FdUcsTUFBTTN4RCxTQUFTLENBQUNtckQsa0JBQWtCLEdBQUcsU0FBU0Esc0JBQXVCO0FBQ3JFd0csTUFBTTN4RCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDckMsT0FBTyxFQUFFO0FBQ1g7QUFDQTh2RCxNQUFNM3hELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNsQyxPQUFPNnZEO0FBQ1Q7QUFFQSxJQUFJRSxrQkFBa0IsU0FBU0E7SUFDN0IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDZixJQUFJaHhELFVBQVVMLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJSyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUM5RCxJQUFJc3hELFNBQVNqeEQsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSSxDQUFDa3hELHFCQUFxQixDQUFDRDtJQUM3QjtBQUNGO0FBQ0FGLGdCQUFnQjd4RCxTQUFTLENBQUNneUQscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXVCRCxNQUFNO0lBQ3RGLElBQUksQ0FBQ0QsT0FBTyxHQUFHQztBQUNqQjtBQUNBRixnQkFBZ0I3eEQsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQy9DLE9BQU87UUFBQzh2RDtLQUFNO0FBQ2hCO0FBQ0FFLGdCQUFnQjd4RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyt2RDtBQUNUO0FBRUEsSUFBSUksZUFBZ0IsU0FBVUMsa0JBQWtCO0lBQzlDLFNBQVNELGFBQWNFLEVBQUU7UUFDdkIsSUFBSUEsSUFBSTtZQUFFRCxtQkFBbUIzdkQsSUFBSSxDQUFDLElBQUksRUFBRTR2RDtRQUFLLE9BQ3hDO1lBQUVELG1CQUFtQjN2RCxJQUFJLENBQUMsSUFBSTtRQUFHO1FBQ3RDLElBQUksQ0FBQzZ2RCxXQUFXLEdBQUcsSUFBSTVrQztRQUN2QixJQUFJLENBQUM2a0MsTUFBTSxHQUFHLElBQUlsTztRQUNsQixJQUFJLENBQUNtTyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNwQjtJQUVBLElBQUtOLG9CQUFxQkQsYUFBYXZ2RCxTQUFTLEdBQUd3dkQ7SUFDbkRELGFBQWFqeUQsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFdXZELHNCQUFzQkEsbUJBQW1CbHlELFNBQVM7SUFDMUZpeUQsYUFBYWp5RCxTQUFTLENBQUM0QyxXQUFXLEdBQUdxdkQ7SUFFckMsSUFBSWx1RCxrQkFBa0I7UUFBRTB1RCxzQkFBc0I7WUFBRXR5RCxjQUFjO1FBQUs7SUFBRTtJQUNyRTh4RCxhQUFhanlELFNBQVMsQ0FBQzB5RCxpQkFBaUIsR0FBRyxTQUFTQTtRQUNsRCxPQUFPLElBQUksQ0FBQ04sV0FBVztJQUN6QjtJQUNBSCxhQUFhanlELFNBQVMsQ0FBQ21yRCxrQkFBa0IsR0FBRyxTQUFTQTtRQUNuRCxPQUFPaEMsbUJBQW1CZ0Msa0JBQWtCLENBQUMsSUFBSSxDQUFDb0gsZ0JBQWdCO0lBQ3BFO0lBQ0FOLGFBQWFqeUQsU0FBUyxDQUFDMnlELFFBQVEsR0FBRyxTQUFTQTtRQUN6QyxPQUFPLElBQUksQ0FBQ04sTUFBTTtJQUNwQjtJQUNBSixhQUFhanlELFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQSxJQUFLMm1ELE1BQU07UUFDL0MsSUFBSXQ0QyxTQUFTLElBQUk7UUFFakIsSUFBSXU0QyxZQUFZN0IscUJBQXFCTyxTQUFTLENBQUNxQixPQUFPbDdCLGNBQWMsSUFBSWs3QjtRQUN4RSxJQUFLLElBQUl4ckQsSUFBSXlyRCxVQUFVeG5DLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUMvQyxJQUFJeWtDLEtBQUs1b0QsRUFBRXNnQixJQUFJO1lBQ2Zzb0MsR0FBR0csS0FBSyxDQUFDNzFDLE9BQU9nNEMsVUFBVTtZQUMxQmg0QyxPQUFPKzNDLE1BQU0sQ0FBQ3hkLE1BQU0sQ0FBQ21iLEdBQUd2bEMsV0FBVyxJQUFJdWxDO1lBQ3ZDMTFDLE9BQU84M0MsV0FBVyxDQUFDbm1ELEdBQUcsQ0FBQytqRDtRQUN6QjtJQUNGO0lBQ0FpQyxhQUFhanlELFNBQVMsQ0FBQzR4RCxZQUFZLEdBQUcsU0FBU0EsYUFBY2tCLGVBQWU7UUFDMUUsSUFBSXg0QyxTQUFTLElBQUk7UUFFakIsSUFBSSxDQUFDaTRDLGdCQUFnQixHQUFHTztRQUN4QixJQUFLLElBQUkxckQsSUFBSTByRCxnQkFBZ0J6bkMsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1lBQ3JEalIsT0FBT3JPLEdBQUcsQ0FBQzdFLEVBQUVzZ0IsSUFBSTtRQUNuQjtRQUNBLElBQUksQ0FBQ3FyQyxlQUFlO0lBQ3RCO0lBQ0FkLGFBQWFqeUQsU0FBUyxDQUFDK3lELGVBQWUsR0FBRyxTQUFTQTtRQUNoRCxJQUFJejRDLFNBQVMsSUFBSTtRQUVqQixJQUFJMDRDLGdCQUFnQixJQUFJUCxxQkFBcUIsSUFBSSxDQUFDWCxPQUFPO1FBQ3pELElBQUssSUFBSTFxRCxJQUFJLElBQUksQ0FBQ2dyRCxXQUFXLENBQUMvbUMsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1lBQ3RELElBQUkwbkMsYUFBYTdyRCxFQUFFc2dCLElBQUk7WUFDdkIsSUFBSXdyQyxnQkFBZ0I1NEMsT0FBTyszQyxNQUFNLENBQUMzVCxLQUFLLENBQUN1VSxXQUFXeG9DLFdBQVc7WUFDOUQsSUFBSyxJQUFJYSxJQUFJNG5DLGNBQWM3bkMsUUFBUSxJQUFJQyxFQUFFQyxPQUFPLElBQUs7Z0JBQ25ELElBQUk0bkMsWUFBWTduQyxFQUFFNUQsSUFBSTtnQkFDdEIsSUFBSXlyQyxVQUFVM0MsS0FBSyxLQUFLeUMsV0FBV3pDLEtBQUssSUFBSTtvQkFDMUN5QyxXQUFXbEQsZUFBZSxDQUFDb0QsV0FBV0g7b0JBQ3RDMTRDLE9BQU9rNEMsVUFBVTtnQkFDbkI7Z0JBQ0EsSUFBSWw0QyxPQUFPdzNDLE9BQU8sQ0FBQ3g2QixNQUFNLElBQUk7b0JBQUUsT0FBTztnQkFBSztZQUM3QztRQUNGO0lBQ0Y7SUFDQTI2QixhQUFhanlELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUM1QyxPQUFPLEVBQUU7SUFDWDtJQUNBb3dELGFBQWFqeUQsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQ3pDLE9BQU9td0Q7SUFDVDtJQUNBbHVELGdCQUFnQjB1RCxvQkFBb0IsQ0FBQ3J2RCxHQUFHLEdBQUc7UUFBYyxPQUFPcXZEO0lBQXFCO0lBRXJGeHlELE9BQU9vRCxnQkFBZ0IsQ0FBRTR1RCxjQUFjbHVEO0lBRXZDLE9BQU9rdUQ7QUFDVCxFQUFFSjtBQUVGLElBQUlZLHVCQUF3QixTQUFVVyw2QkFBNkI7SUFDakUsU0FBU1g7UUFDUFcsOEJBQThCN3dELElBQUksQ0FBQyxJQUFJO1FBQ3ZDLElBQUksQ0FBQzh3RCxHQUFHLEdBQUc7UUFDWCxJQUFJbEIsS0FBS3J4RCxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUN1eUQsR0FBRyxHQUFHbEI7SUFDYjtJQUVBLElBQUtpQiwrQkFBZ0NYLHFCQUFxQi92RCxTQUFTLEdBQUcwd0Q7SUFDdEVYLHFCQUFxQnp5RCxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUV5d0QsaUNBQWlDQSw4QkFBOEJwekQsU0FBUztJQUN4SHl5RCxxQkFBcUJ6eUQsU0FBUyxDQUFDNEMsV0FBVyxHQUFHNnZEO0lBQzdDQSxxQkFBcUJ6eUQsU0FBUyxDQUFDOHVELE9BQU8sR0FBRyxTQUFTQTtRQUNoRCxJQUFJaHVELFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUlzdUQsTUFBTWp1RCxTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJa3VELFNBQVNsdUQsU0FBUyxDQUFDLEVBQUU7WUFDekIsSUFBSW11RCxNQUFNbnVELFNBQVMsQ0FBQyxFQUFFO1lBQ3RCLElBQUlvdUQsU0FBU3B1RCxTQUFTLENBQUMsRUFBRTtZQUN6QixJQUFJd3lELE1BQU12RSxJQUFJd0IsVUFBVTtZQUN4QixJQUFJZ0QsTUFBTXRFLElBQUlzQixVQUFVO1lBQ3hCLElBQUksQ0FBQzhDLEdBQUcsQ0FBQ0csb0JBQW9CLENBQUNGLEtBQUt0RSxRQUFRdUUsS0FBS3JFO1FBQ2xELE9BQU87WUFBRSxPQUFPa0UsOEJBQThCcHpELFNBQVMsQ0FBQzh1RCxPQUFPLENBQUN2MUMsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDekY7SUFDQTJ4RCxxQkFBcUJ6eUQsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ3BELE9BQU8sRUFBRTtJQUNYO0lBQ0E0d0QscUJBQXFCenlELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUNqRCxPQUFPMndEO0lBQ1Q7SUFFQSxPQUFPQTtBQUNULEVBQUVoRTtBQUVGLElBQUlnRixtQkFBbUIsU0FBU0E7SUFDOUIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0QsaUJBQWlCRSx5QkFBeUI7SUFDbkUsSUFBSSxDQUFDQyxZQUFZLEdBQUdILGlCQUFpQkksU0FBUztJQUM5QyxJQUFJLENBQUNDLFVBQVUsR0FBR0wsaUJBQWlCTSxVQUFVO0lBQzdDLElBQUksQ0FBQ0MsV0FBVyxHQUFHUCxpQkFBaUJRLG1CQUFtQjtJQUN2RCxJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBR1YsaUJBQWlCVyx1QkFBdUI7SUFFL0QsSUFBSXR6RCxVQUFVTCxNQUFNLEtBQUssR0FBRyxDQUFDLE9BQU8sSUFBSUssVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDOUQsSUFBSTR6RCxtQkFBbUJ2ekQsU0FBUyxDQUFDLEVBQUU7UUFDbkMsSUFBSSxDQUFDd3pELG1CQUFtQixDQUFDRDtJQUMzQixPQUFPLElBQUl2ekQsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTh6RCxxQkFBcUJ6ekQsU0FBUyxDQUFDLEVBQUU7UUFDckMsSUFBSTB6RCxjQUFjMXpELFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUksQ0FBQ3d6RCxtQkFBbUIsQ0FBQ0M7UUFDekIsSUFBSSxDQUFDRSxjQUFjLENBQUNEO0lBQ3RCLE9BQU8sSUFBSTF6RCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJaTBELHFCQUFxQjV6RCxTQUFTLENBQUMsRUFBRTtRQUNyQyxJQUFJNnpELGdCQUFnQjd6RCxTQUFTLENBQUMsRUFBRTtRQUNoQyxJQUFJOHpELFlBQVk5ekQsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSSt6RCxhQUFhL3pELFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUksQ0FBQ3d6RCxtQkFBbUIsQ0FBQ0k7UUFDekIsSUFBSSxDQUFDRCxjQUFjLENBQUNFO1FBQ3BCLElBQUksQ0FBQ0csWUFBWSxDQUFDRjtRQUNsQixJQUFJLENBQUNHLGFBQWEsQ0FBQ0Y7SUFDckI7QUFDRjtBQUVBLElBQUlHLHFCQUFxQjtJQUFFbkIsV0FBVztRQUFFMXpELGNBQWM7SUFBSztJQUFFODBELFVBQVU7UUFBRTkwRCxjQUFjO0lBQUs7SUFBRSswRCxZQUFZO1FBQUUvMEQsY0FBYztJQUFLO0lBQUU0ekQsWUFBWTtRQUFFNXpELGNBQWM7SUFBSztJQUFFZzFELFlBQVk7UUFBRWgxRCxjQUFjO0lBQUs7SUFBRWkxRCxZQUFZO1FBQUVqMUQsY0FBYztJQUFLO0lBQUV3ekQsMkJBQTJCO1FBQUV4ekQsY0FBYztJQUFLO0lBQUU4ekQscUJBQXFCO1FBQUU5ekQsY0FBYztJQUFLO0lBQUVpMEQseUJBQXlCO1FBQUVqMEQsY0FBYztJQUFLO0FBQUU7QUFDeFhzekQsaUJBQWlCenpELFNBQVMsQ0FBQ3ExRCxjQUFjLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxJQUFJLENBQUN6QixZQUFZO0FBQzFCO0FBQ0FILGlCQUFpQnp6RCxTQUFTLENBQUNzMUQsYUFBYSxHQUFHLFNBQVNBO0lBQ2xELE9BQU8sSUFBSSxDQUFDcEIsY0FBYztBQUM1QjtBQUNBVCxpQkFBaUJ6ekQsU0FBUyxDQUFDczBELG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQmlCLFFBQVE7SUFDckYsSUFBSSxDQUFDN0IsaUJBQWlCLEdBQUc2QjtJQUN6QixJQUFJLElBQUksQ0FBQzdCLGlCQUFpQixLQUFLLEdBQUc7UUFBRSxJQUFJLENBQUNJLFVBQVUsR0FBR0wsaUJBQWlCMkIsVUFBVTtJQUFFO0lBQ25GLElBQUksSUFBSSxDQUFDMUIsaUJBQWlCLEdBQUcsR0FBRztRQUM5QixJQUFJLENBQUNJLFVBQVUsR0FBR0wsaUJBQWlCMEIsVUFBVTtRQUM3QyxJQUFJLENBQUNuQixXQUFXLEdBQUd0ekQsS0FBS3lCLEdBQUcsQ0FBQyxJQUFJLENBQUN1eEQsaUJBQWlCO0lBQ3BEO0lBQ0EsSUFBSTZCLFlBQVksR0FBRztRQUNqQixJQUFJLENBQUM3QixpQkFBaUIsR0FBRztJQUMzQjtJQUNBLElBQUksSUFBSSxDQUFDSSxVQUFVLEtBQUtMLGlCQUFpQk0sVUFBVSxFQUFFO1FBQ25ELElBQUksQ0FBQ0wsaUJBQWlCLEdBQUdELGlCQUFpQkUseUJBQXlCO0lBQ3JFO0FBQ0Y7QUFDQUYsaUJBQWlCenpELFNBQVMsQ0FBQ3cxRCxZQUFZLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxJQUFJLENBQUMxQixVQUFVO0FBQ3hCO0FBQ0FMLGlCQUFpQnp6RCxTQUFTLENBQUM4MEQsWUFBWSxHQUFHLFNBQVNBLGFBQWNGLFNBQVM7SUFDeEUsSUFBSSxDQUFDZCxVQUFVLEdBQUdjO0FBQ3BCO0FBQ0FuQixpQkFBaUJ6ekQsU0FBUyxDQUFDeTFELGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQkMsY0FBYztJQUN2RixJQUFJLENBQUN2QixlQUFlLEdBQUd1QixpQkFBaUIsSUFBSSxJQUFJQTtBQUNsRDtBQUNBakMsaUJBQWlCenpELFNBQVMsQ0FBQzIxRCxpQkFBaUIsR0FBRyxTQUFTQTtJQUN0RCxPQUFPLElBQUksQ0FBQ3hCLGVBQWU7QUFDN0I7QUFDQVYsaUJBQWlCenpELFNBQVMsQ0FBQzQxRCxtQkFBbUIsR0FBRyxTQUFTQTtJQUN4RCxPQUFPLElBQUksQ0FBQ2xDLGlCQUFpQjtBQUMvQjtBQUNBRCxpQkFBaUJ6ekQsU0FBUyxDQUFDeTBELGNBQWMsR0FBRyxTQUFTQSxlQUFnQkQsV0FBVztJQUM5RSxJQUFJLENBQUNaLFlBQVksR0FBR1k7QUFDdEI7QUFDQWYsaUJBQWlCenpELFNBQVMsQ0FBQzYxRCxhQUFhLEdBQUcsU0FBU0E7SUFDbEQsT0FBTyxJQUFJLENBQUM3QixXQUFXO0FBQ3pCO0FBQ0FQLGlCQUFpQnp6RCxTQUFTLENBQUMrMEQsYUFBYSxHQUFHLFNBQVNBLGNBQWVGLFVBQVU7SUFDM0UsSUFBSSxDQUFDYixXQUFXLEdBQUdhO0FBQ3JCO0FBQ0FwQixpQkFBaUJ6ekQsU0FBUyxDQUFDODFELGNBQWMsR0FBRyxTQUFTQSxlQUFnQlIsYUFBYTtJQUNoRixJQUFJLENBQUNwQixjQUFjLEdBQUdvQjtBQUN4QjtBQUNBN0IsaUJBQWlCenpELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNoRCxPQUFPLEVBQUU7QUFDWDtBQUNBNHhELGlCQUFpQnp6RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDN0MsT0FBTzJ4RDtBQUNUO0FBQ0FBLGlCQUFpQnNDLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQlIsUUFBUTtJQUMzRSxJQUFJUyxRQUFRdDFELEtBQUtvSixFQUFFLEdBQUcsTUFBTXlyRDtJQUM1QixPQUFPLElBQUk3MEQsS0FBS3UxRCxHQUFHLENBQUNELFFBQVE7QUFDOUI7QUFDQWhCLG1CQUFtQm5CLFNBQVMsQ0FBQ3p3RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDMUQ0eEQsbUJBQW1CQyxRQUFRLENBQUM3eEQsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ3pENHhELG1CQUFtQkUsVUFBVSxDQUFDOXhELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUMzRDR4RCxtQkFBbUJqQixVQUFVLENBQUMzd0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQzNENHhELG1CQUFtQkcsVUFBVSxDQUFDL3hELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUMzRDR4RCxtQkFBbUJJLFVBQVUsQ0FBQ2h5RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDM0Q0eEQsbUJBQW1CckIseUJBQXlCLENBQUN2d0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQzFFNHhELG1CQUFtQmYsbUJBQW1CLENBQUM3d0QsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFJO0FBQ3RFNHhELG1CQUFtQlosdUJBQXVCLENBQUNoeEQsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFLO0FBRTNFbkQsT0FBT29ELGdCQUFnQixDQUFFb3dELGtCQUFrQnVCO0FBRTNDLElBQUlrQiw0QkFBNEIsU0FBU0EsMEJBQTJCQyxTQUFTO0lBQzNFLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc5MEMsYUFBYXdFLGdCQUFnQjtJQUN0RCxJQUFJLENBQUN1d0MsVUFBVSxHQUFHSixhQUFhO0FBQ2pDO0FBRUEsSUFBSUsscUJBQXFCO0lBQUVDLE1BQU07UUFBRXQyRCxjQUFjO0lBQUs7SUFBRXUyRCxRQUFRO1FBQUV2MkQsY0FBYztJQUFLO0lBQUV3MkQsTUFBTTtRQUFFeDJELGNBQWM7SUFBSztJQUFFeTJELGtCQUFrQjtRQUFFejJELGNBQWM7SUFBSztBQUFFO0FBQzdKKzFELDBCQUEwQmwyRCxTQUFTLENBQUM2MkQsV0FBVyxHQUFHLFNBQVNBLFlBQWFDLEVBQUUsRUFBRWprQyxFQUFFLEVBQUVDLEVBQUUsRUFBRWlrQyxXQUFXO0lBQzdGLElBQUl6NUMsS0FBSyxJQUFJLENBQUNpNUMsVUFBVSxDQUFDTyxHQUFHO0lBQzVCLElBQUl2bEQsS0FBSyxJQUFJLENBQUNnbEQsVUFBVSxDQUFDMWpDLEdBQUc7SUFDNUIsSUFBSXJoQixLQUFLLElBQUksQ0FBQytrRCxVQUFVLENBQUN6akMsR0FBRztJQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDa2tDLFNBQVMsQ0FBQzE1QyxJQUFJL0wsSUFBSUMsS0FBSztRQUFFLE9BQU87SUFBTTtJQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDeWxELFNBQVMsQ0FBQzM1QyxJQUFJL0wsSUFBSUMsSUFBSXVsRCxjQUFjO1FBQUUsT0FBTztJQUFNO0lBQzdELE9BQU8sSUFBSSxDQUFDRyxnQkFBZ0IsQ0FBQzU1QyxJQUFJL0wsSUFBSXVsRCxJQUFJaGtDLElBQUlpa0M7QUFDL0M7QUFDQWIsMEJBQTBCbDJELFNBQVMsQ0FBQ20zRCx3QkFBd0IsR0FBRyxTQUFTQTtJQUNwRSxJQUFJNzhDLFNBQVMsSUFBSTtJQUVuQixJQUFJalMsUUFBUTtJQUNaLDhDQUE4QztJQUM5QyxJQUFJK3VELFdBQVcsSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQ2h2RDtJQUM1QyxJQUFJaXZELFlBQVksSUFBSSxDQUFDRCx1QkFBdUIsQ0FBQ0Q7SUFDN0MsSUFBSXhvQyxZQUFZO0lBQ2hCLE1BQU8wb0MsWUFBWSxJQUFJLENBQUNmLFVBQVUsQ0FBQzkxRCxNQUFNLENBQUU7UUFDekMsSUFBSTgyRCx3QkFBd0I7UUFDNUIsSUFBSWo5QyxPQUFPdThDLFdBQVcsQ0FBQ3h1RCxPQUFPK3VELFVBQVVFLFdBQVdoOUMsT0FBTzg3QyxZQUFZLEdBQUc7WUFDdkU5N0MsT0FBTys3QyxVQUFVLENBQUNlLFNBQVMsR0FBR2xCLDBCQUEwQlEsTUFBTTtZQUM5RGEsd0JBQXdCO1lBQ3hCM29DLFlBQVk7UUFDZDtRQUNBLElBQUkyb0MsdUJBQXVCO1lBQUVsdkQsUUFBUWl2RDtRQUFXLE9BQU87WUFBRWp2RCxRQUFRK3VEO1FBQVU7UUFDM0VBLFdBQVc5OEMsT0FBTys4Qyx1QkFBdUIsQ0FBQ2h2RDtRQUMxQ2l2RCxZQUFZaDlDLE9BQU8rOEMsdUJBQXVCLENBQUNEO0lBQzdDO0lBQ0EsT0FBT3hvQztBQUNUO0FBQ0FzbkMsMEJBQTBCbDJELFNBQVMsQ0FBQ3czRCxrQkFBa0IsR0FBRyxTQUFTQSxtQkFBb0JsNkMsRUFBRSxFQUFFL0wsRUFBRSxFQUFFQyxFQUFFLEVBQUV1bEQsV0FBVztJQUMzRyxJQUFJanRCLGNBQWN0b0IsYUFBYW9HLGtCQUFrQixDQUFDdEssSUFBSS9MLElBQUlDO0lBQzFELElBQUlpbUQsb0JBQW9CM3RCLGdCQUFnQixJQUFJLENBQUN3c0IsaUJBQWlCO0lBQzlELElBQUksQ0FBQ21CLG1CQUFtQjtRQUFFLE9BQU87SUFBTTtJQUN2QyxJQUFJajNDLE9BQU9nQixhQUFhK0MsaUJBQWlCLENBQUNoVCxJQUFJK0wsSUFBSTlMO0lBQ2xELE9BQU9nUCxPQUFPdTJDO0FBQ2hCO0FBQ0FiLDBCQUEwQmwyRCxTQUFTLENBQUNrM0QsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCNTVDLEVBQUUsRUFBRTlMLEVBQUUsRUFBRXNsRCxFQUFFLEVBQUVoa0MsRUFBRSxFQUFFaWtDLFdBQVc7SUFDekcsSUFBSXo4QyxTQUFTLElBQUk7SUFFbkIsSUFBSXVWLE1BQU1udkIsS0FBS2UsS0FBSyxDQUFDLENBQUNxeEIsS0FBS2drQyxFQUFDLElBQUtaLDBCQUEwQlUsZ0JBQWdCO0lBQzNFLElBQUkvbUMsT0FBTyxHQUFHO1FBQUVBLE1BQU07SUFBRztJQUN6QixJQUFLLElBQUl6b0IsSUFBSTB2RCxJQUFJMXZELElBQUkwckIsSUFBSTFyQixLQUFLeW9CLElBQUs7UUFDakMsSUFBSSxDQUFDdlYsT0FBTzI4QyxTQUFTLENBQUMzNUMsSUFBSTlMLElBQUk4SSxPQUFPaThDLFVBQVUsQ0FBQ252RCxFQUFFLEVBQUUydkQsY0FBYztZQUFFLE9BQU87UUFBTTtJQUNuRjtJQUNBLE9BQU87QUFDVDtBQUNBYiwwQkFBMEJsMkQsU0FBUyxDQUFDZzNELFNBQVMsR0FBRyxTQUFTQSxVQUFXMTVDLEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUM1RSxJQUFJczRCLGNBQWN0b0IsYUFBYW9HLGtCQUFrQixDQUFDdEssSUFBSS9MLElBQUlDO0lBQzFELElBQUl3bEQsWUFBWWx0QixnQkFBZ0IsSUFBSSxDQUFDd3NCLGlCQUFpQjtJQUN0RCxPQUFPVTtBQUNUO0FBQ0FkLDBCQUEwQmwyRCxTQUFTLENBQUMwM0QsUUFBUSxHQUFHLFNBQVNBLFNBQVVYLFdBQVc7SUFDekUsSUFBSXo4QyxTQUFTLElBQUk7SUFFbkIsSUFBSSxDQUFDODdDLFlBQVksR0FBRzExRCxLQUFLeUIsR0FBRyxDQUFDNDBEO0lBQzdCLElBQUlBLGNBQWMsR0FBRztRQUFFLElBQUksQ0FBQ1QsaUJBQWlCLEdBQUc5MEMsYUFBYXNFLFNBQVM7SUFBRTtJQUN4RSxJQUFJLENBQUN1d0MsVUFBVSxHQUFHLElBQUl0MkQsTUFBTSxJQUFJLENBQUN3MkQsVUFBVSxDQUFDOTFELE1BQU0sRUFBRUosSUFBSSxDQUFDO0lBQ3pELElBQUl1dUIsWUFBWTtJQUNoQixHQUFHO1FBQ0RBLFlBQVl0VSxPQUFPNjhDLHdCQUF3QjtJQUM3QyxRQUFTdm9DLFdBQVU7SUFDbkIsT0FBTyxJQUFJLENBQUMrb0MsWUFBWTtBQUMxQjtBQUNBekIsMEJBQTBCbDJELFNBQVMsQ0FBQ3EzRCx1QkFBdUIsR0FBRyxTQUFTQSx3QkFBeUJodkQsS0FBSztJQUNuRyxJQUFJcWYsT0FBT3JmLFFBQVE7SUFDbkIsTUFBT3FmLE9BQU8sSUFBSSxDQUFDNnVDLFVBQVUsQ0FBQzkxRCxNQUFNLElBQUksSUFBSSxDQUFDNDFELFVBQVUsQ0FBQzN1QyxLQUFLLEtBQUt3dUMsMEJBQTBCUSxNQUFNLENBQUU7UUFBRWh2QztJQUFRO0lBQzlHLE9BQU9BO0FBQ1Q7QUFDQXd1QywwQkFBMEJsMkQsU0FBUyxDQUFDaTNELFNBQVMsR0FBRyxTQUFTQSxVQUFXMzVDLEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRSxFQUFFdWxELFdBQVc7SUFDekYsSUFBSXYyQyxPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDaFQsSUFBSStMLElBQUk5TDtJQUNsRCxPQUFPZ1AsT0FBT3UyQztBQUNoQjtBQUNBYiwwQkFBMEJsMkQsU0FBUyxDQUFDMjNELFlBQVksR0FBRyxTQUFTQTtJQUN4RCxJQUFJcjlDLFNBQVMsSUFBSTtJQUVuQixJQUFJMFcsWUFBWSxJQUFJMUM7SUFDcEIsSUFBSyxJQUFJbG5CLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNtdkQsVUFBVSxDQUFDOTFELE1BQU0sRUFBRTJHLElBQUs7UUFDL0MsSUFBSWtULE9BQU8rN0MsVUFBVSxDQUFDanZELEVBQUUsS0FBSzh1RCwwQkFBMEJRLE1BQU0sRUFBRTtZQUFFMWxDLFVBQVUva0IsR0FBRyxDQUFDcU8sT0FBT2k4QyxVQUFVLENBQUNudkQsRUFBRTtRQUFHO0lBQ3hHO0lBQ0EsT0FBTzRwQixVQUFVN2MsaUJBQWlCO0FBQ3BDO0FBQ0EraEQsMEJBQTBCbDJELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN6RCxPQUFPLEVBQUU7QUFDWDtBQUNBcTBELDBCQUEwQmwyRCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdEQsT0FBT28wRDtBQUNUO0FBQ0FBLDBCQUEwQndCLFFBQVEsR0FBRyxTQUFTQSxTQUFVdkIsU0FBUyxFQUFFWSxXQUFXO0lBQzVFLElBQUlhLE9BQU8sSUFBSTFCLDBCQUEwQkM7SUFDekMsT0FBT3lCLEtBQUtGLFFBQVEsQ0FBQ1g7QUFDdkI7QUFDQVAsbUJBQW1CQyxJQUFJLENBQUNyekQsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBQ3JEb3pELG1CQUFtQkUsTUFBTSxDQUFDdHpELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRTtBQUN2RG96RCxtQkFBbUJHLElBQUksQ0FBQ3Z6RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDckRvekQsbUJBQW1CSSxnQkFBZ0IsQ0FBQ3h6RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUc7QUFFbEVuRCxPQUFPb0QsZ0JBQWdCLENBQUU2eUQsMkJBQTJCTTtBQUVwRCxJQUFJcUIsc0JBQXNCLFNBQVNBO0lBQ2pDLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDcjVDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNzNUMsc0JBQXNCLEdBQUc7SUFDOUIsSUFBSSxDQUFDRCxPQUFPLEdBQUcsSUFBSXRxQztBQUNyQjtBQUVBLElBQUl3cUMscUJBQXFCO0lBQUVDLHVCQUF1QjtRQUFFOTNELGNBQWM7SUFBSztBQUFFO0FBQ3pFMDNELG9CQUFvQjczRCxTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO0lBQ3RELElBQUkxTCxRQUFRLElBQUksQ0FBQzhyQyxPQUFPLENBQUM5cUMsT0FBTyxDQUFDNnFDLG9CQUFvQkkscUJBQXFCO0lBQzFFLE9BQU9qc0M7QUFDVDtBQUNBNnJDLG9CQUFvQjczRCxTQUFTLENBQUNtZ0IsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CQyxjQUFjO0lBQzFGLElBQUksQ0FBQzNCLGVBQWUsR0FBRzJCO0FBQ3pCO0FBQ0F5M0Msb0JBQW9CNzNELFNBQVMsQ0FBQ2s0RCxLQUFLLEdBQUcsU0FBU0EsTUFBT3IzQyxFQUFFO0lBQ3RELElBQUlzM0MsUUFBUSxJQUFJejBELFdBQVdtZDtJQUMzQixJQUFJLENBQUNwQyxlQUFlLENBQUMwRCxXQUFXLENBQUNnMkM7SUFDakMsSUFBSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0QsUUFBUTtRQUFFLE9BQU87SUFBSztJQUMzQyxJQUFJLENBQUNMLE9BQU8sQ0FBQzdyRCxHQUFHLENBQUNrc0Q7QUFDbkI7QUFDQU4sb0JBQW9CNzNELFNBQVMsQ0FBQ3E0RCxNQUFNLEdBQUcsU0FBU0EsVUFBVztBQUMzRFIsb0JBQW9CNzNELFNBQVMsQ0FBQ3M0RCxNQUFNLEdBQUcsU0FBU0EsT0FBUXozQyxFQUFFLEVBQUV5cEIsU0FBUztJQUNqRSxJQUFJaHdCLFNBQVMsSUFBSTtJQUVuQixJQUFJZ3dCLFdBQVc7UUFDYixJQUFLLElBQUlsakMsSUFBSSxHQUFHQSxJQUFJeVosR0FBR3BnQixNQUFNLEVBQUUyRyxJQUFLO1lBQ2xDa1QsT0FBTzQ5QyxLQUFLLENBQUNyM0MsRUFBRSxDQUFDelosRUFBRTtRQUNwQjtJQUNGLE9BQU87UUFDTCxJQUFLLElBQUl3ZSxNQUFNL0UsR0FBR3BnQixNQUFNLEdBQUcsR0FBR21sQixPQUFPLEdBQUdBLE1BQU87WUFDN0N0TCxPQUFPNDlDLEtBQUssQ0FBQ3IzQyxFQUFFLENBQUMrRSxJQUFJO1FBQ3RCO0lBQ0Y7QUFDRjtBQUNBaXlDLG9CQUFvQjczRCxTQUFTLENBQUNvNEQsV0FBVyxHQUFHLFNBQVNBLFlBQWF2M0MsRUFBRTtJQUNsRSxJQUFJLElBQUksQ0FBQ2kzQyxPQUFPLENBQUNua0QsSUFBSSxLQUFLLEdBQUc7UUFBRSxPQUFPO0lBQU07SUFDNUMsSUFBSTRrRCxTQUFTLElBQUksQ0FBQ1QsT0FBTyxDQUFDMTBELEdBQUcsQ0FBQyxJQUFJLENBQUMwMEQsT0FBTyxDQUFDbmtELElBQUksS0FBSztJQUNwRCxJQUFJNmtELFNBQVMzM0MsR0FBR3RiLFFBQVEsQ0FBQ2d6RDtJQUN6QixJQUFJQyxTQUFTLElBQUksQ0FBQ1Qsc0JBQXNCLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDeEQsT0FBTztBQUNUO0FBQ0FGLG9CQUFvQjczRCxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDaEQsSUFBSXc0QixPQUFPLElBQUkva0I7SUFDZixJQUFJNEQsT0FBT21oQixLQUFLdGhCLGdCQUFnQixDQUFDLElBQUksQ0FBQ3ViLGNBQWM7SUFDcEQsT0FBT3BiLEtBQUtyWCxRQUFRO0FBQ3RCO0FBQ0E0eUQsb0JBQW9CNzNELFNBQVMsQ0FBQzh2QixTQUFTLEdBQUcsU0FBU0E7SUFDakQsSUFBSSxJQUFJLENBQUNnb0MsT0FBTyxDQUFDbmtELElBQUksS0FBSyxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQzNDLElBQUk4a0QsVUFBVSxJQUFJLzBELFdBQVcsSUFBSSxDQUFDbzBELE9BQU8sQ0FBQzEwRCxHQUFHLENBQUM7SUFDOUMsSUFBSW0xRCxTQUFTLElBQUksQ0FBQ1QsT0FBTyxDQUFDMTBELEdBQUcsQ0FBQyxJQUFJLENBQUMwMEQsT0FBTyxDQUFDbmtELElBQUksS0FBSztJQUNwRCx1QkFBdUI7SUFDdkIsb0ZBQW9GO0lBQ3BGLElBQUk4a0QsUUFBUTl6RCxNQUFNLENBQUM0ekQsU0FBUztRQUFFLE9BQU87SUFBSztJQUMxQyxJQUFJLENBQUNULE9BQU8sQ0FBQzdyRCxHQUFHLENBQUN3c0Q7QUFDbkI7QUFDQVosb0JBQW9CNzNELFNBQVMsQ0FBQzA0RCx3QkFBd0IsR0FBRyxTQUFTQSx5QkFBMEJDLHFCQUFxQjtJQUMvRyxJQUFJLENBQUNaLHNCQUFzQixHQUFHWTtBQUNoQztBQUNBZCxvQkFBb0I3M0QsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ25ELE9BQU8sRUFBRTtBQUNYO0FBQ0FnMkQsb0JBQW9CNzNELFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNoRCxPQUFPKzFEO0FBQ1Q7QUFDQUcsbUJBQW1CQyxxQkFBcUIsQ0FBQzcwRCxHQUFHLEdBQUc7SUFBYyxPQUFPLElBQUlyRCxNQUFNLEdBQUdNLElBQUksQ0FBQztBQUFNO0FBRTVGSixPQUFPb0QsZ0JBQWdCLENBQUV3MEQscUJBQXFCRztBQUU5QyxJQUFJWSxRQUFRLFNBQVNBLFNBQVU7QUFFL0IsSUFBSUMscUJBQXFCO0lBQUVDLFlBQVk7UUFBRTM0RCxjQUFjO0lBQUs7SUFBRTQ0RCxXQUFXO1FBQUU1NEQsY0FBYztJQUFLO0lBQUU2NEQsV0FBVztRQUFFNzRELGNBQWM7SUFBSztJQUFFNmxCLGtCQUFrQjtRQUFFN2xCLGNBQWM7SUFBSztJQUFFMmxCLFdBQVc7UUFBRTNsQixjQUFjO0lBQUs7SUFBRTZHLE1BQU07UUFBRTdHLGNBQWM7SUFBSztBQUFFO0FBRTFPeTRELE1BQU01NEQsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sRUFBRTtBQUNYO0FBQ0ErMkQsTUFBTTU0RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbEMsT0FBTzgyRDtBQUNUO0FBQ0FBLE1BQU1LLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxPQUFPO0lBQzNDLE9BQU9BLFVBQVUsTUFBTXg0RCxLQUFLb0osRUFBRTtBQUNoQztBQUNBOHVELE1BQU05dEMsU0FBUyxHQUFHLFNBQVNBLFVBQVd5c0IsS0FBSztJQUN6QyxNQUFPQSxRQUFRNzJDLEtBQUtvSixFQUFFLENBQUU7UUFBRXl0QyxTQUFTcWhCLE1BQU1FLFVBQVU7SUFBRTtJQUNyRCxNQUFPdmhCLFNBQVMsQ0FBQzcyQyxLQUFLb0osRUFBRSxDQUFFO1FBQUV5dEMsU0FBU3FoQixNQUFNRSxVQUFVO0lBQUU7SUFDdkQsT0FBT3ZoQjtBQUNUO0FBQ0FxaEIsTUFBTXJoQixLQUFLLEdBQUcsU0FBU0E7SUFDckIsSUFBSXoyQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJdVUsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLE9BQU9KLEtBQUs4MkMsS0FBSyxDQUFDeGlDLEVBQUVyUixDQUFDLEVBQUVxUixFQUFFdFQsQ0FBQztJQUM1QixPQUFPLElBQUlaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk2YyxLQUFLeGMsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXlRLEtBQUt6USxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJcUUsS0FBS29NLEdBQUc3UCxDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQztRQUNwQixJQUFJMEQsS0FBS21NLEdBQUc1TixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQztRQUNwQixPQUFPakQsS0FBSzgyQyxLQUFLLENBQUNweUMsSUFBSUQ7SUFDeEI7QUFDRjtBQUNBeXpELE1BQU1PLE9BQU8sR0FBRyxTQUFTQSxRQUFTNzdDLEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUMxQyxJQUFJNG5ELE1BQU05N0MsR0FBRzViLENBQUMsR0FBRzZQLEdBQUc3UCxDQUFDO0lBQ3JCLElBQUkyM0QsTUFBTS83QyxHQUFHM1osQ0FBQyxHQUFHNE4sR0FBRzVOLENBQUM7SUFDckIsSUFBSWdPLE1BQU1ILEdBQUc5UCxDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQztJQUNyQixJQUFJa1EsTUFBTUosR0FBRzdOLENBQUMsR0FBRzROLEdBQUc1TixDQUFDO0lBQ3JCLElBQUkyMUQsVUFBVUYsTUFBTXpuRCxNQUFNMG5ELE1BQU16bkQ7SUFDaEMsT0FBTzBuRCxVQUFVO0FBQ25CO0FBQ0FWLE1BQU1XLFFBQVEsR0FBRyxTQUFTQSxTQUFVajhDLEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUM1QyxJQUFJNG5ELE1BQU05N0MsR0FBRzViLENBQUMsR0FBRzZQLEdBQUc3UCxDQUFDO0lBQ3JCLElBQUkyM0QsTUFBTS83QyxHQUFHM1osQ0FBQyxHQUFHNE4sR0FBRzVOLENBQUM7SUFDckIsSUFBSWdPLE1BQU1ILEdBQUc5UCxDQUFDLEdBQUc2UCxHQUFHN1AsQ0FBQztJQUNyQixJQUFJa1EsTUFBTUosR0FBRzdOLENBQUMsR0FBRzROLEdBQUc1TixDQUFDO0lBQ3JCLElBQUkyMUQsVUFBVUYsTUFBTXpuRCxNQUFNMG5ELE1BQU16bkQ7SUFDaEMsT0FBTzBuRCxVQUFVO0FBQ25CO0FBQ0FWLE1BQU1ZLGFBQWEsR0FBRyxTQUFTQSxjQUFlbDhDLEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUN0RCxJQUFJaW9ELFlBQVliLE1BQU1yaEIsS0FBSyxDQUFDaG1DLElBQUkrTDtJQUNoQyxJQUFJbzhDLFlBQVlkLE1BQU1yaEIsS0FBSyxDQUFDaG1DLElBQUlDO0lBQ2hDLE9BQU85USxLQUFLeUIsR0FBRyxDQUFDdTNELFlBQVlEO0FBQzlCO0FBQ0FiLE1BQU1lLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQnBpQixLQUFLO0lBQ3pELElBQUlBLFFBQVEsS0FBSztRQUNmLE1BQU9BLFFBQVEsSUFBSztZQUFFQSxTQUFTcWhCLE1BQU1FLFVBQVU7UUFBRTtRQUNqRCxJQUFJdmhCLFNBQVNxaEIsTUFBTUUsVUFBVSxFQUFFO1lBQUV2aEIsUUFBUTtRQUFLO0lBQ2hELE9BQU87UUFDTCxNQUFPQSxTQUFTcWhCLE1BQU1FLFVBQVUsQ0FBRTtZQUFFdmhCLFNBQVNxaEIsTUFBTUUsVUFBVTtRQUFFO1FBQy9ELElBQUl2aEIsUUFBUSxLQUFLO1lBQUVBLFFBQVE7UUFBSztJQUNsQztJQUNBLE9BQU9BO0FBQ1Q7QUFDQXFoQixNQUFNZ0IsWUFBWSxHQUFHLFNBQVNBLGFBQWNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQzFELElBQUlDLEtBQUtwQixNQUFNcmhCLEtBQUssQ0FBQ3VpQixNQUFNRDtJQUMzQixJQUFJSSxLQUFLckIsTUFBTXJoQixLQUFLLENBQUN1aUIsTUFBTUM7SUFDM0IsT0FBT25CLE1BQU14aUIsSUFBSSxDQUFDNGpCLElBQUlDO0FBQ3hCO0FBQ0FyQixNQUFNeGlCLElBQUksR0FBRyxTQUFTQSxLQUFNOGpCLElBQUksRUFBRUMsSUFBSTtJQUNwQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSUYsT0FBT0MsTUFBTTtRQUNmQyxXQUFXRCxPQUFPRDtJQUNwQixPQUFPO1FBQ0xFLFdBQVdGLE9BQU9DO0lBQ3BCO0lBQ0EsSUFBSUMsV0FBVzE1RCxLQUFLb0osRUFBRSxFQUFFO1FBQ3RCc3dELFdBQVcsSUFBSTE1RCxLQUFLb0osRUFBRSxHQUFHc3dEO0lBQzNCO0lBQ0EsT0FBT0E7QUFDVDtBQUNBeEIsTUFBTXlCLFNBQVMsR0FBRyxTQUFTQSxVQUFXQyxZQUFZO0lBQ2hELE9BQU9BLGVBQWU1NUQsS0FBS29KLEVBQUUsR0FBRztBQUNsQztBQUNBOHVELE1BQU0yQixPQUFPLEdBQUcsU0FBU0EsUUFBU0wsSUFBSSxFQUFFQyxJQUFJO0lBQzFDLElBQUlLLGVBQWU5NUQsS0FBSys1RCxHQUFHLENBQUNOLE9BQU9EO0lBQ25DLElBQUlNLGVBQWUsR0FBRztRQUNwQixPQUFPNUIsTUFBTTV5QyxnQkFBZ0I7SUFDL0I7SUFDQSxJQUFJdzBDLGVBQWUsR0FBRztRQUNwQixPQUFPNUIsTUFBTTl5QyxTQUFTO0lBQ3hCO0lBQ0EsT0FBTzh5QyxNQUFNNXhELElBQUk7QUFDbkI7QUFDQTR4RCxNQUFNOEIsb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCYixJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUMxRSxJQUFJQyxLQUFLcEIsTUFBTXJoQixLQUFLLENBQUN1aUIsTUFBTUQ7SUFDM0IsSUFBSUksS0FBS3JCLE1BQU1yaEIsS0FBSyxDQUFDdWlCLE1BQU1DO0lBQzNCLElBQUlZLFNBQVNWLEtBQUtEO0lBQ2xCLElBQUlXLFVBQVUsQ0FBQ2o2RCxLQUFLb0osRUFBRSxFQUFFO1FBQUUsT0FBTzZ3RCxTQUFTL0IsTUFBTUUsVUFBVTtJQUFDO0lBQzNELElBQUk2QixTQUFTajZELEtBQUtvSixFQUFFLEVBQUU7UUFBRSxPQUFPNndELFNBQVMvQixNQUFNRSxVQUFVO0lBQUM7SUFDekQsT0FBTzZCO0FBQ1Q7QUFDQTlCLG1CQUFtQkMsVUFBVSxDQUFDMTFELEdBQUcsR0FBRztJQUFjLE9BQU8sTUFBTTFDLEtBQUtvSixFQUFFO0FBQUM7QUFDdkUrdUQsbUJBQW1CRSxTQUFTLENBQUMzMUQsR0FBRyxHQUFHO0lBQWMsT0FBTzFDLEtBQUtvSixFQUFFLEdBQUc7QUFBSTtBQUN0RSt1RCxtQkFBbUJHLFNBQVMsQ0FBQzUxRCxHQUFHLEdBQUc7SUFBYyxPQUFPMUMsS0FBS29KLEVBQUUsR0FBRztBQUFJO0FBQ3RFK3VELG1CQUFtQjd5QyxnQkFBZ0IsQ0FBQzVpQixHQUFHLEdBQUc7SUFBYyxPQUFPb2UsYUFBYXdFLGdCQUFnQjtBQUFDO0FBQzdGNnlDLG1CQUFtQi95QyxTQUFTLENBQUMxaUIsR0FBRyxHQUFHO0lBQWMsT0FBT29lLGFBQWFzRSxTQUFTO0FBQUM7QUFDL0UreUMsbUJBQW1CN3hELElBQUksQ0FBQzVELEdBQUcsR0FBRztJQUFjLE9BQU9vZSxhQUFhM0MsU0FBUztBQUFDO0FBRTFFNWUsT0FBT29ELGdCQUFnQixDQUFFdTFELE9BQU9DO0FBRWhDLElBQUkrQix5QkFBeUIsU0FBU0E7SUFDcEMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztJQUM3QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO0lBQzNCLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUc7SUFDL0IsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDcGIsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ25oQyxlQUFlLEdBQUc7SUFDdkIsSUFBSSxDQUFDdzhDLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUk3UDtJQUNqQixJQUFJLENBQUM4UCxLQUFLLEdBQUcsSUFBSTlQO0lBQ2pCLElBQUksQ0FBQytQLFFBQVEsR0FBRyxJQUFJL1A7SUFDcEIsSUFBSSxDQUFDZ1EsUUFBUSxHQUFHLElBQUloUTtJQUNwQixJQUFJLENBQUNpUSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLHNCQUFzQixHQUFHO0lBQzlCLElBQUl2N0MsaUJBQWlCdGYsU0FBUyxDQUFDLEVBQUU7SUFDakMsSUFBSTg2RCxZQUFZOTZELFNBQVMsQ0FBQyxFQUFFO0lBQzVCLElBQUl5RSxXQUFXekUsU0FBUyxDQUFDLEVBQUU7SUFDM0IsSUFBSSxDQUFDMmQsZUFBZSxHQUFHMkI7SUFDdkIsSUFBSSxDQUFDNjZDLFVBQVUsR0FBR1c7SUFDbEIsSUFBSSxDQUFDVixHQUFHLEdBQUcsSUFBSWg2QztJQUNmLElBQUksQ0FBQzQ1QyxtQkFBbUIsR0FBR3A2RCxLQUFLb0osRUFBRSxHQUFHLE1BQU04eEQsVUFBVWhHLG1CQUFtQjtJQUN4RSxJQUFJZ0csVUFBVWhHLG1CQUFtQixNQUFNLEtBQUtnRyxVQUFVcEcsWUFBWSxPQUFPL0IsaUJBQWlCTSxVQUFVLEVBQUU7UUFBRSxJQUFJLENBQUNnSCx1QkFBdUIsR0FBR0gsdUJBQXVCaUIsMEJBQTBCO0lBQUU7SUFDMUwsSUFBSSxDQUFDcnlELElBQUksQ0FBQ2pFO0FBQ1o7QUFFQSxJQUFJdTJELHFCQUFxQjtJQUFFQyxrQ0FBa0M7UUFBRTU3RCxjQUFjO0lBQUs7SUFBRTY3RCx5Q0FBeUM7UUFBRTc3RCxjQUFjO0lBQUs7SUFBRTg3RCxtQ0FBbUM7UUFBRTk3RCxjQUFjO0lBQUs7SUFBRTA3RCw0QkFBNEI7UUFBRTE3RCxjQUFjO0lBQUs7QUFBRTtBQUNqUXk2RCx1QkFBdUI1NkQsU0FBUyxDQUFDazhELGNBQWMsR0FBRyxTQUFTQSxlQUFnQmxuRCxDQUFDLEVBQUVtbkQsYUFBYTtJQUN6RixJQUFJLENBQUNoQixHQUFHLEdBQUcsSUFBSSxDQUFDQyxHQUFHO0lBQ25CLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUksQ0FBQ0MsR0FBRztJQUNuQixJQUFJLENBQUNBLEdBQUcsR0FBR3JtRDtJQUNYLElBQUksQ0FBQ3NtRCxLQUFLLENBQUN2TixjQUFjLENBQUMsSUFBSSxDQUFDb04sR0FBRyxFQUFFLElBQUksQ0FBQ0MsR0FBRztJQUM1QyxJQUFJLENBQUNnQixvQkFBb0IsQ0FBQyxJQUFJLENBQUNkLEtBQUssRUFBRSxJQUFJLENBQUNJLEtBQUssRUFBRSxJQUFJLENBQUM5YixTQUFTLEVBQUUsSUFBSSxDQUFDNGIsUUFBUTtJQUMvRSxJQUFJLENBQUNELEtBQUssQ0FBQ3hOLGNBQWMsQ0FBQyxJQUFJLENBQUNxTixHQUFHLEVBQUUsSUFBSSxDQUFDQyxHQUFHO0lBQzVDLElBQUksQ0FBQ2Usb0JBQW9CLENBQUMsSUFBSSxDQUFDYixLQUFLLEVBQUUsSUFBSSxDQUFDRyxLQUFLLEVBQUUsSUFBSSxDQUFDOWIsU0FBUyxFQUFFLElBQUksQ0FBQzZiLFFBQVE7SUFDL0UsSUFBSSxJQUFJLENBQUNMLEdBQUcsQ0FBQ3oyRCxNQUFNLENBQUMsSUFBSSxDQUFDMDJELEdBQUcsR0FBRztRQUFFLE9BQU87SUFBSztJQUM3QyxJQUFJdnhCLGNBQWN0b0IsYUFBYW9HLGtCQUFrQixDQUFDLElBQUksQ0FBQ3V6QyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxHQUFHO0lBQzlFLElBQUlnQixjQUFjLGdCQUFpQjc2QyxhQUFhc0UsU0FBUyxJQUFJLElBQUksQ0FBQzQxQyxLQUFLLEtBQUtwekIsU0FBU3JpQixJQUFJLElBQU02akIsZ0JBQWdCdG9CLGFBQWF3RSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMwMUMsS0FBSyxLQUFLcHpCLFNBQVN2aUIsS0FBSztJQUM3SyxJQUFJK2pCLGdCQUFnQixHQUFHO1FBQ3JCLElBQUksQ0FBQ3d5QixZQUFZLENBQUNIO0lBQ3BCLE9BQU8sSUFBSUUsYUFBYTtRQUN0QixJQUFJLENBQUNFLGNBQWMsQ0FBQ3p5QixhQUFhcXlCO0lBQ25DLE9BQU87UUFDTCxJQUFJLENBQUNLLGFBQWEsQ0FBQzF5QixhQUFhcXlCO0lBQ2xDO0FBQ0Y7QUFDQXZCLHVCQUF1QjU2RCxTQUFTLENBQUN5OEQsYUFBYSxHQUFHLFNBQVNBLGNBQWVuL0MsRUFBRSxFQUFFL0wsRUFBRTtJQUM3RSxJQUFJcTZDLE1BQU0sSUFBSUgsWUFBWW51QyxJQUFJL0w7SUFDOUIsSUFBSW1yRCxVQUFVLElBQUlqUjtJQUNsQixJQUFJLENBQUMyUSxvQkFBb0IsQ0FBQ3hRLEtBQUt0akIsU0FBU3JpQixJQUFJLEVBQUUsSUFBSSxDQUFDMjVCLFNBQVMsRUFBRThjO0lBQzlELElBQUlDLFVBQVUsSUFBSWxSO0lBQ2xCLElBQUksQ0FBQzJRLG9CQUFvQixDQUFDeFEsS0FBS3RqQixTQUFTdmlCLEtBQUssRUFBRSxJQUFJLENBQUM2NUIsU0FBUyxFQUFFK2M7SUFDL0QsSUFBSXgzRCxLQUFLb00sR0FBRzdQLENBQUMsR0FBRzRiLEdBQUc1YixDQUFDO0lBQ3BCLElBQUkwRCxLQUFLbU0sR0FBRzVOLENBQUMsR0FBRzJaLEdBQUczWixDQUFDO0lBQ3BCLElBQUk0ekMsUUFBUTcyQyxLQUFLODJDLEtBQUssQ0FBQ3B5QyxJQUFJRDtJQUMzQixPQUFRLElBQUksQ0FBQzgxRCxVQUFVLENBQUM1RixjQUFjO1FBQ3BDLEtBQUs1QixpQkFBaUJJLFNBQVM7WUFDN0IsSUFBSSxDQUFDbUgsUUFBUSxDQUFDOUMsS0FBSyxDQUFDd0UsUUFBUW5yRCxFQUFFO1lBQzlCLElBQUksQ0FBQ3FyRCxZQUFZLENBQUNyckQsSUFBSWdtQyxRQUFRNzJDLEtBQUtvSixFQUFFLEdBQUcsR0FBR3l0QyxRQUFRNzJDLEtBQUtvSixFQUFFLEdBQUcsR0FBRzBYLGFBQWFzRSxTQUFTLEVBQUUsSUFBSSxDQUFDODVCLFNBQVM7WUFDdEcsSUFBSSxDQUFDb2IsUUFBUSxDQUFDOUMsS0FBSyxDQUFDeUUsUUFBUXByRCxFQUFFO1lBQzlCO1FBQ0YsS0FBS2tpRCxpQkFBaUJ3QixRQUFRO1lBQzVCLElBQUksQ0FBQytGLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQ3dFLFFBQVFuckQsRUFBRTtZQUM5QixJQUFJLENBQUN5cEQsUUFBUSxDQUFDOUMsS0FBSyxDQUFDeUUsUUFBUXByRCxFQUFFO1lBQzlCO1FBQ0YsS0FBS2tpRCxpQkFBaUJ5QixVQUFVO1lBQzlCLElBQUkySCxzQkFBc0IsSUFBSW41RDtZQUM5Qm01RCxvQkFBb0JuN0QsQ0FBQyxHQUFHaEIsS0FBS3lCLEdBQUcsQ0FBQyxJQUFJLENBQUN5OUMsU0FBUyxJQUFJbC9DLEtBQUt1MUQsR0FBRyxDQUFDMWU7WUFDNURzbEIsb0JBQW9CbDVELENBQUMsR0FBR2pELEtBQUt5QixHQUFHLENBQUMsSUFBSSxDQUFDeTlDLFNBQVMsSUFBSWwvQyxLQUFLKzVELEdBQUcsQ0FBQ2xqQjtZQUM1RCxJQUFJdWxCLG1CQUFtQixJQUFJcDVELFdBQVdnNUQsUUFBUW5yRCxFQUFFLENBQUM3UCxDQUFDLEdBQUdtN0Qsb0JBQW9CbjdELENBQUMsRUFBRWc3RCxRQUFRbnJELEVBQUUsQ0FBQzVOLENBQUMsR0FBR2s1RCxvQkFBb0JsNUQsQ0FBQztZQUNoSCxJQUFJbzVELG1CQUFtQixJQUFJcjVELFdBQVdpNUQsUUFBUXByRCxFQUFFLENBQUM3UCxDQUFDLEdBQUdtN0Qsb0JBQW9CbjdELENBQUMsRUFBRWk3RCxRQUFRcHJELEVBQUUsQ0FBQzVOLENBQUMsR0FBR2s1RCxvQkFBb0JsNUQsQ0FBQztZQUNoSCxJQUFJLENBQUNxM0QsUUFBUSxDQUFDOUMsS0FBSyxDQUFDNEU7WUFDcEIsSUFBSSxDQUFDOUIsUUFBUSxDQUFDOUMsS0FBSyxDQUFDNkU7WUFDcEI7UUFDRjtJQUNGO0FBQ0Y7QUFDQW5DLHVCQUF1QjU2RCxTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO0lBQ3pELElBQUl6USxNQUFNLElBQUksQ0FBQyt6QyxRQUFRLENBQUN0akMsY0FBYztJQUN0QyxPQUFPelE7QUFDVDtBQUNBMnpDLHVCQUF1QjU2RCxTQUFTLENBQUNnOUQsWUFBWSxHQUFHLFNBQVNBLGFBQWNob0QsQ0FBQyxFQUFFaW9ELE9BQU8sRUFBRUMsT0FBTyxFQUFFMzNELFFBQVE7SUFDbEcsSUFBSTQzRCxxQkFBcUI7SUFDekIsSUFBSTk3QyxRQUFRO0lBQ1osSUFBSTtRQUNGQSxRQUFRdk0sWUFBWTNDLFlBQVksQ0FBQzhxRCxRQUFRMy9DLEVBQUUsRUFBRTIvQyxRQUFRMXJELEVBQUUsRUFBRTJyRCxRQUFRNS9DLEVBQUUsRUFBRTQvQyxRQUFRM3JELEVBQUU7UUFDL0UsSUFBSTZyRCxhQUFhNzNELFlBQVksTUFBTSxNQUFNOGIsTUFBTTliLFFBQVEsQ0FBQ3lQLEtBQUt0VSxLQUFLeUIsR0FBRyxDQUFDb0Q7UUFDdEUsSUFBSTYzRCxhQUFhLElBQUksQ0FBQ25DLFVBQVUsQ0FBQ3BGLGFBQWEsSUFBSTtZQUFFc0gscUJBQXFCO1FBQU87SUFDbEYsRUFBRSxPQUFPenNELElBQUk7UUFDWCxJQUFJQSxjQUFjMkQsMkJBQTJCO1lBQzNDZ04sUUFBUSxJQUFJM2QsV0FBVyxHQUFHO1lBQzFCeTVELHFCQUFxQjtRQUN2QixPQUFPO1lBQUUsTUFBTXpzRDtRQUFHO0lBQ3BCLFNBQVUsQ0FBQztJQUNYLElBQUl5c0Qsb0JBQW9CO1FBQ3RCLElBQUksQ0FBQ25DLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQzcyQztJQUN0QixPQUFPO1FBQ0wsSUFBSSxDQUFDZzhDLG1CQUFtQixDQUFDSixTQUFTQyxTQUFTMzNELFVBQVUsSUFBSSxDQUFDMDFELFVBQVUsQ0FBQ3BGLGFBQWE7SUFDcEY7QUFDRjtBQUNBK0UsdUJBQXVCNTZELFNBQVMsQ0FBQ3M5RCxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCdG9ELENBQUMsRUFBRXNJLEVBQUUsRUFBRS9MLEVBQUUsRUFBRTZkLFNBQVMsRUFBRW11QyxNQUFNO0lBQ3ZHLElBQUluRSxNQUFNOTdDLEdBQUc1YixDQUFDLEdBQUdzVCxFQUFFdFQsQ0FBQztJQUNwQixJQUFJMjNELE1BQU0vN0MsR0FBRzNaLENBQUMsR0FBR3FSLEVBQUVyUixDQUFDO0lBQ3BCLElBQUk2NUQsYUFBYTk4RCxLQUFLODJDLEtBQUssQ0FBQzZoQixLQUFLRDtJQUNqQyxJQUFJem5ELE1BQU1KLEdBQUc3UCxDQUFDLEdBQUdzVCxFQUFFdFQsQ0FBQztJQUNwQixJQUFJa1EsTUFBTUwsR0FBRzVOLENBQUMsR0FBR3FSLEVBQUVyUixDQUFDO0lBQ3BCLElBQUk4NUQsV0FBVy84RCxLQUFLODJDLEtBQUssQ0FBQzVsQyxLQUFLRDtJQUMvQixJQUFJeWQsY0FBYzVOLGFBQWFzRSxTQUFTLEVBQUU7UUFDeEMsSUFBSTAzQyxjQUFjQyxVQUFVO1lBQUVELGNBQWMsTUFBTTk4RCxLQUFLb0osRUFBRTtRQUFFO0lBQzdELE9BQU87UUFDTCxJQUFJMHpELGNBQWNDLFVBQVU7WUFBRUQsY0FBYyxNQUFNOThELEtBQUtvSixFQUFFO1FBQUU7SUFDN0Q7SUFDQSxJQUFJLENBQUNreEQsUUFBUSxDQUFDOUMsS0FBSyxDQUFDNTZDO0lBQ3BCLElBQUksQ0FBQ3MvQyxZQUFZLENBQUM1bkQsR0FBR3dvRCxZQUFZQyxVQUFVcnVDLFdBQVdtdUM7SUFDdEQsSUFBSSxDQUFDdkMsUUFBUSxDQUFDOUMsS0FBSyxDQUFDM21EO0FBQ3RCO0FBQ0FxcEQsdUJBQXVCNTZELFNBQVMsQ0FBQ3U4RCxjQUFjLEdBQUcsU0FBU0EsZUFBZ0J6eUIsV0FBVyxFQUFFcXlCLGFBQWE7SUFDbkcsSUFBSSxJQUFJLENBQUNYLFFBQVEsQ0FBQ2pxRCxFQUFFLENBQUNoTSxRQUFRLENBQUMsSUFBSSxDQUFDazJELFFBQVEsQ0FBQ24rQyxFQUFFLElBQUksSUFBSSxDQUFDc2lDLFNBQVMsR0FBR2diLHVCQUF1Qm1CLGdDQUFnQyxFQUFFO1FBQzFILElBQUksQ0FBQ2YsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ2pxRCxFQUFFO1FBQ3BDLE9BQU87SUFDVDtJQUNBLElBQUksSUFBSSxDQUFDMHBELFVBQVUsQ0FBQ3pGLFlBQVksT0FBTy9CLGlCQUFpQjBCLFVBQVUsRUFBRTtRQUNsRSxJQUFJLENBQUM2SCxZQUFZLENBQUMsSUFBSSxDQUFDNUIsR0FBRyxFQUFFLElBQUksQ0FBQ0ksUUFBUSxFQUFFLElBQUksQ0FBQ0MsUUFBUSxFQUFFLElBQUksQ0FBQzdiLFNBQVM7SUFDMUUsT0FBTyxJQUFJLElBQUksQ0FBQ3FiLFVBQVUsQ0FBQ3pGLFlBQVksT0FBTy9CLGlCQUFpQjJCLFVBQVUsRUFBRTtRQUN6RSxJQUFJLENBQUNzSSxZQUFZLENBQUMsSUFBSSxDQUFDbEMsUUFBUSxFQUFFLElBQUksQ0FBQ0MsUUFBUTtJQUNoRCxPQUFPO1FBQ0wsSUFBSVUsZUFBZTtZQUFFLElBQUksQ0FBQ25CLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQyxJQUFJLENBQUNzRCxRQUFRLENBQUNqcUQsRUFBRTtRQUFHO1FBQzVELElBQUksQ0FBQytyRCxlQUFlLENBQUMsSUFBSSxDQUFDbEMsR0FBRyxFQUFFLElBQUksQ0FBQ0ksUUFBUSxDQUFDanFELEVBQUUsRUFBRSxJQUFJLENBQUNrcUQsUUFBUSxDQUFDbitDLEVBQUUsRUFBRXdzQixhQUFhLElBQUksQ0FBQzhWLFNBQVM7UUFDOUYsSUFBSSxDQUFDb2IsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3VELFFBQVEsQ0FBQ24rQyxFQUFFO0lBQ3RDO0FBQ0Y7QUFDQXM5Qyx1QkFBdUI1NkQsU0FBUyxDQUFDMjlELFlBQVksR0FBRyxTQUFTQSxhQUFjM29ELENBQUM7SUFDdEUsSUFBSSxDQUFDZ21ELFFBQVEsQ0FBQzlDLEtBQUssQ0FBQyxJQUFJeDBELFdBQVdzUixFQUFFdFQsQ0FBQyxHQUFHLElBQUksQ0FBQ2srQyxTQUFTLEVBQUU1cUMsRUFBRXJSLENBQUMsR0FBRyxJQUFJLENBQUNpOEMsU0FBUztJQUM3RSxJQUFJLENBQUNvYixRQUFRLENBQUM5QyxLQUFLLENBQUMsSUFBSXgwRCxXQUFXc1IsRUFBRXRULENBQUMsR0FBRyxJQUFJLENBQUNrK0MsU0FBUyxFQUFFNXFDLEVBQUVyUixDQUFDLEdBQUcsSUFBSSxDQUFDaThDLFNBQVM7SUFDN0UsSUFBSSxDQUFDb2IsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUl4MEQsV0FBV3NSLEVBQUV0VCxDQUFDLEdBQUcsSUFBSSxDQUFDaytDLFNBQVMsRUFBRTVxQyxFQUFFclIsQ0FBQyxHQUFHLElBQUksQ0FBQ2k4QyxTQUFTO0lBQzdFLElBQUksQ0FBQ29iLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQyxJQUFJeDBELFdBQVdzUixFQUFFdFQsQ0FBQyxHQUFHLElBQUksQ0FBQ2srQyxTQUFTLEVBQUU1cUMsRUFBRXJSLENBQUMsR0FBRyxJQUFJLENBQUNpOEMsU0FBUztJQUM3RSxJQUFJLENBQUNvYixRQUFRLENBQUNsckMsU0FBUztBQUN6QjtBQUNBOHFDLHVCQUF1QjU2RCxTQUFTLENBQUM0OUQsV0FBVyxHQUFHLFNBQVNBLFlBQWEvOEMsRUFBRSxFQUFFeXBCLFNBQVM7SUFDaEYsSUFBSSxDQUFDMHdCLFFBQVEsQ0FBQzFDLE1BQU0sQ0FBQ3ozQyxJQUFJeXBCO0FBQzNCO0FBQ0Fzd0IsdUJBQXVCNTZELFNBQVMsQ0FBQzY5RCxlQUFlLEdBQUcsU0FBU0E7SUFDMUQsSUFBSSxDQUFDN0MsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3VELFFBQVEsQ0FBQ24rQyxFQUFFO0FBQ3RDO0FBQ0FzOUMsdUJBQXVCNTZELFNBQVMsQ0FBQzg5RCxjQUFjLEdBQUcsU0FBU0E7SUFDekQsSUFBSSxDQUFDOUMsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3VELFFBQVEsQ0FBQ2xxRCxFQUFFO0FBQ3RDO0FBQ0FxcEQsdUJBQXVCNTZELFNBQVMsQ0FBQys5RCxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JDLEVBQUUsRUFBRUMsRUFBRSxFQUFFMTBCLElBQUk7SUFDekYsSUFBSSxDQUFDNnhCLEdBQUcsR0FBRzRDO0lBQ1gsSUFBSSxDQUFDM0MsR0FBRyxHQUFHNEM7SUFDWCxJQUFJLENBQUN2QyxLQUFLLEdBQUdueUI7SUFDYixJQUFJLENBQUNneUIsS0FBSyxDQUFDeE4sY0FBYyxDQUFDaVEsSUFBSUM7SUFDOUIsSUFBSSxDQUFDN0Isb0JBQW9CLENBQUMsSUFBSSxDQUFDYixLQUFLLEVBQUVoeUIsTUFBTSxJQUFJLENBQUNxVyxTQUFTLEVBQUUsSUFBSSxDQUFDNmIsUUFBUTtBQUMzRTtBQUNBYix1QkFBdUI1NkQsU0FBUyxDQUFDcTlELG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQkosT0FBTyxFQUFFQyxPQUFPLEVBQUUzM0QsUUFBUSxFQUFFc3ZELFVBQVU7SUFDekgsSUFBSXFKLFNBQVMsSUFBSSxDQUFDNUMsS0FBSyxDQUFDL3BELEVBQUU7SUFDMUIsSUFBSTRzRCxPQUFPdkYsTUFBTXJoQixLQUFLLENBQUMybUIsUUFBUSxJQUFJLENBQUM1QyxLQUFLLENBQUNoK0MsRUFBRTtJQUM1QyxrREFBa0Q7SUFDbEQsSUFBSThnRCxVQUFVeEYsTUFBTThCLG9CQUFvQixDQUFDLElBQUksQ0FBQ1ksS0FBSyxDQUFDaCtDLEVBQUUsRUFBRTRnRCxRQUFRLElBQUksQ0FBQzNDLEtBQUssQ0FBQ2hxRCxFQUFFO0lBQzdFLElBQUk4c0QsY0FBY0QsVUFBVTtJQUM1QixJQUFJRSxTQUFTMUYsTUFBTTl0QyxTQUFTLENBQUNxekMsT0FBT0U7SUFDcEMsSUFBSUUsY0FBYzNGLE1BQU05dEMsU0FBUyxDQUFDd3pDLFNBQVM1OUQsS0FBS29KLEVBQUU7SUFDbEQsSUFBSTAwRCxZQUFZM0osYUFBYXR2RDtJQUM3QixJQUFJazVELGFBQWFELFlBQVk5OUQsS0FBS3lCLEdBQUcsQ0FBQ3pCLEtBQUsrNUQsR0FBRyxDQUFDNEQ7SUFDL0MsSUFBSUssZUFBZW41RCxXQUFXazVEO0lBQzlCLElBQUlFLFlBQVlULE9BQU94OEQsQ0FBQyxHQUFHODhELFlBQVk5OUQsS0FBS3UxRCxHQUFHLENBQUNzSTtJQUNoRCxJQUFJSyxZQUFZVixPQUFPdjZELENBQUMsR0FBRzY2RCxZQUFZOTlELEtBQUsrNUQsR0FBRyxDQUFDOEQ7SUFDaEQsSUFBSU0sYUFBYSxJQUFJbjdELFdBQVdpN0QsV0FBV0M7SUFDM0MsSUFBSUUsZUFBZSxJQUFJclQsWUFBWXlTLFFBQVFXO0lBQzNDLElBQUlFLGVBQWVELGFBQWF4UixnQkFBZ0IsQ0FBQyxLQUFLb1I7SUFDdEQsSUFBSU0sZ0JBQWdCRixhQUFheFIsZ0JBQWdCLENBQUMsS0FBSyxDQUFDb1I7SUFDeEQsSUFBSSxJQUFJLENBQUNoRCxLQUFLLEtBQUtwekIsU0FBU3JpQixJQUFJLEVBQUU7UUFDaEMsSUFBSSxDQUFDKzBDLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQzZHO1FBQ3BCLElBQUksQ0FBQy9ELFFBQVEsQ0FBQzlDLEtBQUssQ0FBQzhHO0lBQ3RCLE9BQU87UUFDTCxJQUFJLENBQUNoRSxRQUFRLENBQUM5QyxLQUFLLENBQUM4RztRQUNwQixJQUFJLENBQUNoRSxRQUFRLENBQUM5QyxLQUFLLENBQUM2RztJQUN0QjtBQUNGO0FBQ0FuRSx1QkFBdUI1NkQsU0FBUyxDQUFDbzhELG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQnhRLEdBQUcsRUFBRXJpQixJQUFJLEVBQUVoa0MsUUFBUSxFQUFFMDVELE1BQU07SUFDaEgsSUFBSUMsV0FBVzMxQixTQUFTakIsU0FBU3JpQixJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQzdDLElBQUk5Z0IsS0FBS3ltRCxJQUFJcjZDLEVBQUUsQ0FBQzdQLENBQUMsR0FBR2txRCxJQUFJdHVDLEVBQUUsQ0FBQzViLENBQUM7SUFDNUIsSUFBSTBELEtBQUt3bUQsSUFBSXI2QyxFQUFFLENBQUM1TixDQUFDLEdBQUdpb0QsSUFBSXR1QyxFQUFFLENBQUMzWixDQUFDO0lBQzVCLElBQUl1TixNQUFNeFEsS0FBSzRFLElBQUksQ0FBQ0gsS0FBS0EsS0FBS0MsS0FBS0E7SUFDbkMsSUFBSXVvRCxLQUFLdVIsV0FBVzM1RCxXQUFXSixLQUFLK0w7SUFDcEMsSUFBSTA4QyxLQUFLc1IsV0FBVzM1RCxXQUFXSCxLQUFLOEw7SUFDcEMrdEQsT0FBTzNoRCxFQUFFLENBQUM1YixDQUFDLEdBQUdrcUQsSUFBSXR1QyxFQUFFLENBQUM1YixDQUFDLEdBQUdrc0Q7SUFDekJxUixPQUFPM2hELEVBQUUsQ0FBQzNaLENBQUMsR0FBR2lvRCxJQUFJdHVDLEVBQUUsQ0FBQzNaLENBQUMsR0FBR2dxRDtJQUN6QnNSLE9BQU8xdEQsRUFBRSxDQUFDN1AsQ0FBQyxHQUFHa3FELElBQUlyNkMsRUFBRSxDQUFDN1AsQ0FBQyxHQUFHa3NEO0lBQ3pCcVIsT0FBTzF0RCxFQUFFLENBQUM1TixDQUFDLEdBQUdpb0QsSUFBSXI2QyxFQUFFLENBQUM1TixDQUFDLEdBQUdncUQ7QUFDM0I7QUFDQWlOLHVCQUF1QjU2RCxTQUFTLENBQUM0OEQsWUFBWSxHQUFHLFNBQVNBLGFBQWM1bkQsQ0FBQyxFQUFFd29ELFVBQVUsRUFBRUMsUUFBUSxFQUFFcnVDLFNBQVMsRUFBRW11QyxNQUFNO0lBQzdHLElBQUlqakQsU0FBUyxJQUFJO0lBRW5CLElBQUltL0Isa0JBQWtCcnFCLGNBQWM1TixhQUFhc0UsU0FBUyxHQUFHLENBQUMsSUFBSTtJQUNsRSxJQUFJcTVDLGFBQWF6K0QsS0FBS3lCLEdBQUcsQ0FBQ3E3RCxhQUFhQztJQUN2QyxJQUFJMkIsUUFBUTErRCxLQUFLZSxLQUFLLENBQUMwOUQsYUFBYSxJQUFJLENBQUNyRSxtQkFBbUIsR0FBRztJQUMvRCxJQUFJc0UsUUFBUSxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQzdCLElBQUlDLFlBQVk7SUFDaEIsSUFBSUMsZUFBZUgsYUFBYUM7SUFDaEMsSUFBSUcsWUFBWUY7SUFDaEIsSUFBSXgrQyxLQUFLLElBQUluZDtJQUNiLE1BQU82N0QsWUFBWUosV0FBWTtRQUM3QixJQUFJNW5CLFFBQVFpbUIsYUFBYS9qQixrQkFBa0I4bEI7UUFDM0MxK0MsR0FBR25mLENBQUMsR0FBR3NULEVBQUV0VCxDQUFDLEdBQUc2N0QsU0FBUzc4RCxLQUFLdTFELEdBQUcsQ0FBQzFlO1FBQy9CMTJCLEdBQUdsZCxDQUFDLEdBQUdxUixFQUFFclIsQ0FBQyxHQUFHNDVELFNBQVM3OEQsS0FBSys1RCxHQUFHLENBQUNsakI7UUFDL0JqOUIsT0FBTzBnRCxRQUFRLENBQUM5QyxLQUFLLENBQUNyM0M7UUFDdEIwK0MsYUFBYUQ7SUFDZjtBQUNGO0FBQ0ExRSx1QkFBdUI1NkQsU0FBUyxDQUFDdzhELGFBQWEsR0FBRyxTQUFTQSxjQUFlMXlCLFdBQVcsRUFBRXF5QixhQUFhO0lBQ2pHLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMrN0MsUUFBUSxDQUFDbCtDLEVBQUUsRUFBRSxJQUFJLENBQUNrK0MsUUFBUSxDQUFDanFELEVBQUUsRUFBRSxJQUFJLENBQUNrcUQsUUFBUSxDQUFDbitDLEVBQUUsRUFBRSxJQUFJLENBQUNtK0MsUUFBUSxDQUFDbHFELEVBQUU7SUFDbkcsSUFBSSxJQUFJLENBQUMycEQsR0FBRyxDQUFDaDdDLGVBQWUsSUFBSTtRQUM5QixJQUFJLENBQUM4NkMsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ2dELEdBQUcsQ0FBQzM2QyxlQUFlLENBQUM7SUFDL0MsT0FBTztRQUNMLElBQUksQ0FBQ283QyxzQkFBc0IsR0FBRztRQUM5QixJQUFJLElBQUksQ0FBQ0gsUUFBUSxDQUFDanFELEVBQUUsQ0FBQ2hNLFFBQVEsQ0FBQyxJQUFJLENBQUNrMkQsUUFBUSxDQUFDbitDLEVBQUUsSUFBSSxJQUFJLENBQUNzaUMsU0FBUyxHQUFHZ2IsdUJBQXVCb0IsdUNBQXVDLEVBQUU7WUFDakksSUFBSSxDQUFDaEIsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ2pxRCxFQUFFO1FBQ3RDLE9BQU87WUFDTCxJQUFJLENBQUN5cEQsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ2pxRCxFQUFFO1lBQ3BDLElBQUksSUFBSSxDQUFDd3BELHVCQUF1QixHQUFHLEdBQUc7Z0JBQ3BDLElBQUlqSyxPQUFPLElBQUlwdEQsV0FBVyxDQUFDLElBQUksQ0FBQ3EzRCx1QkFBdUIsR0FBRyxJQUFJLENBQUNTLFFBQVEsQ0FBQ2pxRCxFQUFFLENBQUM3UCxDQUFDLEdBQUcsSUFBSSxDQUFDMDVELEdBQUcsQ0FBQzE1RCxDQUFDLElBQUssS0FBSSxDQUFDcTVELHVCQUF1QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUNBLHVCQUF1QixHQUFHLElBQUksQ0FBQ1MsUUFBUSxDQUFDanFELEVBQUUsQ0FBQzVOLENBQUMsR0FBRyxJQUFJLENBQUN5M0QsR0FBRyxDQUFDejNELENBQUMsSUFBSyxLQUFJLENBQUNvM0QsdUJBQXVCLEdBQUc7Z0JBQ3BPLElBQUksQ0FBQ0MsUUFBUSxDQUFDOUMsS0FBSyxDQUFDcEg7Z0JBQ3BCLElBQUlDLE9BQU8sSUFBSXJ0RCxXQUFXLENBQUMsSUFBSSxDQUFDcTNELHVCQUF1QixHQUFHLElBQUksQ0FBQ1UsUUFBUSxDQUFDbitDLEVBQUUsQ0FBQzViLENBQUMsR0FBRyxJQUFJLENBQUMwNUQsR0FBRyxDQUFDMTVELENBQUMsSUFBSyxLQUFJLENBQUNxNUQsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQ0EsdUJBQXVCLEdBQUcsSUFBSSxDQUFDVSxRQUFRLENBQUNuK0MsRUFBRSxDQUFDM1osQ0FBQyxHQUFHLElBQUksQ0FBQ3kzRCxHQUFHLENBQUN6M0QsQ0FBQyxJQUFLLEtBQUksQ0FBQ28zRCx1QkFBdUIsR0FBRztnQkFDcE8sSUFBSSxDQUFDQyxRQUFRLENBQUM5QyxLQUFLLENBQUNuSDtZQUN0QixPQUFPO2dCQUNMLElBQUksQ0FBQ2lLLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQyxJQUFJLENBQUNrRCxHQUFHO1lBQzlCO1lBQ0EsSUFBSSxDQUFDSixRQUFRLENBQUM5QyxLQUFLLENBQUMsSUFBSSxDQUFDdUQsUUFBUSxDQUFDbitDLEVBQUU7UUFDdEM7SUFDRjtBQUNGO0FBQ0FzOUMsdUJBQXVCNTZELFNBQVMsQ0FBQ3cvRCxZQUFZLEdBQUcsU0FBU0EsYUFBY3hxRCxDQUFDO0lBQ3RFLElBQUk2TCxLQUFLLElBQUluZCxXQUFXc1IsRUFBRXRULENBQUMsR0FBRyxJQUFJLENBQUNrK0MsU0FBUyxFQUFFNXFDLEVBQUVyUixDQUFDO0lBQ2pELElBQUksQ0FBQ3EzRCxRQUFRLENBQUM5QyxLQUFLLENBQUNyM0M7SUFDcEIsSUFBSSxDQUFDKzdDLFlBQVksQ0FBQzVuRCxHQUFHLEtBQUssTUFBTXRVLEtBQUtvSixFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQzgxQyxTQUFTO0lBQzNELElBQUksQ0FBQ29iLFFBQVEsQ0FBQ2xyQyxTQUFTO0FBQ3pCO0FBQ0E4cUMsdUJBQXVCNTZELFNBQVMsQ0FBQzA5RCxZQUFZLEdBQUcsU0FBU0EsYUFBY1QsT0FBTyxFQUFFQyxPQUFPO0lBQ3JGLElBQUksQ0FBQ2xDLFFBQVEsQ0FBQzlDLEtBQUssQ0FBQytFLFFBQVExckQsRUFBRTtJQUM5QixJQUFJLENBQUN5cEQsUUFBUSxDQUFDOUMsS0FBSyxDQUFDZ0YsUUFBUTUvQyxFQUFFO0FBQ2hDO0FBQ0FzOUMsdUJBQXVCNTZELFNBQVMsQ0FBQ3dKLElBQUksR0FBRyxTQUFTQSxLQUFNakUsUUFBUTtJQUM3RCxJQUFJLENBQUNxNkMsU0FBUyxHQUFHcjZDO0lBQ2pCLElBQUksQ0FBQ3MxRCxxQkFBcUIsR0FBR3QxRCxXQUFZLEtBQUk3RSxLQUFLdTFELEdBQUcsQ0FBQyxJQUFJLENBQUM2RSxtQkFBbUIsR0FBRyxJQUFHO0lBQ3BGLElBQUksQ0FBQ0UsUUFBUSxHQUFHLElBQUluRDtJQUNwQixJQUFJLENBQUNtRCxRQUFRLENBQUM3NkMsaUJBQWlCLENBQUMsSUFBSSxDQUFDMUIsZUFBZTtJQUNwRCxJQUFJLENBQUN1OEMsUUFBUSxDQUFDdEMsd0JBQXdCLENBQUNuekQsV0FBV3ExRCx1QkFBdUJxQixpQ0FBaUM7QUFDNUc7QUFDQXJCLHVCQUF1QjU2RCxTQUFTLENBQUNzOEQsWUFBWSxHQUFHLFNBQVNBLGFBQWNILGFBQWE7SUFDbEYsSUFBSSxDQUFDakIsR0FBRyxDQUFDejdDLG1CQUFtQixDQUFDLElBQUksQ0FBQzA3QyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEVBQUUsSUFBSSxDQUFDQyxHQUFHO0lBQ25FLElBQUlvRSxTQUFTLElBQUksQ0FBQ3ZFLEdBQUcsQ0FBQ3I3QyxrQkFBa0I7SUFDeEMsSUFBSTQvQyxVQUFVLEdBQUc7UUFDZixJQUFJLElBQUksQ0FBQ3hFLFVBQVUsQ0FBQ3pGLFlBQVksT0FBTy9CLGlCQUFpQjJCLFVBQVUsSUFBSSxJQUFJLENBQUM2RixVQUFVLENBQUN6RixZQUFZLE9BQU8vQixpQkFBaUIwQixVQUFVLEVBQUU7WUFDcEksSUFBSWdILGVBQWU7Z0JBQUUsSUFBSSxDQUFDbkIsUUFBUSxDQUFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQ3NELFFBQVEsQ0FBQ2pxRCxFQUFFO1lBQUc7WUFDNUQsSUFBSSxDQUFDeXBELFFBQVEsQ0FBQzlDLEtBQUssQ0FBQyxJQUFJLENBQUN1RCxRQUFRLENBQUNuK0MsRUFBRTtRQUN0QyxPQUFPO1lBQ0wsSUFBSSxDQUFDZ2dELGVBQWUsQ0FBQyxJQUFJLENBQUNsQyxHQUFHLEVBQUUsSUFBSSxDQUFDSSxRQUFRLENBQUNqcUQsRUFBRSxFQUFFLElBQUksQ0FBQ2txRCxRQUFRLENBQUNuK0MsRUFBRSxFQUFFa0UsYUFBYXNFLFNBQVMsRUFBRSxJQUFJLENBQUM4NUIsU0FBUztRQUMzRztJQUNGO0FBQ0Y7QUFDQWdiLHVCQUF1QjU2RCxTQUFTLENBQUM4dkIsU0FBUyxHQUFHLFNBQVNBO0lBQ3BELElBQUksQ0FBQ2tyQyxRQUFRLENBQUNsckMsU0FBUztBQUN6QjtBQUNBOHFDLHVCQUF1QjU2RCxTQUFTLENBQUMwL0QscUJBQXFCLEdBQUcsU0FBU0E7SUFDaEUsT0FBTyxJQUFJLENBQUMvRCxzQkFBc0I7QUFDcEM7QUFDQWYsdUJBQXVCNTZELFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN0RCxPQUFPLEVBQUU7QUFDWDtBQUNBKzRELHVCQUF1QjU2RCxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbkQsT0FBTzg0RDtBQUNUO0FBQ0FrQixtQkFBbUJDLGdDQUFnQyxDQUFDMzRELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBTztBQUN0RjA0RCxtQkFBbUJFLHVDQUF1QyxDQUFDNTRELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBTztBQUM3RjA0RCxtQkFBbUJHLGlDQUFpQyxDQUFDNzRELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBTztBQUN2RjA0RCxtQkFBbUJELDBCQUEwQixDQUFDejRELEdBQUcsR0FBRztJQUFjLE9BQU87QUFBRztBQUU1RW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRXUzRCx3QkFBd0JrQjtBQUVqRCxJQUFJNkQscUJBQXFCLFNBQVNBO0lBQ2hDLElBQUksQ0FBQy9mLFNBQVMsR0FBRztJQUNqQixJQUFJLENBQUNuaEMsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ3c4QyxVQUFVLEdBQUc7SUFDbEIsSUFBSTc2QyxpQkFBaUJ0ZixTQUFTLENBQUMsRUFBRTtJQUNqQyxJQUFJODZELFlBQVk5NkQsU0FBUyxDQUFDLEVBQUU7SUFDNUIsSUFBSSxDQUFDMmQsZUFBZSxHQUFHMkI7SUFDdkIsSUFBSSxDQUFDNjZDLFVBQVUsR0FBR1c7QUFDcEI7QUFDQStELG1CQUFtQjMvRCxTQUFTLENBQUM0L0QsY0FBYyxHQUFHLFNBQVNBLGVBQWdCQyxRQUFRLEVBQUV0NkQsUUFBUTtJQUN2RixJQUFJLENBQUNxNkMsU0FBUyxHQUFHcjZDO0lBQ2pCLElBQUlBLGFBQWEsS0FBSztRQUFFLE9BQU87SUFBSztJQUNwQyxJQUFJdTZELGNBQWN2NkQsV0FBVztJQUM3QixJQUFJdzZELGNBQWNyL0QsS0FBS3lCLEdBQUcsQ0FBQ29EO0lBQzNCLElBQUl5NkQsU0FBUyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0Y7SUFDNUIsSUFBSUYsU0FBU3AvRCxNQUFNLElBQUksR0FBRztRQUN4QixJQUFJLENBQUN5L0QsaUJBQWlCLENBQUNMLFFBQVEsQ0FBQyxFQUFFLEVBQUVHO0lBQ3RDLE9BQU87UUFDTCxJQUFJLENBQUNHLGtCQUFrQixDQUFDTixVQUFVQyxhQUFhRTtJQUNqRDtJQUNBLElBQUlJLFdBQVdKLE9BQU90b0MsY0FBYztJQUNwQyxJQUFJb29DLGFBQWE7UUFBRS92QyxpQkFBaUJvQixPQUFPLENBQUNpdkM7SUFBVztJQUN2RCxPQUFPQTtBQUNUO0FBQ0FULG1CQUFtQjMvRCxTQUFTLENBQUNxZ0UsNkJBQTZCLEdBQUcsU0FBU0EsOEJBQStCUixRQUFRLEVBQUVDLFdBQVcsRUFBRUUsTUFBTTtJQUNoSSxJQUFJTSxVQUFVLElBQUksQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxDQUFDM2dCLFNBQVM7SUFDbkQsSUFBSWtnQixhQUFhO1FBQ2ZFLE9BQU9wQyxXQUFXLENBQUNpQyxVQUFVO1FBQzdCLElBQUlXLFFBQVF0SywwQkFBMEJ3QixRQUFRLENBQUNtSSxVQUFVLENBQUNTO1FBQzFELElBQUkzK0MsS0FBSzYrQyxNQUFNLy9ELE1BQU0sR0FBRztRQUN4QnUvRCxPQUFPakMsZ0JBQWdCLENBQUN5QyxLQUFLLENBQUM3K0MsR0FBRyxFQUFFNitDLEtBQUssQ0FBQzcrQyxLQUFLLEVBQUUsRUFBRTJtQixTQUFTcmlCLElBQUk7UUFDL0QrNUMsT0FBT25DLGVBQWU7UUFDdEIsSUFBSyxJQUFJejJELElBQUl1YSxLQUFLLEdBQUd2YSxLQUFLLEdBQUdBLElBQUs7WUFDaEM0NEQsT0FBTzlELGNBQWMsQ0FBQ3NFLEtBQUssQ0FBQ3A1RCxFQUFFLEVBQUU7UUFDbEM7SUFDRixPQUFPO1FBQ0w0NEQsT0FBT3BDLFdBQVcsQ0FBQ2lDLFVBQVU7UUFDN0IsSUFBSVksUUFBUXZLLDBCQUEwQndCLFFBQVEsQ0FBQ21JLFVBQVVTO1FBQ3pELElBQUk1K0MsS0FBSysrQyxNQUFNaGdFLE1BQU0sR0FBRztRQUN4QnUvRCxPQUFPakMsZ0JBQWdCLENBQUMwQyxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFbjRCLFNBQVNyaUIsSUFBSTtRQUN6RCs1QyxPQUFPbkMsZUFBZTtRQUN0QixJQUFLLElBQUlqNEMsTUFBTSxHQUFHQSxPQUFPbEUsSUFBSWtFLE1BQU87WUFDbENvNkMsT0FBTzlELGNBQWMsQ0FBQ3VFLEtBQUssQ0FBQzc2QyxJQUFJLEVBQUU7UUFDcEM7SUFDRjtJQUNBbzZDLE9BQU9sQyxjQUFjO0lBQ3JCa0MsT0FBT2x3QyxTQUFTO0FBQ2xCO0FBQ0E2dkMsbUJBQW1CMy9ELFNBQVMsQ0FBQzBnRSxzQkFBc0IsR0FBRyxTQUFTQSx1QkFBd0JiLFFBQVEsRUFBRXQyQixJQUFJLEVBQUV5MkIsTUFBTTtJQUMzRyxJQUFJTSxVQUFVLElBQUksQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxDQUFDM2dCLFNBQVM7SUFDbkQsSUFBSXJXLFNBQVNqQixTQUFTdmlCLEtBQUssRUFBRTtRQUFFdTZDLFVBQVUsQ0FBQ0E7SUFBUztJQUNuRCxJQUFJMUksT0FBTzFCLDBCQUEwQndCLFFBQVEsQ0FBQ21JLFVBQVVTO0lBQ3hELElBQUl0OUQsSUFBSTQwRCxLQUFLbjNELE1BQU0sR0FBRztJQUN0QnUvRCxPQUFPakMsZ0JBQWdCLENBQUNuRyxJQUFJLENBQUM1MEQsSUFBSSxFQUFFLEVBQUU0MEQsSUFBSSxDQUFDLEVBQUUsRUFBRXJ1QjtJQUM5QyxJQUFLLElBQUluaUMsSUFBSSxHQUFHQSxLQUFLcEUsR0FBR29FLElBQUs7UUFDM0IsSUFBSSswRCxnQkFBZ0IvMEQsTUFBTTtRQUMxQjQ0RCxPQUFPOUQsY0FBYyxDQUFDdEUsSUFBSSxDQUFDeHdELEVBQUUsRUFBRSswRDtJQUNqQztJQUNBNkQsT0FBT2x3QyxTQUFTO0FBQ2xCO0FBQ0E2dkMsbUJBQW1CMy9ELFNBQVMsQ0FBQzJnRSxzQkFBc0IsR0FBRyxTQUFTQSx1QkFBd0JkLFFBQVEsRUFBRUcsTUFBTTtJQUNyRyxJQUFJTSxVQUFVLElBQUksQ0FBQ0MsaUJBQWlCLENBQUMsSUFBSSxDQUFDM2dCLFNBQVM7SUFDbkQsSUFBSTZnQixRQUFRdkssMEJBQTBCd0IsUUFBUSxDQUFDbUksVUFBVVM7SUFDekQsSUFBSTUrQyxLQUFLKytDLE1BQU1oZ0UsTUFBTSxHQUFHO0lBQ3hCdS9ELE9BQU9qQyxnQkFBZ0IsQ0FBQzBDLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVuNEIsU0FBU3JpQixJQUFJO0lBQ3pELElBQUssSUFBSTdlLElBQUksR0FBR0EsS0FBS3NhLElBQUl0YSxJQUFLO1FBQzVCNDRELE9BQU85RCxjQUFjLENBQUN1RSxLQUFLLENBQUNyNUQsRUFBRSxFQUFFO0lBQ2xDO0lBQ0E0NEQsT0FBT2xDLGNBQWM7SUFDckJrQyxPQUFPdkQsYUFBYSxDQUFDZ0UsS0FBSyxDQUFDLytDLEtBQUssRUFBRSxFQUFFKytDLEtBQUssQ0FBQy8rQyxHQUFHO0lBQzdDLElBQUk4K0MsUUFBUXRLLDBCQUEwQndCLFFBQVEsQ0FBQ21JLFVBQVUsQ0FBQ1M7SUFDMUQsSUFBSTMrQyxLQUFLNitDLE1BQU0vL0QsTUFBTSxHQUFHO0lBQ3hCdS9ELE9BQU9qQyxnQkFBZ0IsQ0FBQ3lDLEtBQUssQ0FBQzcrQyxHQUFHLEVBQUU2K0MsS0FBSyxDQUFDNytDLEtBQUssRUFBRSxFQUFFMm1CLFNBQVNyaUIsSUFBSTtJQUMvRCxJQUFLLElBQUlMLE1BQU1qRSxLQUFLLEdBQUdpRSxPQUFPLEdBQUdBLE1BQU87UUFDdENvNkMsT0FBTzlELGNBQWMsQ0FBQ3NFLEtBQUssQ0FBQzU2QyxJQUFJLEVBQUU7SUFDcEM7SUFDQW82QyxPQUFPbEMsY0FBYztJQUNyQmtDLE9BQU92RCxhQUFhLENBQUMrRCxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtJQUN2Q1IsT0FBT2x3QyxTQUFTO0FBQ2xCO0FBQ0E2dkMsbUJBQW1CMy9ELFNBQVMsQ0FBQ2tnRSxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJyL0MsRUFBRSxFQUFFbS9DLE1BQU07SUFDckYsT0FBUSxJQUFJLENBQUMvRSxVQUFVLENBQUM1RixjQUFjO1FBQ3BDLEtBQUs1QixpQkFBaUJJLFNBQVM7WUFDN0JtTSxPQUFPUixZQUFZLENBQUMzK0M7WUFDcEI7UUFDRixLQUFLNHlDLGlCQUFpQnlCLFVBQVU7WUFDOUI4SyxPQUFPckMsWUFBWSxDQUFDOThDO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E4K0MsbUJBQW1CMy9ELFNBQVMsQ0FBQzRnRSxZQUFZLEdBQUcsU0FBU0EsYUFBY2YsUUFBUSxFQUFFdDZELFFBQVE7SUFDbkYsSUFBSSxDQUFDcTZDLFNBQVMsR0FBR3I2QztJQUNqQixJQUFJQSxXQUFXLE9BQU8sQ0FBQyxJQUFJLENBQUMwMUQsVUFBVSxDQUFDM0YsYUFBYSxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQ3RFLElBQUkvdkQsYUFBYSxLQUFLO1FBQUUsT0FBTztJQUFLO0lBQ3BDLElBQUl3NkQsY0FBY3IvRCxLQUFLeUIsR0FBRyxDQUFDb0Q7SUFDM0IsSUFBSXk2RCxTQUFTLElBQUksQ0FBQ0MsU0FBUyxDQUFDRjtJQUM1QixJQUFJRixTQUFTcC9ELE1BQU0sSUFBSSxHQUFHO1FBQ3hCLElBQUksQ0FBQ3kvRCxpQkFBaUIsQ0FBQ0wsUUFBUSxDQUFDLEVBQUUsRUFBRUc7SUFDdEMsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDL0UsVUFBVSxDQUFDM0YsYUFBYSxJQUFJO1lBQ25DLElBQUl3SyxjQUFjdjZELFdBQVc7WUFDN0IsSUFBSSxDQUFDODZELDZCQUE2QixDQUFDUixVQUFVQyxhQUFhRTtRQUM1RCxPQUFPO1lBQUUsSUFBSSxDQUFDVyxzQkFBc0IsQ0FBQ2QsVUFBVUc7UUFBUztJQUMxRDtJQUNBLElBQUlhLFlBQVliLE9BQU90b0MsY0FBYztJQUNyQyxPQUFPbXBDO0FBQ1Q7QUFDQWxCLG1CQUFtQjMvRCxTQUFTLENBQUM4Z0UsbUJBQW1CLEdBQUcsU0FBU0E7SUFDMUQsT0FBTyxJQUFJLENBQUM3RixVQUFVO0FBQ3hCO0FBQ0EwRSxtQkFBbUIzL0QsU0FBUyxDQUFDdWdFLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQlEsV0FBVztJQUN0RixPQUFPQSxjQUFjLElBQUksQ0FBQzlGLFVBQVUsQ0FBQ3RGLGlCQUFpQjtBQUN4RDtBQUNBZ0ssbUJBQW1CMy9ELFNBQVMsQ0FBQ2doRSxZQUFZLEdBQUcsU0FBU0EsYUFBY25CLFFBQVEsRUFBRXQyQixJQUFJLEVBQUVoa0MsUUFBUTtJQUN6RixJQUFJLENBQUNxNkMsU0FBUyxHQUFHcjZDO0lBQ2pCLElBQUlzNkQsU0FBU3AvRCxNQUFNLElBQUksR0FBRztRQUFFLE9BQU8sSUFBSSxDQUFDbWdFLFlBQVksQ0FBQ2YsVUFBVXQ2RDtJQUFVO0lBQ3pFLElBQUlBLGFBQWEsS0FBSztRQUNwQixPQUFPbzZELG1CQUFtQnNCLGVBQWUsQ0FBQ3BCO0lBQzVDO0lBQ0EsSUFBSUcsU0FBUyxJQUFJLENBQUNDLFNBQVMsQ0FBQzE2RDtJQUM1QixJQUFJLENBQUNtN0Qsc0JBQXNCLENBQUNiLFVBQVV0MkIsTUFBTXkyQjtJQUM1QyxPQUFPQSxPQUFPdG9DLGNBQWM7QUFDOUI7QUFDQWlvQyxtQkFBbUIzL0QsU0FBUyxDQUFDbWdFLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQk4sUUFBUSxFQUFFQyxXQUFXLEVBQUVFLE1BQU07SUFDMUcsSUFBSU0sVUFBVSxJQUFJLENBQUNDLGlCQUFpQixDQUFDLElBQUksQ0FBQzNnQixTQUFTO0lBQ25ELElBQUlrZ0IsYUFBYTtRQUNmLElBQUlVLFFBQVF0SywwQkFBMEJ3QixRQUFRLENBQUNtSSxVQUFVLENBQUNTO1FBQzFELElBQUkzK0MsS0FBSzYrQyxNQUFNLy9ELE1BQU0sR0FBRztRQUN4QnUvRCxPQUFPakMsZ0JBQWdCLENBQUN5QyxLQUFLLENBQUM3K0MsR0FBRyxFQUFFNitDLEtBQUssQ0FBQzcrQyxLQUFLLEVBQUUsRUFBRTJtQixTQUFTcmlCLElBQUk7UUFDL0QrNUMsT0FBT25DLGVBQWU7UUFDdEIsSUFBSyxJQUFJejJELElBQUl1YSxLQUFLLEdBQUd2YSxLQUFLLEdBQUdBLElBQUs7WUFDaEM0NEQsT0FBTzlELGNBQWMsQ0FBQ3NFLEtBQUssQ0FBQ3A1RCxFQUFFLEVBQUU7UUFDbEM7SUFDRixPQUFPO1FBQ0wsSUFBSXE1RCxRQUFRdkssMEJBQTBCd0IsUUFBUSxDQUFDbUksVUFBVVM7UUFDekQsSUFBSTUrQyxLQUFLKytDLE1BQU1oZ0UsTUFBTSxHQUFHO1FBQ3hCdS9ELE9BQU9qQyxnQkFBZ0IsQ0FBQzBDLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVuNEIsU0FBU3JpQixJQUFJO1FBQ3pEKzVDLE9BQU9uQyxlQUFlO1FBQ3RCLElBQUssSUFBSWo0QyxNQUFNLEdBQUdBLE9BQU9sRSxJQUFJa0UsTUFBTztZQUNsQ282QyxPQUFPOUQsY0FBYyxDQUFDdUUsS0FBSyxDQUFDNzZDLElBQUksRUFBRTtRQUNwQztJQUNGO0lBQ0FvNkMsT0FBT2xDLGNBQWM7QUFDdkI7QUFDQTZCLG1CQUFtQjMvRCxTQUFTLENBQUNpZ0UsU0FBUyxHQUFHLFNBQVNBLFVBQVcxNkQsUUFBUTtJQUNuRSxPQUFPLElBQUlxMUQsdUJBQXVCLElBQUksQ0FBQ244QyxlQUFlLEVBQUUsSUFBSSxDQUFDdzhDLFVBQVUsRUFBRTExRDtBQUMzRTtBQUNBbzZELG1CQUFtQjMvRCxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTyxFQUFFO0FBQ1g7QUFDQTg5RCxtQkFBbUIzL0QsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU82OUQ7QUFDVDtBQUNBQSxtQkFBbUJzQixlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCaDZDLEdBQUc7SUFDaEUsSUFBSWppQixPQUFPLElBQUlqRixNQUFNa25CLElBQUl4bUIsTUFBTSxFQUFFSixJQUFJLENBQUM7SUFDdEMsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJcEMsS0FBS3ZFLE1BQU0sRUFBRTJHLElBQUs7UUFDcENwQyxJQUFJLENBQUNvQyxFQUFFLEdBQUcsSUFBSTFELFdBQVd1akIsR0FBRyxDQUFDN2YsRUFBRTtJQUNqQztJQUNBLE9BQU9wQztBQUNUO0FBRUEsSUFBSWs4RCx1QkFBdUIsU0FBU0E7SUFDbEMsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSTNWO0lBQ2hCLElBQUksQ0FBQzRWLElBQUksR0FBRyxJQUFJNy9DO0lBQ2hCLElBQUk4L0MsWUFBWXhnRSxTQUFTLENBQUMsRUFBRTtJQUM1QixJQUFJLENBQUNxZ0UsVUFBVSxHQUFHRztBQUNwQjtBQUVBLElBQUlDLHFCQUFxQjtJQUFFQyxjQUFjO1FBQUVyaEUsY0FBYztJQUFLO0FBQUU7QUFDaEUrZ0UscUJBQXFCbGhFLFNBQVMsQ0FBQ3loRSxtQkFBbUIsR0FBRyxTQUFTQTtJQUMxRCxJQUFJbm5ELFNBQVMsSUFBSTtJQUVuQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSWloRSxvQkFBb0I1Z0UsU0FBUyxDQUFDLEVBQUU7UUFDcEMsSUFBSTZnRSxrQkFBa0IsSUFBSW4wQztRQUMxQixJQUFLLElBQUlwbUIsSUFBSSxJQUFJLENBQUMrNUQsVUFBVSxDQUFDOTFDLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUNyRCxJQUFJcTJDLE1BQU14NkQsRUFBRXNnQixJQUFJO1lBQ2hCLElBQUl6VCxNQUFNMnRELElBQUluM0MsV0FBVztZQUN6QixJQUFJaTNDLGtCQUFrQi85RCxDQUFDLEdBQUdzUSxJQUFJK0MsT0FBTyxNQUFNMHFELGtCQUFrQi85RCxDQUFDLEdBQUdzUSxJQUFJNkMsT0FBTyxJQUFJO2dCQUFFO1lBQVM7WUFDM0Z3RCxPQUFPbW5ELG1CQUFtQixDQUFDQyxtQkFBbUJFLElBQUl2MEIsZ0JBQWdCLElBQUlzMEI7UUFDeEU7UUFDQSxPQUFPQTtJQUNULE9BQU8sSUFBSTdnRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJMEcsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVzc0IsU0FBVXRzQixTQUFTLENBQUMsRUFBRSxZQUFZNEMsY0FBYzVDLFNBQVMsQ0FBQyxFQUFFLFlBQVltM0MsY0FBZTtZQUNwSCxJQUFJNHBCLHNCQUFzQi9nRSxTQUFTLENBQUMsRUFBRTtZQUN0QyxJQUFJa3NDLFVBQVVsc0MsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSWdoRSxvQkFBb0JoaEUsU0FBUyxDQUFDLEVBQUU7WUFDcEMsSUFBSW1tQixNQUFNK2xCLFFBQVFyRCxPQUFPLEdBQUdqUyxjQUFjO1lBQzFDLElBQUssSUFBSTlSLE1BQU0sR0FBR0EsTUFBTXFCLElBQUl4bUIsTUFBTSxHQUFHLEdBQUdtbEIsTUFBTztnQkFDN0N0TCxPQUFPOG1ELElBQUksQ0FBQzlqRCxFQUFFLEdBQUcySixHQUFHLENBQUNyQixJQUFJO2dCQUN6QnRMLE9BQU84bUQsSUFBSSxDQUFDN3ZELEVBQUUsR0FBRzBWLEdBQUcsQ0FBQ3JCLE1BQU0sRUFBRTtnQkFDN0IsSUFBSXRMLE9BQU84bUQsSUFBSSxDQUFDOWpELEVBQUUsQ0FBQzNaLENBQUMsR0FBRzJXLE9BQU84bUQsSUFBSSxDQUFDN3ZELEVBQUUsQ0FBQzVOLENBQUMsRUFBRTtvQkFBRTJXLE9BQU84bUQsSUFBSSxDQUFDandDLE9BQU87Z0JBQUk7Z0JBQ2xFLElBQUlqTSxPQUFPeGtCLEtBQUtDLEdBQUcsQ0FBQzJaLE9BQU84bUQsSUFBSSxDQUFDOWpELEVBQUUsQ0FBQzViLENBQUMsRUFBRTRZLE9BQU84bUQsSUFBSSxDQUFDN3ZELEVBQUUsQ0FBQzdQLENBQUM7Z0JBQ3RELElBQUl3akIsT0FBTzI4QyxvQkFBb0JuZ0UsQ0FBQyxFQUFFO29CQUFFO2dCQUFTO2dCQUM3QyxJQUFJNFksT0FBTzhtRCxJQUFJLENBQUNqVCxZQUFZLElBQUk7b0JBQUU7Z0JBQVM7Z0JBQzNDLElBQUkwVCxvQkFBb0JsK0QsQ0FBQyxHQUFHMlcsT0FBTzhtRCxJQUFJLENBQUM5akQsRUFBRSxDQUFDM1osQ0FBQyxJQUFJaytELG9CQUFvQmwrRCxDQUFDLEdBQUcyVyxPQUFPOG1ELElBQUksQ0FBQzd2RCxFQUFFLENBQUM1TixDQUFDLEVBQUU7b0JBQUU7Z0JBQVM7Z0JBQ3JHLElBQUk2ZCxhQUFhb0csa0JBQWtCLENBQUN0TixPQUFPOG1ELElBQUksQ0FBQzlqRCxFQUFFLEVBQUVoRCxPQUFPOG1ELElBQUksQ0FBQzd2RCxFQUFFLEVBQUVzd0QseUJBQXlCcmdELGFBQWF1RSxLQUFLLEVBQUU7b0JBQUU7Z0JBQVM7Z0JBQzVILElBQUltVyxRQUFROFEsUUFBUVYsUUFBUSxDQUFDaEUsU0FBU3JpQixJQUFJO2dCQUMxQyxJQUFJLENBQUMzTCxPQUFPOG1ELElBQUksQ0FBQzlqRCxFQUFFLENBQUMzWSxNQUFNLENBQUNzaUIsR0FBRyxDQUFDckIsSUFBSSxHQUFHO29CQUFFc1csUUFBUThRLFFBQVFWLFFBQVEsQ0FBQ2hFLFNBQVN2aUIsS0FBSztnQkFBRztnQkFDbEYsSUFBSWc4QyxLQUFLLElBQUlQLGFBQWFsbkQsT0FBTzhtRCxJQUFJLEVBQUVsbEM7Z0JBQ3ZDNGxDLGtCQUFrQjcxRCxHQUFHLENBQUM4MUQ7WUFDeEI7UUFDRixPQUFPLElBQUk1NkQsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVzc0IsU0FBVXRzQixTQUFTLENBQUMsRUFBRSxZQUFZNEMsY0FBY3lELGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFc3NCLE9BQVE7WUFDdkgsSUFBSTQwQyxzQkFBc0JsaEUsU0FBUyxDQUFDLEVBQUU7WUFDdEMsSUFBSTY3QyxXQUFXNzdDLFNBQVMsQ0FBQyxFQUFFO1lBQzNCLElBQUltaEUsb0JBQW9CbmhFLFNBQVMsQ0FBQyxFQUFFO1lBQ3BDLElBQUssSUFBSXV1QixNQUFNc3RCLFNBQVN0eEIsUUFBUSxJQUFJZ0UsSUFBSTlELE9BQU8sSUFBSztnQkFDbEQsSUFBSStkLEtBQUtqYSxJQUFJM0gsSUFBSTtnQkFDakIsSUFBSSxDQUFDNGhCLEdBQUdnQixTQUFTLElBQUk7b0JBQUU7Z0JBQVM7Z0JBQ2hDaHdCLE9BQU9tbkQsbUJBQW1CLENBQUNPLHFCQUFxQjE0QixJQUFJMjRCO1lBQ3REO1FBQ0Y7SUFDRjtBQUNGO0FBQ0FmLHFCQUFxQmxoRSxTQUFTLENBQUNzc0MsUUFBUSxHQUFHLFNBQVNBLFNBQVV0M0IsQ0FBQztJQUM1RCxJQUFJMnNELGtCQUFrQixJQUFJLENBQUNGLG1CQUFtQixDQUFDenNEO0lBQy9DLElBQUkyc0QsZ0JBQWdCaHVELElBQUksT0FBTyxHQUFHO1FBQUUsT0FBTztJQUFFO0lBQzdDLElBQUlvdUQsS0FBSzFpQixZQUFZeitDLEdBQUcsQ0FBQytnRTtJQUN6QixPQUFPSSxHQUFHRyxVQUFVO0FBQ3RCO0FBQ0FoQixxQkFBcUJsaEUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sRUFBRTtBQUNYO0FBQ0FxL0QscUJBQXFCbGhFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNqRCxPQUFPby9EO0FBQ1Q7QUFDQUssbUJBQW1CQyxZQUFZLENBQUNwK0QsR0FBRyxHQUFHO0lBQWMsT0FBT28rRDtBQUFhO0FBRXhFdmhFLE9BQU9vRCxnQkFBZ0IsQ0FBRTY5RCxzQkFBc0JLO0FBRS9DLElBQUlDLGVBQWUsU0FBU0E7SUFDMUIsSUFBSSxDQUFDVyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDRCxVQUFVLEdBQUc7SUFDbEIsSUFBSXRXLE1BQU05cUQsU0FBUyxDQUFDLEVBQUU7SUFDdEIsSUFBSW83QixRQUFRcDdCLFNBQVMsQ0FBQyxFQUFFO0lBQ3hCLElBQUksQ0FBQ3FoRSxVQUFVLEdBQUcsSUFBSTFXLFlBQVlHO0lBQ2xDLElBQUksQ0FBQ3NXLFVBQVUsR0FBR2htQztBQUNwQjtBQUNBc2xDLGFBQWF4aEUsU0FBUyxDQUFDNkUsU0FBUyxHQUFHLFNBQVNBLFVBQVdtcUIsR0FBRztJQUN4RCxJQUFJeHFCLFFBQVF3cUI7SUFDWixJQUFJLElBQUksQ0FBQ216QyxVQUFVLENBQUN4VyxJQUFJLE1BQU1ubkQsTUFBTTI5RCxVQUFVLENBQUNqVixJQUFJLElBQUk7UUFBRSxPQUFPO0lBQUU7SUFDbEUsSUFBSSxJQUFJLENBQUNpVixVQUFVLENBQUNqVixJQUFJLE1BQU0xb0QsTUFBTTI5RCxVQUFVLENBQUN4VyxJQUFJLElBQUk7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUNuRSxJQUFJeVcsY0FBYyxJQUFJLENBQUNELFVBQVUsQ0FBQzd3RCxnQkFBZ0IsQ0FBQzlNLE1BQU0yOUQsVUFBVTtJQUNuRSxJQUFJQyxnQkFBZ0IsR0FBRztRQUFFLE9BQU9BO0lBQVk7SUFDNUNBLGNBQWMsQ0FBQyxJQUFJNTlELE1BQU0yOUQsVUFBVSxDQUFDN3dELGdCQUFnQixDQUFDLElBQUksQ0FBQzZ3RCxVQUFVO0lBQ3BFLElBQUlDLGdCQUFnQixHQUFHO1FBQUUsT0FBT0E7SUFBWTtJQUM1QyxPQUFPLElBQUksQ0FBQ0QsVUFBVSxDQUFDdDlELFNBQVMsQ0FBQ0wsTUFBTTI5RCxVQUFVO0FBQ25EO0FBQ0FYLGFBQWF4aEUsU0FBUyxDQUFDcWlFLFFBQVEsR0FBRyxTQUFTQSxTQUFVQyxJQUFJLEVBQUVDLElBQUk7SUFDN0QsSUFBSUMsV0FBV0YsS0FBS2hsRCxFQUFFLENBQUN6WSxTQUFTLENBQUMwOUQsS0FBS2psRCxFQUFFO0lBQ3hDLElBQUlrbEQsYUFBYSxHQUFHO1FBQUUsT0FBT0E7SUFBUztJQUN0QyxPQUFPRixLQUFLL3dELEVBQUUsQ0FBQzFNLFNBQVMsQ0FBQzA5RCxLQUFLaHhELEVBQUU7QUFDbEM7QUFDQWl3RCxhQUFheGhFLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPLElBQUksQ0FBQ2s5RCxVQUFVLENBQUNsOUQsUUFBUTtBQUNqQztBQUNBdThELGFBQWF4aEUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzVDLE9BQU87UUFBQ3lCO0tBQVc7QUFDckI7QUFDQWsrRCxhQUFheGhFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPMC9EO0FBQ1Q7QUFFQSxJQUFJaUIsV0FBVyxTQUFTQSxTQUFVbmxELEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUMxQyxJQUFJLENBQUM4TCxFQUFFLEdBQUdBLE1BQU07SUFDaEIsSUFBSSxDQUFDL0wsRUFBRSxHQUFHQSxNQUFNO0lBQ2hCLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxNQUFNO0FBQ2xCO0FBQ0FpeEQsU0FBU3ppRSxTQUFTLENBQUM2M0IsSUFBSSxHQUFHLFNBQVNBO0lBQ2pDLE9BQU80cUMsU0FBUzVxQyxJQUFJLENBQUMsSUFBSSxDQUFDdmEsRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUU7QUFDaEQ7QUFDQWl4RCxTQUFTemlFLFNBQVMsQ0FBQ21tQixVQUFVLEdBQUcsU0FBU0E7SUFDdkMsT0FBT3M4QyxTQUFTdDhDLFVBQVUsQ0FBQyxJQUFJLENBQUM3SSxFQUFFLEVBQUUsSUFBSSxDQUFDL0wsRUFBRSxFQUFFLElBQUksQ0FBQ0MsRUFBRTtBQUN0RDtBQUNBaXhELFNBQVN6aUUsU0FBUyxDQUFDMGlFLFlBQVksR0FBRyxTQUFTQSxhQUFjMXRELENBQUM7SUFDeEQsSUFBSUEsTUFBTSxNQUFNO1FBQUUsTUFBTSxJQUFJNVMseUJBQXlCO0lBQTJCO0lBQ2hGLE9BQU9xZ0UsU0FBU0MsWUFBWSxDQUFDMXRELEdBQUcsSUFBSSxDQUFDc0ksRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUU7QUFDM0Q7QUFDQWl4RCxTQUFTemlFLFNBQVMsQ0FBQzJpRSxpQkFBaUIsR0FBRyxTQUFTQTtJQUM5QyxPQUFPRixTQUFTRSxpQkFBaUIsQ0FBQyxJQUFJLENBQUNybEQsRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUU7QUFDN0Q7QUFDQWl4RCxTQUFTemlFLFNBQVMsQ0FBQ201RCxPQUFPLEdBQUcsU0FBU0E7SUFDcEMsT0FBT3NKLFNBQVN0SixPQUFPLENBQUMsSUFBSSxDQUFDNzdDLEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUUsSUFBSSxDQUFDQyxFQUFFO0FBQ25EO0FBQ0FpeEQsU0FBU3ppRSxTQUFTLENBQUM0aUUsWUFBWSxHQUFHLFNBQVNBO0lBQ3pDLE9BQU9ILFNBQVNHLFlBQVksQ0FBQyxJQUFJLENBQUN0bEQsRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUU7QUFDeEQ7QUFDQWl4RCxTQUFTemlFLFNBQVMsQ0FBQzZpRSxNQUFNLEdBQUcsU0FBU0E7SUFDbkMsT0FBT0osU0FBU0ksTUFBTSxDQUFDLElBQUksQ0FBQ3ZsRCxFQUFFLEVBQUUsSUFBSSxDQUFDL0wsRUFBRSxFQUFFLElBQUksQ0FBQ0MsRUFBRTtBQUNsRDtBQUNBaXhELFNBQVN6aUUsU0FBUyxDQUFDOGlFLFFBQVEsR0FBRyxTQUFTQTtJQUNyQyxPQUFPTCxTQUFTSyxRQUFRLENBQUMsSUFBSSxDQUFDeGxELEVBQUUsRUFBRSxJQUFJLENBQUMvTCxFQUFFLEVBQUUsSUFBSSxDQUFDQyxFQUFFO0FBQ3BEO0FBQ0FpeEQsU0FBU3ppRSxTQUFTLENBQUMraUUsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU9OLFNBQVNNLFFBQVEsQ0FBQyxJQUFJLENBQUN6bEQsRUFBRSxFQUFFLElBQUksQ0FBQy9MLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUU7QUFDcEQ7QUFDQWl4RCxTQUFTemlFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxPQUFPLEVBQUU7QUFDWDtBQUNBNGdFLFNBQVN6aUUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8yZ0U7QUFDVDtBQUNBQSxTQUFTNXFDLElBQUksR0FBRyxTQUFTQSxLQUFNcnhCLENBQUMsRUFBRUMsQ0FBQyxFQUFFM0MsQ0FBQztJQUNwQyxPQUFPcEQsS0FBS3lCLEdBQUcsQ0FBQyxDQUFDLENBQUMyQixFQUFFcEMsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUMsSUFBSytFLENBQUFBLEVBQUU5QyxDQUFDLEdBQUc2QyxFQUFFN0MsQ0FBQyxJQUFJLENBQUM4QyxFQUFFL0UsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUMsSUFBS29DLENBQUFBLEVBQUVILENBQUMsR0FBRzZDLEVBQUU3QyxDQUFDLEtBQUs7QUFDNUU7QUFDQTgrRCxTQUFTdDhDLFVBQVUsR0FBRyxTQUFTQSxXQUFZM2YsQ0FBQyxFQUFFQyxDQUFDLEVBQUUzQyxDQUFDO0lBQ2hELE9BQU8sQ0FBQyxDQUFDQSxFQUFFcEMsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUMsSUFBSytFLENBQUFBLEVBQUU5QyxDQUFDLEdBQUc2QyxFQUFFN0MsQ0FBQyxJQUFJLENBQUM4QyxFQUFFL0UsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUMsSUFBS29DLENBQUFBLEVBQUVILENBQUMsR0FBRzZDLEVBQUU3QyxDQUFDLEtBQUs7QUFDbkU7QUFDQTgrRCxTQUFTdndELEdBQUcsR0FBRyxTQUFTQSxJQUFLOHdELEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDN0MsT0FBT0gsTUFBTUcsTUFBTUYsTUFBTUM7QUFDM0I7QUFDQVQsU0FBU0MsWUFBWSxHQUFHLFNBQVNBLGFBQWMxdEQsQ0FBQyxFQUFFb3VELEVBQUUsRUFBRXg3RCxFQUFFLEVBQUVDLEVBQUU7SUFDMUQsSUFBSXdlLEtBQUsrOEMsR0FBRzFoRSxDQUFDO0lBQ2IsSUFBSXdsQixLQUFLazhDLEdBQUd6L0QsQ0FBQztJQUNiLElBQUk2QyxJQUFJb0IsR0FBR2xHLENBQUMsR0FBRzJrQjtJQUNmLElBQUk1ZixJQUFJb0IsR0FBR25HLENBQUMsR0FBRzJrQjtJQUNmLElBQUl2aUIsSUFBSThELEdBQUdqRSxDQUFDLEdBQUd1akI7SUFDZixJQUFJelcsSUFBSTVJLEdBQUdsRSxDQUFDLEdBQUd1akI7SUFDZixJQUFJaFYsTUFBTTFMLElBQUlpSyxJQUFJaEssSUFBSTNDO0lBQ3RCLElBQUlxQixLQUFLNlAsRUFBRXRULENBQUMsR0FBRzJrQjtJQUNmLElBQUlqaEIsS0FBSzRQLEVBQUVyUixDQUFDLEdBQUd1akI7SUFDZixJQUFJdFksSUFBSSxDQUFDNkIsSUFBSXRMLEtBQUtzQixJQUFJckIsRUFBQyxJQUFLOE07SUFDNUIsSUFBSWxGLElBQUksQ0FBQyxDQUFDbEosSUFBSXFCLEtBQUtxQixJQUFJcEIsRUFBQyxJQUFLOE07SUFDN0IsSUFBSXRPLElBQUl3L0QsR0FBR3gvRCxDQUFDLEdBQUdnTCxJQUFLaEgsQ0FBQUEsR0FBR2hFLENBQUMsR0FBR3cvRCxHQUFHeC9ELENBQUMsSUFBSW9KLElBQUtuRixDQUFBQSxHQUFHakUsQ0FBQyxHQUFHdy9ELEdBQUd4L0QsQ0FBQztJQUNuRCxPQUFPQTtBQUNUO0FBQ0E2K0QsU0FBU0UsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CbjhELENBQUMsRUFBRUMsQ0FBQyxFQUFFM0MsQ0FBQztJQUM5RCxJQUFJdS9ELFFBQVE3OEQsRUFBRWpCLFFBQVEsQ0FBQ2tCO0lBQ3ZCLElBQUk2OEQsUUFBUTc4RCxFQUFFbEIsUUFBUSxDQUFDekI7SUFDdkIsSUFBSXkvRCxRQUFRei9ELEVBQUV5QixRQUFRLENBQUNpQjtJQUN2QixJQUFJZzlELFNBQVNIO0lBQ2IsSUFBSUMsUUFBUUUsUUFBUTtRQUFFQSxTQUFTRjtJQUFPO0lBQ3RDLElBQUlDLFFBQVFDLFFBQVE7UUFBRUEsU0FBU0Q7SUFBTztJQUN0QyxPQUFPQztBQUNUO0FBQ0FmLFNBQVN0SixPQUFPLEdBQUcsU0FBU0EsUUFBUzN5RCxDQUFDLEVBQUVDLENBQUMsRUFBRTNDLENBQUM7SUFDMUMsSUFBSSxDQUFDODBELE1BQU1PLE9BQU8sQ0FBQzN5RCxHQUFHQyxHQUFHM0MsSUFBSTtRQUFFLE9BQU87SUFBTTtJQUM1QyxJQUFJLENBQUM4MEQsTUFBTU8sT0FBTyxDQUFDMXlELEdBQUczQyxHQUFHMEMsSUFBSTtRQUFFLE9BQU87SUFBTTtJQUM1QyxJQUFJLENBQUNveUQsTUFBTU8sT0FBTyxDQUFDcjFELEdBQUcwQyxHQUFHQyxJQUFJO1FBQUUsT0FBTztJQUFNO0lBQzVDLE9BQU87QUFDVDtBQUNBZzhELFNBQVNHLFlBQVksR0FBRyxTQUFTQSxhQUFjcDhELENBQUMsRUFBRUMsQ0FBQyxFQUFFM0MsQ0FBQztJQUNwRCxJQUFJMi9ELEtBQUszL0QsRUFBRXBDLENBQUM7SUFDWixJQUFJZ2lFLEtBQUs1L0QsRUFBRUgsQ0FBQztJQUNaLElBQUl1SyxLQUFLMUgsRUFBRTlFLENBQUMsR0FBRytoRTtJQUNmLElBQUlFLEtBQUtuOUQsRUFBRTdDLENBQUMsR0FBRysvRDtJQUNmLElBQUlFLEtBQUtuOUQsRUFBRS9FLENBQUMsR0FBRytoRTtJQUNmLElBQUlJLEtBQUtwOUQsRUFBRTlDLENBQUMsR0FBRysvRDtJQUNmLElBQUlseEQsUUFBUSxJQUFJaXdELFNBQVN2d0QsR0FBRyxDQUFDaEUsSUFBSXkxRCxJQUFJQyxJQUFJQztJQUN6QyxJQUFJbHhELE9BQU84dkQsU0FBU3Z3RCxHQUFHLENBQUN5eEQsSUFBSXoxRCxLQUFLQSxLQUFLeTFELEtBQUtBLElBQUlFLElBQUlELEtBQUtBLEtBQUtDLEtBQUtBO0lBQ2xFLElBQUk5d0QsT0FBTzB2RCxTQUFTdndELEdBQUcsQ0FBQ2hFLElBQUlBLEtBQUtBLEtBQUt5MUQsS0FBS0EsSUFBSUMsSUFBSUEsS0FBS0EsS0FBS0MsS0FBS0E7SUFDbEUsSUFBSUMsTUFBTUwsS0FBSzl3RCxPQUFPSDtJQUN0QixJQUFJdXhELE1BQU1MLEtBQUszd0QsT0FBT1A7SUFDdEIsT0FBTyxJQUFJOU8sV0FBV29nRSxLQUFLQztBQUM3QjtBQUNBdEIsU0FBU3VCLHFCQUFxQixHQUFHLFNBQVNBLHNCQUF1Qng5RCxDQUFDLEVBQUVDLENBQUM7SUFDbkUsSUFBSXRCLEtBQUtzQixFQUFFL0UsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUM7SUFDbEIsSUFBSTBELEtBQUtxQixFQUFFOUMsQ0FBQyxHQUFHNkMsRUFBRTdDLENBQUM7SUFDbEIsSUFBSXNnRSxLQUFLLElBQUludkQsWUFBWXRPLEVBQUU5RSxDQUFDLEdBQUd5RCxLQUFLLEtBQUtxQixFQUFFN0MsQ0FBQyxHQUFHeUIsS0FBSyxLQUFLO0lBQ3pELElBQUk4K0QsS0FBSyxJQUFJcHZELFlBQVl0TyxFQUFFOUUsQ0FBQyxHQUFHMEQsS0FBS0QsS0FBSyxLQUFLcUIsRUFBRTdDLENBQUMsR0FBR3dCLEtBQUtDLEtBQUssS0FBSztJQUNuRSxPQUFPLElBQUkwUCxZQUFZbXZELElBQUlDO0FBQzdCO0FBQ0F6QixTQUFTMEIsYUFBYSxHQUFHLFNBQVNBLGNBQWUzOUQsQ0FBQyxFQUFFQyxDQUFDLEVBQUUzQyxDQUFDO0lBQ3RELElBQUlzZ0UsT0FBTzM5RCxFQUFFbEIsUUFBUSxDQUFDaUI7SUFDdEIsSUFBSXNoQixPQUFPcmhCLEVBQUVsQixRQUFRLENBQUN6QjtJQUN0QixJQUFJdWdFLE9BQU9ELE9BQVFBLENBQUFBLE9BQU90OEMsSUFBRztJQUM3QixJQUFJM2lCLEtBQUtyQixFQUFFcEMsQ0FBQyxHQUFHOEUsRUFBRTlFLENBQUM7SUFDbEIsSUFBSTBELEtBQUt0QixFQUFFSCxDQUFDLEdBQUc2QyxFQUFFN0MsQ0FBQztJQUNsQixJQUFJMmdFLFVBQVUsSUFBSTVnRSxXQUFXOEMsRUFBRTlFLENBQUMsR0FBRzJpRSxPQUFPbC9ELElBQUlxQixFQUFFN0MsQ0FBQyxHQUFHMGdFLE9BQU9qL0Q7SUFDM0QsT0FBT2svRDtBQUNUO0FBQ0E3QixTQUFTSSxNQUFNLEdBQUcsU0FBU0EsT0FBUXI4RCxDQUFDLEVBQUVDLENBQUMsRUFBRTNDLENBQUM7SUFDeEMsSUFBSTZwRCxLQUFLbG5ELEVBQUUvRSxDQUFDLEdBQUc4RSxFQUFFOUUsQ0FBQztJQUNsQixJQUFJa3NELEtBQUtubkQsRUFBRTlDLENBQUMsR0FBRzZDLEVBQUU3QyxDQUFDO0lBQ2xCLElBQUk0Z0UsS0FBSzk5RCxFQUFFN0MsQ0FBQyxHQUFHNEMsRUFBRTVDLENBQUM7SUFDbEIsSUFBSTRnRSxLQUFLMWdFLEVBQUVwQyxDQUFDLEdBQUc4RSxFQUFFOUUsQ0FBQztJQUNsQixJQUFJK2lFLEtBQUszZ0UsRUFBRUgsQ0FBQyxHQUFHNkMsRUFBRTdDLENBQUM7SUFDbEIsSUFBSStnRSxLQUFLNWdFLEVBQUVGLENBQUMsR0FBRzRDLEVBQUU1QyxDQUFDO0lBQ2xCLElBQUkrZ0UsU0FBUy9XLEtBQUs4VyxLQUFLSCxLQUFLRTtJQUM1QixJQUFJRyxTQUFTTCxLQUFLQyxLQUFLN1csS0FBSytXO0lBQzVCLElBQUlHLFNBQVNsWCxLQUFLOFcsS0FBSzdXLEtBQUs0VztJQUM1QixJQUFJTSxRQUFRSCxTQUFTQSxTQUFTQyxTQUFTQSxTQUFTQyxTQUFTQTtJQUN6RCxJQUFJaEMsU0FBU25pRSxLQUFLNEUsSUFBSSxDQUFDdy9ELFNBQVM7SUFDaEMsT0FBT2pDO0FBQ1Q7QUFDQUosU0FBU0ssUUFBUSxHQUFHLFNBQVNBLFNBQVV0OEQsQ0FBQyxFQUFFQyxDQUFDLEVBQUUzQyxDQUFDO0lBQzVDLElBQUlwQyxJQUFJLENBQUM4RSxFQUFFOUUsQ0FBQyxHQUFHK0UsRUFBRS9FLENBQUMsR0FBR29DLEVBQUVwQyxDQUFDLElBQUk7SUFDNUIsSUFBSWlDLElBQUksQ0FBQzZDLEVBQUU3QyxDQUFDLEdBQUc4QyxFQUFFOUMsQ0FBQyxHQUFHRyxFQUFFSCxDQUFDLElBQUk7SUFDNUIsT0FBTyxJQUFJRCxXQUFXaEMsR0FBR2lDO0FBQzNCO0FBQ0E4K0QsU0FBU00sUUFBUSxHQUFHLFNBQVNBLFNBQVV2OEQsQ0FBQyxFQUFFQyxDQUFDLEVBQUUzQyxDQUFDO0lBQzVDLElBQUlzZ0UsT0FBTzM5RCxFQUFFbEIsUUFBUSxDQUFDekI7SUFDdEIsSUFBSWloRSxPQUFPditELEVBQUVqQixRQUFRLENBQUN6QjtJQUN0QixJQUFJZ2tCLE9BQU90aEIsRUFBRWpCLFFBQVEsQ0FBQ2tCO0lBQ3RCLElBQUl1K0QsU0FBU1osT0FBT1csT0FBT2o5QztJQUMzQixJQUFJbTlDLFlBQVksQ0FBQ2IsT0FBTzU5RCxFQUFFOUUsQ0FBQyxHQUFHcWpFLE9BQU90K0QsRUFBRS9FLENBQUMsR0FBR29tQixPQUFPaGtCLEVBQUVwQyxDQUFDLElBQUlzakU7SUFDekQsSUFBSUUsWUFBWSxDQUFDZCxPQUFPNTlELEVBQUU3QyxDQUFDLEdBQUdvaEUsT0FBT3QrRCxFQUFFOUMsQ0FBQyxHQUFHbWtCLE9BQU9oa0IsRUFBRUgsQ0FBQyxJQUFJcWhFO0lBQ3pELE9BQU8sSUFBSXRoRSxXQUFXdWhFLFdBQVdDO0FBQ25DO0FBRUEsSUFBSUMsd0JBQXdCLFNBQVNBO0lBQ25DLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ3hsQixTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDeWxCLGFBQWEsR0FBRztJQUNyQixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJOTNDO0lBQ3RCLElBQUkrM0MsWUFBWXprRSxTQUFTLENBQUMsRUFBRTtJQUM1QixJQUFJeUUsV0FBV3pFLFNBQVMsQ0FBQyxFQUFFO0lBQzNCLElBQUkwa0UsZUFBZTFrRSxTQUFTLENBQUMsRUFBRTtJQUMvQixJQUFJLENBQUNza0UsVUFBVSxHQUFHRztJQUNsQixJQUFJLENBQUMzbEIsU0FBUyxHQUFHcjZDO0lBQ2pCLElBQUksQ0FBQzgvRCxhQUFhLEdBQUdHO0FBQ3ZCO0FBQ0FMLHNCQUFzQm5sRSxTQUFTLENBQUN5bEUsUUFBUSxHQUFHLFNBQVNBLFNBQVV6d0QsQ0FBQztJQUM3RCxJQUFJLElBQUksQ0FBQzRxQyxTQUFTLElBQUksS0FBSztRQUFFLE9BQU87SUFBSztJQUN6QyxJQUFJNXpCLFFBQVFoWCxFQUFFMGlCLGNBQWM7SUFDNUIsSUFBSWd1QyxRQUFRLElBQUksQ0FBQ0wsYUFBYSxDQUFDekUsWUFBWSxDQUFDNTBDLE9BQU8sSUFBSSxDQUFDNHpCLFNBQVM7SUFDakUsSUFBSSxDQUFDK2xCLFFBQVEsQ0FBQ0QsT0FBTy8rRCxTQUFTSSxRQUFRLEVBQUVKLFNBQVNFLFFBQVE7QUFDM0Q7QUFDQXMrRCxzQkFBc0JubEUsU0FBUyxDQUFDNGxFLFVBQVUsR0FBRyxTQUFTQSxXQUFZNXdELENBQUM7SUFDL0QsSUFBSXNGLFNBQVMsSUFBSTtJQUVuQixJQUFJa3pDLGlCQUFpQixJQUFJLENBQUM1TixTQUFTO0lBQ25DLElBQUlpbUIsYUFBYXY5QixTQUFTcmlCLElBQUk7SUFDOUIsSUFBSSxJQUFJLENBQUMyNUIsU0FBUyxHQUFHLEtBQUs7UUFDeEI0TixpQkFBaUIsQ0FBQyxJQUFJLENBQUM1TixTQUFTO1FBQ2hDaW1CLGFBQWF2OUIsU0FBU3ZpQixLQUFLO0lBQzdCO0lBQ0EsSUFBSW5KLFFBQVE1SCxFQUFFd3FCLGVBQWU7SUFDN0IsSUFBSXNtQyxhQUFhLzFDLGlCQUFpQm1CLG9CQUFvQixDQUFDdFUsTUFBTThhLGNBQWM7SUFDM0UsSUFBSSxJQUFJLENBQUNrb0IsU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDbW1CLGtCQUFrQixDQUFDbnBELE9BQU8sSUFBSSxDQUFDZ2pDLFNBQVMsR0FBRztRQUFFLE9BQU87SUFBSztJQUMxRixJQUFJLElBQUksQ0FBQ0EsU0FBUyxJQUFJLE9BQU9rbUIsV0FBV3JsRSxNQUFNLEdBQUcsR0FBRztRQUFFLE9BQU87SUFBSztJQUNsRSxJQUFJLENBQUN1bEUsY0FBYyxDQUFDRixZQUFZdFksZ0JBQWdCcVksWUFBWWwvRCxTQUFTSSxRQUFRLEVBQUVKLFNBQVNFLFFBQVE7SUFDaEcsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUk0TixFQUFFNHBCLGtCQUFrQixJQUFJeDNCLElBQUs7UUFDL0MsSUFBSXc2QixPQUFPNXNCLEVBQUVnckIsZ0JBQWdCLENBQUM1NEI7UUFDOUIsSUFBSTYrRCxZQUFZbDJDLGlCQUFpQm1CLG9CQUFvQixDQUFDMFEsS0FBS2xLLGNBQWM7UUFDekUsSUFBSXBkLE9BQU9zbEMsU0FBUyxHQUFHLE9BQU90bEMsT0FBT3lyRCxrQkFBa0IsQ0FBQ25rQyxNQUFNLENBQUN0bkIsT0FBT3NsQyxTQUFTLEdBQUc7WUFBRTtRQUFTO1FBQzdGdGxDLE9BQU8wckQsY0FBYyxDQUFDQyxXQUFXelksZ0JBQWdCbGxCLFNBQVNHLFFBQVEsQ0FBQ285QixhQUFhbC9ELFNBQVNFLFFBQVEsRUFBRUYsU0FBU0ksUUFBUTtJQUN0SDtBQUNGO0FBQ0FvK0Qsc0JBQXNCbmxFLFNBQVMsQ0FBQ2ttRSwwQkFBMEIsR0FBRyxTQUFTQSwyQkFBNEJDLGFBQWEsRUFBRUMsY0FBYztJQUM3SCxJQUFJQyxNQUFNLElBQUk1RCxTQUFTMEQsYUFBYSxDQUFDLEVBQUUsRUFBRUEsYUFBYSxDQUFDLEVBQUUsRUFBRUEsYUFBYSxDQUFDLEVBQUU7SUFDM0UsSUFBSXBELFdBQVdzRCxJQUFJdEQsUUFBUTtJQUMzQixJQUFJdUQsZUFBZTlrRCxhQUFhK0MsaUJBQWlCLENBQUN3K0MsVUFBVXNELElBQUkvb0QsRUFBRSxFQUFFK29ELElBQUk5MEQsRUFBRTtJQUMxRSxPQUFPKzBELGVBQWU1bEUsS0FBS3lCLEdBQUcsQ0FBQ2lrRTtBQUNqQztBQUNBakIsc0JBQXNCbmxFLFNBQVMsQ0FBQ3VtRSxhQUFhLEdBQUcsU0FBU0EsY0FBZWpxRCxJQUFJO0lBQzFFLElBQUksSUFBSSxDQUFDc2pDLFNBQVMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDeWxCLGFBQWEsQ0FBQ3ZFLG1CQUFtQixHQUFHeEwsYUFBYSxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQ3RHLElBQUl0cEMsUUFBUStELGlCQUFpQm1CLG9CQUFvQixDQUFDNVUsS0FBS29iLGNBQWM7SUFDckUsSUFBSWd1QyxRQUFRLElBQUksQ0FBQ0wsYUFBYSxDQUFDekUsWUFBWSxDQUFDNTBDLE9BQU8sSUFBSSxDQUFDNHpCLFNBQVM7SUFDakUsSUFBSSxDQUFDK2xCLFFBQVEsQ0FBQ0QsT0FBTy8rRCxTQUFTSSxRQUFRLEVBQUVKLFNBQVNFLFFBQVE7QUFDM0Q7QUFDQXMrRCxzQkFBc0JubEUsU0FBUyxDQUFDMmxFLFFBQVEsR0FBRyxTQUFTQSxTQUFVMzVDLEtBQUssRUFBRXFqQixPQUFPLEVBQUVDLFFBQVE7SUFDcEYsSUFBSXRqQixVQUFVLFFBQVFBLE1BQU12ckIsTUFBTSxHQUFHLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDdEQsSUFBSW9JLElBQUksSUFBSXNnRCxtQkFBbUJuOUIsT0FBTyxJQUFJOGlCLE1BQU0sR0FBR25vQyxTQUFTRyxRQUFRLEVBQUV1b0MsU0FBU0M7SUFDL0UsSUFBSSxDQUFDZzJCLFVBQVUsQ0FBQ3I1RCxHQUFHLENBQUNwRDtBQUN0QjtBQUNBczhELHNCQUFzQm5sRSxTQUFTLENBQUN3bUUsU0FBUyxHQUFHLFNBQVNBO0lBQ25ELElBQUksQ0FBQ3Y2RCxHQUFHLENBQUMsSUFBSSxDQUFDbTVELFVBQVU7SUFDeEIsT0FBTyxJQUFJLENBQUNFLFVBQVU7QUFDeEI7QUFDQUgsc0JBQXNCbmxFLFNBQVMsQ0FBQ2dtRSxjQUFjLEdBQUcsU0FBU0EsZUFBZ0JoNkMsS0FBSyxFQUFFd2hDLGNBQWMsRUFBRWprQixJQUFJLEVBQUVrOUIsU0FBUyxFQUFFQyxVQUFVO0lBQzFILElBQUlsWixtQkFBbUIsT0FBT3hoQyxNQUFNdnJCLE1BQU0sR0FBRzIvQixXQUFXRyxrQkFBa0IsRUFBRTtRQUFFLE9BQU87SUFBSztJQUMxRixJQUFJOE8sVUFBVW8zQjtJQUNkLElBQUluM0IsV0FBV28zQjtJQUNmLElBQUkxNkMsTUFBTXZyQixNQUFNLElBQUkyL0IsV0FBV0csa0JBQWtCLElBQUkvZSxhQUFhMkYsS0FBSyxDQUFDNkUsUUFBUTtRQUM5RXFqQixVQUFVcTNCO1FBQ1ZwM0IsV0FBV20zQjtRQUNYbDlCLE9BQU9qQixTQUFTRyxRQUFRLENBQUNjO0lBQzNCO0lBQ0EsSUFBSW04QixRQUFRLElBQUksQ0FBQ0wsYUFBYSxDQUFDckUsWUFBWSxDQUFDaDFDLE9BQU91ZCxNQUFNaWtCO0lBQ3pELElBQUksQ0FBQ21ZLFFBQVEsQ0FBQ0QsT0FBT3IyQixTQUFTQztBQUNoQztBQUNBNjFCLHNCQUFzQm5sRSxTQUFTLENBQUNpTSxHQUFHLEdBQUcsU0FBU0EsSUFBSzRkLENBQUM7SUFDbkQsSUFBSUEsRUFBRS9QLE9BQU8sSUFBSTtRQUFFLE9BQU87SUFBSztJQUMvQixJQUFJK1AsYUFBYTZVLFNBQVM7UUFBRSxJQUFJLENBQUNrbkMsVUFBVSxDQUFDLzdDO0lBQUksT0FDM0MsSUFBSUEsYUFBYXNRLFlBQVk7UUFBRSxJQUFJLENBQUNvc0MsYUFBYSxDQUFDMThDO0lBQUksT0FDdEQsSUFBSUEsYUFBYTJVLE9BQU87UUFBRSxJQUFJLENBQUNpbkMsUUFBUSxDQUFDNTdDO0lBQUksT0FDNUMsSUFBSUEsYUFBYXFXLFlBQVk7UUFBRSxJQUFJLENBQUN5bUMsYUFBYSxDQUFDOThDO0lBQUksT0FDdEQsSUFBSUEsYUFBYWtQLGlCQUFpQjtRQUFFLElBQUksQ0FBQzR0QyxhQUFhLENBQUM5OEM7SUFBSSxPQUMzRCxJQUFJQSxhQUFhNFcsY0FBYztRQUFFLElBQUksQ0FBQ2ttQyxhQUFhLENBQUM5OEM7SUFBSSxPQUN4RCxJQUFJQSxhQUFhMk4sb0JBQW9CO1FBQUUsSUFBSSxDQUFDbXZDLGFBQWEsQ0FBQzk4QztJQUFJO0FBQ25FLHVFQUF1RTtBQUN6RTtBQUNBczdDLHNCQUFzQm5sRSxTQUFTLENBQUMrbEUsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CcnBELElBQUksRUFBRTBwRCxjQUFjO0lBQ3BHLElBQUlRLFlBQVlscUQsS0FBS2diLGNBQWM7SUFDbkMsc0JBQXNCO0lBQ3RCLElBQUlrdkMsVUFBVW5tRSxNQUFNLEdBQUcsR0FBRztRQUFFLE9BQU8ybEUsaUJBQWlCO0lBQUU7SUFDdEQsSUFBSVEsVUFBVW5tRSxNQUFNLEtBQUssR0FBRztRQUFFLE9BQU8sSUFBSSxDQUFDeWxFLDBCQUEwQixDQUFDVSxXQUFXUjtJQUFnQjtJQUNoRyxJQUFJbnlELE1BQU15SSxLQUFLaU8sbUJBQW1CO0lBQ2xDLElBQUlrOEMsa0JBQWtCbm1FLEtBQUtFLEdBQUcsQ0FBQ3FULElBQUl5QyxTQUFTLElBQUl6QyxJQUFJd0MsUUFBUTtJQUM1RCxJQUFJMnZELGlCQUFpQixPQUFPLElBQUkxbEUsS0FBS3lCLEdBQUcsQ0FBQ2lrRSxrQkFBa0JTLGlCQUFpQjtRQUFFLE9BQU87SUFBSztJQUMxRixPQUFPO0FBQ1Q7QUFDQTFCLHNCQUFzQm5sRSxTQUFTLENBQUMybUUsYUFBYSxHQUFHLFNBQVNBLGNBQWVwdUMsRUFBRTtJQUN0RSxJQUFJamUsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSW14QixHQUFHbk8sZ0JBQWdCLElBQUloakIsSUFBSztRQUM5QyxJQUFJeWlCLElBQUkwTyxHQUFHOU8sWUFBWSxDQUFDcmlCO1FBQ3hCa1QsT0FBT3JPLEdBQUcsQ0FBQzRkO0lBQ2I7QUFDRjtBQUNBczdDLHNCQUFzQm5sRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDckQsT0FBTyxFQUFFO0FBQ1g7QUFDQXNqRSxzQkFBc0JubEUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2xELE9BQU9xakU7QUFDVDtBQUVBLElBQUkyQix5QkFBeUIsU0FBU0EsMEJBQTJCO0FBRWpFQSx1QkFBdUI5bUUsU0FBUyxDQUFDK21FLE1BQU0sR0FBRyxTQUFTQSxPQUFRL3hELENBQUMsR0FBRztBQUMvRDh4RCx1QkFBdUI5bUUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3RELE9BQU8sRUFBRTtBQUNYO0FBQ0FpbEUsdUJBQXVCOW1FLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuRCxPQUFPZ2xFO0FBQ1Q7QUFFQSxJQUFJRSw2QkFBNkIsU0FBU0E7SUFDeEMsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNDLElBQUksR0FBRztJQUNaLElBQUksQ0FBQzlVLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQytVLHNCQUFzQixHQUFHO0lBQzlCLElBQUlsekMsU0FBU3B6QixTQUFTLENBQUMsRUFBRTtJQUN6QixJQUFJLENBQUNtbUUsT0FBTyxHQUFHL3lDO0lBQ2YsSUFBSSxDQUFDZ3pDLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUM3VSxNQUFNLEdBQUc7SUFDZCxJQUFJLENBQUM4VSxJQUFJLEdBQUdqekMsT0FBTzlKLGdCQUFnQjtBQUNyQztBQUNBNDhDLDJCQUEyQmhuRSxTQUFTLENBQUMwbkIsSUFBSSxHQUFHLFNBQVNBO0lBQ25ELElBQUksSUFBSSxDQUFDdy9DLFFBQVEsRUFBRTtRQUNqQixJQUFJLENBQUNBLFFBQVEsR0FBRztRQUNoQixJQUFJRiwyQkFBMkJLLFFBQVEsQ0FBQyxJQUFJLENBQUNKLE9BQU8sR0FBRztZQUFFLElBQUksQ0FBQzVVLE1BQU07UUFBSTtRQUN4RSxPQUFPLElBQUksQ0FBQzRVLE9BQU87SUFDckI7SUFDQSxJQUFJLElBQUksQ0FBQ0csc0JBQXNCLEtBQUssTUFBTTtRQUN4QyxJQUFJLElBQUksQ0FBQ0Esc0JBQXNCLENBQUM3N0MsT0FBTyxJQUFJO1lBQ3pDLE9BQU8sSUFBSSxDQUFDNjdDLHNCQUFzQixDQUFDMS9DLElBQUk7UUFDekMsT0FBTztZQUNMLElBQUksQ0FBQzAvQyxzQkFBc0IsR0FBRztRQUNoQztJQUNGO0lBQ0EsSUFBSSxJQUFJLENBQUMvVSxNQUFNLElBQUksSUFBSSxDQUFDOFUsSUFBSSxFQUFFO1FBQzVCLE1BQU0sSUFBSTU1QztJQUNaO0lBQ0EsSUFBSXlCLE1BQU0sSUFBSSxDQUFDaTRDLE9BQU8sQ0FBQ3g5QyxZQUFZLENBQUMsSUFBSSxDQUFDNG9DLE1BQU07SUFDL0MsSUFBSXJqQyxlQUFld0ksb0JBQW9CO1FBQ3JDLElBQUksQ0FBQzR2QyxzQkFBc0IsR0FBRyxJQUFJSiwyQkFBMkJoNEM7UUFDN0QsT0FBTyxJQUFJLENBQUNvNEMsc0JBQXNCLENBQUMxL0MsSUFBSTtJQUN6QztJQUNBLE9BQU9zSDtBQUNUO0FBQ0FnNEMsMkJBQTJCaG5FLFNBQVMsQ0FBQ2l0QixNQUFNLEdBQUcsU0FBU0E7SUFDckQsTUFBTSxJQUFJNXFCLE1BQU0sSUFBSSxDQUFDUCxRQUFRLEdBQUcyL0IsT0FBTztBQUN6QztBQUNBdWxDLDJCQUEyQmhuRSxTQUFTLENBQUN1ckIsT0FBTyxHQUFHLFNBQVNBO0lBQ3RELElBQUksSUFBSSxDQUFDMjdDLFFBQVEsRUFBRTtRQUNqQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLElBQUksQ0FBQ0Usc0JBQXNCLEtBQUssTUFBTTtRQUN4QyxJQUFJLElBQUksQ0FBQ0Esc0JBQXNCLENBQUM3N0MsT0FBTyxJQUFJO1lBQ3pDLE9BQU87UUFDVDtRQUNBLElBQUksQ0FBQzY3QyxzQkFBc0IsR0FBRztJQUNoQztJQUNBLElBQUksSUFBSSxDQUFDL1UsTUFBTSxJQUFJLElBQUksQ0FBQzhVLElBQUksRUFBRTtRQUM1QixPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQUgsMkJBQTJCaG5FLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxRCxPQUFPO1FBQUNzckI7S0FBUztBQUNuQjtBQUNBNjVDLDJCQUEyQmhuRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdkQsT0FBT2tsRTtBQUNUO0FBQ0FBLDJCQUEyQkssUUFBUSxHQUFHLFNBQVNBLFNBQVVqL0MsSUFBSTtJQUMzRCxPQUFPLENBQUVBLENBQUFBLGdCQUFnQm9QLGtCQUFpQjtBQUM1QztBQUVBLElBQUk4dkMsMkJBQTJCLFNBQVNBO0lBQ3RDLElBQUksQ0FBQ2h1QyxLQUFLLEdBQUc7SUFDYixJQUFJbFIsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtJQUN2QixJQUFJLENBQUN3NEIsS0FBSyxHQUFHbFI7QUFDZjtBQUNBay9DLHlCQUF5QnRuRSxTQUFTLENBQUMrbUUsTUFBTSxHQUFHLFNBQVNBLE9BQVEveEQsQ0FBQztJQUM1RCxPQUFPc3lELHlCQUF5QlAsTUFBTSxDQUFDL3hELEdBQUcsSUFBSSxDQUFDc2tCLEtBQUs7QUFDdEQ7QUFDQWd1Qyx5QkFBeUJ0bkUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hELE9BQU87UUFBQ2lsRTtLQUF1QjtBQUNqQztBQUNBUSx5QkFBeUJ0bkUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JELE9BQU93bEU7QUFDVDtBQUNBQSx5QkFBeUJ2Z0QsYUFBYSxHQUFHLFNBQVNBLGNBQWUvUixDQUFDLEVBQUUwSCxJQUFJO0lBQ3RFLElBQUksQ0FBQ0EsS0FBS2lPLG1CQUFtQixHQUFHMVQsVUFBVSxDQUFDakMsSUFBSTtRQUFFLE9BQU87SUFBTTtJQUM5RCxPQUFPd00sYUFBYXVGLGFBQWEsQ0FBQy9SLEdBQUcwSCxLQUFLZ2IsY0FBYztBQUMxRDtBQUNBNHZDLHlCQUF5QkMsc0JBQXNCLEdBQUcsU0FBU0EsdUJBQXdCdnlELENBQUMsRUFBRXNxQixJQUFJO0lBQ3hGLElBQUlBLEtBQUt4bEIsT0FBTyxJQUFJO1FBQUUsT0FBTztJQUFNO0lBQ25DLElBQUk4QyxRQUFRMGlCLEtBQUtFLGVBQWU7SUFDaEMsSUFBSSxDQUFDOG5DLHlCQUF5QnZnRCxhQUFhLENBQUMvUixHQUFHNEgsUUFBUTtRQUFFLE9BQU87SUFBTTtJQUN0RSxJQUFLLElBQUl4VixJQUFJLEdBQUdBLElBQUlrNEIsS0FBS1Ysa0JBQWtCLElBQUl4M0IsSUFBSztRQUNsRCxJQUFJdzZCLE9BQU90QyxLQUFLVSxnQkFBZ0IsQ0FBQzU0QjtRQUNqQyxJQUFJa2dFLHlCQUF5QnZnRCxhQUFhLENBQUMvUixHQUFHNHNCLE9BQU87WUFBRSxPQUFPO1FBQU07SUFDdEU7SUFDQSxPQUFPO0FBQ1Q7QUFDQTBsQyx5QkFBeUJ6MUIsYUFBYSxHQUFHLFNBQVNBLGNBQWU3OEIsQ0FBQyxFQUFFb1QsSUFBSTtJQUN0RSxJQUFJQSxnQkFBZ0JzVyxTQUFTO1FBQzNCLE9BQU80b0MseUJBQXlCQyxzQkFBc0IsQ0FBQ3Z5RCxHQUFHb1Q7SUFDNUQsT0FBTyxJQUFJQSxnQkFBZ0JvUCxvQkFBb0I7UUFDN0MsSUFBSWd3QyxRQUFRLElBQUlSLDJCQUEyQjUrQztRQUMzQyxNQUFPby9DLE1BQU1qOEMsT0FBTyxHQUFJO1lBQ3RCLElBQUlrOEMsS0FBS0QsTUFBTTkvQyxJQUFJO1lBQ25CLElBQUkrL0MsT0FBT3IvQyxNQUFNO2dCQUFFLElBQUlrL0MseUJBQXlCejFCLGFBQWEsQ0FBQzc4QixHQUFHeXlELEtBQUs7b0JBQUUsT0FBTztnQkFBSztZQUFFO1FBQ3hGO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQUgseUJBQXlCUCxNQUFNLEdBQUcsU0FBU0EsT0FBUS94RCxDQUFDLEVBQUVvVCxJQUFJO0lBQ3hELElBQUlBLEtBQUt0TyxPQUFPLElBQUk7UUFBRSxPQUFPblQsU0FBU0ksUUFBUTtJQUFDO0lBQy9DLElBQUl1Z0UseUJBQXlCejFCLGFBQWEsQ0FBQzc4QixHQUFHb1QsT0FBTztRQUFFLE9BQU96aEIsU0FBU0UsUUFBUTtJQUFDO0lBQ2hGLE9BQU9GLFNBQVNJLFFBQVE7QUFDMUI7QUFFQSxJQUFJMmdFLGNBQWMsU0FBU0E7SUFDekIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSW56QztJQUNwQixJQUFJLENBQUNvekMsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFBQ2xoRSxTQUFTSyxJQUFJO1FBQUVMLFNBQVNLLElBQUk7S0FBQztBQUN6RDtBQUNBMGdFLFlBQVkxbkUsU0FBUyxDQUFDOG5FLFNBQVMsR0FBRyxTQUFTQSxVQUFXeHNCLEVBQUU7SUFDdEQsSUFBSSxDQUFDbFIsUUFBUTtJQUNiLElBQUloakMsSUFBSSxJQUFJLENBQUN3Z0UsU0FBUyxDQUFDdmdFLE9BQU8sQ0FBQ2kwQztJQUMvQixJQUFJeXNCLFVBQVUzZ0UsSUFBSTtJQUNsQixJQUFJQSxNQUFNLEdBQUc7UUFBRTJnRSxVQUFVLElBQUksQ0FBQ0gsU0FBUyxDQUFDajBELElBQUksS0FBSztJQUFHO0lBQ3BELE9BQU8sSUFBSSxDQUFDaTBELFNBQVMsQ0FBQ3hrRSxHQUFHLENBQUMya0U7QUFDNUI7QUFDQUwsWUFBWTFuRSxTQUFTLENBQUNnb0UsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCOTRCLFNBQVM7SUFDakYsSUFBSSs0QixXQUFXdGhFLFNBQVNLLElBQUk7SUFDNUIsSUFBSyxJQUFJMHpCLEtBQUssSUFBSSxDQUFDclAsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUM1QyxJQUFJMWlCLElBQUk2eEIsR0FBR2hULElBQUk7UUFDZixJQUFJcW9CLFFBQVFsbkMsRUFBRWtvQyxRQUFRO1FBQ3RCLElBQUloQixNQUFNekIsTUFBTSxDQUFDWSxjQUFjYSxNQUFNMXFCLFdBQVcsQ0FBQzZwQixXQUFXNUcsU0FBU3JpQixJQUFJLE1BQU10ZixTQUFTSyxJQUFJLEVBQUU7WUFBRWloRSxXQUFXbDRCLE1BQU0xcUIsV0FBVyxDQUFDNnBCLFdBQVc1RyxTQUFTcmlCLElBQUk7UUFBRztJQUMxSjtJQUNBLElBQUlnaUQsYUFBYXRoRSxTQUFTSyxJQUFJLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDOUMsSUFBSWtoRSxVQUFVRDtJQUNkLElBQUssSUFBSUUsT0FBTyxJQUFJLENBQUM5OEMsUUFBUSxJQUFJODhDLEtBQUs1OEMsT0FBTyxJQUFLO1FBQ2hELElBQUl4YyxNQUFNbzVELEtBQUt6Z0QsSUFBSTtRQUNuQixJQUFJMHZCLFVBQVVyb0MsSUFBSWdpQyxRQUFRO1FBQzFCLElBQUlxRyxRQUFRL3hCLFdBQVcsQ0FBQzZwQixXQUFXNUcsU0FBU0UsRUFBRSxNQUFNN2hDLFNBQVNLLElBQUksRUFBRTtZQUFFb3dDLFFBQVE1SSxXQUFXLENBQUNVLFdBQVc1RyxTQUFTRSxFQUFFLEVBQUUwL0I7UUFBVTtRQUMzSCxJQUFJOXdCLFFBQVE5SSxNQUFNLENBQUNZLFlBQVk7WUFDN0IsSUFBSUcsVUFBVStILFFBQVEveEIsV0FBVyxDQUFDNnBCLFdBQVc1RyxTQUFTcmlCLElBQUk7WUFDMUQsSUFBSXFwQixXQUFXOEgsUUFBUS94QixXQUFXLENBQUM2cEIsV0FBVzVHLFNBQVN2aUIsS0FBSztZQUM1RCxJQUFJdXBCLGFBQWEzb0MsU0FBU0ssSUFBSSxFQUFFO2dCQUM5QixJQUFJc29DLGFBQWE0NEIsU0FBUztvQkFBRSxNQUFNLElBQUl2OUIsa0JBQWtCLDBCQUEwQjU3QixJQUFJNkUsYUFBYTtnQkFBSTtnQkFDdkcsSUFBSXk3QixZQUFZMW9DLFNBQVNLLElBQUksRUFBRTtvQkFDN0IwVyxPQUFPQyxvQkFBb0IsQ0FBQyxnQ0FBZ0M1TyxJQUFJNkUsYUFBYSxLQUFLO2dCQUNwRjtnQkFDQXMwRCxVQUFVNzRCO1lBQ1osT0FBTztnQkFDTDN4QixPQUFPRSxNQUFNLENBQUN3NUIsUUFBUS94QixXQUFXLENBQUM2cEIsV0FBVzVHLFNBQVNyaUIsSUFBSSxNQUFNdGYsU0FBU0ssSUFBSSxFQUFFO2dCQUMvRW93QyxRQUFRNUksV0FBVyxDQUFDVSxXQUFXNUcsU0FBU3ZpQixLQUFLLEVBQUVtaUQ7Z0JBQy9DOXdCLFFBQVE1SSxXQUFXLENBQUNVLFdBQVc1RyxTQUFTcmlCLElBQUksRUFBRWlpRDtZQUNoRDtRQUNGO0lBQ0Y7QUFDRjtBQUNBUixZQUFZMW5FLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQTtJQUM3QyxJQUFJOG1CLEtBQUssSUFBSSxDQUFDclAsUUFBUTtJQUN0QixJQUFJLENBQUNxUCxHQUFHblAsT0FBTyxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQ2pDLElBQUkxaUIsSUFBSTZ4QixHQUFHaFQsSUFBSTtJQUNmLE9BQU83ZSxFQUFFK0ssYUFBYTtBQUN4QjtBQUNBOHpELFlBQVkxbkUsU0FBUyxDQUFDcTBDLEtBQUssR0FBRyxTQUFTQSxNQUFPM3hCLEdBQUc7SUFDL0NuTyxPQUFPbU8sR0FBRyxDQUFDQyxPQUFPLENBQUMsb0JBQW9CLElBQUksQ0FBQy9PLGFBQWE7SUFDekQsSUFBSyxJQUFJOG1CLEtBQUssSUFBSSxDQUFDclAsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUM1QyxJQUFJMWlCLElBQUk2eEIsR0FBR2hULElBQUk7UUFDZjdlLEVBQUV3ckMsS0FBSyxDQUFDM3hCO0lBQ1Y7QUFDRjtBQUNBZ2xELFlBQVkxbkUsU0FBUyxDQUFDb29FLHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3QkMsU0FBUztJQUN2RixJQUFJLENBQUNDLG9CQUFvQixDQUFDRCxVQUFVRSxtQkFBbUI7SUFDdkQsT0FBTyxJQUFJLENBQUNDLHlCQUF5QixDQUFDO0FBQ3hDO0FBQ0FkLFlBQVkxbkUsU0FBUyxDQUFDd29FLHlCQUF5QixHQUFHLFNBQVNBLDBCQUEyQnQ1QixTQUFTO0lBQzdGLElBQUlpRixRQUFRLElBQUksQ0FBQy9KLFFBQVE7SUFDekIsSUFBSStKLE1BQU14Z0MsSUFBSSxNQUFNLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDckMsSUFBSTgwRCxnQkFBZ0J0MEIsTUFBTXhnQyxJQUFJLEtBQUs7SUFDbkMsSUFBSSswRCxhQUFhdjBCLE1BQU0vd0MsR0FBRyxDQUFDcWxFLGVBQWUxM0IsUUFBUTtJQUNsRCxJQUFJazNCLFdBQVdTLFdBQVdyakQsV0FBVyxDQUFDNnBCLFdBQVc1RyxTQUFTcmlCLElBQUk7SUFDOUR2SSxPQUFPRSxNQUFNLENBQUNxcUQsYUFBYXRoRSxTQUFTSyxJQUFJLEVBQUU7SUFDMUMsSUFBSWtoRSxVQUFVRDtJQUNkLElBQUssSUFBSXZ0QyxLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDNUMsSUFBSTFpQixJQUFJNnhCLEdBQUdoVCxJQUFJO1FBQ2YsSUFBSXFvQixRQUFRbG5DLEVBQUVrb0MsUUFBUTtRQUN0QnJ6QixPQUFPRSxNQUFNLENBQUNteUIsTUFBTXpCLE1BQU0sQ0FBQ1ksWUFBWTtRQUN2QyxJQUFJRyxVQUFVVSxNQUFNMXFCLFdBQVcsQ0FBQzZwQixXQUFXNUcsU0FBU3JpQixJQUFJO1FBQ3hELElBQUlxcEIsV0FBV1MsTUFBTTFxQixXQUFXLENBQUM2cEIsV0FBVzVHLFNBQVN2aUIsS0FBSztRQUMxRCxJQUFJc3BCLFlBQVlDLFVBQVU7WUFDeEIsT0FBTztRQUNUO1FBQ0EsSUFBSUEsYUFBYTQ0QixTQUFTO1lBQ3hCLE9BQU87UUFDVDtRQUNBQSxVQUFVNzRCO0lBQ1o7SUFDQSxPQUFPO0FBQ1Q7QUFDQXE0QixZQUFZMW5FLFNBQVMsQ0FBQzJvRSxTQUFTLEdBQUcsU0FBU0EsVUFBV0MsT0FBTztJQUN6RCxJQUFJdHVELFNBQVMsSUFBSTtJQUVuQixJQUFJLENBQUMrUSxRQUFRO0lBQ2IsSUFBSyxJQUFJamtCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN3Z0UsU0FBUyxDQUFDajBELElBQUksSUFBSXZNLElBQUs7UUFDOUMsSUFBSXlCLElBQUl5UixPQUFPc3RELFNBQVMsQ0FBQ3hrRSxHQUFHLENBQUNnRTtRQUM3QixJQUFJeUIsTUFBTSsvRCxTQUFTO1lBQUUsT0FBT3hoRTtRQUFFO0lBQ2hDO0lBQ0EsT0FBTyxDQUFDO0FBQ1Y7QUFDQXNnRSxZQUFZMW5FLFNBQVMsQ0FBQ3FyQixRQUFRLEdBQUcsU0FBU0E7SUFDeEMsT0FBTyxJQUFJLENBQUMrZSxRQUFRLEdBQUcvZSxRQUFRO0FBQ2pDO0FBQ0FxOEMsWUFBWTFuRSxTQUFTLENBQUNvcUMsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLElBQUksSUFBSSxDQUFDdzlCLFNBQVMsS0FBSyxNQUFNO1FBQzNCLElBQUksQ0FBQ0EsU0FBUyxHQUFHLElBQUlwNkMsVUFBVSxJQUFJLENBQUNtNkMsUUFBUSxDQUFDeDBDLE1BQU07SUFDckQ7SUFDQSxPQUFPLElBQUksQ0FBQ3kwQyxTQUFTO0FBQ3ZCO0FBQ0FGLFlBQVkxbkUsU0FBUyxDQUFDcWxCLFdBQVcsR0FBRyxTQUFTQSxZQUFhNnBCLFNBQVMsRUFBRWw2QixDQUFDLEVBQUVvVCxJQUFJO0lBQzFFLElBQUksSUFBSSxDQUFDeS9DLGlCQUFpQixDQUFDMzRCLFVBQVUsS0FBS3ZvQyxTQUFTSyxJQUFJLEVBQUU7UUFDdkQsSUFBSSxDQUFDNmdFLGlCQUFpQixDQUFDMzRCLFVBQVUsR0FBR280Qix5QkFBeUJQLE1BQU0sQ0FBQy94RCxHQUFHb1QsSUFBSSxDQUFDOG1CLFVBQVUsQ0FBQzI1QixXQUFXO0lBQ3BHO0lBQ0EsT0FBTyxJQUFJLENBQUNoQixpQkFBaUIsQ0FBQzM0QixVQUFVO0FBQzFDO0FBQ0F3NEIsWUFBWTFuRSxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDeEMsSUFBSW9HLE1BQU0sSUFBSTNDO0lBQ2QyQyxJQUFJekMsTUFBTSxDQUFDLG9CQUFvQixJQUFJLENBQUNnTCxhQUFhO0lBQ2pEdkksSUFBSXpDLE1BQU0sQ0FBQztJQUNYLElBQUssSUFBSTh4QixLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDNUMsSUFBSTFpQixJQUFJNnhCLEdBQUdoVCxJQUFJO1FBQ2ZyYyxJQUFJekMsTUFBTSxDQUFDQztRQUNYd0MsSUFBSXpDLE1BQU0sQ0FBQztJQUNiO0lBQ0EsT0FBT3lDLElBQUlwRyxRQUFRO0FBQ3JCO0FBQ0F5aUUsWUFBWTFuRSxTQUFTLENBQUNzb0Usb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCdHdCLGdCQUFnQjtJQUMxRixJQUFLLElBQUl0ZCxLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDNUMsSUFBSSt2QixLQUFLNWdCLEdBQUdoVCxJQUFJO1FBQ2hCNHpCLEdBQUd2RCxZQUFZLENBQUNDO0lBQ2xCO0FBQ0Y7QUFDQTB2QixZQUFZMW5FLFNBQVMsQ0FBQzhvRSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JULFNBQVM7SUFDekUsSUFBSS90RCxTQUFTLElBQUk7SUFFbkIsSUFBSSxDQUFDZ3VELG9CQUFvQixDQUFDRCxTQUFTLENBQUMsRUFBRSxDQUFDRSxtQkFBbUI7SUFDMUQsSUFBSSxDQUFDUCxtQkFBbUIsQ0FBQztJQUN6QixJQUFJLENBQUNBLG1CQUFtQixDQUFDO0lBQ3pCLElBQUllLDZCQUE2QjtRQUFDO1FBQU87S0FBTTtJQUMvQyxJQUFLLElBQUlydUMsS0FBSyxJQUFJLENBQUNyUCxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1FBQzVDLElBQUkxaUIsSUFBSTZ4QixHQUFHaFQsSUFBSTtRQUNmLElBQUlxb0IsUUFBUWxuQyxFQUFFa29DLFFBQVE7UUFDdEIsSUFBSyxJQUFJeTJCLFFBQVEsR0FBR0EsUUFBUSxHQUFHQSxRQUFTO1lBQ3RDLElBQUl6M0IsTUFBTWpDLE1BQU0sQ0FBQzA1QixVQUFVejNCLE1BQU0xcUIsV0FBVyxDQUFDbWlELFdBQVc3Z0UsU0FBU0csUUFBUSxFQUFFO2dCQUFFaWlFLDBCQUEwQixDQUFDdkIsTUFBTSxHQUFHO1lBQU07UUFDekg7SUFDRjtJQUNBLElBQUssSUFBSVcsT0FBTyxJQUFJLENBQUM5OEMsUUFBUSxJQUFJODhDLEtBQUs1OEMsT0FBTyxJQUFLO1FBQ2hELElBQUl4YyxNQUFNbzVELEtBQUt6Z0QsSUFBSTtRQUNuQixJQUFJMHZCLFVBQVVyb0MsSUFBSWdpQyxRQUFRO1FBQzFCLElBQUssSUFBSWk0QixVQUFVLEdBQUdBLFVBQVUsR0FBR0EsVUFBVztZQUM1QyxJQUFJNXhCLFFBQVE3SSxTQUFTLENBQUN5NkIsVUFBVTtnQkFDOUIsSUFBSW42QixNQUFNbG9DLFNBQVNLLElBQUk7Z0JBQ3ZCLElBQUkraEUsMEJBQTBCLENBQUNDLFFBQVEsRUFBRTtvQkFDdkNuNkIsTUFBTWxvQyxTQUFTSSxRQUFRO2dCQUN6QixPQUFPO29CQUNMLElBQUlpTyxJQUFJakcsSUFBSTZFLGFBQWE7b0JBQ3pCaTdCLE1BQU12MEIsT0FBTytLLFdBQVcsQ0FBQzJqRCxTQUFTaDBELEdBQUdxekQ7Z0JBQ3ZDO2dCQUNBanhCLFFBQVF2SixxQkFBcUIsQ0FBQ203QixTQUFTbjZCO1lBQ3pDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E2NEIsWUFBWTFuRSxTQUFTLENBQUNpcEUsU0FBUyxHQUFHLFNBQVNBO0lBQ3pDLE9BQU8sSUFBSSxDQUFDdEIsUUFBUSxDQUFDaDBELElBQUk7QUFDM0I7QUFDQSt6RCxZQUFZMW5FLFNBQVMsQ0FBQ2twRSxhQUFhLEdBQUcsU0FBU0EsY0FBZXJnRSxDQUFDLEVBQUVtbUIsR0FBRztJQUNsRSxJQUFJLENBQUMyNEMsUUFBUSxDQUFDejBDLEdBQUcsQ0FBQ3JxQixHQUFHbW1CO0lBQ3JCLElBQUksQ0FBQzQ0QyxTQUFTLEdBQUc7QUFDbkI7QUFDQUYsWUFBWTFuRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDM0MsT0FBTyxFQUFFO0FBQ1g7QUFDQTZsRSxZQUFZMW5FLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN4QyxPQUFPNGxFO0FBQ1Q7QUFFQSxJQUFJeUIsbUJBQW9CLFNBQVVDLGNBQWM7SUFDOUMsU0FBU0Q7UUFDUEMsZUFBZTdtRSxJQUFJLENBQUMsSUFBSTtRQUN4QixJQUFJLENBQUM4bUUsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDLzRCLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ2c1QixzQkFBc0IsR0FBRztRQUM5QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQzlCO0lBRUEsSUFBS0gsZ0JBQWlCRCxpQkFBaUJ6bUUsU0FBUyxHQUFHMG1FO0lBQ25ERCxpQkFBaUJucEUsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFeW1FLGtCQUFrQkEsZUFBZXBwRSxTQUFTO0lBQ3RGbXBFLGlCQUFpQm5wRSxTQUFTLENBQUM0QyxXQUFXLEdBQUd1bUU7SUFDekNBLGlCQUFpQm5wRSxTQUFTLENBQUN1NkMsdUJBQXVCLEdBQUcsU0FBU0E7UUFDNUQsSUFBSWpnQyxTQUFTLElBQUk7UUFFakIsSUFBSSxDQUFDa3ZELGtCQUFrQjtRQUN2QixJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsV0FBVztRQUNmLElBQUlDLFFBQVEsSUFBSSxDQUFDTCxzQkFBc0I7UUFDdkMsSUFBSyxJQUFJbGlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpaUUsbUJBQW1CLENBQUMxMUQsSUFBSSxJQUFJdk0sSUFBSztZQUN4RCxJQUFJd2lFLFVBQVV0dkQsT0FBTyt1RCxtQkFBbUIsQ0FBQ2ptRSxHQUFHLENBQUNnRTtZQUM3QyxJQUFJeWlFLFNBQVNELFFBQVFyL0IsTUFBTTtZQUMzQixJQUFJLENBQUNxL0IsUUFBUTc0QixRQUFRLEdBQUd6QyxNQUFNLElBQUk7Z0JBQUU7WUFBUztZQUM3QyxJQUFJbTdCLGFBQWEsUUFBUUcsUUFBUXAyQixVQUFVLElBQUk7Z0JBQUVpMkIsV0FBV0c7WUFBUztZQUNyRSxPQUFRRDtnQkFDTixLQUFLcnZELE9BQU9ndkQsc0JBQXNCO29CQUNoQyxJQUFJLENBQUNPLE9BQU9yMkIsVUFBVSxJQUFJO3dCQUFFO29CQUFTO29CQUNyQ2syQixXQUFXRztvQkFDWEYsUUFBUXJ2RCxPQUFPaXZELG9CQUFvQjtvQkFDbkM7Z0JBQ0YsS0FBS2p2RCxPQUFPaXZELG9CQUFvQjtvQkFDOUIsSUFBSSxDQUFDSyxRQUFRcDJCLFVBQVUsSUFBSTt3QkFBRTtvQkFBUztvQkFDdENrMkIsU0FBUzd2QixPQUFPLENBQUMrdkI7b0JBQ2pCRCxRQUFRcnZELE9BQU9ndkQsc0JBQXNCO29CQUNyQztnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJSyxVQUFVLElBQUksQ0FBQ0osb0JBQW9CLEVBQUU7WUFDdkMsSUFBSUUsYUFBYSxNQUFNO2dCQUFFLE1BQU0sSUFBSTkrQixrQkFBa0IsNkJBQTZCLElBQUksQ0FBQy8yQixhQUFhO1lBQUk7WUFDeEc4SixPQUFPRSxNQUFNLENBQUM2ckQsU0FBU2oyQixVQUFVLElBQUk7WUFDckNrMkIsU0FBUzd2QixPQUFPLENBQUM0dkI7UUFDbkI7SUFDRjtJQUNBTixpQkFBaUJucEUsU0FBUyxDQUFDNjBDLE1BQU0sR0FBRyxTQUFTQSxPQUFReUcsRUFBRTtRQUNyRCxJQUFJaFMsS0FBS2dTO1FBQ1QsSUFBSSxDQUFDNHRCLGFBQWEsQ0FBQzUvQixJQUFJQTtJQUN6QjtJQUNBNi9CLGlCQUFpQm5wRSxTQUFTLENBQUNxcUMsZ0JBQWdCLEdBQUcsU0FBU0E7UUFDckQsSUFBSThKLFFBQVEsSUFBSSxDQUFDL0osUUFBUTtRQUN6QixJQUFJejJCLE9BQU93Z0MsTUFBTXhnQyxJQUFJO1FBQ3JCLElBQUlBLE9BQU8sR0FBRztZQUFFLE9BQU87UUFBSztRQUM1QixJQUFJbTJELE1BQU0zMUIsTUFBTS93QyxHQUFHLENBQUM7UUFDcEIsSUFBSXVRLFNBQVMsR0FBRztZQUFFLE9BQU9tMkQ7UUFBSTtRQUM3QixJQUFJQyxTQUFTNTFCLE1BQU0vd0MsR0FBRyxDQUFDdVEsT0FBTztRQUM5QixJQUFJcTJELFFBQVFGLElBQUloeUIsV0FBVztRQUMzQixJQUFJNUIsUUFBUTZ6QixPQUFPanlCLFdBQVc7UUFDOUIsSUFBSXJDLFNBQVNNLFVBQVUsQ0FBQ2kwQixVQUFVdjBCLFNBQVNNLFVBQVUsQ0FBQ0csUUFBUTtZQUFFLE9BQU80ekI7UUFBSyxPQUFPLElBQUksQ0FBQ3IwQixTQUFTTSxVQUFVLENBQUNpMEIsVUFBVSxDQUFDdjBCLFNBQVNNLFVBQVUsQ0FBQ0csUUFBUTtZQUFFLE9BQU82ekI7UUFBUSxPQUFPO1lBQ3pLLGlDQUFpQztZQUNqQyxJQUFJRCxJQUFJeHlCLEtBQUssT0FBTyxHQUFHO2dCQUFFLE9BQU93eUI7WUFBSyxPQUFPLElBQUlDLE9BQU96eUIsS0FBSyxPQUFPLEdBQUc7Z0JBQUUsT0FBT3l5QjtZQUFPO1FBQ3hGO1FBQ0Fyc0QsT0FBT0Msb0JBQW9CLENBQUM7UUFDNUIsT0FBTztJQUNUO0lBQ0F3ckQsaUJBQWlCbnBFLFNBQVMsQ0FBQ3EwQyxLQUFLLEdBQUcsU0FBU0EsTUFBTzN4QixHQUFHO1FBQ3BEbk8sT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLHVCQUF1QixJQUFJLENBQUMvTyxhQUFhO1FBQzVELElBQUssSUFBSThtQixLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDNUMsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtZQUNoQmhGLElBQUkyeEIsS0FBSyxDQUFDO1lBQ1YvSyxHQUFHK0ssS0FBSyxDQUFDM3hCO1lBQ1RBLElBQUlDLE9BQU87WUFDWEQsSUFBSTJ4QixLQUFLLENBQUM7WUFDVi9LLEdBQUdpQixNQUFNLEdBQUc4SixLQUFLLENBQUMzeEI7WUFDbEJBLElBQUlDLE9BQU87UUFDYjtJQUNGO0lBQ0F3bUQsaUJBQWlCbnBFLFNBQVMsQ0FBQ3dwRSxrQkFBa0IsR0FBRyxTQUFTQTtRQUN2RCxJQUFJbHZELFNBQVMsSUFBSTtRQUVqQixJQUFJLElBQUksQ0FBQyt1RCxtQkFBbUIsS0FBSyxNQUFNO1lBQUUsT0FBTyxJQUFJLENBQUNBLG1CQUFtQjtRQUFDO1FBQ3pFLElBQUksQ0FBQ0EsbUJBQW1CLEdBQUcsSUFBSTc3QztRQUMvQixJQUFLLElBQUlrTixLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDNUMsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtZQUNoQixJQUFJNGhCLEdBQUdrSyxVQUFVLE1BQU1sSyxHQUFHaUIsTUFBTSxHQUFHaUosVUFBVSxJQUFJO2dCQUFFbDVCLE9BQU8rdUQsbUJBQW1CLENBQUNwOUQsR0FBRyxDQUFDcTlCO1lBQUs7UUFDekY7UUFDQSxPQUFPLElBQUksQ0FBQysvQixtQkFBbUI7SUFDakM7SUFDQUYsaUJBQWlCbnBFLFNBQVMsQ0FBQ2lxRSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCQyxTQUFTO1FBQzlFLElBQUssSUFBSXh2QyxLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDNUMsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtZQUNoQixJQUFJcW9CLFFBQVF6RyxHQUFHeUgsUUFBUTtZQUN2QmhCLE1BQU1sQyxxQkFBcUIsQ0FBQyxHQUFHcThCLFVBQVU3a0QsV0FBVyxDQUFDO1lBQ3JEMHFCLE1BQU1sQyxxQkFBcUIsQ0FBQyxHQUFHcThCLFVBQVU3a0QsV0FBVyxDQUFDO1FBQ3ZEO0lBQ0Y7SUFDQThqRCxpQkFBaUJucEUsU0FBUyxDQUFDMjZDLG9CQUFvQixHQUFHLFNBQVNBO1FBQ3pELElBQUlyZ0MsU0FBUyxJQUFJO1FBRWpCLElBQUksQ0FBQzh2QixRQUFRO1FBQ2IsSUFBSSsvQixVQUFVO1FBQ2QsSUFBSUMsVUFBVTtRQUNkLElBQUssSUFBSWhqRSxJQUFJLElBQUksQ0FBQ3dnRSxTQUFTLENBQUNqMEQsSUFBSSxLQUFLLEdBQUd2TSxLQUFLLEdBQUdBLElBQUs7WUFDbkQsSUFBSXdpRSxVQUFVdHZELE9BQU9zdEQsU0FBUyxDQUFDeGtFLEdBQUcsQ0FBQ2dFO1lBQ25DLElBQUl5aUUsU0FBU0QsUUFBUXIvQixNQUFNO1lBQzNCLElBQUk2L0IsWUFBWSxNQUFNO2dCQUFFQSxVQUFVUDtZQUFRO1lBQzFDLElBQUlNLFlBQVksTUFBTTtnQkFBRU4sT0FBT2h3QixPQUFPLENBQUNzd0I7WUFBVTtZQUNqREEsVUFBVVA7UUFDWjtRQUNBUSxRQUFRdndCLE9BQU8sQ0FBQ3N3QjtJQUNsQjtJQUNBaEIsaUJBQWlCbnBFLFNBQVMsQ0FBQzhyQyxhQUFhLEdBQUcsU0FBU0E7UUFDbEQsSUFBSXh4QixTQUFTLElBQUk7UUFFakIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUk2b0MsS0FBS3hvQyxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJdXBFLFlBQVksSUFBSSxDQUFDMUIsU0FBUyxDQUFDci9CO1lBQy9CLDhCQUE4QjtZQUM5QixJQUFJZ2hDLGFBQWFoaEMsR0FBR2dELFFBQVEsQ0FBQ2hFLFNBQVNyaUIsSUFBSTtZQUMxQyxJQUFJc2tELGtCQUFrQmpoQyxHQUFHZ0QsUUFBUSxDQUFDaEUsU0FBU3ZpQixLQUFLO1lBQ2hELElBQUl5a0QsWUFBWSxJQUFJLENBQUMxK0IsYUFBYSxDQUFDdStCLFlBQVksR0FBRyxJQUFJLENBQUN6QyxTQUFTLENBQUNqMEQsSUFBSSxJQUFJMjJEO1lBQ3pFLElBQUlHLFlBQVksSUFBSSxDQUFDMytCLGFBQWEsQ0FBQyxHQUFHdStCLFdBQVdHO1lBQ2pELElBQUlDLGNBQWNGLGlCQUFpQjtnQkFBRSxNQUFNLElBQUk1L0Isa0JBQWtCLHVCQUF1QnJCLEdBQUcxMUIsYUFBYTtZQUFJO1FBQzlHLE9BQU8sSUFBSTlTLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUlpeEMsYUFBYTV3QyxTQUFTLENBQUMsRUFBRTtZQUM3QixJQUFJNHBFLFdBQVc1cEUsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSTZwRSxlQUFlN3BFLFNBQVMsQ0FBQyxFQUFFO1lBQy9CLElBQUk4cEUsWUFBWUQ7WUFDaEIsSUFBSyxJQUFJdmpFLElBQUlzcUMsWUFBWXRxQyxJQUFJc2pFLFVBQVV0akUsSUFBSztnQkFDMUMsSUFBSXlqRSxTQUFTdndELE9BQU9zdEQsU0FBUyxDQUFDeGtFLEdBQUcsQ0FBQ2dFO2dCQUNsQyxrQ0FBa0M7Z0JBQ2xDeWpFLE9BQU8xK0IsYUFBYSxDQUFDN0QsU0FBU3ZpQixLQUFLLEVBQUU2a0Q7Z0JBQ3JDQSxZQUFZQyxPQUFPditCLFFBQVEsQ0FBQ2hFLFNBQVNyaUIsSUFBSTtZQUMzQztZQUNBLE9BQU8ya0Q7UUFDVDtJQUNGO0lBQ0F6QixpQkFBaUJucEUsU0FBUyxDQUFDOHFFLGNBQWMsR0FBRyxTQUFTQTtRQUNuRCxJQUFLLElBQUlwd0MsS0FBSyxJQUFJLENBQUNyUCxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1lBQzVDLElBQUkrZCxLQUFLNU8sR0FBR2hULElBQUk7WUFDaEIsSUFBSXFvQixRQUFRekcsR0FBR3lILFFBQVE7WUFDdkJoQixNQUFNaEMsS0FBSyxDQUFDekUsR0FBR2lCLE1BQU0sR0FBR3dHLFFBQVE7UUFDbEM7SUFDRjtJQUNBbzRCLGlCQUFpQm5wRSxTQUFTLENBQUNrekMsd0JBQXdCLEdBQUcsU0FBU0EseUJBQTBCVCxFQUFFO1FBQ3pGLElBQUluNEIsU0FBUyxJQUFJO1FBRWpCLElBQUltdkQsV0FBVztRQUNmLElBQUlDLFdBQVc7UUFDZixJQUFJQyxRQUFRLElBQUksQ0FBQ0wsc0JBQXNCO1FBQ3ZDLElBQUssSUFBSWxpRSxJQUFJLElBQUksQ0FBQ2lpRSxtQkFBbUIsQ0FBQzExRCxJQUFJLEtBQUssR0FBR3ZNLEtBQUssR0FBR0EsSUFBSztZQUM3RCxJQUFJd2lFLFVBQVV0dkQsT0FBTyt1RCxtQkFBbUIsQ0FBQ2ptRSxHQUFHLENBQUNnRTtZQUM3QyxJQUFJeWlFLFNBQVNELFFBQVFyL0IsTUFBTTtZQUMzQixJQUFJay9CLGFBQWEsUUFBUUcsUUFBUTk0QixXQUFXLE9BQU8yQixJQUFJO2dCQUFFZzNCLFdBQVdHO1lBQVM7WUFDN0UsT0FBUUQ7Z0JBQ04sS0FBS3J2RCxPQUFPZ3ZELHNCQUFzQjtvQkFDaEMsSUFBSU8sT0FBTy80QixXQUFXLE9BQU8yQixJQUFJO3dCQUFFO29CQUFTO29CQUM1Q2kzQixXQUFXRztvQkFDWEYsUUFBUXJ2RCxPQUFPaXZELG9CQUFvQjtvQkFDbkM7Z0JBQ0YsS0FBS2p2RCxPQUFPaXZELG9CQUFvQjtvQkFDOUIsSUFBSUssUUFBUTk0QixXQUFXLE9BQU8yQixJQUFJO3dCQUFFO29CQUFTO29CQUM3Q2kzQixTQUFTOXdCLFVBQVUsQ0FBQ2d4QjtvQkFDcEJELFFBQVFydkQsT0FBT2d2RCxzQkFBc0I7b0JBQ3JDO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUlLLFVBQVUsSUFBSSxDQUFDSixvQkFBb0IsRUFBRTtZQUN2QzdyRCxPQUFPRSxNQUFNLENBQUM2ckQsYUFBYSxNQUFNO1lBQ2pDL3JELE9BQU9FLE1BQU0sQ0FBQzZyRCxTQUFTMzRCLFdBQVcsT0FBTzJCLElBQUk7WUFDN0NpM0IsU0FBUzl3QixVQUFVLENBQUM2d0I7UUFDdEI7SUFDRjtJQUNBTixpQkFBaUJucEUsU0FBUyxDQUFDdXhDLGlCQUFpQixHQUFHLFNBQVNBO1FBQ3RELElBQUl6d0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSTZ3QyxTQUFTO1lBQ2IsSUFBSyxJQUFJNVcsS0FBSyxJQUFJLENBQUNyUCxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO2dCQUM1QyxJQUFJK2QsS0FBSzVPLEdBQUdoVCxJQUFJO2dCQUNoQixJQUFJNGhCLEdBQUdrSyxVQUFVLElBQUk7b0JBQUVsQztnQkFBVTtZQUNuQztZQUNBLE9BQU9BO1FBQ1QsT0FBTyxJQUFJeHdDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUlneUMsS0FBSzN4QyxTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJaXFFLFdBQVc7WUFDZixJQUFLLElBQUk1QyxPQUFPLElBQUksQ0FBQzk4QyxRQUFRLElBQUk4OEMsS0FBSzU4QyxPQUFPLElBQUs7Z0JBQ2hELElBQUl3Z0IsT0FBT284QixLQUFLemdELElBQUk7Z0JBQ3BCLElBQUlxa0IsS0FBSytFLFdBQVcsT0FBTzJCLElBQUk7b0JBQUVzNEI7Z0JBQVk7WUFDL0M7WUFDQSxPQUFPQTtRQUNUO0lBQ0Y7SUFDQTVCLGlCQUFpQm5wRSxTQUFTLENBQUMrd0MsUUFBUSxHQUFHLFNBQVNBO1FBQzdDLE9BQU8sSUFBSSxDQUFDVCxNQUFNO0lBQ3BCO0lBQ0E2NEIsaUJBQWlCbnBFLFNBQVMsQ0FBQ2dyRSxvQkFBb0IsR0FBRyxTQUFTQTtRQUN6RCxJQUFJL0MsV0FBV3RoRSxTQUFTSyxJQUFJO1FBQzVCLElBQUssSUFBSTB6QixLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDNUMsSUFBSXErQyxVQUFVbHZDLEdBQUdoVCxJQUFJO1lBQ3JCLElBQUltaUQsU0FBU0QsUUFBUXIvQixNQUFNO1lBQzNCLElBQUksQ0FBQ3EvQixRQUFRNXdCLFVBQVUsSUFBSTtnQkFDekIsSUFBSTR3QixRQUFRcDJCLFVBQVUsSUFBSTtvQkFDeEJ5MEIsV0FBV3RoRSxTQUFTRSxRQUFRO29CQUM1QjtnQkFDRjtnQkFDQSxJQUFJZ2pFLE9BQU9yMkIsVUFBVSxJQUFJO29CQUN2QnkwQixXQUFXdGhFLFNBQVNJLFFBQVE7b0JBQzVCO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUlraEUsYUFBYXRoRSxTQUFTSyxJQUFJLEVBQUU7WUFBRSxPQUFPO1FBQUs7UUFDOUMsSUFBSWtoRSxVQUFVRDtRQUNkLElBQUssSUFBSUUsT0FBTyxJQUFJLENBQUM5OEMsUUFBUSxJQUFJODhDLEtBQUs1OEMsT0FBTyxJQUFLO1lBQ2hELElBQUkwL0MsWUFBWTlDLEtBQUt6Z0QsSUFBSTtZQUN6QixJQUFJd2pELFdBQVdELFVBQVUxZ0MsTUFBTTtZQUMvQixJQUFJMGdDLFVBQVVqeUIsVUFBVSxJQUFJO2dCQUMxQml5QixVQUFVdGhDLE9BQU8sR0FBR2lLLFVBQVUsQ0FBQ3MwQixZQUFZdmhFLFNBQVNFLFFBQVE7WUFDOUQsT0FBTztnQkFDTCxJQUFJb2tFLFVBQVV6M0IsVUFBVSxJQUFJO29CQUFFMDBCLFVBQVV2aEUsU0FBU0ksUUFBUTtnQkFBRTtnQkFDM0QsSUFBSW1rRSxTQUFTMTNCLFVBQVUsSUFBSTtvQkFBRTAwQixVQUFVdmhFLFNBQVNFLFFBQVE7Z0JBQUU7WUFDNUQ7UUFDRjtJQUNGO0lBQ0FzaUUsaUJBQWlCbnBFLFNBQVMsQ0FBQzhvRSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0IxZ0QsSUFBSTtRQUMzRSxJQUFJOU4sU0FBUyxJQUFJO1FBRWpCOHVELGVBQWVwcEUsU0FBUyxDQUFDOG9FLGdCQUFnQixDQUFDdm1FLElBQUksQ0FBQyxJQUFJLEVBQUU2bEI7UUFDckQsSUFBSSxDQUFDa29CLE1BQU0sR0FBRyxJQUFJeEIsTUFBTW5vQyxTQUFTSyxJQUFJO1FBQ3JDLElBQUssSUFBSTB6QixLQUFLLElBQUksQ0FBQ3JQLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDNUMsSUFBSSt2QixLQUFLNWdCLEdBQUdoVCxJQUFJO1lBQ2hCLElBQUk3ZSxJQUFJeXlDLEdBQUczUixPQUFPO1lBQ2xCLElBQUl3aEMsU0FBU3RpRSxFQUFFa29DLFFBQVE7WUFDdkIsSUFBSyxJQUFJM3BDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQixJQUFJZ2tFLE9BQU9ELE9BQU85bEQsV0FBVyxDQUFDamU7Z0JBQzlCLElBQUlna0UsU0FBU3prRSxTQUFTRSxRQUFRLElBQUl1a0UsU0FBU3prRSxTQUFTRyxRQUFRLEVBQUU7b0JBQUV3VCxPQUFPZzJCLE1BQU0sQ0FBQzlCLFdBQVcsQ0FBQ3BuQyxHQUFHVCxTQUFTRSxRQUFRO2dCQUFHO1lBQ25IO1FBQ0Y7SUFDRjtJQUNBc2lFLGlCQUFpQm5wRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDaEQsT0FBTyxFQUFFO0lBQ1g7SUFDQXNuRSxpQkFBaUJucEUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQzdDLE9BQU9xbkU7SUFDVDtJQUVBLE9BQU9BO0FBQ1QsRUFBRXpCO0FBRUYsSUFBSTJELHFCQUFzQixTQUFVQyxjQUFjO0lBQ2hELFNBQVNEO1FBQ1BDLGVBQWUveEQsS0FBSyxDQUFDLElBQUksRUFBRXpZO0lBQzdCO0lBRUEsSUFBS3dxRSxnQkFBaUJELG1CQUFtQjNvRSxTQUFTLEdBQUc0b0U7SUFDckRELG1CQUFtQnJyRSxTQUFTLEdBQUdDLE9BQU8wQyxNQUFNLENBQUUyb0Usa0JBQWtCQSxlQUFldHJFLFNBQVM7SUFDeEZxckUsbUJBQW1CcnJFLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3lvRTtJQUUzQ0EsbUJBQW1CcnJFLFNBQVMsQ0FBQ3ExQyxVQUFVLEdBQUcsU0FBU0EsV0FBWXJwQixLQUFLO1FBQ2xFLE9BQU8sSUFBSWdvQixLQUFLaG9CLE9BQU8sSUFBSW05QztJQUM3QjtJQUNBa0MsbUJBQW1CcnJFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUNsRCxPQUFPLEVBQUU7SUFDWDtJQUNBd3BFLG1CQUFtQnJyRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDL0MsT0FBT3VwRTtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFcHhCO0FBRUYsSUFBSXN4QiwwQkFBMEIsU0FBU0E7SUFDckMsSUFBSSxDQUFDbDdCLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ203QixZQUFZLEdBQUc7SUFDcEIsSUFBSXZrRCxNQUFNbm1CLFNBQVMsQ0FBQyxFQUFFO0lBQ3RCLElBQUksQ0FBQ3V2QyxJQUFJLEdBQUdwcEI7SUFDWixJQUFJLENBQUN1a0QsWUFBWSxHQUFHRCx3QkFBd0J6aEMsV0FBVyxDQUFDN2lCO0FBQzFEO0FBQ0Fza0Qsd0JBQXdCdnJFLFNBQVMsQ0FBQzZFLFNBQVMsR0FBRyxTQUFTQSxVQUFXb0IsRUFBRTtJQUNsRSxJQUFJd2xFLE1BQU14bEU7SUFDVixJQUFJc2tCLE9BQU9naEQsd0JBQXdCRyxlQUFlLENBQUMsSUFBSSxDQUFDcjdCLElBQUksRUFBRSxJQUFJLENBQUNtN0IsWUFBWSxFQUFFQyxJQUFJcDdCLElBQUksRUFBRW83QixJQUFJRCxZQUFZO0lBQzNHLE9BQU9qaEQ7QUFDVDtBQUNBZ2hELHdCQUF3QnZyRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkQsT0FBTztRQUFDeUI7S0FBVztBQUNyQjtBQUNBaW9FLHdCQUF3QnZyRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDcEQsT0FBT3lwRTtBQUNUO0FBQ0FBLHdCQUF3QnpoQyxXQUFXLEdBQUcsU0FBU0EsWUFBYTdpQixHQUFHO0lBQzdELE9BQU84SSxpQkFBaUJrQyxtQkFBbUIsQ0FBQ2hMLFNBQVM7QUFDdkQ7QUFDQXNrRCx3QkFBd0JHLGVBQWUsR0FBRyxTQUFTQSxnQkFBaUI3NUMsSUFBSSxFQUFFODVDLFlBQVksRUFBRTc1QyxJQUFJLEVBQUU4NUMsWUFBWTtJQUN4RyxJQUFJajVDLE9BQU9nNUMsZUFBZSxJQUFJLENBQUM7SUFDL0IsSUFBSS80QyxPQUFPZzVDLGVBQWUsSUFBSSxDQUFDO0lBQy9CLElBQUlDLFNBQVNGLGVBQWU5NUMsS0FBS3B4QixNQUFNLEdBQUcsQ0FBQztJQUMzQyxJQUFJcXJFLFNBQVNGLGVBQWU5NUMsS0FBS3J4QixNQUFNLEdBQUcsQ0FBQztJQUMzQyxJQUFJb3lCLEtBQUs4NEMsZUFBZSxJQUFJOTVDLEtBQUtweEIsTUFBTSxHQUFHO0lBQzFDLElBQUlxeUIsS0FBSzg0QyxlQUFlLElBQUk5NUMsS0FBS3J4QixNQUFNLEdBQUc7SUFDMUMsaUJBQWlCO0lBQ2pCLE1BQU8sS0FBTTtRQUNYLElBQUlzckUsU0FBU2w2QyxJQUFJLENBQUNnQixHQUFHLENBQUNodUIsU0FBUyxDQUFDaXRCLElBQUksQ0FBQ2dCLEdBQUc7UUFDeEMsSUFBSWk1QyxXQUFXLEdBQUc7WUFBRSxPQUFPQTtRQUFPO1FBQ2xDbDVDLE1BQU1GO1FBQ05HLE1BQU1GO1FBQ04sSUFBSW81QyxRQUFRbjVDLE9BQU9nNUM7UUFDbkIsSUFBSUksUUFBUW41QyxPQUFPZzVDO1FBQ25CLElBQUlFLFNBQVMsQ0FBQ0MsT0FBTztZQUFFLE9BQU8sQ0FBQztRQUFFO1FBQ2pDLElBQUksQ0FBQ0QsU0FBU0MsT0FBTztZQUFFLE9BQU87UUFBRTtRQUNoQyxJQUFJRCxTQUFTQyxPQUFPO1lBQUUsT0FBTztRQUFFO0lBQ2pDO0FBQ0Y7QUFFQSxJQUFJQyxXQUFXLFNBQVNBO0lBQ3RCLElBQUksQ0FBQzk3QixNQUFNLEdBQUcsSUFBSTVpQjtJQUNsQixJQUFJLENBQUMyK0MsT0FBTyxHQUFHLElBQUkzM0M7QUFDckI7QUFDQTAzQyxTQUFTbHNFLFNBQVMsQ0FBQ3EwQyxLQUFLLEdBQUcsU0FBU0EsTUFBTzN4QixHQUFHO0lBQzFDLElBQUlwSSxTQUFTLElBQUk7SUFFbkJvSSxJQUFJMnhCLEtBQUssQ0FBQztJQUNWLElBQUssSUFBSS9vQixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOGtCLE1BQU0sQ0FBQ3o4QixJQUFJLElBQUkyWCxJQUFLO1FBQzNDLElBQUl6aUIsSUFBSXlSLE9BQU84MUIsTUFBTSxDQUFDaHRDLEdBQUcsQ0FBQ2tvQjtRQUMxQixJQUFJQSxJQUFJLEdBQUc7WUFBRTVJLElBQUkyeEIsS0FBSyxDQUFDO1FBQU07UUFDN0IzeEIsSUFBSTJ4QixLQUFLLENBQUM7UUFDVixJQUFJcHRCLE1BQU1wZSxFQUFFNnVCLGNBQWM7UUFDMUIsSUFBSyxJQUFJdHdCLElBQUksR0FBR0EsSUFBSTZmLElBQUl4bUIsTUFBTSxFQUFFMkcsSUFBSztZQUNuQyxJQUFJQSxJQUFJLEdBQUc7Z0JBQUVzYixJQUFJMnhCLEtBQUssQ0FBQztZQUFNO1lBQzdCM3hCLElBQUkyeEIsS0FBSyxDQUFDcHRCLEdBQUcsQ0FBQzdmLEVBQUUsQ0FBQzFGLENBQUMsR0FBRyxNQUFNdWxCLEdBQUcsQ0FBQzdmLEVBQUUsQ0FBQ3pELENBQUM7UUFDckM7UUFDQStlLElBQUlDLE9BQU8sQ0FBQztJQUNkO0lBQ0FELElBQUkyeEIsS0FBSyxDQUFDO0FBQ1o7QUFDQTYzQixTQUFTbHNFLFNBQVMsQ0FBQytzQixNQUFNLEdBQUcsU0FBU0EsT0FBUXEvQyxRQUFRO0lBQ2pELElBQUk5eEQsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUlnbEUsU0FBUy9nRCxRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDOUNqUixPQUFPck8sR0FBRyxDQUFDN0UsRUFBRXNnQixJQUFJO0lBQ25CO0FBQ0Y7QUFDQXdrRCxTQUFTbHNFLFNBQVMsQ0FBQ3FzRSxhQUFhLEdBQUcsU0FBU0EsY0FBZXhqRSxDQUFDO0lBQ3hELElBQUl5UixTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2dwQyxNQUFNLENBQUN6OEIsSUFBSSxJQUFJdk0sSUFBSztRQUMzQyxJQUFJa1QsT0FBTzgxQixNQUFNLENBQUNodEMsR0FBRyxDQUFDZ0UsR0FBR3pDLE1BQU0sQ0FBQ2tFLElBQUk7WUFBRSxPQUFPekI7UUFBRTtJQUNqRDtJQUNBLE9BQU8sQ0FBQztBQUNWO0FBQ0E4a0UsU0FBU2xzRSxTQUFTLENBQUNxckIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sSUFBSSxDQUFDK2tCLE1BQU0sQ0FBQy9rQixRQUFRO0FBQzdCO0FBQ0E2Z0QsU0FBU2xzRSxTQUFTLENBQUNvcUMsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8sSUFBSSxDQUFDZ0csTUFBTTtBQUNwQjtBQUNBODdCLFNBQVNsc0UsU0FBUyxDQUFDb0QsR0FBRyxHQUFHLFNBQVNBLElBQUtnRSxDQUFDO0lBQ3RDLE9BQU8sSUFBSSxDQUFDZ3BDLE1BQU0sQ0FBQ2h0QyxHQUFHLENBQUNnRTtBQUN6QjtBQUNBOGtFLFNBQVNsc0UsU0FBUyxDQUFDc3NFLGFBQWEsR0FBRyxTQUFTQSxjQUFlempFLENBQUM7SUFDMUQsSUFBSTRpRSxNQUFNLElBQUlGLHdCQUF3QjFpRSxFQUFFNnVCLGNBQWM7SUFDdEQsSUFBSTYwQyxZQUFZLElBQUksQ0FBQ0osT0FBTyxDQUFDL29FLEdBQUcsQ0FBQ3FvRTtJQUNqQyxPQUFPYztBQUNUO0FBQ0FMLFNBQVNsc0UsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBLElBQUtwRCxDQUFDO0lBQ3RDLElBQUksQ0FBQ3VuQyxNQUFNLENBQUNua0MsR0FBRyxDQUFDcEQ7SUFDaEIsSUFBSTRpRSxNQUFNLElBQUlGLHdCQUF3QjFpRSxFQUFFNnVCLGNBQWM7SUFDdEQsSUFBSSxDQUFDeTBDLE9BQU8sQ0FBQ2o1QyxHQUFHLENBQUN1NEMsS0FBSzVpRTtBQUN4QjtBQUNBcWpFLFNBQVNsc0UsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sRUFBRTtBQUNYO0FBQ0FxcUUsU0FBU2xzRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDckMsT0FBT29xRTtBQUNUO0FBRUEsSUFBSU0scUJBQXFCLFNBQVNBLHNCQUF1QjtBQUV6REEsbUJBQW1CeHNFLFNBQVMsQ0FBQ3d6RCxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JpWixFQUFFLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxTQUFTLEdBQUc7QUFDbEhKLG1CQUFtQnhzRSxTQUFTLENBQUNzM0IsTUFBTSxHQUFHLFNBQVNBLFVBQVc7QUFDMURrMUMsbUJBQW1CeHNFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNsRCxPQUFPLEVBQUU7QUFDWDtBQUNBMnFFLG1CQUFtQnhzRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDL0MsT0FBTzBxRTtBQUNUO0FBRUEsSUFBSUssb0JBQW9CLFNBQVNBO0lBQy9CLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztJQUMxQixJQUFJLENBQUNDLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNDLHdCQUF3QixHQUFHO0lBQ2hDLElBQUksQ0FBQ2hTLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ2lTLG1CQUFtQixHQUFHO0lBQzNCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRztJQUNoQyxJQUFJLENBQUNDLHNCQUFzQixHQUFHO0lBQzlCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUkzaUIsS0FBSzlwRCxTQUFTLENBQUMsRUFBRTtJQUNyQixJQUFJLENBQUNvNkQsR0FBRyxHQUFHdFE7QUFDYjtBQUNBaWlCLGtCQUFrQjdzRSxTQUFTLENBQUN3dEUscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXVCZixFQUFFLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQzlHLElBQUlILE9BQU9FLElBQUk7UUFDYixJQUFJLElBQUksQ0FBQ3pSLEdBQUcsQ0FBQ3I3QyxrQkFBa0IsT0FBTyxHQUFHO1lBQ3ZDLElBQUlndEQsa0JBQWtCWSxrQkFBa0IsQ0FBQ2YsV0FBV0UsWUFBWTtnQkFBRSxPQUFPO1lBQUs7WUFDOUUsSUFBSUgsR0FBR3h6QyxRQUFRLElBQUk7Z0JBQ2pCLElBQUlnd0IsY0FBY3dqQixHQUFHOTRELElBQUksS0FBSztnQkFDOUIsSUFBSSxjQUFlLEtBQUtpNUQsY0FBYzNqQixlQUNqQzJqQixjQUFjLEtBQUtGLGNBQWN6akIsYUFBYztvQkFDbEQsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBNGpCLGtCQUFrQjdzRSxTQUFTLENBQUMwdEUsMEJBQTBCLEdBQUcsU0FBU0E7SUFDaEUsT0FBTyxJQUFJLENBQUNSLHdCQUF3QjtBQUN0QztBQUNBTCxrQkFBa0I3c0UsU0FBUyxDQUFDMnRFLDZCQUE2QixHQUFHLFNBQVNBO0lBQ25FLE9BQU8sSUFBSSxDQUFDWCxrQkFBa0I7QUFDaEM7QUFDQUgsa0JBQWtCN3NFLFNBQVMsQ0FBQzR0RSxrQkFBa0IsR0FBRyxTQUFTQTtJQUN4RCxPQUFPLElBQUksQ0FBQzFTLEdBQUc7QUFDakI7QUFDQTJSLGtCQUFrQjdzRSxTQUFTLENBQUM2dEUscUJBQXFCLEdBQUcsU0FBU0E7SUFDM0QsT0FBTyxJQUFJLENBQUNkLFVBQVU7QUFDeEI7QUFDQUYsa0JBQWtCN3NFLFNBQVMsQ0FBQ3d6RCxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JpWixFQUFFLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQzVHLElBQUlILE9BQU9FLE1BQU1ELGNBQWNFLFdBQVc7UUFBRSxPQUFPO0lBQUs7SUFDeEQsSUFBSSxDQUFDVyxRQUFRO0lBQ2IsSUFBSTdjLE1BQU0rYixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFVBQVU7SUFDeEMsSUFBSS9iLE1BQU04YixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFlBQVksRUFBRTtJQUM1QyxJQUFJOWIsTUFBTStiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsVUFBVTtJQUN4QyxJQUFJL2IsTUFBTThiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsWUFBWSxFQUFFO0lBQzVDLElBQUksQ0FBQzFSLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQ2l4QyxLQUFLQyxLQUFLQyxLQUFLQztJQUM1QyxJQUFJLElBQUksQ0FBQ3FLLEdBQUcsQ0FBQ2g3QyxlQUFlLElBQUk7UUFDOUIsSUFBSSxDQUFDa3RELGdCQUFnQjtRQUNyQixJQUFJLElBQUksQ0FBQ2xTLEdBQUcsQ0FBQzc2QyxzQkFBc0IsSUFBSTtZQUNyQyxJQUFJLENBQUNndEQsd0JBQXdCO1lBQzdCLElBQUksQ0FBQ0osWUFBWSxHQUFHO1FBQ3RCO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ08scUJBQXFCLENBQUNmLElBQUlDLFdBQVdDLElBQUlDLFlBQVk7WUFDN0QsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRztZQUN4QkwsR0FBR3ZoQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNnUSxHQUFHLEVBQUV3UixXQUFXO1lBQ3pDQyxHQUFHemhCLGdCQUFnQixDQUFDLElBQUksQ0FBQ2dRLEdBQUcsRUFBRTBSLFdBQVc7WUFDekMsSUFBSSxJQUFJLENBQUMxUixHQUFHLENBQUNqN0MsUUFBUSxJQUFJO2dCQUN2QixJQUFJLENBQUNxdEQsc0JBQXNCO2dCQUMzQixJQUFJLENBQUNQLFVBQVUsR0FBRztnQkFDbEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztZQUM1QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBSCxrQkFBa0I3c0UsU0FBUyxDQUFDa2dCLGVBQWUsR0FBRyxTQUFTQTtJQUNyRCxPQUFPLElBQUksQ0FBQzRzRCxnQkFBZ0I7QUFDOUI7QUFDQUQsa0JBQWtCN3NFLFNBQVMsQ0FBQ3MzQixNQUFNLEdBQUcsU0FBU0E7SUFDNUMsT0FBTztBQUNUO0FBQ0F1MUMsa0JBQWtCN3NFLFNBQVMsQ0FBQzh0RSx1QkFBdUIsR0FBRyxTQUFTQTtJQUM3RCxPQUFPLElBQUksQ0FBQ2IsWUFBWTtBQUMxQjtBQUNBSixrQkFBa0I3c0UsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2pELE9BQU87UUFBQzJxRTtLQUFtQjtBQUM3QjtBQUNBSyxrQkFBa0I3c0UsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzlDLE9BQU8rcUU7QUFDVDtBQUNBQSxrQkFBa0JZLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQjU2QyxFQUFFLEVBQUVDLEVBQUU7SUFDeEUsT0FBT3B5QixLQUFLeUIsR0FBRyxDQUFDMHdCLEtBQUtDLFFBQVE7QUFDL0I7QUFFQSxJQUFJaTdDLG1CQUFtQixTQUFTQTtJQUM5QixJQUFJLENBQUMvaEQsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDOU0sWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3NCLElBQUksR0FBRztJQUNaLElBQUl3TCxRQUFRbHJCLFNBQVMsQ0FBQyxFQUFFO0lBQ3hCLElBQUlvZSxlQUFlcGUsU0FBUyxDQUFDLEVBQUU7SUFDL0IsSUFBSTBmLE9BQU8xZixTQUFTLENBQUMsRUFBRTtJQUN2QixJQUFJLENBQUNrckIsS0FBSyxHQUFHLElBQUl0b0IsV0FBV3NvQjtJQUM1QixJQUFJLENBQUM5TSxZQUFZLEdBQUdBO0lBQ3BCLElBQUksQ0FBQ3NCLElBQUksR0FBR0E7QUFDZDtBQUNBdXRELGlCQUFpQi90RSxTQUFTLENBQUNndUUsZUFBZSxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sSUFBSSxDQUFDOXVELFlBQVk7QUFDMUI7QUFDQTZ1RCxpQkFBaUIvdEUsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBO0lBQ2xELE9BQU8sSUFBSSxDQUFDb1ksS0FBSztBQUNuQjtBQUNBK2hELGlCQUFpQi90RSxTQUFTLENBQUNxMEMsS0FBSyxHQUFHLFNBQVNBLE1BQU8zeEIsR0FBRztJQUNwREEsSUFBSTJ4QixLQUFLLENBQUMsSUFBSSxDQUFDcm9CLEtBQUs7SUFDcEJ0SixJQUFJMnhCLEtBQUssQ0FBQyxjQUFjLElBQUksQ0FBQ24xQixZQUFZO0lBQ3pDd0QsSUFBSUMsT0FBTyxDQUFDLGFBQWEsSUFBSSxDQUFDbkMsSUFBSTtBQUNwQztBQUNBdXRELGlCQUFpQi90RSxTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV21xQixHQUFHO0lBQzVELElBQUl4cUIsUUFBUXdxQjtJQUNaLE9BQU8sSUFBSSxDQUFDaHBCLE9BQU8sQ0FBQ3hCLE1BQU0wYSxZQUFZLEVBQUUxYSxNQUFNZ2MsSUFBSTtBQUNwRDtBQUNBdXRELGlCQUFpQi90RSxTQUFTLENBQUN1ZixVQUFVLEdBQUcsU0FBU0EsV0FBWWdvQyxlQUFlO0lBQzFFLElBQUksSUFBSSxDQUFDcm9DLFlBQVksS0FBSyxLQUFLLElBQUksQ0FBQ3NCLElBQUksS0FBSyxLQUFLO1FBQUUsT0FBTztJQUFLO0lBQ2hFLElBQUksSUFBSSxDQUFDdEIsWUFBWSxLQUFLcW9DLGlCQUFpQjtRQUFFLE9BQU87SUFBSztJQUN6RCxPQUFPO0FBQ1Q7QUFDQXdtQixpQkFBaUIvdEUsU0FBUyxDQUFDaUYsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sSUFBSSxDQUFDK21CLEtBQUssR0FBRyxjQUFjLElBQUksQ0FBQzlNLFlBQVksR0FBRyxhQUFhLElBQUksQ0FBQ3NCLElBQUk7QUFDOUU7QUFDQXV0RCxpQkFBaUIvdEUsU0FBUyxDQUFDNmdELFdBQVcsR0FBRyxTQUFTQTtJQUNoRCxPQUFPLElBQUksQ0FBQ3JnQyxJQUFJO0FBQ2xCO0FBQ0F1dEQsaUJBQWlCL3RFLFNBQVMsQ0FBQ2dHLE9BQU8sR0FBRyxTQUFTQSxRQUFTa1osWUFBWSxFQUFFc0IsSUFBSTtJQUN2RSxJQUFJLElBQUksQ0FBQ3RCLFlBQVksR0FBR0EsY0FBYztRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQ2xELElBQUksSUFBSSxDQUFDQSxZQUFZLEdBQUdBLGNBQWM7UUFBRSxPQUFPO0lBQUU7SUFDakQsSUFBSSxJQUFJLENBQUNzQixJQUFJLEdBQUdBLE1BQU07UUFBRSxPQUFPLENBQUM7SUFBRTtJQUNsQyxJQUFJLElBQUksQ0FBQ0EsSUFBSSxHQUFHQSxNQUFNO1FBQUUsT0FBTztJQUFFO0lBQ2pDLE9BQU87QUFDVDtBQUNBdXRELGlCQUFpQi90RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDaEQsT0FBTztRQUFDeUI7S0FBVztBQUNyQjtBQUNBeXFFLGlCQUFpQi90RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDN0MsT0FBT2lzRTtBQUNUO0FBRUEsSUFBSUUsdUJBQXVCLFNBQVNBO0lBQ2xDLElBQUksQ0FBQ3ZtQixRQUFRLEdBQUcsSUFBSWx6QjtJQUNwQixJQUFJLENBQUNnZCxJQUFJLEdBQUc7SUFDWixJQUFJQSxPQUFPMXdDLFNBQVMsQ0FBQyxFQUFFO0lBQ3ZCLElBQUksQ0FBQzB3QyxJQUFJLEdBQUdBO0FBQ2Q7QUFDQXk4QixxQkFBcUJqdUUsU0FBUyxDQUFDcTBDLEtBQUssR0FBRyxTQUFTQSxNQUFPM3hCLEdBQUc7SUFDeERBLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSStYLEtBQUssSUFBSSxDQUFDclAsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUM1QyxJQUFJdThCLEtBQUtwdEIsR0FBR2hULElBQUk7UUFDaEJvZ0MsR0FBR3pULEtBQUssQ0FBQzN4QjtJQUNYO0FBQ0Y7QUFDQXVyRCxxQkFBcUJqdUUsU0FBUyxDQUFDcXJCLFFBQVEsR0FBRyxTQUFTQTtJQUNqRCxPQUFPLElBQUksQ0FBQ3E4QixRQUFRLENBQUN2MEIsTUFBTSxHQUFHOUgsUUFBUTtBQUN4QztBQUNBNGlELHFCQUFxQmp1RSxTQUFTLENBQUN5b0QsYUFBYSxHQUFHLFNBQVNBLGNBQWVDLFFBQVE7SUFDM0UsSUFBSXB1QyxTQUFTLElBQUk7SUFFbkIsSUFBSSxDQUFDc3RDLFlBQVk7SUFDakIsSUFBSWx0QixLQUFLLElBQUksQ0FBQ3JQLFFBQVE7SUFDdEIsSUFBSXc4QixTQUFTbnRCLEdBQUdoVCxJQUFJO0lBQ3BCLE1BQU9nVCxHQUFHblAsT0FBTyxHQUFJO1FBQ25CLElBQUl1OEIsS0FBS3B0QixHQUFHaFQsSUFBSTtRQUNoQixJQUFJaWhDLFVBQVVydUMsT0FBT3N1QyxlQUFlLENBQUNmLFFBQVFDO1FBQzdDWSxTQUFTejhDLEdBQUcsQ0FBQzA4QztRQUNiZCxTQUFTQztJQUNYO0FBQ0Y7QUFDQW1tQixxQkFBcUJqdUUsU0FBUyxDQUFDNG5ELFlBQVksR0FBRyxTQUFTQTtJQUNyRCxJQUFJcUIsY0FBYyxJQUFJLENBQUN6WCxJQUFJLENBQUN2cUIsR0FBRyxDQUFDeG1CLE1BQU0sR0FBRztJQUN6QyxJQUFJLENBQUN3TCxHQUFHLENBQUMsSUFBSSxDQUFDdWxDLElBQUksQ0FBQ3ZxQixHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUc7SUFDOUIsSUFBSSxDQUFDaGIsR0FBRyxDQUFDLElBQUksQ0FBQ3VsQyxJQUFJLENBQUN2cUIsR0FBRyxDQUFDZ2lDLFlBQVksRUFBRUEsYUFBYTtBQUNwRDtBQUNBZ2xCLHFCQUFxQmp1RSxTQUFTLENBQUM0b0QsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQlAsR0FBRyxFQUFFQyxHQUFHO0lBQy9FLElBQUlodUMsU0FBUyxJQUFJO0lBRW5CLElBQUkrWCxPQUFPaTJCLElBQUlwcEMsWUFBWSxHQUFHbXBDLElBQUlucEMsWUFBWSxHQUFHO0lBQ2pELElBQUlxcEMsaUJBQWlCLElBQUksQ0FBQy9XLElBQUksQ0FBQ3ZxQixHQUFHLENBQUNxaEMsSUFBSXBwQyxZQUFZLENBQUM7SUFDcEQsSUFBSXNwQyxZQUFZRixJQUFJOW5DLElBQUksR0FBRyxPQUFPLENBQUM4bkMsSUFBSXQ4QixLQUFLLENBQUN6bkIsUUFBUSxDQUFDZ2tEO0lBQ3RELElBQUksQ0FBQ0MsV0FBVztRQUNkbjJCO0lBQ0Y7SUFDQSxJQUFJcEwsTUFBTSxJQUFJbG5CLE1BQU1zeUIsTUFBTWh5QixJQUFJLENBQUM7SUFDL0IsSUFBSTZvRCxNQUFNO0lBQ1ZqaUMsR0FBRyxDQUFDaWlDLE1BQU0sR0FBRyxJQUFJeGxELFdBQVcya0QsSUFBSXI4QixLQUFLO0lBQ3JDLElBQUssSUFBSTVrQixJQUFJaWhELElBQUlucEMsWUFBWSxHQUFHLEdBQUc5WCxLQUFLa2hELElBQUlwcEMsWUFBWSxFQUFFOVgsSUFBSztRQUM3RDZmLEdBQUcsQ0FBQ2lpQyxNQUFNLEdBQUc1dUMsT0FBT2szQixJQUFJLENBQUN2cUIsR0FBRyxDQUFDN2YsRUFBRTtJQUNqQztJQUNBLElBQUlvaEQsV0FBVztRQUFFdmhDLEdBQUcsQ0FBQ2lpQyxJQUFJLEdBQUdaLElBQUl0OEIsS0FBSztJQUFFO0lBQ3ZDLE9BQU8sSUFBSWtpRCxLQUFLam5ELEtBQUssSUFBSTZuQixNQUFNLElBQUksQ0FBQzBDLElBQUksQ0FBQ2xCLE1BQU07QUFDakQ7QUFDQTI5QixxQkFBcUJqdUUsU0FBUyxDQUFDaU0sR0FBRyxHQUFHLFNBQVNBLElBQUtvVixLQUFLLEVBQUVuQyxZQUFZLEVBQUVzQixJQUFJO0lBQzFFLElBQUk2b0MsUUFBUSxJQUFJMGtCLGlCQUFpQjFzRCxPQUFPbkMsY0FBY3NCO0lBQ3RELElBQUlzbkMsS0FBSyxJQUFJLENBQUNKLFFBQVEsQ0FBQ3RrRCxHQUFHLENBQUNpbUQ7SUFDM0IsSUFBSXZCLE9BQU8sTUFBTTtRQUNmLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLENBQUNKLFFBQVEsQ0FBQ3gwQixHQUFHLENBQUNtMkIsT0FBT0E7SUFDekIsT0FBT0E7QUFDVDtBQUNBNGtCLHFCQUFxQmp1RSxTQUFTLENBQUM0Z0IsY0FBYyxHQUFHLFNBQVNBLGVBQWdCQyxFQUFFO0lBQ3pFLElBQUssSUFBSTZaLEtBQUssSUFBSSxDQUFDclAsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUM1QyxJQUFJdThCLEtBQUtwdEIsR0FBR2hULElBQUk7UUFDaEIsSUFBSW9nQyxHQUFHOTdCLEtBQUssQ0FBQ3JuQixNQUFNLENBQUNrYyxLQUFLO1lBQUUsT0FBTztRQUFLO0lBQ3pDO0lBQ0EsT0FBTztBQUNUO0FBQ0FvdEQscUJBQXFCanVFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNwRCxPQUFPLEVBQUU7QUFDWDtBQUNBb3NFLHFCQUFxQmp1RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDakQsT0FBT21zRTtBQUNUO0FBRUEsSUFBSUUsdUJBQXVCLFNBQVNBLHdCQUF5QjtBQUU3REEscUJBQXFCbnVFLFNBQVMsQ0FBQ2l4RCxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JocUMsR0FBRztJQUNwRixJQUFJM00sU0FBUyxJQUFJO0lBRW5CLElBQUlxVixRQUFRO0lBQ1osSUFBSXVoQyxpQkFBaUIsSUFBSTFqQztJQUN6QjBqQyxlQUFlamxELEdBQUcsQ0FBQyxJQUFJakQsUUFBUTJtQjtJQUMvQixHQUFHO1FBQ0QsSUFBSVosT0FBT3pVLE9BQU82MkMsWUFBWSxDQUFDbHFDLEtBQUswSTtRQUNwQ3VoQyxlQUFlamxELEdBQUcsQ0FBQyxJQUFJakQsUUFBUStsQjtRQUMvQlksUUFBUVo7SUFDVixRQUFTWSxRQUFRMUksSUFBSXhtQixNQUFNLEdBQUcsR0FBRTtJQUNoQyxJQUFJaXhDLGFBQWF5OEIscUJBQXFCL2MsVUFBVSxDQUFDRjtJQUNqRCxPQUFPeGY7QUFDVDtBQUNBeThCLHFCQUFxQm51RSxTQUFTLENBQUNteEQsWUFBWSxHQUFHLFNBQVNBLGFBQWNscUMsR0FBRyxFQUFFMEksS0FBSztJQUM3RSxJQUFJMmhDLFlBQVk3YixTQUFTZSxRQUFRLENBQUN2dkIsR0FBRyxDQUFDMEksTUFBTSxFQUFFMUksR0FBRyxDQUFDMEksUUFBUSxFQUFFO0lBQzVELElBQUlaLE9BQU9ZLFFBQVE7SUFDbkIsTUFBT1osT0FBTzlILElBQUl4bUIsTUFBTSxDQUFFO1FBQ3hCLElBQUl1MUMsT0FBT1AsU0FBU2UsUUFBUSxDQUFDdnZCLEdBQUcsQ0FBQzhILE9BQU8sRUFBRSxFQUFFOUgsR0FBRyxDQUFDOEgsS0FBSztRQUNyRCxJQUFJaW5CLFNBQVNzYixXQUFXO1lBQUU7UUFBTTtRQUNoQ3ZpQztJQUNGO0lBQ0EsT0FBT0EsT0FBTztBQUNoQjtBQUNBby9DLHFCQUFxQm51RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDcEQsT0FBTyxFQUFFO0FBQ1g7QUFDQXNzRSxxQkFBcUJudUUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pELE9BQU9xc0U7QUFDVDtBQUNBQSxxQkFBcUIvYyxVQUFVLEdBQUcsU0FBU0EsV0FBWU0sSUFBSTtJQUN6RCxJQUFJbjNDLFFBQVEsSUFBSXhhLE1BQU0yeEQsS0FBSy85QyxJQUFJLElBQUl0VCxJQUFJLENBQUM7SUFDeEMsSUFBSyxJQUFJK0csSUFBSSxHQUFHQSxJQUFJbVQsTUFBTTlaLE1BQU0sRUFBRTJHLElBQUs7UUFDckNtVCxLQUFLLENBQUNuVCxFQUFFLEdBQUdzcUQsS0FBS3R1RCxHQUFHLENBQUNnRSxHQUFHNkIsUUFBUTtJQUNqQztJQUNBLE9BQU9zUjtBQUNUO0FBRUEsSUFBSTZ6RCxvQkFBb0IsU0FBU0E7SUFDL0IsSUFBSSxDQUFDdmxFLENBQUMsR0FBRztJQUNULElBQUksQ0FBQ29lLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ3lxQixVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDbndCLElBQUksR0FBRyxJQUFJckw7SUFDaEIsSUFBSSxDQUFDbTRELElBQUksR0FBRyxJQUFJbjREO0lBQ2hCLElBQUlyTixJQUFJL0gsU0FBUyxDQUFDLEVBQUU7SUFDcEIsSUFBSSxDQUFDK0gsQ0FBQyxHQUFHQTtJQUNULElBQUksQ0FBQ29lLEdBQUcsR0FBR3BlLEVBQUU2dUIsY0FBYztJQUMzQixJQUFJNDJDLE1BQU0sSUFBSUg7SUFDZCxJQUFJLENBQUN6OEIsVUFBVSxHQUFHNDhCLElBQUlyZCxvQkFBb0IsQ0FBQyxJQUFJLENBQUNocUMsR0FBRztBQUNyRDtBQUNBbW5ELGtCQUFrQnB1RSxTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sSUFBSSxDQUFDelEsR0FBRztBQUNqQjtBQUNBbW5ELGtCQUFrQnB1RSxTQUFTLENBQUM2VyxPQUFPLEdBQUcsU0FBU0EsUUFBUzAzRCxVQUFVO0lBQ2hFLElBQUl2c0UsS0FBSyxJQUFJLENBQUNpbEIsR0FBRyxDQUFDLElBQUksQ0FBQ3lxQixVQUFVLENBQUM2OEIsV0FBVyxDQUFDLENBQUM3c0UsQ0FBQztJQUNoRCxJQUFJTyxLQUFLLElBQUksQ0FBQ2dsQixHQUFHLENBQUMsSUFBSSxDQUFDeXFCLFVBQVUsQ0FBQzY4QixhQUFhLEVBQUUsQ0FBQyxDQUFDN3NFLENBQUM7SUFDcEQsT0FBT00sS0FBS0MsS0FBS0QsS0FBS0M7QUFDeEI7QUFDQW1zRSxrQkFBa0JwdUUsU0FBUyxDQUFDK1csT0FBTyxHQUFHLFNBQVNBLFFBQVN3M0QsVUFBVTtJQUNoRSxJQUFJdnNFLEtBQUssSUFBSSxDQUFDaWxCLEdBQUcsQ0FBQyxJQUFJLENBQUN5cUIsVUFBVSxDQUFDNjhCLFdBQVcsQ0FBQyxDQUFDN3NFLENBQUM7SUFDaEQsSUFBSU8sS0FBSyxJQUFJLENBQUNnbEIsR0FBRyxDQUFDLElBQUksQ0FBQ3lxQixVQUFVLENBQUM2OEIsYUFBYSxFQUFFLENBQUMsQ0FBQzdzRSxDQUFDO0lBQ3BELE9BQU9NLEtBQUtDLEtBQUtELEtBQUtDO0FBQ3hCO0FBQ0Ftc0Usa0JBQWtCcHVFLFNBQVMsQ0FBQ3d1RSx5QkFBeUIsR0FBRyxTQUFTQTtJQUMvRCxJQUFJMXRFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlndUUsY0FBYzN0RSxTQUFTLENBQUMsRUFBRTtRQUM5QixJQUFJNHRFLE1BQU01dEUsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTZ0RSxjQUFjN3RFLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUlxeEQsS0FBS3J4RCxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUMwdEUseUJBQXlCLENBQUMsSUFBSSxDQUFDOThCLFVBQVUsQ0FBQys4QixZQUFZLEVBQUUsSUFBSSxDQUFDLzhCLFVBQVUsQ0FBQys4QixjQUFjLEVBQUUsRUFBRUMsS0FBS0EsSUFBSWg5QixVQUFVLENBQUNpOUIsWUFBWSxFQUFFRCxJQUFJaDlCLFVBQVUsQ0FBQ2k5QixjQUFjLEVBQUUsRUFBRXhjO0lBQ3BLLE9BQU8sSUFBSXJ4RCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJa3ZELFNBQVM3dUQsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSTh1RCxPQUFPOXVELFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk4dEUsUUFBUTl0RSxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJa3VELFNBQVNsdUQsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSTJ2RCxPQUFPM3ZELFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlnbkQsS0FBS2huRCxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJNHZELE1BQU0sSUFBSSxDQUFDenBDLEdBQUcsQ0FBQzBvQyxPQUFPO1FBQzFCLElBQUlnQixNQUFNLElBQUksQ0FBQzFwQyxHQUFHLENBQUMyb0MsS0FBSztRQUN4QixJQUFJZ0IsTUFBTWdlLE1BQU0zbkQsR0FBRyxDQUFDK25DLE9BQU87UUFDM0IsSUFBSTZCLE1BQU0rZCxNQUFNM25ELEdBQUcsQ0FBQ3dwQyxLQUFLO1FBQ3pCLElBQUliLE9BQU9ELFdBQVcsS0FBS2MsT0FBT3pCLFdBQVcsR0FBRztZQUM5Q2xILEdBQUdvRCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNyaUQsQ0FBQyxFQUFFOG1ELFFBQVFpZixNQUFNL2xFLENBQUMsRUFBRW1tRDtZQUM3QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJLENBQUN6dEMsSUFBSSxDQUFDL1gsSUFBSSxDQUFDa25ELEtBQUtDO1FBQ3BCLElBQUksQ0FBQzBkLElBQUksQ0FBQzdrRSxJQUFJLENBQUNvbkQsS0FBS0M7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ3R2QyxJQUFJLENBQUN0SyxVQUFVLENBQUMsSUFBSSxDQUFDbzNELElBQUksR0FBRztZQUFFLE9BQU87UUFBSztRQUNwRCxJQUFJdmQsT0FBT3B3RCxLQUFLZSxLQUFLLENBQUMsQ0FBQ2t1RCxTQUFTQyxJQUFHLElBQUs7UUFDeEMsSUFBSW1CLE9BQU9yd0QsS0FBS2UsS0FBSyxDQUFDLENBQUN1dEQsU0FBU3lCLElBQUcsSUFBSztRQUN4QyxJQUFJZCxTQUFTbUIsTUFBTTtZQUNqQixJQUFJOUIsU0FBUytCLE1BQU07Z0JBQUUsSUFBSSxDQUFDeWQseUJBQXlCLENBQUM3ZSxRQUFRbUIsTUFBTThkLE9BQU81ZixRQUFRK0IsTUFBTWpKO1lBQUs7WUFDNUYsSUFBSWlKLE9BQU9OLE1BQU07Z0JBQUUsSUFBSSxDQUFDK2QseUJBQXlCLENBQUM3ZSxRQUFRbUIsTUFBTThkLE9BQU83ZCxNQUFNTixNQUFNM0k7WUFBSztRQUMxRjtRQUNBLElBQUlnSixPQUFPbEIsTUFBTTtZQUNmLElBQUlaLFNBQVMrQixNQUFNO2dCQUFFLElBQUksQ0FBQ3lkLHlCQUF5QixDQUFDMWQsTUFBTWxCLE1BQU1nZixPQUFPNWYsUUFBUStCLE1BQU1qSjtZQUFLO1lBQzFGLElBQUlpSixPQUFPTixNQUFNO2dCQUFFLElBQUksQ0FBQytkLHlCQUF5QixDQUFDMWQsTUFBTWxCLE1BQU1nZixPQUFPN2QsTUFBTU4sTUFBTTNJO1lBQUs7UUFDeEY7SUFDRjtBQUNGO0FBQ0FzbUIsa0JBQWtCcHVFLFNBQVMsQ0FBQzZ1RSxlQUFlLEdBQUcsU0FBU0E7SUFDckQsT0FBTyxJQUFJLENBQUNuOUIsVUFBVTtBQUN4QjtBQUNBMDhCLGtCQUFrQnB1RSxTQUFTLENBQUM4dUUsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CSixHQUFHLEVBQUV2YyxFQUFFO0lBQy9FLElBQUk3M0MsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNzcUMsVUFBVSxDQUFDanhDLE1BQU0sR0FBRyxHQUFHMkcsSUFBSztRQUNuRCxJQUFLLElBQUlra0IsSUFBSSxHQUFHQSxJQUFJb2pELElBQUloOUIsVUFBVSxDQUFDanhDLE1BQU0sR0FBRyxHQUFHNnFCLElBQUs7WUFDbERoUixPQUFPazBELHlCQUF5QixDQUFDcG5FLEdBQUdzbkUsS0FBS3BqRCxHQUFHNm1DO1FBQzlDO0lBQ0Y7QUFDRjtBQUNBaWMsa0JBQWtCcHVFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNqRCxPQUFPLEVBQUU7QUFDWDtBQUNBdXNFLGtCQUFrQnB1RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDOUMsT0FBT3NzRTtBQUNUO0FBRUEsSUFBSVcsUUFBUSxTQUFTQTtJQUNuQixJQUFJejBELFNBQVMsSUFBSTtJQUVqQixJQUFJLENBQUNtK0IsTUFBTSxHQUFHMTRDLE1BQU0sR0FBR00sSUFBSSxHQUFHOGQsR0FBRyxDQUFDO1FBQWMsT0FBT3BlLE1BQU07SUFBSTtJQUNqRSxJQUFLLElBQUlxSCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUMxQixJQUFLLElBQUlra0IsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUJoUixPQUFPbStCLE1BQU0sQ0FBQ3J4QyxFQUFFLENBQUNra0IsRUFBRSxHQUFHeWpELE1BQU1DLFVBQVU7UUFDeEM7SUFDRjtBQUNGO0FBRUEsSUFBSUMscUJBQXFCO0lBQUVELFlBQVk7UUFBRTd1RSxjQUFjO0lBQUs7QUFBRTtBQUM5RDR1RSxNQUFNL3VFLFNBQVMsQ0FBQ3NzQyxRQUFRLEdBQUcsU0FBU0EsU0FBVTRDLFNBQVMsRUFBRWIsUUFBUTtJQUMvRCxPQUFPLElBQUksQ0FBQ29LLE1BQU0sQ0FBQ3ZKLFVBQVUsQ0FBQ2IsU0FBUztBQUN6QztBQUNBMGdDLE1BQU0vdUUsU0FBUyxDQUFDa3RDLFFBQVEsR0FBRyxTQUFTQSxTQUFVZ0MsU0FBUyxFQUFFYixRQUFRLEVBQUU2Z0MsVUFBVTtJQUMzRSxJQUFJLENBQUN6MkIsTUFBTSxDQUFDdkosVUFBVSxDQUFDYixTQUFTLEdBQUc2Z0M7QUFDckM7QUFDQUgsTUFBTS91RSxTQUFTLENBQUM0VyxNQUFNLEdBQUcsU0FBU0E7SUFDOUIsSUFBSTBELFNBQVMsSUFBSTtJQUVuQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSyxJQUFJMkcsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUIsSUFBSyxJQUFJa2tCLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQixJQUFJaFIsT0FBT20rQixNQUFNLENBQUNyeEMsRUFBRSxDQUFDa2tCLEVBQUUsS0FBS3lqRCxNQUFNQyxVQUFVLEVBQUU7b0JBQUUsT0FBTztnQkFBTTtZQUMvRDtRQUNGO1FBQ0EsT0FBTztJQUNULE9BQU8sSUFBSWx1RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJeXVDLFlBQVlwdUMsU0FBUyxDQUFDLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUMyM0MsTUFBTSxDQUFDdkosVUFBVSxDQUFDLEVBQUUsS0FBSzYvQixNQUFNQyxVQUFVO0lBQ3ZELE9BQU8sSUFBSWx1RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJOHVDLGNBQWN6dUMsU0FBUyxDQUFDLEVBQUU7UUFDOUIsSUFBSXV0QyxXQUFXdnRDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLE9BQU8sSUFBSSxDQUFDMjNDLE1BQU0sQ0FBQ2xKLFlBQVksQ0FBQ2xCLFNBQVMsS0FBSzBnQyxNQUFNQyxVQUFVO0lBQ2hFO0FBQ0Y7QUFDQUQsTUFBTS91RSxTQUFTLENBQUM4cUIsU0FBUyxHQUFHLFNBQVNBO0lBQ2pDLElBQUl4USxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDMUIsSUFBSSxDQUFDa1QsT0FBTzFELE1BQU0sQ0FBQ3hQLElBQUk7WUFDckIsSUFBSStuRSxXQUFXNzBELE9BQU9tK0IsTUFBTSxDQUFDcnhDLEVBQUUsQ0FBQyxFQUFFO1lBQ2xDLElBQUlrVCxPQUFPbStCLE1BQU0sQ0FBQ3J4QyxFQUFFLENBQUMsRUFBRSxHQUFHK25FLFVBQVU7Z0JBQUVBLFdBQVc3MEQsT0FBT20rQixNQUFNLENBQUNyeEMsRUFBRSxDQUFDLEVBQUU7WUFBRTtZQUN0RSxJQUFJK25FLFdBQVcsR0FBRztnQkFBRUEsV0FBVztZQUFHO1lBQ2xDLElBQUssSUFBSTdqRCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztnQkFDMUIsSUFBSThqRCxXQUFXO2dCQUNmLElBQUk5MEQsT0FBT20rQixNQUFNLENBQUNyeEMsRUFBRSxDQUFDa2tCLEVBQUUsR0FBRzZqRCxVQUFVO29CQUFFQyxXQUFXO2dCQUFHO2dCQUNwRDkwRCxPQUFPbStCLE1BQU0sQ0FBQ3J4QyxFQUFFLENBQUNra0IsRUFBRSxHQUFHOGpEO1lBQ3hCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0FMLE1BQU0vdUUsU0FBUyxDQUFDcXZFLFFBQVEsR0FBRyxTQUFTQSxTQUFVbmdDLFNBQVM7SUFDckQsT0FBTyxJQUFJLENBQUN1SixNQUFNLENBQUN2SixVQUFVLENBQUM1RyxTQUFTdmlCLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQzB5QixNQUFNLENBQUN2SixVQUFVLENBQUM1RyxTQUFTcmlCLElBQUksQ0FBQztBQUN2RjtBQUNBOG9ELE1BQU0vdUUsU0FBUyxDQUFDcWxCLFdBQVcsR0FBRyxTQUFTQSxZQUFhNnBCLFNBQVMsRUFBRWIsUUFBUTtJQUNyRSxJQUFJLElBQUksQ0FBQ29LLE1BQU0sQ0FBQ3ZKLFVBQVUsQ0FBQ2IsU0FBUyxJQUFJLEdBQUc7UUFBRSxPQUFPMW5DLFNBQVNJLFFBQVE7SUFBQztJQUN0RSxPQUFPSixTQUFTRSxRQUFRO0FBQzFCO0FBQ0Frb0UsTUFBTS91RSxTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDbEMsT0FBTyxRQUFRLElBQUksQ0FBQ3d6QyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ0EsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsU0FBUyxJQUFJLENBQUNBLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDQSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDbkg7QUFDQXMyQixNQUFNL3VFLFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQTtJQUMzQixJQUFJcU8sU0FBUyxJQUFJO0lBRW5CLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJd3VDLE1BQU1udUMsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSyxJQUFJc0csSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUIsSUFBSyxJQUFJa2tCLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO2dCQUMxQixJQUFJdWpCLE1BQU1JLElBQUk1cEIsV0FBVyxDQUFDamUsR0FBR2trQjtnQkFDN0IsSUFBSXVqQixRQUFRbG9DLFNBQVNJLFFBQVEsSUFBSThuQyxRQUFRbG9DLFNBQVNFLFFBQVEsRUFBRTtvQkFDMUQsSUFBSXlULE9BQU8xRCxNQUFNLENBQUN4UCxHQUFHa2tCLElBQUk7d0JBQ3ZCaFIsT0FBT20rQixNQUFNLENBQUNyeEMsRUFBRSxDQUFDa2tCLEVBQUUsR0FBR3lqRCxNQUFNTyxlQUFlLENBQUN6Z0M7b0JBQzlDLE9BQU87d0JBQUV2MEIsT0FBT20rQixNQUFNLENBQUNyeEMsRUFBRSxDQUFDa2tCLEVBQUUsSUFBSXlqRCxNQUFNTyxlQUFlLENBQUN6Z0M7b0JBQU07Z0JBQzlEO1lBQ0Y7UUFDRjtJQUNGLE9BQU8sSUFBSS90QyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJeXVDLFlBQVlwdUMsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSXV0QyxXQUFXdnRDLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUl5c0MsV0FBV3pzQyxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJeXNDLGFBQWE1bUMsU0FBU0UsUUFBUSxFQUFFO1lBQUUsSUFBSSxDQUFDNHhDLE1BQU0sQ0FBQ3ZKLFVBQVUsQ0FBQ2IsU0FBUztRQUFJO0lBQzVFO0FBQ0Y7QUFDQTBnQyxNQUFNL3VFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNyQyxPQUFPLEVBQUU7QUFDWDtBQUNBa3RFLE1BQU0vdUUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2xDLE9BQU9pdEU7QUFDVDtBQUNBQSxNQUFNTyxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCL2hDLFFBQVE7SUFDeEQsSUFBSUEsYUFBYTVtQyxTQUFTSSxRQUFRLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDL0MsSUFBSXdtQyxhQUFhNW1DLFNBQVNFLFFBQVEsRUFBRTtRQUFFLE9BQU87SUFBRTtJQUMvQyxPQUFPa29FLE1BQU1DLFVBQVU7QUFDekI7QUFDQUMsbUJBQW1CRCxVQUFVLENBQUM1ckUsR0FBRyxHQUFHO0lBQWMsT0FBTyxDQUFDO0FBQUU7QUFFNURuRCxPQUFPb0QsZ0JBQWdCLENBQUUwckUsT0FBT0U7QUFFaEMsSUFBSWYsT0FBUSxTQUFVajZCLGlCQUFpQjtJQUNyQyxTQUFTaTZCO1FBQ1BqNkIsa0JBQWtCMXhDLElBQUksQ0FBQyxJQUFJO1FBQzNCLElBQUksQ0FBQzBrQixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNza0IsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDOE8sTUFBTSxHQUFHLElBQUk0ekIscUJBQXFCLElBQUk7UUFDM0MsSUFBSSxDQUFDdHBDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQzRxQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUMvMkIsTUFBTSxHQUFHLElBQUlzMkI7UUFDbEIsSUFBSSxDQUFDVSxXQUFXLEdBQUc7UUFDbkIsSUFBSTN1RSxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJd21CLE1BQU1ubUIsU0FBUyxDQUFDLEVBQUU7WUFDdEJvdEUsS0FBSzNyRSxJQUFJLENBQUMsSUFBSSxFQUFFMGtCLEtBQUs7UUFDdkIsT0FBTyxJQUFJbm1CLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLElBQUkrd0QsUUFBUTF3RCxTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJaXZDLFFBQVFqdkMsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSSxDQUFDbW1CLEdBQUcsR0FBR3VxQztZQUNYLElBQUksQ0FBQ2xoQixNQUFNLEdBQUdQO1FBQ2hCO0lBQ0Y7SUFFQSxJQUFLa0UsbUJBQW9CaTZCLEtBQUt4ckUsU0FBUyxHQUFHdXhDO0lBQzFDaTZCLEtBQUtsdUUsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFc3hDLHFCQUFxQkEsa0JBQWtCajBDLFNBQVM7SUFDaEZrdUUsS0FBS2x1RSxTQUFTLENBQUM0QyxXQUFXLEdBQUdzckU7SUFDN0JBLEtBQUtsdUUsU0FBUyxDQUFDc3NDLFFBQVEsR0FBRyxTQUFTQTtRQUNqQyxPQUFPLElBQUksQ0FBQ21NLE1BQU07SUFDcEI7SUFDQXkxQixLQUFLbHVFLFNBQVMsQ0FBQzB2RSxnQkFBZ0IsR0FBRyxTQUFTQTtRQUN6QyxJQUFJQyxTQUFTLElBQUk1dkUsTUFBTSxHQUFHTSxJQUFJLENBQUM7UUFDL0JzdkUsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMxb0QsR0FBRyxDQUFDLEVBQUU7UUFDdkIwb0QsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMxb0QsR0FBRyxDQUFDLEVBQUU7UUFDdkIsSUFBSTJvRCxPQUFPLElBQUkxQixLQUFLeUIsUUFBUTdnQyxNQUFNZ0IsV0FBVyxDQUFDLElBQUksQ0FBQ1EsTUFBTTtRQUN6RCxPQUFPcy9CO0lBQ1Q7SUFDQTFCLEtBQUtsdUUsU0FBUyxDQUFDNHdDLFVBQVUsR0FBRyxTQUFTQTtRQUNuQyxPQUFPLElBQUksQ0FBQzQrQixXQUFXO0lBQ3pCO0lBQ0F0QixLQUFLbHVFLFNBQVMsQ0FBQzAzQixjQUFjLEdBQUcsU0FBU0E7UUFDdkMsT0FBTyxJQUFJLENBQUN6USxHQUFHO0lBQ2pCO0lBQ0FpbkQsS0FBS2x1RSxTQUFTLENBQUM2dkUsV0FBVyxHQUFHLFNBQVNBLFlBQWFqL0IsVUFBVTtRQUMzRCxJQUFJLENBQUM0K0IsV0FBVyxHQUFHNStCO0lBQ3JCO0lBQ0FzOUIsS0FBS2x1RSxTQUFTLENBQUM4dkUsT0FBTyxHQUFHLFNBQVNBLFFBQVN0dEUsSUFBSTtRQUM3QyxJQUFJLENBQUNtaUMsS0FBSyxHQUFHbmlDO0lBQ2Y7SUFDQTByRSxLQUFLbHVFLFNBQVMsQ0FBQzJFLE1BQU0sR0FBRyxTQUFTQSxPQUFRRyxDQUFDO1FBQ3hDLElBQUl3VixTQUFTLElBQUk7UUFFakIsSUFBSSxDQUFFeFYsQ0FBQUEsYUFBYW9wRSxJQUFHLEdBQUk7WUFBRSxPQUFPO1FBQU07UUFDekMsSUFBSXJsRSxJQUFJL0Q7UUFDUixJQUFJLElBQUksQ0FBQ21pQixHQUFHLENBQUN4bUIsTUFBTSxLQUFLb0ksRUFBRW9lLEdBQUcsQ0FBQ3htQixNQUFNLEVBQUU7WUFBRSxPQUFPO1FBQU07UUFDckQsSUFBSXN2RSxpQkFBaUI7UUFDckIsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUlDLE9BQU8sSUFBSSxDQUFDaHBELEdBQUcsQ0FBQ3htQixNQUFNO1FBQzFCLElBQUssSUFBSTJHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2ZixHQUFHLENBQUN4bUIsTUFBTSxFQUFFMkcsSUFBSztZQUN4QyxJQUFJLENBQUNrVCxPQUFPMk0sR0FBRyxDQUFDN2YsRUFBRSxDQUFDN0MsUUFBUSxDQUFDc0UsRUFBRW9lLEdBQUcsQ0FBQzdmLEVBQUUsR0FBRztnQkFDckMyb0UsaUJBQWlCO1lBQ25CO1lBQ0EsSUFBSSxDQUFDejFELE9BQU8yTSxHQUFHLENBQUM3ZixFQUFFLENBQUM3QyxRQUFRLENBQUNzRSxFQUFFb2UsR0FBRyxDQUFDLEVBQUVncEQsS0FBSyxHQUFHO2dCQUMxQ0QsaUJBQWlCO1lBQ25CO1lBQ0EsSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQ0MsZ0JBQWdCO2dCQUFFLE9BQU87WUFBTTtRQUN6RDtRQUNBLE9BQU87SUFDVDtJQUNBOUIsS0FBS2x1RSxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7UUFDdEMsSUFBSTlTLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUksSUFBSSxDQUFDd21CLEdBQUcsQ0FBQ3htQixNQUFNLEdBQUcsR0FBRztnQkFBRSxPQUFPLElBQUksQ0FBQ3dtQixHQUFHLENBQUMsRUFBRTtZQUFDO1lBQzlDLE9BQU87UUFDVCxPQUFPLElBQUlubUIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSTJHLElBQUl0RyxTQUFTLENBQUMsRUFBRTtZQUNwQixPQUFPLElBQUksQ0FBQ21tQixHQUFHLENBQUM3ZixFQUFFO1FBQ3BCO0lBQ0Y7SUFDQThtRSxLQUFLbHVFLFNBQVMsQ0FBQ3EwQyxLQUFLLEdBQUcsU0FBU0EsTUFBTzN4QixHQUFHO1FBQ3hDLElBQUlwSSxTQUFTLElBQUk7UUFFakJvSSxJQUFJMnhCLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQzFQLEtBQUssR0FBRztRQUNqQ2ppQixJQUFJMnhCLEtBQUssQ0FBQztRQUNWLElBQUssSUFBSWp0QyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNmYsR0FBRyxDQUFDeG1CLE1BQU0sRUFBRTJHLElBQUs7WUFDeEMsSUFBSUEsSUFBSSxHQUFHO2dCQUFFc2IsSUFBSTJ4QixLQUFLLENBQUM7WUFBTTtZQUM3QjN4QixJQUFJMnhCLEtBQUssQ0FBQy81QixPQUFPMk0sR0FBRyxDQUFDN2YsRUFBRSxDQUFDMUYsQ0FBQyxHQUFHLE1BQU00WSxPQUFPMk0sR0FBRyxDQUFDN2YsRUFBRSxDQUFDekQsQ0FBQztRQUNuRDtRQUNBK2UsSUFBSTJ4QixLQUFLLENBQUMsUUFBUSxJQUFJLENBQUMvRCxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUNtL0IsV0FBVztJQUN4RDtJQUNBdkIsS0FBS2x1RSxTQUFTLENBQUMrekMsU0FBUyxHQUFHLFNBQVNBLFVBQVdELEVBQUU7UUFDL0NvNkIsS0FBS3I2QixRQUFRLENBQUMsSUFBSSxDQUFDdkQsTUFBTSxFQUFFd0Q7SUFDN0I7SUFDQW82QixLQUFLbHVFLFNBQVMsQ0FBQ2dwRCxXQUFXLEdBQUcsU0FBU0E7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQzFZLE1BQU0sQ0FBQ2hDLE1BQU0sSUFBSTtZQUFFLE9BQU87UUFBTTtRQUMxQyxJQUFJLElBQUksQ0FBQ3JuQixHQUFHLENBQUN4bUIsTUFBTSxLQUFLLEdBQUc7WUFBRSxPQUFPO1FBQU07UUFDMUMsSUFBSSxJQUFJLENBQUN3bUIsR0FBRyxDQUFDLEVBQUUsQ0FBQ3RpQixNQUFNLENBQUMsSUFBSSxDQUFDc2lCLEdBQUcsQ0FBQyxFQUFFLEdBQUc7WUFBRSxPQUFPO1FBQUs7UUFDbkQsT0FBTztJQUNUO0lBQ0FpbkQsS0FBS2x1RSxTQUFTLENBQUNpNUIsUUFBUSxHQUFHLFNBQVNBO1FBQ2pDLE9BQU8sSUFBSSxDQUFDaFMsR0FBRyxDQUFDLEVBQUUsQ0FBQ3RpQixNQUFNLENBQUMsSUFBSSxDQUFDc2lCLEdBQUcsQ0FBQyxJQUFJLENBQUNBLEdBQUcsQ0FBQ3htQixNQUFNLEdBQUcsRUFBRTtJQUN6RDtJQUNBeXRFLEtBQUtsdUUsU0FBUyxDQUFDa3dFLHNCQUFzQixHQUFHLFNBQVNBO1FBQy9DLE9BQU8sSUFBSSxDQUFDanBELEdBQUcsQ0FBQ3htQixNQUFNLEdBQUc7SUFDM0I7SUFDQXl0RSxLQUFLbHVFLFNBQVMsQ0FBQzg0QyxhQUFhLEdBQUcsU0FBU0E7UUFDdEMsT0FBTyxJQUFJLENBQUMyMkIsV0FBVztJQUN6QjtJQUNBdkIsS0FBS2x1RSxTQUFTLENBQUMyM0IsWUFBWSxHQUFHLFNBQVNBO1FBQ3JDLE9BQU8sSUFBSSxDQUFDMVEsR0FBRyxDQUFDeG1CLE1BQU07SUFDeEI7SUFDQXl0RSxLQUFLbHVFLFNBQVMsQ0FBQ3M1QyxZQUFZLEdBQUcsU0FBU0EsYUFBYzUyQixHQUFHO1FBQ3RELElBQUlwSSxTQUFTLElBQUk7UUFFakJvSSxJQUFJMnhCLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQzFQLEtBQUssR0FBRztRQUNqQyxJQUFLLElBQUl2OUIsSUFBSSxJQUFJLENBQUM2ZixHQUFHLENBQUN4bUIsTUFBTSxHQUFHLEdBQUcyRyxLQUFLLEdBQUdBLElBQUs7WUFDN0NzYixJQUFJMnhCLEtBQUssQ0FBQy81QixPQUFPMk0sR0FBRyxDQUFDN2YsRUFBRSxHQUFHO1FBQzVCO1FBQ0FzYixJQUFJQyxPQUFPLENBQUM7SUFDZDtJQUNBdXJELEtBQUtsdUUsU0FBUyxDQUFDbXdFLG9CQUFvQixHQUFHLFNBQVNBO1FBQzdDLElBQUksSUFBSSxDQUFDWixJQUFJLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQ0EsSUFBSSxHQUFHLElBQUluQixrQkFBa0IsSUFBSTtRQUFHO1FBQ25FLE9BQU8sSUFBSSxDQUFDbUIsSUFBSTtJQUNsQjtJQUNBckIsS0FBS2x1RSxTQUFTLENBQUN5cUIsV0FBVyxHQUFHLFNBQVNBO1FBQ3BDLElBQUluUSxTQUFTLElBQUk7UUFFakIsSUFBSSxJQUFJLENBQUNpeEIsSUFBSSxLQUFLLE1BQU07WUFDdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFBSXIxQjtZQUNoQixJQUFLLElBQUk5TyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNmYsR0FBRyxDQUFDeG1CLE1BQU0sRUFBRTJHLElBQUs7Z0JBQ3hDa1QsT0FBT2l4QixJQUFJLENBQUNoMEIsZUFBZSxDQUFDK0MsT0FBTzJNLEdBQUcsQ0FBQzdmLEVBQUU7WUFDM0M7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDbWtDLElBQUk7SUFDbEI7SUFDQTJpQyxLQUFLbHVFLFNBQVMsQ0FBQ3NxRCxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCTSxFQUFFLEVBQUUxckMsWUFBWSxFQUFFZ3dCLFNBQVMsRUFBRS92QixRQUFRO1FBQzlGLElBQUlrQyxRQUFRLElBQUkzZCxXQUFXa25ELEdBQUdycUMsZUFBZSxDQUFDcEI7UUFDOUMsSUFBSTRyQyx5QkFBeUI3ckM7UUFDN0IsSUFBSXNCLE9BQU9vcUMsR0FBRzdxQyxlQUFlLENBQUNtdkIsV0FBVy92QjtRQUN6QyxJQUFJNnJDLGVBQWVELHlCQUF5QjtRQUM1QyxJQUFJQyxlQUFlLElBQUksQ0FBQy9qQyxHQUFHLENBQUN4bUIsTUFBTSxFQUFFO1lBQ2xDLElBQUl3cUQsU0FBUyxJQUFJLENBQUNoa0MsR0FBRyxDQUFDK2pDLGFBQWE7WUFDbkMsSUFBSTNwQyxNQUFNOWMsUUFBUSxDQUFDMG1ELFNBQVM7Z0JBQzFCRix5QkFBeUJDO2dCQUN6QnhxQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLElBQUksQ0FBQzY1QixNQUFNLENBQUNwdUMsR0FBRyxDQUFDb1YsT0FBTzBwQyx3QkFBd0J2cUM7SUFDakQ7SUFDQTB0RCxLQUFLbHVFLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtRQUNqQyxJQUFJcVYsU0FBUyxJQUFJO1FBRWpCLElBQUlqUCxNQUFNLElBQUkzQztRQUNkMkMsSUFBSXpDLE1BQU0sQ0FBQyxVQUFVLElBQUksQ0FBQys3QixLQUFLLEdBQUc7UUFDbEN0NUIsSUFBSXpDLE1BQU0sQ0FBQztRQUNYLElBQUssSUFBSXhCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2ZixHQUFHLENBQUN4bUIsTUFBTSxFQUFFMkcsSUFBSztZQUN4QyxJQUFJQSxJQUFJLEdBQUc7Z0JBQUVpRSxJQUFJekMsTUFBTSxDQUFDO1lBQU07WUFDOUJ5QyxJQUFJekMsTUFBTSxDQUFDMFIsT0FBTzJNLEdBQUcsQ0FBQzdmLEVBQUUsQ0FBQzFGLENBQUMsR0FBRyxNQUFNNFksT0FBTzJNLEdBQUcsQ0FBQzdmLEVBQUUsQ0FBQ3pELENBQUM7UUFDcEQ7UUFDQTBILElBQUl6QyxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMwbkMsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDbS9CLFdBQVc7UUFDdkQsT0FBT3BrRSxJQUFJcEcsUUFBUTtJQUNyQjtJQUNBaXBFLEtBQUtsdUUsU0FBUyxDQUFDb3dFLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQnZuRSxDQUFDO1FBQzVELElBQUl5UixTQUFTLElBQUk7UUFFakIsSUFBSSxJQUFJLENBQUMyTSxHQUFHLENBQUN4bUIsTUFBTSxLQUFLb0ksRUFBRW9lLEdBQUcsQ0FBQ3htQixNQUFNLEVBQUU7WUFBRSxPQUFPO1FBQU07UUFDckQsSUFBSyxJQUFJMkcsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZmLEdBQUcsQ0FBQ3htQixNQUFNLEVBQUUyRyxJQUFLO1lBQ3hDLElBQUksQ0FBQ2tULE9BQU8yTSxHQUFHLENBQUM3ZixFQUFFLENBQUM3QyxRQUFRLENBQUNzRSxFQUFFb2UsR0FBRyxDQUFDN2YsRUFBRSxHQUFHO2dCQUNyQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBOG1FLEtBQUtsdUUsU0FBUyxDQUFDcXdFLGFBQWEsR0FBRyxTQUFTQSxjQUFlajNCLFVBQVU7UUFDL0QsSUFBSSxDQUFDcTJCLFdBQVcsR0FBR3IyQjtJQUNyQjtJQUNBODBCLEtBQUtsdUUsU0FBUyxDQUFDc3dFLHVCQUF1QixHQUFHLFNBQVNBO1FBQ2hELE9BQU8sSUFBSSxDQUFDajJCLE1BQU07SUFDcEI7SUFDQTZ6QixLQUFLbHVFLFNBQVMsQ0FBQ2tyRCxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0JOLEVBQUUsRUFBRTFyQyxZQUFZLEVBQUVnd0IsU0FBUztRQUN0RixJQUFJNTBCLFNBQVMsSUFBSTtRQUVqQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUl3akQsR0FBRy9xQyxrQkFBa0IsSUFBSXpZLElBQUs7WUFDaERrVCxPQUFPZ3dDLGVBQWUsQ0FBQ00sSUFBSTFyQyxjQUFjZ3dCLFdBQVc5bkM7UUFDdEQ7SUFDRjtJQUNBOG1FLEtBQUtsdUUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ3BDLE9BQU8sRUFBRTtJQUNYO0lBQ0Fxc0UsS0FBS2x1RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDakMsT0FBT29zRTtJQUNUO0lBQ0FBLEtBQUtyNkIsUUFBUSxHQUFHLFNBQVNBO1FBQ3ZCLElBQUkveUMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSXN2QyxRQUFRanZDLFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUlnekMsS0FBS2h6QyxTQUFTLENBQUMsRUFBRTtZQUNyQmd6QyxHQUFHeThCLGlCQUFpQixDQUFDeGdDLE1BQU0xcUIsV0FBVyxDQUFDLEdBQUdpakIsU0FBU0UsRUFBRSxHQUFHdUgsTUFBTTFxQixXQUFXLENBQUMsR0FBR2lqQixTQUFTRSxFQUFFLEdBQUc7WUFDM0YsSUFBSXVILE1BQU16QixNQUFNLElBQUk7Z0JBQ2xCd0YsR0FBR3k4QixpQkFBaUIsQ0FBQ3hnQyxNQUFNMXFCLFdBQVcsQ0FBQyxHQUFHaWpCLFNBQVNyaUIsSUFBSSxHQUFHOHBCLE1BQU0xcUIsV0FBVyxDQUFDLEdBQUdpakIsU0FBU3JpQixJQUFJLEdBQUc7Z0JBQy9GNnRCLEdBQUd5OEIsaUJBQWlCLENBQUN4Z0MsTUFBTTFxQixXQUFXLENBQUMsR0FBR2lqQixTQUFTdmlCLEtBQUssR0FBR2dxQixNQUFNMXFCLFdBQVcsQ0FBQyxHQUFHaWpCLFNBQVN2aUIsS0FBSyxHQUFHO1lBQ25HO1FBQ0YsT0FBTztZQUFFLE9BQU9rdUIsa0JBQWtCajBDLFNBQVMsQ0FBQzZ6QyxRQUFRLENBQUN0NkIsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDOUU7SUFFQSxPQUFPb3RFO0FBQ1QsRUFBRS82QjtBQUVGLElBQUlxOUIsZ0JBQWdCLFNBQVNBLGNBQWU1VSxTQUFTO0lBQ25ELElBQUksQ0FBQzZVLHNCQUFzQixHQUFHO0lBQzlCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO0lBQ3JCLElBQUksQ0FBQ24zQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDbzNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQy9JLFNBQVMsR0FBRyxJQUFJc0U7SUFDckIsSUFBSSxDQUFDalIsVUFBVSxHQUFHVyxhQUFhO0FBQ2pDO0FBQ0E0VSxjQUFjeHdFLFNBQVMsQ0FBQzR3RSx3QkFBd0IsR0FBRyxTQUFTQSx5QkFBMEJsdEMsRUFBRTtJQUN0RixJQUFJLENBQUMrc0Msc0JBQXNCLEdBQUcvc0M7QUFDaEM7QUFDQThzQyxjQUFjeHdFLFNBQVMsQ0FBQzZ3RSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0Job0UsQ0FBQztJQUNyRSxJQUFJaW9FLGVBQWUsSUFBSSxDQUFDbEosU0FBUyxDQUFDMEUsYUFBYSxDQUFDempFO0lBQ2hELElBQUlpb0UsaUJBQWlCLE1BQU07UUFDekIsSUFBSUMsZ0JBQWdCRCxhQUFhLy9CLFFBQVE7UUFDekMsSUFBSWlnQyxlQUFlbm9FLEVBQUVrb0MsUUFBUTtRQUM3QixJQUFJLENBQUMrL0IsYUFBYVYsZ0JBQWdCLENBQUN2bkUsSUFBSTtZQUNyQ21vRSxlQUFlLElBQUlsaUMsTUFBTWptQyxFQUFFa29DLFFBQVE7WUFDbkNpZ0MsYUFBYTlpQyxJQUFJO1FBQ25CO1FBQ0E2aUMsY0FBY2hqQyxLQUFLLENBQUNpakM7UUFDcEIsSUFBSUMsYUFBYVQsY0FBY3AzQixVQUFVLENBQUM0M0I7UUFDMUMsSUFBSUUsZ0JBQWdCSixhQUFhaDRCLGFBQWE7UUFDOUMsSUFBSXE0QixXQUFXRCxnQkFBZ0JEO1FBQy9CSCxhQUFhVCxhQUFhLENBQUNjO0lBQzdCLE9BQU87UUFDTCxJQUFJLENBQUN2SixTQUFTLENBQUMzN0QsR0FBRyxDQUFDcEQ7UUFDbkJBLEVBQUV3bkUsYUFBYSxDQUFDRyxjQUFjcDNCLFVBQVUsQ0FBQ3Z3QyxFQUFFa29DLFFBQVE7SUFDckQ7QUFDRjtBQUNBeS9CLGNBQWN4d0UsU0FBUyxDQUFDb3hFLGNBQWMsR0FBRyxTQUFTQSxlQUFnQkMsWUFBWSxFQUFFQyxXQUFXO0lBQ3pGLElBQUlDLGtCQUFrQixJQUFJL2pEO0lBQzFCLElBQUssSUFBSXBtQixJQUFJaXFFLGFBQWFobUQsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQ2xELElBQUlpbUQsV0FBV3BxRSxFQUFFc2dCLElBQUk7UUFDckIsSUFBSTFTLElBQUl3OEQsU0FBUzlsQyxzQkFBc0I7UUFDdkMsSUFBSStsQyxVQUFVLElBQUl2USxxQkFBcUJxUTtRQUN2QyxJQUFJcmxDLGVBQWV1bEMsUUFBUW5sQyxRQUFRLENBQUN0M0I7UUFDcEN3OEQsU0FBU3ZsQyxZQUFZLENBQUNDO1FBQ3RCc2xDLFNBQVNubEMsZUFBZTtRQUN4QmtsQyxnQkFBZ0J0bEUsR0FBRyxDQUFDdWxFO1FBQ3BCRixZQUFZcmxFLEdBQUcsQ0FBQ3VsRSxTQUFTbmtDLGdCQUFnQixJQUFJbWtDLFNBQVNwa0MsUUFBUTtJQUNoRTtBQUNGO0FBQ0FvakMsY0FBY3h3RSxTQUFTLENBQUMweEUsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQjVrQyxLQUFLO0lBQ3ZFLElBQUl1a0MsZUFBZSxJQUFJN2pEO0lBQ3ZCLElBQUssSUFBSXBtQixJQUFJMGxDLE1BQU1NLFFBQVEsR0FBRy9oQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDdEQsSUFBSTBlLE9BQU83aUMsRUFBRXNnQixJQUFJO1FBQ2pCLElBQUksQ0FBQ3VpQixLQUFLNEIsU0FBUyxJQUFJO1lBQ3JCLElBQUkybEMsV0FBVyxJQUFJdG1DO1lBQ25Cc21DLFNBQVM3dUUsTUFBTSxDQUFDc25DO1lBQ2hCb25DLGFBQWFwbEUsR0FBRyxDQUFDdWxFO1FBQ25CO0lBQ0Y7SUFDQW55QixZQUFZeHBCLElBQUksQ0FBQ3c3QyxjQUFjaHlCLFlBQVlDLFlBQVk7SUFDdkQsT0FBTyt4QjtBQUNUO0FBQ0FiLGNBQWN4d0UsU0FBUyxDQUFDMnhFLHlCQUF5QixHQUFHLFNBQVNBO0lBQzNELElBQUlDLFlBQVksSUFBSSxDQUFDcjRDLFNBQVMsQ0FBQzljLGFBQWE7SUFDNUMsT0FBT20xRDtBQUNUO0FBQ0FwQixjQUFjeHdFLFNBQVMsQ0FBQzZ4RSxRQUFRLEdBQUcsU0FBU0EsU0FBVXp4RCxjQUFjO0lBQ2xFLElBQUksSUFBSSxDQUFDc3dELGFBQWEsS0FBSyxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUNBLGFBQWE7SUFBQztJQUM3RCxJQUFJb0IsUUFBUSxJQUFJN2Y7SUFDaEIsSUFBSXJILEtBQUssSUFBSTFwQztJQUNiMHBDLEdBQUd6cUMsaUJBQWlCLENBQUNDO0lBQ3JCMHhELE1BQU05ZixxQkFBcUIsQ0FBQyxJQUFJNmEsa0JBQWtCamlCO0lBQ2xELE9BQU9rbkI7QUFDVDtBQUNBdEIsY0FBY3h3RSxTQUFTLENBQUMreEUsTUFBTSxHQUFHLFNBQVNBLE9BQVFsb0QsQ0FBQyxFQUFFdGtCLFFBQVE7SUFDM0QsSUFBSTZhLGlCQUFpQixJQUFJLENBQUNxd0Qsc0JBQXNCO0lBQ2hELElBQUlyd0QsbUJBQW1CLE1BQU07UUFBRUEsaUJBQWlCeUosRUFBRWtCLGlCQUFpQjtJQUFJO0lBQ3ZFLElBQUksQ0FBQ3dPLFNBQVMsR0FBRzFQLEVBQUVMLFVBQVU7SUFDN0IsSUFBSWc4QyxlQUFlLElBQUk3RixtQkFBbUJ2L0MsZ0JBQWdCLElBQUksQ0FBQzY2QyxVQUFVO0lBQ3pFLElBQUkrVyxrQkFBa0IsSUFBSTdNLHNCQUFzQnQ3QyxHQUFHdGtCLFVBQVVpZ0U7SUFDN0QsSUFBSXlNLG1CQUFtQkQsZ0JBQWdCeEwsU0FBUztJQUNoRCxJQUFJeUwsaUJBQWlCdCtELElBQUksTUFBTSxHQUFHO1FBQ2hDLE9BQU8sSUFBSSxDQUFDZytELHlCQUF5QjtJQUN2QztJQUNBLElBQUksQ0FBQ08saUJBQWlCLENBQUNELGtCQUFrQjd4RDtJQUN6QyxJQUFJLENBQUN1d0QsTUFBTSxHQUFHLElBQUl6MkIsWUFBWSxJQUFJbXhCO0lBQ2xDLElBQUksQ0FBQ3NGLE1BQU0sQ0FBQ3AxQixRQUFRLENBQUMsSUFBSSxDQUFDcXNCLFNBQVMsQ0FBQ3g5QixRQUFRO0lBQzVDLElBQUlpbkMsZUFBZSxJQUFJLENBQUNLLGVBQWUsQ0FBQyxJQUFJLENBQUNmLE1BQU07SUFDbkQsSUFBSVcsY0FBYyxJQUFJMTFCLGVBQWUsSUFBSSxDQUFDcmlCLFNBQVM7SUFDbkQsSUFBSSxDQUFDNjNDLGNBQWMsQ0FBQ0MsY0FBY0M7SUFDbEMsSUFBSW4xQixpQkFBaUJtMUIsWUFBWTEwQixXQUFXO0lBQzVDLElBQUlULGVBQWV4b0MsSUFBSSxNQUFNLEdBQUc7UUFDOUIsT0FBTyxJQUFJLENBQUNnK0QseUJBQXlCO0lBQ3ZDO0lBQ0EsSUFBSVEsYUFBYSxJQUFJLENBQUM1NEMsU0FBUyxDQUFDMEwsYUFBYSxDQUFDa1g7SUFDOUMsT0FBT2cyQjtBQUNUO0FBQ0EzQixjQUFjeHdFLFNBQVMsQ0FBQ2t5RSxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJELGdCQUFnQixFQUFFN3hELGNBQWM7SUFDcEcsSUFBSTlGLFNBQVMsSUFBSTtJQUVuQixJQUFJdzNELFFBQVEsSUFBSSxDQUFDRCxRQUFRLENBQUN6eEQ7SUFDMUIweEQsTUFBTWxnQixZQUFZLENBQUNxZ0I7SUFDbkIsSUFBSUcsa0JBQWtCTixNQUFNM21CLGtCQUFrQjtJQUM5QyxJQUFLLElBQUkvakQsSUFBSWdyRSxnQkFBZ0IvbUQsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQ3JELElBQUlxbkMsU0FBU3hyRCxFQUFFc2dCLElBQUk7UUFDbkIsSUFBSVQsTUFBTTJyQyxPQUFPbDdCLGNBQWM7UUFDL0IsSUFBSXpRLElBQUl4bUIsTUFBTSxLQUFLLEtBQUt3bUIsR0FBRyxDQUFDLEVBQUUsQ0FBQzFpQixRQUFRLENBQUMwaUIsR0FBRyxDQUFDLEVBQUUsR0FBRztZQUFFO1FBQVM7UUFDNUQsSUFBSW9yRCxXQUFXemYsT0FBT3hKLE9BQU87UUFDN0IsSUFBSTVYLE9BQU8sSUFBSTA4QixLQUFLdGIsT0FBT2w3QixjQUFjLElBQUksSUFBSW9YLE1BQU11akM7UUFDdkQvM0QsT0FBT3UyRCxnQkFBZ0IsQ0FBQ3IvQjtJQUMxQjtBQUNGO0FBQ0FnL0IsY0FBY3h3RSxTQUFTLENBQUNzeUUsUUFBUSxHQUFHLFNBQVNBLFNBQVVSLEtBQUs7SUFDekQsSUFBSSxDQUFDcEIsYUFBYSxHQUFHb0I7QUFDdkI7QUFDQXRCLGNBQWN4d0UsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sRUFBRTtBQUNYO0FBQ0EydUUsY0FBY3h3RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDMUMsT0FBTzB1RTtBQUNUO0FBQ0FBLGNBQWNwM0IsVUFBVSxHQUFHLFNBQVNBLFdBQVlySixLQUFLO0lBQ25ELElBQUl3aUMsT0FBT3hpQyxNQUFNMXFCLFdBQVcsQ0FBQyxHQUFHaWpCLFNBQVNyaUIsSUFBSTtJQUM3QyxJQUFJdXNELE9BQU96aUMsTUFBTTFxQixXQUFXLENBQUMsR0FBR2lqQixTQUFTdmlCLEtBQUs7SUFDOUMsSUFBSXdzRCxTQUFTNXJFLFNBQVNFLFFBQVEsSUFBSTJyRSxTQUFTN3JFLFNBQVNJLFFBQVEsRUFBRTtRQUFFLE9BQU87SUFBRyxPQUFPLElBQUl3ckUsU0FBUzVyRSxTQUFTSSxRQUFRLElBQUl5ckUsU0FBUzdyRSxTQUFTRSxRQUFRLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUMzSixPQUFPO0FBQ1Q7QUFDQTJwRSxjQUFjaUMsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CLzNDLEVBQUU7SUFDOUQsSUFBSStDLE9BQU8sSUFBSS9rQjtJQUNmLElBQUk2RCxRQUFRLElBQUlpUjtJQUNoQixNQUFPa04sR0FBR25QLE9BQU8sR0FBSTtRQUNuQixJQUFJaWdDLEtBQUs5d0IsR0FBR2hULElBQUk7UUFDaEIsSUFBSXBMLE9BQU9taEIsS0FBS3RoQixnQkFBZ0IsQ0FBQ3F2QyxHQUFHOXpCLGNBQWM7UUFDbERuYixNQUFNdFEsR0FBRyxDQUFDcVE7SUFDWjtJQUNBLE9BQU9taEIsS0FBS3dILGFBQWEsQ0FBQzFvQjtBQUM1QjtBQUVBLElBQUltMkQsY0FBYyxTQUFTQTtJQUN6QixJQUFJLENBQUNDLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUlqeUUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSXF4RSxRQUFRaHhFLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUlreUUsY0FBY2x5RSxTQUFTLENBQUMsRUFBRTtRQUM5QixJQUFJLENBQUM2eEUsTUFBTSxHQUFHYjtRQUNkLElBQUksQ0FBQ2MsWUFBWSxHQUFHSTtRQUNwQixJQUFJLENBQUNILFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQ0Usa0JBQWtCO0lBQzNDLE9BQU8sSUFBSW55RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJeXlFLFVBQVVweUUsU0FBUyxDQUFDLEVBQUU7UUFDMUIsSUFBSXF5RSxnQkFBZ0JyeUUsU0FBUyxDQUFDLEVBQUU7UUFDaEMsSUFBSXN5RSxVQUFVdHlFLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLElBQUl1eUUsVUFBVXZ5RSxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJLENBQUM2eEUsTUFBTSxHQUFHTztRQUNkLElBQUksQ0FBQ04sWUFBWSxHQUFHTztRQUNwQixJQUFJLENBQUNOLFFBQVEsR0FBR087UUFDaEIsSUFBSSxDQUFDTixRQUFRLEdBQUdPO1FBQ2hCLElBQUksQ0FBQ04sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDRSxrQkFBa0I7SUFDM0M7QUFDRjtBQUNBUCxZQUFZMXlFLFNBQVMsQ0FBQ3N6RSxPQUFPLEdBQUcsU0FBU0E7SUFDckMsSUFBSWg1RCxTQUFTLElBQUk7SUFFbkIsSUFBSW5ULGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFZ3NCLGFBQWE7UUFDMUMsSUFBSXMrQixhQUFhdHFELFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUssSUFBSXNHLElBQUlna0QsV0FBVy8vQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDaEQsSUFBSWlnQyxLQUFLcGtELEVBQUVzZ0IsSUFBSTtZQUNmcE4sT0FBT2c1RCxPQUFPLENBQUM5bkIsR0FBRzl6QixjQUFjO1FBQ2xDO0lBQ0YsT0FBTyxJQUFJNTJCLFNBQVMsQ0FBQyxFQUFFLFlBQVlmLE9BQU87UUFDeEMsSUFBSWtuQixNQUFNbm1CLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLGdCQUFnQjtRQUNoQixnQkFBZ0I7UUFDaEIsMEJBQTBCO1FBQzFCLDhCQUE4QjtRQUM5Qiw4QkFBOEI7UUFDOUIsSUFBSTtRQUNKLElBQUssSUFBSThrQixNQUFNLEdBQUdBLE1BQU1xQixJQUFJeG1CLE1BQU0sRUFBRW1sQixNQUFPO1lBQ3pDcUIsR0FBRyxDQUFDckIsSUFBSSxDQUFDbGtCLENBQUMsR0FBR3VsQixHQUFHLENBQUNyQixJQUFJLENBQUNsa0IsQ0FBQyxHQUFHNFksT0FBT3M0RCxZQUFZLEdBQUd0NEQsT0FBT3U0RCxRQUFRO1lBQy9ENXJELEdBQUcsQ0FBQ3JCLElBQUksQ0FBQ2ppQixDQUFDLEdBQUdzakIsR0FBRyxDQUFDckIsSUFBSSxDQUFDamlCLENBQUMsR0FBRzJXLE9BQU9zNEQsWUFBWSxHQUFHdDRELE9BQU93NEQsUUFBUTtRQUNqRTtRQUNBLElBQUk3ckQsSUFBSXhtQixNQUFNLEtBQUssS0FBS3dtQixHQUFHLENBQUMsRUFBRSxDQUFDMWlCLFFBQVEsQ0FBQzBpQixHQUFHLENBQUMsRUFBRSxHQUFHO1lBQy9DMVMsT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDc0U7UUFDckI7SUFDRjtBQUNGO0FBQ0F5ckQsWUFBWTF5RSxTQUFTLENBQUM4SyxLQUFLLEdBQUcsU0FBU0E7SUFDbkMsSUFBSXdQLFNBQVMsSUFBSTtJQUVuQixJQUFJblQsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVnc0IsYUFBYTtRQUMxQyxJQUFJcytCLGFBQWF0cUQsU0FBUyxDQUFDLEVBQUU7UUFDN0IsSUFBSXl5RSxzQkFBc0IsSUFBSS9sRDtRQUM5QixJQUFLLElBQUlwbUIsSUFBSWdrRCxXQUFXLy9CLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUNoRCxJQUFJaWdDLEtBQUtwa0QsRUFBRXNnQixJQUFJO1lBQ2Y2ckQsb0JBQW9CdG5FLEdBQUcsQ0FBQyxJQUFJazlDLG1CQUFtQjd1QyxPQUFPeFAsS0FBSyxDQUFDMGdELEdBQUc5ekIsY0FBYyxLQUFLOHpCLEdBQUdwQyxPQUFPO1FBQzlGO1FBQ0EsT0FBT21xQjtJQUNULE9BQU8sSUFBSXp5RSxTQUFTLENBQUMsRUFBRSxZQUFZZixPQUFPO1FBQ3hDLElBQUlrbkIsTUFBTW5tQixTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJMHlFLFdBQVcsSUFBSXp6RSxNQUFNa25CLElBQUl4bUIsTUFBTSxFQUFFSixJQUFJLENBQUM7UUFDMUMsSUFBSyxJQUFJdWxCLE1BQU0sR0FBR0EsTUFBTXFCLElBQUl4bUIsTUFBTSxFQUFFbWxCLE1BQU87WUFDekM0dEQsUUFBUSxDQUFDNXRELElBQUksR0FBRyxJQUFJbGlCLFdBQVdoRCxLQUFLNGpDLEtBQUssQ0FBQyxDQUFDcmQsR0FBRyxDQUFDckIsSUFBSSxDQUFDbGtCLENBQUMsR0FBRzRZLE9BQU91NEQsUUFBUSxJQUFJdjRELE9BQU9zNEQsWUFBWSxHQUFHbHlFLEtBQUs0akMsS0FBSyxDQUFDLENBQUNyZCxHQUFHLENBQUNyQixJQUFJLENBQUNqaUIsQ0FBQyxHQUFHMlcsT0FBT3c0RCxRQUFRLElBQUl4NEQsT0FBT3M0RCxZQUFZLEdBQUczckQsR0FBRyxDQUFDckIsSUFBSSxDQUFDaGlCLENBQUM7UUFDL0s7UUFDQSxJQUFJNnZFLGdCQUFnQjFqRCxpQkFBaUJtQixvQkFBb0IsQ0FBQ3NpRDtRQUMxRCxPQUFPQztJQUNUO0FBQ0Y7QUFDQWYsWUFBWTF5RSxTQUFTLENBQUNpekUsa0JBQWtCLEdBQUcsU0FBU0E7SUFDbEQsT0FBTyxJQUFJLENBQUNMLFlBQVksS0FBSztBQUMvQjtBQUNBRixZQUFZMXlFLFNBQVMsQ0FBQ21yRCxrQkFBa0IsR0FBRyxTQUFTQTtJQUNsRCxJQUFJdW9CLFVBQVUsSUFBSSxDQUFDZixNQUFNLENBQUN4bkIsa0JBQWtCO0lBQzVDLElBQUksSUFBSSxDQUFDNG5CLFNBQVMsRUFBRTtRQUFFLElBQUksQ0FBQ08sT0FBTyxDQUFDSTtJQUFVO0lBQzdDLE9BQU9BO0FBQ1Q7QUFDQWhCLFlBQVkxeUUsU0FBUyxDQUFDNHhELFlBQVksR0FBRyxTQUFTQSxhQUFja0IsZUFBZTtJQUN6RSxJQUFJNmdCLGdCQUFnQjdnQjtJQUNwQixJQUFJLElBQUksQ0FBQ2lnQixTQUFTLEVBQUU7UUFBRVksZ0JBQWdCLElBQUksQ0FBQzdvRSxLQUFLLENBQUNnb0Q7SUFBa0I7SUFDbkUsSUFBSSxDQUFDNmYsTUFBTSxDQUFDL2dCLFlBQVksQ0FBQytoQjtBQUMzQjtBQUNBakIsWUFBWTF5RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDM0MsT0FBTztRQUFDOHZEO0tBQU07QUFDaEI7QUFDQStnQixZQUFZMXlFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN4QyxPQUFPNHdFO0FBQ1Q7QUFFQSxJQUFJa0Isa0JBQWtCLFNBQVNBO0lBQzdCLElBQUksQ0FBQzFZLEdBQUcsR0FBRyxJQUFJaDZDO0lBQ2YsSUFBSSxDQUFDMnlELFdBQVcsR0FBRztJQUNuQixJQUFJem9CLGFBQWF0cUQsU0FBUyxDQUFDLEVBQUU7SUFDN0IsSUFBSSxDQUFDK3lFLFdBQVcsR0FBR3pvQjtBQUNyQjtBQUVBLElBQUkwb0IscUJBQXFCO0lBQUVyMkMsTUFBTTtRQUFFdDlCLGNBQWM7SUFBSztBQUFFO0FBQ3hEeXpFLGdCQUFnQjV6RSxTQUFTLENBQUMrekUsNkJBQTZCLEdBQUcsU0FBU0E7SUFDL0QsSUFBSXo1RCxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUssSUFBSTJHLElBQUksSUFBSSxDQUFDeXNFLFdBQVcsQ0FBQ3hvRCxRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDdEQsSUFBSWlnQyxLQUFLcGtELEVBQUVzZ0IsSUFBSTtZQUNmLElBQUlULE1BQU11a0MsR0FBRzl6QixjQUFjO1lBQzNCcGQsT0FBT3k1RCw2QkFBNkIsQ0FBQzlzRCxHQUFHLENBQUMsRUFBRSxFQUFFM00sT0FBT3U1RCxXQUFXO1lBQy9EdjVELE9BQU95NUQsNkJBQTZCLENBQUM5c0QsR0FBRyxDQUFDQSxJQUFJeG1CLE1BQU0sR0FBRyxFQUFFLEVBQUU2WixPQUFPdTVELFdBQVc7UUFDOUU7SUFDRixPQUFPLElBQUkveUUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTZ2QixTQUFTeHZCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlzcUQsYUFBYXRxRCxTQUFTLENBQUMsRUFBRTtRQUM3QixJQUFLLElBQUk4a0IsTUFBTXdsQyxXQUFXLy9CLFFBQVEsSUFBSXpGLElBQUkyRixPQUFPLElBQUs7WUFDcEQsSUFBSXlvRCxPQUFPcHVELElBQUk4QixJQUFJO1lBQ25CLElBQUk4cEMsUUFBUXdpQixLQUFLdDhDLGNBQWM7WUFDL0IsSUFBSyxJQUFJcE0sSUFBSSxHQUFHQSxJQUFJa21DLE1BQU0vd0QsTUFBTSxHQUFHLEdBQUc2cUIsSUFBSztnQkFDekMsSUFBSWttQyxLQUFLLENBQUNsbUMsRUFBRSxDQUFDM21CLE1BQU0sQ0FBQzJyQixTQUFTO29CQUFFLE1BQU0sSUFBSS9TLGlCQUFpQixtREFBbUQrTixJQUFJLFVBQVVnRjtnQkFBUTtZQUNySTtRQUNGO0lBQ0Y7QUFDRjtBQUNBc2pELGdCQUFnQjV6RSxTQUFTLENBQUNpMEUsMEJBQTBCLEdBQUcsU0FBU0E7SUFDNUQsSUFBSTM1RCxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUssSUFBSTJHLElBQUksSUFBSSxDQUFDeXNFLFdBQVcsQ0FBQ3hvRCxRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDdEQsSUFBSTJvRCxNQUFNOXNFLEVBQUVzZ0IsSUFBSTtZQUNoQixJQUFLLElBQUk0RCxJQUFJLElBQUksQ0FBQ3VvRCxXQUFXLENBQUN4b0QsUUFBUSxJQUFJQyxFQUFFQyxPQUFPLElBQUs7Z0JBQ3RELElBQUkrbkMsTUFBTWhvQyxFQUFFNUQsSUFBSTtnQkFDaEJwTixPQUFPMjVELDBCQUEwQixDQUFDQyxLQUFLNWdCO1lBQ3pDO1FBQ0Y7SUFDRixPQUFPLElBQUl4eUQsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTB6RSxRQUFRcnpFLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUlzekUsUUFBUXR6RSxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJdXpFLE9BQU9GLE1BQU16OEMsY0FBYztRQUMvQixJQUFJN0YsT0FBT3VpRCxNQUFNMThDLGNBQWM7UUFDL0IsSUFBSyxJQUFJby9CLEtBQUssR0FBR0EsS0FBS3VkLEtBQUs1ekUsTUFBTSxHQUFHLEdBQUdxMkQsS0FBTTtZQUMzQyxJQUFLLElBQUlqa0MsS0FBSyxHQUFHQSxLQUFLaEIsS0FBS3B4QixNQUFNLEdBQUcsR0FBR295QixLQUFNO2dCQUMzQ3ZZLE9BQU8yNUQsMEJBQTBCLENBQUNFLE9BQU9yZCxJQUFJc2QsT0FBT3ZoRDtZQUN0RDtRQUNGO0lBQ0YsT0FBTyxJQUFJL3hCLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlnc0UsS0FBSzNyRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJNHJFLFlBQVk1ckUsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSTZyRSxLQUFLN3JFLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUk4ckUsWUFBWTlyRSxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFJMnJFLE9BQU9FLE1BQU1ELGNBQWNFLFdBQVc7WUFBRSxPQUFPO1FBQUs7UUFDeEQsSUFBSWxjLE1BQU0rYixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFVBQVU7UUFDeEMsSUFBSS9iLE1BQU04YixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFlBQVksRUFBRTtRQUM1QyxJQUFJOWIsTUFBTStiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsVUFBVTtRQUN4QyxJQUFJL2IsTUFBTThiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsWUFBWSxFQUFFO1FBQzVDLElBQUksQ0FBQzFSLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQ2l4QyxLQUFLQyxLQUFLQyxLQUFLQztRQUM1QyxJQUFJLElBQUksQ0FBQ3FLLEdBQUcsQ0FBQ2g3QyxlQUFlLElBQUk7WUFDOUIsSUFBSSxJQUFJLENBQUNnN0MsR0FBRyxDQUFDajdDLFFBQVEsTUFBTSxJQUFJLENBQUM2dEQsdUJBQXVCLENBQUMsSUFBSSxDQUFDNVMsR0FBRyxFQUFFeEssS0FBS0MsUUFBUSxJQUFJLENBQUNtZCx1QkFBdUIsQ0FBQyxJQUFJLENBQUM1UyxHQUFHLEVBQUV0SyxLQUFLQyxNQUFNO2dCQUMvSCxNQUFNLElBQUl0ekMsaUJBQWlCLHFDQUFxQ216QyxNQUFNLE1BQU1DLE1BQU0sVUFBVUMsTUFBTSxNQUFNQztZQUMxRztRQUNGO0lBQ0Y7QUFDRjtBQUNBK2lCLGdCQUFnQjV6RSxTQUFTLENBQUNzMEUsVUFBVSxHQUFHLFNBQVNBO0lBQzlDLElBQUksQ0FBQ1AsNkJBQTZCO0lBQ2xDLElBQUksQ0FBQ0UsMEJBQTBCO0lBQy9CLElBQUksQ0FBQ00sY0FBYztBQUNyQjtBQUNBWCxnQkFBZ0I1ekUsU0FBUyxDQUFDdTBFLGNBQWMsR0FBRyxTQUFTQTtJQUNoRCxJQUFJajZELFNBQVMsSUFBSTtJQUVuQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSyxJQUFJMkcsSUFBSSxJQUFJLENBQUN5c0UsV0FBVyxDQUFDeG9ELFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUN0RCxJQUFJaWdDLEtBQUtwa0QsRUFBRXNnQixJQUFJO1lBQ2ZwTixPQUFPaTZELGNBQWMsQ0FBQy9vQjtRQUN4QjtJQUNGLE9BQU8sSUFBSTFxRCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJdXpFLE9BQU9sekUsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSW1tQixNQUFNK3NELEtBQUt0OEMsY0FBYztRQUM3QixJQUFLLElBQUk5UixNQUFNLEdBQUdBLE1BQU1xQixJQUFJeG1CLE1BQU0sR0FBRyxHQUFHbWxCLE1BQU87WUFDN0N0TCxPQUFPazZELGFBQWEsQ0FBQ3Z0RCxHQUFHLENBQUNyQixJQUFJLEVBQUVxQixHQUFHLENBQUNyQixNQUFNLEVBQUUsRUFBRXFCLEdBQUcsQ0FBQ3JCLE1BQU0sRUFBRTtRQUMzRDtJQUNGO0FBQ0Y7QUFDQWd1RCxnQkFBZ0I1ekUsU0FBUyxDQUFDOHRFLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QmxqQixFQUFFLEVBQUV0dEMsRUFBRSxFQUFFL0wsRUFBRTtJQUM5RixJQUFLLElBQUluSyxJQUFJLEdBQUdBLElBQUl3akQsR0FBRy9xQyxrQkFBa0IsSUFBSXpZLElBQUs7UUFDaEQsSUFBSWlhLFFBQVF1cEMsR0FBR3JxQyxlQUFlLENBQUNuWjtRQUMvQixJQUFJLENBQUVpYSxDQUFBQSxNQUFNMWMsTUFBTSxDQUFDMlksT0FBTytELE1BQU0xYyxNQUFNLENBQUM0TSxHQUFFLEdBQUk7WUFBRSxPQUFPO1FBQUs7SUFDN0Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQXFpRSxnQkFBZ0I1ekUsU0FBUyxDQUFDdzBFLGFBQWEsR0FBRyxTQUFTQSxjQUFlbDNELEVBQUUsRUFBRS9MLEVBQUUsRUFBRUMsRUFBRTtJQUMxRSxJQUFJOEwsR0FBRzNZLE1BQU0sQ0FBQzZNLEtBQUs7UUFBRSxNQUFNLElBQUkrTCxpQkFBaUIsaUNBQWlDcTJELGdCQUFnQm4yQyxJQUFJLENBQUN0aEIsZ0JBQWdCLENBQUM7WUFBQ21CO1lBQUkvTDtZQUFJQztTQUFHO0lBQUc7QUFDeEk7QUFDQW9pRSxnQkFBZ0I1ekUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQy9DLE9BQU8sRUFBRTtBQUNYO0FBQ0EreEUsZ0JBQWdCNXpFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM1QyxPQUFPOHhFO0FBQ1Q7QUFDQUUsbUJBQW1CcjJDLElBQUksQ0FBQ3I2QixHQUFHLEdBQUc7SUFBYyxPQUFPLElBQUlzVjtBQUFrQjtBQUV6RXpZLE9BQU9vRCxnQkFBZ0IsQ0FBRXV3RSxpQkFBaUJFO0FBRTFDLElBQUlXLFdBQVcsU0FBU0E7SUFDdEIsSUFBSSxDQUFDdlosR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDd1osR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDbEMsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3o4RCxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUN5K0QsT0FBTyxHQUFHLElBQUloMUUsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDakMsSUFBSSxDQUFDMjBFLFFBQVEsR0FBRztJQUNoQixJQUFJbjBELEtBQUsvZixTQUFTLENBQUMsRUFBRTtJQUNyQixJQUFJa3lFLGNBQWNseUUsU0FBUyxDQUFDLEVBQUU7SUFDOUIsSUFBSThwRCxLQUFLOXBELFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQzZ6RSxXQUFXLEdBQUc5ekQ7SUFDbkIsSUFBSSxDQUFDNnpELEdBQUcsR0FBRzd6RDtJQUNYLElBQUksQ0FBQyt4RCxZQUFZLEdBQUdJO0lBQ3BCLElBQUksQ0FBQzlYLEdBQUcsR0FBR3RRO0lBQ1gsSUFBSW9vQixlQUFlLEdBQUc7UUFBRSxNQUFNLElBQUk1d0UseUJBQXlCO0lBQWlDO0lBQzVGLElBQUk0d0UsZ0JBQWdCLEtBQUs7UUFDdkIsSUFBSSxDQUFDMEIsR0FBRyxHQUFHLElBQUloeEUsV0FBVyxJQUFJLENBQUNvSCxLQUFLLENBQUMrVixHQUFHbmYsQ0FBQyxHQUFHLElBQUksQ0FBQ29KLEtBQUssQ0FBQytWLEdBQUdsZCxDQUFDO1FBQzNELElBQUksQ0FBQ2t4RSxTQUFTLEdBQUcsSUFBSW54RTtRQUNyQixJQUFJLENBQUNveEUsU0FBUyxHQUFHLElBQUlweEU7SUFDdkI7SUFDQSxJQUFJLENBQUN1eEUsV0FBVyxDQUFDLElBQUksQ0FBQ1AsR0FBRztBQUMzQjtBQUVBLElBQUlRLHFCQUFxQjtJQUFFQywyQkFBMkI7UUFBRWgxRSxjQUFjO0lBQUs7QUFBRTtBQUM3RXMwRSxTQUFTejBFLFNBQVMsQ0FBQ28xRSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0I5M0QsRUFBRSxFQUFFL0wsRUFBRTtJQUNyRSxJQUFJOGpFLFVBQVUzMEUsS0FBS0UsR0FBRyxDQUFDMGMsR0FBRzViLENBQUMsRUFBRTZQLEdBQUc3UCxDQUFDO0lBQ2pDLElBQUk0ekUsVUFBVTUwRSxLQUFLQyxHQUFHLENBQUMyYyxHQUFHNWIsQ0FBQyxFQUFFNlAsR0FBRzdQLENBQUM7SUFDakMsSUFBSTZ6RSxVQUFVNzBFLEtBQUtFLEdBQUcsQ0FBQzBjLEdBQUczWixDQUFDLEVBQUU0TixHQUFHNU4sQ0FBQztJQUNqQyxJQUFJNnhFLFVBQVU5MEUsS0FBS0MsR0FBRyxDQUFDMmMsR0FBRzNaLENBQUMsRUFBRTROLEdBQUc1TixDQUFDO0lBQ2pDLElBQUk4eEUsb0JBQW9CLElBQUksQ0FBQ3IvRCxLQUFLLEdBQUdpL0QsV0FBVyxJQUFJLENBQUNsL0QsS0FBSyxHQUFHbS9ELFdBQVcsSUFBSSxDQUFDaC9ELEtBQUssR0FBR2kvRCxXQUFXLElBQUksQ0FBQ2wvRCxLQUFLLEdBQUdtL0Q7SUFDN0csSUFBSUMsbUJBQW1CO1FBQUUsT0FBTztJQUFNO0lBQ3RDLElBQUl4K0QsYUFBYSxJQUFJLENBQUN5K0QseUJBQXlCLENBQUNwNEQsSUFBSS9MO0lBQ3BEbU0sT0FBT0UsTUFBTSxDQUFDLENBQUU2M0QsQ0FBQUEscUJBQXFCeCtELFVBQVMsR0FBSTtJQUNsRCxPQUFPQTtBQUNUO0FBQ0F3OUQsU0FBU3owRSxTQUFTLENBQUNpMUUsV0FBVyxHQUFHLFNBQVNBLFlBQWFwMEQsRUFBRTtJQUN2RCxJQUFJM2UsWUFBWTtJQUNoQixJQUFJLENBQUNpVSxLQUFLLEdBQUcwSyxHQUFHbmYsQ0FBQyxHQUFHUTtJQUNwQixJQUFJLENBQUNrVSxLQUFLLEdBQUd5SyxHQUFHbmYsQ0FBQyxHQUFHUTtJQUNwQixJQUFJLENBQUNtVSxLQUFLLEdBQUd3SyxHQUFHbGQsQ0FBQyxHQUFHekI7SUFDcEIsSUFBSSxDQUFDb1UsS0FBSyxHQUFHdUssR0FBR2xkLENBQUMsR0FBR3pCO0lBQ3BCLElBQUksQ0FBQzZ5RSxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUlyeEUsV0FBVyxJQUFJLENBQUMwUyxLQUFLLEVBQUUsSUFBSSxDQUFDRSxLQUFLO0lBQ3ZELElBQUksQ0FBQ3krRCxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUlyeEUsV0FBVyxJQUFJLENBQUN5UyxLQUFLLEVBQUUsSUFBSSxDQUFDRyxLQUFLO0lBQ3ZELElBQUksQ0FBQ3krRCxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUlyeEUsV0FBVyxJQUFJLENBQUN5UyxLQUFLLEVBQUUsSUFBSSxDQUFDRSxLQUFLO0lBQ3ZELElBQUksQ0FBQzArRCxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUlyeEUsV0FBVyxJQUFJLENBQUMwUyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxLQUFLO0FBQ3pEO0FBQ0FvK0QsU0FBU3owRSxTQUFTLENBQUNpWCxVQUFVLEdBQUcsU0FBU0EsV0FBWXFHLEVBQUUsRUFBRS9MLEVBQUU7SUFDekQsSUFBSSxJQUFJLENBQUNxaEUsWUFBWSxLQUFLLEtBQUs7UUFBRSxPQUFPLElBQUksQ0FBQ3dDLGdCQUFnQixDQUFDOTNELElBQUkvTDtJQUFJO0lBQ3RFLElBQUksQ0FBQ29rRSxVQUFVLENBQUNyNEQsSUFBSSxJQUFJLENBQUN1M0QsU0FBUztJQUNsQyxJQUFJLENBQUNjLFVBQVUsQ0FBQ3BrRSxJQUFJLElBQUksQ0FBQ3VqRSxTQUFTO0lBQ2xDLE9BQU8sSUFBSSxDQUFDTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNQLFNBQVMsRUFBRSxJQUFJLENBQUNDLFNBQVM7QUFDN0Q7QUFDQUwsU0FBU3owRSxTQUFTLENBQUM4SyxLQUFLLEdBQUcsU0FBU0EsTUFBT3pKLEdBQUc7SUFDNUMsT0FBT1gsS0FBSzRqQyxLQUFLLENBQUNqakMsTUFBTSxJQUFJLENBQUN1eEUsWUFBWTtBQUMzQztBQUNBNkIsU0FBU3owRSxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0E7SUFDMUMsT0FBTyxJQUFJLENBQUMrZ0UsV0FBVztBQUN6QjtBQUNBRixTQUFTejBFLFNBQVMsQ0FBQzIxRSxVQUFVLEdBQUcsU0FBU0EsV0FBWTNnRSxDQUFDLEVBQUU0Z0UsT0FBTztJQUM3REEsUUFBUWwwRSxDQUFDLEdBQUcsSUFBSSxDQUFDb0osS0FBSyxDQUFDa0ssRUFBRXRULENBQUM7SUFDMUJrMEUsUUFBUWp5RSxDQUFDLEdBQUcsSUFBSSxDQUFDbUgsS0FBSyxDQUFDa0ssRUFBRXJSLENBQUM7QUFDNUI7QUFDQTh3RSxTQUFTejBFLFNBQVMsQ0FBQzYxRSxlQUFlLEdBQUcsU0FBU0E7SUFDNUMsSUFBSSxJQUFJLENBQUNiLFFBQVEsS0FBSyxNQUFNO1FBQzFCLElBQUljLGdCQUFnQnJCLFNBQVNVLHlCQUF5QixHQUFHLElBQUksQ0FBQ3ZDLFlBQVk7UUFDMUUsSUFBSSxDQUFDb0MsUUFBUSxHQUFHLElBQUk5K0QsU0FBUyxJQUFJLENBQUN5K0QsV0FBVyxDQUFDanpFLENBQUMsR0FBR28wRSxlQUFlLElBQUksQ0FBQ25CLFdBQVcsQ0FBQ2p6RSxDQUFDLEdBQUdvMEUsZUFBZSxJQUFJLENBQUNuQixXQUFXLENBQUNoeEUsQ0FBQyxHQUFHbXlFLGVBQWUsSUFBSSxDQUFDbkIsV0FBVyxDQUFDaHhFLENBQUMsR0FBR215RTtJQUNoSztJQUNBLE9BQU8sSUFBSSxDQUFDZCxRQUFRO0FBQ3RCO0FBQ0FQLFNBQVN6MEUsU0FBUyxDQUFDKzFFLHNCQUFzQixHQUFHLFNBQVNBLHVCQUF3Qno0RCxFQUFFLEVBQUUvTCxFQUFFO0lBQ2pGLElBQUksQ0FBQzJwRCxHQUFHLENBQUN6N0MsbUJBQW1CLENBQUNuQyxJQUFJL0wsSUFBSSxJQUFJLENBQUN3akUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLE9BQU8sQ0FBQyxFQUFFO0lBQ3JFLElBQUksSUFBSSxDQUFDN1osR0FBRyxDQUFDaDdDLGVBQWUsSUFBSTtRQUFFLE9BQU87SUFBSztJQUM5QyxJQUFJLENBQUNnN0MsR0FBRyxDQUFDejdDLG1CQUFtQixDQUFDbkMsSUFBSS9MLElBQUksSUFBSSxDQUFDd2pFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxPQUFPLENBQUMsRUFBRTtJQUNyRSxJQUFJLElBQUksQ0FBQzdaLEdBQUcsQ0FBQ2g3QyxlQUFlLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDOUMsSUFBSSxDQUFDZzdDLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQ25DLElBQUkvTCxJQUFJLElBQUksQ0FBQ3dqRSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsT0FBTyxDQUFDLEVBQUU7SUFDckUsSUFBSSxJQUFJLENBQUM3WixHQUFHLENBQUNoN0MsZUFBZSxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQzlDLElBQUksQ0FBQ2c3QyxHQUFHLENBQUN6N0MsbUJBQW1CLENBQUNuQyxJQUFJL0wsSUFBSSxJQUFJLENBQUN3akUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLE9BQU8sQ0FBQyxFQUFFO0lBQ3JFLElBQUksSUFBSSxDQUFDN1osR0FBRyxDQUFDaDdDLGVBQWUsSUFBSTtRQUFFLE9BQU87SUFBSztJQUM5QyxPQUFPO0FBQ1Q7QUFDQXUwRCxTQUFTejBFLFNBQVMsQ0FBQzAxRSx5QkFBeUIsR0FBRyxTQUFTQSwwQkFBMkJwNEQsRUFBRSxFQUFFL0wsRUFBRTtJQUN2RixJQUFJeWtFLGlCQUFpQjtJQUNyQixJQUFJQyxtQkFBbUI7SUFDdkIsSUFBSSxDQUFDL2EsR0FBRyxDQUFDejdDLG1CQUFtQixDQUFDbkMsSUFBSS9MLElBQUksSUFBSSxDQUFDd2pFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxPQUFPLENBQUMsRUFBRTtJQUNyRSxJQUFJLElBQUksQ0FBQzdaLEdBQUcsQ0FBQ2o3QyxRQUFRLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDdkMsSUFBSSxDQUFDaTdDLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQ25DLElBQUkvTCxJQUFJLElBQUksQ0FBQ3dqRSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsT0FBTyxDQUFDLEVBQUU7SUFDckUsSUFBSSxJQUFJLENBQUM3WixHQUFHLENBQUNqN0MsUUFBUSxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQ3ZDLElBQUksSUFBSSxDQUFDaTdDLEdBQUcsQ0FBQ2g3QyxlQUFlLElBQUk7UUFBRTgxRCxpQkFBaUI7SUFBTTtJQUN6RCxJQUFJLENBQUM5YSxHQUFHLENBQUN6N0MsbUJBQW1CLENBQUNuQyxJQUFJL0wsSUFBSSxJQUFJLENBQUN3akUsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLE9BQU8sQ0FBQyxFQUFFO0lBQ3JFLElBQUksSUFBSSxDQUFDN1osR0FBRyxDQUFDajdDLFFBQVEsSUFBSTtRQUFFLE9BQU87SUFBSztJQUN2QyxJQUFJLElBQUksQ0FBQ2k3QyxHQUFHLENBQUNoN0MsZUFBZSxJQUFJO1FBQUUrMUQsbUJBQW1CO0lBQU07SUFDM0QsSUFBSSxDQUFDL2EsR0FBRyxDQUFDejdDLG1CQUFtQixDQUFDbkMsSUFBSS9MLElBQUksSUFBSSxDQUFDd2pFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxPQUFPLENBQUMsRUFBRTtJQUNyRSxJQUFJLElBQUksQ0FBQzdaLEdBQUcsQ0FBQ2o3QyxRQUFRLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDdkMsSUFBSSsxRCxrQkFBa0JDLGtCQUFrQjtRQUFFLE9BQU87SUFBSztJQUN0RCxJQUFJMzRELEdBQUczWSxNQUFNLENBQUMsSUFBSSxDQUFDK3ZFLEdBQUcsR0FBRztRQUFFLE9BQU87SUFBSztJQUN2QyxJQUFJbmpFLEdBQUc1TSxNQUFNLENBQUMsSUFBSSxDQUFDK3ZFLEdBQUcsR0FBRztRQUFFLE9BQU87SUFBSztJQUN2QyxPQUFPO0FBQ1Q7QUFDQUQsU0FBU3owRSxTQUFTLENBQUNrMkUsY0FBYyxHQUFHLFNBQVNBLGVBQWdCdGpCLE1BQU0sRUFBRXVqQixRQUFRO0lBQzNFLElBQUk3NEQsS0FBS3MxQyxPQUFPaC9DLGFBQWEsQ0FBQ3VpRTtJQUM5QixJQUFJNWtFLEtBQUtxaEQsT0FBT2gvQyxhQUFhLENBQUN1aUUsV0FBVztJQUN6QyxJQUFJLElBQUksQ0FBQ2wvRCxVQUFVLENBQUNxRyxJQUFJL0wsS0FBSztRQUMzQnFoRCxPQUFPdEksZUFBZSxDQUFDLElBQUksQ0FBQzEyQyxhQUFhLElBQUl1aUU7UUFDN0MsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0ExQixTQUFTejBFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4QyxPQUFPLEVBQUU7QUFDWDtBQUNBNHlFLFNBQVN6MEUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JDLE9BQU8yeUU7QUFDVDtBQUNBUyxtQkFBbUJDLHlCQUF5QixDQUFDL3hFLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBSztBQUU3RW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRW94RSxVQUFVUztBQUVuQyxJQUFJa0IsNEJBQTRCLFNBQVNBO0lBQ3ZDLElBQUksQ0FBQzFuQixRQUFRLEdBQUcsSUFBSXg0QztJQUNwQixJQUFJLENBQUNtZ0UsZUFBZSxHQUFHLElBQUk1cUI7QUFDN0I7QUFDQTJxQiwwQkFBMEJwMkUsU0FBUyxDQUFDOHZELE1BQU0sR0FBRyxTQUFTQTtJQUNwRCxJQUFJaHZELFVBQVVMLE1BQU0sS0FBSyxHQUFHO0lBQzFCLDJCQUEyQjtJQUM3QixPQUFPLElBQUlLLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUl1dkQsS0FBS2x2RCxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJNHdDLGFBQWE1d0MsU0FBUyxDQUFDLEVBQUU7UUFDN0JrdkQsR0FBR2IsY0FBYyxDQUFDemQsWUFBWSxJQUFJLENBQUMya0MsZUFBZTtRQUNsRCxJQUFJLENBQUN2bUIsTUFBTSxDQUFDLElBQUksQ0FBQ3VtQixlQUFlO0lBQ2xDO0FBQ0Y7QUFDQUQsMEJBQTBCcDJFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN6RCxPQUFPLEVBQUU7QUFDWDtBQUNBdTBFLDBCQUEwQnAyRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdEQsT0FBT3MwRTtBQUNUO0FBRUEsSUFBSUUsc0JBQXNCLFNBQVNBO0lBQ2pDLElBQUksQ0FBQ2prQixNQUFNLEdBQUc7SUFDZCxJQUFJaHFELFFBQVF2SCxTQUFTLENBQUMsRUFBRTtJQUN4QixJQUFJLENBQUN1eEQsTUFBTSxHQUFHaHFEO0FBQ2hCO0FBRUEsSUFBSWt1RSxxQkFBcUI7SUFBRUMsb0JBQW9CO1FBQUVyMkUsY0FBYztJQUFLO0FBQUU7QUFDdEVtMkUsb0JBQW9CdDJFLFNBQVMsQ0FBQ3kyRSxJQUFJLEdBQUcsU0FBU0E7SUFDNUMsSUFBSTMxRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJaTJFLFdBQVc1MUUsU0FBUyxDQUFDLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUMyMUUsSUFBSSxDQUFDQyxVQUFVLE1BQU0sQ0FBQztJQUNwQyxPQUFPLElBQUk1MUUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWsyRSxhQUFhNzFFLFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUk4MUUsYUFBYTkxRSxTQUFTLENBQUMsRUFBRTtRQUM3QixJQUFJKzFFLHNCQUFzQi8xRSxTQUFTLENBQUMsRUFBRTtRQUN0QyxJQUFJZzJFLFdBQVdILFdBQVdkLGVBQWU7UUFDekMsSUFBSWtCLHFCQUFxQixJQUFJUCxtQkFBbUJHLFlBQVlDLFlBQVlDO1FBQ3hFLElBQUksQ0FBQ3hrQixNQUFNLENBQUMzVCxLQUFLLENBQUNvNEIsVUFBVTtZQUMxQmoxRSxhQUFhO2dCQUNYLE9BQU87b0JBQUN5OEM7aUJBQVk7WUFDdEI7WUFDQUMsV0FBVyxTQUFVVixJQUFJO2dCQUN2QixJQUFJc1YsWUFBWXRWO2dCQUNoQnNWLFVBQVVyRCxNQUFNLENBQUNnbkIsVUFBVUM7WUFDN0I7UUFDRjtRQUNBLE9BQU9BLG1CQUFtQkMsV0FBVztJQUN2QztBQUNGO0FBQ0FWLG9CQUFvQnQyRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxFQUFFO0FBQ1g7QUFDQXkwRSxvQkFBb0J0MkUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2hELE9BQU93MEU7QUFDVDtBQUNBQyxtQkFBbUJDLGtCQUFrQixDQUFDcHpFLEdBQUcsR0FBRztJQUFjLE9BQU9vekU7QUFBbUI7QUFFcEZ2MkUsT0FBT29ELGdCQUFnQixDQUFFaXpFLHFCQUFxQkM7QUFFOUMsSUFBSUMscUJBQXNCLFNBQVVTLDRCQUE0QjtJQUM5RCxTQUFTVDtRQUNQUyw2QkFBNkIxMEUsSUFBSSxDQUFDLElBQUk7UUFDdEMsSUFBSSxDQUFDMjBFLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUlYLFdBQVc1MUUsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSTgxRSxhQUFhOTFFLFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUkrMUUsc0JBQXNCLzFFLFNBQVMsQ0FBQyxFQUFFO1FBQ3RDLElBQUksQ0FBQ28yRSxTQUFTLEdBQUdSO1FBQ2pCLElBQUksQ0FBQ1MsV0FBVyxHQUFHUDtRQUNuQixJQUFJLENBQUNRLG9CQUFvQixHQUFHUDtJQUM5QjtJQUVBLElBQUtJLDhCQUErQlQsbUJBQW1COXpFLFNBQVMsR0FBR3UwRTtJQUNuRVQsbUJBQW1CeDJFLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRXMwRSxnQ0FBZ0NBLDZCQUE2QmozRSxTQUFTO0lBQ3BIdzJFLG1CQUFtQngyRSxTQUFTLENBQUM0QyxXQUFXLEdBQUc0ekU7SUFDM0NBLG1CQUFtQngyRSxTQUFTLENBQUNnM0UsV0FBVyxHQUFHLFNBQVNBO1FBQ2xELE9BQU8sSUFBSSxDQUFDSyxZQUFZO0lBQzFCO0lBQ0FiLG1CQUFtQngyRSxTQUFTLENBQUM4dkQsTUFBTSxHQUFHLFNBQVNBO1FBQzdDLElBQUlodkQsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSXV2RCxLQUFLbHZELFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUk0d0MsYUFBYTV3QyxTQUFTLENBQUMsRUFBRTtZQUM3QixJQUFJMHFELEtBQUt3RSxHQUFHTyxVQUFVO1lBQ3RCLElBQUksSUFBSSxDQUFDNG1CLFdBQVcsS0FBSyxNQUFNO2dCQUM3QixJQUFJM3JCLE9BQU8sSUFBSSxDQUFDMnJCLFdBQVcsSUFBSXpsQyxlQUFlLElBQUksQ0FBQzBsQyxvQkFBb0IsRUFBRTtvQkFBRSxPQUFPO2dCQUFLO1lBQ3pGO1lBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSSxDQUFDSCxTQUFTLENBQUNoQixjQUFjLENBQUMxcUIsSUFBSTlaO1FBQ3hELE9BQU87WUFBRSxPQUFPdWxDLDZCQUE2QmozRSxTQUFTLENBQUM4dkQsTUFBTSxDQUFDdjJDLEtBQUssQ0FBQyxJQUFJLEVBQUV6WTtRQUFXO0lBQ3ZGO0lBQ0EwMUUsbUJBQW1CeDJFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUNsRCxPQUFPLEVBQUU7SUFDWDtJQUNBMjBFLG1CQUFtQngyRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDL0MsT0FBTzAwRTtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFSjtBQUVGLElBQUlrQixrQ0FBa0MsU0FBU0E7SUFDN0MsSUFBSSxDQUFDcGMsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDcWMsc0JBQXNCLEdBQUc7SUFDOUIsSUFBSTNzQixLQUFLOXBELFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQ282RCxHQUFHLEdBQUd0UTtJQUNYLElBQUksQ0FBQzJzQixzQkFBc0IsR0FBRyxJQUFJL3BEO0FBQ3BDO0FBQ0E4cEQsZ0NBQWdDdDNFLFNBQVMsQ0FBQ3d6RCxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JpWixFQUFFLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQ3hILElBQUl0eUQsU0FBUyxJQUFJO0lBRW5CLElBQUlteUQsT0FBT0UsTUFBTUQsY0FBY0UsV0FBVztRQUFFLE9BQU87SUFBSztJQUN4RCxJQUFJbGMsTUFBTStiLEdBQUcvMEMsY0FBYyxFQUFFLENBQUNnMUMsVUFBVTtJQUN4QyxJQUFJL2IsTUFBTThiLEdBQUcvMEMsY0FBYyxFQUFFLENBQUNnMUMsWUFBWSxFQUFFO0lBQzVDLElBQUk5YixNQUFNK2IsR0FBR2oxQyxjQUFjLEVBQUUsQ0FBQ2sxQyxVQUFVO0lBQ3hDLElBQUkvYixNQUFNOGIsR0FBR2oxQyxjQUFjLEVBQUUsQ0FBQ2sxQyxZQUFZLEVBQUU7SUFDNUMsSUFBSSxDQUFDMVIsR0FBRyxDQUFDejdDLG1CQUFtQixDQUFDaXhDLEtBQUtDLEtBQUtDLEtBQUtDO0lBQzVDLElBQUksSUFBSSxDQUFDcUssR0FBRyxDQUFDaDdDLGVBQWUsSUFBSTtRQUM5QixJQUFJLElBQUksQ0FBQ2c3QyxHQUFHLENBQUM3NkMsc0JBQXNCLElBQUk7WUFDckMsSUFBSyxJQUFJbEIsV0FBVyxHQUFHQSxXQUFXLElBQUksQ0FBQys3QyxHQUFHLENBQUNyN0Msa0JBQWtCLElBQUlWLFdBQVk7Z0JBQzNFN0UsT0FBT2k5RCxzQkFBc0IsQ0FBQ3RyRSxHQUFHLENBQUNxTyxPQUFPNGdELEdBQUcsQ0FBQzM2QyxlQUFlLENBQUNwQjtZQUMvRDtZQUNBc3RELEdBQUd2aEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDZ1EsR0FBRyxFQUFFd1IsV0FBVztZQUN6Q0MsR0FBR3poQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNnUSxHQUFHLEVBQUUwUixXQUFXO1FBQzNDO0lBQ0Y7QUFDRjtBQUNBMEssZ0NBQWdDdDNFLFNBQVMsQ0FBQ3MzQixNQUFNLEdBQUcsU0FBU0E7SUFDMUQsT0FBTztBQUNUO0FBQ0FnZ0QsZ0NBQWdDdDNFLFNBQVMsQ0FBQ3czRSx3QkFBd0IsR0FBRyxTQUFTQTtJQUM1RSxPQUFPLElBQUksQ0FBQ0Qsc0JBQXNCO0FBQ3BDO0FBQ0FELGdDQUFnQ3QzRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDL0QsT0FBTztRQUFDMnFFO0tBQW1CO0FBQzdCO0FBQ0E4SyxnQ0FBZ0N0M0UsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzVELE9BQU93MUU7QUFDVDtBQUVBLElBQUlHLHFCQUFxQixTQUFTQTtJQUNoQyxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ3hjLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQzBYLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNELE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQ2dGLGFBQWEsR0FBRztJQUNyQixJQUFJLENBQUNwbEIsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSTd1QixLQUFLNWlDLFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQzQyRSxHQUFHLEdBQUdoMEM7SUFDWCxJQUFJLENBQUN3M0IsR0FBRyxHQUFHLElBQUloNkM7SUFDZixJQUFJLENBQUNnNkMsR0FBRyxDQUFDLzZDLGlCQUFpQixDQUFDdWpCO0lBQzNCLElBQUksQ0FBQ2t2QyxZQUFZLEdBQUdsdkMsR0FBR00sUUFBUTtBQUNqQztBQUNBeXpDLG1CQUFtQnozRSxTQUFTLENBQUM0M0UsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCQyxtQkFBbUI7SUFDNUYsSUFBSUMsbUJBQW1CM3VCLG1CQUFtQmdDLGtCQUFrQixDQUFDMHNCO0lBQzdELElBQUlFLEtBQUssSUFBSW5FLGdCQUFnQmtFO0lBQzdCLElBQUk7UUFDRkMsR0FBR3pELFVBQVU7SUFDZixFQUFFLE9BQU81akUsSUFBSTtRQUNYLElBQUlBLGNBQWMwRCxXQUFXO1lBQzNCMUQsR0FBR3NyQixlQUFlO1FBQ3BCLE9BQU87WUFBRSxNQUFNdHJCO1FBQUc7SUFDcEIsU0FBVSxDQUFDO0FBQ2I7QUFDQSttRSxtQkFBbUJ6M0UsU0FBUyxDQUFDbXJELGtCQUFrQixHQUFHLFNBQVNBO0lBQ3pELE9BQU9oQyxtQkFBbUJnQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUNvSCxnQkFBZ0I7QUFDcEU7QUFDQWtsQixtQkFBbUJ6M0UsU0FBUyxDQUFDZzRFLFNBQVMsR0FBRyxTQUFTQSxVQUFXNXNCLFVBQVUsRUFBRVIsRUFBRTtJQUN6RSxJQUFJcXRCLGdCQUFnQixJQUFJLENBQUNDLHlCQUF5QixDQUFDOXNCLFlBQVlSO0lBQy9ELElBQUksQ0FBQ3V0Qix3QkFBd0IsQ0FBQ0Y7SUFDOUIsSUFBSSxDQUFDRyxrQkFBa0IsQ0FBQ2h0QjtBQUMxQjtBQUNBcXNCLG1CQUFtQnozRSxTQUFTLENBQUNrNEUseUJBQXlCLEdBQUcsU0FBU0EsMEJBQTJCOXNCLFVBQVUsRUFBRVIsRUFBRTtJQUN6RyxJQUFJeXRCLGlCQUFpQixJQUFJZixnQ0FBZ0Mxc0I7SUFDekQsSUFBSSxDQUFDK25CLE1BQU0sQ0FBQzNnQixxQkFBcUIsQ0FBQ3FtQjtJQUNsQyxJQUFJLENBQUMxRixNQUFNLENBQUMvZ0IsWUFBWSxDQUFDeEc7SUFDekIsT0FBT2l0QixlQUFlYix3QkFBd0I7QUFDaEQ7QUFDQUMsbUJBQW1CejNFLFNBQVMsQ0FBQ280RSxrQkFBa0IsR0FBRyxTQUFTQTtJQUN2RCxJQUFJOTlELFNBQVMsSUFBSTtJQUVuQixJQUFJblQsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVnc0IsYUFBYTtRQUMxQyxJQUFJcW5CLFFBQVFyekMsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSyxJQUFJZzJELEtBQUszaUIsTUFBTTlvQixRQUFRLElBQUl5ckMsR0FBR3ZyQyxPQUFPLElBQUs7WUFDN0MsSUFBSStzRCxRQUFReGhCLEdBQUdwdkMsSUFBSTtZQUNuQnBOLE9BQU84OUQsa0JBQWtCLENBQUNFO1FBQzVCO0lBQ0YsT0FBTyxJQUFJeDNFLFNBQVMsQ0FBQyxFQUFFLFlBQVlxb0Qsb0JBQW9CO1FBQ3JELElBQUl0Z0QsSUFBSS9ILFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUl1ekUsT0FBT3hyRSxFQUFFNnVCLGNBQWM7UUFDM0IsSUFBSyxJQUFJdHdCLElBQUksR0FBR0EsSUFBSWl0RSxLQUFLNXpFLE1BQU0sRUFBRTJHLElBQUs7WUFDcEMsSUFBSXN2RSxXQUFXLElBQUlqQyxTQUFTSixJQUFJLENBQUNqdEUsRUFBRSxFQUFFa1QsT0FBT3M0RCxZQUFZLEVBQUV0NEQsT0FBTzRnRCxHQUFHO1lBQ3BFLElBQUk4YixjQUFjMThELE9BQU9xOUQsYUFBYSxDQUFDbEIsSUFBSSxDQUFDQyxVQUFVN3RFLEdBQUd6QjtZQUN6RCxJQUFJNHZFLGFBQWE7Z0JBQ2ZudUUsRUFBRXloRCxlQUFlLENBQUMrcEIsSUFBSSxDQUFDanRFLEVBQUUsRUFBRUE7WUFDN0I7UUFDRjtJQUNGO0FBQ0Y7QUFDQXF3RSxtQkFBbUJ6M0UsU0FBUyxDQUFDNHhELFlBQVksR0FBRyxTQUFTQSxhQUFjaW1CLG1CQUFtQjtJQUNwRixJQUFJLENBQUN0bEIsZ0JBQWdCLEdBQUdzbEI7SUFDeEIsSUFBSSxDQUFDbEYsTUFBTSxHQUFHLElBQUkxZ0I7SUFDbEIsSUFBSSxDQUFDMGxCLGFBQWEsR0FBRyxJQUFJckIsb0JBQW9CLElBQUksQ0FBQzNELE1BQU0sQ0FBQ2hnQixRQUFRO0lBQ2pFLElBQUksQ0FBQ3FsQixTQUFTLENBQUNILHFCQUFxQixJQUFJLENBQUMzYyxHQUFHO0FBQzlDO0FBQ0F1YyxtQkFBbUJ6M0UsU0FBUyxDQUFDbTRFLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQkksT0FBTztJQUM5RixJQUFJaitELFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlvZ0IsS0FBSzY5QyxRQUFRbHRELFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDL0MsSUFBSWl0RCxTQUFTOTlDLEdBQUdoVCxJQUFJO1FBQ3BCLElBQUlndkQsV0FBVyxJQUFJakMsU0FBUytELFFBQVFsK0QsT0FBT3M0RCxZQUFZLEVBQUV0NEQsT0FBTzRnRCxHQUFHO1FBQ25FNWdELE9BQU9xOUQsYUFBYSxDQUFDbEIsSUFBSSxDQUFDQztJQUM1QjtBQUNGO0FBQ0FlLG1CQUFtQnozRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbEQsT0FBTztRQUFDOHZEO0tBQU07QUFDaEI7QUFDQThsQixtQkFBbUJ6M0UsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU8yMUU7QUFDVDtBQUVBLElBQUlnQixXQUFXLFNBQVNBO0lBQ3RCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQzk0QixTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDcWIsVUFBVSxHQUFHLElBQUl4SDtJQUN0QixJQUFJLENBQUNrbEIsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQ3RCLElBQUk5M0UsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSW9wQixJQUFJL29CLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUksQ0FBQzQzRSxRQUFRLEdBQUc3dUQ7SUFDbEIsT0FBTyxJQUFJL29CLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlrcEIsTUFBTTdvQixTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJODZELFlBQVk5NkQsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSSxDQUFDNDNFLFFBQVEsR0FBRy91RDtRQUNoQixJQUFJLENBQUNzeEMsVUFBVSxHQUFHVztJQUNwQjtBQUNGO0FBRUEsSUFBSWlkLHFCQUFxQjtJQUFFaGxCLFdBQVc7UUFBRTF6RCxjQUFjO0lBQUs7SUFBRTI0RSxVQUFVO1FBQUUzNEUsY0FBYztJQUFLO0lBQUU4MEQsVUFBVTtRQUFFOTBELGNBQWM7SUFBSztJQUFFKzBELFlBQVk7UUFBRS8wRCxjQUFjO0lBQUs7SUFBRTQ0RSxzQkFBc0I7UUFBRTU0RSxjQUFjO0lBQUs7QUFBRTtBQUMvTXM0RSxTQUFTejRFLFNBQVMsQ0FBQ2c1RSxvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JDLE9BQU87SUFDOUUsSUFBSW5ILFFBQVEsSUFBSVksWUFBWSxJQUFJK0UsbUJBQW1CLElBQUl2MEMsZUFBZSxPQUFPKzFDLFFBQVFqMUMsUUFBUTtJQUM3RixJQUFJazFDLGFBQWEsSUFBSTFJLGNBQWMsSUFBSSxDQUFDdlYsVUFBVTtJQUNsRGllLFdBQVd0SSx3QkFBd0IsQ0FBQ3FJO0lBQ3BDQyxXQUFXNUcsUUFBUSxDQUFDUjtJQUNwQixJQUFJLENBQUM2RyxlQUFlLEdBQUdPLFdBQVduSCxNQUFNLENBQUMsSUFBSSxDQUFDMkcsUUFBUSxFQUFFLElBQUksQ0FBQzk0QixTQUFTO0FBQ3hFO0FBQ0E2NEIsU0FBU3o0RSxTQUFTLENBQUNtNUUsc0JBQXNCLEdBQUcsU0FBU0E7SUFDakQsSUFBSTcrRCxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUssSUFBSTI0RSxhQUFhWCxTQUFTTSxvQkFBb0IsRUFBRUssY0FBYyxHQUFHQSxhQUFjO1lBQ2xGLElBQUk7Z0JBQ0Y5K0QsT0FBTzYrRCxzQkFBc0IsQ0FBQ0M7WUFDaEMsRUFBRSxPQUFPMW9FLElBQUk7Z0JBQ1gsSUFBSUEsY0FBY2k2QixtQkFBbUI7b0JBQ25DcndCLE9BQU9zK0QsY0FBYyxHQUFHbG9FO2dCQUMxQixPQUFPO29CQUFFLE1BQU1BO2dCQUFHO1lBQ3BCLFNBQVUsQ0FBQztZQUNYLElBQUk0SixPQUFPcStELGVBQWUsS0FBSyxNQUFNO2dCQUFFLE9BQU87WUFBSztRQUNyRDtRQUNBLE1BQU0sSUFBSSxDQUFDQyxjQUFjO0lBQzNCLE9BQU8sSUFBSTkzRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNDRFLGtCQUFrQnY0RSxTQUFTLENBQUMsRUFBRTtRQUNsQyxJQUFJdzRFLHVCQUF1QmIsU0FBU2Msb0JBQW9CLENBQUMsSUFBSSxDQUFDYixRQUFRLEVBQUUsSUFBSSxDQUFDOTRCLFNBQVMsRUFBRXk1QjtRQUN4RixJQUFJSixVQUFVLElBQUkvMUMsZUFBZW8yQztRQUNqQyxJQUFJLENBQUNOLG9CQUFvQixDQUFDQztJQUM1QjtBQUNGO0FBQ0FSLFNBQVN6NEUsU0FBUyxDQUFDdzVFLGVBQWUsR0FBRyxTQUFTQTtJQUM1QyxJQUFJLENBQUNDLHVCQUF1QjtJQUM1QixJQUFJLElBQUksQ0FBQ2QsZUFBZSxLQUFLLE1BQU07UUFBRSxPQUFPO0lBQUs7SUFDakQsSUFBSWUsUUFBUSxJQUFJLENBQUNoQixRQUFRLENBQUNsdkQsVUFBVSxHQUFHdUIsaUJBQWlCO0lBQ3hELElBQUkydUQsTUFBTXYxQyxPQUFPLE9BQU9qQixlQUFlTSxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUN3MUMsb0JBQW9CLENBQUNVO0lBQVEsT0FBTztRQUFFLElBQUksQ0FBQ1Asc0JBQXNCO0lBQUk7QUFDNUg7QUFDQVYsU0FBU3o0RSxTQUFTLENBQUNzMEQsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCRCxnQkFBZ0I7SUFDckYsSUFBSSxDQUFDNEcsVUFBVSxDQUFDM0csbUJBQW1CLENBQUNEO0FBQ3RDO0FBQ0Fva0IsU0FBU3o0RSxTQUFTLENBQUN5NUUsdUJBQXVCLEdBQUcsU0FBU0E7SUFDcEQsSUFBSTtRQUNGLElBQUlQLGFBQWEsSUFBSTFJLGNBQWMsSUFBSSxDQUFDdlYsVUFBVTtRQUNsRCxJQUFJLENBQUMwZCxlQUFlLEdBQUdPLFdBQVduSCxNQUFNLENBQUMsSUFBSSxDQUFDMkcsUUFBUSxFQUFFLElBQUksQ0FBQzk0QixTQUFTO0lBQ3hFLEVBQUUsT0FBT2x2QyxJQUFJO1FBQ1gsSUFBSUEsY0FBYzZNLGtCQUFrQjtZQUNsQyxJQUFJLENBQUNxN0QsY0FBYyxHQUFHbG9FO1FBQ3hCLE9BQU87WUFBRSxNQUFNQTtRQUFHO0lBQ3BCLFNBQVUsQ0FBQztBQUNiO0FBQ0ErbkUsU0FBU3o0RSxTQUFTLENBQUMyNUUsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CcDBFLFFBQVE7SUFDekUsSUFBSSxDQUFDcTZDLFNBQVMsR0FBR3I2QztJQUNqQixJQUFJLENBQUNpMEUsZUFBZTtJQUNwQixPQUFPLElBQUksQ0FBQ2IsZUFBZTtBQUM3QjtBQUNBRixTQUFTejRFLFNBQVMsQ0FBQ3kwRCxjQUFjLEdBQUcsU0FBU0EsZUFBZ0JELFdBQVc7SUFDdEUsSUFBSSxDQUFDeUcsVUFBVSxDQUFDeEcsY0FBYyxDQUFDRDtBQUNqQztBQUNBaWtCLFNBQVN6NEUsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8sRUFBRTtBQUNYO0FBQ0E0MkUsU0FBU3o0RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDckMsT0FBTzIyRTtBQUNUO0FBQ0FBLFNBQVNtQixRQUFRLEdBQUcsU0FBU0E7SUFDM0IsSUFBSTk0RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJb3BCLElBQUkvb0IsU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSXlFLFdBQVd6RSxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJKzRFLE9BQU8sSUFBSXBCLFNBQVM1dUQ7UUFDeEIsSUFBSWl3RCxVQUFVRCxLQUFLRixpQkFBaUIsQ0FBQ3AwRTtRQUNyQyxPQUFPdTBFO0lBQ1QsT0FBTyxJQUFJaDVFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlPLE9BQU9JLFNBQVMsQ0FBQ04sU0FBUyxDQUFDLEVBQUUsS0FBTUEsU0FBUyxDQUFDLEVBQUUsWUFBWXVuQixZQUFZLE9BQU92bkIsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFXO1lBQzVHLElBQUk2b0IsTUFBTTdvQixTQUFTLENBQUMsRUFBRTtZQUN0QixJQUFJaTVFLGFBQWFqNUUsU0FBUyxDQUFDLEVBQUU7WUFDN0IsSUFBSXV6RCxtQkFBbUJ2ekQsU0FBUyxDQUFDLEVBQUU7WUFDbkMsSUFBSWs1RSxRQUFRLElBQUl2QixTQUFTOXVEO1lBQ3pCcXdELE1BQU0xbEIsbUJBQW1CLENBQUNEO1lBQzFCLElBQUk0bEIsWUFBWUQsTUFBTUwsaUJBQWlCLENBQUNJO1lBQ3hDLE9BQU9FO1FBQ1QsT0FBTyxJQUFJbjVFLFNBQVMsQ0FBQyxFQUFFLFlBQVkyeUQsb0JBQXFCM3lELFNBQVMsQ0FBQyxFQUFFLFlBQVl1bkIsWUFBWSxPQUFPdm5CLFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFBVztZQUM3SCxJQUFJbzVFLE1BQU1wNUUsU0FBUyxDQUFDLEVBQUU7WUFDdEIsSUFBSXE1RSxhQUFhcjVFLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLElBQUlzNUUsU0FBU3Q1RSxTQUFTLENBQUMsRUFBRTtZQUN6QixJQUFJdTVFLFVBQVUsSUFBSTVCLFNBQVN5QixLQUFLRTtZQUNoQyxJQUFJRSxZQUFZRCxRQUFRVixpQkFBaUIsQ0FBQ1E7WUFDMUMsT0FBT0c7UUFDVDtJQUNGLE9BQU8sSUFBSXg1RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJODVFLE1BQU16NUUsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTA1RSxhQUFhMTVFLFNBQVMsQ0FBQyxFQUFFO1FBQzdCLElBQUl5ekQscUJBQXFCenpELFNBQVMsQ0FBQyxFQUFFO1FBQ3JDLElBQUkwekQsY0FBYzF6RCxTQUFTLENBQUMsRUFBRTtRQUM5QixJQUFJMjVFLFVBQVUsSUFBSWhDLFNBQVM4QjtRQUMzQkUsUUFBUW5tQixtQkFBbUIsQ0FBQ0M7UUFDNUJrbUIsUUFBUWhtQixjQUFjLENBQUNEO1FBQ3ZCLElBQUlrbUIsWUFBWUQsUUFBUWQsaUJBQWlCLENBQUNhO1FBQzFDLE9BQU9FO0lBQ1Q7QUFDRjtBQUNBakMsU0FBU2Msb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCMXZELENBQUMsRUFBRXRrQixRQUFRLEVBQUVvMUUsa0JBQWtCO0lBQzVGLElBQUkxbUUsTUFBTTRWLEVBQUVjLG1CQUFtQjtJQUMvQixJQUFJaXdELFNBQVN0ekUsU0FBUzNHLEdBQUcsQ0FBQ0QsS0FBS3lCLEdBQUcsQ0FBQzhSLElBQUk0QyxPQUFPLEtBQUtuVyxLQUFLeUIsR0FBRyxDQUFDOFIsSUFBSTZDLE9BQU8sS0FBS3BXLEtBQUt5QixHQUFHLENBQUM4UixJQUFJOEMsT0FBTyxLQUFLclcsS0FBS3lCLEdBQUcsQ0FBQzhSLElBQUkrQyxPQUFPO0lBQ3pILElBQUk2akUsbUJBQW1CdDFFLFdBQVcsTUFBTUEsV0FBVztJQUNuRCxJQUFJdTFFLFlBQVlGLFNBQVMsSUFBSUM7SUFDN0IsSUFBSUUsd0JBQXdCcjZFLEtBQUtlLEtBQUssQ0FBQ2YsS0FBS2lILEdBQUcsQ0FBQ216RSxhQUFhcDZFLEtBQUtpSCxHQUFHLENBQUMsTUFBTTtJQUM1RSxJQUFJcXpFLGVBQWVMLHFCQUFxQkk7SUFDeEMsSUFBSS9ILGNBQWN0eUUsS0FBS3FLLEdBQUcsQ0FBQyxNQUFNaXdFO0lBQ2pDLE9BQU9oSTtBQUNUO0FBQ0E2RixtQkFBbUJobEIsU0FBUyxDQUFDendELEdBQUcsR0FBRztJQUFjLE9BQU9xd0QsaUJBQWlCSSxTQUFTO0FBQUM7QUFDbkZnbEIsbUJBQW1CQyxRQUFRLENBQUMxMUUsR0FBRyxHQUFHO0lBQWMsT0FBT3F3RCxpQkFBaUJ3QixRQUFRO0FBQUM7QUFDakY0akIsbUJBQW1CNWpCLFFBQVEsQ0FBQzd4RCxHQUFHLEdBQUc7SUFBYyxPQUFPcXdELGlCQUFpQndCLFFBQVE7QUFBQztBQUNqRjRqQixtQkFBbUIzakIsVUFBVSxDQUFDOXhELEdBQUcsR0FBRztJQUFjLE9BQU9xd0QsaUJBQWlCeUIsVUFBVTtBQUFDO0FBQ3JGMmpCLG1CQUFtQkUsb0JBQW9CLENBQUMzMUUsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFHO0FBRXRFbkQsT0FBT29ELGdCQUFnQixDQUFFbzFFLFVBQVVJO0FBRW5DLElBQUlvQyxvQkFBb0IsU0FBU0E7SUFDL0IsSUFBSSxDQUFDdkcsR0FBRyxHQUFHO1FBQUMsSUFBSWh4RTtRQUFjLElBQUlBO0tBQWE7SUFDL0MsSUFBSSxDQUFDazhDLFNBQVMsR0FBRy84QyxPQUFPK0MsR0FBRztJQUMzQixJQUFJLENBQUNzMUUsT0FBTyxHQUFHO0FBQ2pCO0FBQ0FELGtCQUFrQmo3RSxTQUFTLENBQUMwM0IsY0FBYyxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sSUFBSSxDQUFDZzlDLEdBQUc7QUFDakI7QUFDQXVHLGtCQUFrQmo3RSxTQUFTLENBQUM0VCxhQUFhLEdBQUcsU0FBU0EsY0FBZXhNLENBQUM7SUFDbkUsT0FBTyxJQUFJLENBQUNzdEUsR0FBRyxDQUFDdHRFLEVBQUU7QUFDcEI7QUFDQTZ6RSxrQkFBa0JqN0UsU0FBUyxDQUFDbTdFLFVBQVUsR0FBRyxTQUFTQTtJQUNoRCxJQUFJcjZFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkrM0QsU0FBUzEzRCxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJLENBQUNxNkUsVUFBVSxDQUFDM2lCLE9BQU9rYyxHQUFHLENBQUMsRUFBRSxFQUFFbGMsT0FBT2tjLEdBQUcsQ0FBQyxFQUFFO0lBQzlDLE9BQU8sSUFBSTV6RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNmMsS0FBS3hjLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl5USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNvNkUsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0UsVUFBVSxDQUFDOTlELElBQUkvTDtZQUNwQixPQUFPO1FBQ1Q7UUFDQSxJQUFJaVAsT0FBT2xELEdBQUcvWCxRQUFRLENBQUNnTTtRQUN2QixJQUFJaVAsT0FBTyxJQUFJLENBQUNvL0IsU0FBUyxFQUFFO1lBQUUsSUFBSSxDQUFDdzdCLFVBQVUsQ0FBQzk5RCxJQUFJL0wsSUFBSWlQO1FBQU87SUFDOUQ7QUFDRjtBQUNBeTZELGtCQUFrQmo3RSxTQUFTLENBQUNvN0UsVUFBVSxHQUFHLFNBQVNBO0lBQ2hELElBQUl0NkUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSxDQUFDeTZFLE9BQU8sR0FBRztJQUNqQixPQUFPLElBQUlwNkUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTZjLEtBQUt4YyxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJeVEsS0FBS3pRLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQzR6RSxHQUFHLENBQUMsRUFBRSxDQUFDaHZFLGFBQWEsQ0FBQzRYO1FBQzFCLElBQUksQ0FBQ28zRCxHQUFHLENBQUMsRUFBRSxDQUFDaHZFLGFBQWEsQ0FBQzZMO1FBQzFCLElBQUksQ0FBQ3F1QyxTQUFTLEdBQUd0aUMsR0FBRy9YLFFBQVEsQ0FBQ2dNO1FBQzdCLElBQUksQ0FBQzJwRSxPQUFPLEdBQUc7SUFDakIsT0FBTyxJQUFJcDZFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkwMkMsT0FBT3IyQyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJcVUsT0FBT3JVLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUl5RSxXQUFXekUsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDNHpFLEdBQUcsQ0FBQyxFQUFFLENBQUNodkUsYUFBYSxDQUFDeXhDO1FBQzFCLElBQUksQ0FBQ3U5QixHQUFHLENBQUMsRUFBRSxDQUFDaHZFLGFBQWEsQ0FBQ3lQO1FBQzFCLElBQUksQ0FBQ3lxQyxTQUFTLEdBQUdyNkM7UUFDakIsSUFBSSxDQUFDMjFFLE9BQU8sR0FBRztJQUNqQjtBQUNGO0FBQ0FELGtCQUFrQmo3RSxTQUFTLENBQUM2Z0QsV0FBVyxHQUFHLFNBQVNBO0lBQ2pELE9BQU8sSUFBSSxDQUFDakIsU0FBUztBQUN2QjtBQUNBcTdCLGtCQUFrQmo3RSxTQUFTLENBQUNxN0UsVUFBVSxHQUFHLFNBQVNBO0lBQ2hELElBQUl2NkUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSszRCxTQUFTMTNELFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3U2RSxVQUFVLENBQUM3aUIsT0FBT2tjLEdBQUcsQ0FBQyxFQUFFLEVBQUVsYyxPQUFPa2MsR0FBRyxDQUFDLEVBQUU7SUFDOUMsT0FBTyxJQUFJNXpFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk2YyxLQUFLeGMsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXlRLEtBQUt6USxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ282RSxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDRSxVQUFVLENBQUM5OUQsSUFBSS9MO1lBQ3BCLE9BQU87UUFDVDtRQUNBLElBQUlpUCxPQUFPbEQsR0FBRy9YLFFBQVEsQ0FBQ2dNO1FBQ3ZCLElBQUlpUCxPQUFPLElBQUksQ0FBQ28vQixTQUFTLEVBQUU7WUFBRSxJQUFJLENBQUN3N0IsVUFBVSxDQUFDOTlELElBQUkvTCxJQUFJaVA7UUFBTztJQUM5RDtBQUNGO0FBQ0F5NkQsa0JBQWtCajdFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNqRCxPQUFPLEVBQUU7QUFDWDtBQUNBbzVFLGtCQUFrQmo3RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDOUMsT0FBT201RTtBQUNUO0FBRUEsSUFBSUssd0JBQXdCLFNBQVNBLHlCQUEwQjtBQUUvREEsc0JBQXNCdDdFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNyRCxPQUFPLEVBQUU7QUFDWDtBQUNBeTVFLHNCQUFzQnQ3RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbEQsT0FBT3c1RTtBQUNUO0FBQ0FBLHNCQUFzQkMsZUFBZSxHQUFHLFNBQVNBO0lBQy9DLElBQUl6NkUsU0FBUyxDQUFDLEVBQUUsWUFBWW02RSxxQkFBc0JuNkUsU0FBUyxDQUFDLEVBQUUsWUFBWXE1QixjQUFjcjVCLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFhO1FBQzNILElBQUk0WSxPQUFPeGIsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSStmLEtBQUsvZixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJMDNELFNBQVMxM0QsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSTZhLFNBQVNXLEtBQUtvYixjQUFjO1FBQ2hDLElBQUk4akQsY0FBYyxJQUFJL3ZCO1FBQ3RCLElBQUssSUFBSXJrRCxJQUFJLEdBQUdBLElBQUl1VSxPQUFPbGIsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1lBQzFDbzBFLFlBQVl6dEIsY0FBYyxDQUFDcHlDLE1BQU0sQ0FBQ3ZVLEVBQUUsRUFBRXVVLE1BQU0sQ0FBQ3ZVLElBQUksRUFBRTtZQUNuRCxJQUFJdWxELFlBQVk2dUIsWUFBWTN1QixZQUFZLENBQUNoc0M7WUFDekMyM0MsT0FBTzJpQixVQUFVLENBQUN4dUIsV0FBVzlyQztRQUMvQjtJQUNGLE9BQU8sSUFBSS9mLFNBQVMsQ0FBQyxFQUFFLFlBQVltNkUscUJBQXNCbjZFLFNBQVMsQ0FBQyxFQUFFLFlBQVk0OUIsV0FBVzU5QixTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBYTtRQUMvSCxJQUFJNDdCLE9BQU94K0IsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTI2RSxPQUFPMzZFLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk0NkUsV0FBVzU2RSxTQUFTLENBQUMsRUFBRTtRQUMzQnc2RSxzQkFBc0JDLGVBQWUsQ0FBQ2o4QyxLQUFLRSxlQUFlLElBQUlpOEMsTUFBTUM7UUFDcEUsSUFBSyxJQUFJOTFELE1BQU0sR0FBR0EsTUFBTTBaLEtBQUtWLGtCQUFrQixJQUFJaFosTUFBTztZQUN4RDAxRCxzQkFBc0JDLGVBQWUsQ0FBQ2o4QyxLQUFLVSxnQkFBZ0IsQ0FBQ3BhLE1BQU02MUQsTUFBTUM7UUFDMUU7SUFDRixPQUFPLElBQUk1NkUsU0FBUyxDQUFDLEVBQUUsWUFBWW02RSxxQkFBc0JuNkUsU0FBUyxDQUFDLEVBQUUsWUFBWXVuQixZQUFZdm5CLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFhO1FBQ2hJLElBQUkwa0IsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJNjZFLE9BQU83NkUsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTg2RSxXQUFXOTZFLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUlzbkIsZ0JBQWdCK1IsWUFBWTtZQUM5Qm1oRCxzQkFBc0JDLGVBQWUsQ0FBQ256RCxNQUFNdXpELE1BQU1DO1FBQ3BELE9BQU8sSUFBSXh6RCxnQkFBZ0JzVyxTQUFTO1lBQ2xDNDhDLHNCQUFzQkMsZUFBZSxDQUFDbnpELE1BQU11ekQsTUFBTUM7UUFDcEQsT0FBTyxJQUFJeHpELGdCQUFnQm9QLG9CQUFvQjtZQUM3QyxJQUFJZSxLQUFLblE7WUFDVCxJQUFLLElBQUlpSCxNQUFNLEdBQUdBLE1BQU1rSixHQUFHbk8sZ0JBQWdCLElBQUlpRixNQUFPO2dCQUNwRCxJQUFJeEYsSUFBSTBPLEdBQUc5TyxZQUFZLENBQUM0RjtnQkFDeEJpc0Qsc0JBQXNCQyxlQUFlLENBQUMxeEQsR0FBRzh4RCxNQUFNQztZQUNqRDtRQUNGLE9BQU87WUFDTEEsU0FBU1QsVUFBVSxDQUFDL3lELEtBQUt4VSxhQUFhLElBQUkrbkU7UUFDNUM7SUFDRixPQUFPLElBQUk3NkUsU0FBUyxDQUFDLEVBQUUsWUFBWW02RSxxQkFBc0JuNkUsU0FBUyxDQUFDLEVBQUUsWUFBWTJxRCxlQUFlM3FELFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFhO1FBQ25JLElBQUltNEUsVUFBVS82RSxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJZzdFLE9BQU9oN0UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSWk3RSxXQUFXajdFLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUlrN0UsY0FBY0gsUUFBUWh2QixZQUFZLENBQUNpdkI7UUFDdkNDLFNBQVNaLFVBQVUsQ0FBQ2EsYUFBYUY7SUFDbkM7QUFDRjtBQUVBLElBQUlHLG1DQUFtQyxTQUFTQSxpQ0FBa0MxVyxTQUFTO0lBQ3pGLElBQUksQ0FBQzJXLFVBQVUsR0FBRyxJQUFJakI7SUFDdEIsSUFBSSxDQUFDN1YsVUFBVSxHQUFHRyxhQUFhO0FBQ2pDO0FBRUEsSUFBSTRXLHFCQUFxQjtJQUFFQyx3QkFBd0I7UUFBRWo4RSxjQUFjO0lBQUs7SUFBRWs4RSwyQkFBMkI7UUFBRWw4RSxjQUFjO0lBQUs7QUFBRTtBQUM1SDg3RSxpQ0FBaUNqOEUsU0FBUyxDQUFDczhFLDBCQUEwQixHQUFHLFNBQVNBLDJCQUE0QjVXLEtBQUs7SUFDaEgsSUFBSTZXLGFBQWEsSUFBSUYsMEJBQTBCLElBQUksQ0FBQ2pYLFVBQVU7SUFDOURNLE1BQU1uc0QsS0FBSyxDQUFDZ2pFO0lBQ1osSUFBSSxDQUFDTCxVQUFVLENBQUNiLFVBQVUsQ0FBQ2tCLFdBQVdDLG1CQUFtQjtBQUMzRDtBQUNBUCxpQ0FBaUNqOEUsU0FBUyxDQUFDeThFLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQi9XLEtBQUs7SUFDNUcsSUFBSTZXLGFBQWEsSUFBSUgsdUJBQXVCLElBQUksQ0FBQ2hYLFVBQVU7SUFDM0RNLE1BQU1uc0QsS0FBSyxDQUFDZ2pFO0lBQ1osSUFBSSxDQUFDTCxVQUFVLENBQUNiLFVBQVUsQ0FBQ2tCLFdBQVdDLG1CQUFtQjtBQUMzRDtBQUNBUCxpQ0FBaUNqOEUsU0FBUyxDQUFDMDhFLFlBQVksR0FBRyxTQUFTQSxhQUFjQyxXQUFXO0lBQzFGLElBQUksQ0FBQ0Ysd0JBQXdCLENBQUNFO0lBQzlCLElBQUksQ0FBQ0wsMEJBQTBCLENBQUNLO0lBQ2hDLE9BQU8sSUFBSSxDQUFDVCxVQUFVLENBQUNyN0IsV0FBVztBQUNwQztBQUNBbzdCLGlDQUFpQ2o4RSxTQUFTLENBQUM0OEUsaUJBQWlCLEdBQUcsU0FBU0E7SUFDdEUsT0FBTyxJQUFJLENBQUNWLFVBQVU7QUFDeEI7QUFDQUQsaUNBQWlDajhFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNoRSxPQUFPLEVBQUU7QUFDWDtBQUNBbzZFLGlDQUFpQ2o4RSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDN0QsT0FBT202RTtBQUNUO0FBQ0FFLG1CQUFtQkMsc0JBQXNCLENBQUNoNUUsR0FBRyxHQUFHO0lBQWMsT0FBT2c1RTtBQUF1QjtBQUM1RkQsbUJBQW1CRSx5QkFBeUIsQ0FBQ2o1RSxHQUFHLEdBQUc7SUFBYyxPQUFPaTVFO0FBQTBCO0FBRWxHcDhFLE9BQU9vRCxnQkFBZ0IsQ0FBRTQ0RSxrQ0FBa0NFO0FBRTNELElBQUlDLHlCQUF5QixTQUFTQSx1QkFBd0JoMEQsSUFBSTtJQUNoRSxJQUFJLENBQUM4ekQsVUFBVSxHQUFHLElBQUlqQjtJQUN0QixJQUFJLENBQUM0QixVQUFVLEdBQUcsSUFBSTVCO0lBQ3RCLElBQUksQ0FBQzNoRCxLQUFLLEdBQUdsUixRQUFRO0FBQ3ZCO0FBQ0FnMEQsdUJBQXVCcDhFLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUXRILEVBQUU7SUFDM0QsSUFBSSxDQUFDZzhELFVBQVUsQ0FBQ3pCLFVBQVU7SUFDMUJFLHNCQUFzQkMsZUFBZSxDQUFDLElBQUksQ0FBQ2ppRCxLQUFLLEVBQUV6WSxJQUFJLElBQUksQ0FBQ2c4RCxVQUFVO0lBQ3JFLElBQUksQ0FBQ1gsVUFBVSxDQUFDYixVQUFVLENBQUMsSUFBSSxDQUFDd0IsVUFBVTtBQUM1QztBQUNBVCx1QkFBdUJwOEUsU0FBUyxDQUFDdzhFLG1CQUFtQixHQUFHLFNBQVNBO0lBQzlELE9BQU8sSUFBSSxDQUFDTixVQUFVO0FBQ3hCO0FBQ0FFLHVCQUF1QnA4RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdEQsT0FBTztRQUFDa3FCO0tBQWlCO0FBQzNCO0FBQ0Fxd0QsdUJBQXVCcDhFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuRCxPQUFPczZFO0FBQ1Q7QUFFQSxJQUFJQyw0QkFBNEIsU0FBU0EsMEJBQTJCajBELElBQUk7SUFDdEUsSUFBSSxDQUFDOHpELFVBQVUsR0FBRyxJQUFJakI7SUFDdEIsSUFBSSxDQUFDNEIsVUFBVSxHQUFHLElBQUk1QjtJQUN0QixJQUFJLENBQUMzaEQsS0FBSyxHQUFHbFIsUUFBUTtBQUN2QjtBQUNBaTBELDBCQUEwQnI4RSxTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVFrUCxHQUFHLEVBQUVodkIsS0FBSztJQUN0RSxJQUFJQSxVQUFVLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDL0IsSUFBSWlWLEtBQUsrWixJQUFJempCLGFBQWEsQ0FBQ3ZMLFFBQVE7SUFDbkMsSUFBSWtKLEtBQUs4bEIsSUFBSXpqQixhQUFhLENBQUN2TDtJQUMzQixJQUFJeTBFLFFBQVEsSUFBSXA1RSxXQUFXLENBQUM0WixHQUFHNWIsQ0FBQyxHQUFHNlAsR0FBRzdQLENBQUMsSUFBSSxHQUFHLENBQUM0YixHQUFHM1osQ0FBQyxHQUFHNE4sR0FBRzVOLENBQUMsSUFBSTtJQUM5RCxJQUFJLENBQUNrNUUsVUFBVSxDQUFDekIsVUFBVTtJQUMxQkUsc0JBQXNCQyxlQUFlLENBQUMsSUFBSSxDQUFDamlELEtBQUssRUFBRXdqRCxPQUFPLElBQUksQ0FBQ0QsVUFBVTtJQUN4RSxJQUFJLENBQUNYLFVBQVUsQ0FBQ2IsVUFBVSxDQUFDLElBQUksQ0FBQ3dCLFVBQVU7QUFDNUM7QUFDQVIsMEJBQTBCcjhFLFNBQVMsQ0FBQ3MzQixNQUFNLEdBQUcsU0FBU0E7SUFDcEQsT0FBTztBQUNUO0FBQ0Era0QsMEJBQTBCcjhFLFNBQVMsQ0FBQ3UzQixpQkFBaUIsR0FBRyxTQUFTQTtJQUMvRCxPQUFPO0FBQ1Q7QUFDQThrRCwwQkFBMEJyOEUsU0FBUyxDQUFDdzhFLG1CQUFtQixHQUFHLFNBQVNBO0lBQ2pFLE9BQU8sSUFBSSxDQUFDTixVQUFVO0FBQ3hCO0FBQ0FHLDBCQUEwQnI4RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDekQsT0FBTztRQUFDdTFCO0tBQXlCO0FBQ25DO0FBQ0FpbEQsMEJBQTBCcjhFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN0RCxPQUFPdTZFO0FBQ1Q7QUFFQSxJQUFJVSxtQkFBbUIsU0FBU0EsaUJBQWtCQyxLQUFLO0lBQ3JELElBQUksQ0FBQ0MsTUFBTSxHQUFHRCxTQUFTO0FBQ3pCO0FBQ0FELGlCQUFpQi84RSxTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVFDLElBQUk7SUFDdkQsSUFBSUEsZ0JBQWdCc1csU0FBUztRQUFFLElBQUksQ0FBQ3UrQyxNQUFNLENBQUNoeEUsR0FBRyxDQUFDbWM7SUFBTztBQUN4RDtBQUNBMjBELGlCQUFpQi84RSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDaEQsT0FBTztRQUFDczFCO0tBQWU7QUFDekI7QUFDQTRsRCxpQkFBaUIvOEUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLE9BQU9pN0U7QUFDVDtBQUNBQSxpQkFBaUJuZ0MsV0FBVyxHQUFHLFNBQVNBO0lBQ3RDLElBQUk5N0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSTJuQixPQUFPdG5CLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE9BQU9pOEUsaUJBQWlCbmdDLFdBQVcsQ0FBQ3gwQixNQUFNLElBQUlvRjtJQUNoRCxPQUFPLElBQUkxc0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWs1QixTQUFTNzRCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUk0d0QsT0FBTzV3RCxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJNjRCLGtCQUFrQitFLFNBQVM7WUFDN0JnekIsS0FBS3psRCxHQUFHLENBQUMwdEI7UUFDWCxPQUFPLElBQUlBLGtCQUFrQm5DLG9CQUFvQjtZQUMvQ21DLE9BQU9wZ0IsS0FBSyxDQUFDLElBQUl3akUsaUJBQWlCcnJCO1FBQ3BDO1FBQ0EsT0FBT0E7SUFDVDtBQUNGO0FBRUEsSUFBSXdyQiwyQkFBMkIsU0FBU0E7SUFDdEMsSUFBSSxDQUFDQyxNQUFNLEdBQUc7SUFDZCxJQUFJLENBQUNDLHFCQUFxQixHQUFHO0lBQzdCLElBQUl0OEUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSThiLFFBQVF6YixTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJLENBQUNxOEUsTUFBTSxHQUFHNWdFO0lBQ2hCLE9BQU8sSUFBSXpiLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk0OEUsVUFBVXY4RSxTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJdzhFLHVCQUF1Qng4RSxTQUFTLENBQUMsRUFBRTtRQUN2QyxJQUFJLENBQUNxOEUsTUFBTSxHQUFHRTtRQUNkLElBQUksQ0FBQ0QscUJBQXFCLEdBQUdFO0lBQy9CO0FBQ0Y7QUFDQUoseUJBQXlCbDlFLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUUMsSUFBSTtJQUMvRCxJQUFJLElBQUksQ0FBQ2cxRCxxQkFBcUIsSUFBSWgxRCxnQkFBZ0JnWSxZQUFZO1FBQzVELElBQUk5akIsT0FBTzhMLEtBQUtvQixVQUFVLEdBQUdyTixnQkFBZ0IsQ0FBQ2lNLEtBQUtnVyxxQkFBcUI7UUFDeEUsSUFBSSxDQUFDKytDLE1BQU0sQ0FBQ2x4RSxHQUFHLENBQUNxUTtRQUNoQixPQUFPO0lBQ1Q7SUFDQSxJQUFJOEwsZ0JBQWdCK1IsWUFBWTtRQUFFLElBQUksQ0FBQ2dqRCxNQUFNLENBQUNseEUsR0FBRyxDQUFDbWM7SUFBTztBQUMzRDtBQUNBODBELHlCQUF5Qmw5RSxTQUFTLENBQUN1OUUsb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCRCxvQkFBb0I7SUFDM0csSUFBSSxDQUFDRixxQkFBcUIsR0FBR0U7QUFDL0I7QUFDQUoseUJBQXlCbDlFLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4RCxPQUFPO1FBQUNxbUI7S0FBd0I7QUFDbEM7QUFDQWcxRCx5QkFBeUJsOUUsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JELE9BQU9vN0U7QUFDVDtBQUNBQSx5QkFBeUJyVSxXQUFXLEdBQUcsU0FBU0E7SUFDOUMsSUFBSS9uRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJMm5CLE9BQU90bkIsU0FBUyxDQUFDLEVBQUU7UUFDdkIsT0FBT3NuQixLQUFLb0IsVUFBVSxHQUFHeWIsYUFBYSxDQUFDaTRDLHlCQUF5Qk0sUUFBUSxDQUFDcDFEO0lBQzNFLE9BQU8sSUFBSXRuQixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJazVCLFNBQVM3NEIsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSTI4RSxvQkFBb0IzOEUsU0FBUyxDQUFDLEVBQUU7UUFDcEMsT0FBTzY0QixPQUFPblEsVUFBVSxHQUFHeWIsYUFBYSxDQUFDaTRDLHlCQUF5Qk0sUUFBUSxDQUFDN2pELFFBQVE4akQ7SUFDckY7QUFDRjtBQUNBUCx5QkFBeUJNLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxJQUFJMThFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkybkIsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtRQUN2QixPQUFPbzhFLHlCQUF5Qk0sUUFBUSxDQUFDcDFELE1BQU07SUFDakQsT0FBTyxJQUFJdG5CLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUkwRyxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRWdzQixlQUFlM2xCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFZ3NCLGFBQWE7WUFDcEYsSUFBSTR3RCxRQUFRNThFLFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUl1OEUsVUFBVXY4RSxTQUFTLENBQUMsRUFBRTtZQUMxQixJQUFLLElBQUlzRyxJQUFJczJFLE1BQU1yeUQsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO2dCQUMzQyxJQUFJMUIsSUFBSXppQixFQUFFc2dCLElBQUk7Z0JBQ2R3MUQseUJBQXlCTSxRQUFRLENBQUMzekQsR0FBR3d6RDtZQUN2QztZQUNBLE9BQU9BO1FBQ1QsT0FBTyxJQUFJdjhFLFNBQVMsQ0FBQyxFQUFFLFlBQVl1bkIsWUFBWSxPQUFPdm5CLFNBQVMsQ0FBQyxFQUFFLEtBQUssV0FBVztZQUNoRixJQUFJNjRCLFNBQVM3NEIsU0FBUyxDQUFDLEVBQUU7WUFDekIsSUFBSTI4RSxvQkFBb0IzOEUsU0FBUyxDQUFDLEVBQUU7WUFDcEMsSUFBSXliLFFBQVEsSUFBSWlSO1lBQ2hCbU0sT0FBT3BnQixLQUFLLENBQUMsSUFBSTJqRSx5QkFBeUIzZ0UsT0FBT2toRTtZQUNqRCxPQUFPbGhFO1FBQ1QsT0FBTyxJQUFJemIsU0FBUyxDQUFDLEVBQUUsWUFBWXVuQixZQUFZbGhCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFZ3NCLGFBQWE7WUFDckYsSUFBSTZ3RCxTQUFTNzhFLFNBQVMsQ0FBQyxFQUFFO1lBQ3pCLElBQUk4OEUsVUFBVTk4RSxTQUFTLENBQUMsRUFBRTtZQUMxQixJQUFJNjhFLGtCQUFrQnhqRCxZQUFZO2dCQUNoQ3lqRCxRQUFRM3hFLEdBQUcsQ0FBQzB4RTtZQUNkLE9BQU87Z0JBQ0xBLE9BQU9wa0UsS0FBSyxDQUFDLElBQUkyakUseUJBQXlCVTtZQUM1QztZQUNBLE9BQU9BO1FBQ1Q7SUFDRixPQUFPLElBQUk5OEUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSSxPQUFPSyxTQUFTLENBQUMsRUFBRSxLQUFLLGFBQWNxRyxhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRWdzQixlQUFlM2xCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFZ3NCLGFBQWM7WUFDM0gsSUFBSSt3RCxVQUFVLzhFLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLElBQUlnOUUsVUFBVWg5RSxTQUFTLENBQUMsRUFBRTtZQUMxQixJQUFJaTlFLHNCQUFzQmo5RSxTQUFTLENBQUMsRUFBRTtZQUN0QyxJQUFLLElBQUk4a0IsTUFBTWk0RCxRQUFReHlELFFBQVEsSUFBSXpGLElBQUkyRixPQUFPLElBQUs7Z0JBQ2pELElBQUk1QixNQUFNL0QsSUFBSThCLElBQUk7Z0JBQ2xCdzFELHlCQUF5Qk0sUUFBUSxDQUFDN3pELEtBQUttMEQsU0FBU0M7WUFDbEQ7WUFDQSxPQUFPRDtRQUNULE9BQU8sSUFBSSxPQUFPaDlFLFNBQVMsQ0FBQyxFQUFFLEtBQUssYUFBY0EsU0FBUyxDQUFDLEVBQUUsWUFBWXVuQixZQUFZbGhCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFZ3NCLGFBQWM7WUFDNUgsSUFBSWt4RCxTQUFTbDlFLFNBQVMsQ0FBQyxFQUFFO1lBQ3pCLElBQUltOUUsVUFBVW45RSxTQUFTLENBQUMsRUFBRTtZQUMxQixJQUFJbzlFLHNCQUFzQnA5RSxTQUFTLENBQUMsRUFBRTtZQUN0Q2s5RSxPQUFPemtFLEtBQUssQ0FBQyxJQUFJMmpFLHlCQUF5QmUsU0FBU0M7WUFDbkQsT0FBT0Q7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxJQUFJRSxlQUFlLFNBQVNBO0lBQzFCLElBQUksQ0FBQ0MsYUFBYSxHQUFHbnlELGlCQUFpQlUscUJBQXFCO0lBQzNELElBQUksQ0FBQzB4RCxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixJQUFJeDlFLFVBQVVMLE1BQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJSyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUM5RCxJQUFJODlFLGVBQWV6OUUsU0FBUyxDQUFDLEVBQUU7UUFDL0IsSUFBSXk5RSxpQkFBaUIsTUFBTTtZQUFFLE1BQU0sSUFBSW44RSx5QkFBeUI7UUFBeUI7UUFDekYsSUFBSSxDQUFDZzhFLGFBQWEsR0FBR0c7SUFDdkI7QUFDRjtBQUNBSixhQUFhbitFLFNBQVMsQ0FBQ3crRSxjQUFjLEdBQUcsU0FBU0E7SUFDN0MsSUFBSWxrRSxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxjQUFjNUMsU0FBUyxDQUFDLEVBQUUsWUFBWTQ5QixTQUFTO1FBQ3pFLElBQUkxcEIsSUFBSWxVLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUl3K0IsT0FBT3grQixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJdytCLEtBQUt4bEIsT0FBTyxJQUFJO1lBQUUsT0FBT25ULFNBQVNJLFFBQVE7UUFBQztRQUMvQyxJQUFJNlYsUUFBUTBpQixLQUFLRSxlQUFlO1FBQ2hDLElBQUlpL0MsV0FBVyxJQUFJLENBQUNDLG1CQUFtQixDQUFDMXBFLEdBQUc0SDtRQUMzQyxJQUFJNmhFLGFBQWE5M0UsU0FBU0ksUUFBUSxFQUFFO1lBQUUsT0FBT0osU0FBU0ksUUFBUTtRQUFDO1FBQy9ELElBQUkwM0UsYUFBYTkzRSxTQUFTRyxRQUFRLEVBQUU7WUFBRSxPQUFPSCxTQUFTRyxRQUFRO1FBQUM7UUFDL0QsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlrNEIsS0FBS1Ysa0JBQWtCLElBQUl4M0IsSUFBSztZQUNsRCxJQUFJdzZCLE9BQU90QyxLQUFLVSxnQkFBZ0IsQ0FBQzU0QjtZQUNqQyxJQUFJdTNFLFVBQVVya0UsT0FBT29rRSxtQkFBbUIsQ0FBQzFwRSxHQUFHNHNCO1lBQzVDLElBQUkrOEMsWUFBWWg0RSxTQUFTRSxRQUFRLEVBQUU7Z0JBQUUsT0FBT0YsU0FBU0ksUUFBUTtZQUFDO1lBQzlELElBQUk0M0UsWUFBWWg0RSxTQUFTRyxRQUFRLEVBQUU7Z0JBQUUsT0FBT0gsU0FBU0csUUFBUTtZQUFDO1FBQ2hFO1FBQ0EsT0FBT0gsU0FBU0UsUUFBUTtJQUMxQixPQUFPLElBQUkvRixTQUFTLENBQUMsRUFBRSxZQUFZNEMsY0FBYzVDLFNBQVMsQ0FBQyxFQUFFLFlBQVlxNUIsWUFBWTtRQUNuRixJQUFJMVUsTUFBTTNrQixTQUFTLENBQUMsRUFBRTtRQUN0QixJQUFJdTBCLElBQUl2MEIsU0FBUyxDQUFDLEVBQUU7UUFDcEIsSUFBSSxDQUFDdTBCLEVBQUUxSyxtQkFBbUIsR0FBRzFULFVBQVUsQ0FBQ3dPLE1BQU07WUFBRSxPQUFPOWUsU0FBU0ksUUFBUTtRQUFDO1FBQ3pFLElBQUk4WixLQUFLd1UsRUFBRXFDLGNBQWM7UUFDekIsSUFBSSxDQUFDckMsRUFBRTRELFFBQVEsSUFBSTtZQUNqQixJQUFJeFQsSUFBSTlnQixNQUFNLENBQUNrYyxFQUFFLENBQUMsRUFBRSxLQUFLNEUsSUFBSTlnQixNQUFNLENBQUNrYyxFQUFFLENBQUNBLEdBQUdwZ0IsTUFBTSxHQUFHLEVBQUUsR0FBRztnQkFDdEQsT0FBT2tHLFNBQVNHLFFBQVE7WUFDMUI7UUFDRjtRQUNBLElBQUkwYSxhQUFhd0csUUFBUSxDQUFDdkMsS0FBSzVFLEtBQUs7WUFBRSxPQUFPbGEsU0FBU0UsUUFBUTtRQUFDO1FBQy9ELE9BQU9GLFNBQVNJLFFBQVE7SUFDMUIsT0FBTyxJQUFJakcsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLGNBQWM1QyxTQUFTLENBQUMsRUFBRSxZQUFZMDlCLE9BQU87UUFDOUUsSUFBSW9nRCxNQUFNOTlFLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUkyNkUsT0FBTzM2RSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJKzlFLFVBQVVwRCxLQUFLN25FLGFBQWE7UUFDaEMsSUFBSWlyRSxRQUFRdDZFLFFBQVEsQ0FBQ3E2RSxNQUFNO1lBQUUsT0FBT2o0RSxTQUFTRSxRQUFRO1FBQUM7UUFDdEQsT0FBT0YsU0FBU0ksUUFBUTtJQUMxQjtBQUNGO0FBQ0FvM0UsYUFBYW4rRSxTQUFTLENBQUMwK0UsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCMXBFLENBQUMsRUFBRTBILElBQUk7SUFDaEYsSUFBSSxDQUFDQSxLQUFLaU8sbUJBQW1CLEdBQUcxVCxVQUFVLENBQUNqQyxJQUFJO1FBQUUsT0FBT3JPLFNBQVNJLFFBQVE7SUFBQztJQUMxRSxPQUFPeWEsYUFBYStELGlCQUFpQixDQUFDdlEsR0FBRzBILEtBQUtnYixjQUFjO0FBQzlEO0FBQ0F5bUQsYUFBYW4rRSxTQUFTLENBQUNpWCxVQUFVLEdBQUcsU0FBU0EsV0FBWWpDLENBQUMsRUFBRW9ULElBQUk7SUFDOUQsT0FBTyxJQUFJLENBQUMyK0MsTUFBTSxDQUFDL3hELEdBQUdvVCxVQUFVemhCLFNBQVNJLFFBQVE7QUFDbkQ7QUFDQW8zRSxhQUFhbitFLFNBQVMsQ0FBQzgrRSxrQkFBa0IsR0FBRyxTQUFTQSxtQkFBb0Jqd0MsR0FBRztJQUMxRSxJQUFJQSxRQUFRbG9DLFNBQVNFLFFBQVEsRUFBRTtRQUFFLElBQUksQ0FBQ3czRSxLQUFLLEdBQUc7SUFBTTtJQUNwRCxJQUFJeHZDLFFBQVFsb0MsU0FBU0csUUFBUSxFQUFFO1FBQUUsSUFBSSxDQUFDdzNFLGNBQWM7SUFBSTtBQUMxRDtBQUNBSCxhQUFhbitFLFNBQVMsQ0FBQysrRSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCL3BFLENBQUMsRUFBRW9ULElBQUk7SUFDdEUsSUFBSTlOLFNBQVMsSUFBSTtJQUVuQixJQUFJOE4sZ0JBQWdCb1csT0FBTztRQUN6QixJQUFJLENBQUNzZ0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDTixjQUFjLENBQUN4cEUsR0FBR29UO0lBQ2pEO0lBQ0EsSUFBSUEsZ0JBQWdCK1IsWUFBWTtRQUM5QixJQUFJLENBQUMya0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDTixjQUFjLENBQUN4cEUsR0FBR29UO0lBQ2pELE9BQU8sSUFBSUEsZ0JBQWdCc1csU0FBUztRQUNsQyxJQUFJLENBQUNvZ0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDTixjQUFjLENBQUN4cEUsR0FBR29UO0lBQ2pELE9BQU8sSUFBSUEsZ0JBQWdCMlEsaUJBQWlCO1FBQzFDLElBQUlpbUQsS0FBSzUyRDtRQUNULElBQUssSUFBSWhoQixJQUFJLEdBQUdBLElBQUk0M0UsR0FBRzUwRCxnQkFBZ0IsSUFBSWhqQixJQUFLO1lBQzlDLElBQUlpdUIsSUFBSTJwRCxHQUFHdjFELFlBQVksQ0FBQ3JpQjtZQUN4QmtULE9BQU93a0Usa0JBQWtCLENBQUN4a0UsT0FBT2trRSxjQUFjLENBQUN4cEUsR0FBR3FnQjtRQUNyRDtJQUNGLE9BQU8sSUFBSWpOLGdCQUFnQnFZLGNBQWM7UUFDdkMsSUFBSXcrQyxRQUFRNzJEO1FBQ1osSUFBSyxJQUFJeEMsTUFBTSxHQUFHQSxNQUFNcTVELE1BQU03MEQsZ0JBQWdCLElBQUl4RSxNQUFPO1lBQ3ZELElBQUkwWixPQUFPMi9DLE1BQU14MUQsWUFBWSxDQUFDN0Q7WUFDOUJ0TCxPQUFPd2tFLGtCQUFrQixDQUFDeGtFLE9BQU9ra0UsY0FBYyxDQUFDeHBFLEdBQUdzcUI7UUFDckQ7SUFDRixPQUFPLElBQUlsWCxnQkFBZ0JvUCxvQkFBb0I7UUFDN0MsSUFBSWd3QyxRQUFRLElBQUlSLDJCQUEyQjUrQztRQUMzQyxNQUFPby9DLE1BQU1qOEMsT0FBTyxHQUFJO1lBQ3RCLElBQUlrOEMsS0FBS0QsTUFBTTkvQyxJQUFJO1lBQ25CLElBQUkrL0MsT0FBT3IvQyxNQUFNO2dCQUFFOU4sT0FBT3lrRSxlQUFlLENBQUMvcEUsR0FBR3l5RDtZQUFLO1FBQ3BEO0lBQ0Y7QUFDRjtBQUNBMFcsYUFBYW4rRSxTQUFTLENBQUMrbUUsTUFBTSxHQUFHLFNBQVNBLE9BQVEveEQsQ0FBQyxFQUFFb1QsSUFBSTtJQUN0RCxJQUFJQSxLQUFLdE8sT0FBTyxJQUFJO1FBQUUsT0FBT25ULFNBQVNJLFFBQVE7SUFBQztJQUMvQyxJQUFJcWhCLGdCQUFnQitSLFlBQVk7UUFDOUIsT0FBTyxJQUFJLENBQUNxa0QsY0FBYyxDQUFDeHBFLEdBQUdvVDtJQUNoQyxPQUFPLElBQUlBLGdCQUFnQnNXLFNBQVM7UUFDbEMsT0FBTyxJQUFJLENBQUM4L0MsY0FBYyxDQUFDeHBFLEdBQUdvVDtJQUNoQztJQUNBLElBQUksQ0FBQ2kyRCxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNTLGVBQWUsQ0FBQy9wRSxHQUFHb1Q7SUFDeEIsSUFBSSxJQUFJLENBQUNnMkQsYUFBYSxDQUFDeHhELFlBQVksQ0FBQyxJQUFJLENBQUMweEQsY0FBYyxHQUFHO1FBQUUsT0FBTzMzRSxTQUFTRyxRQUFRO0lBQUM7SUFDckYsSUFBSSxJQUFJLENBQUN3M0UsY0FBYyxHQUFHLEtBQUssSUFBSSxDQUFDRCxLQUFLLEVBQUU7UUFBRSxPQUFPMTNFLFNBQVNFLFFBQVE7SUFBQztJQUN0RSxPQUFPRixTQUFTSSxRQUFRO0FBQzFCO0FBQ0FvM0UsYUFBYW4rRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxFQUFFO0FBQ1g7QUFDQXM4RSxhQUFhbitFLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPcThFO0FBQ1Q7QUFFQSxJQUFJZSxtQkFBbUIsU0FBU0E7SUFDOUIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDMUssR0FBRyxHQUFHO0lBQ1gsSUFBSTV6RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJNCtFLFlBQVl2K0UsU0FBUyxDQUFDLEVBQUU7UUFDNUIsSUFBSStmLEtBQUsvZixTQUFTLENBQUMsRUFBRTtRQUNyQm8rRSxpQkFBaUIzOEUsSUFBSSxDQUFDLElBQUksRUFBRTg4RSxXQUFXSCxpQkFBaUJJLFdBQVcsRUFBRXorRDtJQUN2RSxPQUFPLElBQUkvZixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJOCtFLGNBQWN6K0UsU0FBUyxDQUFDLEVBQUU7UUFDOUIsSUFBSXExRSxXQUFXcjFFLFNBQVMsQ0FBQyxFQUFFO1FBQzNCLElBQUkyNkUsT0FBTzM2RSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJLENBQUNxK0UsVUFBVSxHQUFHSTtRQUNsQixJQUFJLENBQUNILFNBQVMsR0FBR2pKO1FBQ2pCLElBQUksQ0FBQ3pCLEdBQUcsR0FBRytHO0lBQ2I7QUFDRjtBQUVBLElBQUkrRCxxQkFBcUI7SUFBRUYsYUFBYTtRQUFFbi9FLGNBQWM7SUFBSztBQUFFO0FBQy9EKytFLGlCQUFpQmwvRSxTQUFTLENBQUN5L0UsWUFBWSxHQUFHLFNBQVNBO0lBQ2pELE9BQU8sSUFBSSxDQUFDTCxTQUFTLEtBQUtGLGlCQUFpQkksV0FBVztBQUN4RDtBQUNBSixpQkFBaUJsL0UsU0FBUyxDQUFDNFQsYUFBYSxHQUFHLFNBQVNBO0lBQ2xELE9BQU8sSUFBSSxDQUFDOGdFLEdBQUc7QUFDakI7QUFDQXdLLGlCQUFpQmwvRSxTQUFTLENBQUMwL0Usb0JBQW9CLEdBQUcsU0FBU0E7SUFDekQsT0FBTyxJQUFJLENBQUNQLFVBQVU7QUFDeEI7QUFDQUQsaUJBQWlCbC9FLFNBQVMsQ0FBQ2d1RSxlQUFlLEdBQUcsU0FBU0E7SUFDcEQsT0FBTyxJQUFJLENBQUNvUixTQUFTO0FBQ3ZCO0FBQ0FGLGlCQUFpQmwvRSxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDaEQsT0FBTyxFQUFFO0FBQ1g7QUFDQXE5RSxpQkFBaUJsL0UsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLE9BQU9vOUU7QUFDVDtBQUNBTSxtQkFBbUJGLFdBQVcsQ0FBQ2w4RSxHQUFHLEdBQUc7SUFBYyxPQUFPLENBQUM7QUFBRTtBQUU3RG5ELE9BQU9vRCxnQkFBZ0IsQ0FBRTY3RSxrQkFBa0JNO0FBRTNDLElBQUlHLGlCQUFpQixTQUFTQSxlQUFnQjE0RCxHQUFHO0lBQy9DLElBQUksQ0FBQ29wQixJQUFJLEdBQUdwcEIsT0FBTztBQUNyQjtBQUNBMDRELGVBQWUzL0UsU0FBUyxDQUFDbW9CLE1BQU0sR0FBRyxTQUFTQSxPQUFRQyxJQUFJO0lBQ3JELElBQUlBLGdCQUFnQm9XLE9BQU87UUFBRSxJQUFJLENBQUM2UixJQUFJLENBQUNwa0MsR0FBRyxDQUFDbWM7SUFBTztBQUNwRDtBQUNBdTNELGVBQWUzL0UsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlDLE9BQU87UUFBQ3MxQjtLQUFlO0FBQ3pCO0FBQ0F3b0QsZUFBZTMvRSxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDM0MsT0FBTzY5RTtBQUNUO0FBQ0FBLGVBQWVDLFNBQVMsR0FBRyxTQUFTQTtJQUNsQyxJQUFJOStFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkybkIsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJc25CLGdCQUFnQm9XLE9BQU87WUFDekIsT0FBTzZnQixZQUFZRyxhQUFhLENBQUNwM0I7UUFDbkM7UUFDQSxPQUFPdTNELGVBQWVDLFNBQVMsQ0FBQ3gzRCxNQUFNLElBQUlvRjtJQUM1QyxPQUFPLElBQUkxc0IsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSWs1QixTQUFTNzRCLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUk0d0QsT0FBTzV3RCxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJNjRCLGtCQUFrQjZFLE9BQU87WUFDM0JrekIsS0FBS3psRCxHQUFHLENBQUMwdEI7UUFDWCxPQUFPLElBQUlBLGtCQUFrQm5DLG9CQUFvQjtZQUMvQ21DLE9BQU9wZ0IsS0FBSyxDQUFDLElBQUlvbUUsZUFBZWp1QjtRQUNsQztRQUNBLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLElBQUltdUIsaUNBQWlDLFNBQVNBO0lBQzVDLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUlDLFlBQVlqL0UsU0FBUyxDQUFDLEVBQUU7SUFDNUIsSUFBSSxDQUFDZy9FLFVBQVUsR0FBR0M7QUFDcEI7QUFDQUYsK0JBQStCNy9FLFNBQVMsQ0FBQ21vQixNQUFNLEdBQUcsU0FBU0EsT0FBUUMsSUFBSTtJQUNyRSxJQUFJQSxnQkFBZ0JvVyxTQUFTcFcsZ0JBQWdCK1IsY0FBYy9SLGdCQUFnQnNXLFNBQVM7UUFBRSxJQUFJLENBQUNvaEQsVUFBVSxDQUFDN3pFLEdBQUcsQ0FBQyxJQUFJaXpFLGlCQUFpQjkyRCxNQUFNLEdBQUdBLEtBQUt4VSxhQUFhO0lBQU07QUFDbEs7QUFDQWlzRSwrQkFBK0I3L0UsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzlELE9BQU87UUFBQ3MxQjtLQUFlO0FBQ3pCO0FBQ0Ewb0QsK0JBQStCNy9FLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzRCxPQUFPKzlFO0FBQ1Q7QUFDQUEsK0JBQStCNXhDLFlBQVksR0FBRyxTQUFTQSxhQUFjN2xCLElBQUk7SUFDdkUsSUFBSTIzRCxZQUFZLElBQUl2eUQ7SUFDcEJwRixLQUFLN08sS0FBSyxDQUFDLElBQUlzbUUsK0JBQStCRTtJQUM5QyxPQUFPQTtBQUNUO0FBRUEsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJLENBQUMxbUQsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDMm1ELGtCQUFrQixHQUFHO0lBQzFCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUkvQjtJQUN0QixJQUFJLENBQUNnQyxvQkFBb0IsR0FBRztJQUM1QixJQUFJLENBQUNDLFlBQVksR0FBR3Y5RSxPQUFPRSxTQUFTO0lBQ3BDLElBQUlqQyxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJNC9FLEtBQUt2L0UsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXcvRSxLQUFLeC9FLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUksQ0FBQ3c0QixLQUFLLEdBQUc7WUFBQyttRDtZQUFJQztTQUFHO1FBQ3JCLElBQUksQ0FBQ0wsa0JBQWtCLEdBQUc7SUFDNUIsT0FBTyxJQUFJbi9FLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk4L0UsT0FBT3ovRSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJMC9FLE9BQU8xL0UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTIvRSxvQkFBb0IzL0UsU0FBUyxDQUFDLEVBQUU7UUFDcEMsSUFBSSxDQUFDdzRCLEtBQUssR0FBRyxJQUFJdjVCLE1BQU0sR0FBR00sSUFBSSxDQUFDO1FBQy9CLElBQUksQ0FBQ2k1QixLQUFLLENBQUMsRUFBRSxHQUFHaW5EO1FBQ2hCLElBQUksQ0FBQ2puRCxLQUFLLENBQUMsRUFBRSxHQUFHa25EO1FBQ2hCLElBQUksQ0FBQ1Asa0JBQWtCLEdBQUdRO0lBQzVCO0FBQ0Y7QUFDQVQsV0FBV2hnRixTQUFTLENBQUMwZ0YsMEJBQTBCLEdBQUcsU0FBU0E7SUFDdkQsSUFBSXBtRSxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlrZ0YsWUFBWSxJQUFJNWdGLE1BQU0sR0FBR00sSUFBSSxDQUFDO1FBQ2xDLElBQUksQ0FBQ3FnRiwwQkFBMEIsQ0FBQyxHQUFHQztRQUNuQyxJQUFJLElBQUksQ0FBQ1AsWUFBWSxJQUFJLElBQUksQ0FBQ0gsa0JBQWtCLEVBQUU7WUFBRSxPQUFPO1FBQUs7UUFDaEUsSUFBSSxDQUFDUywwQkFBMEIsQ0FBQyxHQUFHQztJQUNyQyxPQUFPLElBQUk3L0UsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSW1nRixnQkFBZ0I5L0UsU0FBUyxDQUFDLEVBQUU7UUFDaEMsSUFBSSsvRSxjQUFjLy9FLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUlnZ0YsaUJBQWlCLElBQUlGO1FBQ3pCLElBQUlHLFFBQVFoRSxpQkFBaUJuZ0MsV0FBVyxDQUFDLElBQUksQ0FBQ3RqQixLQUFLLENBQUNzbkQsY0FBYztRQUNsRSxJQUFJRyxNQUFNcHRFLElBQUksS0FBSyxHQUFHO1lBQ3BCLElBQUlxdEUsYUFBYW5CLCtCQUErQjV4QyxZQUFZLENBQUMsSUFBSSxDQUFDM1UsS0FBSyxDQUFDd25ELGVBQWU7WUFDdkYsSUFBSSxDQUFDSiwwQkFBMEIsQ0FBQ00sWUFBWUQsT0FBT0Y7WUFDbkQsSUFBSSxJQUFJLENBQUNULFlBQVksSUFBSSxJQUFJLENBQUNILGtCQUFrQixFQUFFO2dCQUNoRCxJQUFJLENBQUNFLG9CQUFvQixDQUFDVyxlQUFlLEdBQUdELFdBQVcsQ0FBQyxFQUFFO2dCQUMxRCxJQUFJLENBQUNWLG9CQUFvQixDQUFDUyxjQUFjLEdBQUdDLFdBQVcsQ0FBQyxFQUFFO2dCQUN6RCxPQUFPO1lBQ1Q7UUFDRjtJQUNGLE9BQU8sSUFBSS8vRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJSyxTQUFTLENBQUMsRUFBRSxZQUFZZixTQUFVb0gsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVzc0IsU0FBU2ptQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRXNzQixPQUFRO1lBQzNHLElBQUk2ekQsT0FBT25nRixTQUFTLENBQUMsRUFBRTtZQUN2QixJQUFJb2dGLFVBQVVwZ0YsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSXFnRixjQUFjcmdGLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLElBQUssSUFBSXNHLElBQUksR0FBR0EsSUFBSTY1RSxLQUFLdHRFLElBQUksSUFBSXZNLElBQUs7Z0JBQ3BDLElBQUl5bkMsTUFBTW95QyxLQUFLNzlFLEdBQUcsQ0FBQ2dFO2dCQUNuQixJQUFLLElBQUlra0IsSUFBSSxHQUFHQSxJQUFJNDFELFFBQVF2dEUsSUFBSSxJQUFJMlgsSUFBSztvQkFDdkNoUixPQUFPb21FLDBCQUEwQixDQUFDN3hDLEtBQUtxeUMsUUFBUTk5RSxHQUFHLENBQUNrb0IsSUFBSTYxRDtvQkFDdkQsSUFBSTdtRSxPQUFPOGxFLFlBQVksSUFBSTlsRSxPQUFPMmxFLGtCQUFrQixFQUFFO3dCQUFFLE9BQU87b0JBQUs7Z0JBQ3RFO1lBQ0Y7UUFDRixPQUFPLElBQUluL0UsU0FBUyxDQUFDLEVBQUUsWUFBWWYsU0FBVWUsU0FBUyxDQUFDLEVBQUUsWUFBWW8rRSxvQkFBb0JwK0UsU0FBUyxDQUFDLEVBQUUsWUFBWTQ5QixTQUFVO1lBQ3pILElBQUkwaUQsUUFBUXRnRixTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJdytCLE9BQU94K0IsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSXVnRixjQUFjdmdGLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLElBQUkrZixLQUFLdWdFLE1BQU14dEUsYUFBYTtZQUM1QixJQUFJak4sU0FBU0ksUUFBUSxLQUFLLElBQUksQ0FBQ201RSxVQUFVLENBQUNuWixNQUFNLENBQUNsbUQsSUFBSXllLE9BQU87Z0JBQzFELElBQUksQ0FBQzhnRCxZQUFZLEdBQUc7Z0JBQ3BCaUIsV0FBVyxDQUFDLEVBQUUsR0FBR0Q7Z0JBQ2pCQyxXQUFXLENBQUMsRUFBRSxHQUFHLElBQUluQyxpQkFBaUI1L0MsTUFBTXplO2dCQUU1QyxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUFDQW0vRCxXQUFXaGdGLFNBQVMsQ0FBQ3NoRiw2QkFBNkIsR0FBRyxTQUFTQSw4QkFBK0Iva0UsS0FBSyxFQUFFUCxNQUFNLEVBQUV1bEUsT0FBTztJQUMvRyxJQUFJam5FLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUltVixNQUFNNUksSUFBSSxJQUFJdk0sSUFBSztRQUNyQyxJQUFJa1YsT0FBT0MsTUFBTW5aLEdBQUcsQ0FBQ2dFO1FBQ3JCLElBQUssSUFBSWtrQixJQUFJLEdBQUdBLElBQUl0UCxPQUFPckksSUFBSSxJQUFJMlgsSUFBSztZQUN0QyxJQUFJekssS0FBSzdFLE9BQU81WSxHQUFHLENBQUNrb0I7WUFDcEJoUixPQUFPa25FLGtCQUFrQixDQUFDbGxFLE1BQU11RSxJQUFJMGdFO1lBQ3BDLElBQUlqbkUsT0FBTzhsRSxZQUFZLElBQUk5bEUsT0FBTzJsRSxrQkFBa0IsRUFBRTtnQkFBRSxPQUFPO1lBQUs7UUFDdEU7SUFDRjtBQUNGO0FBQ0FELFdBQVdoZ0YsU0FBUyxDQUFDeWhGLG9CQUFvQixHQUFHLFNBQVNBO0lBQ25ELElBQUlGLFVBQVUsSUFBSXhoRixNQUFNLEdBQUdNLElBQUksQ0FBQztJQUNoQyxJQUFJcWhGLFNBQVN4RSx5QkFBeUJNLFFBQVEsQ0FBQyxJQUFJLENBQUNsa0QsS0FBSyxDQUFDLEVBQUU7SUFDNUQsSUFBSXFvRCxTQUFTekUseUJBQXlCTSxRQUFRLENBQUMsSUFBSSxDQUFDbGtELEtBQUssQ0FBQyxFQUFFO0lBQzVELElBQUkrNkMsT0FBT3NMLGVBQWVDLFNBQVMsQ0FBQyxJQUFJLENBQUN0bUQsS0FBSyxDQUFDLEVBQUU7SUFDakQsSUFBSXpILE9BQU84dEQsZUFBZUMsU0FBUyxDQUFDLElBQUksQ0FBQ3RtRCxLQUFLLENBQUMsRUFBRTtJQUNqRCxJQUFJLENBQUNzb0QsdUJBQXVCLENBQUNGLFFBQVFDLFFBQVFKO0lBQzdDLElBQUksQ0FBQ00saUJBQWlCLENBQUNOLFNBQVM7SUFDaEMsSUFBSSxJQUFJLENBQUNuQixZQUFZLElBQUksSUFBSSxDQUFDSCxrQkFBa0IsRUFBRTtRQUFFLE9BQU87SUFBSztJQUNoRXNCLE9BQU8sQ0FBQyxFQUFFLEdBQUc7SUFDYkEsT0FBTyxDQUFDLEVBQUUsR0FBRztJQUNiLElBQUksQ0FBQ0QsNkJBQTZCLENBQUNJLFFBQVE3dkQsTUFBTTB2RDtJQUNqRCxJQUFJLENBQUNNLGlCQUFpQixDQUFDTixTQUFTO0lBQ2hDLElBQUksSUFBSSxDQUFDbkIsWUFBWSxJQUFJLElBQUksQ0FBQ0gsa0JBQWtCLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDaEVzQixPQUFPLENBQUMsRUFBRSxHQUFHO0lBQ2JBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7SUFDYixJQUFJLENBQUNELDZCQUE2QixDQUFDSyxRQUFRdE4sTUFBTWtOO0lBQ2pELElBQUksQ0FBQ00saUJBQWlCLENBQUNOLFNBQVM7SUFDaEMsSUFBSSxJQUFJLENBQUNuQixZQUFZLElBQUksSUFBSSxDQUFDSCxrQkFBa0IsRUFBRTtRQUFFLE9BQU87SUFBSztJQUNoRXNCLE9BQU8sQ0FBQyxFQUFFLEdBQUc7SUFDYkEsT0FBTyxDQUFDLEVBQUUsR0FBRztJQUNiLElBQUksQ0FBQ08sd0JBQXdCLENBQUN6TixNQUFNeGlELE1BQU0wdkQ7SUFDMUMsSUFBSSxDQUFDTSxpQkFBaUIsQ0FBQ04sU0FBUztBQUNsQztBQUNBdkIsV0FBV2hnRixTQUFTLENBQUMraEYsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDL0MsSUFBSSxDQUFDUCxrQkFBa0I7SUFDdkIsT0FBTyxJQUFJLENBQUNyQixvQkFBb0I7QUFDbEM7QUFDQUgsV0FBV2hnRixTQUFTLENBQUM2aEYsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CTixPQUFPLEVBQUVyekMsSUFBSTtJQUNoRixJQUFJcXpDLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTTtRQUFFLE9BQU87SUFBSztJQUN2QyxJQUFJcnpDLE1BQU07UUFDUixJQUFJLENBQUNpeUMsb0JBQW9CLENBQUMsRUFBRSxHQUFHb0IsT0FBTyxDQUFDLEVBQUU7UUFDekMsSUFBSSxDQUFDcEIsb0JBQW9CLENBQUMsRUFBRSxHQUFHb0IsT0FBTyxDQUFDLEVBQUU7SUFDM0MsT0FBTztRQUNMLElBQUksQ0FBQ3BCLG9CQUFvQixDQUFDLEVBQUUsR0FBR29CLE9BQU8sQ0FBQyxFQUFFO1FBQ3pDLElBQUksQ0FBQ3BCLG9CQUFvQixDQUFDLEVBQUUsR0FBR29CLE9BQU8sQ0FBQyxFQUFFO0lBQzNDO0FBQ0Y7QUFDQXZCLFdBQVdoZ0YsU0FBUyxDQUFDZ2lGLGFBQWEsR0FBRyxTQUFTQTtJQUM1QyxJQUFJLENBQUNSLGtCQUFrQjtJQUN2QixJQUFJUyxhQUFhO1FBQUMsSUFBSSxDQUFDOUIsb0JBQW9CLENBQUMsRUFBRSxDQUFDdnNFLGFBQWE7UUFBSSxJQUFJLENBQUN1c0Usb0JBQW9CLENBQUMsRUFBRSxDQUFDdnNFLGFBQWE7S0FBRztJQUM3RyxPQUFPcXVFO0FBQ1Q7QUFDQWpDLFdBQVdoZ0YsU0FBUyxDQUFDd2hGLGtCQUFrQixHQUFHLFNBQVNBO0lBQy9DLElBQUlsbkUsU0FBUyxJQUFJO0lBRW5CLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLElBQUksQ0FBQzAvRSxvQkFBb0IsS0FBSyxNQUFNO1lBQUUsT0FBTztRQUFLO1FBQ3RELElBQUksQ0FBQ0Esb0JBQW9CLEdBQUcsSUFBSXBnRixNQUFNLEdBQUdNLElBQUksQ0FBQztRQUM5QyxJQUFJLENBQUNxZ0YsMEJBQTBCO1FBQy9CLElBQUksSUFBSSxDQUFDTixZQUFZLElBQUksSUFBSSxDQUFDSCxrQkFBa0IsRUFBRTtZQUFFLE9BQU87UUFBSztRQUNoRSxJQUFJLENBQUN3QixvQkFBb0I7SUFDM0IsT0FBTyxJQUFJM2dGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUlLLFNBQVMsQ0FBQyxFQUFFLFlBQVlmLFNBQVVlLFNBQVMsQ0FBQyxFQUFFLFlBQVlxNUIsY0FBY3I1QixTQUFTLENBQUMsRUFBRSxZQUFZMDlCLE9BQVE7WUFDMUcsSUFBSWxpQixPQUFPeGIsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSStmLEtBQUsvZixTQUFTLENBQUMsRUFBRTtZQUNyQixJQUFJeWdGLFVBQVV6Z0YsU0FBUyxDQUFDLEVBQUU7WUFDMUIsSUFBSXdiLEtBQUtxTyxtQkFBbUIsR0FBR3BsQixRQUFRLENBQUNzYixHQUFHOEosbUJBQW1CLE1BQU0sSUFBSSxDQUFDeTFELFlBQVksRUFBRTtnQkFBRSxPQUFPO1lBQUs7WUFDckcsSUFBSThCLFNBQVM1bEUsS0FBS29iLGNBQWM7WUFDaEMsSUFBSTFMLFFBQVFuTCxHQUFHak4sYUFBYTtZQUM1QixJQUFLLElBQUl4TSxJQUFJLEdBQUdBLElBQUk4NkUsT0FBT3poRixNQUFNLEdBQUcsR0FBRzJHLElBQUs7Z0JBQzFDLElBQUlvWixPQUFPZ0IsYUFBYStDLGlCQUFpQixDQUFDeUgsT0FBT2syRCxNQUFNLENBQUM5NkUsRUFBRSxFQUFFODZFLE1BQU0sQ0FBQzk2RSxJQUFJLEVBQUU7Z0JBQ3pFLElBQUlvWixPQUFPbEcsT0FBTzhsRSxZQUFZLEVBQUU7b0JBQzlCOWxFLE9BQU84bEUsWUFBWSxHQUFHNS9EO29CQUN0QixJQUFJb3JDLE1BQU0sSUFBSUgsWUFBWXkyQixNQUFNLENBQUM5NkUsRUFBRSxFQUFFODZFLE1BQU0sQ0FBQzk2RSxJQUFJLEVBQUU7b0JBQ2xELElBQUkrNkUsa0JBQWtCdjJCLElBQUlpQixZQUFZLENBQUM3Z0M7b0JBQ3ZDdTFELE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSXJDLGlCQUFpQjVpRSxNQUFNbFYsR0FBRys2RTtvQkFDM0NaLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSXJDLGlCQUFpQnIrRCxJQUFJLEdBQUdtTDtnQkFDM0M7Z0JBQ0EsSUFBSTFSLE9BQU84bEUsWUFBWSxJQUFJOWxFLE9BQU8ybEUsa0JBQWtCLEVBQUU7b0JBQUUsT0FBTztnQkFBSztZQUN0RTtRQUNGLE9BQU8sSUFBSW4vRSxTQUFTLENBQUMsRUFBRSxZQUFZZixTQUFVZSxTQUFTLENBQUMsRUFBRSxZQUFZcTVCLGNBQWNyNUIsU0FBUyxDQUFDLEVBQUUsWUFBWXE1QixZQUFhO1lBQ3RILElBQUlpb0QsUUFBUXRoRixTQUFTLENBQUMsRUFBRTtZQUN4QixJQUFJdWhGLFFBQVF2aEYsU0FBUyxDQUFDLEVBQUU7WUFDeEIsSUFBSXdoRixZQUFZeGhGLFNBQVMsQ0FBQyxFQUFFO1lBQzVCLElBQUlzaEYsTUFBTXozRCxtQkFBbUIsR0FBR3BsQixRQUFRLENBQUM4OEUsTUFBTTEzRCxtQkFBbUIsTUFBTSxJQUFJLENBQUN5MUQsWUFBWSxFQUFFO2dCQUFFLE9BQU87WUFBSztZQUN6RyxJQUFJbUMsV0FBV0gsTUFBTTFxRCxjQUFjO1lBQ25DLElBQUkvRyxTQUFTMHhELE1BQU0zcUQsY0FBYztZQUNqQyxJQUFLLElBQUk5UixNQUFNLEdBQUdBLE1BQU0yOEQsU0FBUzloRixNQUFNLEdBQUcsR0FBR21sQixNQUFPO2dCQUNsRCxJQUFLLElBQUkwRixJQUFJLEdBQUdBLElBQUlxRixPQUFPbHdCLE1BQU0sR0FBRyxHQUFHNnFCLElBQUs7b0JBQzFDLElBQUlrM0QsU0FBU2hoRSxhQUFhZ0YsZ0JBQWdCLENBQUMrN0QsUUFBUSxDQUFDMzhELElBQUksRUFBRTI4RCxRQUFRLENBQUMzOEQsTUFBTSxFQUFFLEVBQUUrSyxNQUFNLENBQUNyRixFQUFFLEVBQUVxRixNQUFNLENBQUNyRixJQUFJLEVBQUU7b0JBQ3JHLElBQUlrM0QsU0FBU2xvRSxPQUFPOGxFLFlBQVksRUFBRTt3QkFDaEM5bEUsT0FBTzhsRSxZQUFZLEdBQUdvQzt3QkFDdEIsSUFBSWxnQixPQUFPLElBQUk3VyxZQUFZODJCLFFBQVEsQ0FBQzM4RCxJQUFJLEVBQUUyOEQsUUFBUSxDQUFDMzhELE1BQU0sRUFBRTt3QkFDM0QsSUFBSTI4QyxPQUFPLElBQUk5VyxZQUFZOTZCLE1BQU0sQ0FBQ3JGLEVBQUUsRUFBRXFGLE1BQU0sQ0FBQ3JGLElBQUksRUFBRTt3QkFDbkQsSUFBSXFoQyxZQUFZMlYsS0FBSzVWLGFBQWEsQ0FBQzZWO3dCQUNuQytmLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBSXBELGlCQUFpQmtELE9BQU94OEQsS0FBSyttQyxTQUFTLENBQUMsRUFBRTt3QkFDNUQyMUIsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJcEQsaUJBQWlCbUQsT0FBTy8yRCxHQUFHcWhDLFNBQVMsQ0FBQyxFQUFFO29CQUM1RDtvQkFDQSxJQUFJcnlDLE9BQU84bEUsWUFBWSxJQUFJOWxFLE9BQU8ybEUsa0JBQWtCLEVBQUU7d0JBQUUsT0FBTztvQkFBSztnQkFDdEU7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBRCxXQUFXaGdGLFNBQVMsQ0FBQzhoRix3QkFBd0IsR0FBRyxTQUFTQSx5QkFBMEJXLE9BQU8sRUFBRUMsT0FBTyxFQUFFbkIsT0FBTztJQUN4RyxJQUFJam5FLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUlxN0UsUUFBUTl1RSxJQUFJLElBQUl2TSxJQUFLO1FBQ3ZDLElBQUlzaUQsTUFBTSs0QixRQUFRci9FLEdBQUcsQ0FBQ2dFO1FBQ3RCLElBQUssSUFBSWtrQixJQUFJLEdBQUdBLElBQUlvM0QsUUFBUS91RSxJQUFJLElBQUkyWCxJQUFLO1lBQ3ZDLElBQUlxM0QsTUFBTUQsUUFBUXQvRSxHQUFHLENBQUNrb0I7WUFDdEIsSUFBSTlLLE9BQU9rcEMsSUFBSTkxQyxhQUFhLEdBQUdyTyxRQUFRLENBQUNvOUUsSUFBSS91RSxhQUFhO1lBQ3pELElBQUk0TSxPQUFPbEcsT0FBTzhsRSxZQUFZLEVBQUU7Z0JBQzlCOWxFLE9BQU84bEUsWUFBWSxHQUFHNS9EO2dCQUN0QitnRSxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUlyQyxpQkFBaUJ4MUIsS0FBSyxHQUFHQSxJQUFJOTFDLGFBQWE7Z0JBQzNEMnRFLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSXJDLGlCQUFpQnlELEtBQUssR0FBR0EsSUFBSS91RSxhQUFhO1lBQzdEO1lBQ0EsSUFBSTBHLE9BQU84bEUsWUFBWSxJQUFJOWxFLE9BQU8ybEUsa0JBQWtCLEVBQUU7Z0JBQUUsT0FBTztZQUFLO1FBQ3RFO0lBQ0Y7QUFDRjtBQUNBRCxXQUFXaGdGLFNBQVMsQ0FBQ3VGLFFBQVEsR0FBRyxTQUFTQTtJQUN2QyxJQUFJLElBQUksQ0FBQyt6QixLQUFLLENBQUMsRUFBRSxLQUFLLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLE1BQU07UUFBRSxNQUFNLElBQUlsM0IseUJBQXlCO0lBQXFDO0lBQ2hJLElBQUksSUFBSSxDQUFDazNCLEtBQUssQ0FBQyxFQUFFLENBQUN4ZixPQUFPLE1BQU0sSUFBSSxDQUFDd2YsS0FBSyxDQUFDLEVBQUUsQ0FBQ3hmLE9BQU8sSUFBSTtRQUFFLE9BQU87SUFBSTtJQUNyRSxJQUFJLENBQUMwbkUsa0JBQWtCO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDcEIsWUFBWTtBQUMxQjtBQUNBSixXQUFXaGdGLFNBQVMsQ0FBQzRoRix1QkFBdUIsR0FBRyxTQUFTQSx3QkFBeUJGLE1BQU0sRUFBRUMsTUFBTSxFQUFFSixPQUFPO0lBQ3BHLElBQUlqbkUsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWxULElBQUksR0FBR0EsSUFBSXM2RSxPQUFPL3RFLElBQUksSUFBSXZNLElBQUs7UUFDdEMsSUFBSWc3RSxRQUFRVixPQUFPdCtFLEdBQUcsQ0FBQ2dFO1FBQ3ZCLElBQUssSUFBSWtrQixJQUFJLEdBQUdBLElBQUlxMkQsT0FBT2h1RSxJQUFJLElBQUkyWCxJQUFLO1lBQ3RDLElBQUkrMkQsUUFBUVYsT0FBT3YrRSxHQUFHLENBQUNrb0I7WUFDdkJoUixPQUFPa25FLGtCQUFrQixDQUFDWSxPQUFPQyxPQUFPZDtZQUN4QyxJQUFJam5FLE9BQU84bEUsWUFBWSxJQUFJOWxFLE9BQU8ybEUsa0JBQWtCLEVBQUU7Z0JBQUUsT0FBTztZQUFLO1FBQ3RFO0lBQ0Y7QUFDRjtBQUNBRCxXQUFXaGdGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxPQUFPLEVBQUU7QUFDWDtBQUNBbStFLFdBQVdoZ0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3ZDLE9BQU9rK0U7QUFDVDtBQUNBQSxXQUFXejZFLFFBQVEsR0FBRyxTQUFTQSxTQUFVODZFLEVBQUUsRUFBRUMsRUFBRTtJQUM3QyxJQUFJc0MsU0FBUyxJQUFJNUMsV0FBV0ssSUFBSUM7SUFDaEMsT0FBT3NDLE9BQU9yOUUsUUFBUTtBQUN4QjtBQUNBeTZFLFdBQVc2QyxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0J4QyxFQUFFLEVBQUVDLEVBQUUsRUFBRS82RSxRQUFRO0lBQ3ZFLElBQUlxOUUsU0FBUyxJQUFJNUMsV0FBV0ssSUFBSUMsSUFBSS82RTtJQUNwQyxPQUFPcTlFLE9BQU9yOUUsUUFBUSxNQUFNQTtBQUM5QjtBQUNBeTZFLFdBQVdnQyxhQUFhLEdBQUcsU0FBU0EsY0FBZTNCLEVBQUUsRUFBRUMsRUFBRTtJQUN2RCxJQUFJc0MsU0FBUyxJQUFJNUMsV0FBV0ssSUFBSUM7SUFDaEMsT0FBT3NDLE9BQU9aLGFBQWE7QUFDN0I7QUFFQSxJQUFJYyxzQkFBc0IsU0FBUzdIO0lBQ2pDLElBQUksQ0FBQ3ZHLEdBQUcsR0FBRztRQUFDLElBQUloeEU7UUFBYyxJQUFJQTtLQUFhO0lBQy9DLElBQUksQ0FBQ2s4QyxTQUFTLEdBQUcvOEMsT0FBTytDLEdBQUc7SUFDM0IsSUFBSSxDQUFDczFFLE9BQU8sR0FBRztBQUNqQjtBQUNBNEgsb0JBQW9COWlGLFNBQVMsQ0FBQzAzQixjQUFjLEdBQUcsU0FBU0E7SUFDdEQsT0FBTyxJQUFJLENBQUNnOUMsR0FBRztBQUNqQjtBQUNBb08sb0JBQW9COWlGLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQSxjQUFleE0sQ0FBQztJQUNyRSxPQUFPLElBQUksQ0FBQ3N0RSxHQUFHLENBQUN0dEUsRUFBRTtBQUNwQjtBQUNBMDdFLG9CQUFvQjlpRixTQUFTLENBQUNtN0UsVUFBVSxHQUFHLFNBQVNBO0lBQ2xELElBQUlyNkUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSSszRCxTQUFTMTNELFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3E2RSxVQUFVLENBQUMzaUIsT0FBT2tjLEdBQUcsQ0FBQyxFQUFFLEVBQUVsYyxPQUFPa2MsR0FBRyxDQUFDLEVBQUU7SUFDOUMsT0FBTyxJQUFJNXpFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk2YyxLQUFLeGMsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXlRLEtBQUt6USxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ282RSxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDRSxVQUFVLENBQUM5OUQsSUFBSS9MO1lBQ3BCLE9BQU87UUFDVDtRQUNBLElBQUlpUCxPQUFPbEQsR0FBRy9YLFFBQVEsQ0FBQ2dNO1FBQ3ZCLElBQUlpUCxPQUFPLElBQUksQ0FBQ28vQixTQUFTLEVBQUU7WUFBRSxJQUFJLENBQUN3N0IsVUFBVSxDQUFDOTlELElBQUkvTCxJQUFJaVA7UUFBTztJQUM5RDtBQUNGO0FBQ0FzaUUsb0JBQW9COWlGLFNBQVMsQ0FBQ283RSxVQUFVLEdBQUcsU0FBU0E7SUFDbEQsSUFBSXQ2RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUMxQixJQUFJLENBQUN5NkUsT0FBTyxHQUFHO0lBQ2pCLE9BQU8sSUFBSXA2RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNmMsS0FBS3hjLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl5USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxDQUFDNHpFLEdBQUcsQ0FBQyxFQUFFLENBQUNodkUsYUFBYSxDQUFDNFg7UUFDMUIsSUFBSSxDQUFDbzNELEdBQUcsQ0FBQyxFQUFFLENBQUNodkUsYUFBYSxDQUFDNkw7UUFDMUIsSUFBSSxDQUFDcXVDLFNBQVMsR0FBR3RpQyxHQUFHL1gsUUFBUSxDQUFDZ007UUFDN0IsSUFBSSxDQUFDMnBFLE9BQU8sR0FBRztJQUNqQixPQUFPLElBQUlwNkUsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTAyQyxPQUFPcjJDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUlxVSxPQUFPclUsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXlFLFdBQVd6RSxTQUFTLENBQUMsRUFBRTtRQUMzQixJQUFJLENBQUM0ekUsR0FBRyxDQUFDLEVBQUUsQ0FBQ2h2RSxhQUFhLENBQUN5eEM7UUFDMUIsSUFBSSxDQUFDdTlCLEdBQUcsQ0FBQyxFQUFFLENBQUNodkUsYUFBYSxDQUFDeVA7UUFDMUIsSUFBSSxDQUFDeXFDLFNBQVMsR0FBR3I2QztRQUNqQixJQUFJLENBQUMyMUUsT0FBTyxHQUFHO0lBQ2pCO0FBQ0Y7QUFDQTRILG9CQUFvQjlpRixTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDaEQsT0FBT2tZLFVBQVVFLFlBQVksQ0FBQyxJQUFJLENBQUNxM0QsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLEdBQUcsQ0FBQyxFQUFFO0FBQ3hEO0FBQ0FvTyxvQkFBb0I5aUYsU0FBUyxDQUFDNmdELFdBQVcsR0FBRyxTQUFTQTtJQUNuRCxPQUFPLElBQUksQ0FBQ2pCLFNBQVM7QUFDdkI7QUFDQWtqQyxvQkFBb0I5aUYsU0FBUyxDQUFDcTdFLFVBQVUsR0FBRyxTQUFTQTtJQUNsRCxJQUFJdjZFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUkrM0QsU0FBUzEzRCxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJLENBQUN1NkUsVUFBVSxDQUFDN2lCLE9BQU9rYyxHQUFHLENBQUMsRUFBRSxFQUFFbGMsT0FBT2tjLEdBQUcsQ0FBQyxFQUFFO0lBQzlDLE9BQU8sSUFBSTV6RSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNmMsS0FBS3hjLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl5USxLQUFLelEsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLENBQUNvNkUsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0UsVUFBVSxDQUFDOTlELElBQUkvTDtZQUNwQixPQUFPO1FBQ1Q7UUFDQSxJQUFJaVAsT0FBT2xELEdBQUcvWCxRQUFRLENBQUNnTTtRQUN2QixJQUFJaVAsT0FBTyxJQUFJLENBQUNvL0IsU0FBUyxFQUFFO1lBQUUsSUFBSSxDQUFDdzdCLFVBQVUsQ0FBQzk5RCxJQUFJL0wsSUFBSWlQO1FBQU87SUFDOUQ7QUFDRjtBQUNBc2lFLG9CQUFvQjlpRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxFQUFFO0FBQ1g7QUFDQWloRixvQkFBb0I5aUYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2hELE9BQU9naEY7QUFDVDtBQUVBLElBQUlDLGtCQUFrQixTQUFTQSxtQkFBb0I7QUFFbkRBLGdCQUFnQi9pRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxFQUFFO0FBQ1g7QUFDQWtoRixnQkFBZ0IvaUYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU9paEY7QUFDVDtBQUNBQSxnQkFBZ0J4SCxlQUFlLEdBQUcsU0FBU0E7SUFDekMsSUFBSXo2RSxTQUFTLENBQUMsRUFBRSxZQUFZZ2lGLHVCQUF3QmhpRixTQUFTLENBQUMsRUFBRSxZQUFZcTVCLGNBQWNyNUIsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQWE7UUFDN0gsSUFBSTRZLE9BQU94YixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJK2YsS0FBSy9mLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUkwM0QsU0FBUzEzRCxTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJMDZFLGNBQWMsSUFBSS92QjtRQUN0QixJQUFJOXZDLFNBQVNXLEtBQUtvYixjQUFjO1FBQ2hDLElBQUssSUFBSXR3QixJQUFJLEdBQUdBLElBQUl1VSxPQUFPbGIsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1lBQzFDbzBFLFlBQVl6dEIsY0FBYyxDQUFDcHlDLE1BQU0sQ0FBQ3ZVLEVBQUUsRUFBRXVVLE1BQU0sQ0FBQ3ZVLElBQUksRUFBRTtZQUNuRCxJQUFJdWxELFlBQVk2dUIsWUFBWTN1QixZQUFZLENBQUNoc0M7WUFDekMyM0MsT0FBTzJpQixVQUFVLENBQUN4dUIsV0FBVzlyQztRQUMvQjtJQUNGLE9BQU8sSUFBSS9mLFNBQVMsQ0FBQyxFQUFFLFlBQVlnaUYsdUJBQXdCaGlGLFNBQVMsQ0FBQyxFQUFFLFlBQVk0OUIsV0FBVzU5QixTQUFTLENBQUMsRUFBRSxZQUFZNEMsWUFBYTtRQUNqSSxJQUFJNDdCLE9BQU94K0IsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTI2RSxPQUFPMzZFLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk0NkUsV0FBVzU2RSxTQUFTLENBQUMsRUFBRTtRQUMzQmlpRixnQkFBZ0J4SCxlQUFlLENBQUNqOEMsS0FBS0UsZUFBZSxJQUFJaThDLE1BQU1DO1FBQzlELElBQUssSUFBSTkxRCxNQUFNLEdBQUdBLE1BQU0wWixLQUFLVixrQkFBa0IsSUFBSWhaLE1BQU87WUFDeERtOUQsZ0JBQWdCeEgsZUFBZSxDQUFDajhDLEtBQUtVLGdCQUFnQixDQUFDcGEsTUFBTTYxRCxNQUFNQztRQUNwRTtJQUNGLE9BQU8sSUFBSTU2RSxTQUFTLENBQUMsRUFBRSxZQUFZZ2lGLHVCQUF3QmhpRixTQUFTLENBQUMsRUFBRSxZQUFZdW5CLFlBQVl2bkIsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQWE7UUFDbEksSUFBSTBrQixPQUFPdG5CLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUk2NkUsT0FBTzc2RSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJODZFLFdBQVc5NkUsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSXNuQixnQkFBZ0IrUixZQUFZO1lBQzlCNG9ELGdCQUFnQnhILGVBQWUsQ0FBQ256RCxNQUFNdXpELE1BQU1DO1FBQzlDLE9BQU8sSUFBSXh6RCxnQkFBZ0JzVyxTQUFTO1lBQ2xDcWtELGdCQUFnQnhILGVBQWUsQ0FBQ256RCxNQUFNdXpELE1BQU1DO1FBQzlDLE9BQU8sSUFBSXh6RCxnQkFBZ0JvUCxvQkFBb0I7WUFDN0MsSUFBSWUsS0FBS25RO1lBQ1QsSUFBSyxJQUFJaUgsTUFBTSxHQUFHQSxNQUFNa0osR0FBR25PLGdCQUFnQixJQUFJaUYsTUFBTztnQkFDcEQsSUFBSXhGLElBQUkwTyxHQUFHOU8sWUFBWSxDQUFDNEY7Z0JBQ3hCMHpELGdCQUFnQnhILGVBQWUsQ0FBQzF4RCxHQUFHOHhELE1BQU1DO1lBQzNDO1FBQ0YsT0FBTztZQUNMQSxTQUFTVCxVQUFVLENBQUMveUQsS0FBS3hVLGFBQWEsSUFBSStuRTtRQUM1QztJQUNGLE9BQU8sSUFBSTc2RSxTQUFTLENBQUMsRUFBRSxZQUFZZ2lGLHVCQUF3QmhpRixTQUFTLENBQUMsRUFBRSxZQUFZMnFELGVBQWUzcUQsU0FBUyxDQUFDLEVBQUUsWUFBWTRDLFlBQWE7UUFDckksSUFBSW00RSxVQUFVLzZFLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLElBQUlnN0UsT0FBT2g3RSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJaTdFLFdBQVdqN0UsU0FBUyxDQUFDLEVBQUU7UUFDM0IsSUFBSWs3RSxjQUFjSCxRQUFRaHZCLFlBQVksQ0FBQ2l2QjtRQUN2Q0MsU0FBU1osVUFBVSxDQUFDYSxhQUFhRjtJQUNuQztBQUNGO0FBRUEsSUFBSWtILDRCQUE0QixTQUFTQTtJQUN2QyxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUw7SUFDbkIsSUFBSSxDQUFDTSxZQUFZLEdBQUc7SUFDcEIsSUFBSS9DLEtBQUt2L0UsU0FBUyxDQUFDLEVBQUU7SUFDckIsSUFBSXcvRSxLQUFLeC9FLFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQ21pRixHQUFHLEdBQUc1QztJQUNYLElBQUksQ0FBQzZDLEdBQUcsR0FBRzVDO0FBQ2I7QUFFQSxJQUFJK0MscUJBQXFCO0lBQUVqSCx3QkFBd0I7UUFBRWo4RSxjQUFjO0lBQUs7SUFBRW1qRixzQ0FBc0M7UUFBRW5qRixjQUFjO0lBQUs7QUFBRTtBQUN2STZpRiwwQkFBMEJoakYsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQTtJQUM1RCxPQUFPLElBQUksQ0FBQ3lyRCxPQUFPLENBQUN6ckQsY0FBYztBQUNwQztBQUNBc3JELDBCQUEwQmhqRixTQUFTLENBQUN1akYsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CQyxXQUFXO0lBQy9GLElBQUlBLGNBQWMsT0FBT0EsZUFBZSxLQUFLO1FBQUUsTUFBTSxJQUFJcGhGLHlCQUF5QjtJQUF3QztJQUMxSCxJQUFJLENBQUNnaEYsWUFBWSxHQUFHSTtBQUN0QjtBQUNBUiwwQkFBMEJoakYsU0FBUyxDQUFDeWpGLE9BQU8sR0FBRyxTQUFTQSxRQUFTcEQsRUFBRSxFQUFFQyxFQUFFO0lBQ3BFLElBQUksQ0FBQ29ELHVCQUF1QixDQUFDckQsSUFBSUMsSUFBSSxJQUFJLENBQUM2QyxPQUFPO0lBQ2pELElBQUksQ0FBQ08sdUJBQXVCLENBQUNwRCxJQUFJRCxJQUFJLElBQUksQ0FBQzhDLE9BQU87QUFDbkQ7QUFDQUgsMEJBQTBCaGpGLFNBQVMsQ0FBQ3VGLFFBQVEsR0FBRyxTQUFTQTtJQUN0RCxJQUFJLENBQUNrK0UsT0FBTyxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFLElBQUksQ0FBQ0MsR0FBRztJQUMvQixPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDdGlDLFdBQVc7QUFDakM7QUFDQW1pQywwQkFBMEJoakYsU0FBUyxDQUFDMGpGLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QkMsWUFBWSxFQUFFdjdELElBQUksRUFBRW93QyxNQUFNO0lBQ3hILElBQUkrakIsYUFBYSxJQUFJcUgseUJBQXlCeDdEO0lBQzlDdTdELGFBQWFwcUUsS0FBSyxDQUFDZ2pFO0lBQ25CL2pCLE9BQU82aUIsVUFBVSxDQUFDa0IsV0FBV0MsbUJBQW1CO0lBQ2hELElBQUksSUFBSSxDQUFDNEcsWUFBWSxHQUFHLEdBQUc7UUFDekIsSUFBSVMsYUFBYSxJQUFJUCxxQ0FBcUNsN0QsTUFBTSxJQUFJLENBQUNnN0QsWUFBWTtRQUNqRk8sYUFBYXBxRSxLQUFLLENBQUNzcUU7UUFDbkJyckIsT0FBTzZpQixVQUFVLENBQUN3SSxXQUFXckgsbUJBQW1CO0lBQ2xEO0FBQ0Y7QUFDQXdHLDBCQUEwQmhqRixTQUFTLENBQUM4akYsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDOUQsSUFBSSxDQUFDSix1QkFBdUIsQ0FBQyxJQUFJLENBQUNULEdBQUcsRUFBRSxJQUFJLENBQUNDLEdBQUcsRUFBRSxJQUFJLENBQUNDLE9BQU87SUFDN0QsT0FBTyxJQUFJLENBQUNBLE9BQU8sQ0FBQ3RpQyxXQUFXO0FBQ2pDO0FBQ0FtaUMsMEJBQTBCaGpGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN6RCxPQUFPLEVBQUU7QUFDWDtBQUNBbWhGLDBCQUEwQmhqRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdEQsT0FBT2toRjtBQUNUO0FBQ0FBLDBCQUEwQno5RSxRQUFRLEdBQUcsU0FBU0E7SUFDNUMsSUFBSXpFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUk0L0UsS0FBS3YvRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJdy9FLEtBQUt4L0UsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSTBmLE9BQU8sSUFBSXdpRSwwQkFBMEIzQyxJQUFJQztRQUM3QyxPQUFPOS9ELEtBQUtqYixRQUFRO0lBQ3RCLE9BQU8sSUFBSXpFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk4L0UsT0FBT3ovRSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJMC9FLE9BQU8xL0UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTBpRixjQUFjMWlGLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUkwaEYsU0FBUyxJQUFJUSwwQkFBMEJ6QyxNQUFNQztRQUNqRGdDLE9BQU9lLGtCQUFrQixDQUFDQztRQUMxQixPQUFPaEIsT0FBT2o5RSxRQUFRO0lBQ3hCO0FBQ0Y7QUFDQTg5RSxtQkFBbUJqSCxzQkFBc0IsQ0FBQ2g1RSxHQUFHLEdBQUc7SUFBYyxPQUFPd2dGO0FBQXlCO0FBQzlGUCxtQkFBbUJDLG9DQUFvQyxDQUFDbGdGLEdBQUcsR0FBRztJQUFjLE9BQU9rZ0Y7QUFBcUM7QUFFeEhyakYsT0FBT29ELGdCQUFnQixDQUFFMi9FLDJCQUEyQks7QUFFcEQsSUFBSU8sMkJBQTJCLFNBQVN4SDtJQUN0QyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJNEc7SUFDdEIsSUFBSSxDQUFDakcsVUFBVSxHQUFHLElBQUlpRztJQUN0QixJQUFJLENBQUNpQixjQUFjLEdBQUcsSUFBSWhCO0lBQzFCLElBQUksQ0FBQ3pwRCxLQUFLLEdBQUc7SUFDYixJQUFJbFIsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtJQUN2QixJQUFJLENBQUN3NEIsS0FBSyxHQUFHbFI7QUFDZjtBQUNBdzdELHlCQUF5QjVqRixTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVF0SCxFQUFFO0lBQzdELElBQUksQ0FBQ2c4RCxVQUFVLENBQUN6QixVQUFVO0lBQzFCMkgsZ0JBQWdCeEgsZUFBZSxDQUFDLElBQUksQ0FBQ2ppRCxLQUFLLEVBQUV6WSxJQUFJLElBQUksQ0FBQ2c4RCxVQUFVO0lBQy9ELElBQUksQ0FBQ1gsVUFBVSxDQUFDYixVQUFVLENBQUMsSUFBSSxDQUFDd0IsVUFBVTtBQUM1QztBQUNBK0cseUJBQXlCNWpGLFNBQVMsQ0FBQ3c4RSxtQkFBbUIsR0FBRyxTQUFTQTtJQUNoRSxPQUFPLElBQUksQ0FBQ04sVUFBVTtBQUN4QjtBQUNBMEgseUJBQXlCNWpGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN4RCxPQUFPO1FBQUNrcUI7S0FBaUI7QUFDM0I7QUFDQTYzRCx5QkFBeUI1akYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3JELE9BQU84aEY7QUFDVDtBQUVBLElBQUlOLHVDQUF1QyxTQUFTQTtJQUNsRCxJQUFJLENBQUNwSCxVQUFVLEdBQUcsSUFBSTRHO0lBQ3RCLElBQUksQ0FBQ2pHLFVBQVUsR0FBRyxJQUFJaUc7SUFDdEIsSUFBSSxDQUFDeHBELEtBQUssR0FBRztJQUNiLElBQUksQ0FBQzBxRCxXQUFXLEdBQUc7SUFDbkIsSUFBSTU3RCxPQUFPdG5CLFNBQVMsQ0FBQyxFQUFFO0lBQ3ZCLElBQUltakYsV0FBV25qRixTQUFTLENBQUMsRUFBRTtJQUMzQixJQUFJLENBQUN3NEIsS0FBSyxHQUFHbFI7SUFDYixJQUFJLENBQUM0N0QsV0FBVyxHQUFHdGpGLEtBQUtlLEtBQUssQ0FBQ2YsS0FBSzRqQyxLQUFLLENBQUMsTUFBTTIvQztBQUNqRDtBQUNBWCxxQ0FBcUN0akYsU0FBUyxDQUFDbW9CLE1BQU0sR0FBRyxTQUFTQSxPQUFRa1AsR0FBRyxFQUFFaHZCLEtBQUs7SUFDL0UsSUFBSWlTLFNBQVMsSUFBSTtJQUVuQixJQUFJalMsVUFBVSxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQy9CLElBQUlpVixLQUFLK1osSUFBSXpqQixhQUFhLENBQUN2TCxRQUFRO0lBQ25DLElBQUlrSixLQUFLOGxCLElBQUl6akIsYUFBYSxDQUFDdkw7SUFDM0IsSUFBSTY3RSxPQUFPLENBQUMzeUUsR0FBRzdQLENBQUMsR0FBRzRiLEdBQUc1YixDQUFDLElBQUksSUFBSSxDQUFDc2lGLFdBQVc7SUFDM0MsSUFBSUcsT0FBTyxDQUFDNXlFLEdBQUc1TixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQyxJQUFJLElBQUksQ0FBQ3FnRixXQUFXO0lBQzNDLElBQUssSUFBSTU4RSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDNDhFLFdBQVcsRUFBRTU4RSxJQUFLO1FBQ3pDLElBQUkxRixJQUFJNGIsR0FBRzViLENBQUMsR0FBRzBGLElBQUk4OEU7UUFDbkIsSUFBSXZnRixJQUFJMlosR0FBRzNaLENBQUMsR0FBR3lELElBQUkrOEU7UUFDbkIsSUFBSXRqRSxLQUFLLElBQUluZCxXQUFXaEMsR0FBR2lDO1FBQzNCMlcsT0FBT3VpRSxVQUFVLENBQUN6QixVQUFVO1FBQzVCMkgsZ0JBQWdCeEgsZUFBZSxDQUFDamhFLE9BQU9nZixLQUFLLEVBQUV6WSxJQUFJdkcsT0FBT3VpRSxVQUFVO1FBQ25FdmlFLE9BQU80aEUsVUFBVSxDQUFDYixVQUFVLENBQUMvZ0UsT0FBT3VpRSxVQUFVO0lBQ2hEO0FBQ0Y7QUFDQXlHLHFDQUFxQ3RqRixTQUFTLENBQUNzM0IsTUFBTSxHQUFHLFNBQVNBO0lBQy9ELE9BQU87QUFDVDtBQUNBZ3NELHFDQUFxQ3RqRixTQUFTLENBQUN1M0IsaUJBQWlCLEdBQUcsU0FBU0E7SUFDMUUsT0FBTztBQUNUO0FBQ0ErckQscUNBQXFDdGpGLFNBQVMsQ0FBQ3c4RSxtQkFBbUIsR0FBRyxTQUFTQTtJQUM1RSxPQUFPLElBQUksQ0FBQ04sVUFBVTtBQUN4QjtBQUNBb0gscUNBQXFDdGpGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNwRSxPQUFPO1FBQUN1MUI7S0FBeUI7QUFDbkM7QUFDQWtzRCxxQ0FBcUN0akYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pFLE9BQU93aEY7QUFDVDtBQUVBLElBQUljLDBCQUEwQixTQUFTQSx3QkFBeUJDLEtBQUssRUFBRXRqQixXQUFXLEVBQUV0N0QsTUFBTTtJQUN4RixJQUFJLENBQUM2K0UsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUN6QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDZixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLE1BQU0sR0FBR1QsU0FBUztJQUN2QixJQUFJLENBQUNVLFlBQVksR0FBR2hrQixlQUFlO0lBQ25DLElBQUksQ0FBQzlpRCxPQUFPLEdBQUd4WSxVQUFVO0FBQzNCO0FBRUEsSUFBSXUvRSxxQkFBcUI7SUFBRUMsU0FBUztRQUFFOWtGLGNBQWM7SUFBSztJQUFFK2tGLHdCQUF3QjtRQUFFL2tGLGNBQWM7SUFBSztBQUFFO0FBQzFHaWtGLHdCQUF3QnBrRixTQUFTLENBQUNtbEYsb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCZCxLQUFLLEVBQUVlLFFBQVEsRUFBRUMsT0FBTztJQUM5RyxJQUFJQyxPQUFPLElBQUl0QywwQkFBMEJvQyxVQUFVZjtJQUNuRGlCLEtBQUsvQixrQkFBa0IsQ0FBQztJQUN4QixJQUFJLENBQUNrQixpQkFBaUIsR0FBR2EsS0FBS3hCLGdCQUFnQjtJQUM5QyxJQUFJLElBQUksQ0FBQ1csaUJBQWlCLEdBQUdZLFNBQVM7UUFDcEMsSUFBSSxDQUFDWCxRQUFRLEdBQUc7UUFDaEIsSUFBSXo5RCxNQUFNcStELEtBQUs1dEQsY0FBYztRQUM3QixJQUFJLENBQUNrdEQsY0FBYyxHQUFHMzlELEdBQUcsQ0FBQyxFQUFFO1FBQzVCLElBQUksQ0FBQzQ5RCxlQUFlLEdBQUdSLE1BQU03NkQsVUFBVSxHQUFHck4sZ0JBQWdCLENBQUM4SztRQUMzRCxJQUFJLENBQUMwOUQsT0FBTyxHQUFHLDJEQUEyRCxJQUFJLENBQUNGLGlCQUFpQixHQUFHLFNBQVN0bkUsVUFBVUUsWUFBWSxDQUFDNEosR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsSUFBSTtJQUN2SjtBQUNGO0FBQ0FtOUQsd0JBQXdCcGtGLFNBQVMsQ0FBQ21nQyxPQUFPLEdBQUcsU0FBU0E7SUFDbkQsSUFBSTQvQixjQUFjci9ELEtBQUt5QixHQUFHLENBQUMsSUFBSSxDQUFDNGlGLFlBQVk7SUFDNUMsSUFBSVEsWUFBWW5CLHdCQUF3QmMsc0JBQXNCLEdBQUdubEI7SUFDakUsSUFBSSxDQUFDdWtCLGlCQUFpQixHQUFHdmtCLGNBQWN3bEI7SUFDdkMsSUFBSSxDQUFDaEIsaUJBQWlCLEdBQUd4a0IsY0FBY3dsQjtJQUN2QyxJQUFJLElBQUksQ0FBQ1QsTUFBTSxDQUFDaHJFLE9BQU8sTUFBTSxJQUFJLENBQUNtRSxPQUFPLENBQUNuRSxPQUFPLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDbkUsSUFBSSxJQUFJLENBQUNpckUsWUFBWSxHQUFHLEtBQUs7UUFDM0IsSUFBSSxDQUFDUyxrQkFBa0I7SUFDekIsT0FBTztRQUNMLElBQUksQ0FBQ0Msa0JBQWtCO0lBQ3pCO0lBQ0EsSUFBSXJCLHdCQUF3QmEsT0FBTyxFQUFFO1FBQ25DMXdFLE9BQU9tTyxHQUFHLENBQUNDLE9BQU8sQ0FBQyxlQUFlLElBQUksQ0FBQzZoRSxpQkFBaUIsR0FBRyxZQUFhLE9BQU0sSUFBSSxDQUFDQSxpQkFBaUIsR0FBRyxJQUFJLENBQUNPLFlBQVksSUFBSSxpQkFBaUIsSUFBSSxDQUFDTixpQkFBaUIsR0FBRyxZQUFhLEtBQUksQ0FBQ0EsaUJBQWlCLEdBQUcsSUFBSSxDQUFDTSxZQUFZLEdBQUcsR0FBRTtJQUNwTztJQUNBLE9BQU8sSUFBSSxDQUFDTCxRQUFRO0FBQ3RCO0FBQ0FOLHdCQUF3QnBrRixTQUFTLENBQUN5bEYsa0JBQWtCLEdBQUcsU0FBU0E7SUFDOUQsSUFBSSxDQUFFLEtBQUksQ0FBQ1gsTUFBTSxZQUFZcG1ELFdBQVcsSUFBSSxDQUFDb21ELE1BQU0sWUFBWXJrRCxnQkFBZ0IsSUFBSSxDQUFDcWtELE1BQU0sWUFBWXR0RCxrQkFBaUIsR0FBSTtRQUN6SCxPQUFPO0lBQ1Q7SUFDQSxJQUFJa3VELGFBQWEsSUFBSSxDQUFDQyxlQUFlLENBQUMsSUFBSSxDQUFDYixNQUFNO0lBQ2pELElBQUksQ0FBQ2Msb0JBQW9CLENBQUNGLFlBQVksSUFBSSxDQUFDem5FLE9BQU8sRUFBRSxJQUFJLENBQUNxbUUsaUJBQWlCO0lBQzFFLElBQUksQ0FBQyxJQUFJLENBQUNJLFFBQVEsRUFBRTtRQUFFLE9BQU87SUFBSztJQUNsQyxJQUFJLENBQUNTLG9CQUFvQixDQUFDTyxZQUFZLElBQUksQ0FBQ3puRSxPQUFPLEVBQUUsSUFBSSxDQUFDc21FLGlCQUFpQjtBQUM1RTtBQUNBSCx3QkFBd0Jwa0YsU0FBUyxDQUFDNmxGLGlCQUFpQixHQUFHLFNBQVNBO0lBQzdELE9BQU8sSUFBSSxDQUFDaEIsZUFBZTtBQUM3QjtBQUNBVCx3QkFBd0Jwa0YsU0FBUyxDQUFDNGxGLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQnRGLEVBQUUsRUFBRTdZLEVBQUUsRUFBRW5qRCxPQUFPO0lBQ3JHLElBQUlzK0QsU0FBUyxJQUFJNUMsV0FBV00sSUFBSTdZLElBQUluakQ7SUFDcEMsSUFBSSxDQUFDa2dFLGlCQUFpQixHQUFHNUIsT0FBT3I5RSxRQUFRO0lBQ3hDLElBQUksSUFBSSxDQUFDaS9FLGlCQUFpQixHQUFHbGdFLFNBQVM7UUFDcEMsSUFBSSxDQUFDb2dFLFFBQVEsR0FBRztRQUNoQixJQUFJejlELE1BQU0yN0QsT0FBT1osYUFBYTtRQUM5QixJQUFJLENBQUM0QyxjQUFjLEdBQUdoQyxPQUFPWixhQUFhLEVBQUUsQ0FBQyxFQUFFO1FBQy9DLElBQUksQ0FBQzZDLGVBQWUsR0FBR3ZFLEdBQUc5MkQsVUFBVSxHQUFHck4sZ0JBQWdCLENBQUM4SztRQUN4RCxJQUFJLENBQUMwOUQsT0FBTyxHQUFHLDJEQUEyRCxJQUFJLENBQUNILGlCQUFpQixHQUFHLFNBQVNybkUsVUFBVUUsWUFBWSxDQUFDNEosR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsSUFBSTtJQUN2SjtBQUNGO0FBQ0FtOUQsd0JBQXdCcGtGLFNBQVMsQ0FBQ3dsRixrQkFBa0IsR0FBRyxTQUFTQTtJQUM5RCxJQUFJSixXQUFXLElBQUksQ0FBQ25uRSxPQUFPLENBQUM2YSxXQUFXO0lBQ3ZDLElBQUksQ0FBQzhzRCxvQkFBb0IsQ0FBQyxJQUFJLENBQUNkLE1BQU0sRUFBRU0sVUFBVSxJQUFJLENBQUNkLGlCQUFpQjtJQUN2RSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDbEMsSUFBSSxDQUFDUyxvQkFBb0IsQ0FBQyxJQUFJLENBQUNMLE1BQU0sRUFBRU0sVUFBVSxJQUFJLENBQUNiLGlCQUFpQjtBQUN6RTtBQUNBSCx3QkFBd0Jwa0YsU0FBUyxDQUFDOGxGLGdCQUFnQixHQUFHLFNBQVNBO0lBQzVELE9BQU8sSUFBSSxDQUFDbEIsY0FBYztBQUM1QjtBQUNBUix3QkFBd0Jwa0YsU0FBUyxDQUFDMmxGLGVBQWUsR0FBRyxTQUFTQSxnQkFBaUI5N0QsQ0FBQztJQUM3RSxJQUFJdE4sUUFBUSxJQUFJaVI7SUFDaEIsSUFBSXU0RCxnQkFBZ0IsSUFBSTdJLHlCQUF5QjNnRTtJQUNqRCxJQUFJd2tFLFFBQVFoRSxpQkFBaUJuZ0MsV0FBVyxDQUFDL3lCO0lBQ3pDLElBQUssSUFBSXppQixJQUFJMjVFLE1BQU0xMUQsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzNDLElBQUkrVCxPQUFPbDRCLEVBQUVzZ0IsSUFBSTtRQUNqQjRYLEtBQUsvbEIsS0FBSyxDQUFDd3NFO0lBQ2I7SUFDQSxPQUFPbDhELEVBQUVMLFVBQVUsR0FBR3liLGFBQWEsQ0FBQzFvQjtBQUN0QztBQUNBNm5FLHdCQUF3QnBrRixTQUFTLENBQUNnbUYsZUFBZSxHQUFHLFNBQVNBO0lBQzNELE9BQU8sSUFBSSxDQUFDckIsT0FBTztBQUNyQjtBQUNBUCx3QkFBd0Jwa0YsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3ZELE9BQU8sRUFBRTtBQUNYO0FBQ0F1aUYsd0JBQXdCcGtGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNwRCxPQUFPc2lGO0FBQ1Q7QUFDQVksbUJBQW1CQyxPQUFPLENBQUM3aEYsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFNO0FBQzVENGhGLG1CQUFtQkUsc0JBQXNCLENBQUM5aEYsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFNO0FBRTNFbkQsT0FBT29ELGdCQUFnQixDQUFFK2dGLHlCQUF5Qlk7QUFFbEQsSUFBSWlCLHdCQUF3QixTQUFTQSxzQkFBdUI1QixLQUFLLEVBQUU5K0UsUUFBUSxFQUFFRSxNQUFNO0lBQ2pGLElBQUksQ0FBQ2kvRSxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDd0IsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ3RCLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLE1BQU0sR0FBR1QsU0FBUztJQUN2QixJQUFJLENBQUN6a0MsU0FBUyxHQUFHcjZDLFlBQVk7SUFDN0IsSUFBSSxDQUFDMFksT0FBTyxHQUFHeFksVUFBVTtBQUMzQjtBQUVBLElBQUkwZ0YscUJBQXFCO0lBQUVsQixTQUFTO1FBQUU5a0YsY0FBYztJQUFLO0lBQUVpbUYsbUJBQW1CO1FBQUVqbUYsY0FBYztJQUFLO0FBQUU7QUFDckc4bEYsc0JBQXNCam1GLFNBQVMsQ0FBQ21nQyxPQUFPLEdBQUcsU0FBU0E7SUFDakQsSUFBSSxDQUFDa21ELGNBQWM7SUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQzNCLFFBQVEsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDQSxRQUFRO0lBQUM7SUFDM0MsSUFBSSxDQUFDNEIsa0JBQWtCO0lBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUM1QixRQUFRLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ0EsUUFBUTtJQUFDO0lBQzNDLElBQUksQ0FBQzZCLGFBQWE7SUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQzdCLFFBQVEsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDQSxRQUFRO0lBQUM7SUFDM0MsSUFBSSxDQUFDOEIsU0FBUztJQUNkLElBQUksQ0FBQyxJQUFJLENBQUM5QixRQUFRLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ0EsUUFBUTtJQUFDO0lBQzNDLElBQUksQ0FBQytCLGFBQWE7SUFDbEIsT0FBTyxJQUFJLENBQUMvQixRQUFRO0FBQ3RCO0FBQ0F1QixzQkFBc0JqbUYsU0FBUyxDQUFDdW1GLGFBQWEsR0FBRyxTQUFTQTtJQUN2RCxJQUFJLElBQUksQ0FBQzNtQyxTQUFTLEdBQUcsS0FBSztRQUFFLE9BQU87SUFBSztJQUN4QyxJQUFJOG1DLFVBQVUsSUFBSSxDQUFDOW1DLFNBQVMsR0FBR3FtQyxzQkFBc0JHLGlCQUFpQjtJQUN0RSxJQUFJTSxZQUFZLEtBQUs7UUFBRUEsVUFBVTtJQUFPO0lBQ3hDLElBQUlDLGNBQWMsSUFBSXp3RSxTQUFTLElBQUksQ0FBQzR1RSxNQUFNLENBQUNuNkQsbUJBQW1CO0lBQzlEZzhELFlBQVk3dUUsUUFBUSxDQUFDLElBQUksQ0FBQzhuQyxTQUFTO0lBQ25DLElBQUlnbkMsU0FBUyxJQUFJMXdFLFNBQVMsSUFBSSxDQUFDK0gsT0FBTyxDQUFDME0sbUJBQW1CO0lBQzFEaThELE9BQU85dUUsUUFBUSxDQUFDNHVFO0lBQ2hCLElBQUksQ0FBQ0UsT0FBTzN1RSxRQUFRLENBQUMwdUUsY0FBYztRQUNqQyxJQUFJLENBQUNqQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDd0IsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3JCLGVBQWUsR0FBRyxJQUFJLENBQUNDLE1BQU0sQ0FBQ3Q3RCxVQUFVLEdBQUdrQixVQUFVLENBQUNrOEQ7SUFDN0Q7SUFDQSxJQUFJLENBQUNDLE1BQU0sQ0FBQztBQUNkO0FBQ0FaLHNCQUFzQmptRixTQUFTLENBQUN5bUYsYUFBYSxHQUFHLFNBQVNBO0lBQ3ZELElBQUlLLFlBQVksSUFBSTFDLHdCQUF3QixJQUFJLENBQUNVLE1BQU0sRUFBRSxJQUFJLENBQUNsbEMsU0FBUyxFQUFFLElBQUksQ0FBQzNoQyxPQUFPO0lBQ3JGLElBQUksQ0FBQzZvRSxVQUFVM21ELE9BQU8sSUFBSTtRQUN4QixJQUFJLENBQUN1a0QsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ3dCLFNBQVMsR0FBR1ksVUFBVWQsZUFBZTtRQUMxQyxJQUFJLENBQUNwQixjQUFjLEdBQUdrQyxVQUFVaEIsZ0JBQWdCO1FBQ2hELElBQUksQ0FBQ2pCLGVBQWUsR0FBR2lDLFVBQVVqQixpQkFBaUI7SUFDcEQ7SUFDQSxJQUFJLENBQUNnQixNQUFNLENBQUM7QUFDZDtBQUNBWixzQkFBc0JqbUYsU0FBUyxDQUFDd21GLFNBQVMsR0FBRyxTQUFTQTtJQUNuRCxJQUFJTyxZQUFZLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ3R1RSxPQUFPO0lBQ25DLElBQUl3d0UsYUFBYSxJQUFJLENBQUMvb0UsT0FBTyxDQUFDekgsT0FBTztJQUNyQyxJQUFJLElBQUksQ0FBQ29wQyxTQUFTLEdBQUcsT0FBT21uQyxZQUFZQyxZQUFZO1FBQ2xELElBQUksQ0FBQ3RDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUN3QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDckIsZUFBZSxHQUFHLElBQUksQ0FBQzVtRSxPQUFPO0lBQ3JDO0lBQ0EsSUFBSSxJQUFJLENBQUMyaEMsU0FBUyxHQUFHLE9BQU9tbkMsWUFBWUMsWUFBWTtRQUNsRCxJQUFJLENBQUN0QyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDd0IsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3JCLGVBQWUsR0FBRyxJQUFJLENBQUM1bUUsT0FBTztJQUNyQztJQUNBLElBQUksQ0FBQzRvRSxNQUFNLENBQUM7QUFDZDtBQUNBWixzQkFBc0JqbUYsU0FBUyxDQUFDcW1GLGNBQWMsR0FBRyxTQUFTQTtJQUN4RCxJQUFJLENBQUUsS0FBSSxDQUFDcG9FLE9BQU8sWUFBWXlnQixXQUFXLElBQUksQ0FBQ3pnQixPQUFPLFlBQVl3aUIsWUFBVyxHQUFJO1FBQUUsSUFBSSxDQUFDaWtELFFBQVEsR0FBRztJQUFPO0lBQ3pHLElBQUksQ0FBQ3dCLFNBQVMsR0FBRztJQUNqQixJQUFJLENBQUNyQixlQUFlLEdBQUcsSUFBSSxDQUFDNW1FLE9BQU87SUFDbkMsSUFBSSxDQUFDNG9FLE1BQU0sQ0FBQztBQUNkO0FBQ0FaLHNCQUFzQmptRixTQUFTLENBQUM2bEYsaUJBQWlCLEdBQUcsU0FBU0E7SUFDM0QsT0FBTyxJQUFJLENBQUNoQixlQUFlO0FBQzdCO0FBQ0FvQixzQkFBc0JqbUYsU0FBUyxDQUFDOGxGLGdCQUFnQixHQUFHLFNBQVNBO0lBQzFELE9BQU8sSUFBSSxDQUFDbEIsY0FBYztBQUM1QjtBQUNBcUIsc0JBQXNCam1GLFNBQVMsQ0FBQ3NtRixrQkFBa0IsR0FBRyxTQUFTQTtJQUM1RCxJQUFJLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ2h4RSxZQUFZLE1BQU0sR0FBRztRQUFFLE9BQU87SUFBSztJQUNuRCxJQUFJLElBQUksQ0FBQzhyQyxTQUFTLEdBQUcsS0FBSztRQUFFLE9BQU87SUFBSztJQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDM2hDLE9BQU8sQ0FBQ25FLE9BQU8sSUFBSTtRQUMzQixJQUFJLENBQUM0cUUsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ3dCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNyQixlQUFlLEdBQUcsSUFBSSxDQUFDNW1FLE9BQU87SUFDckM7SUFDQSxJQUFJLENBQUM0b0UsTUFBTSxDQUFDO0FBQ2Q7QUFDQVosc0JBQXNCam1GLFNBQVMsQ0FBQzZtRixNQUFNLEdBQUcsU0FBU0EsT0FBUUksU0FBUztJQUNqRSxJQUFJLENBQUNoQixzQkFBc0JoQixPQUFPLEVBQUU7UUFBRSxPQUFPO0lBQUs7SUFDbEQxd0UsT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLFdBQVdza0UsWUFBWSxPQUFRLEtBQUksQ0FBQ3ZDLFFBQVEsR0FBRyxXQUFXLFFBQU87QUFDdEY7QUFDQXVCLHNCQUFzQmptRixTQUFTLENBQUNnbUYsZUFBZSxHQUFHLFNBQVNBO0lBQ3pELE9BQU8sSUFBSSxDQUFDRSxTQUFTO0FBQ3ZCO0FBQ0FELHNCQUFzQmptRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDckQsT0FBTyxFQUFFO0FBQ1g7QUFDQW9rRixzQkFBc0JqbUYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2xELE9BQU9ta0Y7QUFDVDtBQUNBQSxzQkFBc0JpQixVQUFVLEdBQUcsU0FBU0EsV0FBWXI5RCxDQUFDLEVBQUV0a0IsUUFBUSxFQUFFRSxNQUFNO0lBQ3pFLElBQUkwaEYsWUFBWSxJQUFJbEIsc0JBQXNCcDhELEdBQUd0a0IsVUFBVUU7SUFDdkQsSUFBSSxDQUFDMGhGLFVBQVVobkQsT0FBTyxJQUFJO1FBQUUsT0FBT2duRCxVQUFVbkIsZUFBZTtJQUFHO0lBQy9ELE9BQU87QUFDVDtBQUNBQyxzQkFBc0I5bEQsT0FBTyxHQUFHLFNBQVNBLFFBQVN0VyxDQUFDLEVBQUV0a0IsUUFBUSxFQUFFRSxNQUFNO0lBQ25FLElBQUkwaEYsWUFBWSxJQUFJbEIsc0JBQXNCcDhELEdBQUd0a0IsVUFBVUU7SUFDdkQsSUFBSTBoRixVQUFVaG5ELE9BQU8sSUFBSTtRQUFFLE9BQU87SUFBSztJQUN2QyxPQUFPO0FBQ1Q7QUFDQWdtRCxtQkFBbUJsQixPQUFPLENBQUM3aEYsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFNO0FBQzVEK2lGLG1CQUFtQkMsaUJBQWlCLENBQUNoakYsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFNO0FBRXRFbkQsT0FBT29ELGdCQUFnQixDQUFFNGlGLHVCQUF1QkU7QUFFaEQsbUJBQW1CO0FBRW5CLElBQUlpQixxQkFBcUIsU0FBU0E7SUFDaEMsSUFBSSxDQUFDLzJDLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ21hLEtBQUssR0FBRztJQUNiLElBQUl2akMsTUFBTW5tQixTQUFTLENBQUMsRUFBRTtJQUN0QixJQUFJK1ksT0FBTy9ZLFNBQVMsQ0FBQyxFQUFFO0lBQ3ZCLElBQUksQ0FBQ3V2QyxJQUFJLEdBQUdwcEI7SUFDWixJQUFJLENBQUN1akMsS0FBSyxHQUFHM3dDO0FBQ2Y7QUFDQXV0RSxtQkFBbUJwbkYsU0FBUyxDQUFDMDNCLGNBQWMsR0FBRyxTQUFTQTtJQUNyRCxPQUFPLElBQUksQ0FBQzJZLElBQUk7QUFDbEI7QUFDQSsyQyxtQkFBbUJwbkYsU0FBUyxDQUFDMlQsSUFBSSxHQUFHLFNBQVNBO0lBQzNDLE9BQU8sSUFBSSxDQUFDMDhCLElBQUksQ0FBQzV2QyxNQUFNO0FBQ3pCO0FBQ0EybUYsbUJBQW1CcG5GLFNBQVMsQ0FBQzRULGFBQWEsR0FBRyxTQUFTQSxjQUFleE0sQ0FBQztJQUNwRSxPQUFPLElBQUksQ0FBQ2lwQyxJQUFJLENBQUNqcEMsRUFBRTtBQUNyQjtBQUNBZ2dGLG1CQUFtQnBuRixTQUFTLENBQUNpNUIsUUFBUSxHQUFHLFNBQVNBO0lBQy9DLE9BQU8sSUFBSSxDQUFDb1gsSUFBSSxDQUFDLEVBQUUsQ0FBQzFyQyxNQUFNLENBQUMsSUFBSSxDQUFDMHJDLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksQ0FBQzV2QyxNQUFNLEdBQUcsRUFBRTtBQUM1RDtBQUNBMm1GLG1CQUFtQnBuRixTQUFTLENBQUNzcEQsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCamhELEtBQUs7SUFDOUUsSUFBSUEsVUFBVSxJQUFJLENBQUNnb0MsSUFBSSxDQUFDNXZDLE1BQU0sR0FBRyxHQUFHO1FBQUUsT0FBTyxDQUFDO0lBQUU7SUFDaEQsT0FBT3FwRCxPQUFPbkQsTUFBTSxDQUFDLElBQUksQ0FBQy95QyxhQUFhLENBQUN2TCxRQUFRLElBQUksQ0FBQ3VMLGFBQWEsQ0FBQ3ZMLFFBQVE7QUFDN0U7QUFDQSsrRSxtQkFBbUJwbkYsU0FBUyxDQUFDb3FELE9BQU8sR0FBRyxTQUFTQSxRQUFTdndDLElBQUk7SUFDM0QsSUFBSSxDQUFDMndDLEtBQUssR0FBRzN3QztBQUNmO0FBQ0F1dEUsbUJBQW1CcG5GLFNBQVMsQ0FBQ29wRCxPQUFPLEdBQUcsU0FBU0E7SUFDOUMsT0FBTyxJQUFJLENBQUNvQixLQUFLO0FBQ25CO0FBQ0E0OEIsbUJBQW1CcG5GLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtJQUMvQyxPQUFPa1ksVUFBVUUsWUFBWSxDQUFDLElBQUkwa0Isd0JBQXdCLElBQUksQ0FBQ3NPLElBQUk7QUFDckU7QUFDQSsyQyxtQkFBbUJwbkYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xELE9BQU87UUFBQ3NvRDtLQUFjO0FBQ3hCO0FBQ0FpOUIsbUJBQW1CcG5GLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMvQyxPQUFPc2xGO0FBQ1Q7QUFFQSxJQUFJQyw2QkFBNkIsU0FBU0E7SUFDeEMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztJQUM3QixJQUFJLENBQUNDLHVCQUF1QixHQUFHO0lBQy9CLElBQUksQ0FBQ3JzQixHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNzc0IscUJBQXFCLEdBQUc7SUFDN0IsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDcEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSWw2RDtJQUMxQixJQUFJLENBQUNtNkQsa0JBQWtCLEdBQUc7SUFDMUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztJQUMxQixJQUFJaDlCLEtBQUs5cEQsU0FBUyxDQUFDLEVBQUU7SUFDckIsSUFBSSxDQUFDbzZELEdBQUcsR0FBR3RRO0lBQ1gsSUFBSSxDQUFDNDhCLHFCQUFxQixHQUFHO0FBQy9CO0FBQ0FILDJCQUEyQnJuRixTQUFTLENBQUM2bkYsdUJBQXVCLEdBQUcsU0FBU0E7SUFDdEUsT0FBTyxJQUFJLENBQUNMLHFCQUFxQjtBQUNuQztBQUNBSCwyQkFBMkJybkYsU0FBUyxDQUFDOG5GLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QkMsc0JBQXNCO0lBQ3JILElBQUksQ0FBQ1IsdUJBQXVCLEdBQUdRO0FBQ2pDO0FBQ0FWLDJCQUEyQnJuRixTQUFTLENBQUNnb0YsdUJBQXVCLEdBQUcsU0FBU0E7SUFDdEUsT0FBTyxJQUFJLENBQUNQLFlBQVk7QUFDMUI7QUFDQUosMkJBQTJCcm5GLFNBQVMsQ0FBQzY2QixLQUFLLEdBQUcsU0FBU0E7SUFDcEQsT0FBTyxJQUFJLENBQUM4c0Qsa0JBQWtCO0FBQ2hDO0FBQ0FOLDJCQUEyQnJuRixTQUFTLENBQUNpb0YsZ0JBQWdCLEdBQUcsU0FBU0E7SUFDL0QsT0FBTyxJQUFJLENBQUNQLGNBQWM7QUFDNUI7QUFDQUwsMkJBQTJCcm5GLFNBQVMsQ0FBQ2tvRix1QkFBdUIsR0FBRyxTQUFTQSx3QkFBeUJDLG9CQUFvQjtJQUNuSCxJQUFJLENBQUNiLHFCQUFxQixHQUFHYTtBQUMvQjtBQUNBZCwyQkFBMkJybkYsU0FBUyxDQUFDb29GLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQkMsaUJBQWlCO0lBQzFHLElBQUksQ0FBQ1Qsa0JBQWtCLEdBQUdTO0FBQzVCO0FBQ0FoQiwyQkFBMkJybkYsU0FBUyxDQUFDd3pELG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQmlaLEVBQUUsRUFBRUMsU0FBUyxFQUFFQyxFQUFFLEVBQUVDLFNBQVM7SUFDckgsSUFBSSxDQUFDLElBQUksQ0FBQzBhLHFCQUFxQixJQUFJLElBQUksQ0FBQ3BuRSxlQUFlLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDekUsSUFBSXVzRCxPQUFPRSxNQUFNRCxjQUFjRSxXQUFXO1FBQUUsT0FBTztJQUFLO0lBQ3hELElBQUksSUFBSSxDQUFDMmEsdUJBQXVCLEVBQUU7UUFDaEMsSUFBSWUsa0JBQWtCLElBQUksQ0FBQ0MsWUFBWSxDQUFDOWIsSUFBSUMsY0FBYyxJQUFJLENBQUM2YixZQUFZLENBQUM1YixJQUFJQztRQUNoRixJQUFJLENBQUMwYixpQkFBaUI7WUFBRSxPQUFPO1FBQUs7SUFDdEM7SUFDQSxJQUFJNTNCLE1BQU0rYixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFVBQVU7SUFDeEMsSUFBSS9iLE1BQU04YixHQUFHLzBDLGNBQWMsRUFBRSxDQUFDZzFDLFlBQVksRUFBRTtJQUM1QyxJQUFJOWIsTUFBTStiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsVUFBVTtJQUN4QyxJQUFJL2IsTUFBTThiLEdBQUdqMUMsY0FBYyxFQUFFLENBQUNrMUMsWUFBWSxFQUFFO0lBQzVDLElBQUksQ0FBQzFSLEdBQUcsQ0FBQ3o3QyxtQkFBbUIsQ0FBQ2l4QyxLQUFLQyxLQUFLQyxLQUFLQztJQUM1QyxJQUFJLElBQUksQ0FBQ3FLLEdBQUcsQ0FBQ2g3QyxlQUFlLElBQUk7UUFDOUIsSUFBSSxJQUFJLENBQUNnN0MsR0FBRyxDQUFDNzZDLHNCQUFzQixJQUFJO1lBQ3JDLElBQUksQ0FBQ29uRSxZQUFZLEdBQUcsSUFBSTFuRixNQUFNLEdBQUdNLElBQUksQ0FBQztZQUN0QyxJQUFJLENBQUNvbkYsWUFBWSxDQUFDLEVBQUUsR0FBRy8yQjtZQUN2QixJQUFJLENBQUMrMkIsWUFBWSxDQUFDLEVBQUUsR0FBRzkyQjtZQUN2QixJQUFJLENBQUM4MkIsWUFBWSxDQUFDLEVBQUUsR0FBRzcyQjtZQUN2QixJQUFJLENBQUM2MkIsWUFBWSxDQUFDLEVBQUUsR0FBRzUyQjtZQUN2QixJQUFJLENBQUMyMkIscUJBQXFCLEdBQUcsSUFBSSxDQUFDdHNCLEdBQUcsQ0FBQzM2QyxlQUFlLENBQUM7WUFDdEQsSUFBSSxJQUFJLENBQUNxbkUsa0JBQWtCLEVBQUU7Z0JBQUUsSUFBSSxDQUFDRixjQUFjLENBQUN6N0UsR0FBRyxDQUFDLElBQUksQ0FBQ3U3RSxxQkFBcUI7WUFBRztZQUNwRixJQUFJLENBQUNHLGtCQUFrQjtRQUN6QjtJQUNGO0FBQ0Y7QUFDQU4sMkJBQTJCcm5GLFNBQVMsQ0FBQ3VvRixZQUFZLEdBQUcsU0FBU0EsYUFBYzMxQixNQUFNLEVBQUV2cUQsS0FBSztJQUN0RixJQUFJQSxVQUFVLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDL0IsSUFBSUEsU0FBU3VxRCxPQUFPai9DLElBQUksS0FBSyxHQUFHO1FBQUUsT0FBTztJQUFLO0lBQzlDLE9BQU87QUFDVDtBQUNBMHpFLDJCQUEyQnJuRixTQUFTLENBQUNrZ0IsZUFBZSxHQUFHLFNBQVNBO0lBQzlELE9BQU8sSUFBSSxDQUFDc25FLHFCQUFxQixLQUFLO0FBQ3hDO0FBQ0FILDJCQUEyQnJuRixTQUFTLENBQUNzM0IsTUFBTSxHQUFHLFNBQVNBO0lBQ3JELElBQUksSUFBSSxDQUFDZ3dELHFCQUFxQixFQUFFO1FBQUUsT0FBTztJQUFNO0lBQy9DLE9BQU8sSUFBSSxDQUFDRSxxQkFBcUIsS0FBSztBQUN4QztBQUNBSCwyQkFBMkJybkYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzFELE9BQU87UUFBQzJxRTtLQUFtQjtBQUM3QjtBQUNBNmEsMkJBQTJCcm5GLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN2RCxPQUFPdWxGO0FBQ1Q7QUFDQUEsMkJBQTJCbUIsNEJBQTRCLEdBQUcsU0FBU0EsNkJBQThCNTlCLEVBQUU7SUFDakcsSUFBSTY5QixTQUFTLElBQUlwQiwyQkFBMkJ6OEI7SUFDNUM2OUIsT0FBT1AsdUJBQXVCLENBQUM7SUFDL0IsT0FBT087QUFDVDtBQUNBcEIsMkJBQTJCcUIsMkJBQTJCLEdBQUcsU0FBU0EsNEJBQTZCOTlCLEVBQUU7SUFDL0YsT0FBTyxJQUFJeThCLDJCQUEyQno4QjtBQUN4QztBQUNBeThCLDJCQUEyQnNCLHlCQUF5QixHQUFHLFNBQVNBLDBCQUEyQi85QixFQUFFO0lBQzNGLElBQUk2OUIsU0FBUyxJQUFJcEIsMkJBQTJCejhCO0lBQzVDNjlCLE9BQU9QLHVCQUF1QixDQUFDO0lBQy9CTyxPQUFPTCxvQkFBb0IsQ0FBQztJQUM1QixPQUFPSztBQUNUO0FBRUEsSUFBSUcsc0JBQXNCLFNBQVNBO0lBQ2pDLElBQUksQ0FBQzF0QixHQUFHLEdBQUcsSUFBSWg2QztJQUNmLElBQUksQ0FBQzJ5RCxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDeVQscUJBQXFCLEdBQUc7SUFDN0IsSUFBSSxDQUFDeDFCLE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQzR5QixRQUFRLEdBQUc7SUFDaEIsSUFBSXQ1QixhQUFhdHFELFNBQVMsQ0FBQyxFQUFFO0lBQzdCLElBQUksQ0FBQyt5RSxXQUFXLEdBQUd6b0I7QUFDckI7QUFDQXc5QixvQkFBb0I1b0YsU0FBUyxDQUFDNm9GLE9BQU8sR0FBRyxTQUFTQTtJQUMvQyxJQUFJLElBQUksQ0FBQy8yQixPQUFPLEtBQUssTUFBTTtRQUFFLE9BQU87SUFBSztJQUN6QyxJQUFJLENBQUNtaUIsMEJBQTBCO0FBQ2pDO0FBQ0EyVSxvQkFBb0I1b0YsU0FBUyxDQUFDaW9GLGdCQUFnQixHQUFHLFNBQVNBO0lBQ3hELE9BQU8sSUFBSSxDQUFDbjJCLE9BQU8sQ0FBQ20yQixnQkFBZ0I7QUFDdEM7QUFDQVcsb0JBQW9CNW9GLFNBQVMsQ0FBQ21nQyxPQUFPLEdBQUcsU0FBU0E7SUFDL0MsSUFBSSxDQUFDMG9ELE9BQU87SUFDWixPQUFPLElBQUksQ0FBQ25FLFFBQVE7QUFDdEI7QUFDQWtFLG9CQUFvQjVvRixTQUFTLENBQUNrb0YsdUJBQXVCLEdBQUcsU0FBU0Esd0JBQXlCQyxvQkFBb0I7SUFDNUcsSUFBSSxDQUFDYixxQkFBcUIsR0FBR2E7QUFDL0I7QUFDQVMsb0JBQW9CNW9GLFNBQVMsQ0FBQ2kwRSwwQkFBMEIsR0FBRyxTQUFTQTtJQUNsRSxJQUFJLENBQUN5USxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDNXlCLE9BQU8sR0FBRyxJQUFJdTFCLDJCQUEyQixJQUFJLENBQUNuc0IsR0FBRztJQUN0RCxJQUFJLENBQUNwSixPQUFPLENBQUNvMkIsdUJBQXVCLENBQUMsSUFBSSxDQUFDWixxQkFBcUI7SUFDL0QsSUFBSXhWLFFBQVEsSUFBSTdmO0lBQ2hCNmYsTUFBTTlmLHFCQUFxQixDQUFDLElBQUksQ0FBQ0YsT0FBTztJQUN4Q2dnQixNQUFNbGdCLFlBQVksQ0FBQyxJQUFJLENBQUNpaUIsV0FBVztJQUNuQyxJQUFJLElBQUksQ0FBQy9oQixPQUFPLENBQUM1eEMsZUFBZSxJQUFJO1FBQ2xDLElBQUksQ0FBQ3drRSxRQUFRLEdBQUc7UUFDaEIsT0FBTztJQUNUO0FBQ0Y7QUFDQWtFLG9CQUFvQjVvRixTQUFTLENBQUNzMEUsVUFBVSxHQUFHLFNBQVNBO0lBQ2xELElBQUksQ0FBQ3VVLE9BQU87SUFDWixJQUFJLENBQUMsSUFBSSxDQUFDbkUsUUFBUSxFQUFFO1FBQUUsTUFBTSxJQUFJLzVDLGtCQUFrQixJQUFJLENBQUNxN0MsZUFBZSxJQUFJLElBQUksQ0FBQ2wwQixPQUFPLENBQUMrMUIsdUJBQXVCO0lBQUk7QUFDcEg7QUFDQWUsb0JBQW9CNW9GLFNBQVMsQ0FBQ2dtRixlQUFlLEdBQUcsU0FBU0E7SUFDdkQsSUFBSSxJQUFJLENBQUN0QixRQUFRLEVBQUU7UUFBRSxPQUFPO0lBQXlCO0lBQ3JELElBQUlvRSxVQUFVLElBQUksQ0FBQ2gzQixPQUFPLENBQUNrMkIsdUJBQXVCO0lBQ2xELE9BQU8sMENBQTBDN3FFLFVBQVVFLFlBQVksQ0FBQ3lyRSxPQUFPLENBQUMsRUFBRSxFQUFFQSxPQUFPLENBQUMsRUFBRSxJQUFJLFVBQVUzckUsVUFBVUUsWUFBWSxDQUFDeXJFLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxFQUFFO0FBQzNKO0FBQ0FGLG9CQUFvQjVvRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxFQUFFO0FBQ1g7QUFDQSttRixvQkFBb0I1b0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2hELE9BQU84bUY7QUFDVDtBQUNBQSxvQkFBb0JHLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQjM5QixVQUFVO0lBQ2xGLElBQUkyc0IsS0FBSyxJQUFJNlEsb0JBQW9CeDlCO0lBQ2pDMnNCLEdBQUdtUSx1QkFBdUIsQ0FBQztJQUMzQm5RLEdBQUc1M0MsT0FBTztJQUNWLE9BQU80M0MsR0FBR2tRLGdCQUFnQjtBQUM1QjtBQUVBLElBQUllLHNCQUFzQixTQUFTQTtJQUNqQyxJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUk5MEMsUUFBUXJ6QyxTQUFTLENBQUMsRUFBRTtJQUN4QixJQUFJLENBQUNtb0YsR0FBRyxHQUFHLElBQUlMLG9CQUFvQkksb0JBQW9CRSxnQkFBZ0IsQ0FBQy8wQztBQUMxRTtBQUNBNjBDLG9CQUFvQmhwRixTQUFTLENBQUNzMEUsVUFBVSxHQUFHLFNBQVNBO0lBQ2xELElBQUksQ0FBQzJVLEdBQUcsQ0FBQzNVLFVBQVU7QUFDckI7QUFDQTBVLG9CQUFvQmhwRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDbkQsT0FBTyxFQUFFO0FBQ1g7QUFDQW1uRixvQkFBb0JocEYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2hELE9BQU9rbkY7QUFDVDtBQUNBQSxvQkFBb0JFLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQi8wQyxLQUFLO0lBQ3JFLElBQUlpWCxhQUFhLElBQUk1OUI7SUFDckIsSUFBSyxJQUFJcG1CLElBQUkrc0MsTUFBTTlvQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7UUFDM0MsSUFBSTFpQixJQUFJekIsRUFBRXNnQixJQUFJO1FBQ2QwakMsV0FBV24vQyxHQUFHLENBQUMsSUFBSW03RSxtQkFBbUJ2K0UsRUFBRTZ1QixjQUFjLElBQUk3dUI7SUFDNUQ7SUFDQSxPQUFPdWlEO0FBQ1Q7QUFDQTQ5QixvQkFBb0IxVSxVQUFVLEdBQUcsU0FBU0EsV0FBWW5nQyxLQUFLO0lBQ3pELElBQUlnekMsWUFBWSxJQUFJNkIsb0JBQW9CNzBDO0lBQ3hDZ3pDLFVBQVU3UyxVQUFVO0FBQ3RCO0FBRUEsSUFBSTZVLDJCQUEyQixTQUFTQSx5QkFBMEJDLEtBQUs7SUFDckUsSUFBSSxDQUFDQyxNQUFNLEdBQUdEO0FBQ2hCO0FBQ0FELHlCQUF5Qm5wRixTQUFTLENBQUNtZSxHQUFHLEdBQUcsU0FBU0EsSUFBS29hLEVBQUU7SUFDckQsSUFBSWplLFNBQVMsSUFBSTtJQUVuQixJQUFJZ3ZFLFNBQVMsSUFBSTk3RDtJQUNqQixJQUFLLElBQUlwbUIsSUFBSSxHQUFHQSxJQUFJbXhCLEdBQUduTyxnQkFBZ0IsSUFBSWhqQixJQUFLO1FBQzlDLElBQUl5aUIsSUFBSXZQLE9BQU8rdUUsTUFBTSxDQUFDbHJFLEdBQUcsQ0FBQ29hLEdBQUc5TyxZQUFZLENBQUNyaUI7UUFDMUMsSUFBSSxDQUFDeWlCLEVBQUUvUCxPQUFPLElBQUk7WUFBRXd2RSxPQUFPcjlFLEdBQUcsQ0FBQzRkO1FBQUk7SUFDckM7SUFDQSxPQUFPME8sR0FBRy9PLFVBQVUsR0FBR3ZNLHdCQUF3QixDQUFDdkUsZ0JBQWdCNnNCLGVBQWUsQ0FBQytqRDtBQUNsRjtBQUNBSCx5QkFBeUJucEYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3hELE9BQU8sRUFBRTtBQUNYO0FBQ0FzbkYseUJBQXlCbnBGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNyRCxPQUFPcW5GO0FBQ1Q7QUFDQUEseUJBQXlCaHJFLEdBQUcsR0FBRyxTQUFTQSxJQUFLb2EsRUFBRSxFQUFFZ3hELEVBQUU7SUFDakQsSUFBSUMsU0FBUyxJQUFJTCx5QkFBeUJJO0lBQzFDLE9BQU9DLE9BQU9yckUsR0FBRyxDQUFDb2E7QUFDcEI7QUFFQSxJQUFJa3hELGNBQWMsU0FBU0E7SUFDekIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNqNUMsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSSxDQUFDeXZDLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUN5SixjQUFjLEdBQUcsSUFBSW44RDtJQUMxQixJQUFJLENBQUNvOEQsZUFBZSxHQUFHLElBQUlwOEQ7SUFDM0IsSUFBSSs3RCxLQUFLem9GLFNBQVMsQ0FBQyxFQUFFO0lBQ3JCLElBQUkyWCxrQkFBa0IzWCxTQUFTLENBQUMsRUFBRTtJQUNsQyxJQUFJK29GLFlBQVkvb0YsU0FBUyxDQUFDLEVBQUU7SUFDNUIsSUFBSSxDQUFDNG9GLEdBQUcsR0FBR0g7SUFDWCxJQUFJLENBQUM5NEMsZ0JBQWdCLEdBQUdoNEI7SUFDeEIsSUFBSSxDQUFDeW5FLFVBQVUsR0FBRzJKO0FBQ3BCO0FBQ0FKLFlBQVl6cEYsU0FBUyxDQUFDOHBGLFlBQVksR0FBRyxTQUFTQSxhQUFjQyxNQUFNO0lBQzlELElBQUl6dkUsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSW9nQixLQUFLLElBQUksQ0FBQ2d2RCxHQUFHLENBQUNNLFFBQVEsR0FBR2p2QyxXQUFXLEdBQUcxdkIsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUN6RSxJQUFJK2QsS0FBSzVPLEdBQUdoVCxJQUFJO1FBQ2hCcE4sT0FBTzJ2RSxlQUFlLENBQUMzZ0QsSUFBSXlnRCxRQUFRenZFLE9BQU9xdkUsY0FBYztRQUN4RHJ2RSxPQUFPNHZFLHdCQUF3QixDQUFDNWdELElBQUl5Z0QsUUFBUXp2RSxPQUFPcXZFLGNBQWM7SUFDbkU7QUFDRjtBQUNBRixZQUFZenBGLFNBQVMsQ0FBQ21xRixpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJ0aEYsQ0FBQyxFQUFFdWhGLFdBQVc7SUFDbEYsSUFBSXY3QyxNQUFNLElBQUksQ0FBQ3F4QyxVQUFVLENBQUNuWixNQUFNLENBQUNsK0QsRUFBRStLLGFBQWEsSUFBSSxJQUFJLENBQUM4MUUsR0FBRyxDQUFDVyxjQUFjLENBQUNEO0lBQzVFdmhGLEVBQUVrb0MsUUFBUSxHQUFHdkMsV0FBVyxDQUFDNDdDLGFBQWF2N0M7QUFDeEM7QUFDQTQ2QyxZQUFZenBGLFNBQVMsQ0FBQzJoRCxLQUFLLEdBQUcsU0FBU0EsTUFBT29vQyxNQUFNO0lBQ2xELElBQUksQ0FBQy9lLG9CQUFvQjtJQUN6QixJQUFJLENBQUM4ZSxZQUFZLENBQUNDO0lBQ2xCLElBQUksQ0FBQ08sVUFBVSxDQUFDUDtJQUNoQixPQUFPLElBQUksQ0FBQ0gsZUFBZTtBQUM3QjtBQUNBSCxZQUFZenBGLFNBQVMsQ0FBQ2lxRixlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCM2dELEVBQUUsRUFBRXlnRCxNQUFNLEVBQUU1MUMsS0FBSztJQUNqRixJQUFJcEUsUUFBUXpHLEdBQUd5SCxRQUFRO0lBQ3ZCLElBQUlsb0MsSUFBSXlnQyxHQUFHSyxPQUFPO0lBQ2xCLElBQUlMLEdBQUcwUCxVQUFVLElBQUk7UUFDbkIsSUFBSSxDQUFDMVAsR0FBR3VDLFNBQVMsTUFBTTArQyxVQUFVQyxZQUFZLENBQUN6NkMsT0FBT2c2QyxXQUFXLENBQUNsaEYsRUFBRTRxQyxTQUFTLElBQUk7WUFDOUVVLE1BQU1sb0MsR0FBRyxDQUFDcEQ7WUFDVnlnQyxHQUFHa1EsY0FBYyxDQUFDO1FBQ3BCO0lBQ0Y7QUFDRjtBQUNBaXdDLFlBQVl6cEYsU0FBUyxDQUFDZ3JFLG9CQUFvQixHQUFHLFNBQVNBO0lBQ2xELElBQUkxd0QsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSWtnQyxTQUFTLElBQUksQ0FBQ2t2QyxHQUFHLENBQUNNLFFBQVEsR0FBRzU4QyxRQUFRLEdBQUcvaEIsUUFBUSxJQUFJbXZCLE9BQU9qdkIsT0FBTyxJQUFLO1FBQzlFLElBQUkwZSxPQUFPdVEsT0FBTzl5QixJQUFJO1FBQ3RCdWlCLEtBQUtHLFFBQVEsR0FBRzRnQyxvQkFBb0I7SUFDdEM7SUFDQSxJQUFLLElBQUl0d0MsS0FBSyxJQUFJLENBQUNndkQsR0FBRyxDQUFDTSxRQUFRLEdBQUdqdkMsV0FBVyxHQUFHMXZCLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDekUsSUFBSStkLEtBQUs1TyxHQUFHaFQsSUFBSTtRQUNoQixJQUFJN2UsSUFBSXlnQyxHQUFHSyxPQUFPO1FBQ2xCLElBQUlMLEdBQUcwUCxVQUFVLE1BQU0sQ0FBQ253QyxFQUFFNnFDLFlBQVksSUFBSTtZQUN4QyxJQUFJRCxZQUFZbjVCLE9BQU9vdkUsR0FBRyxDQUFDZSxZQUFZLENBQUNuaEQsR0FBRzExQixhQUFhO1lBQ3hEL0ssRUFBRStxQyxVQUFVLENBQUNIO1FBQ2Y7SUFDRjtBQUNGO0FBQ0FnMkMsWUFBWXpwRixTQUFTLENBQUMwcUYsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CQyxTQUFTO0lBQzdFLElBQUlyd0UsU0FBUyxJQUFJO0lBRW5CLElBQUssSUFBSW9nQixLQUFLaXdELFVBQVV0L0QsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztRQUNqRCxJQUFJMWlCLElBQUk2eEIsR0FBR2hULElBQUk7UUFDZixJQUFJcW9CLFFBQVFsbkMsRUFBRWtvQyxRQUFRO1FBQ3RCLElBQUlsb0MsRUFBRStuQyxVQUFVLElBQUk7WUFDbEIsSUFBSWIsTUFBTW41QixNQUFNLENBQUMsSUFBSTtnQkFBRTBELE9BQU82dkUsaUJBQWlCLENBQUN0aEYsR0FBRztZQUFJLE9BQU87Z0JBQUV5UixPQUFPNnZFLGlCQUFpQixDQUFDdGhGLEdBQUc7WUFBSTtRQUNsRztJQUNGO0FBQ0Y7QUFDQTRnRixZQUFZenBGLFNBQVMsQ0FBQ3NxRixVQUFVLEdBQUcsU0FBU0EsV0FBWVAsTUFBTTtJQUMxRCxJQUFJenZFLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlvZ0IsS0FBSyxJQUFJLENBQUNpdkQsY0FBYyxDQUFDdCtELFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7UUFDM0QsSUFBSTFpQixJQUFJNnhCLEdBQUdoVCxJQUFJO1FBQ2YsNkJBQTZCO1FBQzdCLElBQUlwTCxPQUFPaEMsT0FBT20yQixnQkFBZ0IsQ0FBQ3QwQixnQkFBZ0IsQ0FBQ3RULEVBQUU2dUIsY0FBYztRQUNwRXBkLE9BQU9zdkUsZUFBZSxDQUFDMzlFLEdBQUcsQ0FBQ3FRO1FBQzNCelQsRUFBRTJqQyxXQUFXLENBQUM7SUFDaEI7QUFDRjtBQUNBaTlDLFlBQVl6cEYsU0FBUyxDQUFDa3FGLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQjVnRCxFQUFFLEVBQUV5Z0QsTUFBTSxFQUFFNTFDLEtBQUs7SUFDbkcsSUFBSXBFLFFBQVF6RyxHQUFHeUgsUUFBUTtJQUN2QixJQUFJekgsR0FBRzBQLFVBQVUsSUFBSTtRQUFFLE9BQU87SUFBSztJQUNuQyxJQUFJMVAsR0FBR3VDLFNBQVMsSUFBSTtRQUFFLE9BQU87SUFBSztJQUNsQyxJQUFJdkMsR0FBR2lELGtCQUFrQixJQUFJO1FBQUUsT0FBTztJQUFLO0lBQzNDLElBQUlqRCxHQUFHSyxPQUFPLEdBQUc2SixVQUFVLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDN0M5MUIsT0FBT0UsTUFBTSxDQUFDLENBQUUwckIsQ0FBQUEsR0FBR2tLLFVBQVUsTUFBTWxLLEdBQUdpQixNQUFNLEdBQUdpSixVQUFVLEVBQUMsS0FBTSxDQUFDbEssR0FBR0ssT0FBTyxHQUFHNkosVUFBVTtJQUN4RixJQUFJKzJDLFVBQVVDLFlBQVksQ0FBQ3o2QyxPQUFPZzZDLFdBQVdBLFdBQVdRLFVBQVVLLFlBQVksRUFBRTtRQUM5RXoyQyxNQUFNbG9DLEdBQUcsQ0FBQ3E5QixHQUFHSyxPQUFPO1FBQ3BCTCxHQUFHa1EsY0FBYyxDQUFDO0lBQ3BCO0FBQ0Y7QUFDQWl3QyxZQUFZenBGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLEVBQUU7QUFDWDtBQUNBNG5GLFlBQVl6cEYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3hDLE9BQU8ybkY7QUFDVDtBQUVBLElBQUlvQixlQUFlLFNBQVNBO0lBQzFCLElBQUksQ0FBQ25CLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ2o1QyxnQkFBZ0IsR0FBRztJQUN4QixJQUFJLENBQUNxNkMsZ0JBQWdCLEdBQUcsSUFBSXQ5RDtJQUM1QixJQUFJKzdELEtBQUt6b0YsU0FBUyxDQUFDLEVBQUU7SUFDckIsSUFBSTJYLGtCQUFrQjNYLFNBQVMsQ0FBQyxFQUFFO0lBQ2xDLGlDQUFpQztJQUNqQyxJQUFJLENBQUM0b0YsR0FBRyxHQUFHSDtJQUNYLElBQUksQ0FBQzk0QyxnQkFBZ0IsR0FBR2g0QjtBQUMxQjtBQUNBb3lFLGFBQWE3cUYsU0FBUyxDQUFDK3FGLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQi9uRixDQUFDO0lBQ3BGLElBQUlncEIsUUFBUWhwQixFQUFFNFEsYUFBYTtJQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDODFFLEdBQUcsQ0FBQ3NCLGFBQWEsQ0FBQ2gvRCxRQUFRO1FBQ2xDLElBQUluTCxLQUFLLElBQUksQ0FBQzR2QixnQkFBZ0IsQ0FBQy8wQixXQUFXLENBQUNzUTtRQUMzQyxJQUFJLENBQUM4K0QsZ0JBQWdCLENBQUM3K0UsR0FBRyxDQUFDNFU7SUFDNUI7QUFDRjtBQUNBZ3FFLGFBQWE3cUYsU0FBUyxDQUFDaXJGLDRCQUE0QixHQUFHLFNBQVNBLDZCQUE4QmxCLE1BQU07SUFDL0YsSUFBSXp2RSxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJa2dDLFNBQVMsSUFBSSxDQUFDa3ZDLEdBQUcsQ0FBQ00sUUFBUSxHQUFHNThDLFFBQVEsR0FBRy9oQixRQUFRLElBQUltdkIsT0FBT2p2QixPQUFPLElBQUs7UUFDOUUsSUFBSXZvQixJQUFJdzNDLE9BQU85eUIsSUFBSTtRQUNuQixJQUFJMWtCLEVBQUV3d0MsVUFBVSxJQUFJO1lBQUU7UUFBUztRQUMvQixJQUFJeHdDLEVBQUVveEMsc0JBQXNCLElBQUk7WUFBRTtRQUFTO1FBQzNDLElBQUlweEMsRUFBRW9uQyxRQUFRLEdBQUc2K0IsU0FBUyxPQUFPLEtBQUs4Z0IsV0FBV1EsVUFBVUssWUFBWSxFQUFFO1lBQ3ZFLElBQUk3NkMsUUFBUS9zQyxFQUFFK3RDLFFBQVE7WUFDdEIsSUFBSXc1QyxVQUFVQyxZQUFZLENBQUN6NkMsT0FBT2c2QyxTQUFTO2dCQUN6Q3p2RSxPQUFPeXdFLHdCQUF3QixDQUFDL25GO1lBQ2xDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E2bkYsYUFBYTdxRixTQUFTLENBQUMyaEQsS0FBSyxHQUFHLFNBQVNBLE1BQU9vb0MsTUFBTTtJQUNuRCxJQUFJLENBQUNrQiw0QkFBNEIsQ0FBQ2xCO0lBQ2xDLE9BQU8sSUFBSSxDQUFDZSxnQkFBZ0I7QUFDOUI7QUFDQUQsYUFBYTdxRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxFQUFFO0FBQ1g7QUFDQWdwRixhQUFhN3FGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN6QyxPQUFPK29GO0FBQ1Q7QUFFQSxJQUFJSyxzQkFBc0IsU0FBU0E7SUFDakMsSUFBSSxDQUFDOWxCLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUM1OEMsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQzJpRSxtQkFBbUIsR0FBRztJQUMzQixJQUFJLENBQUNDLCtCQUErQixHQUFHO0lBQ3ZDLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDNUIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7QUFDdkI7QUFDQUosb0JBQW9CbHJGLFNBQVMsQ0FBQ3VyRixjQUFjLEdBQUcsU0FBU0EsZUFBZ0JuakUsSUFBSSxFQUFFOEwsTUFBTTtJQUNsRixPQUFPLElBQUksQ0FBQzFMLFFBQVEsQ0FBQzlNLFdBQVcsQ0FBQyxJQUFJLENBQUM4dkUsb0JBQW9CLENBQUNwakUsS0FBS2dXLHFCQUFxQixJQUFJaFc7QUFDM0Y7QUFDQThpRSxvQkFBb0JsckYsU0FBUyxDQUFDeXJGLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQnJqRSxJQUFJLEVBQUU4TCxNQUFNO0lBQ3BGLElBQUk1WixTQUFTLElBQUk7SUFFbkIsSUFBSW94RSx3QkFBd0I7SUFDNUIsSUFBSTl1RSxRQUFRLElBQUksQ0FBQyt1RSxtQkFBbUIsQ0FBQ3ZqRSxLQUFLb1gsZUFBZSxJQUFJcFg7SUFDN0QsSUFBSXhMLFVBQVUsUUFBUSxDQUFFQSxDQUFBQSxpQkFBaUJ3akIsVUFBUyxLQUFNeGpCLE1BQU05QyxPQUFPLElBQUk7UUFBRTR4RSx3QkFBd0I7SUFBTztJQUMxRyxJQUFJN3VFLFFBQVEsSUFBSTJRO0lBQ2hCLElBQUssSUFBSXBtQixJQUFJLEdBQUdBLElBQUlnaEIsS0FBS3dXLGtCQUFrQixJQUFJeDNCLElBQUs7UUFDbEQsSUFBSXc2QixPQUFPdG5CLE9BQU9xeEUsbUJBQW1CLENBQUN2akUsS0FBSzRYLGdCQUFnQixDQUFDNTRCLElBQUlnaEI7UUFDaEUsSUFBSXdaLFNBQVMsUUFBUUEsS0FBSzluQixPQUFPLElBQUk7WUFDbkM7UUFDRjtRQUNBLElBQUksQ0FBRThuQixDQUFBQSxnQkFBZ0J4QixVQUFTLEdBQUk7WUFBRXNyRCx3QkFBd0I7UUFBTztRQUNwRTd1RSxNQUFNNVEsR0FBRyxDQUFDMjFCO0lBQ1o7SUFDQSxJQUFJOHBELHVCQUF1QjtRQUFFLE9BQU8sSUFBSSxDQUFDbGpFLFFBQVEsQ0FBQy9MLGFBQWEsQ0FBQ0csT0FBT0MsTUFBTW1RLE9BQU8sQ0FBQyxFQUFFO0lBQUksT0FBTztRQUNoRyxJQUFJL1EsYUFBYSxJQUFJdVI7UUFDckIsSUFBSTVRLFVBQVUsTUFBTTtZQUFFWCxXQUFXaFEsR0FBRyxDQUFDMlE7UUFBUTtRQUM3Q1gsV0FBVzhRLE1BQU0sQ0FBQ2xRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDMkwsUUFBUSxDQUFDeWMsYUFBYSxDQUFDaHBCO0lBQ3JDO0FBQ0Y7QUFDQWl2RSxvQkFBb0JsckYsU0FBUyxDQUFDNHJGLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQmp3RSxNQUFNO0lBQ2hHLE9BQU8sSUFBSSxDQUFDNk0sUUFBUSxDQUFDNlYsNEJBQTRCLEdBQUcxN0IsTUFBTSxDQUFDZ1o7QUFDN0Q7QUFDQXV2RSxvQkFBb0JsckYsU0FBUyxDQUFDNnJGLGdCQUFnQixHQUFHLFNBQVNBO0lBQ3hELE9BQU8sSUFBSSxDQUFDem1CLFVBQVU7QUFDeEI7QUFDQThsQixvQkFBb0JsckYsU0FBUyxDQUFDOHJGLHdCQUF3QixHQUFHLFNBQVNBLHlCQUEwQjFqRSxJQUFJLEVBQUU4TCxNQUFNO0lBQ3BHLElBQUk1WixTQUFTLElBQUk7SUFFbkIsSUFBSXl4RSxnQkFBZ0IsSUFBSXYrRDtJQUN4QixJQUFLLElBQUlwbUIsSUFBSSxHQUFHQSxJQUFJZ2hCLEtBQUtnQyxnQkFBZ0IsSUFBSWhqQixJQUFLO1FBQ2hELElBQUk0a0YsZ0JBQWdCMXhFLE9BQU8yeEUsbUJBQW1CLENBQUM3akUsS0FBS3FCLFlBQVksQ0FBQ3JpQixJQUFJZ2hCO1FBQ3JFLElBQUk0akUsa0JBQWtCLE1BQU07WUFBRTtRQUFTO1FBQ3ZDLElBQUlBLGNBQWNseUUsT0FBTyxJQUFJO1lBQUU7UUFBUztRQUN4Q2l5RSxjQUFjOS9FLEdBQUcsQ0FBQysvRTtJQUNwQjtJQUNBLE9BQU8sSUFBSSxDQUFDeGpFLFFBQVEsQ0FBQ3ljLGFBQWEsQ0FBQzhtRDtBQUNyQztBQUNBYixvQkFBb0JsckYsU0FBUyxDQUFDd3JGLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQjd2RSxNQUFNLEVBQUV1WSxNQUFNO0lBQ2hHLE9BQU8sSUFBSSxDQUFDbHZCLElBQUksQ0FBQzJXO0FBQ25CO0FBQ0F1dkUsb0JBQW9CbHJGLFNBQVMsQ0FBQ2lzRixtQkFBbUIsR0FBRyxTQUFTQSxvQkFBcUI3akUsSUFBSSxFQUFFOEwsTUFBTTtJQUM1RixPQUFPLElBQUksQ0FBQzFMLFFBQVEsQ0FBQ3JNLGdCQUFnQixDQUFDLElBQUksQ0FBQ3F2RSxvQkFBb0IsQ0FBQ3BqRSxLQUFLZ1cscUJBQXFCLElBQUloVztBQUNoRztBQUNBOGlFLG9CQUFvQmxyRixTQUFTLENBQUNrc0YsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCOWpFLElBQUksRUFBRThMLE1BQU07SUFDMUYsSUFBSTVaLFNBQVMsSUFBSTtJQUVuQixJQUFJeXhFLGdCQUFnQixJQUFJditEO0lBQ3hCLElBQUssSUFBSXBtQixJQUFJLEdBQUdBLElBQUlnaEIsS0FBS2dDLGdCQUFnQixJQUFJaGpCLElBQUs7UUFDaEQsSUFBSTRrRixnQkFBZ0IxeEUsT0FBT2l4RSxjQUFjLENBQUNuakUsS0FBS3FCLFlBQVksQ0FBQ3JpQixJQUFJZ2hCO1FBQ2hFLElBQUk0akUsa0JBQWtCLE1BQU07WUFBRTtRQUFTO1FBQ3ZDLElBQUlBLGNBQWNseUUsT0FBTyxJQUFJO1lBQUU7UUFBUztRQUN4Q2l5RSxjQUFjOS9FLEdBQUcsQ0FBQysvRTtJQUNwQjtJQUNBLE9BQU8sSUFBSSxDQUFDeGpFLFFBQVEsQ0FBQ3ljLGFBQWEsQ0FBQzhtRDtBQUNyQztBQUNBYixvQkFBb0JsckYsU0FBUyxDQUFDbXNGLHFCQUFxQixHQUFHLFNBQVNBLHNCQUF1Qi9qRSxJQUFJLEVBQUU4TCxNQUFNO0lBQzlGLElBQUk1WixTQUFTLElBQUk7SUFFbkIsSUFBSXl4RSxnQkFBZ0IsSUFBSXYrRDtJQUN4QixJQUFLLElBQUlwbUIsSUFBSSxHQUFHQSxJQUFJZ2hCLEtBQUtnQyxnQkFBZ0IsSUFBSWhqQixJQUFLO1FBQ2hELElBQUk0a0YsZ0JBQWdCMXhFLE9BQU9teEUsZ0JBQWdCLENBQUNyakUsS0FBS3FCLFlBQVksQ0FBQ3JpQixJQUFJZ2hCO1FBQ2xFLElBQUk0akUsa0JBQWtCLE1BQU07WUFBRTtRQUFTO1FBQ3ZDLElBQUlBLGNBQWNseUUsT0FBTyxJQUFJO1lBQUU7UUFBUztRQUN4Q2l5RSxjQUFjOS9FLEdBQUcsQ0FBQysvRTtJQUNwQjtJQUNBLE9BQU8sSUFBSSxDQUFDeGpFLFFBQVEsQ0FBQ3ljLGFBQWEsQ0FBQzhtRDtBQUNyQztBQUNBYixvQkFBb0JsckYsU0FBUyxDQUFDZ0YsSUFBSSxHQUFHLFNBQVNBLEtBQU1xeUIsR0FBRztJQUNyRCxPQUFPQSxJQUFJcnlCLElBQUk7QUFDakI7QUFDQWttRixvQkFBb0JsckYsU0FBUyxDQUFDb3NGLDJCQUEyQixHQUFHLFNBQVNBLDRCQUE2QmhrRSxJQUFJLEVBQUU4TCxNQUFNO0lBQzFHLElBQUk1WixTQUFTLElBQUk7SUFFbkIsSUFBSXl4RSxnQkFBZ0IsSUFBSXYrRDtJQUN4QixJQUFLLElBQUlwbUIsSUFBSSxHQUFHQSxJQUFJZ2hCLEtBQUtnQyxnQkFBZ0IsSUFBSWhqQixJQUFLO1FBQ2hELElBQUk0a0YsZ0JBQWdCMXhFLE9BQU8reEUsU0FBUyxDQUFDamtFLEtBQUtxQixZQUFZLENBQUNyaUI7UUFDdkQsSUFBSTRrRixrQkFBa0IsTUFBTTtZQUFFO1FBQVM7UUFDdkMsSUFBSTF4RSxPQUFPNndFLG1CQUFtQixJQUFJYSxjQUFjbHlFLE9BQU8sSUFBSTtZQUFFO1FBQVM7UUFDdEVpeUUsY0FBYzkvRSxHQUFHLENBQUMrL0U7SUFDcEI7SUFDQSxJQUFJLElBQUksQ0FBQ1osK0JBQStCLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQzVpRSxRQUFRLENBQUN2TCx3QkFBd0IsQ0FBQ3ZFLGdCQUFnQjZzQixlQUFlLENBQUN3bUQ7SUFBZ0I7SUFDMUksT0FBTyxJQUFJLENBQUN2akUsUUFBUSxDQUFDeWMsYUFBYSxDQUFDOG1EO0FBQ3JDO0FBQ0FiLG9CQUFvQmxyRixTQUFTLENBQUNxc0YsU0FBUyxHQUFHLFNBQVNBLFVBQVc5bUIsU0FBUztJQUNyRSxJQUFJLENBQUNILFVBQVUsR0FBR0c7SUFDbEIsSUFBSSxDQUFDLzhDLFFBQVEsR0FBRys4QyxVQUFVLzdDLFVBQVU7SUFDcEMsSUFBSSs3QyxxQkFBcUIvbUMsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDK3NELGNBQWMsQ0FBQ2htQixXQUFXO0lBQU07SUFDOUUsSUFBSUEscUJBQXFCcmxDLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ2dzRCxtQkFBbUIsQ0FBQzNtQixXQUFXO0lBQU07SUFDeEYsSUFBSUEscUJBQXFCbmxDLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ3VyRCxtQkFBbUIsQ0FBQ3BtQixXQUFXO0lBQU07SUFDeEYsSUFBSUEscUJBQXFCcHJDLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQzh4RCxtQkFBbUIsQ0FBQzFtQixXQUFXO0lBQU07SUFDeEYsSUFBSUEscUJBQXFCeHNDLGlCQUFpQjtRQUFFLE9BQU8sSUFBSSxDQUFDK3lELHdCQUF3QixDQUFDdm1CLFdBQVc7SUFBTTtJQUNsRyxJQUFJQSxxQkFBcUI3bUMsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDK3NELGdCQUFnQixDQUFDbG1CLFdBQVc7SUFBTTtJQUNsRixJQUFJQSxxQkFBcUI5a0MsY0FBYztRQUFFLE9BQU8sSUFBSSxDQUFDMHJELHFCQUFxQixDQUFDNW1CLFdBQVc7SUFBTTtJQUM1RixJQUFJQSxxQkFBcUIvdEMsb0JBQW9CO1FBQUUsT0FBTyxJQUFJLENBQUM0MEQsMkJBQTJCLENBQUM3bUIsV0FBVztJQUFNO0lBQ3hHLE1BQU0sSUFBSW5qRSx5QkFBeUIsK0JBQStCbWpFLFVBQVV6akUsUUFBUSxHQUFHMi9CLE9BQU87QUFDaEc7QUFDQXlwRCxvQkFBb0JsckYsU0FBUyxDQUFDMnJGLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQnZqRSxJQUFJLEVBQUU4TCxNQUFNO0lBQzVGLElBQUltRCxNQUFNLElBQUksQ0FBQ20wRCxvQkFBb0IsQ0FBQ3BqRSxLQUFLZ1cscUJBQXFCLElBQUloVztJQUNsRSxJQUFJaVAsUUFBUSxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUM3TyxRQUFRLENBQUNwTSxnQkFBZ0IsQ0FBQztJQUFNO0lBQ2hFLElBQUlrd0UsVUFBVWoxRCxJQUFJMWpCLElBQUk7SUFDdEIsSUFBSTI0RSxVQUFVLEtBQUtBLFVBQVUsS0FBSyxDQUFDLElBQUksQ0FBQ2hCLGFBQWEsRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDOWlFLFFBQVEsQ0FBQ3JNLGdCQUFnQixDQUFDa2I7SUFBSztJQUNwRyxPQUFPLElBQUksQ0FBQzdPLFFBQVEsQ0FBQ3BNLGdCQUFnQixDQUFDaWI7QUFDeEM7QUFDQTZ6RCxvQkFBb0JsckYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ25ELE9BQU8sRUFBRTtBQUNYO0FBQ0FxcEYsb0JBQW9CbHJGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNoRCxPQUFPb3BGO0FBQ1Q7QUFFQSxJQUFJcUIsb0JBQW9CLFNBQVNBO0lBQy9CLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDcnJCLElBQUksR0FBRyxJQUFJM1Y7SUFDaEIsSUFBSSxDQUFDaWhDLDhCQUE4QixHQUFHO0lBQ3RDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLElBQUk3ckYsU0FBUyxDQUFDLEVBQUUsWUFBWXE1QixjQUFjLE9BQU9yNUIsU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzFFLElBQUk4ckYsVUFBVTlyRixTQUFTLENBQUMsRUFBRTtRQUMxQixJQUFJK3JGLGdCQUFnQi9yRixTQUFTLENBQUMsRUFBRTtRQUNoQ3lyRixrQkFBa0JocUYsSUFBSSxDQUFDLElBQUksRUFBRXFxRixRQUFRbDFELGNBQWMsSUFBSW0xRDtJQUN6RCxPQUFPLElBQUkvckYsU0FBUyxDQUFDLEVBQUUsWUFBWWYsU0FBUyxPQUFPZSxTQUFTLENBQUMsRUFBRSxLQUFLLFVBQVU7UUFDNUUsSUFBSWdzRixTQUFTaHNGLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlpc0Ysa0JBQWtCanNGLFNBQVMsQ0FBQyxFQUFFO1FBQ2xDLElBQUksQ0FBQzJyRixPQUFPLEdBQUdLO1FBQ2YsSUFBSSxDQUFDSCxTQUFTLEdBQUdKLGtCQUFrQnR6RCxRQUFRLENBQUM2ekQ7UUFDNUMsSUFBSSxDQUFDTixjQUFjLEdBQUdPO0lBQ3hCO0FBQ0Y7QUFDQVIsa0JBQWtCdnNGLFNBQVMsQ0FBQ2d0RixZQUFZLEdBQUcsU0FBU0EsYUFBY0MsU0FBUyxFQUFFMVUsT0FBTztJQUNoRixJQUFJaitELFNBQVMsSUFBSTtJQUVuQixJQUFJc1YsTUFBTSxJQUFJLENBQUMrOEQsU0FBUyxHQUFHTSxVQUFVdDVFLElBQUksS0FBSyxJQUFJczVFLFVBQVV0NUUsSUFBSTtJQUNoRSxJQUFLLElBQUl2TSxJQUFJLEdBQUdBLElBQUl3b0IsS0FBS3hvQixJQUFLO1FBQzVCLElBQUk4bEYsUUFBUUQsVUFBVTdwRixHQUFHLENBQUNnRTtRQUMxQixJQUFJK2xGLFdBQVc3eUUsT0FBTzh5RSxpQkFBaUIsQ0FBQ0YsT0FBTzNVO1FBQy9DLElBQUk0VSxhQUFhLE1BQU07WUFDckJGLFVBQVUzL0QsR0FBRyxDQUFDbG1CLEdBQUcsSUFBSTFELFdBQVd5cEY7WUFDaEMsSUFBSS9sRixNQUFNLEtBQUtrVCxPQUFPcXlFLFNBQVMsRUFBRTtnQkFBRU0sVUFBVTMvRCxHQUFHLENBQUMyL0QsVUFBVXQ1RSxJQUFJLEtBQUssR0FBRyxJQUFJalEsV0FBV3lwRjtZQUFZO1FBQ3BHO0lBQ0Y7QUFDRjtBQUNBWixrQkFBa0J2c0YsU0FBUyxDQUFDb3RGLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQnZzRSxFQUFFLEVBQUUwM0QsT0FBTztJQUNuRixJQUFJaitELFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUlteEUsUUFBUTkzRSxNQUFNLEVBQUUyRyxJQUFLO1FBQ3ZDLElBQUl5WixHQUFHdGMsUUFBUSxDQUFDZzBFLE9BQU8sQ0FBQ254RSxFQUFFLEdBQUc7WUFBRSxPQUFPO1FBQUs7UUFDM0MsSUFBSXlaLEdBQUd0YixRQUFRLENBQUNnekUsT0FBTyxDQUFDbnhFLEVBQUUsSUFBSWtULE9BQU9reUUsY0FBYyxFQUFFO1lBQUUsT0FBT2pVLE9BQU8sQ0FBQ254RSxFQUFFO1FBQUM7SUFDM0U7SUFDQSxPQUFPO0FBQ1Q7QUFDQW1sRixrQkFBa0J2c0YsU0FBUyxDQUFDcXRGLE1BQU0sR0FBRyxTQUFTQSxPQUFROVUsT0FBTztJQUMzRCxJQUFJdm5ELFlBQVksSUFBSTFDLGVBQWUsSUFBSSxDQUFDbStELE9BQU87SUFDL0MsSUFBSSxDQUFDTyxZQUFZLENBQUNoOEQsV0FBV3VuRDtJQUM3QixJQUFJLENBQUMrVSxZQUFZLENBQUN0OEQsV0FBV3VuRDtJQUM3QixJQUFJNUksU0FBUzMrQyxVQUFVN2MsaUJBQWlCO0lBQ3hDLE9BQU93N0Q7QUFDVDtBQUNBNGMsa0JBQWtCdnNGLFNBQVMsQ0FBQ3N0RixZQUFZLEdBQUcsU0FBU0EsYUFBY0wsU0FBUyxFQUFFMVUsT0FBTztJQUNoRixJQUFJaitELFNBQVMsSUFBSTtJQUVuQixJQUFJaStELFFBQVE5M0UsTUFBTSxLQUFLLEdBQUc7UUFBRSxPQUFPO0lBQUs7SUFDeEMsSUFBSThzRixrQkFBa0JoVixRQUFROTNFLE1BQU07SUFDcEMsSUFBSTgzRSxPQUFPLENBQUMsRUFBRSxDQUFDaDBFLFFBQVEsQ0FBQ2cwRSxPQUFPLENBQUNBLFFBQVE5M0UsTUFBTSxHQUFHLEVBQUUsR0FBRztRQUFFOHNGLGtCQUFrQmhWLFFBQVE5M0UsTUFBTSxHQUFHO0lBQUc7SUFDOUYsSUFBSyxJQUFJMkcsSUFBSSxHQUFHQSxJQUFJbW1GLGlCQUFpQm5tRixJQUFLO1FBQ3hDLElBQUlveEUsU0FBU0QsT0FBTyxDQUFDbnhFLEVBQUU7UUFDdkIsSUFBSWlCLFFBQVFpUyxPQUFPa3pFLHNCQUFzQixDQUFDaFYsUUFBUXlVO1FBQ2xELElBQUk1a0YsU0FBUyxHQUFHO1lBQ2Q0a0YsVUFBVWhoRixHQUFHLENBQUM1RCxRQUFRLEdBQUcsSUFBSTNFLFdBQVc4MEUsU0FBUztRQUNuRDtJQUNGO0FBQ0Y7QUFDQStULGtCQUFrQnZzRixTQUFTLENBQUN3dEYsc0JBQXNCLEdBQUcsU0FBU0EsdUJBQXdCaFYsTUFBTSxFQUFFeVUsU0FBUztJQUNuRyxJQUFJM3lFLFNBQVMsSUFBSTtJQUVuQixJQUFJZ0ssVUFBVXpoQixPQUFPRSxTQUFTO0lBQzlCLElBQUkwcUYsWUFBWSxDQUFDO0lBQ2pCLElBQUssSUFBSXJtRixJQUFJLEdBQUdBLElBQUk2bEYsVUFBVXQ1RSxJQUFJLEtBQUssR0FBR3ZNLElBQUs7UUFDN0NrVCxPQUFPOG1ELElBQUksQ0FBQzlqRCxFQUFFLEdBQUcydkUsVUFBVTdwRixHQUFHLENBQUNnRTtRQUMvQmtULE9BQU84bUQsSUFBSSxDQUFDN3ZELEVBQUUsR0FBRzA3RSxVQUFVN3BGLEdBQUcsQ0FBQ2dFLElBQUk7UUFDbkMsSUFBSWtULE9BQU84bUQsSUFBSSxDQUFDOWpELEVBQUUsQ0FBQy9ZLFFBQVEsQ0FBQ2kwRSxXQUFXbCtELE9BQU84bUQsSUFBSSxDQUFDN3ZELEVBQUUsQ0FBQ2hOLFFBQVEsQ0FBQ2kwRSxTQUFTO1lBQ3RFLElBQUlsK0QsT0FBT295RSw4QkFBOEIsRUFBRTtnQkFBRTtZQUFVLE9BQU87Z0JBQUUsT0FBTyxDQUFDO1lBQUU7UUFDNUU7UUFDQSxJQUFJbHNFLE9BQU9sRyxPQUFPOG1ELElBQUksQ0FBQzc3RCxRQUFRLENBQUNpekU7UUFDaEMsSUFBSWg0RCxPQUFPbEcsT0FBT2t5RSxjQUFjLElBQUloc0UsT0FBTzhELFNBQVM7WUFDbERBLFVBQVU5RDtZQUNWaXRFLFlBQVlybUY7UUFDZDtJQUNGO0lBQ0EsT0FBT3FtRjtBQUNUO0FBQ0FsQixrQkFBa0J2c0YsU0FBUyxDQUFDMHRGLGdDQUFnQyxHQUFHLFNBQVNBLGlDQUFrQ0MsNkJBQTZCO0lBQ3JJLElBQUksQ0FBQ2pCLDhCQUE4QixHQUFHaUI7QUFDeEM7QUFDQXBCLGtCQUFrQnZzRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxFQUFFO0FBQ1g7QUFDQTBxRixrQkFBa0J2c0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzlDLE9BQU95cUY7QUFDVDtBQUNBQSxrQkFBa0J0ekQsUUFBUSxHQUFHLFNBQVNBLFNBQVVoUyxHQUFHO0lBQ2pELElBQUlBLElBQUl4bUIsTUFBTSxJQUFJLEdBQUc7UUFBRSxPQUFPO0lBQU07SUFDcEMsT0FBT3dtQixHQUFHLENBQUMsRUFBRSxDQUFDMWlCLFFBQVEsQ0FBQzBpQixHQUFHLENBQUNBLElBQUl4bUIsTUFBTSxHQUFHLEVBQUU7QUFDNUM7QUFFQSxJQUFJbXRGLGtCQUFrQixTQUFTQSxnQkFBaUJDLE9BQU87SUFDckQsSUFBSSxDQUFDQyxRQUFRLEdBQUdELFdBQVc7QUFDN0I7QUFFQSxJQUFJRSxxQkFBcUI7SUFBRUMsdUJBQXVCO1FBQUU3dEYsY0FBYztJQUFLO0FBQUU7QUFDekV5dEYsZ0JBQWdCNXRGLFNBQVMsQ0FBQ3F0RixNQUFNLEdBQUcsU0FBU0EsT0FBUVksUUFBUSxFQUFFcEIsYUFBYTtJQUN6RSxJQUFJdFUsVUFBVSxJQUFJLENBQUMyVix3QkFBd0IsQ0FBQ0Q7SUFDNUMsSUFBSUUsWUFBWSxJQUFJQyxnQkFBZ0J2QixlQUFldFU7SUFDbkQsT0FBTzRWLFVBQVU5QixTQUFTLENBQUMsSUFBSSxDQUFDeUIsUUFBUTtBQUMxQztBQUNBRixnQkFBZ0I1dEYsU0FBUyxDQUFDcXVGLFVBQVUsR0FBRyxTQUFTQSxXQUFZeEIsYUFBYSxFQUFFeUIsV0FBVztJQUNwRixJQUFJL1YsVUFBVSxJQUFJLENBQUMyVix3QkFBd0IsQ0FBQyxJQUFJLENBQUNKLFFBQVE7SUFDekQsSUFBSUssWUFBWSxJQUFJQyxnQkFBZ0J2QixlQUFldFUsU0FBUztJQUM1RCxJQUFJZ1csY0FBY0osVUFBVTlCLFNBQVMsQ0FBQyxJQUFJLENBQUN5QixRQUFRO0lBQ25ELElBQUlyb0YsU0FBUzhvRjtJQUNiLElBQUlELGVBQWVubkYsYUFBYTFCLFFBQVFnNUIsWUFBWTtRQUNsRGg1QixTQUFTOG9GLFlBQVl4YyxNQUFNLENBQUM7SUFDOUI7SUFDQSxPQUFPdHNFO0FBQ1Q7QUFDQW1vRixnQkFBZ0I1dEYsU0FBUyxDQUFDd3VGLG9CQUFvQixHQUFHLFNBQVNBLHFCQUFzQkMsT0FBTztJQUNyRixJQUFJQyxZQUFZLElBQUksQ0FBQ0MsMkJBQTJCLENBQUNGO0lBQ2pELElBQUlHLFVBQVVGLFlBQVk7SUFDMUIsT0FBT0U7QUFDVDtBQUNBaEIsZ0JBQWdCNXRGLFNBQVMsQ0FBQ2t1Rix3QkFBd0IsR0FBRyxTQUFTQSx5QkFBMEJya0UsQ0FBQztJQUN2RixJQUFJZ2xFLFFBQVEsSUFBSXI1RDtJQUNoQixJQUFJdk8sTUFBTTRDLEVBQUU2TixjQUFjO0lBQzFCLElBQUssSUFBSXR3QixJQUFJLEdBQUdBLElBQUk2ZixJQUFJeG1CLE1BQU0sRUFBRTJHLElBQUs7UUFDbkN5bkYsTUFBTTVpRixHQUFHLENBQUNnYixHQUFHLENBQUM3ZixFQUFFO0lBQ2xCO0lBQ0EsT0FBT3luRixNQUFNN2hFLE9BQU8sQ0FBQyxJQUFJanRCLE1BQU0sR0FBR00sSUFBSSxDQUFDO0FBQ3pDO0FBQ0F1dEYsZ0JBQWdCNXRGLFNBQVMsQ0FBQzJ1RiwyQkFBMkIsR0FBRyxTQUFTQSw0QkFBNkIxbkUsR0FBRztJQUMvRixJQUFJeW5FLFlBQVk3ckYsT0FBT0UsU0FBUztJQUNoQyxJQUFLLElBQUlxRSxJQUFJLEdBQUdBLElBQUk2ZixJQUFJeG1CLE1BQU0sR0FBRyxHQUFHMkcsSUFBSztRQUN2QyxJQUFJMG5GLFNBQVM3bkUsR0FBRyxDQUFDN2YsRUFBRSxDQUFDN0IsUUFBUSxDQUFDMGhCLEdBQUcsQ0FBQzdmLElBQUksRUFBRTtRQUN2QyxJQUFJMG5GLFNBQVNKLFdBQVc7WUFBRUEsWUFBWUk7UUFBUTtJQUNoRDtJQUNBLE9BQU9KO0FBQ1Q7QUFDQWQsZ0JBQWdCNXRGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMvQyxPQUFPLEVBQUU7QUFDWDtBQUNBK3JGLGdCQUFnQjV0RixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDNUMsT0FBTzhyRjtBQUNUO0FBQ0FBLGdCQUFnQm5YLElBQUksR0FBRyxTQUFTQSxLQUFNNEosRUFBRSxFQUFFQyxFQUFFLEVBQUV1TSxhQUFhO0lBQ3pELElBQUlvQixXQUFXLElBQUlsdUYsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDakMsSUFBSTB1RixXQUFXLElBQUluQixnQkFBZ0J2TjtJQUNuQzROLFFBQVEsQ0FBQyxFQUFFLEdBQUdjLFNBQVMxQixNQUFNLENBQUMvTSxJQUFJdU07SUFDbEMsSUFBSW1DLFdBQVcsSUFBSXBCLGdCQUFnQnROO0lBQ25DMk4sUUFBUSxDQUFDLEVBQUUsR0FBR2UsU0FBUzNCLE1BQU0sQ0FBQ1ksUUFBUSxDQUFDLEVBQUUsRUFBRXBCO0lBQzNDLE9BQU9vQjtBQUNUO0FBQ0FMLGdCQUFnQnFCLDJCQUEyQixHQUFHLFNBQVNBO0lBQ3JELElBQUludUYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSW9wQixJQUFJL29CLFNBQVMsQ0FBQyxFQUFFO1FBQ3BCLElBQUkrckYsZ0JBQWdCZSxnQkFBZ0JzQiw2QkFBNkIsQ0FBQ3JsRTtRQUNsRSxJQUFJNlosS0FBSzdaLEVBQUVrQixpQkFBaUI7UUFDNUIsSUFBSTJZLEdBQUdTLE9BQU8sT0FBT2pCLGVBQWVNLEtBQUssRUFBRTtZQUN6QyxJQUFJMnJELGVBQWUsSUFBSXpyRCxHQUFHTSxRQUFRLEtBQUssSUFBSTtZQUMzQyxJQUFJbXJELGVBQWV0QyxlQUFlO2dCQUFFQSxnQkFBZ0JzQztZQUFjO1FBQ3BFO1FBQ0EsT0FBT3RDO0lBQ1QsT0FBTyxJQUFJL3JGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk0L0UsS0FBS3YvRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJdy9FLEtBQUt4L0UsU0FBUyxDQUFDLEVBQUU7UUFDckIsT0FBT0osS0FBS0UsR0FBRyxDQUFDZ3RGLGdCQUFnQnFCLDJCQUEyQixDQUFDNU8sS0FBS3VOLGdCQUFnQnFCLDJCQUEyQixDQUFDM087SUFDL0c7QUFDRjtBQUNBc04sZ0JBQWdCc0IsNkJBQTZCLEdBQUcsU0FBU0EsOEJBQStCcmxFLENBQUM7SUFDdkYsSUFBSTVWLE1BQU00VixFQUFFYyxtQkFBbUI7SUFDL0IsSUFBSXlrRSxlQUFlMXVGLEtBQUtFLEdBQUcsQ0FBQ3FULElBQUl5QyxTQUFTLElBQUl6QyxJQUFJd0MsUUFBUTtJQUN6RCxJQUFJbTRFLFVBQVVRLGVBQWV4QixnQkFBZ0JJLHFCQUFxQjtJQUNsRSxPQUFPWTtBQUNUO0FBQ0FoQixnQkFBZ0JTLFVBQVUsR0FBRyxTQUFTQSxXQUFZam1FLElBQUksRUFBRXlrRSxhQUFhLEVBQUV5QixXQUFXO0lBQ2hGLElBQUlTLFdBQVcsSUFBSW5CLGdCQUFnQnhsRTtJQUNuQyxPQUFPMm1FLFNBQVNWLFVBQVUsQ0FBQ3hCLGVBQWV5QjtBQUM1QztBQUNBUCxtQkFBbUJDLHFCQUFxQixDQUFDNXFGLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBSztBQUV6RW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRXVxRixpQkFBaUJHO0FBRTFDLElBQUlLLGtCQUFtQixTQUFVaUIsc0JBQXNCO0lBQ3JELFNBQVNqQixnQkFBaUJ2QixhQUFhLEVBQUV0VSxPQUFPLEVBQUUrVyxVQUFVO1FBQzFERCx1QkFBdUI5c0YsSUFBSSxDQUFDLElBQUk7UUFDaEMsSUFBSSxDQUFDaXFGLGNBQWMsR0FBR0ssaUJBQWlCO1FBQ3ZDLElBQUksQ0FBQzBDLFFBQVEsR0FBR2hYLFdBQVc7UUFDM0IsSUFBSSxDQUFDaVgsV0FBVyxHQUFHLGVBQWdCbHZGLFlBQWFndkYsYUFBYTtJQUMvRDtJQUVBLElBQUtELHdCQUF5QmpCLGdCQUFnQjFyRixTQUFTLEdBQUcyc0Y7SUFDMURqQixnQkFBZ0JwdUYsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFMHNGLDBCQUEwQkEsdUJBQXVCcnZGLFNBQVM7SUFDckdvdUYsZ0JBQWdCcHVGLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3dyRjtJQUN4Q0EsZ0JBQWdCcHVGLFNBQVMsQ0FBQ3l2RixRQUFRLEdBQUcsU0FBU0EsU0FBVTNDLE1BQU0sRUFBRXZVLE9BQU87UUFDckUsSUFBSW1YLFVBQVUsSUFBSW5ELGtCQUFrQk8sUUFBUSxJQUFJLENBQUNOLGNBQWM7UUFDL0RrRCxRQUFRaEMsZ0NBQWdDLENBQUMsSUFBSSxDQUFDOEIsV0FBVztRQUN6RCxPQUFPRSxRQUFRckMsTUFBTSxDQUFDOVU7SUFDeEI7SUFDQTZWLGdCQUFnQnB1RixTQUFTLENBQUN3ckYsb0JBQW9CLEdBQUcsU0FBU0EscUJBQXNCN3ZFLE1BQU0sRUFBRXVZLE1BQU07UUFDNUYsSUFBSTQ0RCxTQUFTbnhFLE9BQU94SCxpQkFBaUI7UUFDckMsSUFBSXc3RCxTQUFTLElBQUksQ0FBQzhmLFFBQVEsQ0FBQzNDLFFBQVEsSUFBSSxDQUFDeUMsUUFBUTtRQUNoRCxPQUFPLElBQUksQ0FBQy9tRSxRQUFRLENBQUM2Viw0QkFBNEIsR0FBRzE3QixNQUFNLENBQUNndEU7SUFDN0Q7SUFDQXllLGdCQUFnQnB1RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7UUFDL0MsT0FBTyxFQUFFO0lBQ1g7SUFDQXVzRixnQkFBZ0JwdUYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQzVDLE9BQU9zc0Y7SUFDVDtJQUVBLE9BQU9BO0FBQ1QsRUFBRWxEO0FBRUYsSUFBSXlFLGFBQWEsU0FBU0E7SUFDeEIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRztJQUNoQyxJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRztBQUN4QjtBQUNBSixXQUFXM3ZGLFNBQVMsQ0FBQ2d3RixTQUFTLEdBQUcsU0FBU0E7SUFDeEMsT0FBT250RixPQUFPSyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM0c0YsV0FBVztBQUNqRDtBQUNBSCxXQUFXM3ZGLFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQSxJQUFLdUQsR0FBRztJQUMxQyxJQUFJeWdGLFVBQVVwdEYsT0FBT0ksZ0JBQWdCLENBQUN1TTtJQUN0QyxJQUFJLElBQUksQ0FBQ29nRixRQUFRLEVBQUU7UUFDakIsSUFBSSxDQUFDRSxXQUFXLEdBQUdHO1FBQ25CLElBQUksQ0FBQ0YsY0FBYyxHQUFHSixXQUFXTyxXQUFXLENBQUMsSUFBSSxDQUFDSixXQUFXO1FBQzdELElBQUksQ0FBQ0YsUUFBUSxHQUFHO1FBQ2hCLE9BQU87SUFDVDtJQUNBLElBQUlPLGFBQWFSLFdBQVdPLFdBQVcsQ0FBQ0Q7SUFDeEMsSUFBSUUsZUFBZSxJQUFJLENBQUNKLGNBQWMsRUFBRTtRQUN0QyxJQUFJLENBQUNELFdBQVcsR0FBRztRQUNuQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNELHdCQUF3QixHQUFHRixXQUFXUyw0QkFBNEIsQ0FBQyxJQUFJLENBQUNOLFdBQVcsRUFBRUc7SUFDMUYsSUFBSSxDQUFDSCxXQUFXLEdBQUdILFdBQVdVLGFBQWEsQ0FBQyxJQUFJLENBQUNQLFdBQVcsRUFBRSxLQUFNLE1BQUssSUFBSSxDQUFDRCx3QkFBd0I7QUFDeEc7QUFDQUYsV0FBVzN2RixTQUFTLENBQUNpRixRQUFRLEdBQUcsU0FBU0E7SUFDdkMsSUFBSW5FLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUk2dkYsT0FBT3h2RixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJWSxJQUFJbUIsT0FBT0ssZ0JBQWdCLENBQUNvdEY7UUFDaEMsSUFBSUMsU0FBUzF0RixPQUFPMnRGLGNBQWMsQ0FBQ0Y7UUFDbkMsSUFBSUcsU0FBUyxxRUFBcUVGO1FBQ2xGLElBQUlHLFNBQVNELE9BQU96Z0YsU0FBUyxDQUFDeWdGLE9BQU9od0YsTUFBTSxHQUFHO1FBQzlDLElBQUlrSSxNQUFNK25GLE9BQU8xZ0YsU0FBUyxDQUFDLEdBQUcsS0FBSyxPQUFPMGdGLE9BQU8xZ0YsU0FBUyxDQUFDLEdBQUcsTUFBTSxXQUFXMGdGLE9BQU8xZ0YsU0FBUyxDQUFDLE1BQU0sUUFBUXRPLElBQUk7UUFDbEgsT0FBT2lIO0lBQ1Q7QUFDRjtBQUNBZ25GLFdBQVczdkYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQzFDLE9BQU8sRUFBRTtBQUNYO0FBQ0E4dEYsV0FBVzN2RixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdkMsT0FBTzZ0RjtBQUNUO0FBQ0FBLFdBQVdnQixNQUFNLEdBQUcsU0FBU0EsT0FBUUwsSUFBSSxFQUFFbHBGLENBQUM7SUFDMUMsSUFBSXdwRixPQUFPLEtBQUt4cEY7SUFDaEIsT0FBTyxDQUFDa3BGLE9BQU9NLElBQUcsTUFBTyxJQUFJLElBQUk7QUFDbkM7QUFDQWpCLFdBQVdPLFdBQVcsR0FBRyxTQUFTQSxZQUFhMWdGLEdBQUc7SUFDaEQsT0FBT0EsT0FBTztBQUNoQjtBQUNBbWdGLFdBQVdVLGFBQWEsR0FBRyxTQUFTQSxjQUFlQyxJQUFJLEVBQUVPLEtBQUs7SUFDNUQsSUFBSUMsVUFBVSxDQUFDLEtBQUtELEtBQUksSUFBSztJQUM3QixJQUFJRCxPQUFPLENBQUNFO0lBQ1osSUFBSUMsU0FBU1QsT0FBT007SUFDcEIsT0FBT0c7QUFDVDtBQUNBcEIsV0FBV1MsNEJBQTRCLEdBQUcsU0FBU0EsNkJBQThCWSxJQUFJLEVBQUVDLElBQUk7SUFDekYsSUFBSXAyRCxRQUFRO0lBQ1osSUFBSyxJQUFJenpCLElBQUksSUFBSUEsS0FBSyxHQUFHQSxJQUFLO1FBQzVCLElBQUl1b0YsV0FBV2dCLE1BQU0sQ0FBQ0ssTUFBTTVwRixPQUFPdW9GLFdBQVdnQixNQUFNLENBQUNNLE1BQU03cEYsSUFBSTtZQUFFLE9BQU95ekI7UUFBTTtRQUM5RUE7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBLElBQUlxMkQsb0JBQW9CLFNBQVNBO0lBQy9CLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUlDO0FBQ3ZCO0FBRUEsSUFBSUMscUJBQXFCO0lBQUVELHdCQUF3QjtRQUFFbHhGLGNBQWM7SUFBSztJQUFFb3hGLFlBQVk7UUFBRXB4RixjQUFjO0lBQUs7QUFBRTtBQUM3Ryt3RixrQkFBa0JseEYsU0FBUyxDQUFDd3hGLGFBQWEsR0FBRyxTQUFTQSxjQUFlcHBFLElBQUk7SUFDdEUsSUFBSXFwRSxRQUFRLElBQUlGLFdBQVcsSUFBSSxDQUFDSixZQUFZO0lBQzVDL29FLEtBQUs3TyxLQUFLLENBQUNrNEU7SUFDWHJwRSxLQUFLMkIsZUFBZTtBQUN0QjtBQUNBbW5FLGtCQUFrQmx4RixTQUFTLENBQUMweEYsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCdHBFLElBQUk7SUFDNUUsSUFBSSxJQUFJLENBQUMrb0UsWUFBWSxDQUFDenZGLENBQUMsS0FBSyxPQUFPLElBQUksQ0FBQ3l2RixZQUFZLENBQUN4dEYsQ0FBQyxLQUFLLEtBQUs7UUFBRSxPQUFPeWtCO0lBQUs7SUFDOUUsSUFBSXVwRSxXQUFXLElBQUlqdUYsV0FBVyxJQUFJLENBQUN5dEYsWUFBWTtJQUMvQ1EsU0FBU2p3RixDQUFDLEdBQUcsQ0FBQ2l3RixTQUFTandGLENBQUM7SUFDeEJpd0YsU0FBU2h1RixDQUFDLEdBQUcsQ0FBQ2d1RixTQUFTaHVGLENBQUM7SUFDeEIsSUFBSTh0RixRQUFRLElBQUlGLFdBQVdJO0lBQzNCdnBFLEtBQUs3TyxLQUFLLENBQUNrNEU7SUFDWHJwRSxLQUFLMkIsZUFBZTtJQUNwQixPQUFPM0I7QUFDVDtBQUNBOG9FLGtCQUFrQmx4RixTQUFTLENBQUM0eEYsbUJBQW1CLEdBQUcsU0FBU0E7SUFDekQsT0FBTyxJQUFJLENBQUNULFlBQVk7QUFDMUI7QUFDQUQsa0JBQWtCbHhGLFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQSxJQUFLbWMsSUFBSTtJQUNsREEsS0FBSzdPLEtBQUssQ0FBQyxJQUFJLENBQUM2M0UsU0FBUztJQUN6QixJQUFJLENBQUNELFlBQVksR0FBRyxJQUFJLENBQUNDLFNBQVMsQ0FBQ1EsbUJBQW1CO0FBQ3hEO0FBQ0FWLGtCQUFrQmx4RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxFQUFFO0FBQ1g7QUFDQXF2RixrQkFBa0JseEYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzlDLE9BQU9vdkY7QUFDVDtBQUNBSSxtQkFBbUJELHNCQUFzQixDQUFDanVGLEdBQUcsR0FBRztJQUFjLE9BQU9pdUY7QUFBdUI7QUFDNUZDLG1CQUFtQkMsVUFBVSxDQUFDbnVGLEdBQUcsR0FBRztJQUFjLE9BQU9tdUY7QUFBVztBQUVwRXR4RixPQUFPb0QsZ0JBQWdCLENBQUU2dEYsbUJBQW1CSTtBQUU1QyxJQUFJRCx5QkFBeUIsU0FBU0E7SUFDcEMsSUFBSSxDQUFDUSxZQUFZLEdBQUcsSUFBSWxDO0lBQ3hCLElBQUksQ0FBQ21DLFlBQVksR0FBRyxJQUFJbkM7QUFDMUI7QUFDQTBCLHVCQUF1QnJ4RixTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVE2RCxLQUFLO0lBQzlELElBQUksQ0FBQzZsRSxZQUFZLENBQUM1bEYsR0FBRyxDQUFDK2YsTUFBTXRxQixDQUFDO0lBQzdCLElBQUksQ0FBQ293RixZQUFZLENBQUM3bEYsR0FBRyxDQUFDK2YsTUFBTXJvQixDQUFDO0FBQy9CO0FBQ0EwdEYsdUJBQXVCcnhGLFNBQVMsQ0FBQzR4RixtQkFBbUIsR0FBRyxTQUFTQTtJQUM5RCxPQUFPLElBQUlsdUYsV0FBVyxJQUFJLENBQUNtdUYsWUFBWSxDQUFDN0IsU0FBUyxJQUFJLElBQUksQ0FBQzhCLFlBQVksQ0FBQzlCLFNBQVM7QUFDbEY7QUFDQXFCLHVCQUF1QnJ4RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdEQsT0FBTztRQUFDa3FCO0tBQWlCO0FBQzNCO0FBQ0FzbEUsdUJBQXVCcnhGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNuRCxPQUFPdXZGO0FBQ1Q7QUFFQSxJQUFJRSxhQUFhLFNBQVNBO0lBQ3hCLElBQUksQ0FBQ0UsS0FBSyxHQUFHO0lBQ2IsSUFBSUEsUUFBUTN3RixTQUFTLENBQUMsRUFBRTtJQUN4QixJQUFJLENBQUMyd0YsS0FBSyxHQUFHQTtBQUNmO0FBQ0FGLFdBQVd2eEYsU0FBUyxDQUFDbW9CLE1BQU0sR0FBRyxTQUFTQSxPQUFRa1AsR0FBRyxFQUFFandCLENBQUM7SUFDbkQsSUFBSTJxRixLQUFLMTZELElBQUk1eUIsV0FBVyxDQUFDMkMsR0FBRyxLQUFLLElBQUksQ0FBQ3FxRixLQUFLLENBQUMvdkYsQ0FBQztJQUM3QyxJQUFJc3dGLEtBQUszNkQsSUFBSTV5QixXQUFXLENBQUMyQyxHQUFHLEtBQUssSUFBSSxDQUFDcXFGLEtBQUssQ0FBQzl0RixDQUFDO0lBQzdDMHpCLElBQUloekIsV0FBVyxDQUFDK0MsR0FBRyxHQUFHMnFGO0lBQ3RCMTZELElBQUloekIsV0FBVyxDQUFDK0MsR0FBRyxHQUFHNHFGO0FBQ3hCO0FBQ0FULFdBQVd2eEYsU0FBUyxDQUFDczNCLE1BQU0sR0FBRyxTQUFTQTtJQUNyQyxPQUFPO0FBQ1Q7QUFDQWk2RCxXQUFXdnhGLFNBQVMsQ0FBQ3UzQixpQkFBaUIsR0FBRyxTQUFTQTtJQUNoRCxPQUFPO0FBQ1Q7QUFDQWc2RCxXQUFXdnhGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUMxQyxPQUFPO1FBQUN1MUI7S0FBeUI7QUFDbkM7QUFDQW02RCxXQUFXdnhGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUN2QyxPQUFPeXZGO0FBQ1Q7QUFFQSxJQUFJVSxnQkFBZ0IsU0FBU0EsY0FBZTNSLEVBQUUsRUFBRTdZLEVBQUU7SUFDaEQsSUFBSSxDQUFDbnVDLEtBQUssR0FBRyxJQUFJdjVCLE1BQU0sR0FBR00sSUFBSSxDQUFDO0lBQy9CLElBQUksQ0FBQ21zRixjQUFjLEdBQUc7SUFDdEIsSUFBSSxDQUFDMEYsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDNTRELEtBQUssQ0FBQyxFQUFFLEdBQUdnbkQ7SUFDaEIsSUFBSSxDQUFDaG5ELEtBQUssQ0FBQyxFQUFFLEdBQUdtdUM7SUFDaEIsSUFBSSxDQUFDK21CLG9CQUFvQjtBQUMzQjtBQUNBeUQsY0FBY2p5RixTQUFTLENBQUNteUYsUUFBUSxHQUFHLFNBQVNBLFNBQVUvcEUsSUFBSTtJQUN4RCxJQUFJMm1FLFdBQVcsSUFBSW5CLGdCQUFnQnhsRTtJQUNuQyxJQUFJNmxFLFdBQVdjLFNBQVMxQixNQUFNLENBQUNqbEUsTUFBTSxJQUFJLENBQUNva0UsY0FBYztJQUN4RCxPQUFPeUI7QUFDVDtBQUNBZ0UsY0FBY2p5RixTQUFTLENBQUMweEYsZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWtCdHBFLElBQUk7SUFDeEUsSUFBSSxDQUFDOHBFLElBQUksR0FBRyxJQUFJaEI7SUFDaEIsSUFBSSxDQUFDZ0IsSUFBSSxDQUFDam1GLEdBQUcsQ0FBQ21jLElBQUksQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQzhwRSxJQUFJLENBQUNqbUYsR0FBRyxDQUFDbWMsSUFBSSxDQUFDLEVBQUU7SUFDckIsSUFBSWdxRSxVQUFVLElBQUlyeUYsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDaEMreEYsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ1IsZ0JBQWdCLENBQUN0cEUsSUFBSSxDQUFDLEVBQUUsQ0FBQ3BqQixJQUFJO0lBQ3BEb3RGLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDRixJQUFJLENBQUNSLGdCQUFnQixDQUFDdHBFLElBQUksQ0FBQyxFQUFFLENBQUNwakIsSUFBSTtJQUNwRCxPQUFPb3RGO0FBQ1Q7QUFDQUgsY0FBY2p5RixTQUFTLENBQUNxeUYsYUFBYSxHQUFHLFNBQVNBLGNBQWVqcUUsSUFBSTtJQUNsRSxJQUFJLENBQUM4cEUsSUFBSSxDQUFDVixhQUFhLENBQUNwcEU7SUFDeEIsT0FBT0E7QUFDVDtBQUNBNnBFLGNBQWNqeUYsU0FBUyxDQUFDMjVFLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQm9RLE1BQU07SUFDNUUsSUFBSXVJLFdBQVcsSUFBSSxDQUFDN2IsSUFBSSxDQUFDLElBQUksQ0FBQ245QyxLQUFLO0lBQ25DLElBQUk3ekIsU0FBUzhrRixVQUFVZ0ksU0FBUyxDQUFDRCxRQUFRLENBQUMsRUFBRSxFQUFFQSxRQUFRLENBQUMsRUFBRSxFQUFFdkk7SUFDM0QsT0FBTyxJQUFJLENBQUNzSSxhQUFhLENBQUM1c0Y7QUFDNUI7QUFDQXdzRixjQUFjanlGLFNBQVMsQ0FBQ3MwRSxVQUFVLEdBQUcsU0FBU0EsV0FBWXpxRCxDQUFDO0lBQ3pELElBQUksQ0FBQ0EsRUFBRXNXLE9BQU8sSUFBSTtRQUNoQjVyQixPQUFPbU8sR0FBRyxDQUFDQyxPQUFPLENBQUM7SUFDckI7QUFDRjtBQUNBc3ZFLGNBQWNqeUYsU0FBUyxDQUFDd3VGLG9CQUFvQixHQUFHLFNBQVNBO0lBQ3RELElBQUksQ0FBQ2hDLGNBQWMsR0FBR29CLGdCQUFnQnFCLDJCQUEyQixDQUFDLElBQUksQ0FBQzMxRCxLQUFLLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUU7QUFDaEc7QUFDQTI0RCxjQUFjanlGLFNBQVMsQ0FBQ3kyRSxJQUFJLEdBQUcsU0FBU0EsS0FBTXJ1RCxJQUFJO0lBQ2hELElBQUlncUUsVUFBVSxJQUFJLENBQUNWLGdCQUFnQixDQUFDdHBFO0lBQ3BDLElBQUk2bEUsV0FBV0wsZ0JBQWdCblgsSUFBSSxDQUFDMmIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsT0FBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUM1RixjQUFjO0lBQy9FLE9BQU95QjtBQUNUO0FBQ0FnRSxjQUFjanlGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM3QyxPQUFPLEVBQUU7QUFDWDtBQUNBb3dGLGNBQWNqeUYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzFDLE9BQU9td0Y7QUFDVDtBQUNBQSxjQUFjTSxTQUFTLEdBQUcsU0FBU0EsVUFBV2xTLEVBQUUsRUFBRUMsRUFBRSxFQUFFeUosTUFBTTtJQUMxRCxJQUFJUixLQUFLLElBQUkwSSxjQUFjNVIsSUFBSUM7SUFDL0IsT0FBT2lKLEdBQUc1UCxpQkFBaUIsQ0FBQ29RO0FBQzlCO0FBQ0FrSSxjQUFjTyxLQUFLLEdBQUcsU0FBU0EsTUFBT25TLEVBQUUsRUFBRUMsRUFBRTtJQUMxQyxPQUFPMlIsY0FBY00sU0FBUyxDQUFDbFMsSUFBSUMsSUFBSWlLLFVBQVVrSSxLQUFLO0FBQ3hEO0FBQ0FSLGNBQWM5L0UsWUFBWSxHQUFHLFNBQVNBLGFBQWNrdUUsRUFBRSxFQUFFQyxFQUFFO0lBQ3hELE9BQU8yUixjQUFjTSxTQUFTLENBQUNsUyxJQUFJQyxJQUFJaUssVUFBVUssWUFBWTtBQUMvRDtBQUNBcUgsY0FBY1MsYUFBYSxHQUFHLFNBQVNBLGNBQWVyUyxFQUFFLEVBQUVDLEVBQUU7SUFDMUQsT0FBTzJSLGNBQWNNLFNBQVMsQ0FBQ2xTLElBQUlDLElBQUlpSyxVQUFVb0ksYUFBYTtBQUNoRTtBQUNBVixjQUFjVyxVQUFVLEdBQUcsU0FBU0EsV0FBWXZTLEVBQUUsRUFBRUMsRUFBRTtJQUNwRCxPQUFPMlIsY0FBY00sU0FBUyxDQUFDbFMsSUFBSUMsSUFBSWlLLFVBQVVzSSxVQUFVO0FBQzdEO0FBRUEsSUFBSUMsd0JBQXdCLFNBQVNBLHNCQUF1QnhTLEVBQUUsRUFBRTdZLEVBQUU7SUFDaEUsSUFBSSxDQUFDbnVDLEtBQUssR0FBRyxJQUFJdjVCLE1BQU0sR0FBR00sSUFBSSxDQUFDO0lBQy9CLElBQUksQ0FBQ2k1QixLQUFLLENBQUMsRUFBRSxHQUFHZ25EO0lBQ2hCLElBQUksQ0FBQ2huRCxLQUFLLENBQUMsRUFBRSxHQUFHbXVDO0FBQ2xCO0FBQ0FxckIsc0JBQXNCOXlGLFNBQVMsQ0FBQzI1RSxpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJvUSxNQUFNO0lBQ3BGLElBQUl0a0YsU0FBUztJQUNiLElBQUlzdEYsWUFBWTtJQUNoQixJQUFJQyxpQkFBaUI7SUFDckIsSUFBSTtRQUNGdnRGLFNBQVM4a0YsVUFBVWdJLFNBQVMsQ0FBQyxJQUFJLENBQUNqNUQsS0FBSyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLEtBQUssQ0FBQyxFQUFFLEVBQUV5d0Q7UUFDM0QsSUFBSTVwRCxVQUFVO1FBQ2QsSUFBSUEsU0FBUztZQUFFNHlELFlBQVk7UUFBTTtJQUNuQyxFQUFFLE9BQU9yaUYsSUFBSTtRQUNYLElBQUlBLGNBQWM2TSxrQkFBa0I7WUFDbEN5MUUsaUJBQWlCdGlGO1FBQ25CLE9BQU87WUFBRSxNQUFNQTtRQUFHO0lBQ3BCLFNBQVUsQ0FBQztJQUNYLElBQUksQ0FBQ3FpRixXQUFXO1FBQ2QsSUFBSTtZQUNGdHRGLFNBQVN3c0YsY0FBY00sU0FBUyxDQUFDLElBQUksQ0FBQ2o1RCxLQUFLLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsRUFBRXl3RDtRQUNqRSxFQUFFLE9BQU9yNUUsSUFBSTtZQUNYLElBQUlBLGNBQWM2TSxrQkFBa0I7Z0JBQ2xDLE1BQU15MUU7WUFDUixPQUFPO2dCQUFFLE1BQU10aUY7WUFBRztRQUNwQixTQUFVLENBQUM7SUFDYjtJQUNBLE9BQU9qTDtBQUNUO0FBQ0FxdEYsc0JBQXNCOXlGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNyRCxPQUFPLEVBQUU7QUFDWDtBQUNBaXhGLHNCQUFzQjl5RixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbEQsT0FBT2d4RjtBQUNUO0FBQ0FBLHNCQUFzQlAsU0FBUyxHQUFHLFNBQVNBLFVBQVdsUyxFQUFFLEVBQUVDLEVBQUUsRUFBRXlKLE1BQU07SUFDbEUsSUFBSVIsS0FBSyxJQUFJdUosc0JBQXNCelMsSUFBSUM7SUFDdkMsT0FBT2lKLEdBQUc1UCxpQkFBaUIsQ0FBQ29RO0FBQzlCO0FBQ0ErSSxzQkFBc0JOLEtBQUssR0FBRyxTQUFTQSxNQUFPblMsRUFBRSxFQUFFQyxFQUFFO0lBQ2xELE9BQU93UyxzQkFBc0JQLFNBQVMsQ0FBQ2xTLElBQUlDLElBQUlpSyxVQUFVa0ksS0FBSztBQUNoRTtBQUNBSyxzQkFBc0IzZ0YsWUFBWSxHQUFHLFNBQVNBLGFBQWNrdUUsRUFBRSxFQUFFQyxFQUFFO0lBQ2hFLE9BQU93UyxzQkFBc0JQLFNBQVMsQ0FBQ2xTLElBQUlDLElBQUlpSyxVQUFVSyxZQUFZO0FBQ3ZFO0FBQ0FrSSxzQkFBc0JKLGFBQWEsR0FBRyxTQUFTQSxjQUFlclMsRUFBRSxFQUFFQyxFQUFFO0lBQ2xFLE9BQU93UyxzQkFBc0JQLFNBQVMsQ0FBQ2xTLElBQUlDLElBQUlpSyxVQUFVb0ksYUFBYTtBQUN4RTtBQUNBRyxzQkFBc0JGLFVBQVUsR0FBRyxTQUFTQSxXQUFZdlMsRUFBRSxFQUFFQyxFQUFFO0lBQzVELE9BQU93UyxzQkFBc0JQLFNBQVMsQ0FBQ2xTLElBQUlDLElBQUlpSyxVQUFVc0ksVUFBVTtBQUNyRTtBQUVBLElBQUlJLGtCQUFrQixTQUFTN2pDO0lBQzdCLElBQUksQ0FBQ3NmLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0gsVUFBVSxHQUFHO0lBQ2xCLElBQUlHLE1BQU01dEUsU0FBUyxDQUFDLEVBQUU7SUFDdEIsSUFBSXl0RSxhQUFhenRFLFNBQVMsQ0FBQyxFQUFFO0lBQzdCLElBQUksQ0FBQzR0RSxHQUFHLEdBQUdBO0lBQ1gsSUFBSSxDQUFDSCxVQUFVLEdBQUdBO0FBQ3BCO0FBQ0Ewa0IsZ0JBQWdCanpGLFNBQVMsQ0FBQytvRixvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0IvNEIsRUFBRSxFQUFFbUMsRUFBRTtJQUNwRixJQUFJLENBQUN1YyxHQUFHLENBQUNGLHlCQUF5QixDQUFDLElBQUksQ0FBQ0QsVUFBVSxFQUFFdmUsR0FBRzBlLEdBQUcsRUFBRTFlLEdBQUd1ZSxVQUFVLEVBQUVwYztBQUM3RTtBQUNBOGdDLGdCQUFnQmp6RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxFQUFFO0FBQ1g7QUFDQW94RixnQkFBZ0JqekYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU9teEY7QUFDVDtBQUVBLElBQUlDLGlCQUFpQixTQUFTQTtJQUM1QixJQUFJLENBQUM1aUQsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDNmlELE9BQU8sR0FBRztJQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJenlGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlpQixJQUFJWixTQUFTLENBQUMsRUFBRTtRQUNwQixJQUFJMHlGLGNBQWMxeUYsU0FBUyxDQUFDLEVBQUU7UUFDOUIsSUFBSSxDQUFDc3lGLFVBQVUsR0FBR0YsZUFBZXg4QixNQUFNO1FBQ3ZDLElBQUksQ0FBQ3k4QixPQUFPLEdBQUd6eEY7UUFDZixJQUFJLENBQUMyeEYsWUFBWSxHQUFHRztJQUN0QixPQUFPLElBQUkxeUYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXN2QyxRQUFRanZDLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUltSCxNQUFNbkgsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSWt1QixNQUFNbHVCLFNBQVMsQ0FBQyxFQUFFO1FBQ3RCLElBQUksQ0FBQ3N5RixVQUFVLEdBQUdGLGVBQWVPLE1BQU07UUFDdkMsSUFBSSxDQUFDbmpELE1BQU0sR0FBR1A7UUFDZCxJQUFJLENBQUNvakQsT0FBTyxHQUFHbHJGO1FBQ2YsSUFBSSxDQUFDc3JGLElBQUksR0FBR3ZrRTtJQUNkO0FBQ0Y7QUFFQSxJQUFJMGtFLHFCQUFxQjtJQUFFRCxRQUFRO1FBQUV0ekYsY0FBYztJQUFLO0lBQUV1MkQsUUFBUTtRQUFFdjJELGNBQWM7SUFBSztBQUFFO0FBQ3pGK3lGLGVBQWVsekYsU0FBUyxDQUFDMnpGLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPLElBQUksQ0FBQ1AsVUFBVSxLQUFLRixlQUFleDhCLE1BQU07QUFDbEQ7QUFDQXc4QixlQUFlbHpGLFNBQVMsQ0FBQzR6RixtQkFBbUIsR0FBRyxTQUFTQSxvQkFBcUJDLGdCQUFnQjtJQUMzRixJQUFJLENBQUNQLGlCQUFpQixHQUFHTztBQUMzQjtBQUNBWCxlQUFlbHpGLFNBQVMsQ0FBQzh6RixTQUFTLEdBQUcsU0FBU0E7SUFDNUMsT0FBTyxJQUFJLENBQUNQLElBQUk7QUFDbEI7QUFDQUwsZUFBZWx6RixTQUFTLENBQUM2RSxTQUFTLEdBQUcsU0FBU0EsVUFBV0MsQ0FBQztJQUN4RCxJQUFJaXZGLEtBQUtqdkY7SUFDVCxJQUFJLElBQUksQ0FBQ3F1RixPQUFPLEdBQUdZLEdBQUdaLE9BQU8sRUFBRTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzNDLElBQUksSUFBSSxDQUFDQSxPQUFPLEdBQUdZLEdBQUdaLE9BQU8sRUFBRTtRQUFFLE9BQU87SUFBRTtJQUMxQyxJQUFJLElBQUksQ0FBQ0MsVUFBVSxHQUFHVyxHQUFHWCxVQUFVLEVBQUU7UUFBRSxPQUFPLENBQUM7SUFBRTtJQUNqRCxJQUFJLElBQUksQ0FBQ0EsVUFBVSxHQUFHVyxHQUFHWCxVQUFVLEVBQUU7UUFBRSxPQUFPO0lBQUU7SUFDaEQsT0FBTztBQUNUO0FBQ0FGLGVBQWVsekYsU0FBUyxDQUFDZzBGLGNBQWMsR0FBRyxTQUFTQTtJQUNqRCxPQUFPLElBQUksQ0FBQ1gsWUFBWTtBQUMxQjtBQUNBSCxlQUFlbHpGLFNBQVMsQ0FBQ2kwRixRQUFRLEdBQUcsU0FBU0E7SUFDM0MsT0FBTyxJQUFJLENBQUNiLFVBQVUsS0FBS0YsZUFBZU8sTUFBTTtBQUNsRDtBQUNBUCxlQUFlbHpGLFNBQVMsQ0FBQ2swRixXQUFXLEdBQUcsU0FBU0EsWUFBYUMsRUFBRTtJQUM3RCxJQUFJLElBQUksQ0FBQzdqRCxNQUFNLEtBQUssTUFBTTtRQUFFLE9BQU87SUFBTTtJQUN6QyxPQUFPLElBQUksQ0FBQ0EsTUFBTSxLQUFLNmpELEdBQUc3akQsTUFBTTtBQUNsQztBQUNBNGlELGVBQWVsekYsU0FBUyxDQUFDbzBGLG1CQUFtQixHQUFHLFNBQVNBO0lBQ3RELE9BQU8sSUFBSSxDQUFDZCxpQkFBaUI7QUFDL0I7QUFDQUosZUFBZWx6RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDOUMsT0FBTztRQUFDeUI7S0FBVztBQUNyQjtBQUNBNHZGLGVBQWVsekYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLE9BQU9veEY7QUFDVDtBQUNBUSxtQkFBbUJELE1BQU0sQ0FBQ3J3RixHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFDdkRzd0YsbUJBQW1CaDlCLE1BQU0sQ0FBQ3R6RCxHQUFHLEdBQUc7SUFBYyxPQUFPO0FBQUU7QUFFdkRuRCxPQUFPb0QsZ0JBQWdCLENBQUU2dkYsZ0JBQWdCUTtBQUV6QyxJQUFJVyxxQkFBcUIsU0FBU0Esc0JBQXVCO0FBRXpEQSxtQkFBbUJyMEYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2xELE9BQU8sRUFBRTtBQUNYO0FBQ0F3eUYsbUJBQW1CcjBGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMvQyxPQUFPdXlGO0FBQ1Q7QUFFQSxJQUFJQyx1QkFBdUIsU0FBUzluQjtJQUNsQyxJQUFJLENBQUNNLGdCQUFnQixHQUFHO0lBQ3hCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7SUFDMUIsSUFBSSxDQUFDRSx3QkFBd0IsR0FBRztJQUNoQyxJQUFJLENBQUNoUyxHQUFHLEdBQUc7SUFDWCxJQUFJLENBQUNxNUIsY0FBYyxHQUFHO0lBQ3RCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ3JuQixtQkFBbUIsR0FBRztJQUMzQixJQUFJLENBQUNzbkIsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDbG5CLFFBQVEsR0FBRztJQUNoQixJQUFJLENBQUNtbkIsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUM1QixJQUFJaHFDLEtBQUs5cEQsU0FBUyxDQUFDLEVBQUU7SUFDckIsSUFBSSt6RixnQkFBZ0IvekYsU0FBUyxDQUFDLEVBQUU7SUFDaEMsSUFBSWcwRixpQkFBaUJoMEYsU0FBUyxDQUFDLEVBQUU7SUFDakMsSUFBSSxDQUFDbzZELEdBQUcsR0FBR3RRO0lBQ1gsSUFBSSxDQUFDMnBDLGNBQWMsR0FBR007SUFDdEIsSUFBSSxDQUFDTCxlQUFlLEdBQUdNO0FBQ3pCO0FBQ0FSLHFCQUFxQnQwRixTQUFTLENBQUN3dEUscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXVCZixFQUFFLEVBQUVDLFNBQVMsRUFBRUMsRUFBRSxFQUFFQyxTQUFTO0lBQ2pILElBQUlILE9BQU9FLElBQUk7UUFDYixJQUFJLElBQUksQ0FBQ3pSLEdBQUcsQ0FBQ3I3QyxrQkFBa0IsT0FBTyxHQUFHO1lBQ3ZDLElBQUl5MEUscUJBQXFCN21CLGtCQUFrQixDQUFDZixXQUFXRSxZQUFZO2dCQUFFLE9BQU87WUFBSztZQUNqRixJQUFJSCxHQUFHeHpDLFFBQVEsSUFBSTtnQkFDakIsSUFBSWd3QixjQUFjd2pCLEdBQUc5MEMsWUFBWSxLQUFLO2dCQUN0QyxJQUFJLGNBQWUsS0FBS2kxQyxjQUFjM2pCLGVBQ2pDMmpCLGNBQWMsS0FBS0YsY0FBY3pqQixhQUFjO29CQUNsRCxPQUFPO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0FxckMscUJBQXFCdDBGLFNBQVMsQ0FBQzB0RSwwQkFBMEIsR0FBRyxTQUFTQTtJQUNuRSxPQUFPLElBQUksQ0FBQ1Isd0JBQXdCO0FBQ3RDO0FBQ0FvbkIscUJBQXFCdDBGLFNBQVMsQ0FBQyswRixvQkFBb0IsR0FBRyxTQUFTQSxxQkFBc0JDLG1CQUFtQjtJQUN0RyxJQUFJLENBQUNKLG9CQUFvQixHQUFHSTtBQUM5QjtBQUNBVixxQkFBcUJ0MEYsU0FBUyxDQUFDMnRFLDZCQUE2QixHQUFHLFNBQVNBO0lBQ3RFLE9BQU8sSUFBSSxDQUFDWCxrQkFBa0I7QUFDaEM7QUFDQXNuQixxQkFBcUJ0MEYsU0FBUyxDQUFDaTFGLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QnJxQyxFQUFFLEVBQUVwVixRQUFRO0lBQ3JHLElBQUssSUFBSXB1QyxJQUFJb3VDLFNBQVNucUIsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzlDLElBQUkwZSxPQUFPN2lDLEVBQUVzZ0IsSUFBSTtRQUNqQixJQUFJN0csS0FBS29wQixLQUFLcjJCLGFBQWE7UUFDM0IsSUFBSWczQyxHQUFHaHFDLGNBQWMsQ0FBQ0MsS0FBSztZQUFFLE9BQU87UUFBSztJQUMzQztJQUNBLE9BQU87QUFDVDtBQUNBeXpFLHFCQUFxQnQwRixTQUFTLENBQUM2dEUscUJBQXFCLEdBQUcsU0FBU0E7SUFDOUQsT0FBTyxJQUFJLENBQUNkLFVBQVU7QUFDeEI7QUFDQXVuQixxQkFBcUJ0MEYsU0FBUyxDQUFDa2dCLGVBQWUsR0FBRyxTQUFTQTtJQUN4RCxPQUFPLElBQUksQ0FBQzRzRCxnQkFBZ0I7QUFDOUI7QUFDQXduQixxQkFBcUJ0MEYsU0FBUyxDQUFDczNCLE1BQU0sR0FBRyxTQUFTQTtJQUMvQyxPQUFPLElBQUksQ0FBQ3E5RCxPQUFPO0FBQ3JCO0FBQ0FMLHFCQUFxQnQwRixTQUFTLENBQUNrMUYsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQnRxQyxFQUFFLEVBQUVwVixRQUFRO0lBQ3JGLElBQUlBLGFBQWEsTUFBTTtRQUFFLE9BQU87SUFBTTtJQUN0QyxJQUFJLElBQUksQ0FBQ3kvQyx1QkFBdUIsQ0FBQ3JxQyxJQUFJcFYsUUFBUSxDQUFDLEVBQUUsR0FBRztRQUFFLE9BQU87SUFBSztJQUNqRSxJQUFJLElBQUksQ0FBQ3kvQyx1QkFBdUIsQ0FBQ3JxQyxJQUFJcFYsUUFBUSxDQUFDLEVBQUUsR0FBRztRQUFFLE9BQU87SUFBSztJQUNqRSxPQUFPO0FBQ1Q7QUFDQTgrQyxxQkFBcUJ0MEYsU0FBUyxDQUFDbTFGLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFrQkMsU0FBUyxFQUFFQyxTQUFTO0lBQy9GLElBQUksQ0FBQ1gsU0FBUyxHQUFHLElBQUkzMEYsTUFBTSxHQUFHTSxJQUFJLENBQUM7SUFDbkMsSUFBSSxDQUFDcTBGLFNBQVMsQ0FBQyxFQUFFLEdBQUdVO0lBQ3BCLElBQUksQ0FBQ1YsU0FBUyxDQUFDLEVBQUUsR0FBR1c7QUFDdEI7QUFDQWYscUJBQXFCdDBGLFNBQVMsQ0FBQ2tyRCxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0J1aEIsRUFBRSxFQUFFQyxTQUFTLEVBQUVDLEVBQUUsRUFBRUMsU0FBUztJQUN2RyxJQUFJSCxPQUFPRSxNQUFNRCxjQUFjRSxXQUFXO1FBQUUsT0FBTztJQUFLO0lBQ3hELElBQUksQ0FBQ1csUUFBUTtJQUNiLElBQUk3YyxNQUFNK2IsR0FBRy8wQyxjQUFjLEVBQUUsQ0FBQ2cxQyxVQUFVO0lBQ3hDLElBQUkvYixNQUFNOGIsR0FBRy8wQyxjQUFjLEVBQUUsQ0FBQ2cxQyxZQUFZLEVBQUU7SUFDNUMsSUFBSTliLE1BQU0rYixHQUFHajFDLGNBQWMsRUFBRSxDQUFDazFDLFVBQVU7SUFDeEMsSUFBSS9iLE1BQU04YixHQUFHajFDLGNBQWMsRUFBRSxDQUFDazFDLFlBQVksRUFBRTtJQUM1QyxJQUFJLENBQUMxUixHQUFHLENBQUN6N0MsbUJBQW1CLENBQUNpeEMsS0FBS0MsS0FBS0MsS0FBS0M7SUFDNUMsSUFBSSxJQUFJLENBQUNxSyxHQUFHLENBQUNoN0MsZUFBZSxJQUFJO1FBQzlCLElBQUksSUFBSSxDQUFDczBFLGVBQWUsRUFBRTtZQUN4Qi9uQixHQUFHb0QsV0FBVyxDQUFDO1lBQ2ZsRCxHQUFHa0QsV0FBVyxDQUFDO1FBQ2pCO1FBQ0EsSUFBSSxDQUFDNGtCLGlCQUFpQjtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDam5CLHFCQUFxQixDQUFDZixJQUFJQyxXQUFXQyxJQUFJQyxZQUFZO1lBQzdELElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUc7WUFDeEIsSUFBSSxJQUFJLENBQUN5bkIsY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDcjVCLEdBQUcsQ0FBQ2o3QyxRQUFRLElBQUk7Z0JBQy9Dd3NELEdBQUd2aEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDZ1EsR0FBRyxFQUFFd1IsV0FBVztnQkFDekNDLEdBQUd6aEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDZ1EsR0FBRyxFQUFFMFIsV0FBVztZQUMzQztZQUNBLElBQUksSUFBSSxDQUFDMVIsR0FBRyxDQUFDajdDLFFBQVEsSUFBSTtnQkFDdkIsSUFBSSxDQUFDaXRELHdCQUF3QixHQUFHLElBQUksQ0FBQ2hTLEdBQUcsQ0FBQzM2QyxlQUFlLENBQUMsR0FBR3ZiLElBQUk7Z0JBQ2hFLElBQUksQ0FBQytuRSxVQUFVLEdBQUc7Z0JBQ2xCLElBQUksSUFBSSxDQUFDNm5CLG9CQUFvQixFQUFFO29CQUM3QixJQUFJLENBQUNELE9BQU8sR0FBRztnQkFDakI7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ08sZUFBZSxDQUFDLElBQUksQ0FBQ2g2QixHQUFHLEVBQUUsSUFBSSxDQUFDdzVCLFNBQVMsR0FBRztvQkFBRSxJQUFJLENBQUMxbkIsa0JBQWtCLEdBQUc7Z0JBQU07WUFDekY7UUFDRjtJQUNGO0FBQ0Y7QUFDQXNuQixxQkFBcUJ0MEYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sRUFBRTtBQUNYO0FBQ0F5eUYscUJBQXFCdDBGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNqRCxPQUFPd3lGO0FBQ1Q7QUFDQUEscUJBQXFCN21CLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQjU2QyxFQUFFLEVBQUVDLEVBQUU7SUFDM0UsT0FBT3B5QixLQUFLeUIsR0FBRyxDQUFDMHdCLEtBQUtDLFFBQVE7QUFDL0I7QUFFQSxJQUFJd2lFLCtCQUFnQyxTQUFVQyxxQkFBcUI7SUFDakUsU0FBU0Q7UUFDUEMsc0JBQXNCaHpGLElBQUksQ0FBQyxJQUFJO1FBQy9CLElBQUksQ0FBQ2l6RixNQUFNLEdBQUcsSUFBSWhvRTtRQUNsQixJQUFJLENBQUNpb0UsU0FBUyxHQUFHO0lBQ25CO0lBRUEsSUFBS0YsdUJBQXdCRCw2QkFBNkI1eUYsU0FBUyxHQUFHNnlGO0lBQ3RFRCw2QkFBNkJ0MUYsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFNHlGLHlCQUF5QkEsc0JBQXNCdjFGLFNBQVM7SUFDaEhzMUYsNkJBQTZCdDFGLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzB5RjtJQUNyREEsNkJBQTZCdDFGLFNBQVMsQ0FBQzAxRixhQUFhLEdBQUcsU0FBU0E7UUFDOUQsSUFBSXA3RSxTQUFTLElBQUk7UUFFakIra0MsWUFBWXhwQixJQUFJLENBQUMsSUFBSSxDQUFDMi9ELE1BQU07UUFDNUIsSUFBSyxJQUFJcHVGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvdUYsTUFBTSxDQUFDN2hGLElBQUksSUFBSXZNLElBQUs7WUFDM0MsSUFBSStzRixLQUFLNzVFLE9BQU9rN0UsTUFBTSxDQUFDcHlGLEdBQUcsQ0FBQ2dFO1lBQzNCLElBQUkrc0YsR0FBR1IsUUFBUSxJQUFJO2dCQUNqQlEsR0FBR0gsY0FBYyxHQUFHSixtQkFBbUIsQ0FBQ3hzRjtZQUMxQztRQUNGO0lBQ0Y7SUFDQWt1Riw2QkFBNkJ0MUYsU0FBUyxDQUFDK29GLG9CQUFvQixHQUFHLFNBQVNBO1FBQ3JFLElBQUl6dUUsU0FBUyxJQUFJO1FBRWpCLElBQUl4WixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJMHhELEtBQUtyeEQsU0FBUyxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDMjBGLFNBQVMsR0FBRztZQUNqQixJQUFJLENBQUNDLGFBQWE7WUFDbEIsSUFBSyxJQUFJdHVGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNvdUYsTUFBTSxDQUFDN2hGLElBQUksSUFBSXZNLElBQUs7Z0JBQzNDLElBQUkrc0YsS0FBSzc1RSxPQUFPazdFLE1BQU0sQ0FBQ3B5RixHQUFHLENBQUNnRTtnQkFDM0IsSUFBSStzRixHQUFHRixRQUFRLElBQUk7b0JBQ2pCMzVFLE9BQU9xN0UsZUFBZSxDQUFDdnVGLEdBQUcrc0YsR0FBR0MsbUJBQW1CLElBQUlELElBQUloaUM7Z0JBQzFEO2dCQUNBLElBQUlBLEdBQUc3NkIsTUFBTSxJQUFJO29CQUNmO2dCQUNGO1lBQ0Y7UUFDRixPQUFPLElBQUl4MkIsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSUssU0FBUyxDQUFDLEVBQUUsWUFBWXd6Rix3QkFBeUJudEYsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVzc0IsU0FBU2ptQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRXNzQixPQUFRO2dCQUMxSCxJQUFJd29FLFNBQVM5MEYsU0FBUyxDQUFDLEVBQUU7Z0JBQ3pCLElBQUkrMEYsU0FBUy8wRixTQUFTLENBQUMsRUFBRTtnQkFDekIsSUFBSWcxRixPQUFPaDFGLFNBQVMsQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUN5NkMsUUFBUSxDQUFDcTZDLFFBQVFBO2dCQUN0QixJQUFJLENBQUNyNkMsUUFBUSxDQUFDczZDLFFBQVFBO2dCQUN0QixJQUFJLENBQUM5TSxvQkFBb0IsQ0FBQytNO1lBQzVCLE9BQU8sSUFBSSxPQUFPaDFGLFNBQVMsQ0FBQyxFQUFFLEtBQUssYUFBY3FHLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFc3NCLFNBQVN0c0IsU0FBUyxDQUFDLEVBQUUsWUFBWXd6RixzQkFBdUI7Z0JBQ2xJLElBQUluZ0QsUUFBUXJ6QyxTQUFTLENBQUMsRUFBRTtnQkFDeEIsSUFBSWkxRixPQUFPajFGLFNBQVMsQ0FBQyxFQUFFO2dCQUN2QixJQUFJazFGLGtCQUFrQmwxRixTQUFTLENBQUMsRUFBRTtnQkFDbEMsSUFBSWsxRixpQkFBaUI7b0JBQUUsSUFBSSxDQUFDejZDLFFBQVEsQ0FBQ3BILE9BQU87Z0JBQU8sT0FBTztvQkFBRSxJQUFJLENBQUNvSCxRQUFRLENBQUNwSDtnQkFBUTtnQkFDbEYsSUFBSSxDQUFDNDBDLG9CQUFvQixDQUFDZ047WUFDNUI7UUFDRjtJQUNGO0lBQ0FULDZCQUE2QnQxRixTQUFTLENBQUNpMkYsT0FBTyxHQUFHLFNBQVNBLFFBQVN6a0QsSUFBSSxFQUFFMGtELE9BQU87UUFDOUUsSUFBSTU3RSxTQUFTLElBQUk7UUFFakIsSUFBSW8wRCxNQUFNbDlCLEtBQUsyK0Isb0JBQW9CO1FBQ25DLElBQUl6K0IsYUFBYWc5QixJQUFJRyxlQUFlO1FBQ3BDLElBQUssSUFBSXpuRSxJQUFJLEdBQUdBLElBQUlzcUMsV0FBV2p4QyxNQUFNLEdBQUcsR0FBRzJHLElBQUs7WUFDOUMsSUFBSTRvRCxLQUFLLElBQUlpakMsZ0JBQWdCdmtCLEtBQUt0bkU7WUFDbEMsSUFBSW9zRixjQUFjLElBQUlOLGVBQWVnRCxTQUFTeG5CLElBQUkzM0QsT0FBTyxDQUFDM1AsSUFBSTRvRDtZQUM5RDExQyxPQUFPazdFLE1BQU0sQ0FBQ3ZwRixHQUFHLENBQUN1bkY7WUFDbEJsNUUsT0FBT2s3RSxNQUFNLENBQUN2cEYsR0FBRyxDQUFDLElBQUlpbkYsZUFBZXhrQixJQUFJNzNELE9BQU8sQ0FBQ3pQLElBQUlvc0Y7UUFDdkQ7SUFDRjtJQUNBOEIsNkJBQTZCdDFGLFNBQVMsQ0FBQzIxRixlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCaG1FLEtBQUssRUFBRUMsR0FBRyxFQUFFdW1FLEdBQUcsRUFBRWhrQyxFQUFFO1FBQ3BHLElBQUk3M0MsU0FBUyxJQUFJO1FBRWpCLElBQUk4N0UsTUFBTUQsSUFBSXJDLFNBQVM7UUFDdkIsSUFBSyxJQUFJMXNGLElBQUl1b0IsT0FBT3ZvQixJQUFJd29CLEtBQUt4b0IsSUFBSztZQUNoQyxJQUFJaXZGLE1BQU0vN0UsT0FBT2s3RSxNQUFNLENBQUNweUYsR0FBRyxDQUFDZ0U7WUFDNUIsSUFBSWl2RixJQUFJcEMsUUFBUSxJQUFJO2dCQUNsQixJQUFJbGxDLE1BQU1zbkMsSUFBSXZDLFNBQVM7Z0JBQ3ZCLElBQUksQ0FBQ3FDLElBQUlqQyxXQUFXLENBQUNtQyxNQUFNO29CQUN6QkQsSUFBSXJOLG9CQUFvQixDQUFDaDZCLEtBQUtvRDtvQkFDOUI3M0MsT0FBT203RSxTQUFTO2dCQUNsQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBSCw2QkFBNkJ0MUYsU0FBUyxDQUFDdTdDLFFBQVEsR0FBRyxTQUFTQTtRQUN6RCxJQUFJamhDLFNBQVMsSUFBSTtRQUVqQixJQUFJeFosVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSTB6QyxRQUFRcnpDLFNBQVMsQ0FBQyxFQUFFO1lBQ3hCLElBQUssSUFBSXNHLElBQUkrc0MsTUFBTTlvQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7Z0JBQzNDLElBQUlpbUIsT0FBT3BxQyxFQUFFc2dCLElBQUk7Z0JBQ2pCcE4sT0FBTzI3RSxPQUFPLENBQUN6a0QsTUFBTUE7WUFDdkI7UUFDRixPQUFPLElBQUkxd0MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSTYxRixVQUFVeDFGLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLElBQUlvMUYsVUFBVXAxRixTQUFTLENBQUMsRUFBRTtZQUMxQixJQUFLLElBQUk4a0IsTUFBTTB3RSxRQUFRanJFLFFBQVEsSUFBSXpGLElBQUkyRixPQUFPLElBQUs7Z0JBQ2pELElBQUkwckIsU0FBU3J4QixJQUFJOEIsSUFBSTtnQkFDckJwTixPQUFPMjdFLE9BQU8sQ0FBQ2gvQyxRQUFRaS9DO1lBQ3pCO1FBQ0Y7SUFDRjtJQUNBWiw2QkFBNkJ0MUYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQzVELE9BQU8sRUFBRTtJQUNYO0lBQ0F5ekYsNkJBQTZCdDFGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUN6RCxPQUFPd3pGO0lBQ1Q7SUFFQSxPQUFPQTtBQUNULEVBQUVqQjtBQUVGLElBQUlrQyxvQkFBb0IsU0FBU0E7SUFDL0IsSUFBSSxDQUFDQyxJQUFJLEdBQUczekYsT0FBT3lpRCxpQkFBaUI7SUFDcEMsSUFBSSxDQUFDNmhCLElBQUksR0FBR3RrRSxPQUFPNHpGLGlCQUFpQjtBQUN0QztBQUVBLElBQUlDLHFCQUFxQjtJQUFFQyxnQkFBZ0I7UUFBRXgyRixjQUFjO0lBQUs7QUFBRTtBQUNsRW8yRixrQkFBa0J2MkYsU0FBUyxDQUFDNDJGLE1BQU0sR0FBRyxTQUFTQTtJQUM1QyxPQUFPLElBQUksQ0FBQ0osSUFBSTtBQUNsQjtBQUNBRCxrQkFBa0J2MkYsU0FBUyxDQUFDaVgsVUFBVSxHQUFHLFNBQVNBLFdBQVk0L0UsUUFBUSxFQUFFQyxRQUFRO0lBQzlFLElBQUksSUFBSSxDQUFDTixJQUFJLEdBQUdNLFlBQVksSUFBSSxDQUFDM3ZCLElBQUksR0FBRzB2QixVQUFVO1FBQUUsT0FBTztJQUFNO0lBQ2pFLE9BQU87QUFDVDtBQUNBTixrQkFBa0J2MkYsU0FBUyxDQUFDKzJGLE1BQU0sR0FBRyxTQUFTQTtJQUM1QyxPQUFPLElBQUksQ0FBQzV2QixJQUFJO0FBQ2xCO0FBQ0FvdkIsa0JBQWtCdjJGLFNBQVMsQ0FBQ2lGLFFBQVEsR0FBRyxTQUFTQTtJQUM5QyxPQUFPa1ksVUFBVUUsWUFBWSxDQUFDLElBQUkzWixXQUFXLElBQUksQ0FBQzh5RixJQUFJLEVBQUUsSUFBSSxJQUFJOXlGLFdBQVcsSUFBSSxDQUFDeWpFLElBQUksRUFBRTtBQUN4RjtBQUNBb3ZCLGtCQUFrQnYyRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDakQsT0FBTyxFQUFFO0FBQ1g7QUFDQTAwRixrQkFBa0J2MkYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzlDLE9BQU95MEY7QUFDVDtBQUNBRyxtQkFBbUJDLGNBQWMsQ0FBQ3Z6RixHQUFHLEdBQUc7SUFBYyxPQUFPdXpGO0FBQWU7QUFFNUUxMkYsT0FBT29ELGdCQUFnQixDQUFFa3pGLG1CQUFtQkc7QUFFNUMsSUFBSUMsaUJBQWlCLFNBQVNBLGtCQUFtQjtBQUVqREEsZUFBZTMyRixTQUFTLENBQUNnRyxPQUFPLEdBQUcsU0FBU0EsUUFBU0MsRUFBRSxFQUFFQyxFQUFFO0lBQ3pELElBQUl3YixLQUFLemI7SUFDVCxJQUFJMGIsS0FBS3piO0lBQ1QsSUFBSTZxRCxPQUFPLENBQUNydkMsR0FBRzgwRSxJQUFJLEdBQUc5MEUsR0FBR3lsRCxJQUFJLElBQUk7SUFDakMsSUFBSTZ2QixPQUFPLENBQUNyMUUsR0FBRzYwRSxJQUFJLEdBQUc3MEUsR0FBR3dsRCxJQUFJLElBQUk7SUFDakMsSUFBSXBXLE9BQU9pbUMsTUFBTTtRQUFFLE9BQU8sQ0FBQztJQUFFO0lBQzdCLElBQUlqbUMsT0FBT2ltQyxNQUFNO1FBQUUsT0FBTztJQUFFO0lBQzVCLE9BQU87QUFDVDtBQUNBTCxlQUFlMzJGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM5QyxPQUFPO1FBQUMyQjtLQUFXO0FBQ3JCO0FBQ0FtekYsZUFBZTMyRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDM0MsT0FBTzYwRjtBQUNUO0FBRUEsSUFBSU0sd0JBQXlCLFNBQVVDLG9CQUFvQjtJQUN6RCxTQUFTRDtRQUNQQyxxQkFBcUIzMEYsSUFBSSxDQUFDLElBQUk7UUFDOUIsSUFBSSxDQUFDbzdDLEtBQUssR0FBRztRQUNiLElBQUkvOEMsTUFBTUUsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSUgsTUFBTUcsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSSs4QyxPQUFPLzhDLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzAxRixJQUFJLEdBQUc1MUY7UUFDWixJQUFJLENBQUN1bUUsSUFBSSxHQUFHeG1FO1FBQ1osSUFBSSxDQUFDZzlDLEtBQUssR0FBR0U7SUFDZjtJQUVBLElBQUtxNUMsc0JBQXVCRCxzQkFBc0J2MEYsU0FBUyxHQUFHdzBGO0lBQzlERCxzQkFBc0JqM0YsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFdTBGLHdCQUF3QkEscUJBQXFCbDNGLFNBQVM7SUFDdkdpM0Ysc0JBQXNCajNGLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3EwRjtJQUM5Q0Esc0JBQXNCajNGLFNBQVMsQ0FBQzArQyxLQUFLLEdBQUcsU0FBU0EsTUFBT200QyxRQUFRLEVBQUVDLFFBQVEsRUFBRW4wQyxPQUFPO1FBQ2pGLElBQUksQ0FBQyxJQUFJLENBQUMxckMsVUFBVSxDQUFDNC9FLFVBQVVDLFdBQVc7WUFBRSxPQUFPO1FBQUs7UUFDeERuMEMsUUFBUXBFLFNBQVMsQ0FBQyxJQUFJLENBQUNaLEtBQUs7SUFDOUI7SUFDQXM1QyxzQkFBc0JqM0YsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ3JELE9BQU8sRUFBRTtJQUNYO0lBQ0FvMUYsc0JBQXNCajNGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtRQUNsRCxPQUFPbTFGO0lBQ1Q7SUFFQSxPQUFPQTtBQUNULEVBQUVWO0FBRUYsSUFBSVksMEJBQTJCLFNBQVVELG9CQUFvQjtJQUMzRCxTQUFTQztRQUNQRCxxQkFBcUIzMEYsSUFBSSxDQUFDLElBQUk7UUFDOUIsSUFBSSxDQUFDNjBGLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSTMxRSxLQUFLNWdCLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUk2Z0IsS0FBSzdnQixTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUNzMkYsTUFBTSxHQUFHMTFFO1FBQ2QsSUFBSSxDQUFDMjFFLE1BQU0sR0FBRzExRTtRQUNkLElBQUksQ0FBQzIxRSxXQUFXLENBQUMsSUFBSSxDQUFDRixNQUFNLEVBQUUsSUFBSSxDQUFDQyxNQUFNO0lBQzNDO0lBRUEsSUFBS0gsc0JBQXVCQyx3QkFBd0J6MEYsU0FBUyxHQUFHdzBGO0lBQ2hFQyx3QkFBd0JuM0YsU0FBUyxHQUFHQyxPQUFPMEMsTUFBTSxDQUFFdTBGLHdCQUF3QkEscUJBQXFCbDNGLFNBQVM7SUFDekdtM0Ysd0JBQXdCbjNGLFNBQVMsQ0FBQzRDLFdBQVcsR0FBR3UwRjtJQUNoREEsd0JBQXdCbjNGLFNBQVMsQ0FBQ3MzRixXQUFXLEdBQUcsU0FBU0EsWUFBYTUxRSxFQUFFLEVBQUVDLEVBQUU7UUFDMUUsSUFBSSxDQUFDNjBFLElBQUksR0FBRzkxRixLQUFLRSxHQUFHLENBQUM4Z0IsR0FBRzgwRSxJQUFJLEVBQUU3MEUsR0FBRzYwRSxJQUFJO1FBQ3JDLElBQUksQ0FBQ3J2QixJQUFJLEdBQUd6bUUsS0FBS0MsR0FBRyxDQUFDK2dCLEdBQUd5bEQsSUFBSSxFQUFFeGxELEdBQUd3bEQsSUFBSTtJQUN2QztJQUNBZ3dCLHdCQUF3Qm4zRixTQUFTLENBQUMwK0MsS0FBSyxHQUFHLFNBQVNBLE1BQU9tNEMsUUFBUSxFQUFFQyxRQUFRLEVBQUVuMEMsT0FBTztRQUNuRixJQUFJLENBQUMsSUFBSSxDQUFDMXJDLFVBQVUsQ0FBQzQvRSxVQUFVQyxXQUFXO1lBQ3hDLE9BQU87UUFDVDtRQUNBLElBQUksSUFBSSxDQUFDTSxNQUFNLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQ0EsTUFBTSxDQUFDMTRDLEtBQUssQ0FBQ200QyxVQUFVQyxVQUFVbjBDO1FBQVU7UUFDNUUsSUFBSSxJQUFJLENBQUMwMEMsTUFBTSxLQUFLLE1BQU07WUFBRSxJQUFJLENBQUNBLE1BQU0sQ0FBQzM0QyxLQUFLLENBQUNtNEMsVUFBVUMsVUFBVW4wQztRQUFVO0lBQzlFO0lBQ0F3MEMsd0JBQXdCbjNGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUN2RCxPQUFPLEVBQUU7SUFDWDtJQUNBczFGLHdCQUF3Qm4zRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDcEQsT0FBT3ExRjtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFWjtBQUVGLElBQUlnQiw0QkFBNEIsU0FBU0E7SUFDdkMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSWhxRTtJQUNuQixJQUFJLENBQUN3ekIsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDbkMsTUFBTSxHQUFHO0FBQ2hCO0FBQ0EwNEMsMEJBQTBCdjNGLFNBQVMsQ0FBQ3kzRixTQUFTLEdBQUcsU0FBU0E7SUFDckQsSUFBSW45RSxTQUFTLElBQUk7SUFFbkIra0MsWUFBWXhwQixJQUFJLENBQUMsSUFBSSxDQUFDMmhFLE9BQU8sRUFBRSxJQUFJakIsa0JBQWtCSSxjQUFjO0lBQ25FLElBQUlsaUYsTUFBTSxJQUFJLENBQUMraUYsT0FBTztJQUN0QixJQUFJcnBELE9BQU87SUFDWCxJQUFJeDVCLE9BQU8sSUFBSTZZO0lBQ2YsTUFBTyxLQUFNO1FBQ1hsVCxPQUFPbzlFLFVBQVUsQ0FBQ2pqRixLQUFLRTtRQUN2QixJQUFJQSxLQUFLaEIsSUFBSSxPQUFPLEdBQUc7WUFBRSxPQUFPZ0IsS0FBS3ZSLEdBQUcsQ0FBQztRQUFHO1FBQzVDK3FDLE9BQU8xNUI7UUFDUEEsTUFBTUU7UUFDTkEsT0FBT3c1QjtJQUNUO0FBQ0Y7QUFDQW9wRCwwQkFBMEJ2M0YsU0FBUyxDQUFDNjBDLE1BQU0sR0FBRyxTQUFTQSxPQUFRajBDLEdBQUcsRUFBRUQsR0FBRyxFQUFFazlDLElBQUk7SUFDMUUsSUFBSSxJQUFJLENBQUNtRCxLQUFLLEtBQUssTUFBTTtRQUFFLE1BQU0sSUFBSTMrQyxNQUFNO0lBQXFEO0lBQ2hHLElBQUksQ0FBQ20xRixPQUFPLENBQUN2ckYsR0FBRyxDQUFDLElBQUlnckYsc0JBQXNCcjJGLEtBQUtELEtBQUtrOUM7QUFDdkQ7QUFDQTA1QywwQkFBMEJ2M0YsU0FBUyxDQUFDMCtDLEtBQUssR0FBRyxTQUFTQSxNQUFPOTlDLEdBQUcsRUFBRUQsR0FBRyxFQUFFZ2lELE9BQU87SUFDM0UsSUFBSSxDQUFDbjVDLElBQUk7SUFDVCxJQUFJLENBQUN3M0MsS0FBSyxDQUFDdEMsS0FBSyxDQUFDOTlDLEtBQUtELEtBQUtnaUQ7QUFDN0I7QUFDQTQwQywwQkFBMEJ2M0YsU0FBUyxDQUFDMjNGLFNBQVMsR0FBRyxTQUFTQTtJQUN2RCxJQUFJLElBQUksQ0FBQzMyQyxLQUFLLEtBQUssTUFBTTtRQUFFLE9BQU87SUFBSztJQUN2QyxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJLENBQUN5MkMsU0FBUztBQUM3QjtBQUNBRiwwQkFBMEJ2M0YsU0FBUyxDQUFDNDNGLFNBQVMsR0FBRyxTQUFTQSxVQUFXM3RELElBQUk7SUFDdEUxMUIsT0FBT21PLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDeEYsVUFBVUUsWUFBWSxDQUFDLElBQUkzWixXQUFXdW1DLEtBQUt1c0QsSUFBSSxFQUFFLElBQUksQ0FBQzMzQyxNQUFNLEdBQUcsSUFBSW43QyxXQUFXdW1DLEtBQUtrOUIsSUFBSSxFQUFFLElBQUksQ0FBQ3RvQixNQUFNO0FBQ3pIO0FBQ0EwNEMsMEJBQTBCdjNGLFNBQVMsQ0FBQ3dKLElBQUksR0FBRyxTQUFTQTtJQUNsRCxJQUFJLElBQUksQ0FBQ3czQyxLQUFLLEtBQUssTUFBTTtRQUFFLE9BQU87SUFBSztJQUN2QyxJQUFJLENBQUMyMkMsU0FBUztBQUNoQjtBQUNBSiwwQkFBMEJ2M0YsU0FBUyxDQUFDMDNGLFVBQVUsR0FBRyxTQUFTQSxXQUFZampGLEdBQUcsRUFBRUUsSUFBSTtJQUM3RSxJQUFJLENBQUNrcUMsTUFBTTtJQUNYbHFDLEtBQUtrWixLQUFLO0lBQ1YsSUFBSyxJQUFJem1CLElBQUksR0FBR0EsSUFBSXFOLElBQUlkLElBQUksSUFBSXZNLEtBQUssRUFBRztRQUN0QyxJQUFJc2EsS0FBS2pOLElBQUlyUixHQUFHLENBQUNnRTtRQUNqQixJQUFJdWEsS0FBS3ZhLElBQUksSUFBSXFOLElBQUlkLElBQUksS0FBS2MsSUFBSXJSLEdBQUcsQ0FBQ2dFLEtBQUs7UUFDM0MsSUFBSXVhLE9BQU8sTUFBTTtZQUNmaE4sS0FBSzFJLEdBQUcsQ0FBQ3lWO1FBQ1gsT0FBTztZQUNMLElBQUl1b0IsT0FBTyxJQUFJa3RELHdCQUF3QjFpRixJQUFJclIsR0FBRyxDQUFDZ0UsSUFBSXFOLElBQUlyUixHQUFHLENBQUNnRSxJQUFJO1lBQy9EdU4sS0FBSzFJLEdBQUcsQ0FBQ2crQjtRQUNYO0lBQ0Y7QUFDRjtBQUNBc3RELDBCQUEwQnYzRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDekQsT0FBTyxFQUFFO0FBQ1g7QUFDQTAxRiwwQkFBMEJ2M0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3RELE9BQU95MUY7QUFDVDtBQUVBLElBQUlNLG1CQUFtQixTQUFTQTtJQUM5QixJQUFJLENBQUM1NUMsTUFBTSxHQUFHLElBQUl6d0I7QUFDcEI7QUFDQXFxRSxpQkFBaUI3M0YsU0FBUyxDQUFDdStDLFNBQVMsR0FBRyxTQUFTQSxVQUFXVixJQUFJO0lBQzdELElBQUksQ0FBQ0ksTUFBTSxDQUFDaHlDLEdBQUcsQ0FBQzR4QztBQUNsQjtBQUNBZzZDLGlCQUFpQjczRixTQUFTLENBQUM4M0YsUUFBUSxHQUFHLFNBQVNBO0lBQzdDLE9BQU8sSUFBSSxDQUFDNzVDLE1BQU07QUFDcEI7QUFDQTQ1QyxpQkFBaUI3M0YsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2hELE9BQU87UUFBQ3k4QztLQUFZO0FBQ3RCO0FBQ0F1NUMsaUJBQWlCNzNGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM3QyxPQUFPKzFGO0FBQ1Q7QUFFQSxJQUFJRSw0QkFBNEIsU0FBU0E7SUFDdkMsSUFBSSxDQUFDMWxDLE1BQU0sR0FBRztJQUNkLElBQUl4b0MsSUFBSS9vQixTQUFTLENBQUMsRUFBRTtJQUNwQixJQUFJLENBQUNxRyxhQUFhMGlCLEdBQUc0VSxZQUFZO1FBQUUsTUFBTSxJQUFJcjhCLHlCQUF5QjtJQUE4QjtJQUNwRyxJQUFJLENBQUNpd0QsTUFBTSxHQUFHLElBQUkybEMsd0JBQXdCbnVFO0FBQzVDO0FBRUEsSUFBSW91RSxxQkFBcUI7SUFBRUMsZ0JBQWdCO1FBQUUvM0YsY0FBYztJQUFLO0lBQUU2M0YseUJBQXlCO1FBQUU3M0YsY0FBYztJQUFLO0FBQUU7QUFDbEg0M0YsMEJBQTBCLzNGLFNBQVMsQ0FBQyttRSxNQUFNLEdBQUcsU0FBU0EsT0FBUS94RCxDQUFDO0lBQzdELElBQUltakYsTUFBTSxJQUFJdnpFLG1CQUFtQjVQO0lBQ2pDLElBQUkydEMsVUFBVSxJQUFJdTFDLGVBQWVDO0lBQ2pDLElBQUksQ0FBQzlsQyxNQUFNLENBQUMzVCxLQUFLLENBQUMxcEMsRUFBRXJSLENBQUMsRUFBRXFSLEVBQUVyUixDQUFDLEVBQUVnL0M7SUFDNUIsT0FBT3cxQyxJQUFJOXlFLFdBQVc7QUFDeEI7QUFDQTB5RSwwQkFBMEIvM0YsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3pELE9BQU87UUFBQ2lsRTtLQUF1QjtBQUNqQztBQUNBaXhCLDBCQUEwQi8zRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDdEQsT0FBT2kyRjtBQUNUO0FBQ0FFLG1CQUFtQkMsY0FBYyxDQUFDOTBGLEdBQUcsR0FBRztJQUFjLE9BQU84MEY7QUFBZTtBQUM1RUQsbUJBQW1CRCx1QkFBdUIsQ0FBQzUwRixHQUFHLEdBQUc7SUFBYyxPQUFPNDBGO0FBQXdCO0FBRTlGLzNGLE9BQU9vRCxnQkFBZ0IsQ0FBRTAwRiwyQkFBMkJFO0FBRXBELElBQUlDLGlCQUFpQixTQUFTQTtJQUM1QixJQUFJLENBQUNFLFFBQVEsR0FBRztJQUNoQixJQUFJNXlFLFVBQVUxa0IsU0FBUyxDQUFDLEVBQUU7SUFDMUIsSUFBSSxDQUFDczNGLFFBQVEsR0FBRzV5RTtBQUNsQjtBQUNBMHlFLGVBQWVsNEYsU0FBUyxDQUFDdStDLFNBQVMsR0FBRyxTQUFTQSxVQUFXVixJQUFJO0lBQzNELElBQUkrTixNQUFNL047SUFDVixJQUFJLENBQUN1NkMsUUFBUSxDQUFDcHpFLFlBQVksQ0FBQzRtQyxJQUFJaDRDLGFBQWEsQ0FBQyxJQUFJZzRDLElBQUloNEMsYUFBYSxDQUFDO0FBQ3JFO0FBQ0Fza0YsZUFBZWw0RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDOUMsT0FBTztRQUFDeThDO0tBQVk7QUFDdEI7QUFDQTQ1QyxlQUFlbDRGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUMzQyxPQUFPbzJGO0FBQ1Q7QUFFQSxJQUFJRiwwQkFBMEIsU0FBU0E7SUFDckMsSUFBSSxDQUFDM2xDLE1BQU0sR0FBRyxJQUFJa2xDO0lBQ2xCLElBQUludkUsT0FBT3RuQixTQUFTLENBQUMsRUFBRTtJQUN2QixJQUFJLENBQUMwSSxJQUFJLENBQUM0ZTtBQUNaO0FBQ0E0dkUsd0JBQXdCaDRGLFNBQVMsQ0FBQ3dKLElBQUksR0FBRyxTQUFTQSxLQUFNNGUsSUFBSTtJQUN4RCxJQUFJOU4sU0FBUyxJQUFJO0lBRW5CLElBQUlpQyxRQUFRMmdFLHlCQUF5Qk0sUUFBUSxDQUFDcDFEO0lBQzlDLElBQUssSUFBSWhoQixJQUFJbVYsTUFBTThPLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUMzQyxJQUFJalAsT0FBT2xWLEVBQUVzZ0IsSUFBSTtRQUNqQixJQUFJVCxNQUFNM0ssS0FBS29iLGNBQWM7UUFDN0JwZCxPQUFPKzlFLE9BQU8sQ0FBQ3B4RTtJQUNqQjtBQUNGO0FBQ0Erd0Usd0JBQXdCaDRGLFNBQVMsQ0FBQ3E0RixPQUFPLEdBQUcsU0FBU0EsUUFBU3B4RSxHQUFHO0lBQzdELElBQUkzTSxTQUFTLElBQUk7SUFFbkIsSUFBSyxJQUFJbFQsSUFBSSxHQUFHQSxJQUFJNmYsSUFBSXhtQixNQUFNLEVBQUUyRyxJQUFLO1FBQ25DLElBQUl3a0QsTUFBTSxJQUFJSCxZQUFZeGtDLEdBQUcsQ0FBQzdmLElBQUksRUFBRSxFQUFFNmYsR0FBRyxDQUFDN2YsRUFBRTtRQUM1QyxJQUFJeEcsTUFBTUYsS0FBS0UsR0FBRyxDQUFDZ3JELElBQUl0dUMsRUFBRSxDQUFDM1osQ0FBQyxFQUFFaW9ELElBQUlyNkMsRUFBRSxDQUFDNU4sQ0FBQztRQUNyQyxJQUFJaEQsTUFBTUQsS0FBS0MsR0FBRyxDQUFDaXJELElBQUl0dUMsRUFBRSxDQUFDM1osQ0FBQyxFQUFFaW9ELElBQUlyNkMsRUFBRSxDQUFDNU4sQ0FBQztRQUNyQzJXLE9BQU8rM0MsTUFBTSxDQUFDeGQsTUFBTSxDQUFDajBDLEtBQUtELEtBQUtpckQ7SUFDakM7QUFDRjtBQUNBb3NDLHdCQUF3Qmg0RixTQUFTLENBQUMwK0MsS0FBSyxHQUFHLFNBQVNBO0lBQ2pELElBQUk1OUMsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSUcsTUFBTUUsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSUgsTUFBTUcsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTZoRCxVQUFVLElBQUlrMUM7UUFDbEIsSUFBSSxDQUFDeGxDLE1BQU0sQ0FBQzNULEtBQUssQ0FBQzk5QyxLQUFLRCxLQUFLZ2lEO1FBQzVCLE9BQU9BLFFBQVFtMUMsUUFBUTtJQUN6QixPQUFPLElBQUloM0YsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSXlILFFBQVFwSCxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJcUgsUUFBUXJILFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUkraEQsWUFBWS9oRCxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFJLENBQUN1eEQsTUFBTSxDQUFDM1QsS0FBSyxDQUFDeDJDLE9BQU9DLE9BQU8wNkM7SUFDbEM7QUFDRjtBQUNBbTFDLHdCQUF3Qmg0RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkQsT0FBTyxFQUFFO0FBQ1g7QUFDQW0yRix3QkFBd0JoNEYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3BELE9BQU9rMkY7QUFDVDtBQUVBLElBQUlNLGdCQUFpQixTQUFVQyxjQUFjO0lBQzNDLFNBQVNEO1FBQ1BDLGVBQWVoMkYsSUFBSSxDQUFDLElBQUk7UUFDeEIsSUFBSSxDQUFDaTJGLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJNzFEO1FBQ3hCLElBQUksQ0FBQzgxRCxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLDZCQUE2QixHQUFHO1FBQ3JDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDOVksVUFBVSxHQUFHLElBQUkvQjtRQUN0QixJQUFJcjlFLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUlpMEMsV0FBVzV6QyxTQUFTLENBQUMsRUFBRTtZQUMzQixJQUFJbTRGLGFBQWFuNEYsU0FBUyxDQUFDLEVBQUU7WUFDN0IsSUFBSWszQyxtQkFBbUIvckIsaUJBQWlCVSxxQkFBcUI7WUFDN0QsSUFBSSxDQUFDaXNFLFNBQVMsR0FBR2xrRDtZQUNqQixJQUFJLENBQUM4akQsV0FBVyxHQUFHUztZQUNuQixJQUFJLENBQUNQLGlCQUFpQixHQUFHMWdEO1lBQ3pCLElBQUlpaEQsZUFBZSxNQUFNO2dCQUN2QixJQUFJLENBQUNodEYsR0FBRyxDQUFDZ3RGO1lBQ1g7UUFDRixPQUFPLElBQUluNEYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDakMsSUFBSXk0RixhQUFhcDRGLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLElBQUlxNEYsZUFBZXI0RixTQUFTLENBQUMsRUFBRTtZQUMvQixJQUFJczRGLHFCQUFxQnQ0RixTQUFTLENBQUMsRUFBRTtZQUNyQyxJQUFJLENBQUM4M0YsU0FBUyxHQUFHTTtZQUNqQixJQUFJLENBQUNWLFdBQVcsR0FBR1c7WUFDbkIsSUFBSSxDQUFDVCxpQkFBaUIsR0FBR1U7WUFDekIsSUFBSUQsaUJBQWlCLE1BQU07Z0JBQ3pCLElBQUksQ0FBQ2x0RixHQUFHLENBQUNrdEY7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxJQUFLWixnQkFBaUJELGNBQWM1MUYsU0FBUyxHQUFHNjFGO0lBQ2hERCxjQUFjdDRGLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRTQxRixrQkFBa0JBLGVBQWV2NEYsU0FBUztJQUNuRnM0RixjQUFjdDRGLFNBQVMsQ0FBQzRDLFdBQVcsR0FBRzAxRjtJQUN0Q0EsY0FBY3Q0RixTQUFTLENBQUNxNUYsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCM2tELFFBQVEsRUFBRTFvQixLQUFLO1FBQ3pGLElBQUlocEIsSUFBSSxJQUFJLENBQUNxb0MsTUFBTSxDQUFDK0osT0FBTyxDQUFDcHBCO1FBQzVCLElBQUlpakIsTUFBTWpzQyxFQUFFK3RDLFFBQVE7UUFDcEIsSUFBSWxrQixnQkFBZ0I7UUFDcEIsSUFBSWdpQixNQUFNbG9DLFNBQVNLLElBQUk7UUFDdkI2bkMsTUFBTUksSUFBSTVwQixXQUFXLENBQUNxdkIsVUFBVXBNLFNBQVNFLEVBQUU7UUFDM0MsSUFBSXFHLFFBQVFsb0MsU0FBU0csUUFBUSxFQUFFO1lBQUUrbEI7UUFBaUI7UUFDbEQsSUFBSW1oQixTQUFTc3FELGNBQWNnQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNaLGlCQUFpQixFQUFFN3JFO1FBQ3JFb2lCLElBQUlULFdBQVcsQ0FBQ2tHLFVBQVUxRztJQUM1QjtJQUNBc3FELGNBQWN0NEYsU0FBUyxDQUFDdTVGLGdCQUFnQixHQUFHLFNBQVNBO1FBQ2xELElBQUl6NEYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSW1xRCxLQUFLOXBELFNBQVMsQ0FBQyxFQUFFO1lBQ3JCLElBQUkwNEYsdUJBQXVCMTRGLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDeTRGLGdCQUFnQixDQUFDM3VDLElBQUk0dUMsc0JBQXNCO1FBQ3pELE9BQU8sSUFBSTE0RixVQUFVTCxNQUFNLEtBQUssR0FBRztZQUNqQyxJQUFJZzVGLE9BQU8zNEYsU0FBUyxDQUFDLEVBQUU7WUFDdkIsSUFBSTQ0Rix5QkFBeUI1NEYsU0FBUyxDQUFDLEVBQUU7WUFDekMsSUFBSTY0RixvQkFBb0I3NEYsU0FBUyxDQUFDLEVBQUU7WUFDcEMsSUFBSXF4RCxLQUFLLElBQUltaUMscUJBQXFCbUYsTUFBTSxNQUFNO1lBQzlDdG5DLEdBQUc0aUMsb0JBQW9CLENBQUM0RTtZQUN4QixJQUFJQyxNQUFNLElBQUksQ0FBQ0Msd0JBQXdCO1lBQ3ZDLElBQUlDLFVBQVUsSUFBSSxDQUFDdEIsV0FBVyxZQUFZcDRELGNBQWMsSUFBSSxDQUFDbzRELFdBQVcsWUFBWTk1RCxXQUFXLElBQUksQ0FBQzg1RCxXQUFXLFlBQVkvM0Q7WUFDM0gsSUFBSXM1RCxxQkFBcUJMLDBCQUEwQixDQUFDSTtZQUNwREYsSUFBSTdRLG9CQUFvQixDQUFDLElBQUksQ0FBQzM0QyxNQUFNLEVBQUUraEIsSUFBSTRuQztZQUMxQyxJQUFJLENBQUNDLHdCQUF3QixDQUFDLElBQUksQ0FBQ3BCLFNBQVM7WUFDNUMsT0FBT3ptQztRQUNUO0lBQ0Y7SUFDQW1tQyxjQUFjdDRGLFNBQVMsQ0FBQ2k2RixpQkFBaUIsR0FBRyxTQUFTQSxrQkFBbUJDLFFBQVE7UUFDOUUsSUFBSyxJQUFJOXlGLElBQUksSUFBSSxDQUFDZ3BDLE1BQU0sQ0FBQy9rQixRQUFRLElBQUlqa0IsRUFBRW1rQixPQUFPLElBQUs7WUFDakQsSUFBSTFpQixJQUFJekIsRUFBRXNnQixJQUFJO1lBQ2Q3ZSxFQUFFd3hDLE1BQU0sQ0FBQ29PLGFBQWEsQ0FBQ3l4QztRQUN6QjtJQUNGO0lBQ0E1QixjQUFjdDRGLFNBQVMsQ0FBQ202Rix3QkFBd0IsR0FBRyxTQUFTQSx5QkFBMEJ0d0UsQ0FBQyxFQUFFK2dDLEVBQUUsRUFBRWlxQyxhQUFhO1FBQ3hHLElBQUkxaUMsS0FBSyxJQUFJbWlDLHFCQUFxQjFwQyxJQUFJaXFDLGVBQWU7UUFDckQxaUMsR0FBR2dqQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM1L0MsZ0JBQWdCLElBQUkxckIsRUFBRTByQixnQkFBZ0I7UUFDL0QsSUFBSXFrRCxNQUFNLElBQUksQ0FBQ0Msd0JBQXdCO1FBQ3ZDRCxJQUFJN1Esb0JBQW9CLENBQUMsSUFBSSxDQUFDMzRDLE1BQU0sRUFBRXZtQixFQUFFdW1CLE1BQU0sRUFBRStoQjtRQUNoRCxPQUFPQTtJQUNUO0lBQ0FtbUMsY0FBY3Q0RixTQUFTLENBQUM2b0UsV0FBVyxHQUFHLFNBQVNBO1FBQzdDLE9BQU8sSUFBSSxDQUFDMnZCLFdBQVc7SUFDekI7SUFDQUYsY0FBY3Q0RixTQUFTLENBQUN1b0UsbUJBQW1CLEdBQUcsU0FBU0E7UUFDckQsT0FBTyxJQUFJLENBQUNtd0IsaUJBQWlCO0lBQy9CO0lBQ0FKLGNBQWN0NEYsU0FBUyxDQUFDbzZGLGVBQWUsR0FBRyxTQUFTQTtRQUNqRCxPQUFPLElBQUksQ0FBQ3RCLGdCQUFnQjtJQUM5QjtJQUNBUixjQUFjdDRGLFNBQVMsQ0FBQ3lsRSxRQUFRLEdBQUcsU0FBU0E7UUFDMUMsSUFBSTNrRSxTQUFTLENBQUMsRUFBRSxZQUFZMDlCLE9BQU87WUFDakMsSUFBSXhwQixJQUFJbFUsU0FBUyxDQUFDLEVBQUU7WUFDcEIsSUFBSWtyQixRQUFRaFgsRUFBRXBCLGFBQWE7WUFDM0IsSUFBSSxDQUFDeW1GLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixTQUFTLEVBQUU1c0UsT0FBT3JsQixTQUFTRSxRQUFRO1FBQzNELE9BQU8sSUFBSS9GLFNBQVMsQ0FBQyxFQUFFLFlBQVk0QyxZQUFZO1lBQzdDLElBQUltZCxLQUFLL2YsU0FBUyxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDdTVGLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixTQUFTLEVBQUUvM0UsSUFBSWxhLFNBQVNFLFFBQVE7UUFDeEQ7SUFDRjtJQUNBeXhGLGNBQWN0NEYsU0FBUyxDQUFDNGxFLFVBQVUsR0FBRyxTQUFTQSxXQUFZNXdELENBQUM7UUFDekQsSUFBSXNGLFNBQVMsSUFBSTtRQUVqQixJQUFJLENBQUMwckQsY0FBYyxDQUFDaHhELEVBQUV3cUIsZUFBZSxJQUFJNzRCLFNBQVNJLFFBQVEsRUFBRUosU0FBU0UsUUFBUTtRQUM3RSxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSTROLEVBQUU0cEIsa0JBQWtCLElBQUl4M0IsSUFBSztZQUMvQyxJQUFJdzZCLE9BQU81c0IsRUFBRWdyQixnQkFBZ0IsQ0FBQzU0QjtZQUM5QmtULE9BQU8wckQsY0FBYyxDQUFDcGtDLE1BQU1qN0IsU0FBU0UsUUFBUSxFQUFFRixTQUFTSSxRQUFRO1FBQ2xFO0lBQ0Y7SUFDQXV4RixjQUFjdDRGLFNBQVMsQ0FBQ2kyRixPQUFPLEdBQUcsU0FBU0EsUUFBU3B0RixDQUFDO1FBQ25ELElBQUksQ0FBQ3V5QyxVQUFVLENBQUN2eUM7UUFDaEIsSUFBSW1qQixRQUFRbmpCLEVBQUU2dUIsY0FBYztRQUM1QixJQUFJLENBQUMyaUUsV0FBVyxDQUFDLElBQUksQ0FBQ3pCLFNBQVMsRUFBRTVzRSxLQUFLLENBQUMsRUFBRSxFQUFFcmxCLFNBQVNHLFFBQVE7UUFDNUQsSUFBSSxDQUFDdXpGLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixTQUFTLEVBQUU1c0UsS0FBSyxDQUFDQSxNQUFNdnJCLE1BQU0sR0FBRyxFQUFFLEVBQUVrRyxTQUFTRyxRQUFRO0lBQzdFO0lBQ0F3eEYsY0FBY3Q0RixTQUFTLENBQUN1bUUsYUFBYSxHQUFHLFNBQVNBLGNBQWVqcUQsSUFBSTtRQUNsRSxJQUFJMFAsUUFBUStELGlCQUFpQm1CLG9CQUFvQixDQUFDNVUsS0FBS29iLGNBQWM7UUFDckUsSUFBSTFMLE1BQU12ckIsTUFBTSxHQUFHLEdBQUc7WUFDcEIsSUFBSSxDQUFDcTRGLGdCQUFnQixHQUFHO1lBQ3hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHL3NFLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE9BQU87UUFDVDtRQUNBLElBQUluakIsSUFBSSxJQUFJcWxFLEtBQUtsaUQsT0FBTyxJQUFJOGlCLE1BQU0sSUFBSSxDQUFDOHBELFNBQVMsRUFBRWp5RixTQUFTRSxRQUFRO1FBQ25FLElBQUksQ0FBQzR4RixZQUFZLENBQUN2bEUsR0FBRyxDQUFDNVcsTUFBTXpUO1FBQzVCLElBQUksQ0FBQ3V5QyxVQUFVLENBQUN2eUM7UUFDaEI2VSxPQUFPRSxNQUFNLENBQUNvTyxNQUFNdnJCLE1BQU0sSUFBSSxHQUFHO1FBQ2pDLElBQUksQ0FBQzQ0RixtQkFBbUIsQ0FBQyxJQUFJLENBQUNULFNBQVMsRUFBRTVzRSxLQUFLLENBQUMsRUFBRTtRQUNqRCxJQUFJLENBQUNxdEUsbUJBQW1CLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU1c0UsS0FBSyxDQUFDQSxNQUFNdnJCLE1BQU0sR0FBRyxFQUFFO0lBQ2xFO0lBQ0E2M0YsY0FBY3Q0RixTQUFTLENBQUNzNkYsZUFBZSxHQUFHLFNBQVNBO1FBQ2pELE9BQU8sSUFBSSxDQUFDdkIsYUFBYTtJQUMzQjtJQUNBVCxjQUFjdDRGLFNBQVMsQ0FBQ3U2RixpQkFBaUIsR0FBRyxTQUFTQTtRQUNuRCxJQUFJNXJFLE9BQU8sSUFBSSxDQUFDNG1CLGdCQUFnQjtRQUNoQyxJQUFJdHVCLE1BQU0sSUFBSWxuQixNQUFNNHVCLEtBQUtoYixJQUFJLElBQUl0VCxJQUFJLENBQUM7UUFDdEMsSUFBSStHLElBQUk7UUFDUixJQUFLLElBQUlzekIsS0FBSy9MLEtBQUt0RCxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1lBQzVDLElBQUkwZSxPQUFPdlAsR0FBR2hULElBQUk7WUFDbEJULEdBQUcsQ0FBQzdmLElBQUksR0FBRzZpQyxLQUFLcjJCLGFBQWEsR0FBRzVPLElBQUk7UUFDdEM7UUFDQSxPQUFPaWlCO0lBQ1Q7SUFDQXF4RSxjQUFjdDRGLFNBQVMsQ0FBQ3UxQyxnQkFBZ0IsR0FBRyxTQUFTQTtRQUNsRCxJQUFJLElBQUksQ0FBQ3NqRCxjQUFjLEtBQUssTUFBTTtZQUFFLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUksQ0FBQ3h0RCxNQUFNLENBQUNrSyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNxakQsU0FBUztRQUFHO1FBQ3hHLE9BQU8sSUFBSSxDQUFDQyxjQUFjO0lBQzVCO0lBQ0FQLGNBQWN0NEYsU0FBUyxDQUFDdzZGLHVCQUF1QixHQUFHLFNBQVNBLHdCQUF5QjlsRCxRQUFRLEVBQUUxb0IsS0FBSyxFQUFFNmlCLEdBQUc7UUFDdEcsSUFBSSxJQUFJLENBQUM2TCxjQUFjLENBQUNoRyxVQUFVMW9CLFFBQVE7WUFBRSxPQUFPO1FBQUs7UUFDeEQsSUFBSTZpQixRQUFRbG9DLFNBQVNHLFFBQVEsSUFBSSxJQUFJLENBQUM2eEYsNkJBQTZCLEVBQUU7WUFBRSxJQUFJLENBQUNVLG1CQUFtQixDQUFDM2tELFVBQVUxb0I7UUFBUSxPQUFPO1lBQUUsSUFBSSxDQUFDcXVFLFdBQVcsQ0FBQzNsRCxVQUFVMW9CLE9BQU82aUI7UUFBTTtJQUNySztJQUNBeXBELGNBQWN0NEYsU0FBUyxDQUFDZ21FLGNBQWMsR0FBRyxTQUFTQSxlQUFnQnkwQixFQUFFLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztRQUNuRixJQUFJRixHQUFHM2dGLE9BQU8sSUFBSTtZQUFFLE9BQU87UUFBSztRQUNoQyxJQUFJa1MsUUFBUStELGlCQUFpQm1CLG9CQUFvQixDQUFDdXBFLEdBQUcvaUUsY0FBYztRQUNuRSxJQUFJMUwsTUFBTXZyQixNQUFNLEdBQUcsR0FBRztZQUNwQixJQUFJLENBQUNxNEYsZ0JBQWdCLEdBQUc7WUFDeEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcvc0UsS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTztRQUNUO1FBQ0EsSUFBSXFJLE9BQU9xbUU7UUFDWCxJQUFJbm1FLFFBQVFvbUU7UUFDWixJQUFJbjVFLGFBQWEyRixLQUFLLENBQUM2RSxRQUFRO1lBQzdCcUksT0FBT3NtRTtZQUNQcG1FLFFBQVFtbUU7UUFDVjtRQUNBLElBQUk3eEYsSUFBSSxJQUFJcWxFLEtBQUtsaUQsT0FBTyxJQUFJOGlCLE1BQU0sSUFBSSxDQUFDOHBELFNBQVMsRUFBRWp5RixTQUFTRyxRQUFRLEVBQUV1dEIsTUFBTUU7UUFDM0UsSUFBSSxDQUFDa2tFLFlBQVksQ0FBQ3ZsRSxHQUFHLENBQUN1bkUsSUFBSTV4RjtRQUMxQixJQUFJLENBQUN1eUMsVUFBVSxDQUFDdnlDO1FBQ2hCLElBQUksQ0FBQ3d4RixXQUFXLENBQUMsSUFBSSxDQUFDekIsU0FBUyxFQUFFNXNFLEtBQUssQ0FBQyxFQUFFLEVBQUVybEIsU0FBU0csUUFBUTtJQUM5RDtJQUNBd3hGLGNBQWN0NEYsU0FBUyxDQUFDcTZGLFdBQVcsR0FBRyxTQUFTQSxZQUFhM2xELFFBQVEsRUFBRTFvQixLQUFLLEVBQUUyb0IsVUFBVTtRQUNyRixJQUFJM3hDLElBQUksSUFBSSxDQUFDcW9DLE1BQU0sQ0FBQytKLE9BQU8sQ0FBQ3BwQjtRQUM1QixJQUFJaWpCLE1BQU1qc0MsRUFBRSt0QyxRQUFRO1FBQ3BCLElBQUk5QixRQUFRLE1BQU07WUFDaEJqc0MsRUFBRXN0QyxNQUFNLEdBQUcsSUFBSXhCLE1BQU00RixVQUFVQztRQUNqQyxPQUFPO1lBQUUxRixJQUFJVCxXQUFXLENBQUNrRyxVQUFVQztRQUFhO0lBQ2xEO0lBQ0EyakQsY0FBY3Q0RixTQUFTLENBQUM2NUYsd0JBQXdCLEdBQUcsU0FBU0E7UUFDMUQsT0FBTyxJQUFJdkU7SUFDYjtJQUNBZ0QsY0FBY3Q0RixTQUFTLENBQUNnNkYsd0JBQXdCLEdBQUcsU0FBU0EseUJBQTBCdGxELFFBQVE7UUFDNUYsSUFBSXA2QixTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSSxJQUFJLENBQUNncEMsTUFBTSxDQUFDL2tCLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUNqRCxJQUFJMWlCLElBQUl6QixFQUFFc2dCLElBQUk7WUFDZCxJQUFJMGpELE9BQU92aUUsRUFBRWtvQyxRQUFRLEdBQUcxckIsV0FBVyxDQUFDcXZCO1lBQ3BDLElBQUssSUFBSWttRCxPQUFPL3hGLEVBQUV3eEMsTUFBTSxDQUFDaHZCLFFBQVEsSUFBSXV2RSxLQUFLcnZFLE9BQU8sSUFBSztnQkFDcEQsSUFBSXU4QixLQUFLOHlDLEtBQUtsekUsSUFBSTtnQkFDbEJwTixPQUFPa2dGLHVCQUF1QixDQUFDOWxELFVBQVVvVCxHQUFHOTdCLEtBQUssRUFBRW8vQztZQUNyRDtRQUNGO0lBQ0Y7SUFDQWt0QixjQUFjdDRGLFNBQVMsQ0FBQ2lNLEdBQUcsR0FBRyxTQUFTQTtRQUNyQyxJQUFJbkwsVUFBVUwsTUFBTSxLQUFLLEdBQUc7WUFDMUIsSUFBSW9wQixJQUFJL29CLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLElBQUkrb0IsRUFBRS9QLE9BQU8sSUFBSTtnQkFBRSxPQUFPO1lBQUs7WUFDL0IsSUFBSStQLGFBQWE0VyxjQUFjO2dCQUFFLElBQUksQ0FBQ2s0RCw2QkFBNkIsR0FBRztZQUFPO1lBQzdFLElBQUk5dUUsYUFBYTZVLFNBQVM7Z0JBQUUsSUFBSSxDQUFDa25DLFVBQVUsQ0FBQy83QztZQUFJLE9BQzNDLElBQUlBLGFBQWFzUSxZQUFZO2dCQUFFLElBQUksQ0FBQ29zQyxhQUFhLENBQUMxOEM7WUFBSSxPQUN0RCxJQUFJQSxhQUFhMlUsT0FBTztnQkFBRSxJQUFJLENBQUNpbkMsUUFBUSxDQUFDNTdDO1lBQUksT0FDNUMsSUFBSUEsYUFBYXFXLFlBQVk7Z0JBQUUsSUFBSSxDQUFDeW1DLGFBQWEsQ0FBQzk4QztZQUFJLE9BQ3RELElBQUlBLGFBQWFrUCxpQkFBaUI7Z0JBQUUsSUFBSSxDQUFDNHRDLGFBQWEsQ0FBQzk4QztZQUFJLE9BQzNELElBQUlBLGFBQWE0VyxjQUFjO2dCQUFFLElBQUksQ0FBQ2ttQyxhQUFhLENBQUM5OEM7WUFBSSxPQUN4RCxJQUFJQSxhQUFhMk4sb0JBQW9CO2dCQUFFLElBQUksQ0FBQ212QyxhQUFhLENBQUM5OEM7WUFBSSxPQUM5RDtnQkFBRSxNQUFNLElBQUl4bkIsTUFBTXduQixFQUFFL25CLFFBQVEsR0FBRzIvQixPQUFPO1lBQUk7UUFDakQsT0FBTztZQUFFLE9BQU84MkQsZUFBZXY0RixTQUFTLENBQUNpTSxHQUFHLENBQUNzTixLQUFLLENBQUMsSUFBSSxFQUFFelk7UUFBVztJQUN0RTtJQUNBdzNGLGNBQWN0NEYsU0FBUyxDQUFDMm1FLGFBQWEsR0FBRyxTQUFTQSxjQUFlcHVDLEVBQUU7UUFDaEUsSUFBSWplLFNBQVMsSUFBSTtRQUVqQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUlteEIsR0FBR25PLGdCQUFnQixJQUFJaGpCLElBQUs7WUFDOUMsSUFBSXlpQixJQUFJME8sR0FBRzlPLFlBQVksQ0FBQ3JpQjtZQUN4QmtULE9BQU9yTyxHQUFHLENBQUM0ZDtRQUNiO0lBQ0Y7SUFDQXl1RSxjQUFjdDRGLFNBQVMsQ0FBQyttRSxNQUFNLEdBQUcsU0FBU0EsT0FBUWxtRCxFQUFFO1FBQ2xELElBQUkxWixhQUFhLElBQUksQ0FBQ3F4RixXQUFXLEVBQUUvNUQsY0FBYyxJQUFJLENBQUMrNUQsV0FBVyxDQUFDcHVFLGdCQUFnQixLQUFLLElBQUk7WUFDekYsSUFBSSxJQUFJLENBQUM0dUUsY0FBYyxLQUFLLE1BQU07Z0JBQ2hDLElBQUksQ0FBQ0EsY0FBYyxHQUFHLElBQUlqQiwwQkFBMEIsSUFBSSxDQUFDUyxXQUFXO1lBQ3RFO1lBQ0EsT0FBTyxJQUFJLENBQUNRLGNBQWMsQ0FBQ2p5QixNQUFNLENBQUNsbUQ7UUFDcEM7UUFDQSxPQUFPLElBQUksQ0FBQ3EvRCxVQUFVLENBQUNuWixNQUFNLENBQUNsbUQsSUFBSSxJQUFJLENBQUMyM0UsV0FBVztJQUNwRDtJQUNBRixjQUFjdDRGLFNBQVMsQ0FBQ3dxQyxRQUFRLEdBQUcsU0FBU0E7UUFDMUMsSUFBSTFwQyxVQUFVTCxNQUFNLEtBQUssR0FBRztZQUMxQixJQUFJNmIsT0FBT3hiLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDMjNGLFlBQVksQ0FBQ3IxRixHQUFHLENBQUNrWjtRQUMvQixPQUFPO1lBQUUsT0FBT2k4RSxlQUFldjRGLFNBQVMsQ0FBQ3dxQyxRQUFRLENBQUNqeEIsS0FBSyxDQUFDLElBQUksRUFBRXpZO1FBQVc7SUFDM0U7SUFDQXczRixjQUFjdDRGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtRQUM3QyxPQUFPLEVBQUU7SUFDWDtJQUNBeTJGLGNBQWN0NEYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO1FBQzFDLE9BQU93MkY7SUFDVDtJQUNBQSxjQUFjZ0IsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CdGhELGdCQUFnQixFQUFFbnJCLGFBQWE7UUFDM0YsT0FBT21yQixpQkFBaUJwckIsWUFBWSxDQUFDQyxpQkFBaUJsbUIsU0FBU0csUUFBUSxHQUFHSCxTQUFTRSxRQUFRO0lBQzdGO0lBRUEsT0FBT3l4RjtBQUNULEVBQUVwK0M7QUFFRixJQUFJMmdELGtCQUFrQixTQUFTQTtJQUM3QixJQUFJLENBQUMzL0IsR0FBRyxHQUFHLElBQUloNkM7SUFDZixJQUFJLENBQUM0NUUscUJBQXFCLEdBQUc7SUFDN0IsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJajZGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUk0L0UsS0FBS3YvRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJLENBQUNrNkYsdUJBQXVCLENBQUMzYSxHQUFHdDFELGlCQUFpQjtRQUNqRCxJQUFJLENBQUNnd0UsSUFBSSxHQUFHLElBQUloN0YsTUFBTSxHQUFHTSxJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDMDZGLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSXpDLGNBQWMsR0FBR2pZO0lBQ3RDLE9BQU8sSUFBSXYvRSxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJOC9FLE9BQU96L0UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXcvRSxLQUFLeC9FLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUlrM0MsbUJBQW1CL3JCLGlCQUFpQlUscUJBQXFCO1FBQzdELElBQUk0ekQsS0FBS3gxRCxpQkFBaUIsR0FBR2xtQixTQUFTLENBQUN5N0UsR0FBR3YxRCxpQkFBaUIsT0FBTyxHQUFHO1lBQUUsSUFBSSxDQUFDaXdFLHVCQUF1QixDQUFDemEsS0FBS3gxRCxpQkFBaUI7UUFBSyxPQUFPO1lBQUUsSUFBSSxDQUFDaXdFLHVCQUF1QixDQUFDMWEsR0FBR3YxRCxpQkFBaUI7UUFBSztRQUM5TCxJQUFJLENBQUNnd0UsSUFBSSxHQUFHLElBQUloN0YsTUFBTSxHQUFHTSxJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDMDZGLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSXpDLGNBQWMsR0FBRy9YLE1BQU12b0M7UUFDMUMsSUFBSSxDQUFDK2lELElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSXpDLGNBQWMsR0FBR2hZLElBQUl0b0M7SUFDMUMsT0FBTyxJQUFJbDNDLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUl3NkYsT0FBT242RixTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJMC9FLE9BQU8xL0UsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXM0RixxQkFBcUJ0NEYsU0FBUyxDQUFDLEVBQUU7UUFDckMsSUFBSW02RixLQUFLbHdFLGlCQUFpQixHQUFHbG1CLFNBQVMsQ0FBQzI3RSxLQUFLejFELGlCQUFpQixPQUFPLEdBQUc7WUFBRSxJQUFJLENBQUNpd0UsdUJBQXVCLENBQUNDLEtBQUtsd0UsaUJBQWlCO1FBQUssT0FBTztZQUFFLElBQUksQ0FBQ2l3RSx1QkFBdUIsQ0FBQ3hhLEtBQUt6MUQsaUJBQWlCO1FBQUs7UUFDbE0sSUFBSSxDQUFDZ3dFLElBQUksR0FBRyxJQUFJaDdGLE1BQU0sR0FBR00sSUFBSSxDQUFDO1FBQzlCLElBQUksQ0FBQzA2RixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUl6QyxjQUFjLEdBQUcyQyxNQUFNN0I7UUFDMUMsSUFBSSxDQUFDMkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJekMsY0FBYyxHQUFHOVgsTUFBTTRZO0lBQzVDO0FBQ0Y7QUFDQXlCLGdCQUFnQjc2RixTQUFTLENBQUNxcUYsY0FBYyxHQUFHLFNBQVNBLGVBQWdCampGLENBQUM7SUFDbkUsT0FBTyxJQUFJLENBQUMyekYsSUFBSSxDQUFDM3pGLEVBQUUsQ0FBQ3loRSxXQUFXO0FBQ2pDO0FBQ0FneUIsZ0JBQWdCNzZGLFNBQVMsQ0FBQ2c3Rix1QkFBdUIsR0FBRyxTQUFTQSx3QkFBeUJ0M0QsRUFBRTtJQUN0RixJQUFJLENBQUNvM0QscUJBQXFCLEdBQUdwM0Q7SUFDN0IsSUFBSSxDQUFDdzNCLEdBQUcsQ0FBQy82QyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMyNkUscUJBQXFCO0FBQ3ZEO0FBQ0FELGdCQUFnQjc2RixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDL0MsT0FBTyxFQUFFO0FBQ1g7QUFDQWc1RixnQkFBZ0I3NkYsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU8rNEY7QUFDVDtBQUVBLDBCQUEwQjtBQUUxQixJQUFJSyxpQkFBaUIsU0FBU0Esa0JBQW1CO0FBRWpEQSxlQUFlbDdGLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUM5QyxPQUFPLEVBQUU7QUFDWDtBQUNBcTVGLGVBQWVsN0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQzNDLE9BQU9vNUY7QUFDVDtBQUNBQSxlQUFlLzhFLEdBQUcsR0FBRyxTQUFTQTtJQUM1QixJQUFJcmQsU0FBUyxDQUFDLEVBQUUsWUFBWXVuQixZQUFZbGhCLGFBQWFyRyxTQUFTLENBQUMsRUFBRSxFQUFFbzZGLGVBQWVDLEtBQUssR0FBRztRQUN4RixJQUFJL3lFLE9BQU90bkIsU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSXlvRixLQUFLem9GLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl3b0YsU0FBUyxJQUFJOTdEO1FBQ2pCLElBQUssSUFBSXBtQixJQUFJLEdBQUdBLElBQUlnaEIsS0FBS2dDLGdCQUFnQixJQUFJaGpCLElBQUs7WUFDaEQsSUFBSXlpQixJQUFJMC9ELEdBQUdwckUsR0FBRyxDQUFDaUssS0FBS3FCLFlBQVksQ0FBQ3JpQjtZQUNqQyxJQUFJeWlCLE1BQU0sTUFBTTtnQkFBRXkvRCxPQUFPcjlFLEdBQUcsQ0FBQzRkO1lBQUk7UUFDbkM7UUFDQSxPQUFPekIsS0FBS29CLFVBQVUsR0FBR3liLGFBQWEsQ0FBQ3FrRDtJQUN6QyxPQUFPLElBQUluaUYsYUFBYXJHLFNBQVMsQ0FBQyxFQUFFLEVBQUVnc0IsZUFBZTNsQixhQUFhckcsU0FBUyxDQUFDLEVBQUUsRUFBRW82RixlQUFlQyxLQUFLLEdBQUc7UUFDckcsSUFBSXpkLFFBQVE1OEUsU0FBUyxDQUFDLEVBQUU7UUFDeEIsSUFBSXM2RixPQUFPdDZGLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUl1NkYsV0FBVyxJQUFJN3RFO1FBQ25CLElBQUssSUFBSTVILE1BQU04M0QsTUFBTXJ5RCxRQUFRLElBQUl6RixJQUFJMkYsT0FBTyxJQUFLO1lBQy9DLElBQUk1QixNQUFNL0QsSUFBSThCLElBQUk7WUFDbEIsSUFBSTR6RSxLQUFLRixLQUFLajlFLEdBQUcsQ0FBQ3dMO1lBQ2xCLElBQUkyeEUsT0FBTyxNQUFNO2dCQUFFRCxTQUFTcHZGLEdBQUcsQ0FBQ3F2RjtZQUFLO1FBQ3ZDO1FBQ0EsT0FBT0Q7SUFDVDtBQUNGO0FBQ0FILGVBQWVDLEtBQUssR0FBRyxTQUFTQSxTQUFVO0FBRTFDLElBQUk1USxZQUFhLFNBQVVzUSxlQUFlO0lBQ3hDLFNBQVN0UTtRQUNQLElBQUlsSyxLQUFLdi9FLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUl3L0UsS0FBS3gvRSxTQUFTLENBQUMsRUFBRTtRQUNyQis1RixnQkFBZ0J0NEYsSUFBSSxDQUFDLElBQUksRUFBRTg5RSxJQUFJQztRQUMvQixJQUFJLENBQUNKLFVBQVUsR0FBRyxJQUFJL0I7UUFDdEIsSUFBSSxDQUFDNWtELFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNnaUUsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQzVxQixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUMvSSxTQUFTLEdBQUcsSUFBSXNFO1FBQ3JCLElBQUksQ0FBQ3N2QixlQUFlLEdBQUcsSUFBSWh1RTtRQUMzQixJQUFJLENBQUNvOEQsZUFBZSxHQUFHLElBQUlwOEQ7UUFDM0IsSUFBSSxDQUFDczlELGdCQUFnQixHQUFHLElBQUl0OUQ7UUFDNUIsSUFBSSxDQUFDbWpELE1BQU0sR0FBRyxJQUFJejJCLFlBQVksSUFBSW14QjtRQUNsQyxJQUFJLENBQUM5eEMsU0FBUyxHQUFHOG1ELEdBQUc3MkQsVUFBVTtJQUNoQztJQUVBLElBQUtxeEUsaUJBQWtCdFEsVUFBVTduRixTQUFTLEdBQUdtNEY7SUFDN0N0USxVQUFVdnFGLFNBQVMsR0FBR0MsT0FBTzBDLE1BQU0sQ0FBRWs0RixtQkFBbUJBLGdCQUFnQjc2RixTQUFTO0lBQ2pGdXFGLFVBQVV2cUYsU0FBUyxDQUFDNEMsV0FBVyxHQUFHMm5GO0lBQ2xDQSxVQUFVdnFGLFNBQVMsQ0FBQzZ3RSxnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBa0Job0UsQ0FBQztRQUNqRSxJQUFJaW9FLGVBQWUsSUFBSSxDQUFDbEosU0FBUyxDQUFDMEUsYUFBYSxDQUFDempFO1FBQ2hELElBQUlpb0UsaUJBQWlCLE1BQU07WUFDekIsSUFBSUMsZ0JBQWdCRCxhQUFhLy9CLFFBQVE7WUFDekMsSUFBSWlnQyxlQUFlbm9FLEVBQUVrb0MsUUFBUTtZQUM3QixJQUFJLENBQUMrL0IsYUFBYVYsZ0JBQWdCLENBQUN2bkUsSUFBSTtnQkFDckNtb0UsZUFBZSxJQUFJbGlDLE1BQU1qbUMsRUFBRWtvQyxRQUFRO2dCQUNuQ2lnQyxhQUFhOWlDLElBQUk7WUFDbkI7WUFDQSxJQUFJaFMsUUFBUTQwQyxhQUFheGtDLFFBQVE7WUFDakMsSUFBSXBRLE1BQU10bEIsTUFBTSxJQUFJO2dCQUNsQnNsQixNQUFNandCLEdBQUcsQ0FBQzhrRTtZQUNaO1lBQ0E3MEMsTUFBTWp3QixHQUFHLENBQUMra0U7WUFDVkQsY0FBY2hqQyxLQUFLLENBQUNpakM7UUFDdEIsT0FBTztZQUNMLElBQUksQ0FBQ3BKLFNBQVMsQ0FBQzM3RCxHQUFHLENBQUNwRDtRQUNyQjtJQUNGO0lBQ0EwaEYsVUFBVXZxRixTQUFTLENBQUNncUYsUUFBUSxHQUFHLFNBQVNBO1FBQ3RDLE9BQU8sSUFBSSxDQUFDclosTUFBTTtJQUNwQjtJQUNBNFosVUFBVXZxRixTQUFTLENBQUN5N0YsMEJBQTBCLEdBQUcsU0FBU0E7UUFDeEQsSUFBSyxJQUFJL2dFLEtBQUssSUFBSSxDQUFDaTJDLE1BQU0sQ0FBQzUxQixXQUFXLEdBQUcxdkIsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztZQUNqRSxJQUFJK2QsS0FBSzVPLEdBQUdoVCxJQUFJO1lBQ2hCLElBQUlrbEIsTUFBTXRELEdBQUdpQixNQUFNO1lBQ25CLElBQUlqQixHQUFHa0ssVUFBVSxNQUFNNUcsSUFBSTRHLFVBQVUsSUFBSTtnQkFDdkNsSyxHQUFHa0QsV0FBVyxDQUFDO2dCQUNmSSxJQUFJSixXQUFXLENBQUM7WUFDbEI7UUFDRjtJQUNGO0lBQ0ErOUMsVUFBVXZxRixTQUFTLENBQUNnckYsYUFBYSxHQUFHLFNBQVNBLGNBQWVoL0QsS0FBSztRQUMvRCxJQUFJLElBQUksQ0FBQ3luQixTQUFTLENBQUN6bkIsT0FBTyxJQUFJLENBQUM0OUQsZUFBZSxHQUFHO1lBQUUsT0FBTztRQUFLO1FBQy9ELElBQUksSUFBSSxDQUFDbjJDLFNBQVMsQ0FBQ3puQixPQUFPLElBQUksQ0FBQ3d2RSxlQUFlLEdBQUc7WUFBRSxPQUFPO1FBQUs7UUFDL0QsT0FBTztJQUNUO0lBQ0FqUixVQUFVdnFGLFNBQVMsQ0FBQ3c1RSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWlCa2lCLGVBQWUsRUFBRUMsY0FBYyxFQUFFeC9DLGNBQWMsRUFBRXkvQyxNQUFNO1FBQ3JILElBQUkxMkQsV0FBVyxJQUFJMVg7UUFDbkIwWCxTQUFTblksTUFBTSxDQUFDMnVFO1FBQ2hCeDJELFNBQVNuWSxNQUFNLENBQUM0dUU7UUFDaEJ6MkQsU0FBU25ZLE1BQU0sQ0FBQ292QjtRQUNoQixJQUFJalgsU0FBU3ByQixPQUFPLElBQUk7WUFBRSxPQUFPeXdFLFVBQVVzUixpQkFBaUIsQ0FBQ0QsUUFBUSxJQUFJLENBQUNiLElBQUksQ0FBQyxFQUFFLENBQUNseUIsV0FBVyxJQUFJLElBQUksQ0FBQ2t5QixJQUFJLENBQUMsRUFBRSxDQUFDbHlCLFdBQVcsSUFBSSxJQUFJLENBQUN0dkMsU0FBUztRQUFFO1FBQzdJLE9BQU8sSUFBSSxDQUFDQSxTQUFTLENBQUMwTCxhQUFhLENBQUNDO0lBQ3RDO0lBQ0FxbEQsVUFBVXZxRixTQUFTLENBQUM4cUUsY0FBYyxHQUFHLFNBQVNBO1FBQzVDLElBQUssSUFBSXR3QixTQUFTLElBQUksQ0FBQ20yQixNQUFNLENBQUN2akMsUUFBUSxHQUFHL2hCLFFBQVEsSUFBSW12QixPQUFPanZCLE9BQU8sSUFBSztZQUN0RSxJQUFJMGUsT0FBT3VRLE9BQU85eUIsSUFBSTtZQUN0QnVpQixLQUFLRyxRQUFRLEdBQUcwZ0MsY0FBYztRQUNoQztJQUNGO0lBQ0F5ZixVQUFVdnFGLFNBQVMsQ0FBQ3l6QyxTQUFTLEdBQUcsU0FBU0EsVUFBV3puQixLQUFLLEVBQUVrWixRQUFRO1FBQ2pFLElBQUk1cUIsU0FBUyxJQUFJO1FBRWpCLElBQUssSUFBSW9nQixLQUFLd0ssU0FBUzdaLFFBQVEsSUFBSXFQLEdBQUduUCxPQUFPLElBQUs7WUFDaEQsSUFBSW5ELE9BQU9zUyxHQUFHaFQsSUFBSTtZQUNsQixJQUFJbW5CLE1BQU12MEIsT0FBTzRsRSxVQUFVLENBQUNuWixNQUFNLENBQUMvNkMsT0FBTzVEO1lBQzFDLElBQUl5bUIsUUFBUWxvQyxTQUFTSSxRQUFRLEVBQUU7Z0JBQUUsT0FBTztZQUFLO1FBQy9DO1FBQ0EsT0FBTztJQUNUO0lBQ0F3akYsVUFBVXZxRixTQUFTLENBQUM4N0YscUJBQXFCLEdBQUcsU0FBU0E7UUFDbkQsSUFBSUMsV0FBVyxJQUFJdnVFO1FBQ25CLElBQUssSUFBSWtOLEtBQUssSUFBSSxDQUFDa3RDLFNBQVMsQ0FBQ3Y4QyxRQUFRLElBQUlxUCxHQUFHblAsT0FBTyxJQUFLO1lBQ3RELElBQUkxaUIsSUFBSTZ4QixHQUFHaFQsSUFBSTtZQUNmLElBQUk3ZSxFQUFFbWdELFdBQVcsSUFBSTtnQkFDbkJ0dUIsR0FBR3pOLE1BQU07Z0JBQ1Q4dUUsU0FBUzl2RixHQUFHLENBQUNwRCxFQUFFNm1FLGdCQUFnQjtZQUNqQztRQUNGO1FBQ0EsSUFBSSxDQUFDOUgsU0FBUyxDQUFDNzZDLE1BQU0sQ0FBQ2d2RTtJQUN4QjtJQUNBeFIsVUFBVXZxRixTQUFTLENBQUNnOEYsbUJBQW1CLEdBQUcsU0FBU0E7UUFDakQsSUFBSyxJQUFJeGhELFNBQVMsSUFBSSxDQUFDbTJCLE1BQU0sQ0FBQ3ZqQyxRQUFRLEdBQUcvaEIsUUFBUSxJQUFJbXZCLE9BQU9qdkIsT0FBTyxJQUFLO1lBQ3RFLElBQUkwZSxPQUFPdVEsT0FBTzl5QixJQUFJO1lBQ3RCLElBQUl1bkIsTUFBTWhGLEtBQUtHLFFBQVEsR0FBRzJHLFFBQVE7WUFDbEM5RyxLQUFLOEcsUUFBUSxHQUFHaEQsS0FBSyxDQUFDa0I7UUFDeEI7SUFDRjtJQUNBczdDLFVBQVV2cUYsU0FBUyxDQUFDMjVFLGlCQUFpQixHQUFHLFNBQVNBLGtCQUFtQnNpQixhQUFhO1FBQy9FLElBQUksQ0FBQ0MsY0FBYyxDQUFDRDtRQUNwQixPQUFPLElBQUksQ0FBQ1YsV0FBVztJQUN6QjtJQUNBaFIsVUFBVXZxRixTQUFTLENBQUNtOEYsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CaG9ELEtBQUs7UUFDdkUsSUFBSTc1QixTQUFTLElBQUk7UUFFakIsSUFBSyxJQUFJbFQsSUFBSStzQyxNQUFNOW9CLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztZQUMzQyxJQUFJMWlCLElBQUl6QixFQUFFc2dCLElBQUk7WUFDZHBOLE9BQU91MkQsZ0JBQWdCLENBQUNob0U7UUFDMUI7SUFDRjtJQUNBMGhGLFVBQVV2cUYsU0FBUyxDQUFDazhGLGNBQWMsR0FBRyxTQUFTQSxlQUFnQm5TLE1BQU07UUFDbEUsSUFBSSxDQUFDcVMsVUFBVSxDQUFDO1FBQ2hCLElBQUksQ0FBQ0EsVUFBVSxDQUFDO1FBQ2hCLElBQUksQ0FBQ3JCLElBQUksQ0FBQyxFQUFFLENBQUN4QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNyK0IsR0FBRyxFQUFFO1FBQ3hDLElBQUksQ0FBQzYvQixJQUFJLENBQUMsRUFBRSxDQUFDeEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDcitCLEdBQUcsRUFBRTtRQUN4QyxJQUFJLENBQUM2L0IsSUFBSSxDQUFDLEVBQUUsQ0FBQ1osd0JBQXdCLENBQUMsSUFBSSxDQUFDWSxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQzcvQixHQUFHLEVBQUU7UUFDOUQsSUFBSW1oQyxpQkFBaUIsSUFBSTd1RTtRQUN6QixJQUFJLENBQUN1dEUsSUFBSSxDQUFDLEVBQUUsQ0FBQ2QsaUJBQWlCLENBQUNvQztRQUMvQixJQUFJLENBQUN0QixJQUFJLENBQUMsRUFBRSxDQUFDZCxpQkFBaUIsQ0FBQ29DO1FBQy9CLG9DQUFvQztRQUNwQyxJQUFJLENBQUNGLGlCQUFpQixDQUFDRTtRQUN2QixJQUFJLENBQUNDLHVCQUF1QjtRQUM1QixJQUFJLENBQUNSLHFCQUFxQjtRQUMxQjlTLG9CQUFvQjFVLFVBQVUsQ0FBQyxJQUFJLENBQUMxTSxTQUFTLENBQUN4OUIsUUFBUTtRQUN0RCxJQUFJLENBQUN1bUMsTUFBTSxDQUFDcDFCLFFBQVEsQ0FBQyxJQUFJLENBQUNxc0IsU0FBUyxDQUFDeDlCLFFBQVE7UUFDNUMsSUFBSSxDQUFDMCtCLGdCQUFnQjtRQUNyQixJQUFJLENBQUN5ekIsb0JBQW9CO1FBQ3pCLElBQUksQ0FBQ0MsbUJBQW1CLENBQUN6UztRQUN6QixJQUFJLENBQUMwUiwwQkFBMEI7UUFDL0IsSUFBSW5xQixjQUFjLElBQUkxMUIsZUFBZSxJQUFJLENBQUNyaUIsU0FBUztRQUNuRCszQyxZQUFZcmxFLEdBQUcsQ0FBQyxJQUFJLENBQUMwa0UsTUFBTTtRQUMzQixJQUFJLENBQUM2cUIsZUFBZSxHQUFHbHFCLFlBQVkxMEIsV0FBVztRQUM5QyxJQUFJNi9DLGNBQWMsSUFBSWhULFlBQVksSUFBSSxFQUFFLElBQUksQ0FBQ2x3RCxTQUFTLEVBQUUsSUFBSSxDQUFDMm1ELFVBQVU7UUFDdkUsSUFBSSxDQUFDMEosZUFBZSxHQUFHNlMsWUFBWTk2QyxLQUFLLENBQUNvb0M7UUFDekMsSUFBSTJTLGVBQWUsSUFBSTdSLGFBQWEsSUFBSSxFQUFFLElBQUksQ0FBQ3R4RCxTQUFTLEVBQUUsSUFBSSxDQUFDMm1ELFVBQVU7UUFDekUsSUFBSSxDQUFDNEssZ0JBQWdCLEdBQUc0UixhQUFhLzZDLEtBQUssQ0FBQ29vQztRQUMzQyxJQUFJLENBQUN3UixXQUFXLEdBQUcsSUFBSSxDQUFDL2hCLGVBQWUsQ0FBQyxJQUFJLENBQUNzUixnQkFBZ0IsRUFBRSxJQUFJLENBQUNsQixlQUFlLEVBQUUsSUFBSSxDQUFDNFIsZUFBZSxFQUFFelI7SUFDN0c7SUFDQVEsVUFBVXZxRixTQUFTLENBQUMyOEYsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCMzVGLENBQUMsRUFBRW9uRixXQUFXO1FBQ3BGLElBQUl2N0MsTUFBTSxJQUFJLENBQUNxeEMsVUFBVSxDQUFDblosTUFBTSxDQUFDL2pFLEVBQUU0USxhQUFhLElBQUksSUFBSSxDQUFDbW5GLElBQUksQ0FBQzNRLFlBQVksQ0FBQ3ZoQixXQUFXO1FBQ3RGN2xFLEVBQUUrdEMsUUFBUSxHQUFHdkMsV0FBVyxDQUFDNDdDLGFBQWF2N0M7SUFDeEM7SUFDQTA3QyxVQUFVdnFGLFNBQVMsQ0FBQ284RixVQUFVLEdBQUcsU0FBU0EsV0FBWTFuRCxRQUFRO1FBQzVELElBQUlwNkIsU0FBUyxJQUFJO1FBRWpCLElBQUssSUFBSWxULElBQUksSUFBSSxDQUFDMnpGLElBQUksQ0FBQ3JtRCxTQUFTLENBQUM0RixlQUFlLElBQUlsekMsRUFBRW1rQixPQUFPLElBQUs7WUFDaEUsSUFBSXF4RSxZQUFZeDFGLEVBQUVzZ0IsSUFBSTtZQUN0QixJQUFJbTFFLFVBQVV2aUYsT0FBT3EyRCxNQUFNLENBQUN2N0IsT0FBTyxDQUFDd25ELFVBQVVocEYsYUFBYTtZQUMzRGlwRixRQUFRbHBELFFBQVEsQ0FBQ2UsVUFBVWtvRCxVQUFVN3JELFFBQVEsR0FBRzFyQixXQUFXLENBQUNxdkI7UUFDOUQ7SUFDRjtJQUNBNjFDLFVBQVV2cUYsU0FBUyxDQUFDdzhGLG1CQUFtQixHQUFHLFNBQVNBLG9CQUFxQnpTLE1BQU07UUFDNUUsSUFBSyxJQUFJcnZELEtBQUssSUFBSSxDQUFDaTJDLE1BQU0sQ0FBQzUxQixXQUFXLEdBQUcxdkIsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztZQUNqRSxJQUFJK2QsS0FBSzVPLEdBQUdoVCxJQUFJO1lBQ2hCLElBQUlxb0IsUUFBUXpHLEdBQUd5SCxRQUFRO1lBQ3ZCLElBQUloQixNQUFNekIsTUFBTSxNQUFNLENBQUNoRixHQUFHaUQsa0JBQWtCLE1BQU1nK0MsVUFBVUMsWUFBWSxDQUFDejZDLE1BQU0xcUIsV0FBVyxDQUFDLEdBQUdpakIsU0FBU3ZpQixLQUFLLEdBQUdncUIsTUFBTTFxQixXQUFXLENBQUMsR0FBR2lqQixTQUFTdmlCLEtBQUssR0FBR2drRSxTQUFTO2dCQUM1SnpnRCxHQUFHa0QsV0FBVyxDQUFDO1lBQ2pCO1FBQ0Y7SUFDRjtJQUNBKzlDLFVBQVV2cUYsU0FBUyxDQUFDczhGLHVCQUF1QixHQUFHLFNBQVNBO1FBQ3JELElBQUssSUFBSTVoRSxLQUFLLElBQUksQ0FBQ2t0QyxTQUFTLENBQUN2OEMsUUFBUSxJQUFJcVAsR0FBR25QLE9BQU8sSUFBSztZQUN0RCxJQUFJMWlCLElBQUk2eEIsR0FBR2hULElBQUk7WUFDZixJQUFJdW5CLE1BQU1wbUMsRUFBRWtvQyxRQUFRO1lBQ3BCLElBQUk3VSxRQUFRcnpCLEVBQUV5akMsUUFBUTtZQUN0QixJQUFJLENBQUNwUSxNQUFNdGxCLE1BQU0sSUFBSTtnQkFDbkJzbEIsTUFBTXBSLFNBQVM7Z0JBQ2YsSUFBSyxJQUFJMWpCLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO29CQUMxQixJQUFJLENBQUM2bkMsSUFBSXI0QixNQUFNLENBQUN4UCxNQUFNNm5DLElBQUlYLE1BQU0sTUFBTSxDQUFDcFMsTUFBTXRsQixNQUFNLENBQUN4UCxJQUFJO3dCQUN0RCxJQUFJODBCLE1BQU1tekMsUUFBUSxDQUFDam9FLE9BQU8sR0FBRzs0QkFDM0I2bkMsSUFBSVksTUFBTSxDQUFDem9DO3dCQUNiLE9BQU87NEJBQ0xzVyxPQUFPRSxNQUFNLENBQUMsQ0FBQ3NlLE1BQU10bEIsTUFBTSxDQUFDeFAsR0FBR2toQyxTQUFTcmlCLElBQUksR0FBRzs0QkFDL0NncEIsSUFBSVQsV0FBVyxDQUFDcG5DLEdBQUdraEMsU0FBU3JpQixJQUFJLEVBQUVpVyxNQUFNN1csV0FBVyxDQUFDamUsR0FBR2toQyxTQUFTcmlCLElBQUk7NEJBQ3BFdkksT0FBT0UsTUFBTSxDQUFDLENBQUNzZSxNQUFNdGxCLE1BQU0sQ0FBQ3hQLEdBQUdraEMsU0FBU3ZpQixLQUFLLEdBQUc7NEJBQ2hEa3BCLElBQUlULFdBQVcsQ0FBQ3BuQyxHQUFHa2hDLFNBQVN2aUIsS0FBSyxFQUFFbVcsTUFBTTdXLFdBQVcsQ0FBQ2plLEdBQUdraEMsU0FBU3ZpQixLQUFLO3dCQUN4RTtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBd2tFLFVBQVV2cUYsU0FBUyxDQUFDOG9FLGdCQUFnQixHQUFHLFNBQVNBO1FBQzlDLElBQUl4dUQsU0FBUyxJQUFJO1FBRWpCLElBQUssSUFBSWtnQyxTQUFTLElBQUksQ0FBQ20yQixNQUFNLENBQUN2akMsUUFBUSxHQUFHL2hCLFFBQVEsSUFBSW12QixPQUFPanZCLE9BQU8sSUFBSztZQUN0RSxJQUFJMGUsT0FBT3VRLE9BQU85eUIsSUFBSTtZQUN0QnVpQixLQUFLRyxRQUFRLEdBQUcwK0IsZ0JBQWdCLENBQUN4dUQsT0FBT3lnRixJQUFJO1FBQzlDO1FBQ0EsSUFBSSxDQUFDandCLGNBQWM7UUFDbkIsSUFBSSxDQUFDa3hCLG1CQUFtQjtJQUMxQjtJQUNBelIsVUFBVXZxRixTQUFTLENBQUN1OEYsb0JBQW9CLEdBQUcsU0FBU0E7UUFDbEQsSUFBSWppRixTQUFTLElBQUk7UUFFakIsb0JBQW9CO1FBQ3BCLElBQUssSUFBSXdpRixLQUFLLElBQUksQ0FBQ25zQixNQUFNLENBQUN2akMsUUFBUSxHQUFHL2hCLFFBQVEsSUFBSXl4RSxHQUFHdnhFLE9BQU8sSUFBSztZQUM5RCxJQUFJdm9CLElBQUk4NUYsR0FBR3AxRSxJQUFJO1lBQ2YsSUFBSXFvQixRQUFRL3NDLEVBQUUrdEMsUUFBUTtZQUN0QixJQUFJL3RDLEVBQUU0dEMsVUFBVSxJQUFJO2dCQUNsQixjQUFjO2dCQUNkLElBQUliLE1BQU1uNUIsTUFBTSxDQUFDLElBQUk7b0JBQUUwRCxPQUFPcWlGLG1CQUFtQixDQUFDMzVGLEdBQUc7Z0JBQUksT0FBTztvQkFBRXNYLE9BQU9xaUYsbUJBQW1CLENBQUMzNUYsR0FBRztnQkFBSTtZQUN0RztZQUNBQSxFQUFFb25DLFFBQVEsR0FBRzYvQixlQUFlLENBQUNsNkI7UUFDL0I7SUFDRjtJQUNBdzZDLFVBQVV2cUYsU0FBUyxDQUFDeXFGLFlBQVksR0FBRyxTQUFTQSxhQUFjeitELEtBQUs7UUFDN0QsSUFBSSxJQUFJLENBQUN5bkIsU0FBUyxDQUFDem5CLE9BQU8sSUFBSSxDQUFDd3ZFLGVBQWUsR0FBRztZQUFFLE9BQU87UUFBSztRQUMvRCxPQUFPO0lBQ1Q7SUFDQWpSLFVBQVV2cUYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO1FBQ3pDLE9BQU8sRUFBRTtJQUNYO0lBQ0Ewb0YsVUFBVXZxRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7UUFDdEMsT0FBT3lvRjtJQUNUO0lBRUEsT0FBT0E7QUFDVCxFQUFFc1E7QUFFRnRRLFVBQVVnSSxTQUFTLEdBQUcsU0FBVS9zRCxLQUFLLEVBQUV1M0QsS0FBSyxFQUFFaFQsTUFBTTtJQUNsRCxJQUFJaVQsTUFBTSxJQUFJelMsVUFBVS9rRCxPQUFPdTNEO0lBQy9CLElBQUlFLFNBQVNELElBQUlyakIsaUJBQWlCLENBQUNvUTtJQUNuQyxPQUFPa1Q7QUFDVDtBQUNBMVMsVUFBVXA0RSxZQUFZLEdBQUcsU0FBVTBYLENBQUMsRUFBRXJsQixLQUFLO0lBQ3pDLElBQUlxbEIsRUFBRS9QLE9BQU8sTUFBTXRWLE1BQU1zVixPQUFPLElBQUk7UUFBRSxPQUFPeXdFLFVBQVVzUixpQkFBaUIsQ0FBQ3RSLFVBQVVLLFlBQVksRUFBRS9nRSxHQUFHcmxCLE9BQU9xbEIsRUFBRUwsVUFBVTtJQUFJO0lBQzNILElBQUlLLEVBQUVQLG9CQUFvQixJQUFJO1FBQzVCLElBQUltK0MsS0FBS2pqRTtRQUNULE9BQU8ya0YseUJBQXlCaHJFLEdBQUcsQ0FBQzBMLEdBQUc7WUFDckNob0IsYUFBYTtnQkFDWCxPQUFPO29CQUFDcTVGLGVBQWVDLEtBQUs7aUJBQUM7WUFDL0I7WUFDQWg5RSxLQUFLLFNBQVUwTCxDQUFDO2dCQUNkLE9BQU9BLEVBQUUxWCxZQUFZLENBQUNzMUQ7WUFDeEI7UUFDRjtJQUNGO0lBQ0E1OUMsRUFBRWUsMEJBQTBCLENBQUNmO0lBQzdCQSxFQUFFZSwwQkFBMEIsQ0FBQ3BtQjtJQUM3QixPQUFPc3VGLHNCQUFzQlAsU0FBUyxDQUFDMW9FLEdBQUdybEIsT0FBTytsRixVQUFVSyxZQUFZO0FBQ3pFO0FBQ0FMLFVBQVVtSSxhQUFhLEdBQUcsU0FBVTdvRSxDQUFDLEVBQUVybEIsS0FBSztJQUMxQyxJQUFJcWxCLEVBQUUvUCxPQUFPLE1BQU10VixNQUFNc1YsT0FBTyxJQUFJO1FBQ2xDLElBQUkrUCxFQUFFL1AsT0FBTyxNQUFNdFYsTUFBTXNWLE9BQU8sSUFBSTtZQUFFLE9BQU95d0UsVUFBVXNSLGlCQUFpQixDQUFDdFIsVUFBVW9JLGFBQWEsRUFBRTlvRSxHQUFHcmxCLE9BQU9xbEIsRUFBRUwsVUFBVTtRQUFJO1FBQzVILElBQUlLLEVBQUUvUCxPQUFPLElBQUk7WUFBRSxPQUFPdFYsTUFBTVEsSUFBSTtRQUFHO1FBQ3ZDLElBQUlSLE1BQU1zVixPQUFPLElBQUk7WUFBRSxPQUFPK1AsRUFBRTdrQixJQUFJO1FBQUc7SUFDekM7SUFDQTZrQixFQUFFZSwwQkFBMEIsQ0FBQ2Y7SUFDN0JBLEVBQUVlLDBCQUEwQixDQUFDcG1CO0lBQzdCLE9BQU9zdUYsc0JBQXNCUCxTQUFTLENBQUMxb0UsR0FBR3JsQixPQUFPK2xGLFVBQVVvSSxhQUFhO0FBQzFFO0FBQ0FwSSxVQUFVMlMsZUFBZSxHQUFHLFNBQVVuVCxNQUFNLEVBQUUxSixFQUFFLEVBQUVDLEVBQUU7SUFDbEQsSUFBSTZjLE9BQU85YyxHQUFHdnNFLFlBQVk7SUFDMUIsSUFBSXNwRixPQUFPOWMsR0FBR3hzRSxZQUFZO0lBQzFCLElBQUlvcEYsa0JBQWtCLENBQUM7SUFDdkIsT0FBUW5UO1FBQ04sS0FBS1EsVUFBVUssWUFBWTtZQUN6QnNTLGtCQUFrQng4RixLQUFLRSxHQUFHLENBQUN1OEYsTUFBTUM7WUFDakM7UUFDRixLQUFLN1MsVUFBVWtJLEtBQUs7WUFDbEJ5SyxrQkFBa0J4OEYsS0FBS0MsR0FBRyxDQUFDdzhGLE1BQU1DO1lBQ2pDO1FBQ0YsS0FBSzdTLFVBQVVzSSxVQUFVO1lBQ3ZCcUssa0JBQWtCQztZQUNsQjtRQUNGLEtBQUs1UyxVQUFVb0ksYUFBYTtZQUMxQnVLLGtCQUFrQng4RixLQUFLQyxHQUFHLENBQUN3OEYsTUFBTUM7WUFDakM7UUFDRjtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBM1MsVUFBVXNSLGlCQUFpQixHQUFHLFNBQVVJLGFBQWEsRUFBRXoxRixDQUFDLEVBQUVDLENBQUMsRUFBRTQyRixRQUFRO0lBQ25FLElBQUk1M0YsU0FBUztJQUNiLE9BQVE4a0YsVUFBVTJTLGVBQWUsQ0FBQ2pCLGVBQWV6MUYsR0FBR0M7UUFDbEQsS0FBSyxDQUFDO1lBQ0poQixTQUFTNDNGLFNBQVNwZ0Ysd0JBQXdCLENBQUMsSUFBSWxkLE1BQU0sR0FBR00sSUFBSSxDQUFDO1lBQzdEO1FBQ0YsS0FBSztZQUNIb0YsU0FBUzQzRixTQUFTM2hGLFdBQVc7WUFDN0I7UUFDRixLQUFLO1lBQ0hqVyxTQUFTNDNGLFNBQVNsaEYsZ0JBQWdCO1lBQ2xDO1FBQ0YsS0FBSztZQUNIMVcsU0FBUzQzRixTQUFTNWdGLGFBQWE7WUFDL0I7UUFDRjtJQUNGO0lBQ0EsT0FBT2hYO0FBQ1Q7QUFDQThrRixVQUFVcUksVUFBVSxHQUFHLFNBQVUvb0UsQ0FBQyxFQUFFcmxCLEtBQUs7SUFDdkMsSUFBSXFsQixFQUFFL1AsT0FBTyxJQUFJO1FBQUUsT0FBT3l3RSxVQUFVc1IsaUJBQWlCLENBQUN0UixVQUFVc0ksVUFBVSxFQUFFaHBFLEdBQUdybEIsT0FBT3FsQixFQUFFTCxVQUFVO0lBQUk7SUFDdEcsSUFBSWhsQixNQUFNc1YsT0FBTyxJQUFJO1FBQUUsT0FBTytQLEVBQUU3a0IsSUFBSTtJQUFHO0lBQ3ZDNmtCLEVBQUVlLDBCQUEwQixDQUFDZjtJQUM3QkEsRUFBRWUsMEJBQTBCLENBQUNwbUI7SUFDN0IsT0FBT3N1RixzQkFBc0JQLFNBQVMsQ0FBQzFvRSxHQUFHcmxCLE9BQU8rbEYsVUFBVXNJLFVBQVU7QUFDdkU7QUFDQXRJLFVBQVVDLFlBQVksR0FBRztJQUN2QixJQUFJMXBGLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlzdkMsUUFBUWp2QyxTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJaXBGLFNBQVNqcEYsU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSXc4RixPQUFPdnRELE1BQU0xcUIsV0FBVyxDQUFDO1FBQzdCLElBQUlrNEUsT0FBT3h0RCxNQUFNMXFCLFdBQVcsQ0FBQztRQUM3QixPQUFPa2xFLFVBQVVDLFlBQVksQ0FBQzhTLE1BQU1DLE1BQU14VDtJQUM1QyxPQUFPLElBQUlqcEYsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSSs4RixTQUFTMThGLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUkyOEYsU0FBUzM4RixTQUFTLENBQUMsRUFBRTtRQUN6QixJQUFJbTdGLGdCQUFnQm43RixTQUFTLENBQUMsRUFBRTtRQUNoQyxJQUFJMDhGLFdBQVc3MkYsU0FBU0csUUFBUSxFQUFFO1lBQUUwMkYsU0FBUzcyRixTQUFTRSxRQUFRO1FBQUU7UUFDaEUsSUFBSTQyRixXQUFXOTJGLFNBQVNHLFFBQVEsRUFBRTtZQUFFMjJGLFNBQVM5MkYsU0FBU0UsUUFBUTtRQUFFO1FBQ2hFLE9BQVFvMUY7WUFDTixLQUFLMVIsVUFBVUssWUFBWTtnQkFDekIsT0FBTzRTLFdBQVc3MkYsU0FBU0UsUUFBUSxJQUFJNDJGLFdBQVc5MkYsU0FBU0UsUUFBUTtZQUNyRSxLQUFLMGpGLFVBQVVrSSxLQUFLO2dCQUNsQixPQUFPK0ssV0FBVzcyRixTQUFTRSxRQUFRLElBQUk0MkYsV0FBVzkyRixTQUFTRSxRQUFRO1lBQ3JFLEtBQUswakYsVUFBVXNJLFVBQVU7Z0JBQ3ZCLE9BQU8ySyxXQUFXNzJGLFNBQVNFLFFBQVEsSUFBSTQyRixXQUFXOTJGLFNBQVNFLFFBQVE7WUFDckUsS0FBSzBqRixVQUFVb0ksYUFBYTtnQkFDMUIsT0FBTyxXQUFZaHNGLFNBQVNFLFFBQVEsSUFBSTQyRixXQUFXOTJGLFNBQVNFLFFBQVEsSUFBTTIyRixXQUFXNzJGLFNBQVNFLFFBQVEsSUFBSTQyRixXQUFXOTJGLFNBQVNFLFFBQVE7WUFDeEk7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGO0FBQ0EwakYsVUFBVUssWUFBWSxHQUFHO0FBQ3pCTCxVQUFVa0ksS0FBSyxHQUFHO0FBQ2xCbEksVUFBVXNJLFVBQVUsR0FBRztBQUN2QnRJLFVBQVVvSSxhQUFhLEdBQUc7QUFFMUIsSUFBSStLLG9CQUFvQixTQUFTQTtJQUMvQixJQUFJLENBQUNDLEVBQUUsR0FBRztJQUNWLElBQUksQ0FBQ0MsMEJBQTBCLEdBQUc7SUFDbEMsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDM2QsVUFBVSxHQUFHLElBQUkvQjtJQUN0QixJQUFJLENBQUMvYyxJQUFJLEdBQUcsSUFBSTNWO0lBQ2hCLElBQUk1aEMsSUFBSS9vQixTQUFTLENBQUMsRUFBRTtJQUNwQixJQUFJZzlGLDRCQUE0Qmg5RixTQUFTLENBQUMsRUFBRTtJQUM1QyxJQUFJLENBQUM2OEYsRUFBRSxHQUFHOXpFO0lBQ1YsSUFBSSxDQUFDK3pFLDBCQUEwQixHQUFHRTtJQUNsQyxJQUFJLENBQUNELFNBQVMsR0FBRyxJQUFJLENBQUNFLGVBQWUsQ0FBQ2wwRTtBQUN4QztBQUNBNnpFLGtCQUFrQjE5RixTQUFTLENBQUNnK0YsMkJBQTJCLEdBQUcsU0FBU0EsNEJBQTZCbjlFLEVBQUU7SUFDOUYsSUFBSXZHLFNBQVMsSUFBSTtJQUVuQixJQUFLLElBQUlsVCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDeTJGLFNBQVMsQ0FBQ3p6RSxnQkFBZ0IsSUFBSWhqQixJQUFLO1FBQzFELElBQUlrVixPQUFPaEMsT0FBT3VqRixTQUFTLENBQUNwMEUsWUFBWSxDQUFDcmlCO1FBQ3pDLElBQUlpd0IsTUFBTS9hLEtBQUs4aEIscUJBQXFCO1FBQ3BDLElBQUssSUFBSTlTLElBQUksR0FBR0EsSUFBSStMLElBQUkxakIsSUFBSSxLQUFLLEdBQUcyWCxJQUFLO1lBQ3ZDK0wsSUFBSXpqQixhQUFhLENBQUMwWCxHQUFHaFIsT0FBTzhtRCxJQUFJLENBQUM5akQsRUFBRTtZQUNuQytaLElBQUl6akIsYUFBYSxDQUFDMFgsSUFBSSxHQUFHaFIsT0FBTzhtRCxJQUFJLENBQUM3dkQsRUFBRTtZQUN2QyxJQUFJaVAsT0FBT2xHLE9BQU84bUQsSUFBSSxDQUFDNzdELFFBQVEsQ0FBQ3NiO1lBQ2hDLElBQUlMLFFBQVFsRyxPQUFPc2pGLDBCQUEwQixFQUFFO2dCQUFFLE9BQU87WUFBSztRQUMvRDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0FGLGtCQUFrQjE5RixTQUFTLENBQUNxbEIsV0FBVyxHQUFHLFNBQVNBLFlBQWF4RSxFQUFFO0lBQ2hFLElBQUksSUFBSSxDQUFDbTlFLDJCQUEyQixDQUFDbjlFLEtBQUs7UUFBRSxPQUFPbGEsU0FBU0csUUFBUTtJQUFDO0lBQ3JFLE9BQU8sSUFBSSxDQUFDbzVFLFVBQVUsQ0FBQ25aLE1BQU0sQ0FBQ2xtRCxJQUFJLElBQUksQ0FBQzg4RSxFQUFFO0FBQzNDO0FBQ0FELGtCQUFrQjE5RixTQUFTLENBQUMrOUYsZUFBZSxHQUFHLFNBQVNBLGdCQUFpQmwwRSxDQUFDO0lBQ3ZFLElBQUlvMEUsWUFBWSxJQUFJQztJQUNwQnIwRSxFQUFFdFEsS0FBSyxDQUFDMGtGO0lBQ1IsSUFBSUUsV0FBV0YsVUFBVUcsV0FBVztJQUNwQyxJQUFJN2hGLFFBQVE3RCxnQkFBZ0JpdEIsaUJBQWlCLENBQUN3NEQ7SUFDOUMsT0FBT3QwRSxFQUFFTCxVQUFVLEdBQUduTixxQkFBcUIsQ0FBQ0U7QUFDOUM7QUFDQW1oRixrQkFBa0IxOUYsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ2pELE9BQU8sRUFBRTtBQUNYO0FBQ0E2N0Ysa0JBQWtCMTlGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUM5QyxPQUFPNDdGO0FBQ1Q7QUFFQSxJQUFJUSw2QkFBNkIsU0FBU0E7SUFDeEMsSUFBSSxDQUFDTCxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQSxTQUFTLEdBQUcsSUFBSXJ3RTtBQUN2QjtBQUNBMHdFLDJCQUEyQmwrRixTQUFTLENBQUNvK0YsV0FBVyxHQUFHLFNBQVNBO0lBQzFELE9BQU8sSUFBSSxDQUFDUCxTQUFTO0FBQ3ZCO0FBQ0FLLDJCQUEyQmwrRixTQUFTLENBQUNtb0IsTUFBTSxHQUFHLFNBQVNBLE9BQVEwQixDQUFDO0lBQzVELElBQUl2UCxTQUFTLElBQUk7SUFFbkIsSUFBSXVQLGFBQWE2VSxTQUFTO1FBQ3hCLElBQUlZLE9BQU96VjtRQUNYLElBQUksQ0FBQ2cwRSxTQUFTLENBQUM1eEYsR0FBRyxDQUFDcXpCLEtBQUtFLGVBQWU7UUFDdkMsSUFBSyxJQUFJcDRCLElBQUksR0FBR0EsSUFBSWs0QixLQUFLVixrQkFBa0IsSUFBSXgzQixJQUFLO1lBQ2xEa1QsT0FBT3VqRixTQUFTLENBQUM1eEYsR0FBRyxDQUFDcXpCLEtBQUtVLGdCQUFnQixDQUFDNTRCO1FBQzdDO0lBQ0Y7QUFDRjtBQUNBODJGLDJCQUEyQmwrRixTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDMUQsT0FBTztRQUFDczFCO0tBQWU7QUFDekI7QUFDQSttRSwyQkFBMkJsK0YsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ3ZELE9BQU9vOEY7QUFDVDtBQUVBLElBQUlHLHVCQUF1QixTQUFTQTtJQUNsQyxJQUFJLENBQUNWLEVBQUUsR0FBRztJQUNWLElBQUksQ0FBQ1csT0FBTyxHQUFHO0lBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsSUFBSTEwRSxJQUFJL29CLFNBQVMsQ0FBQyxFQUFFO0lBQ3BCLElBQUksQ0FBQzY4RixFQUFFLEdBQUc5ekU7QUFDWjtBQUNBdzBFLHFCQUFxQnIrRixTQUFTLENBQUN3K0YsYUFBYSxHQUFHLFNBQVNBLGNBQWVsaUYsSUFBSSxFQUFFa3hDLGNBQWMsRUFBRWl4QyxTQUFTO0lBQ2xHLElBQUlua0YsU0FBUyxJQUFJO0lBRW5CLElBQUkyTSxNQUFNM0ssS0FBS29iLGNBQWM7SUFDN0IsSUFBSyxJQUFJdHdCLElBQUksR0FBR0EsSUFBSTZmLElBQUl4bUIsTUFBTSxHQUFHLEdBQUcyRyxJQUFLO1FBQ3ZDa1QsT0FBT29rRixtQkFBbUIsQ0FBQ3ozRSxHQUFHLENBQUM3ZixFQUFFLEVBQUU2ZixHQUFHLENBQUM3ZixJQUFJLEVBQUUsRUFBRW9tRCxnQkFBZ0JpeEM7SUFDakU7QUFDRjtBQUNBSixxQkFBcUJyK0YsU0FBUyxDQUFDMitGLGtCQUFrQixHQUFHLFNBQVNBLG1CQUFvQkMsTUFBTSxFQUFFQyxPQUFPO0lBQzlGLElBQUksQ0FBQ1AsT0FBTyxHQUFHTTtJQUNmLElBQUksQ0FBQ0wsUUFBUSxHQUFHTTtBQUNsQjtBQUNBUixxQkFBcUJyK0YsU0FBUyxDQUFDNC9FLFNBQVMsR0FBRyxTQUFTQSxVQUFXcHlCLGNBQWM7SUFDekUsSUFBSWx6QyxTQUFTLElBQUk7SUFFbkIsSUFBSW1rRixZQUFZLElBQUlqeEU7SUFDcEIsSUFBSWpSLFFBQVEyZ0UseUJBQXlCTSxRQUFRLENBQUMsSUFBSSxDQUFDbWdCLEVBQUU7SUFDckQsSUFBSyxJQUFJdjJGLElBQUltVixNQUFNOE8sUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzNDLElBQUlqUCxPQUFPbFYsRUFBRXNnQixJQUFJO1FBQ2pCcE4sT0FBT2trRixhQUFhLENBQUNsaUYsTUFBTWt4QyxnQkFBZ0JpeEM7SUFDN0M7SUFDQSxPQUFPQTtBQUNUO0FBQ0FKLHFCQUFxQnIrRixTQUFTLENBQUMwK0YsbUJBQW1CLEdBQUcsU0FBU0Esb0JBQXFCcGhGLEVBQUUsRUFBRS9MLEVBQUUsRUFBRWk4QyxjQUFjLEVBQUVpeEMsU0FBUztJQUNsSCxJQUFJdDVGLEtBQUtvTSxHQUFHN1AsQ0FBQyxHQUFHNGIsR0FBRzViLENBQUM7SUFDcEIsSUFBSTBELEtBQUttTSxHQUFHNU4sQ0FBQyxHQUFHMlosR0FBRzNaLENBQUM7SUFDcEIsSUFBSXVOLE1BQU14USxLQUFLNEUsSUFBSSxDQUFDSCxLQUFLQSxLQUFLQyxLQUFLQTtJQUNuQyxJQUFJdW9ELEtBQUtILGlCQUFpQnJvRCxLQUFLK0w7SUFDL0IsSUFBSTA4QyxLQUFLSixpQkFBaUJwb0QsS0FBSzhMO0lBQy9CLElBQUk0dEYsT0FBTyxDQUFDdnRGLEdBQUc3UCxDQUFDLEdBQUc0YixHQUFHNWIsQ0FBQyxJQUFJO0lBQzNCLElBQUlxOUYsT0FBTyxDQUFDeHRGLEdBQUc1TixDQUFDLEdBQUcyWixHQUFHM1osQ0FBQyxJQUFJO0lBQzNCLElBQUksSUFBSSxDQUFDMjZGLE9BQU8sRUFBRTtRQUNoQixJQUFJVSxhQUFhLElBQUl0N0YsV0FBV283RixPQUFPbHhDLElBQUlteEMsT0FBT3B4QztRQUNsRDh3QyxVQUFVeHlGLEdBQUcsQ0FBQyt5RjtJQUNoQjtJQUNBLElBQUksSUFBSSxDQUFDVCxRQUFRLEVBQUU7UUFDakIsSUFBSVUsY0FBYyxJQUFJdjdGLFdBQVdvN0YsT0FBT2x4QyxJQUFJbXhDLE9BQU9weEM7UUFDbkQ4d0MsVUFBVXh5RixHQUFHLENBQUNnekY7SUFDaEI7QUFDRjtBQUNBWixxQkFBcUJyK0YsU0FBUyxDQUFDNkIsV0FBVyxHQUFHLFNBQVNBO0lBQ3BELE9BQU8sRUFBRTtBQUNYO0FBQ0F3OEYscUJBQXFCcitGLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNqRCxPQUFPdThGO0FBQ1Q7QUFFQSxJQUFJYSx5QkFBeUIsU0FBU0E7SUFDcEMsSUFBSSxDQUFDNWxFLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQzZsRSxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSXIvRixNQUFNLEdBQUdNLElBQUksQ0FBQztJQUNuQyxJQUFJLENBQUNnL0YsZ0JBQWdCLEdBQUc7SUFDeEIsSUFBSSxDQUFDekIsMEJBQTBCLEdBQUdzQix1QkFBdUJJLFNBQVM7SUFDbEUsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSS94RTtJQUN2QixJQUFJaG5CLElBQUkxRixTQUFTLENBQUMsRUFBRTtJQUNwQixJQUFJMkYsSUFBSTNGLFNBQVMsQ0FBQyxFQUFFO0lBQ3BCLElBQUkyRSxTQUFTM0UsU0FBUyxDQUFDLEVBQUU7SUFDekIsSUFBSSxDQUFDODhGLDBCQUEwQixHQUFHc0IsdUJBQXVCTSxnQ0FBZ0MsQ0FBQ2g1RixHQUFHQztJQUM3RixJQUFJLENBQUM2eUIsS0FBSyxHQUFHO1FBQUM5eUI7UUFBR0M7UUFBR2hCO0tBQU87SUFDM0IsSUFBSSxDQUFDMDVGLFVBQVUsR0FBRztRQUFDLElBQUl6QixrQkFBa0IsSUFBSSxDQUFDcGtFLEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDc2tFLDBCQUEwQjtRQUFHLElBQUlGLGtCQUFrQixJQUFJLENBQUNwa0UsS0FBSyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNza0UsMEJBQTBCO1FBQUcsSUFBSUYsa0JBQWtCLElBQUksQ0FBQ3BrRSxLQUFLLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ3NrRSwwQkFBMEI7S0FBRTtBQUN6TztBQUVBLElBQUk2QixxQkFBcUI7SUFBRUgsV0FBVztRQUFFbi9GLGNBQWM7SUFBSztBQUFFO0FBQzdEKytGLHVCQUF1QmwvRixTQUFTLENBQUMwL0YsWUFBWSxHQUFHLFNBQVNBLGFBQWNuTixTQUFTLEVBQUVobEQsUUFBUSxFQUFFb3lELGdCQUFnQjtJQUMxR3ByRixPQUFPbU8sR0FBRyxDQUFDQyxPQUFPLENBQUMsZ0NBQWdDaGMsU0FBU00sZ0JBQWdCLENBQUNzbUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxRQUFRNW1DLFNBQVNNLGdCQUFnQixDQUFDc21DLFFBQVEsQ0FBQyxFQUFFLElBQUksZUFBZ0JveUQsQ0FBQUEsbUJBQW1CLE1BQU0sR0FBRSxJQUFLLGFBQWFoNUYsU0FBU00sZ0JBQWdCLENBQUNzbUMsUUFBUSxDQUFDLEVBQUU7QUFDalA7QUFDQTJ4RCx1QkFBdUJsL0YsU0FBUyxDQUFDbWdDLE9BQU8sR0FBRyxTQUFTQSxRQUFTb3lELFNBQVM7SUFDcEUsSUFBSSxDQUFDcU4sVUFBVSxDQUFDLElBQUksQ0FBQ3RtRSxLQUFLLENBQUMsRUFBRTtJQUM3QixJQUFJLENBQUNzbUUsVUFBVSxDQUFDLElBQUksQ0FBQ3RtRSxLQUFLLENBQUMsRUFBRTtJQUM3QixJQUFJNkcsVUFBVSxJQUFJLENBQUNtMEMsVUFBVSxDQUFDaWU7SUFDOUIsT0FBT3B5RDtBQUNUO0FBQ0ErK0QsdUJBQXVCbC9GLFNBQVMsQ0FBQ3MwRSxVQUFVLEdBQUcsU0FBU0E7SUFDbkQsSUFBSWg2RCxTQUFTLElBQUk7SUFFbkIsSUFBSXhaLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUk4eEYsWUFBWXp4RixTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFLLElBQUlzRyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDbTRGLFdBQVcsQ0FBQzVyRixJQUFJLElBQUl2TSxJQUFLO1lBQ2hELElBQUl5WixLQUFLdkcsT0FBT2lsRixXQUFXLENBQUNuOEYsR0FBRyxDQUFDZ0U7WUFDaEMsSUFBSSxDQUFDa1QsT0FBT2c2RCxVQUFVLENBQUNpZSxXQUFXMXhFLEtBQUs7Z0JBQ3JDdkcsT0FBTytrRixnQkFBZ0IsR0FBR3grRTtnQkFDMUIsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsT0FBTyxJQUFJL2YsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSW8vRixjQUFjLytGLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLElBQUkyNkUsT0FBTzM2RSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJLENBQUNzK0YsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNELFVBQVUsQ0FBQyxFQUFFLENBQUM5NUUsV0FBVyxDQUFDbzJEO1FBQ25ELElBQUksQ0FBQzJqQixTQUFTLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0QsVUFBVSxDQUFDLEVBQUUsQ0FBQzk1RSxXQUFXLENBQUNvMkQ7UUFDbkQsSUFBSSxDQUFDMmpCLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDRCxVQUFVLENBQUMsRUFBRSxDQUFDOTVFLFdBQVcsQ0FBQ28yRDtRQUNuRCxJQUFJeWpCLHVCQUF1QlksV0FBVyxDQUFDLElBQUksQ0FBQ1YsU0FBUyxFQUFFejRGLFNBQVNHLFFBQVEsR0FBRztZQUFFLE9BQU87UUFBSztRQUN6RixPQUFPLElBQUksQ0FBQ2k1RixhQUFhLENBQUNGLGFBQWEsSUFBSSxDQUFDVCxTQUFTO0lBQ3ZEO0FBQ0Y7QUFDQUYsdUJBQXVCbC9GLFNBQVMsQ0FBQzQvRixVQUFVLEdBQUcsU0FBU0EsV0FBWS8xRSxDQUFDO0lBQ2xFLElBQUltMkUsUUFBUSxJQUFJM0IscUJBQXFCeDBFO0lBQ3JDLElBQUksQ0FBQzAxRSxXQUFXLENBQUN4eUUsTUFBTSxDQUFDaXpFLE1BQU1wZ0IsU0FBUyxDQUFDLElBQUksSUFBSSxDQUFDZ2UsMEJBQTBCO0FBQzdFO0FBQ0FzQix1QkFBdUJsL0YsU0FBUyxDQUFDKy9GLGFBQWEsR0FBRyxTQUFTQSxjQUFleE4sU0FBUyxFQUFFaGxELFFBQVE7SUFDMUYsSUFBSW95RCxtQkFBbUJwVixVQUFVQyxZQUFZLENBQUNqOUMsUUFBUSxDQUFDLEVBQUUsRUFBRUEsUUFBUSxDQUFDLEVBQUUsRUFBRWdsRDtJQUN4RSxJQUFJME4sbUJBQW1CMXlELFFBQVEsQ0FBQyxFQUFFLEtBQUs1bUMsU0FBU0UsUUFBUTtJQUN4RCxJQUFJczVCLFVBQVUsQ0FBRXcvRCxDQUFBQSxtQkFBbUJNLGdCQUFlO0lBQ2xELElBQUksQ0FBQzkvRCxTQUFTO1FBQUUsSUFBSSxDQUFDdS9ELFlBQVksQ0FBQ25OLFdBQVdobEQsVUFBVW95RDtJQUFtQjtJQUMxRSxPQUFPeC9EO0FBQ1Q7QUFDQSsrRCx1QkFBdUJsL0YsU0FBUyxDQUFDa2dHLGtCQUFrQixHQUFHLFNBQVNBO0lBQzdELE9BQU8sSUFBSSxDQUFDYixnQkFBZ0I7QUFDOUI7QUFDQUgsdUJBQXVCbC9GLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUN0RCxPQUFPLEVBQUU7QUFDWDtBQUNBcTlGLHVCQUF1QmwvRixTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDbkQsT0FBT285RjtBQUNUO0FBQ0FBLHVCQUF1QlksV0FBVyxHQUFHLFNBQVNBLFlBQWF2eUQsUUFBUSxFQUFFc0IsR0FBRztJQUN0RSxJQUFLLElBQUl6bkMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDMUIsSUFBSW1tQyxRQUFRLENBQUNubUMsRUFBRSxLQUFLeW5DLEtBQUs7WUFBRSxPQUFPO1FBQUs7SUFDekM7SUFDQSxPQUFPO0FBQ1Q7QUFDQXF3RCx1QkFBdUJNLGdDQUFnQyxHQUFHLFNBQVNBLGlDQUFrQ25mLEVBQUUsRUFBRUMsRUFBRTtJQUN6RyxPQUFPNS9FLEtBQUtFLEdBQUcsQ0FBQ2d0RixnQkFBZ0JzQiw2QkFBNkIsQ0FBQzdPLEtBQUt1TixnQkFBZ0JzQiw2QkFBNkIsQ0FBQzVPO0FBQ25IO0FBQ0E0ZSx1QkFBdUIvK0QsT0FBTyxHQUFHLFNBQVNBLFFBQVMzNUIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU4ckYsU0FBUyxFQUFFOXNGLE1BQU07SUFDeEUsSUFBSTBoRixZQUFZLElBQUkrWCx1QkFBdUIxNEYsR0FBR0MsR0FBR2hCO0lBQ2pELE9BQU8waEYsVUFBVWhuRCxPQUFPLENBQUNveUQ7QUFDM0I7QUFDQWtOLG1CQUFtQkgsU0FBUyxDQUFDbDhGLEdBQUcsR0FBRztJQUFjLE9BQU87QUFBUztBQUVqRW5ELE9BQU9vRCxnQkFBZ0IsQ0FBRTY3Rix3QkFBd0JPO0FBRWpELG9CQUFvQjtBQUVwQixJQUFJVSxtQkFBbUIsU0FBU0EsaUJBQWtCemlCLEtBQUs7SUFDckQsSUFBSSxDQUFDMGlCLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNsQixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNGLFlBQVksR0FBR0QsaUJBQWlCSSxjQUFjLENBQUM3aUI7SUFDcEQsSUFBSSxDQUFDNGlCLFdBQVcsR0FBRzVpQjtBQUNyQjtBQUNBeWlCLGlCQUFpQm5nRyxTQUFTLENBQUN3Z0csZUFBZSxHQUFHLFNBQVNBLGdCQUFpQnA0RSxJQUFJLEVBQUVxNEUsS0FBSztJQUM5RSxJQUFJbm1GLFNBQVMsSUFBSTtJQUVuQixJQUFJOE4sU0FBUyxNQUFNO1FBQUUsT0FBTztJQUFLO0lBQ2pDLElBQUssSUFBSWhoQixJQUFJLEdBQUdBLElBQUlnaEIsS0FBS2dDLGdCQUFnQixJQUFJaGpCLElBQUs7UUFDaEQsSUFBSXM1RixXQUFXdDRFLEtBQUtxQixZQUFZLENBQUNyaUI7UUFDakMsSUFBSWtULE9BQU8rbEYsVUFBVSxJQUFJSyxTQUFTNW1GLE9BQU8sSUFBSTtZQUFFO1FBQVM7UUFDeEQybUYsTUFBTXgwRixHQUFHLENBQUN5MEY7SUFDWjtBQUNGO0FBQ0FQLGlCQUFpQm5nRyxTQUFTLENBQUMyZ0csT0FBTyxHQUFHLFNBQVNBO0lBQzFDLElBQUlybUYsU0FBUyxJQUFJO0lBRW5CLElBQUltbUYsUUFBUSxJQUFJanpFO0lBQ2hCLElBQUssSUFBSXBtQixJQUFJLElBQUksQ0FBQ2s1RixXQUFXLENBQUNqMUUsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQ3RELElBQUkxQixJQUFJemlCLEVBQUVzZ0IsSUFBSTtRQUNkcE4sT0FBT2ttRixlQUFlLENBQUMzMkUsR0FBRzQyRTtJQUM1QjtJQUNBLElBQUlBLE1BQU05c0YsSUFBSSxPQUFPLEdBQUc7UUFDdEIsSUFBSSxJQUFJLENBQUN5c0YsWUFBWSxLQUFLLE1BQU07WUFDOUIsT0FBTyxJQUFJLENBQUNBLFlBQVksQ0FBQ25qRix3QkFBd0IsQ0FBQztRQUNwRDtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU8sSUFBSSxDQUFDbWpGLFlBQVksQ0FBQ243RCxhQUFhLENBQUN3N0Q7QUFDekM7QUFDQU4saUJBQWlCbmdHLFNBQVMsQ0FBQzZCLFdBQVcsR0FBRyxTQUFTQTtJQUNoRCxPQUFPLEVBQUU7QUFDWDtBQUNBcytGLGlCQUFpQm5nRyxTQUFTLENBQUM4QixRQUFRLEdBQUcsU0FBU0E7SUFDN0MsT0FBT3ErRjtBQUNUO0FBQ0FBLGlCQUFpQlEsT0FBTyxHQUFHLFNBQVNBO0lBQ2xDLElBQUk3L0YsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSWk5RSxRQUFRNThFLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUk4L0YsV0FBVyxJQUFJVCxpQkFBaUJ6aUI7UUFDcEMsT0FBT2tqQixTQUFTRCxPQUFPO0lBQ3pCLE9BQU8sSUFBSTcvRixVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJNC9FLEtBQUt2L0UsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXcvRSxLQUFLeC9FLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCLElBQUkrL0YsYUFBYSxJQUFJVixpQkFBaUJBLGlCQUFpQlcsVUFBVSxDQUFDemdCLElBQUlDO1FBQ3RFLE9BQU91Z0IsV0FBV0YsT0FBTztJQUMzQixPQUFPLElBQUk3L0YsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSTgvRSxPQUFPei9FLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLElBQUkwL0UsT0FBTzEvRSxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJMm1FLEtBQUszbUUsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSWlnRyxhQUFhLElBQUlaLGlCQUFpQkEsaUJBQWlCVyxVQUFVLENBQUN2Z0IsTUFBTUMsTUFBTS9ZO1FBQzlFLE9BQU9zNUIsV0FBV0osT0FBTztJQUMzQjtBQUNGO0FBQ0FSLGlCQUFpQkksY0FBYyxHQUFHLFNBQVNBLGVBQWdCN2lCLEtBQUs7SUFDOUQsSUFBSUEsTUFBTTVqRSxPQUFPLElBQUk7UUFBRSxPQUFPO0lBQUs7SUFDbkMsT0FBTzRqRSxNQUFNcnlELFFBQVEsR0FBRzNELElBQUksR0FBRzhCLFVBQVU7QUFDM0M7QUFDQTIyRSxpQkFBaUJXLFVBQVUsR0FBRyxTQUFTQTtJQUNyQyxJQUFJaGdHLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUl1Z0csT0FBT2xnRyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJbWdHLE9BQU9uZ0csU0FBUyxDQUFDLEVBQUU7UUFDdkIsSUFBSTR3RCxPQUFPLElBQUlsa0M7UUFDZmtrQyxLQUFLemxELEdBQUcsQ0FBQyswRjtRQUNUdHZDLEtBQUt6bEQsR0FBRyxDQUFDZzFGO1FBQ1QsT0FBT3Z2QztJQUNULE9BQU8sSUFBSTV3RCxVQUFVTCxNQUFNLEtBQUssR0FBRztRQUNqQyxJQUFJeWdHLFNBQVNwZ0csU0FBUyxDQUFDLEVBQUU7UUFDekIsSUFBSXFnRyxTQUFTcmdHLFNBQVMsQ0FBQyxFQUFFO1FBQ3pCLElBQUlzZ0csT0FBT3RnRyxTQUFTLENBQUMsRUFBRTtRQUN2QixJQUFJdWdHLFNBQVMsSUFBSTd6RTtRQUNqQjZ6RSxPQUFPcDFGLEdBQUcsQ0FBQ2kxRjtRQUNYRyxPQUFPcDFGLEdBQUcsQ0FBQ2sxRjtRQUNYRSxPQUFPcDFGLEdBQUcsQ0FBQ20xRjtRQUNYLE9BQU9DO0lBQ1Q7QUFDRjtBQUVBLElBQUlDLHVCQUF1QixTQUFTQTtJQUNsQyxJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNuQixZQUFZLEdBQUc7SUFDcEIsSUFBSXJmLFFBQVFqZ0YsU0FBUyxDQUFDLEVBQUU7SUFDeEIsSUFBSSxDQUFDeWdHLFdBQVcsR0FBR3hnQjtJQUNuQixJQUFJLElBQUksQ0FBQ3dnQixXQUFXLEtBQUssTUFBTTtRQUFFLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUkvekU7SUFBYTtBQUN2RTtBQUVBLElBQUlnMEUscUJBQXFCO0lBQUVDLHVCQUF1QjtRQUFFdGhHLGNBQWM7SUFBSztBQUFFO0FBQ3pFbWhHLHFCQUFxQnRoRyxTQUFTLENBQUMwaEcsa0JBQWtCLEdBQUcsU0FBU0EsbUJBQW9CQyxRQUFRO0lBQ3JGLElBQUlybkYsU0FBUyxJQUFJO0lBRW5CLElBQUlvakUsUUFBUSxJQUFJbHdEO0lBQ2hCLElBQUssSUFBSXBtQixJQUFJdTZGLFNBQVN0MkUsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzlDLElBQUl6bUIsSUFBSXNDLEVBQUVzZ0IsSUFBSTtRQUNkLElBQUlVLE9BQU87UUFDWCxJQUFJamhCLGFBQWFyQyxHQUFHc29CLE9BQU87WUFDekJoRixPQUFPOU4sT0FBT3NuRixTQUFTLENBQUM5OEY7UUFDMUIsT0FBTyxJQUFJQSxhQUFhdWpCLFVBQVU7WUFDaENELE9BQU90akI7UUFDVDtRQUNBNDRFLE1BQU16eEUsR0FBRyxDQUFDbWM7SUFDWjtJQUNBLE9BQU9zMUQ7QUFDVDtBQUNBNGpCLHFCQUFxQnRoRyxTQUFTLENBQUM2aEcsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQW1CNXRGLEdBQUcsRUFBRW1VLElBQUksRUFBRTA1RSxhQUFhO0lBQ3JHLElBQUlDLG9CQUFvQixJQUFJdjBFO0lBQzVCLElBQUssSUFBSXBtQixJQUFJLEdBQUdBLElBQUlnaEIsS0FBS2dDLGdCQUFnQixJQUFJaGpCLElBQUs7UUFDaEQsSUFBSTQ2RixPQUFPNTVFLEtBQUtxQixZQUFZLENBQUNyaUI7UUFDN0IsSUFBSTQ2RixLQUFLcjNFLG1CQUFtQixHQUFHMVQsVUFBVSxDQUFDaEQsTUFBTTtZQUFFOHRGLGtCQUFrQjkxRixHQUFHLENBQUMrMUY7UUFBTyxPQUFPO1lBQUVGLGNBQWM3MUYsR0FBRyxDQUFDKzFGO1FBQU87SUFDbkg7SUFDQSxPQUFPLElBQUksQ0FBQzVCLFlBQVksQ0FBQ243RCxhQUFhLENBQUM4OEQ7QUFDekM7QUFDQVQscUJBQXFCdGhHLFNBQVMsQ0FBQ2lpRyxjQUFjLEdBQUcsU0FBU0EsZUFBZ0I1aEIsRUFBRSxFQUFFQyxFQUFFO0lBQzdFLElBQUk0aEIsUUFBUTdoQixHQUFHMTFELG1CQUFtQjtJQUNsQyxJQUFJdzNFLFFBQVE3aEIsR0FBRzMxRCxtQkFBbUI7SUFDbEMsSUFBSSxDQUFDdTNFLE1BQU1qckYsVUFBVSxDQUFDa3JGLFFBQVE7UUFDNUIsSUFBSUMsUUFBUWpDLGlCQUFpQlEsT0FBTyxDQUFDdGdCLElBQUlDO1FBQ3pDLE9BQU84aEI7SUFDVDtJQUNBLElBQUkvaEIsR0FBR2oyRCxnQkFBZ0IsTUFBTSxLQUFLazJELEdBQUdsMkQsZ0JBQWdCLE1BQU0sR0FBRztRQUFFLE9BQU8sSUFBSSxDQUFDaTRFLFdBQVcsQ0FBQ2hpQixJQUFJQztJQUFJO0lBQ2hHLElBQUlnaUIsWUFBWUosTUFBTS92RixZQUFZLENBQUNnd0Y7SUFDbkMsT0FBTyxJQUFJLENBQUNJLDhCQUE4QixDQUFDbGlCLElBQUlDLElBQUlnaUI7QUFDckQ7QUFDQWhCLHFCQUFxQnRoRyxTQUFTLENBQUN3eUYsS0FBSyxHQUFHLFNBQVNBO0lBQzlDLElBQUksSUFBSSxDQUFDK08sV0FBVyxLQUFLLE1BQU07UUFBRSxNQUFNLElBQUlsL0YsTUFBTTtJQUF5QztJQUMxRixJQUFJLElBQUksQ0FBQ2svRixXQUFXLENBQUN6bkYsT0FBTyxJQUFJO1FBQUUsT0FBTztJQUFLO0lBQzlDLElBQUksQ0FBQ3NtRixZQUFZLEdBQUcsSUFBSSxDQUFDbUIsV0FBVyxDQUFDbDJFLFFBQVEsR0FBRzNELElBQUksR0FBRzhCLFVBQVU7SUFDakUsSUFBSW5oQixRQUFRLElBQUk4N0MsUUFBUW05QyxxQkFBcUJHLHFCQUFxQjtJQUNsRSxJQUFLLElBQUlyNkYsSUFBSSxJQUFJLENBQUNtNkYsV0FBVyxDQUFDbDJFLFFBQVEsSUFBSWprQixFQUFFbWtCLE9BQU8sSUFBSztRQUN0RCxJQUFJc3lCLE9BQU96MkMsRUFBRXNnQixJQUFJO1FBQ2pCcmYsTUFBTXdzQyxNQUFNLENBQUNnSixLQUFLbHpCLG1CQUFtQixJQUFJa3pCO0lBQzNDO0lBQ0EsSUFBSSxDQUFDMGpELFdBQVcsR0FBRztJQUNuQixJQUFJaUIsV0FBV242RixNQUFNeTVDLFNBQVM7SUFDOUIsSUFBSTJnRCxXQUFXLElBQUksQ0FBQ2IsU0FBUyxDQUFDWTtJQUM5QixPQUFPQztBQUNUO0FBQ0FuQixxQkFBcUJ0aEcsU0FBUyxDQUFDMGlHLFdBQVcsR0FBRyxTQUFTQTtJQUNwRCxJQUFJNWhHLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQzFCLElBQUlpOUUsUUFBUTU4RSxTQUFTLENBQUMsRUFBRTtRQUN4QixPQUFPLElBQUksQ0FBQzRoRyxXQUFXLENBQUNobEIsT0FBTyxHQUFHQSxNQUFNL3BFLElBQUk7SUFDOUMsT0FBTyxJQUFJN1MsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDakMsSUFBSW85RSxVQUFVLzhFLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLElBQUk2dUIsUUFBUTd1QixTQUFTLENBQUMsRUFBRTtRQUN4QixJQUFJOHVCLE1BQU05dUIsU0FBUyxDQUFDLEVBQUU7UUFDdEIsSUFBSTh1QixNQUFNRCxTQUFTLEdBQUc7WUFDcEIsSUFBSTB3RCxLQUFLaWhCLHFCQUFxQno0QixXQUFXLENBQUNnVixTQUFTbHVEO1lBQ25ELE9BQU8sSUFBSSxDQUFDZ3pFLFNBQVMsQ0FBQ3RpQixJQUFJO1FBQzVCLE9BQU8sSUFBSXp3RCxNQUFNRCxVQUFVLEdBQUc7WUFDNUIsT0FBTyxJQUFJLENBQUNnekUsU0FBUyxDQUFDckIscUJBQXFCejRCLFdBQVcsQ0FBQ2dWLFNBQVNsdUQsUUFBUTJ4RSxxQkFBcUJ6NEIsV0FBVyxDQUFDZ1YsU0FBU2x1RCxRQUFRO1FBQzVILE9BQU87WUFDTCxJQUFJeUIsTUFBTTF3QixLQUFLZSxLQUFLLENBQUMsQ0FBQ211QixNQUFNRCxLQUFJLElBQUs7WUFDckMsSUFBSTR3RCxPQUFPLElBQUksQ0FBQ21pQixXQUFXLENBQUM3a0IsU0FBU2x1RCxPQUFPeUI7WUFDNUMsSUFBSWt2RCxLQUFLLElBQUksQ0FBQ29pQixXQUFXLENBQUM3a0IsU0FBU3pzRCxLQUFLeEI7WUFDeEMsT0FBTyxJQUFJLENBQUMreUUsU0FBUyxDQUFDcGlCLE1BQU1EO1FBQzlCO0lBQ0Y7QUFDRjtBQUNBZ2hCLHFCQUFxQnRoRyxTQUFTLENBQUM0aUcsYUFBYSxHQUFHLFNBQVNBLGNBQWVsbEIsS0FBSztJQUMxRSxJQUFJOFUsUUFBUTtJQUNaLElBQUssSUFBSXByRixJQUFJczJFLE1BQU1yeUQsUUFBUSxJQUFJamtCLEVBQUVta0IsT0FBTyxJQUFLO1FBQzNDLElBQUkxQixJQUFJemlCLEVBQUVzZ0IsSUFBSTtRQUNkLElBQUk4cUUsVUFBVSxNQUFNO1lBQUVBLFFBQVEzb0UsRUFBRTdrQixJQUFJO1FBQUksT0FBTztZQUFFd3RGLFFBQVFBLE1BQU1BLEtBQUssQ0FBQzNvRTtRQUFJO0lBQzNFO0lBQ0EsT0FBTzJvRTtBQUNUO0FBQ0E4TyxxQkFBcUJ0aEcsU0FBUyxDQUFDMmlHLFNBQVMsR0FBRyxTQUFTQSxVQUFXdGlCLEVBQUUsRUFBRUMsRUFBRTtJQUNuRSxJQUFJRCxPQUFPLFFBQVFDLE9BQU8sTUFBTTtRQUFFLE9BQU87SUFBSztJQUM5QyxJQUFJRCxPQUFPLE1BQU07UUFBRSxPQUFPQyxHQUFHdDdFLElBQUk7SUFBRztJQUNwQyxJQUFJczdFLE9BQU8sTUFBTTtRQUFFLE9BQU9ELEdBQUdyN0UsSUFBSTtJQUFHO0lBQ3BDLE9BQU8sSUFBSSxDQUFDaTlGLGNBQWMsQ0FBQzVoQixJQUFJQztBQUNqQztBQUNBZ2hCLHFCQUFxQnRoRyxTQUFTLENBQUNxaUcsV0FBVyxHQUFHLFNBQVNBLFlBQWFoaUIsRUFBRSxFQUFFQyxFQUFFO0lBQ3ZFLE9BQU9naEIscUJBQXFCdUIsa0JBQWtCLENBQUN4aUIsR0FBR21TLEtBQUssQ0FBQ2xTO0FBQzFEO0FBQ0FnaEIscUJBQXFCdGhHLFNBQVMsQ0FBQzRoRyxTQUFTLEdBQUcsU0FBU0EsVUFBV0QsUUFBUTtJQUNyRSxJQUFJamtCLFFBQVEsSUFBSSxDQUFDZ2tCLGtCQUFrQixDQUFDQztJQUNwQyxJQUFJblAsUUFBUSxJQUFJLENBQUNrUSxXQUFXLENBQUNobEI7SUFDN0IsT0FBTzhVO0FBQ1Q7QUFDQThPLHFCQUFxQnRoRyxTQUFTLENBQUN1aUcsOEJBQThCLEdBQUcsU0FBU0EsK0JBQWdDbGlCLEVBQUUsRUFBRUMsRUFBRSxFQUFFd2lCLE1BQU07SUFDckgsSUFBSUMsZ0JBQWdCLElBQUl2MUU7SUFDeEIsSUFBSXcxRSxRQUFRLElBQUksQ0FBQ25CLGlCQUFpQixDQUFDaUIsUUFBUXppQixJQUFJMGlCO0lBQy9DLElBQUlFLFFBQVEsSUFBSSxDQUFDcEIsaUJBQWlCLENBQUNpQixRQUFReGlCLElBQUl5aUI7SUFDL0MsSUFBSXZRLFFBQVEsSUFBSSxDQUFDNlAsV0FBVyxDQUFDVyxPQUFPQztJQUNwQ0YsY0FBYzkyRixHQUFHLENBQUN1bUY7SUFDbEIsSUFBSTBRLGVBQWUvQyxpQkFBaUJRLE9BQU8sQ0FBQ29DO0lBQzVDLE9BQU9HO0FBQ1Q7QUFDQTVCLHFCQUFxQnRoRyxTQUFTLENBQUNtakcsV0FBVyxHQUFHLFNBQVNBO0lBQ3BELElBQUlyaUcsVUFBVUwsTUFBTSxLQUFLLEdBQUc7UUFDMUIsSUFBSWk5RSxRQUFRNThFLFNBQVMsQ0FBQyxFQUFFO1FBQ3hCLElBQUl3bkIsVUFBVW8xRCxNQUFNdDZFLEdBQUcsQ0FBQyxHQUFHb21CLFVBQVU7UUFDckMsSUFBSTQ1RSxRQUFROTZFLFFBQVEyYyxhQUFhLENBQUN5NEM7UUFDbEMsSUFBSStrQixXQUFXVyxNQUFNcnhCLE1BQU0sQ0FBQztRQUM1QixPQUFPMHdCO0lBQ1QsT0FBTyxJQUFJM2hHLFVBQVVMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLElBQUk0L0UsS0FBS3YvRSxTQUFTLENBQUMsRUFBRTtRQUNyQixJQUFJdy9FLEtBQUt4L0UsU0FBUyxDQUFDLEVBQUU7UUFDckIsSUFBSXVpRyxZQUFZaGpCLEdBQUc3MkQsVUFBVTtRQUM3QixJQUFJODVFLFVBQVVELFVBQVVwbUYsd0JBQXdCLENBQUM7WUFBQ29qRTtZQUFJQztTQUFHO1FBQ3pELElBQUlpakIsYUFBYUQsUUFBUXZ4QixNQUFNLENBQUM7UUFDaEMsT0FBT3d4QjtJQUNUO0FBQ0Y7QUFDQWpDLHFCQUFxQnRoRyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDcEQsT0FBTyxFQUFFO0FBQ1g7QUFDQXkvRixxQkFBcUJ0aEcsU0FBUyxDQUFDOEIsUUFBUSxHQUFHLFNBQVNBO0lBQ2pELE9BQU93L0Y7QUFDVDtBQUNBQSxxQkFBcUJ1QixrQkFBa0IsR0FBRyxTQUFTQSxtQkFBb0JoNUUsQ0FBQztJQUN0RSxJQUFJMWlCLGFBQWEwaUIsR0FBRzRVLFlBQVk7UUFDOUIsT0FBTzVVO0lBQ1Q7SUFDQSxJQUFJOU0sV0FBV2dnRSxpQkFBaUJuZ0MsV0FBVyxDQUFDL3lCO0lBQzVDLElBQUk5TSxTQUFTcEosSUFBSSxPQUFPLEdBQUc7UUFBRSxPQUFPb0osU0FBUzNaLEdBQUcsQ0FBQztJQUFHO0lBQ3BELE9BQU95bUIsRUFBRUwsVUFBVSxHQUFHMU0sa0JBQWtCLENBQUNwRSxnQkFBZ0JndEIsY0FBYyxDQUFDM29CO0FBQzFFO0FBQ0F1a0YscUJBQXFCejRCLFdBQVcsR0FBRyxTQUFTQSxZQUFhblgsSUFBSSxFQUFFcnBELEtBQUs7SUFDbEUsSUFBSUEsU0FBU3FwRCxLQUFLLzlDLElBQUksSUFBSTtRQUFFLE9BQU87SUFBSztJQUN4QyxPQUFPKzlDLEtBQUt0dUQsR0FBRyxDQUFDaUY7QUFDbEI7QUFDQWk1RixxQkFBcUI5TyxLQUFLLEdBQUcsU0FBU0EsTUFBT3pSLEtBQUs7SUFDaEQsSUFBSXdJLEtBQUssSUFBSStYLHFCQUFxQnZnQjtJQUNsQyxPQUFPd0ksR0FBR2lKLEtBQUs7QUFDakI7QUFDQWdQLG1CQUFtQkMscUJBQXFCLENBQUNyK0YsR0FBRyxHQUFHO0lBQWMsT0FBTztBQUFFO0FBRXRFbkQsT0FBT29ELGdCQUFnQixDQUFFaStGLHNCQUFzQkU7QUFFL0MsSUFBSWdDLFVBQVUsU0FBU0EsV0FBWTtBQUVuQ0EsUUFBUXhqRyxTQUFTLENBQUM2QixXQUFXLEdBQUcsU0FBU0E7SUFDdkMsT0FBTyxFQUFFO0FBQ1g7QUFDQTJoRyxRQUFReGpHLFNBQVMsQ0FBQzhCLFFBQVEsR0FBRyxTQUFTQTtJQUNwQyxPQUFPMGhHO0FBQ1Q7QUFDQUEsUUFBUWhSLEtBQUssR0FBRyxTQUFTQSxNQUFPM29FLENBQUMsRUFBRXJsQixLQUFLO0lBQ3RDLElBQUlxbEIsRUFBRS9QLE9BQU8sTUFBTXRWLE1BQU1zVixPQUFPLElBQUk7UUFDbEMsSUFBSStQLEVBQUUvUCxPQUFPLE1BQU10VixNQUFNc1YsT0FBTyxJQUFJO1lBQUUsT0FBT3l3RSxVQUFVc1IsaUJBQWlCLENBQUN0UixVQUFVa0ksS0FBSyxFQUFFNW9FLEdBQUdybEIsT0FBT3FsQixFQUFFTCxVQUFVO1FBQUk7UUFDcEgsSUFBSUssRUFBRS9QLE9BQU8sSUFBSTtZQUFFLE9BQU90VixNQUFNUSxJQUFJO1FBQUc7UUFDdkMsSUFBSVIsTUFBTXNWLE9BQU8sSUFBSTtZQUFFLE9BQU8rUCxFQUFFN2tCLElBQUk7UUFBRztJQUN6QztJQUNBNmtCLEVBQUVlLDBCQUEwQixDQUFDZjtJQUM3QkEsRUFBRWUsMEJBQTBCLENBQUNwbUI7SUFDN0IsT0FBT3N1RixzQkFBc0JQLFNBQVMsQ0FBQzFvRSxHQUFHcmxCLE9BQU8rbEYsVUFBVWtJLEtBQUs7QUFDbEU7QUFFQSxrQkFBa0I7QUFFbEIsWUFBWTtBQUVaOztDQUVDLEdBRXFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdjMtYXBwLy4vbm9kZV9tb2R1bGVzL3R1cmYtanN0cy9qc3RzLm1qcz9iMzExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFBvbHlmaWxsIHNlcnZpY2UgdjMuMTMuMFxuICogRm9yIGRldGFpbGVkIGNyZWRpdHMgYW5kIGxpY2VuY2UgaW5mb3JtYXRpb24gc2VlIGh0dHA6Ly9naXRodWIuY29tL2ZpbmFuY2lhbC10aW1lcy9wb2x5ZmlsbC1zZXJ2aWNlXG4gKlxuICogLSBBcnJheS5wcm90b3R5cGUuZmlsbCwgTGljZW5zZTogQ0MwICovXG5cbmlmICghKCdmaWxsJyBpbiBBcnJheS5wcm90b3R5cGUpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaWxsJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbCAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRoaXMgKyAnIGlzIG5vdCBhbiBvYmplY3QnKVxuICAgICAgfVxuXG4gICAgICB2YXIgYXJyYXlMaWtlID0gT2JqZWN0KHRoaXMpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oYXJyYXlMaWtlLmxlbmd0aCwgOTAwNzE5OTI1NDc0MDk5MSksIDApIHx8IDA7XG5cbiAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gMSBpbiBhcmd1bWVudHMgPyBwYXJzZUludChOdW1iZXIoYXJndW1lbnRzWzFdKSwgMTApIHx8IDAgOiAwO1xuXG4gICAgICByZWxhdGl2ZVN0YXJ0ID0gcmVsYXRpdmVTdGFydCA8IDAgPyBNYXRoLm1heChsZW5ndGggKyByZWxhdGl2ZVN0YXJ0LCAwKSA6IE1hdGgubWluKHJlbGF0aXZlU3RhcnQsIGxlbmd0aCk7XG5cbiAgICAgIHZhciByZWxhdGl2ZUVuZCA9IDIgaW4gYXJndW1lbnRzICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQoTnVtYmVyKGFyZ3VtZW50c1syXSksIDEwKSB8fCAwIDogbGVuZ3RoO1xuXG4gICAgICByZWxhdGl2ZUVuZCA9IHJlbGF0aXZlRW5kIDwgMCA/IE1hdGgubWF4KGxlbmd0aCArIGFyZ3VtZW50c1syXSwgMCkgOiBNYXRoLm1pbihyZWxhdGl2ZUVuZCwgbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKHJlbGF0aXZlU3RhcnQgPCByZWxhdGl2ZUVuZCkge1xuICAgICAgICBhcnJheUxpa2VbcmVsYXRpdmVTdGFydF0gPSB2YWx1ZTtcblxuICAgICAgICArK3JlbGF0aXZlU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheUxpa2VcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBJRSBzdXBwb3J0XG4gKi9cbk51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpXG59O1xuXG5OdW1iZXIuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJlxuICBpc0Zpbml0ZSh2YWwpICYmXG4gIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsXG59O1xuXG5OdW1iZXIucGFyc2VGbG9hdCA9IE51bWJlci5wYXJzZUZsb2F0IHx8IHBhcnNlRmxvYXQ7XG5cbk51bWJlci5pc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBJRSBzdXBwb3J0XG4gKi9cbk1hdGgudHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4IDwgMCA/IE1hdGguY2VpbCh4KSA6IE1hdGguZmxvb3IoeClcbn07XG5cbnZhciBOdW1iZXJVdGlsID0gZnVuY3Rpb24gTnVtYmVyVXRpbCAoKSB7fTtcblxuTnVtYmVyVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk51bWJlclV0aWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTnVtYmVyVXRpbFxufTtcbk51bWJlclV0aWwucHJvdG90eXBlLmVxdWFsc1dpdGhUb2xlcmFuY2UgPSBmdW5jdGlvbiBlcXVhbHNXaXRoVG9sZXJhbmNlICh4MSwgeDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPD0gdG9sZXJhbmNlXG59O1xuXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gKGZ1bmN0aW9uIChFcnJvcikge1xuXHRmdW5jdGlvbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gKG1lc3NhZ2UpIHtcblx0XHRFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG5cdH1cblxuXHRpZiAoIEVycm9yICkgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLl9fcHJvdG9fXyA9IEVycm9yO1xuXHRJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IgJiYgRXJyb3IucHJvdG90eXBlICk7XG5cdElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb247XG5cblx0cmV0dXJuIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcblxudmFyIERvdWJsZSA9IGZ1bmN0aW9uIERvdWJsZSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxID0geyBNQVhfVkFMVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuRG91YmxlLmlzTmFOID0gZnVuY3Rpb24gaXNOYU4gKG4pIHsgcmV0dXJuIE51bWJlci5pc05hTihuKSB9O1xuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHMgPSBmdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzIChuKSB7IHJldHVybiBuIH07XG5Eb3VibGUubG9uZ0JpdHNUb0RvdWJsZSA9IGZ1bmN0aW9uIGxvbmdCaXRzVG9Eb3VibGUgKG4pIHsgcmV0dXJuIG4gfTtcbkRvdWJsZS5pc0luZmluaXRlID0gZnVuY3Rpb24gaXNJbmZpbml0ZSAobikgeyByZXR1cm4gIU51bWJlci5pc0Zpbml0ZShuKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEuTUFYX1ZBTFVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlci5NQVhfVkFMVUUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERvdWJsZSwgc3RhdGljQWNjZXNzb3JzJDEgKTtcblxudmFyIENvbXBhcmFibGUgPSBmdW5jdGlvbiBDb21wYXJhYmxlICgpIHt9O1xuXG52YXIgQ2xvbmFibGUgPSBmdW5jdGlvbiBDbG9uYWJsZSAoKSB7fTtcblxudmFyIENvbXBhcmF0b3IgPSBmdW5jdGlvbiBDb21wYXJhdG9yICgpIHt9O1xuXG5mdW5jdGlvbiBTZXJpYWxpemFibGUgKCkge31cblxuLy8gaW1wb3J0IEFzc2VydCBmcm9tICcuLi91dGlsL0Fzc2VydCdcblxudmFyIENvb3JkaW5hdGUgPSBmdW5jdGlvbiBDb29yZGluYXRlICgpIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgdGhpcy56ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnggPSAwLjA7XG4gICAgdGhpcy55ID0gMC4wO1xuICAgIHRoaXMueiA9IENvb3JkaW5hdGUuTlVMTF9PUkRJTkFURTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy54ID0gYy54O1xuICAgIHRoaXMueSA9IGMueTtcbiAgICB0aGlzLnogPSBjLno7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMueCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnkgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy56ID0gQ29vcmRpbmF0ZS5OVUxMX09SRElOQVRFO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB0aGlzLnggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy55ID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMueiA9IGFyZ3VtZW50c1syXTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgRGltZW5zaW9uYWxDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTlVMTF9PUkRJTkFURTogeyBjb25maWd1cmFibGU6IHRydWUgfSxYOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuc2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRPcmRpbmF0ZSAob3JkaW5hdGVJbmRleCwgdmFsdWUpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlLlg6XG4gICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlLlk6XG4gICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlLlo6XG4gICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgb3JkaW5hdGUgaW5kZXg6ICcgKyBvcmRpbmF0ZUluZGV4KVxuICB9XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZXF1YWxzMkQgPSBmdW5jdGlvbiBlcXVhbHMyRCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLnggIT09IG90aGVyLngpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAodGhpcy55ICE9PSBvdGhlci55KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIU51bWJlclV0aWwuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsIGMueCwgdG9sZXJhbmNlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghTnVtYmVyVXRpbC5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSwgYy55LCB0b2xlcmFuY2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKG9yZGluYXRlSW5kZXgpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlLlg6XG4gICAgICByZXR1cm4gdGhpcy54XG4gICAgY2FzZSBDb29yZGluYXRlLlk6XG4gICAgICByZXR1cm4gdGhpcy55XG4gICAgY2FzZSBDb29yZGluYXRlLlo6XG4gICAgICByZXR1cm4gdGhpcy56XG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG9yZGluYXRlIGluZGV4OiAnICsgb3JkaW5hdGVJbmRleClcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5lcXVhbHMzRCA9IGZ1bmN0aW9uIGVxdWFsczNEIChvdGhlcikge1xuICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmXG4gICAgICAgICB0aGlzLnkgPT09IG90aGVyLnkgJiZcbiAgICAgICAgICgodGhpcy56ID09PSBvdGhlci56IHx8IERvdWJsZS5pc05hTih0aGlzLnopKSAmJlxuICAgICAgICAgRG91YmxlLmlzTmFOKG90aGVyLnopKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLmVxdWFsczJEKG90aGVyKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFsSW5aID0gZnVuY3Rpb24gZXF1YWxJblogKGMsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gTnVtYmVyVXRpbC5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueiwgYy56LCB0b2xlcmFuY2UpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBvdGhlciA9IG87XG4gIGlmICh0aGlzLnggPCBvdGhlci54KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnggPiBvdGhlci54KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMueSA8IG90aGVyLnkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMueSA+IG90aGVyLnkpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAvLyB0cnkge1xuICAvLyB2YXIgY29vcmQgPSBudWxsXG4gIC8vIHJldHVybiBjb29yZFxuICAvLyB9IGNhdGNoIChlKSB7XG4gIC8vIGlmIChlIGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pIHtcbiAgLy8gICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKVxuICAvLyAgIHJldHVybiBudWxsXG4gIC8vIH0gZWxzZSB0aHJvdyBlXG4gIC8vIH0gZmluYWxseSB7fVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJywgJyArIHRoaXMueiArICcpJ1xufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmRpc3RhbmNlM0QgPSBmdW5jdGlvbiBkaXN0YW5jZTNEIChjKSB7XG4gIHZhciBkeCA9IHRoaXMueCAtIGMueDtcbiAgdmFyIGR5ID0gdGhpcy55IC0gYy55O1xuICB2YXIgZHogPSB0aGlzLnogLSBjLno7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGMpIHtcbiAgdmFyIGR4ID0gdGhpcy54IC0gYy54O1xuICB2YXIgZHkgPSB0aGlzLnkgLSBjLnk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHZhciByZXN1bHQgPSAxNztcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMueCk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLnkpO1xuICByZXR1cm4gcmVzdWx0XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGUgKG90aGVyKSB7XG4gIHRoaXMueCA9IG90aGVyLng7XG4gIHRoaXMueSA9IG90aGVyLnk7XG4gIHRoaXMueiA9IG90aGVyLno7XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZSwgQ2xvbmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVcbn07XG5Db29yZGluYXRlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBmID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHMoeCk7XG4gICAgcmV0dXJuIE1hdGgudHJ1bmMoKGYgXiBmKSA+Pj4gMzIpXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMuRGltZW5zaW9uYWxDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERpbWVuc2lvbmFsQ29tcGFyYXRvciB9O1xuc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNjY4MzEwODkwMjQyODM2NjkxMCB9O1xuc3RhdGljQWNjZXNzb3JzLk5VTExfT1JESU5BVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRG91YmxlLk5hTiB9O1xuc3RhdGljQWNjZXNzb3JzLlguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzLlkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzLlouZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZSwgc3RhdGljQWNjZXNzb3JzICk7XG5cbnZhciBEaW1lbnNpb25hbENvbXBhcmF0b3IgPSBmdW5jdGlvbiBEaW1lbnNpb25hbENvbXBhcmF0b3IgKGRpbWVuc2lvbnNUb1Rlc3QpIHtcbiAgdGhpcy5fZGltZW5zaW9uc1RvVGVzdCA9IDI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRpbWVuc2lvbnNUb1Rlc3QkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZGltZW5zaW9uc1RvVGVzdCQxICE9PSAyICYmIGRpbWVuc2lvbnNUb1Rlc3QkMSAhPT0gMykgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWQnKSB9XG4gICAgdGhpcy5fZGltZW5zaW9uc1RvVGVzdCA9IGRpbWVuc2lvbnNUb1Rlc3QkMTtcbiAgfVxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgYzEgPSBvMTtcbiAgdmFyIGMyID0gbzI7XG4gIHZhciBjb21wWCA9IERpbWVuc2lvbmFsQ29tcGFyYXRvci5jb21wYXJlKGMxLngsIGMyLngpO1xuICBpZiAoY29tcFggIT09IDApIHsgcmV0dXJuIGNvbXBYIH1cbiAgdmFyIGNvbXBZID0gRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUoYzEueSwgYzIueSk7XG4gIGlmIChjb21wWSAhPT0gMCkgeyByZXR1cm4gY29tcFkgfVxuICBpZiAodGhpcy5fZGltZW5zaW9uc1RvVGVzdCA8PSAyKSB7IHJldHVybiAwIH1cbiAgdmFyIGNvbXBaID0gRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUoYzEueiwgYzIueik7XG4gIHJldHVybiBjb21wWlxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5EaW1lbnNpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGltZW5zaW9uYWxDb21wYXJhdG9yXG59O1xuRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgeyByZXR1cm4gLTEgfVxuICBpZiAoYSA+IGIpIHsgcmV0dXJuIDEgfVxuICBpZiAoRG91YmxlLmlzTmFOKGEpKSB7XG4gICAgaWYgKERvdWJsZS5pc05hTihiKSkgeyByZXR1cm4gMCB9XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKERvdWJsZS5pc05hTihiKSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuXG4vLyBpbXBvcnQgaGFzSW50ZXJmYWNlIGZyb20gJy4uLy4uLy4uLy4uL2hhc0ludGVyZmFjZSdcbi8vIGltcG9ydCBDb29yZGluYXRlU2VxdWVuY2UgZnJvbSAnLi9Db29yZGluYXRlU2VxdWVuY2UnXG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlICgpIHtcbiAgLy8gaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgLy8gaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gIC8vICAgbGV0IGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdXG4gIC8vIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAvLyAgIGxldCBjb29yZFNlcSA9IGFyZ3VtZW50c1swXVxuICAvLyB9XG4gIC8vIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAvLyBsZXQgc2l6ZSA9IGFyZ3VtZW50c1swXVxuICAvLyBsZXQgZGltZW5zaW9uID0gYXJndW1lbnRzWzFdXG4gIC8vIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5XG59O1xuXG52YXIgTG9jYXRpb24gPSBmdW5jdGlvbiBMb2NhdGlvbiAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0ID0geyBJTlRFUklPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxCT1VOREFSWTogeyBjb25maWd1cmFibGU6IHRydWUgfSxFWFRFUklPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxOT05FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTG9jYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTG9jYXRpb25cbn07XG5Mb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sID0gZnVuY3Rpb24gdG9Mb2NhdGlvblN5bWJvbCAobG9jYXRpb25WYWx1ZSkge1xuICBzd2l0Y2ggKGxvY2F0aW9uVmFsdWUpIHtcbiAgICBjYXNlIExvY2F0aW9uLkVYVEVSSU9SOlxuICAgICAgcmV0dXJuICdlJ1xuICAgIGNhc2UgTG9jYXRpb24uQk9VTkRBUlk6XG4gICAgICByZXR1cm4gJ2InXG4gICAgY2FzZSBMb2NhdGlvbi5JTlRFUklPUjpcbiAgICAgIHJldHVybiAnaSdcbiAgICBjYXNlIExvY2F0aW9uLk5PTkU6XG4gICAgICByZXR1cm4gJy0nXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGxvY2F0aW9uIHZhbHVlOiAnICsgbG9jYXRpb25WYWx1ZSlcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNC5JTlRFUklPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5CT1VOREFSWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5FWFRFUklPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5OT05FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMb2NhdGlvbiwgc3RhdGljQWNjZXNzb3JzJDQgKTtcblxudmFyIGhhc0ludGVyZmFjZSA9IGZ1bmN0aW9uIChvLCBpKSB7XG4gIHJldHVybiBvLmludGVyZmFjZXNfICYmIG8uaW50ZXJmYWNlc18oKS5pbmRleE9mKGkpID4gLTFcbn07XG5cbnZhciBNYXRoVXRpbCA9IGZ1bmN0aW9uIE1hdGhVdGlsICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDUgPSB7IExPR18xMDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5NYXRoVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1hdGhVdGlsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1hdGhVdGlsXG59O1xuTWF0aFV0aWwubG9nMTAgPSBmdW5jdGlvbiBsb2cxMCAoeCkge1xuICB2YXIgbG4gPSBNYXRoLmxvZyh4KTtcbiAgaWYgKERvdWJsZS5pc0luZmluaXRlKGxuKSkgeyByZXR1cm4gbG4gfVxuICBpZiAoRG91YmxlLmlzTmFOKGxuKSkgeyByZXR1cm4gbG4gfVxuICByZXR1cm4gbG4gLyBNYXRoVXRpbC5MT0dfMTBcbn07XG5NYXRoVXRpbC5taW4gPSBmdW5jdGlvbiBtaW4gKHYxLCB2MiwgdjMsIHY0KSB7XG4gIHZhciBtaW4gPSB2MTtcbiAgaWYgKHYyIDwgbWluKSB7IG1pbiA9IHYyOyB9XG4gIGlmICh2MyA8IG1pbikgeyBtaW4gPSB2MzsgfVxuICBpZiAodjQgPCBtaW4pIHsgbWluID0gdjQ7IH1cbiAgcmV0dXJuIG1pblxufTtcbk1hdGhVdGlsLmNsYW1wID0gZnVuY3Rpb24gY2xhbXAgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoeCA8IG1pbikgeyByZXR1cm4gbWluIH1cbiAgICBpZiAoeCA+IG1heCkgeyByZXR1cm4gbWF4IH1cbiAgICByZXR1cm4geFxuICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSAmJiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pICYmIE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSkpIHtcbiAgICB2YXIgeCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtaW4kMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWF4JDEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHgkMSA8IG1pbiQxKSB7IHJldHVybiBtaW4kMSB9XG4gICAgaWYgKHgkMSA+IG1heCQxKSB7IHJldHVybiBtYXgkMSB9XG4gICAgcmV0dXJuIHgkMVxuICB9XG59O1xuTWF0aFV0aWwud3JhcCA9IGZ1bmN0aW9uIHdyYXAgKGluZGV4LCBtYXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBtYXggLSAtaW5kZXggJSBtYXhcbiAgfVxuICByZXR1cm4gaW5kZXggJSBtYXhcbn07XG5NYXRoVXRpbC5tYXggPSBmdW5jdGlvbiBtYXggKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciB2MSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdjIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHYzID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBtYXggPSB2MTtcbiAgICBpZiAodjIgPiBtYXgpIHsgbWF4ID0gdjI7IH1cbiAgICBpZiAodjMgPiBtYXgpIHsgbWF4ID0gdjM7IH1cbiAgICByZXR1cm4gbWF4XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciB2MSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB2MiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2MyQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB2NCA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgbWF4JDEgPSB2MSQxO1xuICAgIGlmICh2MiQxID4gbWF4JDEpIHsgbWF4JDEgPSB2MiQxOyB9XG4gICAgaWYgKHYzJDEgPiBtYXgkMSkgeyBtYXgkMSA9IHYzJDE7IH1cbiAgICBpZiAodjQgPiBtYXgkMSkgeyBtYXgkMSA9IHY0OyB9XG4gICAgcmV0dXJuIG1heCQxXG4gIH1cbn07XG5NYXRoVXRpbC5hdmVyYWdlID0gZnVuY3Rpb24gYXZlcmFnZSAoeDEsIHgyKSB7XG4gIHJldHVybiAoeDEgKyB4MikgLyAyLjBcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNS5MT0dfMTAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5sb2coMTApIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNYXRoVXRpbCwgc3RhdGljQWNjZXNzb3JzJDUgKTtcblxudmFyIFN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uIFN0cmluZ0J1ZmZlciAoc3RyKSB7XG4gIHRoaXMuc3RyID0gc3RyO1xufTtcblN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChlKSB7XG4gIHRoaXMuc3RyICs9IGU7XG59O1xuXG5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldENoYXJBdCA9IGZ1bmN0aW9uIHNldENoYXJBdCAoaSwgYykge1xuICB0aGlzLnN0ciA9IHRoaXMuc3RyLnN1YnN0cigwLCBpKSArIGMgKyB0aGlzLnN0ci5zdWJzdHIoaSArIDEpO1xufTtcblxuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlKSB7XG4gIHJldHVybiB0aGlzLnN0clxufTtcblxudmFyIEludGVnZXIgPSBmdW5jdGlvbiBJbnRlZ2VyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBmdW5jdGlvbiBpbnRWYWx1ZSAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlXG59O1xuSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIGlmICh0aGlzLnZhbHVlIDwgbykgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy52YWx1ZSA+IG8pIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkludGVnZXIuaXNOYU4gPSBmdW5jdGlvbiBpc05hTiAobikgeyByZXR1cm4gTnVtYmVyLmlzTmFOKG4pIH07XG5cbnZhciBDaGFyYWN0ZXIgPSBmdW5jdGlvbiBDaGFyYWN0ZXIgKCkge307XG5cbkNoYXJhY3Rlci5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMpIHsgcmV0dXJuICgoYyA8PSAzMiAmJiBjID49IDApIHx8IGMgPT09IDEyNykgfTtcbkNoYXJhY3Rlci50b1VwcGVyQ2FzZSA9IGZ1bmN0aW9uIHRvVXBwZXJDYXNlIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCkgfTtcblxudmFyIEREID0gZnVuY3Rpb24gREQgKCkge1xuICB0aGlzLl9oaSA9IDAuMDtcbiAgdGhpcy5fbG8gPSAwLjA7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5pbml0KDAuMCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoeCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIGRkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGRkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc3RyID0gYXJndW1lbnRzWzBdO1xuICAgICAgREQuY2FsbCh0aGlzLCBERC5wYXJzZShzdHIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBoaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG8gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5pbml0KGhpLCBsbyk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNyA9IHsgUEk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVFdPX1BJOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBJXzI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxOYU46IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRVBTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNQTElUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9QUklOVF9ESUdJVFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVEVOOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE9ORTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTQ0lfTk9UX0VYUE9ORU5UX0NIQVI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU0NJX05PVF9aRVJPOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5ERC5wcm90b3R5cGUubGUgPSBmdW5jdGlvbiBsZSAoeSkge1xuICByZXR1cm4gKHRoaXMuX2hpIDwgeS5faGkgfHwgdGhpcy5faGkgPT09IHkuX2hpKSAmJiB0aGlzLl9sbyA8PSB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgKGluc2VydERlY2ltYWxQb2ludCwgbWFnbml0dWRlKSB7XG4gIHZhciB5ID0gdGhpcy5hYnMoKTtcbiAgdmFyIG1hZyA9IERELm1hZ25pdHVkZSh5Ll9oaSk7XG4gIHZhciBzY2FsZSA9IERELlRFTi5wb3cobWFnKTtcbiAgeSA9IHkuZGl2aWRlKHNjYWxlKTtcbiAgaWYgKHkuZ3QoREQuVEVOKSkge1xuICAgIHkgPSB5LmRpdmlkZShERC5URU4pO1xuICAgIG1hZyArPSAxO1xuICB9IGVsc2UgaWYgKHkubHQoREQuT05FKSkge1xuICAgIHkgPSB5Lm11bHRpcGx5KERELlRFTik7XG4gICAgbWFnIC09IDE7XG4gIH1cbiAgdmFyIGRlY2ltYWxQb2ludFBvcyA9IG1hZyArIDE7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIHZhciBudW1EaWdpdHMgPSBERC5NQVhfUFJJTlRfRElHSVRTIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtRGlnaXRzOyBpKyspIHtcbiAgICBpZiAoaW5zZXJ0RGVjaW1hbFBvaW50ICYmIGkgPT09IGRlY2ltYWxQb2ludFBvcykge1xuICAgICAgYnVmLmFwcGVuZCgnLicpO1xuICAgIH1cbiAgICB2YXIgZGlnaXQgPSBNYXRoLnRydW5jKHkuX2hpKTtcbiAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICB2YXIgcmViaWFzQnkxMCA9IGZhbHNlO1xuICAgIHZhciBkaWdpdENoYXIgPSAwO1xuICAgIGlmIChkaWdpdCA+IDkpIHtcbiAgICAgIHJlYmlhc0J5MTAgPSB0cnVlO1xuICAgICAgZGlnaXRDaGFyID0gJzknO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdENoYXIgPSAnMCcgKyBkaWdpdDtcbiAgICB9XG4gICAgYnVmLmFwcGVuZChkaWdpdENoYXIpO1xuICAgIHkgPSB5LnN1YnRyYWN0KERELnZhbHVlT2YoZGlnaXQpKS5tdWx0aXBseShERC5URU4pO1xuICAgIGlmIChyZWJpYXNCeTEwKSB7IHkuc2VsZkFkZChERC5URU4pOyB9XG4gICAgdmFyIGNvbnRpbnVlRXh0cmFjdGluZ0RpZ2l0cyA9IHRydWU7XG4gICAgdmFyIHJlbU1hZyA9IERELm1hZ25pdHVkZSh5Ll9oaSk7XG4gICAgaWYgKHJlbU1hZyA8IDAgJiYgTWF0aC5hYnMocmVtTWFnKSA+PSBudW1EaWdpdHMgLSBpKSB7IGNvbnRpbnVlRXh0cmFjdGluZ0RpZ2l0cyA9IGZhbHNlOyB9XG4gICAgaWYgKCFjb250aW51ZUV4dHJhY3RpbmdEaWdpdHMpIHsgYnJlYWsgfVxuICB9XG4gIG1hZ25pdHVkZVswXSA9IG1hZztcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuREQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gIHJldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpXG59O1xuREQucHJvdG90eXBlLmRvdWJsZVZhbHVlID0gZnVuY3Rpb24gZG91YmxlVmFsdWUgKCkge1xuICByZXR1cm4gdGhpcy5faGkgKyB0aGlzLl9sb1xufTtcbkRELnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkKHkubmVnYXRlKCkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmFkZCgteSQxKVxuICB9XG59O1xuREQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX2hpID09PSB5Ll9oaSAmJiB0aGlzLl9sbyA9PT0geS5fbG9cbiAgfVxufTtcbkRELnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICByZXR1cm4gdGhpcy5faGkgPT09IDAuMCAmJiB0aGlzLl9sbyA9PT0gMC4wXG59O1xuREQucHJvdG90eXBlLnNlbGZTdWJ0cmFjdCA9IGZ1bmN0aW9uIHNlbGZTdWJ0cmFjdCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiB0aGlzLnNlbGZBZGQoLXkuX2hpLCAteS5fbG8pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiB0aGlzLnNlbGZBZGQoLXkkMSwgMC4wKVxuICB9XG59O1xuREQucHJvdG90eXBlLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcgPSBmdW5jdGlvbiBnZXRTcGVjaWFsTnVtYmVyU3RyaW5nICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHsgcmV0dXJuICcwLjAnIH1cbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gJ05hTiAnIH1cbiAgcmV0dXJuIG51bGxcbn07XG5ERC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gbWluICh4KSB7XG4gIGlmICh0aGlzLmxlKHgpKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geFxuICB9XG59O1xuREQucHJvdG90eXBlLnNlbGZEaXZpZGUgPSBmdW5jdGlvbiBzZWxmRGl2aWRlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh5Ll9oaSwgeS5fbG8pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZEaXZpZGUoeSQxLCAwLjApXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeWhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5bG8gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhjID0gbnVsbDtcbiAgICB2YXIgdGMgPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIHZhciBVID0gbnVsbDtcbiAgICB2YXIgdSA9IG51bGw7XG4gICAgQyA9IHRoaXMuX2hpIC8geWhpO1xuICAgIGMgPSBERC5TUExJVCAqIEM7XG4gICAgaGMgPSBjIC0gQztcbiAgICB1ID0gREQuU1BMSVQgKiB5aGk7XG4gICAgaGMgPSBjIC0gaGM7XG4gICAgdGMgPSBDIC0gaGM7XG4gICAgaHkgPSB1IC0geWhpO1xuICAgIFUgPSBDICogeWhpO1xuICAgIGh5ID0gdSAtIGh5O1xuICAgIHR5ID0geWhpIC0gaHk7XG4gICAgdSA9IGhjICogaHkgLSBVICsgaGMgKiB0eSArIHRjICogaHkgKyB0YyAqIHR5O1xuICAgIGMgPSAodGhpcy5faGkgLSBVIC0gdSArIHRoaXMuX2xvIC0gQyAqIHlsbykgLyB5aGk7XG4gICAgdSA9IEMgKyBjO1xuICAgIHRoaXMuX2hpID0gdTtcbiAgICB0aGlzLl9sbyA9IEMgLSB1ICsgYztcbiAgICByZXR1cm4gdGhpc1xuICB9XG59O1xuREQucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiBkdW1wICgpIHtcbiAgcmV0dXJuICdERDwnICsgdGhpcy5faGkgKyAnLCAnICsgdGhpcy5fbG8gKyAnPidcbn07XG5ERC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGhjID0gbnVsbDtcbiAgICB2YXIgdGMgPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIHZhciBVID0gbnVsbDtcbiAgICB2YXIgdSA9IG51bGw7XG4gICAgQyA9IHRoaXMuX2hpIC8geS5faGk7XG4gICAgYyA9IERELlNQTElUICogQztcbiAgICBoYyA9IGMgLSBDO1xuICAgIHUgPSBERC5TUExJVCAqIHkuX2hpO1xuICAgIGhjID0gYyAtIGhjO1xuICAgIHRjID0gQyAtIGhjO1xuICAgIGh5ID0gdSAtIHkuX2hpO1xuICAgIFUgPSBDICogeS5faGk7XG4gICAgaHkgPSB1IC0gaHk7XG4gICAgdHkgPSB5Ll9oaSAtIGh5O1xuICAgIHUgPSBoYyAqIGh5IC0gVSArIGhjICogdHkgKyB0YyAqIGh5ICsgdGMgKiB0eTtcbiAgICBjID0gKHRoaXMuX2hpIC0gVSAtIHUgKyB0aGlzLl9sbyAtIEMgKiB5Ll9sbykgLyB5Ll9oaTtcbiAgICB1ID0gQyArIGM7XG4gICAgdmFyIHpoaSA9IHU7XG4gICAgdmFyIHpsbyA9IEMgLSB1ICsgYztcbiAgICByZXR1cm4gbmV3IEREKHpoaSwgemxvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoRG91YmxlLmlzTmFOKHkkMSkpIHsgcmV0dXJuIERELmNyZWF0ZU5hTigpIH1cbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmRGl2aWRlKHkkMSwgMC4wKVxuICB9XG59O1xuREQucHJvdG90eXBlLmdlID0gZnVuY3Rpb24gZ2UgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA+IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPj0geS5fbG9cbn07XG5ERC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChleHApIHtcbiAgaWYgKGV4cCA9PT0gMC4wKSB7IHJldHVybiBERC52YWx1ZU9mKDEuMCkgfVxuICB2YXIgciA9IG5ldyBERCh0aGlzKTtcbiAgdmFyIHMgPSBERC52YWx1ZU9mKDEuMCk7XG4gIHZhciBuID0gTWF0aC5hYnMoZXhwKTtcbiAgaWYgKG4gPiAxKSB7XG4gICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHtcbiAgICAgICAgcy5zZWxmTXVsdGlwbHkocik7XG4gICAgICB9XG4gICAgICBuIC89IDI7XG4gICAgICBpZiAobiA+IDApIHsgciA9IHIuc3FyKCk7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcyA9IHI7XG4gIH1cbiAgaWYgKGV4cCA8IDApIHsgcmV0dXJuIHMucmVjaXByb2NhbCgpIH1cbiAgcmV0dXJuIHNcbn07XG5ERC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIGNlaWwgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiBERC5OYU4gfVxuICB2YXIgZmhpID0gTWF0aC5jZWlsKHRoaXMuX2hpKTtcbiAgdmFyIGZsbyA9IDAuMDtcbiAgaWYgKGZoaSA9PT0gdGhpcy5faGkpIHtcbiAgICBmbG8gPSBNYXRoLmNlaWwodGhpcy5fbG8pO1xuICB9XG4gIHJldHVybiBuZXcgREQoZmhpLCBmbG8pXG59O1xuREQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgb3RoZXIgPSBvO1xuICBpZiAodGhpcy5faGkgPCBvdGhlci5faGkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2hpID4gb3RoZXIuX2hpKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2xvIDwgb3RoZXIuX2xvKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9sbyA+IG90aGVyLl9sbykgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuREQucHJvdG90eXBlLnJpbnQgPSBmdW5jdGlvbiByaW50ICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gdGhpcyB9XG4gIHZhciBwbHVzNSA9IHRoaXMuYWRkKDAuNSk7XG4gIHJldHVybiBwbHVzNS5mbG9vcigpXG59O1xuREQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5pbml0KHZhbHVlKTtcbiAgICByZXR1cm4gdGhpc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5pbml0KHZhbHVlJDEpO1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn07XG5ERC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gbWF4ICh4KSB7XG4gIGlmICh0aGlzLmdlKHgpKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geFxuICB9XG59O1xuREQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0ICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHsgcmV0dXJuIERELnZhbHVlT2YoMC4wKSB9XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgIHJldHVybiBERC5OYU5cbiAgfVxuICB2YXIgeCA9IDEuMCAvIE1hdGguc3FydCh0aGlzLl9oaSk7XG4gIHZhciBheCA9IHRoaXMuX2hpICogeDtcbiAgdmFyIGF4ZGQgPSBERC52YWx1ZU9mKGF4KTtcbiAgdmFyIGRpZmZTcSA9IHRoaXMuc3VidHJhY3QoYXhkZC5zcXIoKSk7XG4gIHZhciBkMiA9IGRpZmZTcS5faGkgKiAoeCAqIDAuNSk7XG4gIHJldHVybiBheGRkLmFkZChkMilcbn07XG5ERC5wcm90b3R5cGUuc2VsZkFkZCA9IGZ1bmN0aW9uIHNlbGZBZGQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmQWRkKHkuX2hpLCB5Ll9sbylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIEggPSBudWxsO1xuICAgICAgdmFyIGggPSBudWxsO1xuICAgICAgdmFyIFMgPSBudWxsO1xuICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgdmFyIGUgPSBudWxsO1xuICAgICAgdmFyIGYgPSBudWxsO1xuICAgICAgUyA9IHRoaXMuX2hpICsgeSQxO1xuICAgICAgZSA9IFMgLSB0aGlzLl9oaTtcbiAgICAgIHMgPSBTIC0gZTtcbiAgICAgIHMgPSB5JDEgLSBlICsgKHRoaXMuX2hpIC0gcyk7XG4gICAgICBmID0gcyArIHRoaXMuX2xvO1xuICAgICAgSCA9IFMgKyBmO1xuICAgICAgaCA9IGYgKyAoUyAtIEgpO1xuICAgICAgdGhpcy5faGkgPSBIICsgaDtcbiAgICAgIHRoaXMuX2xvID0gaCArIChIIC0gdGhpcy5faGkpO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB5aGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHlsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgSCQxID0gbnVsbDtcbiAgICB2YXIgaCQxID0gbnVsbDtcbiAgICB2YXIgVCA9IG51bGw7XG4gICAgdmFyIHQgPSBudWxsO1xuICAgIHZhciBTJDEgPSBudWxsO1xuICAgIHZhciBzJDEgPSBudWxsO1xuICAgIHZhciBlJDEgPSBudWxsO1xuICAgIHZhciBmJDEgPSBudWxsO1xuICAgIFMkMSA9IHRoaXMuX2hpICsgeWhpO1xuICAgIFQgPSB0aGlzLl9sbyArIHlsbztcbiAgICBlJDEgPSBTJDEgLSB0aGlzLl9oaTtcbiAgICBmJDEgPSBUIC0gdGhpcy5fbG87XG4gICAgcyQxID0gUyQxIC0gZSQxO1xuICAgIHQgPSBUIC0gZiQxO1xuICAgIHMkMSA9IHloaSAtIGUkMSArICh0aGlzLl9oaSAtIHMkMSk7XG4gICAgdCA9IHlsbyAtIGYkMSArICh0aGlzLl9sbyAtIHQpO1xuICAgIGUkMSA9IHMkMSArIFQ7XG4gICAgSCQxID0gUyQxICsgZSQxO1xuICAgIGgkMSA9IGUkMSArIChTJDEgLSBIJDEpO1xuICAgIGUkMSA9IHQgKyBoJDE7XG4gICAgdmFyIHpoaSA9IEgkMSArIGUkMTtcbiAgICB2YXIgemxvID0gZSQxICsgKEgkMSAtIHpoaSk7XG4gICAgdGhpcy5faGkgPSB6aGk7XG4gICAgdGhpcy5fbG8gPSB6bG87XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zZWxmTXVsdGlwbHkgPSBmdW5jdGlvbiBzZWxmTXVsdGlwbHkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoeS5faGksIHkuX2xvKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoeSQxLCAwLjApXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeWhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5bG8gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGh4ID0gbnVsbDtcbiAgICB2YXIgdHggPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIEMgPSBERC5TUExJVCAqIHRoaXMuX2hpO1xuICAgIGh4ID0gQyAtIHRoaXMuX2hpO1xuICAgIGMgPSBERC5TUExJVCAqIHloaTtcbiAgICBoeCA9IEMgLSBoeDtcbiAgICB0eCA9IHRoaXMuX2hpIC0gaHg7XG4gICAgaHkgPSBjIC0geWhpO1xuICAgIEMgPSB0aGlzLl9oaSAqIHloaTtcbiAgICBoeSA9IGMgLSBoeTtcbiAgICB0eSA9IHloaSAtIGh5O1xuICAgIGMgPSBoeCAqIGh5IC0gQyArIGh4ICogdHkgKyB0eCAqIGh5ICsgdHggKiB0eSArICh0aGlzLl9oaSAqIHlsbyArIHRoaXMuX2xvICogeWhpKTtcbiAgICB2YXIgemhpID0gQyArIGM7XG4gICAgaHggPSBDIC0gemhpO1xuICAgIHZhciB6bG8gPSBjICsgaHg7XG4gICAgdGhpcy5faGkgPSB6aGk7XG4gICAgdGhpcy5fbG8gPSB6bG87XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zZWxmU3FyID0gZnVuY3Rpb24gc2VsZlNxciAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKVxufTtcbkRELnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uIGZsb29yICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gREQuTmFOIH1cbiAgdmFyIGZoaSA9IE1hdGguZmxvb3IodGhpcy5faGkpO1xuICB2YXIgZmxvID0gMC4wO1xuICBpZiAoZmhpID09PSB0aGlzLl9oaSkge1xuICAgIGZsbyA9IE1hdGguZmxvb3IodGhpcy5fbG8pO1xuICB9XG4gIHJldHVybiBuZXcgREQoZmhpLCBmbG8pXG59O1xuREQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbmV3IEREKC10aGlzLl9oaSwgLXRoaXMuX2xvKVxufTtcbkRELnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgLy8gdHJ5IHtcbiAgLy8gcmV0dXJuIG51bGxcbiAgLy8gfSBjYXRjaCAoZXgpIHtcbiAgLy8gaWYgKGV4IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pIHtcbiAgLy8gICByZXR1cm4gbnVsbFxuICAvLyB9IGVsc2UgdGhyb3cgZXhcbiAgLy8gfSBmaW5hbGx5IHt9XG59O1xuREQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoeS5pc05hTigpKSB7IHJldHVybiBERC5jcmVhdGVOYU4oKSB9XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChEb3VibGUuaXNOYU4oeSQxKSkgeyByZXR1cm4gREQuY3JlYXRlTmFOKCkgfVxuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh5JDEsIDAuMClcbiAgfVxufTtcbkRELnByb3RvdHlwZS5pc05hTiA9IGZ1bmN0aW9uIGlzTmFOICgpIHtcbiAgcmV0dXJuIERvdWJsZS5pc05hTih0aGlzLl9oaSlcbn07XG5ERC5wcm90b3R5cGUuaW50VmFsdWUgPSBmdW5jdGlvbiBpbnRWYWx1ZSAoKSB7XG4gIHJldHVybiBNYXRoLnRydW5jKHRoaXMuX2hpKVxufTtcbkRELnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIG1hZyA9IERELm1hZ25pdHVkZSh0aGlzLl9oaSk7XG4gIGlmIChtYWcgPj0gLTMgJiYgbWFnIDw9IDIwKSB7IHJldHVybiB0aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpIH1cbiAgcmV0dXJuIHRoaXMudG9TY2lOb3RhdGlvbigpXG59O1xuREQucHJvdG90eXBlLnRvU3RhbmRhcmROb3RhdGlvbiA9IGZ1bmN0aW9uIHRvU3RhbmRhcmROb3RhdGlvbiAoKSB7XG4gIHZhciBzcGVjaWFsU3RyID0gdGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7XG4gIGlmIChzcGVjaWFsU3RyICE9PSBudWxsKSB7IHJldHVybiBzcGVjaWFsU3RyIH1cbiAgdmFyIG1hZ25pdHVkZSA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICB2YXIgc2lnRGlnaXRzID0gdGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModHJ1ZSwgbWFnbml0dWRlKTtcbiAgdmFyIGRlY2ltYWxQb2ludFBvcyA9IG1hZ25pdHVkZVswXSArIDE7XG4gIHZhciBudW0gPSBzaWdEaWdpdHM7XG4gIGlmIChzaWdEaWdpdHMuY2hhckF0KDApID09PSAnLicpIHtcbiAgICBudW0gPSAnMCcgKyBzaWdEaWdpdHM7XG4gIH0gZWxzZSBpZiAoZGVjaW1hbFBvaW50UG9zIDwgMCkge1xuICAgIG51bSA9ICcwLicgKyBERC5zdHJpbmdPZkNoYXIoJzAnLCAtZGVjaW1hbFBvaW50UG9zKSArIHNpZ0RpZ2l0cztcbiAgfSBlbHNlIGlmIChzaWdEaWdpdHMuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgIHZhciBudW1aZXJvZXMgPSBkZWNpbWFsUG9pbnRQb3MgLSBzaWdEaWdpdHMubGVuZ3RoO1xuICAgIHZhciB6ZXJvZXMgPSBERC5zdHJpbmdPZkNoYXIoJzAnLCBudW1aZXJvZXMpO1xuICAgIG51bSA9IHNpZ0RpZ2l0cyArIHplcm9lcyArICcuMCc7XG4gIH1cbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IHJldHVybiAnLScgKyBudW0gfVxuICByZXR1cm4gbnVtXG59O1xuREQucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiByZWNpcHJvY2FsICgpIHtcbiAgdmFyIGhjID0gbnVsbDtcbiAgdmFyIHRjID0gbnVsbDtcbiAgdmFyIGh5ID0gbnVsbDtcbiAgdmFyIHR5ID0gbnVsbDtcbiAgdmFyIEMgPSBudWxsO1xuICB2YXIgYyA9IG51bGw7XG4gIHZhciBVID0gbnVsbDtcbiAgdmFyIHUgPSBudWxsO1xuICBDID0gMS4wIC8gdGhpcy5faGk7XG4gIGMgPSBERC5TUExJVCAqIEM7XG4gIGhjID0gYyAtIEM7XG4gIHUgPSBERC5TUExJVCAqIHRoaXMuX2hpO1xuICBoYyA9IGMgLSBoYztcbiAgdGMgPSBDIC0gaGM7XG4gIGh5ID0gdSAtIHRoaXMuX2hpO1xuICBVID0gQyAqIHRoaXMuX2hpO1xuICBoeSA9IHUgLSBoeTtcbiAgdHkgPSB0aGlzLl9oaSAtIGh5O1xuICB1ID0gaGMgKiBoeSAtIFUgKyBoYyAqIHR5ICsgdGMgKiBoeSArIHRjICogdHk7XG4gIGMgPSAoMS4wIC0gVSAtIHUgLSBDICogdGhpcy5fbG8pIC8gdGhpcy5faGk7XG4gIHZhciB6aGkgPSBDICsgYztcbiAgdmFyIHpsbyA9IEMgLSB6aGkgKyBjO1xuICByZXR1cm4gbmV3IEREKHpoaSwgemxvKVxufTtcbkRELnByb3RvdHlwZS50b1NjaU5vdGF0aW9uID0gZnVuY3Rpb24gdG9TY2lOb3RhdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKSB7IHJldHVybiBERC5TQ0lfTk9UX1pFUk8gfVxuICB2YXIgc3BlY2lhbFN0ciA9IHRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO1xuICBpZiAoc3BlY2lhbFN0ciAhPT0gbnVsbCkgeyByZXR1cm4gc3BlY2lhbFN0ciB9XG4gIHZhciBtYWduaXR1ZGUgPSBuZXcgQXJyYXkoMSkuZmlsbChudWxsKTtcbiAgdmFyIGRpZ2l0cyA9IHRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKGZhbHNlLCBtYWduaXR1ZGUpO1xuICB2YXIgZXhwU3RyID0gREQuU0NJX05PVF9FWFBPTkVOVF9DSEFSICsgbWFnbml0dWRlWzBdO1xuICBpZiAoZGlnaXRzLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBsZWFkaW5nIHplcm86ICcgKyBkaWdpdHMpXG4gIH1cbiAgdmFyIHRyYWlsaW5nRGlnaXRzID0gJyc7XG4gIGlmIChkaWdpdHMubGVuZ3RoID4gMSkgeyB0cmFpbGluZ0RpZ2l0cyA9IGRpZ2l0cy5zdWJzdHJpbmcoMSk7IH1cbiAgdmFyIGRpZ2l0c1dpdGhEZWNpbWFsID0gZGlnaXRzLmNoYXJBdCgwKSArICcuJyArIHRyYWlsaW5nRGlnaXRzO1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgcmV0dXJuICctJyArIGRpZ2l0c1dpdGhEZWNpbWFsICsgZXhwU3RyIH1cbiAgcmV0dXJuIGRpZ2l0c1dpdGhEZWNpbWFsICsgZXhwU3RyXG59O1xuREQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyByZXR1cm4gdGhpcy5uZWdhdGUoKSB9XG4gIHJldHVybiBuZXcgREQodGhpcylcbn07XG5ERC5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUgKCkge1xuICByZXR1cm4gKHRoaXMuX2hpID4gMC4wIHx8IHRoaXMuX2hpID09PSAwLjApICYmIHRoaXMuX2xvID4gMC4wXG59O1xuREQucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA8IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPCB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmQWRkKHkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZBZGQoeSQxKVxuICB9XG59O1xuREQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5faGkgPSB4O1xuICAgICAgdGhpcy5fbG8gPSAwLjA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIGRkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5faGkgPSBkZC5faGk7XG4gICAgICB0aGlzLl9sbyA9IGRkLl9sbztcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBoaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG8gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5faGkgPSBoaTtcbiAgICB0aGlzLl9sbyA9IGxvO1xuICB9XG59O1xuREQucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA+IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPiB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSAoKSB7XG4gIHJldHVybiAodGhpcy5faGkgPCAwLjAgfHwgdGhpcy5faGkgPT09IDAuMCkgJiYgdGhpcy5fbG8gPCAwLjBcbn07XG5ERC5wcm90b3R5cGUudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIGlmICh0aGlzLmlzUG9zaXRpdmUoKSkgeyByZXR1cm4gdGhpcy5mbG9vcigpOyB9IGVsc2UgeyByZXR1cm4gdGhpcy5jZWlsKCkgfVxufTtcbkRELnByb3RvdHlwZS5zaWdudW0gPSBmdW5jdGlvbiBzaWdudW0gKCkge1xuICBpZiAodGhpcy5faGkgPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2hpIDwgMCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbG8gPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2xvIDwgMCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gMFxufTtcbkRELnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGUsIENvbXBhcmFibGUsIENsb25hYmxlXVxufTtcbkRELnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEREXG59O1xuREQuc3FyID0gZnVuY3Rpb24gc3FyICh4KSB7XG4gIHJldHVybiBERC52YWx1ZU9mKHgpLnNlbGZNdWx0aXBseSh4KVxufTtcbkRELnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gREQucGFyc2Uoc3RyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBERCh4KVxuICB9XG59O1xuREQuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKHgpIHtcbiAgcmV0dXJuIERELnZhbHVlT2YoeCkuc3FydCgpXG59O1xuREQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoc3RyKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHN0cmxlbiA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChDaGFyYWN0ZXIuaXNXaGl0ZXNwYWNlKHN0ci5jaGFyQXQoaSkpKSB7IGkrKzsgfVxuICB2YXIgaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICBpZiAoaSA8IHN0cmxlbikge1xuICAgIHZhciBzaWduQ2ggPSBzdHIuY2hhckF0KGkpO1xuICAgIGlmIChzaWduQ2ggPT09ICctJyB8fCBzaWduQ2ggPT09ICcrJykge1xuICAgICAgaSsrO1xuICAgICAgaWYgKHNpZ25DaCA9PT0gJy0nKSB7IGlzTmVnYXRpdmUgPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIHZhciB2YWwgPSBuZXcgREQoKTtcbiAgdmFyIG51bURpZ2l0cyA9IDA7XG4gIHZhciBudW1CZWZvcmVEZWMgPSAwO1xuICB2YXIgZXhwID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoaSA+PSBzdHJsZW4pIHsgYnJlYWsgfVxuICAgIHZhciBjaCA9IHN0ci5jaGFyQXQoaSk7XG4gICAgaSsrO1xuICAgIGlmIChDaGFyYWN0ZXIuaXNEaWdpdChjaCkpIHtcbiAgICAgIHZhciBkID0gY2ggLSAnMCc7XG4gICAgICB2YWwuc2VsZk11bHRpcGx5KERELlRFTik7XG4gICAgICB2YWwuc2VsZkFkZChkKTtcbiAgICAgIG51bURpZ2l0cysrO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgIG51bUJlZm9yZURlYyA9IG51bURpZ2l0cztcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgIHZhciBleHBTdHIgPSBzdHIuc3Vic3RyaW5nKGkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXhwID0gSW50ZWdlci5wYXJzZUludChleHBTdHIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXhwb25lbnQgJyArIGV4cFN0ciArICcgaW4gc3RyaW5nICcgKyBzdHIpXG4gICAgICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgICAgIH0gZmluYWxseSB7fVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIicgYXQgcG9zaXRpb24gXCIgKyBpICsgJyBpbiBzdHJpbmcgJyArIHN0cilcbiAgfVxuICB2YXIgdmFsMiA9IHZhbDtcbiAgdmFyIG51bURlY1BsYWNlcyA9IG51bURpZ2l0cyAtIG51bUJlZm9yZURlYyAtIGV4cDtcbiAgaWYgKG51bURlY1BsYWNlcyA9PT0gMCkge1xuICAgIHZhbDIgPSB2YWw7XG4gIH0gZWxzZSBpZiAobnVtRGVjUGxhY2VzID4gMCkge1xuICAgIHZhciBzY2FsZSA9IERELlRFTi5wb3cobnVtRGVjUGxhY2VzKTtcbiAgICB2YWwyID0gdmFsLmRpdmlkZShzY2FsZSk7XG4gIH0gZWxzZSBpZiAobnVtRGVjUGxhY2VzIDwgMCkge1xuICAgIHZhciBzY2FsZSQxID0gREQuVEVOLnBvdygtbnVtRGVjUGxhY2VzKTtcbiAgICB2YWwyID0gdmFsLm11bHRpcGx5KHNjYWxlJDEpO1xuICB9XG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgcmV0dXJuIHZhbDIubmVnYXRlKClcbiAgfVxuICByZXR1cm4gdmFsMlxufTtcbkRELmNyZWF0ZU5hTiA9IGZ1bmN0aW9uIGNyZWF0ZU5hTiAoKSB7XG4gIHJldHVybiBuZXcgREQoRG91YmxlLk5hTiwgRG91YmxlLk5hTilcbn07XG5ERC5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGQpIHtcbiAgcmV0dXJuIG5ldyBERChkZClcbn07XG5ERC5tYWduaXR1ZGUgPSBmdW5jdGlvbiBtYWduaXR1ZGUgKHgpIHtcbiAgdmFyIHhBYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyIHhMb2cxMCA9IE1hdGgubG9nKHhBYnMpIC8gTWF0aC5sb2coMTApO1xuICB2YXIgeE1hZyA9IE1hdGgudHJ1bmMoTWF0aC5mbG9vcih4TG9nMTApKTtcbiAgdmFyIHhBcHByb3ggPSBNYXRoLnBvdygxMCwgeE1hZyk7XG4gIGlmICh4QXBwcm94ICogMTAgPD0geEFicykgeyB4TWFnICs9IDE7IH1cbiAgcmV0dXJuIHhNYWdcbn07XG5ERC5zdHJpbmdPZkNoYXIgPSBmdW5jdGlvbiBzdHJpbmdPZkNoYXIgKGNoLCBsZW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1Zi5hcHBlbmQoY2gpO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlBJLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCgzLjE0MTU5MjY1MzU4OTc5MzExNmUrMDAsIDEuMjI0NjQ2Nzk5MTQ3MzUzMjA3ZS0xNikgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlRXT19QSS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoNi4yODMxODUzMDcxNzk1ODYyMzJlKzAwLCAyLjQ0OTI5MzU5ODI5NDcwNjQxNGUtMTYpIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5QSV8yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCgxLjU3MDc5NjMyNjc5NDg5NjU1OGUrMDAsIDYuMTIzMjMzOTk1NzM2NzY2MDM2ZS0xNykgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKDIuNzE4MjgxODI4NDU5MDQ1MDkxZSswMCwgMS40NDU2NDY4OTE3MjkyNTAxNThlLTE2KSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuTmFOLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERChEb3VibGUuTmFOLCBEb3VibGUuTmFOKSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuRVBTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMjMyNTk1MTY0NDA3ODNlLTMyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5TUExJVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMzQyMTc3MjkuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDcuTUFYX1BSSU5UX0RJR0lUUy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMiB9O1xuc3RhdGljQWNjZXNzb3JzJDcuVEVOLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERELnZhbHVlT2YoMTAuMCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3Lk9ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBERC52YWx1ZU9mKDEuMCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlNDSV9OT1RfRVhQT05FTlRfQ0hBUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnRScgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlNDSV9OT1RfWkVSTy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnMC4wRTAnIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBERCwgc3RhdGljQWNjZXNzb3JzJDcgKTtcblxudmFyIENHQWxnb3JpdGhtc0REID0gZnVuY3Rpb24gQ0dBbGdvcml0aG1zREQgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNiA9IHsgRFBfU0FGRV9FUFNJTE9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkNHQWxnb3JpdGhtc0RELnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ0dBbGdvcml0aG1zREQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zRERcbn07XG5DR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4ID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleCAocDEsIHAyLCBxKSB7XG4gIHZhciBpbmRleCA9IENHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIocDEsIHAyLCBxKTtcbiAgaWYgKGluZGV4IDw9IDEpIHsgcmV0dXJuIGluZGV4IH1cbiAgdmFyIGR4MSA9IERELnZhbHVlT2YocDIueCkuc2VsZkFkZCgtcDEueCk7XG4gIHZhciBkeTEgPSBERC52YWx1ZU9mKHAyLnkpLnNlbGZBZGQoLXAxLnkpO1xuICB2YXIgZHgyID0gREQudmFsdWVPZihxLngpLnNlbGZBZGQoLXAyLngpO1xuICB2YXIgZHkyID0gREQudmFsdWVPZihxLnkpLnNlbGZBZGQoLXAyLnkpO1xuICByZXR1cm4gZHgxLnNlbGZNdWx0aXBseShkeTIpLnNlbGZTdWJ0cmFjdChkeTEuc2VsZk11bHRpcGx5KGR4MikpLnNpZ251bSgpXG59O1xuQ0dBbGdvcml0aG1zREQuc2lnbk9mRGV0MngyID0gZnVuY3Rpb24gc2lnbk9mRGV0MngyICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZGV0ID0geDEubXVsdGlwbHkoeTIpLnNlbGZTdWJ0cmFjdCh5MS5tdWx0aXBseSh4MikpO1xuICByZXR1cm4gZGV0LnNpZ251bSgpXG59O1xuQ0dBbGdvcml0aG1zREQuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICB2YXIgZGVub20xID0gREQudmFsdWVPZihxMi55KS5zZWxmU3VidHJhY3QocTEueSkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDIueCkuc2VsZlN1YnRyYWN0KHAxLngpKTtcbiAgdmFyIGRlbm9tMiA9IERELnZhbHVlT2YocTIueCkuc2VsZlN1YnRyYWN0KHExLngpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAyLnkpLnNlbGZTdWJ0cmFjdChwMS55KSk7XG4gIHZhciBkZW5vbSA9IGRlbm9tMS5zdWJ0cmFjdChkZW5vbTIpO1xuICB2YXIgbnVteDEgPSBERC52YWx1ZU9mKHEyLngpLnNlbGZTdWJ0cmFjdChxMS54KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS55KS5zZWxmU3VidHJhY3QocTEueSkpO1xuICB2YXIgbnVteDIgPSBERC52YWx1ZU9mKHEyLnkpLnNlbGZTdWJ0cmFjdChxMS55KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS54KS5zZWxmU3VidHJhY3QocTEueCkpO1xuICB2YXIgbnVteCA9IG51bXgxLnN1YnRyYWN0KG51bXgyKTtcbiAgdmFyIGZyYWNQID0gbnVteC5zZWxmRGl2aWRlKGRlbm9tKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgeCA9IERELnZhbHVlT2YocDEueCkuc2VsZkFkZChERC52YWx1ZU9mKHAyLngpLnNlbGZTdWJ0cmFjdChwMS54KS5zZWxmTXVsdGlwbHkoZnJhY1ApKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgbnVteTEgPSBERC52YWx1ZU9mKHAyLngpLnNlbGZTdWJ0cmFjdChwMS54KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS55KS5zZWxmU3VidHJhY3QocTEueSkpO1xuICB2YXIgbnVteTIgPSBERC52YWx1ZU9mKHAyLnkpLnNlbGZTdWJ0cmFjdChwMS55KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS54KS5zZWxmU3VidHJhY3QocTEueCkpO1xuICB2YXIgbnVteSA9IG51bXkxLnN1YnRyYWN0KG51bXkyKTtcbiAgdmFyIGZyYWNRID0gbnVteS5zZWxmRGl2aWRlKGRlbm9tKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgeSA9IERELnZhbHVlT2YocTEueSkuc2VsZkFkZChERC52YWx1ZU9mKHEyLnkpLnNlbGZTdWJ0cmFjdChxMS55KS5zZWxmTXVsdGlwbHkoZnJhY1EpKS5kb3VibGVWYWx1ZSgpO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoeCwgeSlcbn07XG5DR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4RmlsdGVyID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleEZpbHRlciAocGEsIHBiLCBwYykge1xuICB2YXIgZGV0c3VtID0gbnVsbDtcbiAgdmFyIGRldGxlZnQgPSAocGEueCAtIHBjLngpICogKHBiLnkgLSBwYy55KTtcbiAgdmFyIGRldHJpZ2h0ID0gKHBhLnkgLSBwYy55KSAqIChwYi54IC0gcGMueCk7XG4gIHZhciBkZXQgPSBkZXRsZWZ0IC0gZGV0cmlnaHQ7XG4gIGlmIChkZXRsZWZ0ID4gMC4wKSB7XG4gICAgaWYgKGRldHJpZ2h0IDw9IDAuMCkge1xuICAgICAgcmV0dXJuIENHQWxnb3JpdGhtc0RELnNpZ251bShkZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRldHN1bSA9IGRldGxlZnQgKyBkZXRyaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGV0bGVmdCA8IDAuMCkge1xuICAgIGlmIChkZXRyaWdodCA+PSAwLjApIHtcbiAgICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXRzdW0gPSAtZGV0bGVmdCAtIGRldHJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zREQuc2lnbnVtKGRldClcbiAgfVxuICB2YXIgZXJyYm91bmQgPSBDR0FsZ29yaXRobXNERC5EUF9TQUZFX0VQU0lMT04gKiBkZXRzdW07XG4gIGlmIChkZXQgPj0gZXJyYm91bmQgfHwgLWRldCA+PSBlcnJib3VuZCkge1xuICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICB9XG4gIHJldHVybiAyXG59O1xuQ0dBbGdvcml0aG1zREQuc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtICh4KSB7XG4gIGlmICh4ID4gMCkgeyByZXR1cm4gMSB9XG4gIGlmICh4IDwgMCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gMFxufTtcbnN0YXRpY0FjY2Vzc29ycyQ2LkRQX1NBRkVfRVBTSUxPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxZS0xNSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ0dBbGdvcml0aG1zREQsIHN0YXRpY0FjY2Vzc29ycyQ2ICk7XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2UgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkOCA9IHsgWDogeyBjb25maWd1cmFibGU6IHRydWUgfSxZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFo6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkOC5YLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQ4LlkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDguWi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkOC5NLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuc2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRPcmRpbmF0ZSAoaW5kZXgsIG9yZGluYXRlSW5kZXgsIHZhbHVlKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4KSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVDb3B5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUNvcHkgKGkpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYIChpbmRleCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmV4cGFuZEVudmVsb3BlID0gZnVuY3Rpb24gZXhwYW5kRW52ZWxvcGUgKGVudikge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoaW5kZXgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS50b0Nvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIHRvQ29vcmRpbmF0ZUFycmF5ICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDbG9uYWJsZV1cbn07XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZVNlcXVlbmNlLCBzdGF0aWNBY2Nlc3NvcnMkOCApO1xuXG52YXIgRXhjZXB0aW9uID0gZnVuY3Rpb24gRXhjZXB0aW9uICgpIHt9O1xuXG52YXIgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoRXhjZXB0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24gKCkge1xuICAgIEV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMsICdQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuJyk7XG4gIH1cblxuICBpZiAoIEV4Y2VwdGlvbiQkMSApIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24uX19wcm90b19fID0gRXhjZXB0aW9uJCQxO1xuICBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV4Y2VwdGlvbiQkMSAmJiBFeGNlcHRpb24kJDEucHJvdG90eXBlICk7XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbjtcbiAgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uXG4gIH07XG5cbiAgcmV0dXJuIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb247XG59KEV4Y2VwdGlvbikpO1xuXG52YXIgU3lzdGVtID0gZnVuY3Rpb24gU3lzdGVtICgpIHt9O1xuXG5TeXN0ZW0uYXJyYXljb3B5ID0gZnVuY3Rpb24gYXJyYXljb3B5IChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuKSB7XG4gIHZhciBjID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BvczsgaSA8IHNyY1BvcyArIGxlbjsgaSsrKSB7XG4gICAgZGVzdFtkZXN0UG9zICsgY10gPSBzcmNbaV07XG4gICAgYysrO1xuICB9XG59O1xuXG5TeXN0ZW0uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eSAobmFtZSkge1xuICByZXR1cm4ge1xuICAgICdsaW5lLnNlcGFyYXRvcic6ICdcXG4nXG4gIH1bbmFtZV1cbn07XG5cbnZhciBIQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIEhDb29yZGluYXRlICgpIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgdGhpcy53ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnggPSAwLjA7XG4gICAgdGhpcy55ID0gMC4wO1xuICAgIHRoaXMudyA9IDEuMDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy54ID0gcC54O1xuICAgIHRoaXMueSA9IHAueTtcbiAgICB0aGlzLncgPSAxLjA7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIF94ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIF95ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy54ID0gX3g7XG4gICAgICB0aGlzLnkgPSBfeTtcbiAgICAgIHRoaXMudyA9IDEuMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEhDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEhDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnggPSBwMS55ICogcDIudyAtIHAyLnkgKiBwMS53O1xuICAgICAgdGhpcy55ID0gcDIueCAqIHAxLncgLSBwMS54ICogcDIudztcbiAgICAgIHRoaXMudyA9IHAxLnggKiBwMi55IC0gcDIueCAqIHAxLnk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHAyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnggPSBwMSQxLnkgLSBwMiQxLnk7XG4gICAgICB0aGlzLnkgPSBwMiQxLnggLSBwMSQxLng7XG4gICAgICB0aGlzLncgPSBwMSQxLnggKiBwMiQxLnkgLSBwMiQxLnggKiBwMSQxLnk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgX3gkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgX3kkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgX3cgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy54ID0gX3gkMTtcbiAgICB0aGlzLnkgPSBfeSQxO1xuICAgIHRoaXMudyA9IF93O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgcDEkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHEyID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBweCA9IHAxJDIueSAtIHAyJDIueTtcbiAgICB2YXIgcHkgPSBwMiQyLnggLSBwMSQyLng7XG4gICAgdmFyIHB3ID0gcDEkMi54ICogcDIkMi55IC0gcDIkMi54ICogcDEkMi55O1xuICAgIHZhciBxeCA9IHExLnkgLSBxMi55O1xuICAgIHZhciBxeSA9IHEyLnggLSBxMS54O1xuICAgIHZhciBxdyA9IHExLnggKiBxMi55IC0gcTIueCAqIHExLnk7XG4gICAgdGhpcy54ID0gcHkgKiBxdyAtIHF5ICogcHc7XG4gICAgdGhpcy55ID0gcXggKiBwdyAtIHB4ICogcXc7XG4gICAgdGhpcy53ID0gcHggKiBxeSAtIHF4ICogcHk7XG4gIH1cbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKCkge1xuICB2YXIgYSA9IHRoaXMueSAvIHRoaXMudztcbiAgaWYgKERvdWJsZS5pc05hTihhKSB8fCBEb3VibGUuaXNJbmZpbml0ZShhKSkge1xuICAgIHRocm93IG5ldyBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gYVxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCAoKSB7XG4gIHZhciBhID0gdGhpcy54IC8gdGhpcy53O1xuICBpZiAoRG91YmxlLmlzTmFOKGEpIHx8IERvdWJsZS5pc0luZmluaXRlKGEpKSB7XG4gICAgdGhyb3cgbmV3IE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24oKVxuICB9XG4gIHJldHVybiBhXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgdmFyIHAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICBwLnggPSB0aGlzLmdldFgoKTtcbiAgcC55ID0gdGhpcy5nZXRZKCk7XG4gIHJldHVybiBwXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBIQ29vcmRpbmF0ZVxufTtcbkhDb29yZGluYXRlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgdmFyIHB4ID0gcDEueSAtIHAyLnk7XG4gIHZhciBweSA9IHAyLnggLSBwMS54O1xuICB2YXIgcHcgPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICB2YXIgcXggPSBxMS55IC0gcTIueTtcbiAgdmFyIHF5ID0gcTIueCAtIHExLng7XG4gIHZhciBxdyA9IHExLnggKiBxMi55IC0gcTIueCAqIHExLnk7XG4gIHZhciB4ID0gcHkgKiBxdyAtIHF5ICogcHc7XG4gIHZhciB5ID0gcXggKiBwdyAtIHB4ICogcXc7XG4gIHZhciB3ID0gcHggKiBxeSAtIHF4ICogcHk7XG4gIHZhciB4SW50ID0geCAvIHc7XG4gIHZhciB5SW50ID0geSAvIHc7XG4gIGlmIChEb3VibGUuaXNOYU4oeEludCkgfHwgKERvdWJsZS5pc0luZmluaXRlKHhJbnQpIHx8IERvdWJsZS5pc05hTih5SW50KSkgfHwgRG91YmxlLmlzSW5maW5pdGUoeUludCkpIHtcbiAgICB0aHJvdyBuZXcgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbigpXG4gIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHhJbnQsIHlJbnQpXG59O1xuXG52YXIgRW52ZWxvcGUgPSBmdW5jdGlvbiBFbnZlbG9wZSAoKSB7XG4gIHRoaXMuX21pbnggPSBudWxsO1xuICB0aGlzLl9tYXh4ID0gbnVsbDtcbiAgdGhpcy5fbWlueSA9IG51bGw7XG4gIHRoaXMuX21heHkgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQocC54LCBwLngsIHAueSwgcC55KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgZW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGVudik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuaW5pdChwMS54LCBwMi54LCBwMS55LCBwMi55KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHgxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHkyID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuaW5pdCh4MSwgeDIsIHkxLCB5Mik7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkOSA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KClcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEVudmVsb3BlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBvdGhlckVudmVsb3BlID0gb3RoZXI7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIG90aGVyRW52ZWxvcGUuaXNOdWxsKClcbiAgfVxuICByZXR1cm4gdGhpcy5fbWF4eCA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNYXhYKCkgJiYgdGhpcy5fbWF4eSA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNYXhZKCkgJiYgdGhpcy5fbWlueCA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNaW5YKCkgJiYgdGhpcy5fbWlueSA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNaW5ZKClcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChlbnYpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkgfHwgZW52LmlzTnVsbCgpIHx8ICF0aGlzLmludGVyc2VjdHMoZW52KSkgeyByZXR1cm4gbmV3IEVudmVsb3BlKCkgfVxuICB2YXIgaW50TWluWCA9IHRoaXMuX21pbnggPiBlbnYuX21pbnggPyB0aGlzLl9taW54IDogZW52Ll9taW54O1xuICB2YXIgaW50TWluWSA9IHRoaXMuX21pbnkgPiBlbnYuX21pbnkgPyB0aGlzLl9taW55IDogZW52Ll9taW55O1xuICB2YXIgaW50TWF4WCA9IHRoaXMuX21heHggPCBlbnYuX21heHggPyB0aGlzLl9tYXh4IDogZW52Ll9tYXh4O1xuICB2YXIgaW50TWF4WSA9IHRoaXMuX21heHkgPCBlbnYuX21heHkgPyB0aGlzLl9tYXh5IDogZW52Ll9tYXh5O1xuICByZXR1cm4gbmV3IEVudmVsb3BlKGludE1pblgsIGludE1heFgsIGludE1pblksIGludE1heFkpXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh4IDwgdGhpcy5fbWlueFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gZ2V0TWF4WCAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh4XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNvdmVycyA9IGZ1bmN0aW9uIGNvdmVycyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY292ZXJzKHAueCwgcC55KVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLmlzTnVsbCgpIHx8IG90aGVyLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVyLmdldE1pblgoKSA+PSB0aGlzLl9taW54ICYmIG90aGVyLmdldE1heFgoKSA8PSB0aGlzLl9tYXh4ICYmIG90aGVyLmdldE1pblkoKSA+PSB0aGlzLl9taW55ICYmIG90aGVyLmdldE1heFkoKSA8PSB0aGlzLl9tYXh5XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB4ID49IHRoaXMuX21pbnggJiYgeCA8PSB0aGlzLl9tYXh4ICYmIHkgPj0gdGhpcy5fbWlueSAmJiB5IDw9IHRoaXMuX21heHlcbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc051bGwoKSB8fCBvdGhlci5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiAhKG90aGVyLl9taW54ID4gdGhpcy5fbWF4eCB8fCBvdGhlci5fbWF4eCA8IHRoaXMuX21pbnggfHwgb3RoZXIuX21pbnkgPiB0aGlzLl9tYXh5IHx8IG90aGVyLl9tYXh5IDwgdGhpcy5fbWlueSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhwLngsIHAueSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICEoeCA+IHRoaXMuX21heHggfHwgeCA8IHRoaXMuX21pbnggfHwgeSA+IHRoaXMuX21heHkgfHwgeSA8IHRoaXMuX21pbnkpXG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uIGdldE1pblkgKCkge1xuICByZXR1cm4gdGhpcy5fbWlueVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gZ2V0TWluWCAoKSB7XG4gIHJldHVybiB0aGlzLl9taW54XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmV4cGFuZFRvSW5jbHVkZSA9IGZ1bmN0aW9uIGV4cGFuZFRvSW5jbHVkZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5leHBhbmRUb0luY2x1ZGUocC54LCBwLnkpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChvdGhlci5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICAgICAgdGhpcy5fbWlueCA9IG90aGVyLmdldE1pblgoKTtcbiAgICAgICAgdGhpcy5fbWF4eCA9IG90aGVyLmdldE1heFgoKTtcbiAgICAgICAgdGhpcy5fbWlueSA9IG90aGVyLmdldE1pblkoKTtcbiAgICAgICAgdGhpcy5fbWF4eSA9IG90aGVyLmdldE1heFkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdGhlci5fbWlueCA8IHRoaXMuX21pbngpIHtcbiAgICAgICAgICB0aGlzLl9taW54ID0gb3RoZXIuX21pbng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLl9tYXh4ID4gdGhpcy5fbWF4eCkge1xuICAgICAgICAgIHRoaXMuX21heHggPSBvdGhlci5fbWF4eDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuX21pbnkgPCB0aGlzLl9taW55KSB7XG4gICAgICAgICAgdGhpcy5fbWlueSA9IG90aGVyLl9taW55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbWF4eSA+IHRoaXMuX21heHkpIHtcbiAgICAgICAgICB0aGlzLl9tYXh5ID0gb3RoZXIuX21heHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgICB0aGlzLl9taW54ID0geDtcbiAgICAgIHRoaXMuX21heHggPSB4O1xuICAgICAgdGhpcy5fbWlueSA9IHk7XG4gICAgICB0aGlzLl9tYXh5ID0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHggPCB0aGlzLl9taW54KSB7XG4gICAgICAgIHRoaXMuX21pbnggPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHggPiB0aGlzLl9tYXh4KSB7XG4gICAgICAgIHRoaXMuX21heHggPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHkgPCB0aGlzLl9taW55KSB7XG4gICAgICAgIHRoaXMuX21pbnkgPSB5O1xuICAgICAgfVxuICAgICAgaWYgKHkgPiB0aGlzLl9tYXh5KSB7XG4gICAgICAgIHRoaXMuX21heHkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5taW5FeHRlbnQgPSBmdW5jdGlvbiBtaW5FeHRlbnQgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIHcgPSB0aGlzLmdldFdpZHRoKCk7XG4gIHZhciBoID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgaWYgKHcgPCBoKSB7IHJldHVybiB3IH1cbiAgcmV0dXJuIGhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICByZXR1cm4gdGhpcy5fbWF4eCAtIHRoaXMuX21pbnhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBlbnYgPSBvO1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIGlmIChlbnYuaXNOdWxsKCkpIHsgcmV0dXJuIDAgfVxuICAgIHJldHVybiAtMVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYuaXNOdWxsKCkpIHsgcmV0dXJuIDEgfVxuICB9XG4gIGlmICh0aGlzLl9taW54IDwgZW52Ll9taW54KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9taW54ID4gZW52Ll9taW54KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX21pbnkgPCBlbnYuX21pbnkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX21pbnkgPiBlbnYuX21pbnkpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbWF4eCA8IGVudi5fbWF4eCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbWF4eCA+IGVudi5fbWF4eCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9tYXh5IDwgZW52Ll9tYXh5KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9tYXh5ID4gZW52Ll9tYXh5KSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlICh0cmFuc1gsIHRyYW5zWSkge1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpICsgdHJhbnNYLCB0aGlzLmdldE1heFgoKSArIHRyYW5zWCwgdGhpcy5nZXRNaW5ZKCkgKyB0cmFuc1ksIHRoaXMuZ2V0TWF4WSgpICsgdHJhbnNZKTtcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnRW52WycgKyB0aGlzLl9taW54ICsgJyA6ICcgKyB0aGlzLl9tYXh4ICsgJywgJyArIHRoaXMuX21pbnkgKyAnIDogJyArIHRoaXMuX21heHkgKyAnXSdcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuc2V0VG9OdWxsID0gZnVuY3Rpb24gc2V0VG9OdWxsICgpIHtcbiAgdGhpcy5fbWlueCA9IDA7XG4gIHRoaXMuX21heHggPSAtMTtcbiAgdGhpcy5fbWlueSA9IDA7XG4gIHRoaXMuX21heHkgPSAtMTtcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0ICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHJldHVybiB0aGlzLl9tYXh5IC0gdGhpcy5fbWlueVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5tYXhFeHRlbnQgPSBmdW5jdGlvbiBtYXhFeHRlbnQgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIHcgPSB0aGlzLmdldFdpZHRoKCk7XG4gIHZhciBoID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgaWYgKHcgPiBoKSB7IHJldHVybiB3IH1cbiAgcmV0dXJuIGhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZXhwYW5kQnkgPSBmdW5jdGlvbiBleHBhbmRCeSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuZXhwYW5kQnkoZGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlbHRhWCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGVsdGFZID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLl9taW54IC09IGRlbHRhWDtcbiAgICB0aGlzLl9tYXh4ICs9IGRlbHRhWDtcbiAgICB0aGlzLl9taW55IC09IGRlbHRhWTtcbiAgICB0aGlzLl9tYXh5ICs9IGRlbHRhWTtcbiAgICBpZiAodGhpcy5fbWlueCA+IHRoaXMuX21heHggfHwgdGhpcy5fbWlueSA+IHRoaXMuX21heHkpIHsgdGhpcy5zZXRUb051bGwoKTsgfVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY292ZXJzKG90aGVyKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3ZlcnMocClcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzLmNvdmVycyh4LCB5KVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNlbnRyZSA9IGZ1bmN0aW9uIGNlbnRyZSAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKCh0aGlzLmdldE1pblgoKSArIHRoaXMuZ2V0TWF4WCgpKSAvIDIuMCwgKHRoaXMuZ2V0TWluWSgpICsgdGhpcy5nZXRNYXhZKCkpIC8gMi4wKVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5zZXRUb051bGwoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KHAueCwgcC54LCBwLnksIHAueSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIGVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX21pbnggPSBlbnYuX21pbng7XG4gICAgICB0aGlzLl9tYXh4ID0gZW52Ll9tYXh4O1xuICAgICAgdGhpcy5fbWlueSA9IGVudi5fbWlueTtcbiAgICAgIHRoaXMuX21heHkgPSBlbnYuX21heHk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuaW5pdChwMS54LCBwMi54LCBwMS55LCBwMi55KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHgxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHkyID0gYXJndW1lbnRzWzNdO1xuICAgIGlmICh4MSA8IHgyKSB7XG4gICAgICB0aGlzLl9taW54ID0geDE7XG4gICAgICB0aGlzLl9tYXh4ID0geDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21pbnggPSB4MjtcbiAgICAgIHRoaXMuX21heHggPSB4MTtcbiAgICB9XG4gICAgaWYgKHkxIDwgeTIpIHtcbiAgICAgIHRoaXMuX21pbnkgPSB5MTtcbiAgICAgIHRoaXMuX21heHkgPSB5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWlueSA9IHkyO1xuICAgICAgdGhpcy5fbWF4eSA9IHkxO1xuICAgIH1cbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNYXhZID0gZnVuY3Rpb24gZ2V0TWF4WSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh5XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGVudikge1xuICBpZiAodGhpcy5pbnRlcnNlY3RzKGVudikpIHsgcmV0dXJuIDAgfVxuICB2YXIgZHggPSAwLjA7XG4gIGlmICh0aGlzLl9tYXh4IDwgZW52Ll9taW54KSB7IGR4ID0gZW52Ll9taW54IC0gdGhpcy5fbWF4eDsgfSBlbHNlIGlmICh0aGlzLl9taW54ID4gZW52Ll9tYXh4KSB7IGR4ID0gdGhpcy5fbWlueCAtIGVudi5fbWF4eDsgfVxuICB2YXIgZHkgPSAwLjA7XG4gIGlmICh0aGlzLl9tYXh5IDwgZW52Ll9taW55KSB7IGR5ID0gZW52Ll9taW55IC0gdGhpcy5fbWF4eTsgfSBlbHNlIGlmICh0aGlzLl9taW55ID4gZW52Ll9tYXh5KSB7IGR5ID0gdGhpcy5fbWlueSAtIGVudi5fbWF4eTsgfVxuICBpZiAoZHggPT09IDAuMCkgeyByZXR1cm4gZHkgfVxuICBpZiAoZHkgPT09IDAuMCkgeyByZXR1cm4gZHggfVxuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgdmFyIHJlc3VsdCA9IDE3O1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWlueCk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLl9tYXh4KTtcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMuX21pbnkpO1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWF4eSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVudmVsb3BlXG59O1xuRW52ZWxvcGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHEueCA+PSAocDEueCA8IHAyLnggPyBwMS54IDogcDIueCkgJiYgcS54IDw9IChwMS54ID4gcDIueCA/IHAxLnggOiBwMi54KSAmJiAocS55ID49IChwMS55IDwgcDIueSA/IHAxLnkgOiBwMi55KSAmJiBxLnkgPD0gKHAxLnkgPiBwMi55ID8gcDEueSA6IHAyLnkpKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgcTIgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIG1pbnEgPSBNYXRoLm1pbihxMS54LCBxMi54KTtcbiAgICB2YXIgbWF4cSA9IE1hdGgubWF4KHExLngsIHEyLngpO1xuICAgIHZhciBtaW5wID0gTWF0aC5taW4ocDEkMS54LCBwMiQxLngpO1xuICAgIHZhciBtYXhwID0gTWF0aC5tYXgocDEkMS54LCBwMiQxLngpO1xuICAgIGlmIChtaW5wID4gbWF4cSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChtYXhwIDwgbWlucSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIG1pbnEgPSBNYXRoLm1pbihxMS55LCBxMi55KTtcbiAgICBtYXhxID0gTWF0aC5tYXgocTEueSwgcTIueSk7XG4gICAgbWlucCA9IE1hdGgubWluKHAxJDEueSwgcDIkMS55KTtcbiAgICBtYXhwID0gTWF0aC5tYXgocDEkMS55LCBwMiQxLnkpO1xuICAgIGlmIChtaW5wID4gbWF4cSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChtYXhwIDwgbWlucSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMkOS5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDU4NzM5MjE4ODUyNzMxMDI0MjAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEVudmVsb3BlLCBzdGF0aWNBY2Nlc3NvcnMkOSApO1xuXG52YXIgcmVnRXhlcyA9IHtcbiAgJ3R5cGVTdHInOiAvXlxccyooXFx3KylcXHMqXFwoXFxzKiguKilcXHMqXFwpXFxzKiQvLFxuICAnZW1wdHlUeXBlU3RyJzogL15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLFxuICAnc3BhY2VzJzogL1xccysvLFxuICAncGFyZW5Db21tYSc6IC9cXClcXHMqLFxccypcXCgvLFxuICAnZG91YmxlUGFyZW5Db21tYSc6IC9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sIC8vIGNhbid0IHVzZSB7Mn0gaGVyZVxuICAndHJpbVBhcmVucyc6IC9eXFxzKlxcKD8oLio/KVxcKT9cXHMqJC9cbn07XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgV2VsbC1Lbm93biBUZXh0LlxuICpcbiAqIE5PVEU6IEFkYXB0ZWQgZnJvbSBPcGVuTGF5ZXJzIDIuMTEgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuLyoqIENyZWF0ZSBhIG5ldyBwYXJzZXIgZm9yIFdLVFxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgV0tUUGFyc2VyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgV0tUUGFyc2VyID0gZnVuY3Rpb24gV0tUUGFyc2VyIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgdGhpcy5nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3RvcnkgfHwgbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xufTtcbi8qKlxuICogRGVzZXJpYWxpemUgYSBXS1Qgc3RyaW5nIGFuZCByZXR1cm4gYSBnZW9tZXRyeS4gU3VwcG9ydHMgV0tUIGZvciBQT0lOVCxcbiAqIE1VTFRJUE9JTlQsIExJTkVTVFJJTkcsIExJTkVBUlJJTkcsIE1VTFRJTElORVNUUklORywgUE9MWUdPTiwgTVVMVElQT0xZR09OLFxuICogYW5kIEdFT01FVFJZQ09MTEVDVElPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gd2t0IEEgV0tUIHN0cmluZy5cbiAqIEByZXR1cm4ge0dlb21ldHJ5fSBBIGdlb21ldHJ5IGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuV0tUUGFyc2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAod2t0KSB7XG4gIHZhciBnZW9tZXRyeSwgdHlwZSwgc3RyO1xuICB3a3QgPSB3a3QucmVwbGFjZSgvW1xcblxccl0vZywgJyAnKTtcbiAgdmFyIG1hdGNoZXMgPSByZWdFeGVzLnR5cGVTdHIuZXhlYyh3a3QpO1xuICBpZiAod2t0LnNlYXJjaCgnRU1QVFknKSAhPT0gLTEpIHtcbiAgICBtYXRjaGVzID0gcmVnRXhlcy5lbXB0eVR5cGVTdHIuZXhlYyh3a3QpO1xuICAgIG1hdGNoZXNbMl0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICB0eXBlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgIHN0ciA9IG1hdGNoZXNbMl07XG4gICAgaWYgKHBhcnNlJDFbdHlwZV0pIHtcbiAgICAgIGdlb21ldHJ5ID0gcGFyc2UkMVt0eXBlXS5hcHBseSh0aGlzLCBbc3RyXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdlb21ldHJ5ID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgV0tUICcgKyB3a3QpIH1cblxuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgZ2VvbWV0cnkgaW50byBhIFdLVCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgQSBmZWF0dXJlIG9yIGFycmF5IG9mIGZlYXR1cmVzLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgV0tUIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQgZ2VvbWV0cmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoZ2VvbWV0cnkpIHtcbiAgcmV0dXJuIHRoaXMuZXh0cmFjdEdlb21ldHJ5KGdlb21ldHJ5KVxufTtcblxuLyoqXG4gKiBFbnRyeSBwb2ludCB0byBjb25zdHJ1Y3QgdGhlIFdLVCBmb3IgYSBzaW5nbGUgR2VvbWV0cnkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgV0tUIHN0cmluZyBvZiByZXByZXNlbnRpbmcgdGhlIGdlb21ldHJ5LlxuICogQHByaXZhdGVcbiAqL1xuV0tUUGFyc2VyLnByb3RvdHlwZS5leHRyYWN0R2VvbWV0cnkgPSBmdW5jdGlvbiBleHRyYWN0R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cnlUeXBlKCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFleHRyYWN0JDFbdHlwZV0pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB3a3RUeXBlID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgZGF0YTtcbiAgaWYgKGdlb21ldHJ5LmlzRW1wdHkoKSkge1xuICAgIGRhdGEgPSB3a3RUeXBlICsgJyBFTVBUWSc7XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IHdrdFR5cGUgKyAnKCcgKyBleHRyYWN0JDFbdHlwZV0uYXBwbHkodGhpcywgW2dlb21ldHJ5XSkgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn07XG5cbi8qKlxuICogT2JqZWN0IHdpdGggcHJvcGVydGllcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnZW9tZXRyeSB0eXBlcy4gUHJvcGVydHkgdmFsdWVzXG4gKiBhcmUgZnVuY3Rpb25zIHRoYXQgZG8gdGhlIGFjdHVhbCBkYXRhIGV4dHJhY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXh0cmFjdCQxID0ge1xuICBjb29yZGluYXRlOiBmdW5jdGlvbiBjb29yZGluYXRlIChjb29yZGluYXRlJDEpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZSQxLnggKyAnICcgKyBjb29yZGluYXRlJDEueVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzcGFjZSBkZWxpbWl0ZWQgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50fVxuICAgKiAgICAgICAgICBwb2ludFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIGNvb3JkaW5hdGVzIHJlcHJlc2VudGluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBwb2ludDogZnVuY3Rpb24gcG9pbnQgKHBvaW50JDEpIHtcbiAgICByZXR1cm4gZXh0cmFjdCQxLmNvb3JkaW5hdGUuY2FsbCh0aGlzLCBwb2ludCQxLl9jb29yZGluYXRlcy5fY29vcmRpbmF0ZXNbMF0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZXMgZnJvbSBhIG11bHRpcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2ludH1cbiAgICogICAgICAgICAgbXVsdGlwb2ludFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGUgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlXG4gICAqICAgICAgICAgbXVsdGlwb2ludC5cbiAgICovXG4gIG11bHRpcG9pbnQ6IGZ1bmN0aW9uIG11bHRpcG9pbnQgKG11bHRpcG9pbnQkMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11bHRpcG9pbnQkMS5fZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCgnKCcgKyBleHRyYWN0JDEucG9pbnQuYXBwbHkodGhpcyQxLCBbbXVsdGlwb2ludCQxLl9nZW9tZXRyaWVzW2ldXSkgKyAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZXMgZnJvbSBhIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZXN0cmluZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGUgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqL1xuICBsaW5lc3RyaW5nOiBmdW5jdGlvbiBsaW5lc3RyaW5nIChsaW5lc3RyaW5nJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lc3RyaW5nJDEuX3BvaW50cy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdCQxLmNvb3JkaW5hdGUuYXBwbHkodGhpcyQxLCBbbGluZXN0cmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzW2ldXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgbGluZWFycmluZzogZnVuY3Rpb24gbGluZWFycmluZyAobGluZWFycmluZyQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZWFycmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKGV4dHJhY3QkMS5jb29yZGluYXRlLmFwcGx5KHRoaXMkMSwgW2xpbmVhcnJpbmckMS5fcG9pbnRzLl9jb29yZGluYXRlc1tpXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIGxpbmVzdHJpbmcgc3RyaW5ncyBmcm9tIGFcbiAgICogbXVsdGlsaW5lc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpTGluZVN0cmluZ30gbXVsdGlsaW5lc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgb2Ygb2YgbGluZXN0cmluZyBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKi9cbiAgbXVsdGlsaW5lc3RyaW5nOiBmdW5jdGlvbiBtdWx0aWxpbmVzdHJpbmcgKG11bHRpbGluZXN0cmluZyQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlsaW5lc3RyaW5nJDEuX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICtcbiAgICAgICAgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbbXVsdGlsaW5lc3RyaW5nJDEuX2dlb21ldHJpZXNbaV1dKSArXG4gICAgICAgICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZyBvZiBsaW5lYXIgcmluZyBhcnJheXMgZnJvbSBhIHBvbHlnb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEFuIGFycmF5IG9mIGxpbmVhciByaW5nIGFycmF5cyByZXByZXNlbnRpbmcgdGhlIHBvbHlnb24uXG4gICAqL1xuICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uIChwb2x5Z29uJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcywgW3BvbHlnb24kMS5fc2hlbGxdKSArICcpJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvbHlnb24kMS5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbcG9seWdvbiQxLl9ob2xlc1tpXV0pICsgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgcG9seWdvbiBhcnJheXMgZnJvbSBhIG11bHRpcG9seWdvbi5cbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aVBvbHlnb259IG11bHRpcG9seWdvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEFuIGFycmF5IG9mIHBvbHlnb24gYXJyYXlzIHJlcHJlc2VudGluZyB0aGUgbXVsdGlwb2x5Z29uLlxuICAgKi9cbiAgbXVsdGlwb2x5Z29uOiBmdW5jdGlvbiBtdWx0aXBvbHlnb24gKG11bHRpcG9seWdvbiQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlwb2x5Z29uJDEuX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLnBvbHlnb24uYXBwbHkodGhpcyQxLCBbbXVsdGlwb2x5Z29uJDEuX2dlb21ldHJpZXNbaV1dKSArICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBXS1QgcG9ydGlvbiBiZXR3ZWVuICdHRU9NRVRSWUNPTExFQ1RJT04oJyBhbmQgJyknIGZvciBhblxuICAgKiBnZW9tZXRyeWNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlDb2xsZWN0aW9ufSBjb2xsZWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaW50ZXJuYWwgV0tUIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2VvbWV0cnljb2xsZWN0aW9uOiBmdW5jdGlvbiBnZW9tZXRyeWNvbGxlY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXMkMS5leHRyYWN0R2VvbWV0cnkoY29sbGVjdGlvbi5fZ2VvbWV0cmllc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH1cbn07XG5cbi8qKlxuICogT2JqZWN0IHdpdGggcHJvcGVydGllcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnZW9tZXRyeSB0eXBlcy4gUHJvcGVydHkgdmFsdWVzXG4gKiBhcmUgZnVuY3Rpb25zIHRoYXQgZG8gdGhlIGFjdHVhbCBwYXJzaW5nLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlJDEgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm4gcG9pbnQgZ2VvbWV0cnkgZ2l2ZW4gYSBwb2ludCBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7UG9pbnR9IEEgcG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwb2ludDogZnVuY3Rpb24gcG9pbnQgKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KClcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnNwYWNlcyk7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBDb29yZGluYXRlKE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1swXSksXG4gICAgICBOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMV0pKSlcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlwb2ludCBnZW9tZXRyeSBnaXZlbiBhIG11bHRpcG9pbnQgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7UG9pbnR9IEEgbXVsdGlwb2ludCBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlwb2ludDogZnVuY3Rpb24gbXVsdGlwb2ludCAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KClcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQ7XG4gICAgdmFyIHBvaW50cyA9IHN0ci50cmltKCkuc3BsaXQoJywnKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldLnJlcGxhY2UocmVnRXhlcy50cmltUGFyZW5zLCAnJDEnKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChwYXJzZSQxLnBvaW50LmFwcGx5KHRoaXMkMSwgW3BvaW50XSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaW5lc3RyaW5nIGdlb21ldHJ5IGdpdmVuIGEgbGluZXN0cmluZyBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBBIGxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsaW5lc3RyaW5nOiBmdW5jdGlvbiBsaW5lc3RyaW5nIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKClcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzID0gc3RyLnRyaW0oKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgdmFyIGNvb3JkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb29yZHMgPSBwb2ludHNbaV0udHJpbSgpLnNwbGl0KHJlZ0V4ZXMuc3BhY2VzKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChuZXcgQ29vcmRpbmF0ZShOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMF0pLCBOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMV0pKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpbmVhcnJpbmcgZ2VvbWV0cnkgZ2l2ZW4gYSBsaW5lYXJyaW5nIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIGxpbmVhcnJpbmcuXG4gICAqIEByZXR1cm4ge0xpbmVhclJpbmd9IEEgbGluZWFycmluZyBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxpbmVhcnJpbmc6IGZ1bmN0aW9uIGxpbmVhcnJpbmcgKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKVxuICAgIH1cblxuICAgIHZhciBwb2ludHMgPSBzdHIudHJpbSgpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgY29vcmRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvb3JkcyA9IHBvaW50c1tpXS50cmltKCkuc3BsaXQocmVnRXhlcy5zcGFjZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKG5ldyBDb29yZGluYXRlKE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1swXSksIE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1sxXSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlsaW5lc3RyaW5nIGdlb21ldHJ5IGdpdmVuIGEgbXVsdGlsaW5lc3RyaW5nIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfSBBIG11bHRpbGluZXN0cmluZyBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11bHRpbGluZXN0cmluZzogZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZygpXG4gICAgfVxuXG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGxpbmVzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnBhcmVuQ29tbWEpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsaW5lID0gbGluZXNbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKHBhcnNlJDEubGluZXN0cmluZy5hcHBseSh0aGlzJDEsIFtsaW5lXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHBvbHlnb24gZ2VvbWV0cnkgZ2l2ZW4gYSBwb2x5Z29uIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm4ge1BvbHlnb259IEEgcG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24gKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpXG4gICAgfVxuXG4gICAgdmFyIHJpbmcsIGxpbmVzdHJpbmcsIGxpbmVhcnJpbmc7XG4gICAgdmFyIHJpbmdzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnBhcmVuQ29tbWEpO1xuICAgIHZhciBzaGVsbDtcbiAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHJpbmcgPSByaW5nc1tpXS5yZXBsYWNlKHJlZ0V4ZXMudHJpbVBhcmVucywgJyQxJyk7XG4gICAgICBsaW5lc3RyaW5nID0gcGFyc2UkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMkMSwgW3JpbmddKTtcbiAgICAgIGxpbmVhcnJpbmcgPSB0aGlzJDEuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobGluZXN0cmluZy5fcG9pbnRzKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHNoZWxsID0gbGluZWFycmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvbGVzLnB1c2gobGluZWFycmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlwb2x5Z29uIGdlb21ldHJ5IGdpdmVuIGEgbXVsdGlwb2x5Z29uIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIG11bHRpcG9seWdvbi5cbiAgICogQHJldHVybiB7TXVsdGlQb2x5Z29ufSBBIG11bHRpcG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11bHRpcG9seWdvbjogZnVuY3Rpb24gbXVsdGlwb2x5Z29uIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpXG4gICAgfVxuXG4gICAgdmFyIHBvbHlnb247XG4gICAgdmFyIHBvbHlnb25zID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLmRvdWJsZVBhcmVuQ29tbWEpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBwb2x5Z29uID0gcG9seWdvbnNbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKHBhcnNlJDEucG9seWdvbi5hcHBseSh0aGlzJDEsIFtwb2x5Z29uXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGdlb21ldHJ5Y29sbGVjdGlvbiBnaXZlbiBhIGdlb21ldHJ5Y29sbGVjdGlvbiBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBnZW9tZXRyeWNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5Q29sbGVjdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdlb21ldHJ5Y29sbGVjdGlvbjogZnVuY3Rpb24gZ2VvbWV0cnljb2xsZWN0aW9uIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpXG4gICAgfVxuXG4gICAgLy8gc2VwYXJhdGUgY29tcG9uZW50cyBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHxcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvLFxccyooW0EtWmEtel0pL2csICd8JDEnKTtcbiAgICB2YXIgd2t0QXJyYXkgPSBzdHIudHJpbSgpLnNwbGl0KCd8Jyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd2t0QXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzJDEucmVhZCh3a3RBcnJheVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGNvbXBvbmVudHMpXG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHRoZSBXZWxsLUtub3duIFRleHQgcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgR2VvbWV0cnl9LiBUaGVcbiAqIFdlbGwtS25vd24gVGV4dCBmb3JtYXQgaXMgZGVmaW5lZCBpbiB0aGUgPEFcbiAqIEhSRUY9XCJodHRwOi8vd3d3Lm9wZW5naXMub3JnL3RlY2huby9zcGVjcy5odG1cIj4gT0dDIFNpbXBsZSBGZWF0dXJlc1xuICogU3BlY2lmaWNhdGlvbiBmb3IgU1FMPC9BPi5cbiAqIDxwPlxuICogVGhlIDxjb2RlPldLVFdyaXRlcjwvY29kZT4gb3V0cHV0cyBjb29yZGluYXRlcyByb3VuZGVkIHRvIHRoZSBwcmVjaXNpb25cbiAqIG1vZGVsLiBPbmx5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZVxuICogb3JkaW5hdGVzIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gd2lsbCBiZSBvdXRwdXQuXG4gKiA8cD5cbiAqIFRoZSBTRlMgV0tUIHNwZWMgZG9lcyBub3QgZGVmaW5lIGEgc3BlY2lhbCB0YWcgZm9yIHtAbGluayBMaW5lYXJSaW5nfXMuXG4gKiBVbmRlciB0aGUgc3BlYywgcmluZ3MgYXJlIG91dHB1dCBhcyA8Y29kZT5MSU5FU1RSSU5HPC9jb2RlPnMuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFdLVFdyaXRlciA9IGZ1bmN0aW9uIFdLVFdyaXRlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMucGFyc2VyID0gbmV3IFdLVFBhcnNlcihnZW9tZXRyeUZhY3RvcnkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBpdHMgV2VsbC1rbm93biBUZXh0IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgPEdlb21ldHJ5IFRhZ2dlZCBUZXh0PiBzdHJpbmcgKHNlZSB0aGUgT3BlbkdJUyBTaW1wbGVcbiAqICAgICAgIEZlYXR1cmVzIFNwZWNpZmljYXRpb24pLlxuICogQG1lbWJlcm9mIFdLVFdyaXRlclxuICovXG5XS1RXcml0ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlci53cml0ZShnZW9tZXRyeSlcbn07XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgV0tUIGZvciBhIDx0dD5MSU5FU1RSSU5HPC90dD4gc3BlY2lmaWVkIGJ5IHR3b1xuICoge0BsaW5rIENvb3JkaW5hdGV9cy5cbiAqXG4gKiBAcGFyYW0gcDAgdGhlIGZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0gcDEgdGhlIHNlY29uZCBjb29yZGluYXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIFdLVC5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFdyaXRlci50b0xpbmVTdHJpbmcgPSBmdW5jdGlvbiB0b0xpbmVTdHJpbmcgKHAwLCBwMSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJylcbiAgfVxuICByZXR1cm4gJ0xJTkVTVFJJTkcgKCAnICsgcDAueCArICcgJyArIHAwLnkgKyAnLCAnICsgcDEueCArICcgJyArIHAxLnkgKyAnICknXG59O1xuXG52YXIgUnVudGltZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoRXJyb3IpIHtcbiAgZnVuY3Rpb24gUnVudGltZUV4Y2VwdGlvbiAobWVzc2FnZSkge1xuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1J1bnRpbWVFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH1cblxuICBpZiAoIEVycm9yICkgUnVudGltZUV4Y2VwdGlvbi5fX3Byb3RvX18gPSBFcnJvcjtcbiAgUnVudGltZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvciAmJiBFcnJvci5wcm90b3R5cGUgKTtcbiAgUnVudGltZUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdW50aW1lRXhjZXB0aW9uO1xuXG4gIHJldHVybiBSdW50aW1lRXhjZXB0aW9uO1xufShFcnJvcikpO1xuXG52YXIgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChSdW50aW1lRXhjZXB0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbiAoKSB7XG4gICAgUnVudGltZUV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIFJ1bnRpbWVFeGNlcHRpb24kJDEuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIFJ1bnRpbWVFeGNlcHRpb24kJDEgKSBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24uX19wcm90b19fID0gUnVudGltZUV4Y2VwdGlvbiQkMTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJ1bnRpbWVFeGNlcHRpb24kJDEgJiYgUnVudGltZUV4Y2VwdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbjtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uXG4gIH07XG5cbiAgcmV0dXJuIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbjtcbn0oUnVudGltZUV4Y2VwdGlvbikpO1xuXG52YXIgQXNzZXJ0ID0gZnVuY3Rpb24gQXNzZXJ0ICgpIHt9O1xuXG5Bc3NlcnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Bc3NlcnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQXNzZXJ0XG59O1xuQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlID0gZnVuY3Rpb24gc2hvdWxkTmV2ZXJSZWFjaEhlcmUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbignU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUnICsgKG1lc3NhZ2UgIT09IG51bGwgPyAnOiAnICsgbWVzc2FnZSA6ICcnKSlcbiAgfVxufTtcbkFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiBpc1RydWUgKCkge1xuICB2YXIgYXNzZXJ0aW9uO1xuICB2YXIgbWVzc2FnZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBhc3NlcnRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgQXNzZXJ0LmlzVHJ1ZShhc3NlcnRpb24sIG51bGwpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBhc3NlcnRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgbWVzc2FnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uKG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQXNzZXJ0LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIHZhciBleHBlY3RlZFZhbHVlO1xuICB2YXIgYWN0dWFsVmFsdWU7XG4gIHZhciBtZXNzYWdlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGV4cGVjdGVkVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgYWN0dWFsVmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgQXNzZXJ0LmVxdWFscyhleHBlY3RlZFZhbHVlLCBhY3R1YWxWYWx1ZSwgbnVsbCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGV4cGVjdGVkVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgYWN0dWFsVmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgbWVzc2FnZSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoIWFjdHVhbFZhbHVlLmVxdWFscyhleHBlY3RlZFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbignRXhwZWN0ZWQgJyArIGV4cGVjdGVkVmFsdWUgKyAnIGJ1dCBlbmNvdW50ZXJlZCAnICsgYWN0dWFsVmFsdWUgKyAobWVzc2FnZSAhPT0gbnVsbCA/ICc6ICcgKyBtZXNzYWdlIDogJycpKVxuICAgIH1cbiAgfVxufTtcblxudmFyIExpbmVJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIExpbmVJbnRlcnNlY3RvciAoKSB7XG4gIHRoaXMuX3Jlc3VsdCA9IG51bGw7XG4gIHRoaXMuX2lucHV0TGluZXMgPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDIpOyB9KTtcbiAgdGhpcy5faW50UHQgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdGhpcy5faW50TGluZUluZGV4ID0gbnVsbDtcbiAgdGhpcy5faXNQcm9wZXIgPSBudWxsO1xuICB0aGlzLl9wYSA9IG51bGw7XG4gIHRoaXMuX3BiID0gbnVsbDtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHRoaXMuX2ludFB0WzFdID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgdGhpcy5fcGEgPSB0aGlzLl9pbnRQdFswXTtcbiAgdGhpcy5fcGIgPSB0aGlzLl9pbnRQdFsxXTtcbiAgdGhpcy5fcmVzdWx0ID0gMDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTAgPSB7IERPTlRfSU5URVJTRUNUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERPX0lOVEVSU0VDVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT0xMSU5FQVI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTk9fSU5URVJTRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBPSU5UX0lOVEVSU0VDVElPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT0xMSU5FQVJfSU5URVJTRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEluZGV4QWxvbmdTZWdtZW50ID0gZnVuY3Rpb24gZ2V0SW5kZXhBbG9uZ1NlZ21lbnQgKHNlZ21lbnRJbmRleCwgaW50SW5kZXgpIHtcbiAgdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCk7XG4gIHJldHVybiB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVtpbnRJbmRleF1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldFRvcG9sb2d5U3VtbWFyeSA9IGZ1bmN0aW9uIGdldFRvcG9sb2d5U3VtbWFyeSAoKSB7XG4gIHZhciBjYXRCdWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGlmICh0aGlzLmlzRW5kUG9pbnQoKSkgeyBjYXRCdWYuYXBwZW5kKCcgZW5kcG9pbnQnKTsgfVxuICBpZiAodGhpcy5faXNQcm9wZXIpIHsgY2F0QnVmLmFwcGVuZCgnIHByb3BlcicpOyB9XG4gIGlmICh0aGlzLmlzQ29sbGluZWFyKCkpIHsgY2F0QnVmLmFwcGVuZCgnIGNvbGxpbmVhcicpOyB9XG4gIHJldHVybiBjYXRCdWYudG9TdHJpbmcoKVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHRoaXMuX2lucHV0TGluZXNbMF1bMF0gPSBwMTtcbiAgdGhpcy5faW5wdXRMaW5lc1swXVsxXSA9IHAyO1xuICB0aGlzLl9pbnB1dExpbmVzWzFdWzBdID0gcDM7XG4gIHRoaXMuX2lucHV0TGluZXNbMV1bMV0gPSBwNDtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5jb21wdXRlSW50ZXJzZWN0KHAxLCBwMiwgcDMsIHA0KTtcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEludGVyc2VjdGlvbk51bSA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbk51bSAoKSB7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRMaW5lSW5kZXggPSBmdW5jdGlvbiBjb21wdXRlSW50TGluZUluZGV4ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5faW50TGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXggPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDIpOyB9KTtcbiAgICAgIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKTtcbiAgICAgIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWdtZW50SW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRpc3QwID0gdGhpcy5nZXRFZGdlRGlzdGFuY2Uoc2VnbWVudEluZGV4LCAwKTtcbiAgICB2YXIgZGlzdDEgPSB0aGlzLmdldEVkZ2VEaXN0YW5jZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIGlmIChkaXN0MCA+IGRpc3QxKSB7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVswXSA9IDA7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVsxXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzBdID0gMTtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzFdID0gMDtcbiAgICB9XG4gIH1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzUHJvcGVyID0gZnVuY3Rpb24gaXNQcm9wZXIgKCkge1xuICByZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSAmJiB0aGlzLl9pc1Byb3BlclxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuc2V0UHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBzZXRQcmVjaXNpb25Nb2RlbCAocHJlY2lzaW9uTW9kZWwpIHtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc0ludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmICh0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaW5wdXRMaW5lSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHQ7IGkrKykge1xuICAgICAgaWYgKCEodGhpcyQxLl9pbnRQdFtpXS5lcXVhbHMyRCh0aGlzJDEuX2lucHV0TGluZXNbaW5wdXRMaW5lSW5kZXhdWzBdKSB8fCB0aGlzJDEuX2ludFB0W2ldLmVxdWFsczJEKHRoaXMkMS5faW5wdXRMaW5lc1tpbnB1dExpbmVJbmRleF1bMV0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uIChpbnRJbmRleCkge1xuICByZXR1cm4gdGhpcy5faW50UHRbaW50SW5kZXhdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0VuZFBvaW50ID0gZnVuY3Rpb24gaXNFbmRQb2ludCAoKSB7XG4gIHJldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpICYmICF0aGlzLl9pc1Byb3BlclxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdCAhPT0gTGluZUludGVyc2VjdG9yLk5PX0lOVEVSU0VDVElPTlxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0RWRnZURpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RWRnZURpc3RhbmNlIChzZWdtZW50SW5kZXgsIGludEluZGV4KSB7XG4gIHZhciBkaXN0ID0gTGluZUludGVyc2VjdG9yLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbaW50SW5kZXhdLCB0aGlzLl9pbnB1dExpbmVzW3NlZ21lbnRJbmRleF1bMF0sIHRoaXMuX2lucHV0TGluZXNbc2VnbWVudEluZGV4XVsxXSk7XG4gIHJldHVybiBkaXN0XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0NvbGxpbmVhciA9IGZ1bmN0aW9uIGlzQ29sbGluZWFyICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdCA9PT0gTGluZUludGVyc2VjdG9yLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzBdWzFdKSArICcgLSAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzFdWzFdKSArIHRoaXMuZ2V0VG9wb2xvZ3lTdW1tYXJ5KClcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEVuZHBvaW50ID0gZnVuY3Rpb24gZ2V0RW5kcG9pbnQgKHNlZ21lbnRJbmRleCwgcHRJbmRleCkge1xuICByZXR1cm4gdGhpcy5faW5wdXRMaW5lc1tzZWdtZW50SW5kZXhdW3B0SW5kZXhdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uIChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0OyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9pbnRQdFtpXS5lcXVhbHMyRChwdCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50ID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50IChzZWdtZW50SW5kZXgsIGludEluZGV4KSB7XG4gIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpO1xuICByZXR1cm4gdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1baW50SW5kZXhdXVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lSW50ZXJzZWN0b3Jcbn07XG5MaW5lSW50ZXJzZWN0b3IuY29tcHV0ZUVkZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVFZGdlRGlzdGFuY2UgKHAsIHAwLCBwMSkge1xuICB2YXIgZHggPSBNYXRoLmFicyhwMS54IC0gcDAueCk7XG4gIHZhciBkeSA9IE1hdGguYWJzKHAxLnkgLSBwMC55KTtcbiAgdmFyIGRpc3QgPSAtMS4wO1xuICBpZiAocC5lcXVhbHMocDApKSB7XG4gICAgZGlzdCA9IDAuMDtcbiAgfSBlbHNlIGlmIChwLmVxdWFscyhwMSkpIHtcbiAgICBpZiAoZHggPiBkeSkgeyBkaXN0ID0gZHg7IH0gZWxzZSB7IGRpc3QgPSBkeTsgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwZHggPSBNYXRoLmFicyhwLnggLSBwMC54KTtcbiAgICB2YXIgcGR5ID0gTWF0aC5hYnMocC55IC0gcDAueSk7XG4gICAgaWYgKGR4ID4gZHkpIHsgZGlzdCA9IHBkeDsgfSBlbHNlIHsgZGlzdCA9IHBkeTsgfVxuICAgIGlmIChkaXN0ID09PSAwLjAgJiYgIXAuZXF1YWxzKHAwKSkge1xuICAgICAgZGlzdCA9IE1hdGgubWF4KHBkeCwgcGR5KTtcbiAgICB9XG4gIH1cbiAgQXNzZXJ0LmlzVHJ1ZSghKGRpc3QgPT09IDAuMCAmJiAhcC5lcXVhbHMocDApKSwgJ0JhZCBkaXN0YW5jZSBjYWxjdWxhdGlvbicpO1xuICByZXR1cm4gZGlzdFxufTtcbkxpbmVJbnRlcnNlY3Rvci5ub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlID0gZnVuY3Rpb24gbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSAocCwgcDEsIHAyKSB7XG4gIHZhciBkeCA9IHAueCAtIHAxLng7XG4gIHZhciBkeSA9IHAueSAtIHAxLnk7XG4gIHZhciBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgQXNzZXJ0LmlzVHJ1ZSghKGRpc3QgPT09IDAuMCAmJiAhcC5lcXVhbHMocDEpKSwgJ0ludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb24nKTtcbiAgcmV0dXJuIGRpc3Rcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuRE9OVF9JTlRFUlNFQ1QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLkRPX0lOVEVSU0VDVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuQ09MTElORUFSLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5OT19JTlRFUlNFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLlBPSU5UX0lOVEVSU0VDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuQ09MTElORUFSX0lOVEVSU0VDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lSW50ZXJzZWN0b3IsIHN0YXRpY0FjY2Vzc29ycyQxMCApO1xuXG52YXIgUm9idXN0TGluZUludGVyc2VjdG9yID0gKGZ1bmN0aW9uIChMaW5lSW50ZXJzZWN0b3IkJDEpIHtcbiAgZnVuY3Rpb24gUm9idXN0TGluZUludGVyc2VjdG9yICgpIHtcbiAgICBMaW5lSW50ZXJzZWN0b3IkJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggTGluZUludGVyc2VjdG9yJCQxICkgUm9idXN0TGluZUludGVyc2VjdG9yLl9fcHJvdG9fXyA9IExpbmVJbnRlcnNlY3RvciQkMTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVJbnRlcnNlY3RvciQkMSAmJiBMaW5lSW50ZXJzZWN0b3IkJDEucHJvdG90eXBlICk7XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb2J1c3RMaW5lSW50ZXJzZWN0b3I7XG5cbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0luU2VnbWVudEVudmVsb3BlcyA9IGZ1bmN0aW9uIGlzSW5TZWdtZW50RW52ZWxvcGVzIChpbnRQdCkge1xuICAgIHZhciBlbnYwID0gbmV3IEVudmVsb3BlKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sIHRoaXMuX2lucHV0TGluZXNbMF1bMV0pO1xuICAgIHZhciBlbnYxID0gbmV3IEVudmVsb3BlKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sIHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO1xuICAgIHJldHVybiBlbnYwLmNvbnRhaW5zKGludFB0KSAmJiBlbnYxLmNvbnRhaW5zKGludFB0KVxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcDIgPSBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgICAgaWYgKEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBwKSkge1xuICAgICAgICBpZiAoQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBwKSA9PT0gMCAmJiBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMiwgcDEsIHApID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5faXNQcm9wZXIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwLmVxdWFscyhwMSkgfHwgcC5lcXVhbHMocDIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXN1bHQgPSBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OO1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT047XG4gICAgfSBlbHNlIHsgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5ub3JtYWxpemVUb01pbmltdW0gPSBmdW5jdGlvbiBub3JtYWxpemVUb01pbmltdW0gKG4xLCBuMiwgbjMsIG40LCBub3JtUHQpIHtcbiAgICBub3JtUHQueCA9IHRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKG4xLngsIG4yLngsIG4zLngsIG40LngpO1xuICAgIG5vcm1QdC55ID0gdGhpcy5zbWFsbGVzdEluQWJzVmFsdWUobjEueSwgbjIueSwgbjMueSwgbjQueSk7XG4gICAgbjEueCAtPSBub3JtUHQueDtcbiAgICBuMS55IC09IG5vcm1QdC55O1xuICAgIG4yLnggLT0gbm9ybVB0Lng7XG4gICAgbjIueSAtPSBub3JtUHQueTtcbiAgICBuMy54IC09IG5vcm1QdC54O1xuICAgIG4zLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjQueCAtPSBub3JtUHQueDtcbiAgICBuNC55IC09IG5vcm1QdC55O1xuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgaW50UHQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpbnRQdCA9IEhDb29yZGluYXRlLmludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKSB7XG4gICAgICAgIGludFB0ID0gUm9idXN0TGluZUludGVyc2VjdG9yLm5lYXJlc3RFbmRwb2ludChwMSwgcDIsIHExLCBxMik7XG4gICAgICB9IGVsc2UgeyB0aHJvdyBlIH1cbiAgICB9IGZpbmFsbHkge31cbiAgICByZXR1cm4gaW50UHRcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIGludFB0ID0gdGhpcy5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgaWYgKCF0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKGludFB0KSkge1xuICAgICAgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZShSb2J1c3RMaW5lSW50ZXJzZWN0b3IubmVhcmVzdEVuZHBvaW50KHAxLCBwMiwgcTEsIHEyKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVjaXNpb25Nb2RlbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoaW50UHQpO1xuICAgIH1cbiAgICByZXR1cm4gaW50UHRcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5zbWFsbGVzdEluQWJzVmFsdWUgPSBmdW5jdGlvbiBzbWFsbGVzdEluQWJzVmFsdWUgKHgxLCB4MiwgeDMsIHg0KSB7XG4gICAgdmFyIHggPSB4MTtcbiAgICB2YXIgeGFicyA9IE1hdGguYWJzKHgpO1xuICAgIGlmIChNYXRoLmFicyh4MikgPCB4YWJzKSB7XG4gICAgICB4ID0geDI7XG4gICAgICB4YWJzID0gTWF0aC5hYnMoeDIpO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoeDMpIDwgeGFicykge1xuICAgICAgeCA9IHgzO1xuICAgICAgeGFicyA9IE1hdGguYWJzKHgzKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHg0KSA8IHhhYnMpIHtcbiAgICAgIHggPSB4NDtcbiAgICB9XG4gICAgcmV0dXJuIHhcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jaGVja0REID0gZnVuY3Rpb24gY2hlY2tERCAocDEsIHAyLCBxMSwgcTIsIGludFB0KSB7XG4gICAgdmFyIGludFB0REQgPSBDR0FsZ29yaXRobXNERC5pbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpO1xuICAgIHZhciBpc0luID0gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpbnRQdEREKTtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ0REIGluIGVudiA9ICcgKyBpc0luICsgJyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICcgKyBpbnRQdEREKTtcbiAgICBpZiAoaW50UHQuZGlzdGFuY2UoaW50UHRERCkgPiAwLjAwMDEpIHtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbignRGlzdGFuY2UgPSAnICsgaW50UHQuZGlzdGFuY2UoaW50UHRERCkpO1xuICAgIH1cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBuMSA9IG5ldyBDb29yZGluYXRlKHAxKTtcbiAgICB2YXIgbjIgPSBuZXcgQ29vcmRpbmF0ZShwMik7XG4gICAgdmFyIG4zID0gbmV3IENvb3JkaW5hdGUocTEpO1xuICAgIHZhciBuNCA9IG5ldyBDb29yZGluYXRlKHEyKTtcbiAgICB2YXIgbm9ybVB0ID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLm5vcm1hbGl6ZVRvRW52Q2VudHJlKG4xLCBuMiwgbjMsIG40LCBub3JtUHQpO1xuICAgIHZhciBpbnRQdCA9IHRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKG4xLCBuMiwgbjMsIG40KTtcbiAgICBpbnRQdC54ICs9IG5vcm1QdC54O1xuICAgIGludFB0LnkgKz0gbm9ybVB0Lnk7XG4gICAgcmV0dXJuIGludFB0XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIHAxcTFwMiA9IEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBxMSk7XG4gICAgdmFyIHAxcTJwMiA9IEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBxMik7XG4gICAgdmFyIHExcDFxMiA9IEVudmVsb3BlLmludGVyc2VjdHMocTEsIHEyLCBwMSk7XG4gICAgdmFyIHExcDJxMiA9IEVudmVsb3BlLmludGVyc2VjdHMocTEsIHEyLCBwMik7XG4gICAgaWYgKHAxcTFwMiAmJiBwMXEycDIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHEyO1xuICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChxMXAxcTIgJiYgcTFwMnEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHAxO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMjtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMXAyICYmIHExcDFxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMTtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDE7XG4gICAgICByZXR1cm4gcTEuZXF1YWxzKHAxKSAmJiAhcDFxMnAyICYmICFxMXAycTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHAxcTFwMiAmJiBxMXAycTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAyO1xuICAgICAgcmV0dXJuIHExLmVxdWFscyhwMikgJiYgIXAxcTJwMiAmJiAhcTFwMXEyID8gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTiA6IExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChwMXEycDIgJiYgcTFwMXEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHEyO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMTtcbiAgICAgIHJldHVybiBxMi5lcXVhbHMocDEpICYmICFwMXExcDIgJiYgIXExcDJxMiA/IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT04gOiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMnAyICYmIHExcDJxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMjtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDI7XG4gICAgICByZXR1cm4gcTIuZXF1YWxzKHAyKSAmJiAhcDFxMXAyICYmICFxMXAxcTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT05cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5ub3JtYWxpemVUb0VudkNlbnRyZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvRW52Q2VudHJlIChuMDAsIG4wMSwgbjEwLCBuMTEsIG5vcm1QdCkge1xuICAgIHZhciBtaW5YMCA9IG4wMC54IDwgbjAxLnggPyBuMDAueCA6IG4wMS54O1xuICAgIHZhciBtaW5ZMCA9IG4wMC55IDwgbjAxLnkgPyBuMDAueSA6IG4wMS55O1xuICAgIHZhciBtYXhYMCA9IG4wMC54ID4gbjAxLnggPyBuMDAueCA6IG4wMS54O1xuICAgIHZhciBtYXhZMCA9IG4wMC55ID4gbjAxLnkgPyBuMDAueSA6IG4wMS55O1xuICAgIHZhciBtaW5YMSA9IG4xMC54IDwgbjExLnggPyBuMTAueCA6IG4xMS54O1xuICAgIHZhciBtaW5ZMSA9IG4xMC55IDwgbjExLnkgPyBuMTAueSA6IG4xMS55O1xuICAgIHZhciBtYXhYMSA9IG4xMC54ID4gbjExLnggPyBuMTAueCA6IG4xMS54O1xuICAgIHZhciBtYXhZMSA9IG4xMC55ID4gbjExLnkgPyBuMTAueSA6IG4xMS55O1xuICAgIHZhciBpbnRNaW5YID0gbWluWDAgPiBtaW5YMSA/IG1pblgwIDogbWluWDE7XG4gICAgdmFyIGludE1heFggPSBtYXhYMCA8IG1heFgxID8gbWF4WDAgOiBtYXhYMTtcbiAgICB2YXIgaW50TWluWSA9IG1pblkwID4gbWluWTEgPyBtaW5ZMCA6IG1pblkxO1xuICAgIHZhciBpbnRNYXhZID0gbWF4WTAgPCBtYXhZMSA/IG1heFkwIDogbWF4WTE7XG4gICAgdmFyIGludE1pZFggPSAoaW50TWluWCArIGludE1heFgpIC8gMi4wO1xuICAgIHZhciBpbnRNaWRZID0gKGludE1pblkgKyBpbnRNYXhZKSAvIDIuMDtcbiAgICBub3JtUHQueCA9IGludE1pZFg7XG4gICAgbm9ybVB0LnkgPSBpbnRNaWRZO1xuICAgIG4wMC54IC09IG5vcm1QdC54O1xuICAgIG4wMC55IC09IG5vcm1QdC55O1xuICAgIG4wMS54IC09IG5vcm1QdC54O1xuICAgIG4wMS55IC09IG5vcm1QdC55O1xuICAgIG4xMC54IC09IG5vcm1QdC54O1xuICAgIG4xMC55IC09IG5vcm1QdC55O1xuICAgIG4xMS54IC09IG5vcm1QdC54O1xuICAgIG4xMS55IC09IG5vcm1QdC55O1xuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3QgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0IChwMSwgcDIsIHExLCBxMikge1xuICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgaWYgKCFFbnZlbG9wZS5pbnRlcnNlY3RzKHAxLCBwMiwgcTEsIHEyKSkgeyByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTiB9XG4gICAgdmFyIFBxMSA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcTEpO1xuICAgIHZhciBQcTIgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHEyKTtcbiAgICBpZiAoKFBxMSA+IDAgJiYgUHEyID4gMCkgfHwgKFBxMSA8IDAgJiYgUHEyIDwgMCkpIHtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIHZhciBRcDEgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChxMSwgcTIsIHAxKTtcbiAgICB2YXIgUXAyID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocTEsIHEyLCBwMik7XG4gICAgaWYgKChRcDEgPiAwICYmIFFwMiA+IDApIHx8IChRcDEgPCAwICYmIFFwMiA8IDApKSB7XG4gICAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICB2YXIgY29sbGluZWFyID0gUHExID09PSAwICYmIFBxMiA9PT0gMCAmJiBRcDEgPT09IDAgJiYgUXAyID09PSAwO1xuICAgIGlmIChjb2xsaW5lYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpXG4gICAgfVxuICAgIGlmIChQcTEgPT09IDAgfHwgUHEyID09PSAwIHx8IFFwMSA9PT0gMCB8fCBRcDIgPT09IDApIHtcbiAgICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgICBpZiAocDEuZXF1YWxzMkQocTEpIHx8IHAxLmVxdWFsczJEKHEyKSkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IHAxO1xuICAgICAgfSBlbHNlIGlmIChwMi5lcXVhbHMyRChxMSkgfHwgcDIuZXF1YWxzMkQocTIpKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gcDI7XG4gICAgICB9IGVsc2UgaWYgKFBxMSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHExKTtcbiAgICAgIH0gZWxzZSBpZiAoUHEyID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUocTIpO1xuICAgICAgfSBlbHNlIGlmIChRcDEgPT09IDApIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZShwMSk7XG4gICAgICB9IGVsc2UgaWYgKFFwMiA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNQcm9wZXIgPSB0cnVlO1xuICAgICAgdGhpcy5faW50UHRbMF0gPSB0aGlzLmludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgfVxuICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFJvYnVzdExpbmVJbnRlcnNlY3RvclxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IubmVhcmVzdEVuZHBvaW50ID0gZnVuY3Rpb24gbmVhcmVzdEVuZHBvaW50IChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBuZWFyZXN0UHQgPSBwMTtcbiAgICB2YXIgbWluRGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMSwgcTEsIHEyKTtcbiAgICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMiwgcTEsIHEyKTtcbiAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgbmVhcmVzdFB0ID0gcDI7XG4gICAgfVxuICAgIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocTEsIHAxLCBwMik7XG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIG5lYXJlc3RQdCA9IHExO1xuICAgIH1cbiAgICBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHEyLCBwMSwgcDIpO1xuICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICBuZWFyZXN0UHQgPSBxMjtcbiAgICB9XG4gICAgcmV0dXJuIG5lYXJlc3RQdFxuICB9O1xuXG4gIHJldHVybiBSb2J1c3RMaW5lSW50ZXJzZWN0b3I7XG59KExpbmVJbnRlcnNlY3RvcikpO1xuXG52YXIgUm9idXN0RGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiBSb2J1c3REZXRlcm1pbmFudCAoKSB7fTtcblxuUm9idXN0RGV0ZXJtaW5hbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Sb2J1c3REZXRlcm1pbmFudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBSb2J1c3REZXRlcm1pbmFudFxufTtcblJvYnVzdERldGVybWluYW50Lm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4IChwMSwgcDIsIHEpIHtcbiAgdmFyIGR4MSA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkxID0gcDIueSAtIHAxLnk7XG4gIHZhciBkeDIgPSBxLnggLSBwMi54O1xuICB2YXIgZHkyID0gcS55IC0gcDIueTtcbiAgcmV0dXJuIFJvYnVzdERldGVybWluYW50LnNpZ25PZkRldDJ4MihkeDEsIGR5MSwgZHgyLCBkeTIpXG59O1xuUm9idXN0RGV0ZXJtaW5hbnQuc2lnbk9mRGV0MngyID0gZnVuY3Rpb24gc2lnbk9mRGV0MngyICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgc2lnbiA9IG51bGw7XG4gIHZhciBzd2FwID0gbnVsbDtcbiAgdmFyIGsgPSBudWxsO1xuICBzaWduID0gMTtcbiAgaWYgKHgxID09PSAwLjAgfHwgeTIgPT09IDAuMCkge1xuICAgIGlmICh5MSA9PT0gMC4wIHx8IHgyID09PSAwLjApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmICh5MSA+IDApIHtcbiAgICAgIGlmICh4MiA+IDApIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDIgPiAwKSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHkxID09PSAwLjAgfHwgeDIgPT09IDAuMCkge1xuICAgIGlmICh5MiA+IDApIHtcbiAgICAgIGlmICh4MSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHkxID4gMC4wKSB7XG4gICAgaWYgKHkyID4gMC4wKSB7XG4gICAgICBpZiAoeTEgPD0geTIpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0geTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkxIDw9IC15Mikge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHgyID0gLXgyO1xuICAgICAgICB5MiA9IC15MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSAteDI7XG4gICAgICAgIHgyID0gc3dhcDtcbiAgICAgICAgc3dhcCA9IHkxO1xuICAgICAgICB5MSA9IC15MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoeTIgPiAwLjApIHtcbiAgICAgIGlmICgteTEgPD0geTIpIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICB4MSA9IC14MTtcbiAgICAgICAgeTEgPSAteTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2FwID0gLXgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXA7XG4gICAgICAgIHN3YXAgPSAteTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkxID49IHkyKSB7XG4gICAgICAgIHgxID0gLXgxO1xuICAgICAgICB5MSA9IC15MTtcbiAgICAgICAgeDIgPSAteDI7XG4gICAgICAgIHkyID0gLXkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICBzd2FwID0gLXgxO1xuICAgICAgICB4MSA9IC14MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0gLXkxO1xuICAgICAgICB5MSA9IC15MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoeDEgPiAwLjApIHtcbiAgICBpZiAoeDIgPiAwLjApIHtcbiAgICAgIGlmICh4MSA8PSB4Mikge1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh4MiA+IDAuMCkge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHgxID0gLXgxO1xuICAgICAgICB4MiA9IC14MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGsgPSBNYXRoLmZsb29yKHgyIC8geDEpO1xuICAgIHgyID0geDIgLSBrICogeDE7XG4gICAgeTIgPSB5MiAtIGsgKiB5MTtcbiAgICBpZiAoeTIgPCAwLjApIHtcbiAgICAgIHJldHVybiAtc2lnblxuICAgIH1cbiAgICBpZiAoeTIgPiB5MSkge1xuICAgICAgcmV0dXJuIHNpZ25cbiAgICB9XG4gICAgaWYgKHgxID4geDIgKyB4Mikge1xuICAgICAgaWYgKHkxIDwgeTIgKyB5Mikge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeTEgPiB5MiArIHkyKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB4MSAtIHgyO1xuICAgICAgICB5MiA9IHkxIC0geTI7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkyID09PSAwLjApIHtcbiAgICAgIGlmICh4MiA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHgyID09PSAwLjApIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICAgIGsgPSBNYXRoLmZsb29yKHgxIC8geDIpO1xuICAgIHgxID0geDEgLSBrICogeDI7XG4gICAgeTEgPSB5MSAtIGsgKiB5MjtcbiAgICBpZiAoeTEgPCAwLjApIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICAgIGlmICh5MSA+IHkyKSB7XG4gICAgICByZXR1cm4gLXNpZ25cbiAgICB9XG4gICAgaWYgKHgyID4geDEgKyB4MSkge1xuICAgICAgaWYgKHkyIDwgeTEgKyB5MSkge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkyID4geTEgKyB5MSkge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSB4MiAtIHgxO1xuICAgICAgICB5MSA9IHkyIC0geTE7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkxID09PSAwLjApIHtcbiAgICAgIGlmICh4MSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeDEgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfVxuICB9XG59O1xuXG52YXIgUmF5Q3Jvc3NpbmdDb3VudGVyID0gZnVuY3Rpb24gUmF5Q3Jvc3NpbmdDb3VudGVyICgpIHtcbiAgdGhpcy5fcCA9IG51bGw7XG4gIHRoaXMuX2Nyb3NzaW5nQ291bnQgPSAwO1xuICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gZmFsc2U7XG4gIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wID0gcDtcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmNvdW50U2VnbWVudCA9IGZ1bmN0aW9uIGNvdW50U2VnbWVudCAocDEsIHAyKSB7XG4gIGlmIChwMS54IDwgdGhpcy5fcC54ICYmIHAyLnggPCB0aGlzLl9wLngpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fcC54ID09PSBwMi54ICYmIHRoaXMuX3AueSA9PT0gcDIueSkge1xuICAgIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQgPSB0cnVlO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHAxLnkgPT09IHRoaXMuX3AueSAmJiBwMi55ID09PSB0aGlzLl9wLnkpIHtcbiAgICB2YXIgbWlueCA9IHAxLng7XG4gICAgdmFyIG1heHggPSBwMi54O1xuICAgIGlmIChtaW54ID4gbWF4eCkge1xuICAgICAgbWlueCA9IHAyLng7XG4gICAgICBtYXh4ID0gcDEueDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3AueCA+PSBtaW54ICYmIHRoaXMuX3AueCA8PSBtYXh4KSB7XG4gICAgICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoKHAxLnkgPiB0aGlzLl9wLnkgJiYgcDIueSA8PSB0aGlzLl9wLnkpIHx8IChwMi55ID4gdGhpcy5fcC55ICYmIHAxLnkgPD0gdGhpcy5fcC55KSkge1xuICAgIHZhciB4MSA9IHAxLnggLSB0aGlzLl9wLng7XG4gICAgdmFyIHkxID0gcDEueSAtIHRoaXMuX3AueTtcbiAgICB2YXIgeDIgPSBwMi54IC0gdGhpcy5fcC54O1xuICAgIHZhciB5MiA9IHAyLnkgLSB0aGlzLl9wLnk7XG4gICAgdmFyIHhJbnRTaWduID0gUm9idXN0RGV0ZXJtaW5hbnQuc2lnbk9mRGV0MngyKHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoeEludFNpZ24gPT09IDAuMCkge1xuICAgICAgdGhpcy5faXNQb2ludE9uU2VnbWVudCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAoeTIgPCB5MSkgeyB4SW50U2lnbiA9IC14SW50U2lnbjsgfVxuICAgIGlmICh4SW50U2lnbiA+IDAuMCkge1xuICAgICAgdGhpcy5fY3Jvc3NpbmdDb3VudCsrO1xuICAgIH1cbiAgfVxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuaXNQb2ludEluUG9seWdvbiA9IGZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pc1BvaW50T25TZWdtZW50KSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gIGlmICh0aGlzLl9jcm9zc2luZ0NvdW50ICUgMiA9PT0gMSkge1xuICAgIHJldHVybiBMb2NhdGlvbi5JTlRFUklPUlxuICB9XG4gIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuaXNPblNlZ21lbnQgPSBmdW5jdGlvbiBpc09uU2VnbWVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50XG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFJheUNyb3NzaW5nQ291bnRlclxufTtcblJheUNyb3NzaW5nQ291bnRlci5sb2NhdGVQb2ludEluUmluZyA9IGZ1bmN0aW9uIGxvY2F0ZVBvaW50SW5SaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByaW5nID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb3VudGVyID0gbmV3IFJheUNyb3NzaW5nQ291bnRlcihwKTtcbiAgICB2YXIgcDEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHZhciBwMiA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByaW5nLnNpemUoKTsgaSsrKSB7XG4gICAgICByaW5nLmdldENvb3JkaW5hdGUoaSwgcDEpO1xuICAgICAgcmluZy5nZXRDb29yZGluYXRlKGkgLSAxLCBwMik7XG4gICAgICBjb3VudGVyLmNvdW50U2VnbWVudChwMSwgcDIpO1xuICAgICAgaWYgKGNvdW50ZXIuaXNPblNlZ21lbnQoKSkgeyByZXR1cm4gY291bnRlci5nZXRMb2NhdGlvbigpIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXIuZ2V0TG9jYXRpb24oKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByaW5nJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvdW50ZXIkMSA9IG5ldyBSYXlDcm9zc2luZ0NvdW50ZXIocCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCByaW5nJDEubGVuZ3RoOyBpJDErKykge1xuICAgICAgdmFyIHAxJDEgPSByaW5nJDFbaSQxXTtcbiAgICAgIHZhciBwMiQxID0gcmluZyQxW2kkMSAtIDFdO1xuICAgICAgY291bnRlciQxLmNvdW50U2VnbWVudChwMSQxLCBwMiQxKTtcbiAgICAgIGlmIChjb3VudGVyJDEuaXNPblNlZ21lbnQoKSkgeyByZXR1cm4gY291bnRlciQxLmdldExvY2F0aW9uKCkgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlciQxLmdldExvY2F0aW9uKClcbiAgfVxufTtcblxudmFyIENHQWxnb3JpdGhtcyA9IGZ1bmN0aW9uIENHQWxnb3JpdGhtcyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzID0geyBDTE9DS1dJU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUklHSFQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09VTlRFUkNMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxMRUZUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPTExJTkVBUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTVFJBSUdIVDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5DR0FsZ29yaXRobXMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5DR0FsZ29yaXRobXMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zXG59O1xuQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4IChwMSwgcDIsIHEpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxKVxufTtcbkNHQWxnb3JpdGhtcy5zaWduZWRBcmVhID0gZnVuY3Rpb24gc2lnbmVkQXJlYSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciByaW5nID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChyaW5nLmxlbmd0aCA8IDMpIHsgcmV0dXJuIDAuMCB9XG4gICAgdmFyIHN1bSA9IDAuMDtcbiAgICB2YXIgeDAgPSByaW5nWzBdLng7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByaW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIHggPSByaW5nW2ldLnggLSB4MDtcbiAgICAgIHZhciB5MSA9IHJpbmdbaSArIDFdLnk7XG4gICAgICB2YXIgeTIgPSByaW5nW2kgLSAxXS55O1xuICAgICAgc3VtICs9IHggKiAoeTIgLSB5MSk7XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyAyLjBcbiAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgdmFyIHJpbmckMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbiA9IHJpbmckMS5zaXplKCk7XG4gICAgaWYgKG4gPCAzKSB7IHJldHVybiAwLjAgfVxuICAgIHZhciBwMCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdmFyIHAxID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB2YXIgcDIgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHJpbmckMS5nZXRDb29yZGluYXRlKDAsIHAxKTtcbiAgICByaW5nJDEuZ2V0Q29vcmRpbmF0ZSgxLCBwMik7XG4gICAgdmFyIHgwJDEgPSBwMS54O1xuICAgIHAyLnggLT0geDAkMTtcbiAgICB2YXIgc3VtJDEgPSAwLjA7XG4gICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgbiAtIDE7IGkkMSsrKSB7XG4gICAgICBwMC55ID0gcDEueTtcbiAgICAgIHAxLnggPSBwMi54O1xuICAgICAgcDEueSA9IHAyLnk7XG4gICAgICByaW5nJDEuZ2V0Q29vcmRpbmF0ZShpJDEgKyAxLCBwMik7XG4gICAgICBwMi54IC09IHgwJDE7XG4gICAgICBzdW0kMSArPSBwMS54ICogKHAwLnkgLSBwMi55KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSQxIC8gMi4wXG4gIH1cbn07XG5DR0FsZ29yaXRobXMuZGlzdGFuY2VMaW5lTGluZSA9IGZ1bmN0aW9uIGRpc3RhbmNlTGluZUxpbmUgKEEsIEIsIEMsIEQpIHtcbiAgaWYgKEEuZXF1YWxzKEIpKSB7IHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQSwgQywgRCkgfVxuICBpZiAoQy5lcXVhbHMoRCkpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShELCBBLCBCKSB9XG4gIHZhciBub0ludGVyc2VjdGlvbiA9IGZhbHNlO1xuICBpZiAoIUVudmVsb3BlLmludGVyc2VjdHMoQSwgQiwgQywgRCkpIHtcbiAgICBub0ludGVyc2VjdGlvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbm9tID0gKEIueCAtIEEueCkgKiAoRC55IC0gQy55KSAtIChCLnkgLSBBLnkpICogKEQueCAtIEMueCk7XG4gICAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgICBub0ludGVyc2VjdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByTnVtYiA9IChBLnkgLSBDLnkpICogKEQueCAtIEMueCkgLSAoQS54IC0gQy54KSAqIChELnkgLSBDLnkpO1xuICAgICAgdmFyIHNOdW0gPSAoQS55IC0gQy55KSAqIChCLnggLSBBLngpIC0gKEEueCAtIEMueCkgKiAoQi55IC0gQS55KTtcbiAgICAgIHZhciBzID0gc051bSAvIGRlbm9tO1xuICAgICAgdmFyIHIgPSByTnVtYiAvIGRlbm9tO1xuICAgICAgaWYgKHIgPCAwIHx8IHIgPiAxIHx8IHMgPCAwIHx8IHMgPiAxKSB7XG4gICAgICAgIG5vSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vSW50ZXJzZWN0aW9uKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLm1pbihDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQSwgQywgRCksIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShCLCBDLCBEKSwgQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEMsIEEsIEIpLCBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoRCwgQSwgQikpXG4gIH1cbiAgcmV0dXJuIDAuMFxufTtcbkNHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nID0gZnVuY3Rpb24gaXNQb2ludEluUmluZyAocCwgcmluZykge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zLmxvY2F0ZVBvaW50SW5SaW5nKHAsIHJpbmcpICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcbkNHQWxnb3JpdGhtcy5jb21wdXRlTGVuZ3RoID0gZnVuY3Rpb24gY29tcHV0ZUxlbmd0aCAocHRzKSB7XG4gIHZhciBuID0gcHRzLnNpemUoKTtcbiAgaWYgKG4gPD0gMSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIGxlbiA9IDAuMDtcbiAgdmFyIHAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICBwdHMuZ2V0Q29vcmRpbmF0ZSgwLCBwKTtcbiAgdmFyIHgwID0gcC54O1xuICB2YXIgeTAgPSBwLnk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgcHRzLmdldENvb3JkaW5hdGUoaSwgcCk7XG4gICAgdmFyIHgxID0gcC54O1xuICAgIHZhciB5MSA9IHAueTtcbiAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgIHZhciBkeSA9IHkxIC0geTA7XG4gICAgbGVuICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBsZW5cbn07XG5DR0FsZ29yaXRobXMuaXNDQ1cgPSBmdW5jdGlvbiBpc0NDVyAocmluZykge1xuICB2YXIgblB0cyA9IHJpbmcubGVuZ3RoIC0gMTtcbiAgaWYgKG5QdHMgPCAzKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkJykgfVxuICB2YXIgaGlQdCA9IHJpbmdbMF07XG4gIHZhciBoaUluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gblB0czsgaSsrKSB7XG4gICAgdmFyIHAgPSByaW5nW2ldO1xuICAgIGlmIChwLnkgPiBoaVB0LnkpIHtcbiAgICAgIGhpUHQgPSBwO1xuICAgICAgaGlJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHZhciBpUHJldiA9IGhpSW5kZXg7XG4gIGRvIHtcbiAgICBpUHJldiA9IGlQcmV2IC0gMTtcbiAgICBpZiAoaVByZXYgPCAwKSB7IGlQcmV2ID0gblB0czsgfVxuICB9IHdoaWxlIChyaW5nW2lQcmV2XS5lcXVhbHMyRChoaVB0KSAmJiBpUHJldiAhPT0gaGlJbmRleClcbiAgdmFyIGlOZXh0ID0gaGlJbmRleDtcbiAgZG8ge1xuICAgIGlOZXh0ID0gKGlOZXh0ICsgMSkgJSBuUHRzO1xuICB9IHdoaWxlIChyaW5nW2lOZXh0XS5lcXVhbHMyRChoaVB0KSAmJiBpTmV4dCAhPT0gaGlJbmRleClcbiAgdmFyIHByZXYgPSByaW5nW2lQcmV2XTtcbiAgdmFyIG5leHQgPSByaW5nW2lOZXh0XTtcbiAgaWYgKHByZXYuZXF1YWxzMkQoaGlQdCkgfHwgbmV4dC5lcXVhbHMyRChoaVB0KSB8fCBwcmV2LmVxdWFsczJEKG5leHQpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaXNjID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwcmV2LCBoaVB0LCBuZXh0KTtcbiAgdmFyIGlzQ0NXID0gZmFsc2U7XG4gIGlmIChkaXNjID09PSAwKSB7XG4gICAgaXNDQ1cgPSBwcmV2LnggPiBuZXh0Lng7XG4gIH0gZWxzZSB7XG4gICAgaXNDQ1cgPSBkaXNjID4gMDtcbiAgfVxuICByZXR1cm4gaXNDQ1dcbn07XG5DR0FsZ29yaXRobXMubG9jYXRlUG9pbnRJblJpbmcgPSBmdW5jdGlvbiBsb2NhdGVQb2ludEluUmluZyAocCwgcmluZykge1xuICByZXR1cm4gUmF5Q3Jvc3NpbmdDb3VudGVyLmxvY2F0ZVBvaW50SW5SaW5nKHAsIHJpbmcpXG59O1xuQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhciA9IGZ1bmN0aW9uIGRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhciAocCwgQSwgQikge1xuICB2YXIgbGVuMiA9IChCLnggLSBBLngpICogKEIueCAtIEEueCkgKyAoQi55IC0gQS55KSAqIChCLnkgLSBBLnkpO1xuICB2YXIgcyA9ICgoQS55IC0gcC55KSAqIChCLnggLSBBLngpIC0gKEEueCAtIHAueCkgKiAoQi55IC0gQS55KSkgLyBsZW4yO1xuICByZXR1cm4gTWF0aC5hYnMocykgKiBNYXRoLnNxcnQobGVuMilcbn07XG5DR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gY29tcHV0ZU9yaWVudGF0aW9uIChwMSwgcDIsIHEpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcSlcbn07XG5DR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUgPSBmdW5jdGlvbiBkaXN0YW5jZVBvaW50TGluZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0xpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXgnKSB9XG4gICAgdmFyIG1pbkRpc3RhbmNlID0gcC5kaXN0YW5jZShsaW5lWzBdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwLCBsaW5lW2ldLCBsaW5lW2kgKyAxXSk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbkRpc3RhbmNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIEEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIEIgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKEEueCA9PT0gQi54ICYmIEEueSA9PT0gQi55KSB7IHJldHVybiBwJDEuZGlzdGFuY2UoQSkgfVxuICAgIHZhciBsZW4yID0gKEIueCAtIEEueCkgKiAoQi54IC0gQS54KSArIChCLnkgLSBBLnkpICogKEIueSAtIEEueSk7XG4gICAgdmFyIHIgPSAoKHAkMS54IC0gQS54KSAqIChCLnggLSBBLngpICsgKHAkMS55IC0gQS55KSAqIChCLnkgLSBBLnkpKSAvIGxlbjI7XG4gICAgaWYgKHIgPD0gMC4wKSB7IHJldHVybiBwJDEuZGlzdGFuY2UoQSkgfVxuICAgIGlmIChyID49IDEuMCkgeyByZXR1cm4gcCQxLmRpc3RhbmNlKEIpIH1cbiAgICB2YXIgcyA9ICgoQS55IC0gcCQxLnkpICogKEIueCAtIEEueCkgLSAoQS54IC0gcCQxLngpICogKEIueSAtIEEueSkpIC8gbGVuMjtcbiAgICByZXR1cm4gTWF0aC5hYnMocykgKiBNYXRoLnNxcnQobGVuMilcbiAgfVxufTtcbkNHQWxnb3JpdGhtcy5pc09uTGluZSA9IGZ1bmN0aW9uIGlzT25MaW5lIChwLCBwdCkge1xuICB2YXIgbGluZUludGVyc2VjdG9yID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAwID0gcHRbaSAtIDFdO1xuICAgIHZhciBwMSA9IHB0W2ldO1xuICAgIGxpbmVJbnRlcnNlY3Rvci5jb21wdXRlSW50ZXJzZWN0aW9uKHAsIHAwLCBwMSk7XG4gICAgaWYgKGxpbmVJbnRlcnNlY3Rvci5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDMuQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5SSUdIVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5DT1VOVEVSQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLkxFRlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLkNPTExJTkVBUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5TVFJBSUdIVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09MTElORUFSIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDR0FsZ29yaXRobXMsIHN0YXRpY0FjY2Vzc29ycyQzICk7XG5cbnZhciBHZW9tZXRyeUNvbXBvbmVudEZpbHRlciA9IGZ1bmN0aW9uIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyICgpIHt9O1xuXG5HZW9tZXRyeUNvbXBvbmVudEZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7fTtcbkdlb21ldHJ5Q29tcG9uZW50RmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlDb21wb25lbnRGaWx0ZXJcbn07XG5cbnZhciBHZW9tZXRyeSA9IGZ1bmN0aW9uIEdlb21ldHJ5ICgpIHtcbiAgdmFyIGZhY3RvcnkgPSBhcmd1bWVudHNbMF07XG5cbiAgdGhpcy5fZW52ZWxvcGUgPSBudWxsO1xuICB0aGlzLl9mYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fU1JJRCA9IG51bGw7XG4gIHRoaXMuX3VzZXJEYXRhID0gbnVsbDtcbiAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gIHRoaXMuX1NSSUQgPSBmYWN0b3J5LmdldFNSSUQoKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTEgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX1BPSU5UOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9NVUxUSVBPSU5UOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9MSU5FU1RSSU5HOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9MSU5FQVJSSU5HOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX1BPTFlHT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX01VTFRJUE9MWUdPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGdlb21ldHJ5Q2hhbmdlZEZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnkucHJvdG90eXBlLmlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNvbGxlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTlxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0RmFjdG9yeSAoKSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEdlb21ldHJ5TiA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5TiAobikge1xuICByZXR1cm4gdGhpc1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gIHJldHVybiAwLjBcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaXNSZWN0YW5nbGUgPSBmdW5jdGlvbiBpc1JlY3RhbmdsZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkpIHtcbiAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChnJDEgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gdGhpcy5lcXVhbHNUb3BvKGckMSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoIShvIGluc3RhbmNlb2YgR2VvbWV0cnkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGcgPSBvO1xuICAgIHJldHVybiB0aGlzLmVxdWFsc0V4YWN0KGcpXG4gIH1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8IHRoaXMuZXF1YWxzRXhhY3Qob3RoZXIsIDApXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGdlb21ldHJ5Q2hhbmdlZCAoKSB7XG4gIHRoaXMuYXBwbHkoR2VvbWV0cnkuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKTtcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uID0gZnVuY3Rpb24gZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uICgpIHtcbiAgdGhpcy5fZW52ZWxvcGUgPSBudWxsO1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbHNOb3JtID0gZnVuY3Rpb24gZXF1YWxzTm9ybSAoZykge1xuICBpZiAoZyA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QoZy5ub3JtKCkpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gIHJldHVybiAwLjBcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0TnVtR2VvbWV0cmllcyA9IGZ1bmN0aW9uIGdldE51bUdlb21ldHJpZXMgKCkge1xuICByZXR1cm4gMVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvdGhlciA9IG87XG4gICAgaWYgKHRoaXMuZ2V0U29ydEluZGV4KCkgIT09IG90aGVyLmdldFNvcnRJbmRleCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSAtIG90aGVyLmdldFNvcnRJbmRleCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhvKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb3RoZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5nZXRTb3J0SW5kZXgoKSAhPT0gb3RoZXIkMS5nZXRTb3J0SW5kZXgoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkgLSBvdGhlciQxLmdldFNvcnRJbmRleCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiBvdGhlciQxLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgaWYgKG90aGVyJDEuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXIkMSwgY29tcClcbiAgfVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIGdldFVzZXJEYXRhICgpIHtcbiAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldFNSSUQgPSBmdW5jdGlvbiBnZXRTUklEICgpIHtcbiAgcmV0dXJuIHRoaXMuX1NSSURcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uIChnKSB7XG4gIGlmIChnLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzJylcbiAgfVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsIChhLCBiLCB0b2xlcmFuY2UpIHtcbiAgaWYgKHRvbGVyYW5jZSA9PT0gMCkge1xuICAgIHJldHVybiBhLmVxdWFscyhiKVxuICB9XG4gIHJldHVybiBhLmRpc3RhbmNlKGIpIDw9IHRvbGVyYW5jZVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5ub3JtID0gZnVuY3Rpb24gbm9ybSAoKSB7XG4gIHZhciBjb3B5ID0gdGhpcy5jb3B5KCk7XG4gIGNvcHkubm9ybWFsaXplKCk7XG4gIHJldHVybiBjb3B5XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gZ2V0UHJlY2lzaW9uTW9kZWwgKCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZUludGVybmFsICgpIHtcbiAgaWYgKHRoaXMuX2VudmVsb3BlID09PSBudWxsKSB7XG4gICAgdGhpcy5fZW52ZWxvcGUgPSB0aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFbnZlbG9wZSh0aGlzLl9lbnZlbG9wZSlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0U1JJRCA9IGZ1bmN0aW9uIHNldFNSSUQgKFNSSUQpIHtcbiAgdGhpcy5fU1JJRCA9IFNSSUQ7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gc2V0VXNlckRhdGEgKHVzZXJEYXRhKSB7XG4gIHRoaXMuX3VzZXJEYXRhID0gdXNlckRhdGE7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIHZhciBpID0gYS5pdGVyYXRvcigpO1xuICB2YXIgaiA9IGIuaXRlcmF0b3IoKTtcbiAgd2hpbGUgKGkuaGFzTmV4dCgpICYmIGouaGFzTmV4dCgpKSB7XG4gICAgdmFyIGFFbGVtZW50ID0gaS5uZXh0KCk7XG4gICAgdmFyIGJFbGVtZW50ID0gai5uZXh0KCk7XG4gICAgdmFyIGNvbXBhcmlzb24gPSBhRWxlbWVudC5jb21wYXJlVG8oYkVsZW1lbnQpO1xuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICByZXR1cm4gY29tcGFyaXNvblxuICAgIH1cbiAgfVxuICBpZiAoaS5oYXNOZXh0KCkpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIGlmIChqLmhhc05leHQoKSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHJldHVybiAwXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICByZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkICgpIHtcbiAgaWYgKHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04gfHwgdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9JTlQgfHwgdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX01VTFRJTElORVNUUklORyB8fCB0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElQT0xZR09OKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ2xvbmFibGUsIENvbXBhcmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeVxufTtcbkdlb21ldHJ5Lmhhc05vbkVtcHR5RWxlbWVudHMgPSBmdW5jdGlvbiBoYXNOb25FbXB0eUVsZW1lbnRzIChnZW9tZXRyaWVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZ2VvbWV0cmllc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkdlb21ldHJ5Lmhhc051bGxFbGVtZW50cyA9IGZ1bmN0aW9uIGhhc051bGxFbGVtZW50cyAoYXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDExLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gODc2MzYyMjY3OTE4NzM3NjcwMiB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9QT0lOVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX01VTFRJUE9JTlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9MSU5FU1RSSU5HLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTElORUFSUklORy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX01VTFRJTElORVNUUklORy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX1BPTFlHT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNSB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9NVUxUSVBPTFlHT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNiB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNyB9O1xuc3RhdGljQWNjZXNzb3JzJDExLmdlb21ldHJ5Q2hhbmdlZEZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZW9tZXRyeUNoYW5nZWRGaWx0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5LCBzdGF0aWNBY2Nlc3NvcnMkMTEgKTtcblxudmFyIGdlb21ldHJ5Q2hhbmdlZEZpbHRlciA9IGZ1bmN0aW9uIGdlb21ldHJ5Q2hhbmdlZEZpbHRlciAoKSB7fTtcblxuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5Q29tcG9uZW50RmlsdGVyXVxufTtcbmdlb21ldHJ5Q2hhbmdlZEZpbHRlci5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgZ2VvbS5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKTtcbn07XG5cbnZhciBDb29yZGluYXRlRmlsdGVyID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUZpbHRlciAoKSB7fTtcblxuQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChjb29yZCkge307XG5Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlRmlsdGVyXG59O1xuXG52YXIgQm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTIgPSB7IE1vZDJCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1PRDJfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxFTkRQT0lOVF9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE9HQ19TRlNfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Cb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHt9O1xuQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhcnlOb2RlUnVsZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5Nb2QyQm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2QyQm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1PRDJfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLkVORFBPSU5UX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuT0dDX1NGU19CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvdW5kYXJ5Tm9kZVJ1bGUuTU9EMl9CT1VOREFSWV9SVUxFIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCb3VuZGFyeU5vZGVSdWxlLCBzdGF0aWNBY2Nlc3NvcnMkMTIgKTtcblxudmFyIE1vZDJCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbk1vZDJCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgJSAyID09PSAxXG59O1xuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYXJ5Tm9kZVJ1bGVdXG59O1xuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9kMkJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5cbnZhciBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7XG4gIHJldHVybiBib3VuZGFyeUNvdW50ID4gMFxufTtcbkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlXG59O1xuXG52YXIgTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge1xuICByZXR1cm4gYm91bmRhcnlDb3VudCA+IDFcbn07XG5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZVxufTtcblxudmFyIE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgPT09IDFcbn07XG5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFyeU5vZGVSdWxlXVxufTtcbk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZVxufTtcblxuLy8gaW1wb3J0IEl0ZXJhdG9yIGZyb20gJy4vSXRlcmF0b3InXG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvQ29sbGVjdGlvbi5odG1sXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24gKCkge307XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7fTtcblxuLyoqXG4gKiBBcHBlbmRzIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhpc1xuICogbGlzdCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgcmV0dXJuZWQgYnkgdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uJ3NcbiAqIGl0ZXJhdG9yIChvcHRpb25hbCBvcGVyYXRpb24pLlxuICogQHBhcmFtIHtqYXZhc2NyaXB0LnV0aWwuQ29sbGVjdGlvbn0gY1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbGxlY3Rpb24gY29udGFpbnMgbm8gZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqIEByZXR1cm4ge2phdmFzY3JpcHQudXRpbC5JdGVyYXRvcn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5ICgpIHt9O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBjb2xsZWN0aW9uIGlmIGl0XG4gKiBpcyBwcmVzZW50LiAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9JdGVyYXRvci5odG1sXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yICgpIHt9O1xuXG5JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBpdGVyYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7fTtcblxuLyoqXG4gKiBSZW1vdmVzIGZyb20gdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiB0aGUgbGFzdCBlbGVtZW50IHJldHVybmVkIGJ5IHRoZVxuICogaXRlcmF0b3IgKG9wdGlvbmFsIG9wZXJhdGlvbikuXG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge307XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvTGlzdC5odG1sXG4gKlxuICogQGV4dGVuZHMge2phdmFzY3JpcHQudXRpbC5Db2xsZWN0aW9ufVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGlzdCA9IChmdW5jdGlvbiAoQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBMaXN0ICgpIHtcbiAgICBDb2xsZWN0aW9uJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24kJDEgKSBMaXN0Ll9fcHJvdG9fXyA9IENvbGxlY3Rpb24kJDE7XG4gIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiQkMSAmJiBDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpc3Q7XG5cbiAgTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHsgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGlzIGxpc3Qgd2l0aCB0aGVcbiAgICogc3BlY2lmaWVkIGVsZW1lbnQgKG9wdGlvbmFsIG9wZXJhdGlvbikuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKCkgeyB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkgeyB9O1xuXG4gIHJldHVybiBMaXN0O1xufShDb2xsZWN0aW9uKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiAobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xufVxuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ05vU3VjaEVsZW1lbnRFeGNlcHRpb24nO1xuXG4vLyBpbXBvcnQgT3BlcmF0aW9uTm90U3VwcG9ydGVkIGZyb20gJy4vT3BlcmF0aW9uTm90U3VwcG9ydGVkJ1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0FycmF5TGlzdC5odG1sXG4gKlxuICogQGV4dGVuZHMgTGlzdFxuICogQHByaXZhdGVcbiAqL1xudmFyIEFycmF5TGlzdCA9IChmdW5jdGlvbiAoTGlzdCQkMSkge1xuICBmdW5jdGlvbiBBcnJheUxpc3QgKCkge1xuICAgIExpc3QkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBMaXN0JCQxICkgQXJyYXlMaXN0Ll9fcHJvdG9fXyA9IExpc3QkJDE7XG4gIEFycmF5TGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaXN0JCQxICYmIExpc3QkJDEucHJvdG90eXBlICk7XG4gIEFycmF5TGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheUxpc3Q7XG5cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uIGVuc3VyZUNhcGFjaXR5ICgpIHt9O1xuICBBcnJheUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkgeyByZXR1cm4gW0xpc3QkJDEsIENvbGxlY3Rpb25dIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5hcnJheV8ucHVzaChlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcnJheV8uc3BsaWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBBcnJheUxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHRoaXMuYXJyYXlfID0gW107XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKGMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSBjLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIG9sZEVsZW1lbnQgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbWVudDtcbiAgICByZXR1cm4gb2xkRWxlbWVudFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcl8odGhpcylcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfW2luZGV4XVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzJDEuYXJyYXlfW2ldID09PSBvKSB7XG4gICAgICAgIHRoaXMkMS5hcnJheV8uc3BsaWNlKGksIDEpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kXG4gIH07XG5cbiAgcmV0dXJuIEFycmF5TGlzdDtcbn0oTGlzdCkpO1xuXG4vKipcbiAqIEBleHRlbmRzIHtJdGVyYXRvcn1cbiAqIEBwYXJhbSB7QXJyYXlMaXN0fSBhcnJheUxpc3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEl0ZXJhdG9yXyA9IChmdW5jdGlvbiAoSXRlcmF0b3IkJDEpIHtcbiAgZnVuY3Rpb24gSXRlcmF0b3JfIChhcnJheUxpc3QpIHtcbiAgICBJdGVyYXRvciQkMS5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheUxpc3R9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuYXJyYXlMaXN0XyA9IGFycmF5TGlzdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uXyA9IDA7XG4gIH1cblxuICBpZiAoIEl0ZXJhdG9yJCQxICkgSXRlcmF0b3JfLl9fcHJvdG9fXyA9IEl0ZXJhdG9yJCQxO1xuICBJdGVyYXRvcl8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IkJDEgJiYgSXRlcmF0b3IkJDEucHJvdG90eXBlICk7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJdGVyYXRvcl87XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fID09PSB0aGlzLmFycmF5TGlzdF8uc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKyspXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gaGFzTmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fIDwgdGhpcy5hcnJheUxpc3RfLnNpemUoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUT0RPOiBzaG91bGQgYmUgaW4gTGlzdEl0ZXJhdG9yXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXyAtIDEsIGVsZW1lbnQpXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHRoaXMuYXJyYXlMaXN0Xy5yZW1vdmUodGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXykpO1xuICB9O1xuXG4gIHJldHVybiBJdGVyYXRvcl87XG59KEl0ZXJhdG9yKSk7XG5cbnZhciBDb29yZGluYXRlTGlzdCA9IChmdW5jdGlvbiAoQXJyYXlMaXN0JCQxKSB7XG4gIGZ1bmN0aW9uIENvb3JkaW5hdGVMaXN0ICgpIHtcbiAgICBBcnJheUxpc3QkJDEuY2FsbCh0aGlzKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eShjb29yZC5sZW5ndGgpO1xuICAgICAgdGhpcy5hZGQoY29vcmQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGNvb3JkJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkoY29vcmQkMS5sZW5ndGgpO1xuICAgICAgdGhpcy5hZGQoY29vcmQkMSwgYWxsb3dSZXBlYXRlZCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBBcnJheUxpc3QkJDEgKSBDb29yZGluYXRlTGlzdC5fX3Byb3RvX18gPSBBcnJheUxpc3QkJDE7XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFycmF5TGlzdCQkMSAmJiBBcnJheUxpc3QkJDEucHJvdG90eXBlICk7XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvb3JkaW5hdGVMaXN0O1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IGNvb3JkQXJyYXlUeXBlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIHN0YXRpY0FjY2Vzc29ycy5jb29yZEFycmF5VHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoMCkuZmlsbChudWxsKSB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoaSlcbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGNvbGwgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSBjb2xsLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgICB0aGlzJDEuYWRkKGkubmV4dCgpLCBhbGxvd1JlcGVhdGVkKTtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0NoYW5nZWRcbiAgICB9IGVsc2UgeyByZXR1cm4gQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGRBbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjbG9uZSA9IEFycmF5TGlzdCQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGNsb25lLmFkZChpLCB0aGlzJDEuZ2V0KGkpLmNvcHkoKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUudG9Db29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiB0b0Nvb3JkaW5hdGVBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheShDb29yZGluYXRlTGlzdC5jb29yZEFycmF5VHlwZSlcbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgICAgQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBjb29yZCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBjb29yZCQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5hZGQoY29vcmQkMSwgYWxsb3dSZXBlYXRlZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBjb29yZCQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoIWFsbG93UmVwZWF0ZWQkMSkge1xuICAgICAgICAgIGlmICh0aGlzLnNpemUoKSA+PSAxKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZ2V0KHRoaXMuc2l6ZSgpIC0gMSk7XG4gICAgICAgICAgICBpZiAobGFzdC5lcXVhbHMyRChjb29yZCQyKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5TGlzdCQkMS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgY29vcmQkMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5hZGQob2JqLCBhbGxvd1JlcGVhdGVkJDIpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICB2YXIgY29vcmQkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkJDMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcyQxLmFkZChjb29yZCQzW2kkMV0sIGFsbG93UmVwZWF0ZWQkMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkkMiA9IGNvb3JkJDMubGVuZ3RoIC0gMTsgaSQyID49IDA7IGkkMi0tKSB7XG4gICAgICAgICAgICB0aGlzJDEuYWRkKGNvb3JkJDNbaSQyXSwgYWxsb3dSZXBlYXRlZCQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICAgICAgdmFyIGkkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGNvb3JkJDQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICghYWxsb3dSZXBlYXRlZCQ0KSB7XG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGlmIChpJDMgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXQoaSQzIC0gMSk7XG4gICAgICAgICAgICAgIGlmIChwcmV2LmVxdWFsczJEKGNvb3JkJDQpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpJDMgPCBzaXplKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXQoaSQzKTtcbiAgICAgICAgICAgICAgaWYgKG5leHQuZXF1YWxzMkQoY29vcmQkNCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheUxpc3QkJDEucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGkkMywgY29vcmQkNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgY29vcmQkNSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDUgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzWzNdO1xuICAgICAgdmFyIGluYyA9IDE7XG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHsgaW5jID0gLTE7IH1cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSAhPT0gZW5kOyBpICs9IGluYykge1xuICAgICAgICB0aGlzJDEuYWRkKGNvb3JkJDVbaV0sIGFsbG93UmVwZWF0ZWQkNSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmNsb3NlUmluZyA9IGZ1bmN0aW9uIGNsb3NlUmluZyAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpID4gMCkgeyB0aGlzLmFkZChuZXcgQ29vcmRpbmF0ZSh0aGlzLmdldCgwKSksIGZhbHNlKTsgfVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gQ29vcmRpbmF0ZUxpc3RcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZUxpc3QsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBDb29yZGluYXRlTGlzdDtcbn0oQXJyYXlMaXN0KSk7XG5cbnZhciBDb29yZGluYXRlQXJyYXlzID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUFycmF5cyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxMyA9IHsgRm9yd2FyZENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY29vcmRBcnJheVR5cGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuc3RhdGljQWNjZXNzb3JzJDEzLkZvcndhcmRDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcndhcmRDb21wYXJhdG9yIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTMuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMy5jb29yZEFycmF5VHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoMCkuZmlsbChudWxsKSB9O1xuXG5Db29yZGluYXRlQXJyYXlzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pc1JpbmcgPSBmdW5jdGlvbiBpc1JpbmcgKHB0cykge1xuICBpZiAocHRzLmxlbmd0aCA8IDQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFwdHNbMF0uZXF1YWxzMkQocHRzW3B0cy5sZW5ndGggLSAxXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Db29yZGluYXRlQXJyYXlzLnB0Tm90SW5MaXN0ID0gZnVuY3Rpb24gcHROb3RJbkxpc3QgKHRlc3RQdHMsIHB0cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGVzdFB0ID0gdGVzdFB0c1tpXTtcbiAgICBpZiAoQ29vcmRpbmF0ZUFycmF5cy5pbmRleE9mKHRlc3RQdCwgcHRzKSA8IDApIHsgcmV0dXJuIHRlc3RQdCB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5Db29yZGluYXRlQXJyYXlzLnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbCAoY29vcmRpbmF0ZXMsIGZpcnN0Q29vcmRpbmF0ZSkge1xuICB2YXIgaSA9IENvb3JkaW5hdGVBcnJheXMuaW5kZXhPZihmaXJzdENvb3JkaW5hdGUsIGNvb3JkaW5hdGVzKTtcbiAgaWYgKGkgPCAwKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG5ld0Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgU3lzdGVtLmFycmF5Y29weShjb29yZGluYXRlcywgaSwgbmV3Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLmxlbmd0aCAtIGkpO1xuICBTeXN0ZW0uYXJyYXljb3B5KGNvb3JkaW5hdGVzLCAwLCBuZXdDb29yZGluYXRlcywgY29vcmRpbmF0ZXMubGVuZ3RoIC0gaSwgaSk7XG4gIFN5c3RlbS5hcnJheWNvcHkobmV3Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcy5sZW5ndGgpO1xufTtcbkNvb3JkaW5hdGVBcnJheXMuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgY29vcmQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb29yZDIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGNvb3JkMSA9PT0gY29vcmQyKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29vcmQxID09PSBudWxsIHx8IGNvb3JkMiA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb29yZDEubGVuZ3RoICE9PSBjb29yZDIubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY29vcmQxW2ldLmVxdWFscyhjb29yZDJbaV0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBjb29yZDEkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29vcmQyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvb3JkaW5hdGVDb21wYXJhdG9yID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChjb29yZDEkMSA9PT0gY29vcmQyJDEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb29yZDEkMSA9PT0gbnVsbCB8fCBjb29yZDIkMSA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb29yZDEkMS5sZW5ndGggIT09IGNvb3JkMiQxLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkMSQxLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIGlmIChjb29yZGluYXRlQ29tcGFyYXRvci5jb21wYXJlKGNvb3JkMSQxW2kkMV0sIGNvb3JkMiQxW2kkMV0pICE9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlzLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoY29vcmRpbmF0ZXMsIGVudikge1xuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZW52LmludGVyc2VjdHMoY29vcmRpbmF0ZXNbaV0pKSB7IGNvb3JkTGlzdC5hZGQoY29vcmRpbmF0ZXNbaV0sIHRydWUpOyB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5oYXNSZXBlYXRlZFBvaW50cyA9IGZ1bmN0aW9uIGhhc1JlcGVhdGVkUG9pbnRzIChjb29yZCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvb3JkW2kgLSAxXS5lcXVhbHMoY29vcmRbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Db29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzID0gZnVuY3Rpb24gcmVtb3ZlUmVwZWF0ZWRQb2ludHMgKGNvb3JkKSB7XG4gIGlmICghQ29vcmRpbmF0ZUFycmF5cy5oYXNSZXBlYXRlZFBvaW50cyhjb29yZCkpIHsgcmV0dXJuIGNvb3JkIH1cbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdChjb29yZCwgZmFsc2UpO1xuICByZXR1cm4gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KClcbn07XG5Db29yZGluYXRlQXJyYXlzLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlIChjb29yZCkge1xuICB2YXIgbGFzdCA9IGNvb3JkLmxlbmd0aCAtIDE7XG4gIHZhciBtaWQgPSBNYXRoLnRydW5jKGxhc3QgLyAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWlkOyBpKyspIHtcbiAgICB2YXIgdG1wID0gY29vcmRbaV07XG4gICAgY29vcmRbaV0gPSBjb29yZFtsYXN0IC0gaV07XG4gICAgY29vcmRbbGFzdCAtIGldID0gdG1wO1xuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVOdWxsID0gZnVuY3Rpb24gcmVtb3ZlTnVsbCAoY29vcmQpIHtcbiAgdmFyIG5vbk51bGwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvb3JkW2ldICE9PSBudWxsKSB7IG5vbk51bGwrKzsgfVxuICB9XG4gIHZhciBuZXdDb29yZCA9IG5ldyBBcnJheShub25OdWxsKS5maWxsKG51bGwpO1xuICBpZiAobm9uTnVsbCA9PT0gMCkgeyByZXR1cm4gbmV3Q29vcmQgfVxuICB2YXIgaiA9IDA7XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkLmxlbmd0aDsgaSQxKyspIHtcbiAgICBpZiAoY29vcmRbaSQxXSAhPT0gbnVsbCkgeyBuZXdDb29yZFtqKytdID0gY29vcmRbaSQxXTsgfVxuICB9XG4gIHJldHVybiBuZXdDb29yZFxufTtcbkNvb3JkaW5hdGVBcnJheXMuY29weURlZXAgPSBmdW5jdGlvbiBjb3B5RGVlcCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3B5W2ldID0gbmV3IENvb3JkaW5hdGUoY29vcmRpbmF0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3JjID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzcmNTdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGVzdCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZGVzdFN0YXJ0ID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHNbNF07XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuZ3RoOyBpJDErKykge1xuICAgICAgZGVzdFtkZXN0U3RhcnQgKyBpJDFdID0gbmV3IENvb3JkaW5hdGUoc3JjW3NyY1N0YXJ0ICsgaSQxXSk7XG4gICAgfVxuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pc0VxdWFsUmV2ZXJzZWQgPSBmdW5jdGlvbiBpc0VxdWFsUmV2ZXJzZWQgKHB0czEsIHB0czIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAxID0gcHRzMVtpXTtcbiAgICB2YXIgcDIgPSBwdHMyW3B0czEubGVuZ3RoIC0gaSAtIDFdO1xuICAgIGlmIChwMS5jb21wYXJlVG8ocDIpICE9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Db29yZGluYXRlQXJyYXlzLmVudmVsb3BlID0gZnVuY3Rpb24gZW52ZWxvcGUgKGNvb3JkaW5hdGVzKSB7XG4gIHZhciBlbnYgPSBuZXcgRW52ZWxvcGUoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGVudi5leHBhbmRUb0luY2x1ZGUoY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBlbnZcbn07XG5Db29yZGluYXRlQXJyYXlzLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKGNvb3JkTGlzdCkge1xuICByZXR1cm4gY29vcmRMaXN0LnRvQXJyYXkoQ29vcmRpbmF0ZUFycmF5cy5jb29yZEFycmF5VHlwZSlcbn07XG5Db29yZGluYXRlQXJyYXlzLmF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcgPSBmdW5jdGlvbiBhdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nIChuLCBjKSB7XG4gIHJldHVybiBjLmxlbmd0aCA+PSBuID8gYyA6IFtdXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoY29vcmRpbmF0ZSwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb29yZGluYXRlLmVxdWFscyhjb29yZGluYXRlc1tpXSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaW5jcmVhc2luZ0RpcmVjdGlvbiA9IGZ1bmN0aW9uIGluY3JlYXNpbmdEaXJlY3Rpb24gKHB0cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgudHJ1bmMocHRzLmxlbmd0aCAvIDIpOyBpKyspIHtcbiAgICB2YXIgaiA9IHB0cy5sZW5ndGggLSAxIC0gaTtcbiAgICB2YXIgY29tcCA9IHB0c1tpXS5jb21wYXJlVG8ocHRzW2pdKTtcbiAgICBpZiAoY29tcCAhPT0gMCkgeyByZXR1cm4gY29tcCB9XG4gIH1cbiAgcmV0dXJuIDFcbn07XG5Db29yZGluYXRlQXJyYXlzLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChwdHMxLCBwdHMyKSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBwdHMxLmxlbmd0aCAmJiBpIDwgcHRzMi5sZW5ndGgpIHtcbiAgICB2YXIgY29tcGFyZSA9IHB0czFbaV0uY29tcGFyZVRvKHB0czJbaV0pO1xuICAgIGlmIChjb21wYXJlICE9PSAwKSB7IHJldHVybiBjb21wYXJlIH1cbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPCBwdHMyLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAoaSA8IHB0czEubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Db29yZGluYXRlQXJyYXlzLm1pbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiBtaW5Db29yZGluYXRlIChjb29yZGluYXRlcykge1xuICB2YXIgbWluQ29vcmQgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pbkNvb3JkID09PSBudWxsIHx8IG1pbkNvb3JkLmNvbXBhcmVUbyhjb29yZGluYXRlc1tpXSkgPiAwKSB7XG4gICAgICBtaW5Db29yZCA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluQ29vcmRcbn07XG5Db29yZGluYXRlQXJyYXlzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0IChwdHMsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBNYXRoVXRpbC5jbGFtcChzdGFydCwgMCwgcHRzLmxlbmd0aCk7XG4gIGVuZCA9IE1hdGhVdGlsLmNsYW1wKGVuZCwgLTEsIHB0cy5sZW5ndGgpO1xuICB2YXIgbnB0cyA9IGVuZCAtIHN0YXJ0ICsgMTtcbiAgaWYgKGVuZCA8IDApIHsgbnB0cyA9IDA7IH1cbiAgaWYgKHN0YXJ0ID49IHB0cy5sZW5ndGgpIHsgbnB0cyA9IDA7IH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7IG5wdHMgPSAwOyB9XG4gIHZhciBleHRyYWN0UHRzID0gbmV3IEFycmF5KG5wdHMpLmZpbGwobnVsbCk7XG4gIGlmIChucHRzID09PSAwKSB7IHJldHVybiBleHRyYWN0UHRzIH1cbiAgdmFyIGlQdHMgPSAwO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBleHRyYWN0UHRzW2lQdHMrK10gPSBwdHNbaV07XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RQdHNcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlzLCBzdGF0aWNBY2Nlc3NvcnMkMTMgKTtcblxudmFyIEZvcndhcmRDb21wYXJhdG9yID0gZnVuY3Rpb24gRm9yd2FyZENvbXBhcmF0b3IgKCkge307XG5cbkZvcndhcmRDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzLmNvbXBhcmUocHRzMSwgcHRzMilcbn07XG5Gb3J3YXJkQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5Gb3J3YXJkQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBGb3J3YXJkQ29tcGFyYXRvclxufTtcblxudmFyIEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yID0gZnVuY3Rpb24gQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IgKCkge307XG5cbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIGlmIChwdHMxLmxlbmd0aCA8IHB0czIubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA+IHB0czIubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgaWYgKHB0czEubGVuZ3RoID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGZvcndhcmRDb21wID0gQ29vcmRpbmF0ZUFycmF5cy5jb21wYXJlKHB0czEsIHB0czIpO1xuICB2YXIgaXNFcXVhbFJldiA9IENvb3JkaW5hdGVBcnJheXMuaXNFcXVhbFJldmVyc2VkKHB0czEsIHB0czIpO1xuICBpZiAoaXNFcXVhbFJldikgeyByZXR1cm4gMCB9XG4gIHJldHVybiBmb3J3YXJkQ29tcFxufTtcbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5PTERjb21wYXJlID0gZnVuY3Rpb24gT0xEY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIGlmIChwdHMxLmxlbmd0aCA8IHB0czIubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA+IHB0czIubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgaWYgKHB0czEubGVuZ3RoID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGRpcjEgPSBDb29yZGluYXRlQXJyYXlzLmluY3JlYXNpbmdEaXJlY3Rpb24ocHRzMSk7XG4gIHZhciBkaXIyID0gQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uKHB0czIpO1xuICB2YXIgaTEgPSBkaXIxID4gMCA/IDAgOiBwdHMxLmxlbmd0aCAtIDE7XG4gIHZhciBpMiA9IGRpcjIgPiAwID8gMCA6IHB0czEubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBhcmVQdCA9IHB0czFbaTFdLmNvbXBhcmVUbyhwdHMyW2kyXSk7XG4gICAgaWYgKGNvbXBhcmVQdCAhPT0gMCkgeyByZXR1cm4gY29tcGFyZVB0IH1cbiAgICBpMSArPSBkaXIxO1xuICAgIGkyICs9IGRpcjI7XG4gIH1cbiAgcmV0dXJuIDBcbn07XG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCaWRpcmVjdGlvbmFsQ29tcGFyYXRvclxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9NYXAuaHRtbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIE1hcCQxID0gZnVuY3Rpb24gTWFwICgpIHt9O1xuXG5NYXAkMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHt9O1xuLyoqXG4gKiBBc3NvY2lhdGVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGlzIG1hcCAob3B0aW9uYWxcbiAqIG9wZXJhdGlvbikuXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWFwJDEucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIHB1dCAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIG1hcHBpbmdzIGluIHRoaXMgbWFwLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5NYXAkMS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhIENvbGxlY3Rpb24gdmlldyBvZiB0aGUgdmFsdWVzIGNvbnRhaW5lZCBpbiB0aGlzIG1hcC5cbiAqIEByZXR1cm4ge2phdmFzY3JpcHQudXRpbC5Db2xsZWN0aW9ufVxuICovXG5NYXAkMS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYSB7QGxpbmsgU2V0fSB2aWV3IG9mIHRoZSBtYXBwaW5ncyBjb250YWluZWQgaW4gdGhpcyBtYXAuXG4gKiBUaGUgc2V0IGlzIGJhY2tlZCBieSB0aGUgbWFwLCBzbyBjaGFuZ2VzIHRvIHRoZSBtYXAgYXJlXG4gKiByZWZsZWN0ZWQgaW4gdGhlIHNldCwgYW5kIHZpY2UtdmVyc2EuSWYgdGhlIG1hcCBpcyBtb2RpZmllZFxuICogd2hpbGUgYW4gaXRlcmF0aW9uIG92ZXIgdGhlIHNldCBpcyBpbiBwcm9ncmVzcyAoZXhjZXB0IHRocm91Z2hcbiAqIHRoZSBpdGVyYXRvcidzIG93biA8dHQ+cmVtb3ZlPC90dD4gb3BlcmF0aW9uLCBvciB0aHJvdWdoIHRoZVxuICogPHR0PnNldFZhbHVlPC90dD4gb3BlcmF0aW9uIG9uIGEgbWFwIGVudHJ5IHJldHVybmVkIGJ5IHRoZVxuICogaXRlcmF0b3IpIHRoZSByZXN1bHRzIG9mIHRoZSBpdGVyYXRpb24gYXJlIHVuZGVmaW5lZC5UaGUgc2V0XG4gKiBzdXBwb3J0cyBlbGVtZW50IHJlbW92YWwsIHdoaWNoIHJlbW92ZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIG1hcHBpbmcgZnJvbSB0aGUgbWFwLCB2aWEgdGhlIDx0dD5JdGVyYXRvci5yZW1vdmU8L3R0PixcbiAqIDx0dD5TZXQucmVtb3ZlPC90dD4sIDx0dD5yZW1vdmVBbGw8L3R0PiwgPHR0PnJldGFpbkFsbDwvdHQ+IGFuZFxuICogPHR0PmNsZWFyPC90dD4gb3BlcmF0aW9ucy5JdCBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICogPHR0PmFkZDwvdHQ+IG9yIDx0dD5hZGRBbGw8L3R0PiBvcGVyYXRpb25zLlxuICpcbiAqIEByZXR1cm4ge1NldH0gYSBzZXQgdmlldyBvZiB0aGUgbWFwcGluZ3MgY29udGFpbmVkIGluIHRoaXMgbWFwXG4gKi9cbk1hcCQxLnByb3RvdHlwZS5lbnRyeVNldCA9IGZ1bmN0aW9uIGVudHJ5U2V0ICgpIHt9O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1NvcnRlZE1hcC5odG1sXG4gKlxuICogQGV4dGVuZHMge01hcH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIFNvcnRlZE1hcCA9IChmdW5jdGlvbiAoTWFwKSB7XG5cdGZ1bmN0aW9uIFNvcnRlZE1hcCAoKSB7XG5cdFx0TWFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1pZiAoIE1hcCApIFNvcnRlZE1hcC5fX3Byb3RvX18gPSBNYXA7XG5cdFNvcnRlZE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXAgJiYgTWFwLnByb3RvdHlwZSApO1xuXHRTb3J0ZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29ydGVkTWFwO1xuXG5cdFxuXG5cdHJldHVybiBTb3J0ZWRNYXA7XG59KE1hcCQxKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gT3BlcmF0aW9uTm90U3VwcG9ydGVkIChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG59XG5PcGVyYXRpb25Ob3RTdXBwb3J0ZWQucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuT3BlcmF0aW9uTm90U3VwcG9ydGVkLnByb3RvdHlwZS5uYW1lID0gJ09wZXJhdGlvbk5vdFN1cHBvcnRlZCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7Q29sbGVjdGlvbn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU2V0KCkge31cblNldC5wcm90b3R5cGUgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2V0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gTW9yZSBmb3JtYWxseSxcbiAqIHJldHVybnMgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHNldCBjb250YWlucyBhbiBlbGVtZW50IGUgc3VjaCB0aGF0IChvPT1udWxsID9cbiAqIGU9PW51bGwgOiBvLmVxdWFscyhlKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9IYXNoU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7amF2YXNjcmlwdC51dGlsLlNldH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEhhc2hTZXQgPSAoZnVuY3Rpb24gKFNldCQkMSkge1xuICBmdW5jdGlvbiBIYXNoU2V0ICgpIHtcbiAgICBTZXQkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTZXQkJDEgKSBIYXNoU2V0Ll9fcHJvdG9fXyA9IFNldCQkMTtcbiAgSGFzaFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXQkJDEgJiYgU2V0JCQxLnByb3RvdHlwZSApO1xuICBIYXNoU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hTZXQ7XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZSA9IHRoaXMkMS5hcnJheV9baV07XG4gICAgICBpZiAoZSA9PT0gbykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG8pIHtcbiAgICBpZiAodGhpcy5jb250YWlucyhvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5hcnJheV8ucHVzaChvKTtcblxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gYy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobykge1xuICAgIC8vIHRocm93IG5ldyBqYXZhc2NyaXB0LnV0aWwuT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yXyQxKHRoaXMpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hTZXQ7XG59KFNldCkpO1xuXG4vKipcbiAgICogQGV4dGVuZHMge0l0ZXJhdG9yfVxuICAgKiBAcGFyYW0ge0hhc2hTZXR9IGhhc2hTZXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xudmFyIEl0ZXJhdG9yXyQxID0gKGZ1bmN0aW9uIChJdGVyYXRvciQkMSkge1xuICBmdW5jdGlvbiBJdGVyYXRvcl8gKGhhc2hTZXQpIHtcbiAgICBJdGVyYXRvciQkMS5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIYXNoU2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5oYXNoU2V0XyA9IGhhc2hTZXQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb25fID0gMDtcbiAgfVxuXG4gIGlmICggSXRlcmF0b3IkJDEgKSBJdGVyYXRvcl8uX19wcm90b19fID0gSXRlcmF0b3IkJDE7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciQkMSAmJiBJdGVyYXRvciQkMS5wcm90b3R5cGUgKTtcbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEl0ZXJhdG9yXztcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbl8gPT09IHRoaXMuaGFzaFNldF8uc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhc2hTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uXyA8IHRoaXMuaGFzaFNldF8uc2l6ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHRocm93IG5ldyBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxuICB9O1xuXG4gIHJldHVybiBJdGVyYXRvcl87XG59KEl0ZXJhdG9yKSk7XG5cbnZhciBCTEFDSyA9IDA7XG52YXIgUkVEID0gMTtcbmZ1bmN0aW9uIGNvbG9yT2YgKHApIHsgcmV0dXJuIChwID09PSBudWxsID8gQkxBQ0sgOiBwLmNvbG9yKSB9XG5mdW5jdGlvbiBwYXJlbnRPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBudWxsIDogcC5wYXJlbnQpIH1cbmZ1bmN0aW9uIHNldENvbG9yIChwLCBjKSB7IGlmIChwICE9PSBudWxsKSB7IHAuY29sb3IgPSBjOyB9IH1cbmZ1bmN0aW9uIGxlZnRPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBudWxsIDogcC5sZWZ0KSB9XG5mdW5jdGlvbiByaWdodE9mIChwKSB7IHJldHVybiAocCA9PT0gbnVsbCA/IG51bGwgOiBwLnJpZ2h0KSB9XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvVHJlZU1hcC5odG1sXG4gKlxuICogQGV4dGVuZHMge1NvcnRlZE1hcH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJlZU1hcCAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290XyA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLnNpemVfID0gMDtcbn1cblRyZWVNYXAucHJvdG90eXBlID0gbmV3IFNvcnRlZE1hcCgpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBwID0gdGhpcy5yb290XztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICB2YXIgY21wID0ga2V5Wydjb21wYXJlVG8nXShwLmtleSk7XG4gICAgaWYgKGNtcCA8IDApIHsgcCA9IHAubGVmdDsgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHsgcCA9IHAucmlnaHQ7IH1cbiAgICBlbHNlIHsgcmV0dXJuIHAudmFsdWUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5yb290XyA9PT0gbnVsbCkge1xuICAgIHRoaXMucm9vdF8gPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGNvbG9yOiBCTEFDSyxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7IHJldHVybiB0aGlzLnZhbHVlIH0sXG4gICAgICBnZXRLZXk6IGZ1bmN0aW9uIGdldEtleSAoKSB7IHJldHVybiB0aGlzLmtleSB9XG4gICAgfTtcbiAgICB0aGlzLnNpemVfID0gMTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB0ID0gdGhpcy5yb290XztcbiAgdmFyIHBhcmVudDtcbiAgdmFyIGNtcDtcbiAgZG8ge1xuICAgIHBhcmVudCA9IHQ7XG4gICAgY21wID0ga2V5Wydjb21wYXJlVG8nXSh0LmtleSk7XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIHQgPSB0LmxlZnQ7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICB0ID0gdC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZFZhbHVlID0gdC52YWx1ZTtcbiAgICAgIHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgIH1cbiAgfSB3aGlsZSAodCAhPT0gbnVsbClcbiAgdmFyIGUgPSB7XG4gICAga2V5OiBrZXksXG4gICAgbGVmdDogbnVsbCxcbiAgICByaWdodDogbnVsbCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY29sb3I6IEJMQUNLLFxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7IHJldHVybiB0aGlzLnZhbHVlIH0sXG4gICAgZ2V0S2V5OiBmdW5jdGlvbiBnZXRLZXkgKCkgeyByZXR1cm4gdGhpcy5rZXkgfVxuICB9O1xuICBpZiAoY21wIDwgMCkge1xuICAgIHBhcmVudC5sZWZ0ID0gZTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQucmlnaHQgPSBlO1xuICB9XG4gIHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24oZSk7XG4gIHRoaXMuc2l6ZV8rKztcbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHhcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb24gPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB4LmNvbG9yID0gUkVEO1xuICB3aGlsZSAoeCAhPSBudWxsICYmIHggIT09IHRoaXMucm9vdF8gJiYgeC5wYXJlbnQuY29sb3IgPT09IFJFRCkge1xuICAgIGlmIChwYXJlbnRPZih4KSA9PT0gbGVmdE9mKHBhcmVudE9mKHBhcmVudE9mKHgpKSkpIHtcbiAgICAgIHZhciB5ID0gcmlnaHRPZihwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgaWYgKGNvbG9yT2YoeSkgPT09IFJFRCkge1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcih5LCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgeCA9IHBhcmVudE9mKHBhcmVudE9mKHgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4ID09PSByaWdodE9mKHBhcmVudE9mKHgpKSkge1xuICAgICAgICAgIHggPSBwYXJlbnRPZih4KTtcbiAgICAgICAgICB0aGlzJDEucm90YXRlTGVmdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHRoaXMkMS5yb3RhdGVSaWdodChwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeSQxID0gbGVmdE9mKHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICBpZiAoY29sb3JPZih5JDEpID09PSBSRUQpIHtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YoeCksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IoeSQxLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgeCA9IHBhcmVudE9mKHBhcmVudE9mKHgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4ID09PSBsZWZ0T2YocGFyZW50T2YoeCkpKSB7XG4gICAgICAgICAgeCA9IHBhcmVudE9mKHgpO1xuICAgICAgICAgIHRoaXMkMS5yb3RhdGVSaWdodCh4KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHRoaXMkMS5yb3RhdGVMZWZ0KHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucm9vdF8uY29sb3IgPSBCTEFDSztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIHAgPSB0aGlzLmdldEZpcnN0RW50cnkoKTtcbiAgaWYgKHAgIT09IG51bGwpIHtcbiAgICBhcnJheUxpc3QuYWRkKHAudmFsdWUpO1xuICAgIHdoaWxlICgocCA9IFRyZWVNYXAuc3VjY2Vzc29yKHApKSAhPT0gbnVsbCkge1xuICAgICAgYXJyYXlMaXN0LmFkZChwLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5TGlzdFxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZW50cnlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYXNoU2V0ID0gbmV3IEhhc2hTZXQoKTtcbiAgdmFyIHAgPSB0aGlzLmdldEZpcnN0RW50cnkoKTtcbiAgaWYgKHAgIT09IG51bGwpIHtcbiAgICBoYXNoU2V0LmFkZChwKTtcbiAgICB3aGlsZSAoKHAgPSBUcmVlTWFwLnN1Y2Nlc3NvcihwKSkgIT09IG51bGwpIHtcbiAgICAgIGhhc2hTZXQuYWRkKHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaFNldFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcFxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKHApIHtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciByID0gcC5yaWdodDtcbiAgICBwLnJpZ2h0ID0gci5sZWZ0O1xuICAgIGlmIChyLmxlZnQgIT0gbnVsbCkgeyByLmxlZnQucGFyZW50ID0gcDsgfVxuICAgIHIucGFyZW50ID0gcC5wYXJlbnQ7XG4gICAgaWYgKHAucGFyZW50ID09PSBudWxsKSB7IHRoaXMucm9vdF8gPSByOyB9IGVsc2UgaWYgKHAucGFyZW50LmxlZnQgPT09IHApIHsgcC5wYXJlbnQubGVmdCA9IHI7IH0gZWxzZSB7IHAucGFyZW50LnJpZ2h0ID0gcjsgfVxuICAgIHIubGVmdCA9IHA7XG4gICAgcC5wYXJlbnQgPSByO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKHApIHtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciBsID0gcC5sZWZ0O1xuICAgIHAubGVmdCA9IGwucmlnaHQ7XG4gICAgaWYgKGwucmlnaHQgIT0gbnVsbCkgeyBsLnJpZ2h0LnBhcmVudCA9IHA7IH1cbiAgICBsLnBhcmVudCA9IHAucGFyZW50O1xuICAgIGlmIChwLnBhcmVudCA9PT0gbnVsbCkgeyB0aGlzLnJvb3RfID0gbDsgfSBlbHNlIGlmIChwLnBhcmVudC5yaWdodCA9PT0gcCkgeyBwLnBhcmVudC5yaWdodCA9IGw7IH0gZWxzZSB7IHAucGFyZW50LmxlZnQgPSBsOyB9XG4gICAgbC5yaWdodCA9IHA7XG4gICAgcC5wYXJlbnQgPSBsO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZ2V0Rmlyc3RFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHAgPSB0aGlzLnJvb3RfO1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgd2hpbGUgKHAubGVmdCAhPSBudWxsKSB7XG4gICAgICBwID0gcC5sZWZ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuVHJlZU1hcC5zdWNjZXNzb3IgPSBmdW5jdGlvbiAodCkge1xuICBpZiAodCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9IGVsc2UgaWYgKHQucmlnaHQgIT09IG51bGwpIHtcbiAgICB2YXIgcCA9IHQucmlnaHQ7XG4gICAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCkge1xuICAgICAgcCA9IHAubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHBcbiAgfSBlbHNlIHtcbiAgICB2YXIgcCQxID0gdC5wYXJlbnQ7XG4gICAgdmFyIGNoID0gdDtcbiAgICB3aGlsZSAocCQxICE9PSBudWxsICYmIGNoID09PSBwJDEucmlnaHQpIHtcbiAgICAgIGNoID0gcCQxO1xuICAgICAgcCQxID0gcCQxLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHAkMVxuICB9XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaXplX1xufTtcblxudmFyIExpbmVhbCA9IGZ1bmN0aW9uIExpbmVhbCAoKSB7fTtcblxuTGluZWFsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGluZWFsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVhbFxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9Tb3J0ZWRTZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtTZXR9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFNvcnRlZFNldCAoKSB7fVxuU29ydGVkU2V0LnByb3RvdHlwZSA9IG5ldyBTZXQoKTtcblxuLy8gaW1wb3J0IEl0ZXJhdG9yIGZyb20gJy4vSXRlcmF0b3InXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1RyZWVTZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtTb3J0ZWRTZXR9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRyZWVTZXQgKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKTtcbiAgfVxufVxuVHJlZVNldC5wcm90b3R5cGUgPSBuZXcgU29ydGVkU2V0KCk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG8pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuYXJyYXlfW2ldO1xuICAgIGlmIChlWydjb21wYXJlVG8nXShvKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5jb250YWlucyhvKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuYXJyYXlfW2ldO1xuICAgIGlmIChlWydjb21wYXJlVG8nXShvKSA9PT0gMSkge1xuICAgICAgdGhpcyQxLmFycmF5Xy5zcGxpY2UoaSwgMCwgbyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlfLnB1c2gobyk7XG5cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIChjKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSBjLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICB0aHJvdyBuZXcgT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGhcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5LnB1c2godGhpcyQxLmFycmF5X1tpXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEl0ZXJhdG9yXyQyKHRoaXMpXG59O1xuXG4vKipcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuSXRlcmF0b3J9XG4gKiBAcGFyYW0ge2phdmFzY3JpcHQudXRpbC5UcmVlU2V0fSB0cmVlU2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJdGVyYXRvcl8kMiA9IGZ1bmN0aW9uICh0cmVlU2V0KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7amF2YXNjcmlwdC51dGlsLlRyZWVTZXR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyZWVTZXRfID0gdHJlZVNldDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5JdGVyYXRvcl8kMi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucG9zaXRpb25fID09PSB0aGlzLnRyZWVTZXRfLnNpemUoKSkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK11cbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkl0ZXJhdG9yXyQyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3NpdGlvbl8gPCB0aGlzLnRyZWVTZXRfLnNpemUoKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkl0ZXJhdG9yXyQyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9BcnJheXMuaHRtbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEFycmF5cyA9IGZ1bmN0aW9uIEFycmF5cyAoKSB7fTtcblxuQXJyYXlzLnNvcnQgPSBmdW5jdGlvbiBzb3J0ICgpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gIHZhciBpO1xuICB2YXIgdDtcbiAgdmFyIGNvbXBhcmF0b3I7XG4gIHZhciBjb21wYXJlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpXG4gICAgfTtcbiAgICBhLnNvcnQoY29tcGFyZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbXBhcmF0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclsnY29tcGFyZSddKGEsIGIpXG4gICAgfTtcbiAgICBhLnNvcnQoY29tcGFyZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHQgPSBhLnNsaWNlKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB0LnNvcnQoKTtcbiAgICB2YXIgciA9IGEuc2xpY2UoMCwgYXJndW1lbnRzWzFdKS5jb25jYXQodCwgYS5zbGljZShhcmd1bWVudHNbMl0sIGEubGVuZ3RoKSk7XG4gICAgYS5zcGxpY2UoMCwgYS5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhLnB1c2gocltpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB0ID0gYS5zbGljZShhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgY29tcGFyYXRvciA9IGFyZ3VtZW50c1szXTtcbiAgICBjb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yWydjb21wYXJlJ10oYSwgYilcbiAgICB9O1xuICAgIHQuc29ydChjb21wYXJlKTtcbiAgICByID0gYS5zbGljZSgwLCBhcmd1bWVudHNbMV0pLmNvbmNhdCh0LCBhLnNsaWNlKGFyZ3VtZW50c1syXSwgYS5sZW5ndGgpKTtcbiAgICBhLnNwbGljZSgwLCBhLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGEucHVzaChyW2ldKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheUxpc3R9XG4gKi9cbkFycmF5cy5hc0xpc3QgPSBmdW5jdGlvbiBhc0xpc3QgKGFycmF5KSB7XG4gIHZhciBhcnJheUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5TGlzdC5hZGQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBhcnJheUxpc3Rcbn07XG5cbnZhciBEaW1lbnNpb24gPSBmdW5jdGlvbiBEaW1lbnNpb24gKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTQgPSB7IFA6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTDogeyBjb25maWd1cmFibGU6IHRydWUgfSxBOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEZBTFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRSVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRE9OVENBUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX0ZBTFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9UUlVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9ET05UQ0FSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fUDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fTDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fQTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMTQuUC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuTC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuQS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuRkFMU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5UUlVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0yIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuRE9OVENBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTMgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fRkFMU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0YnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX1RSVUUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1QnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX0RPTlRDQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcqJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9QLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcwJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9MLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcxJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9BLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcyJyB9O1xuXG5EaW1lbnNpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGltZW5zaW9uXG59O1xuRGltZW5zaW9uLnRvRGltZW5zaW9uU3ltYm9sID0gZnVuY3Rpb24gdG9EaW1lbnNpb25TeW1ib2wgKGRpbWVuc2lvblZhbHVlKSB7XG4gIHN3aXRjaCAoZGltZW5zaW9uVmFsdWUpIHtcbiAgICBjYXNlIERpbWVuc2lvbi5GQUxTRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0ZBTFNFXG4gICAgY2FzZSBEaW1lbnNpb24uVFJVRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX1RSVUVcbiAgICBjYXNlIERpbWVuc2lvbi5ET05UQ0FSRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0RPTlRDQVJFXG4gICAgY2FzZSBEaW1lbnNpb24uUDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX1BcbiAgICBjYXNlIERpbWVuc2lvbi5MOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fTFxuICAgIGNhc2UgRGltZW5zaW9uLkE6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9BXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogJyArIGRpbWVuc2lvblZhbHVlKVxufTtcbkRpbWVuc2lvbi50b0RpbWVuc2lvblZhbHVlID0gZnVuY3Rpb24gdG9EaW1lbnNpb25WYWx1ZSAoZGltZW5zaW9uU3ltYm9sKSB7XG4gIHN3aXRjaCAoQ2hhcmFjdGVyLnRvVXBwZXJDYXNlKGRpbWVuc2lvblN5bWJvbCkpIHtcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fRkFMU0U6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX1RSVUU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlRSVUVcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fRE9OVENBUkU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkRPTlRDQVJFXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX1A6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlBcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fTDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uTFxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9BOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5BXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6ICcgKyBkaW1lbnNpb25TeW1ib2wpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRGltZW5zaW9uLCBzdGF0aWNBY2Nlc3NvcnMkMTQgKTtcblxudmFyIEdlb21ldHJ5RmlsdGVyID0gZnVuY3Rpb24gR2VvbWV0cnlGaWx0ZXIgKCkge307XG5cbkdlb21ldHJ5RmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHt9O1xuR2VvbWV0cnlGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUZpbHRlclxufTtcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlciA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlciAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaSkge307XG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuaXNHZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q2hhbmdlZCAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJcbn07XG5cbnZhciBHZW9tZXRyeUNvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbWV0cmllcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fZ2VvbWV0cmllcyA9IGdlb21ldHJpZXMgfHwgW107XG5cbiAgICBpZiAoR2VvbWV0cnkkJDEuaGFzTnVsbEVsZW1lbnRzKHRoaXMuX2dlb21ldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50cycpXG4gICAgfVxuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIEdlb21ldHJ5Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBHZW9tZXRyeSQkMTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnlDb2xsZWN0aW9uO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBlbnZlbG9wZSA9IG5ldyBFbnZlbG9wZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZW52ZWxvcGUuZXhwYW5kVG9JbmNsdWRlKHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZW52ZWxvcGVcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRHZW9tZXRyeU4gPSBmdW5jdGlvbiBnZXRHZW9tZXRyeU4gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1tuXVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT05cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO1xuICAgIHZhciBrID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRDb29yZGluYXRlcyA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZENvb3JkaW5hdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGsrKztcbiAgICAgICAgY29vcmRpbmF0ZXNba10gPSBjaGlsZENvb3JkaW5hdGVzW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXNcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZWEgKz0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldEFyZWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWFcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHZhciBvdGhlckNvbGxlY3Rpb24gPSBvdGhlcjtcbiAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCAhPT0gb3RoZXJDb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMkMS5fZ2VvbWV0cmllc1tpXS5lcXVhbHNFeGFjdChvdGhlckNvbGxlY3Rpb24uX2dlb21ldHJpZXNbaV0sIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgQXJyYXlzLnNvcnQodGhpcy5fZ2VvbWV0cmllcyk7XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZGltZW5zaW9uID0gRGltZW5zaW9uLkZBTFNFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGltZW5zaW9uID0gTWF0aC5tYXgoZGltZW5zaW9uLCB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IERpbWVuc2lvbi5GQUxTRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpbWVuc2lvbiA9IE1hdGgubWF4KGRpbWVuc2lvbiwgdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldERpbWVuc2lvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvblxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3VtID0gMC4wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VtICs9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbnVtUG9pbnRzID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG51bVBvaW50cyArPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0TnVtUG9pbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1Qb2ludHNcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROdW1HZW9tZXRyaWVzID0gZnVuY3Rpb24gZ2V0TnVtR2VvbWV0cmllcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG4gPSB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB2YXIgcmV2R2VvbXMgPSBuZXcgQXJyYXkobikuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldkdlb21zW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihyZXZHZW9tcylcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21wYXJlVG9TYW1lQ2xhc3MgPSBmdW5jdGlvbiBjb21wYXJlVG9TYW1lQ2xhc3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRoZXNlRWxlbWVudHMgPSBuZXcgVHJlZVNldChBcnJheXMuYXNMaXN0KHRoaXMuX2dlb21ldHJpZXMpKTtcbiAgICAgIHZhciBvdGhlckVsZW1lbnRzID0gbmV3IFRyZWVTZXQoQXJyYXlzLmFzTGlzdChvLl9nZW9tZXRyaWVzKSk7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHRoZXNlRWxlbWVudHMsIG90aGVyRWxlbWVudHMpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZ2MgPSBvJDE7XG4gICAgICB2YXIgbjEgPSB0aGlzLmdldE51bUdlb21ldHJpZXMoKTtcbiAgICAgIHZhciBuMiA9IGdjLmdldE51bUdlb21ldHJpZXMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbjEgJiYgaSA8IG4yKSB7XG4gICAgICAgIHZhciB0aGlzR2VvbSA9IHRoaXMkMS5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICAgIHZhciBvdGhlckdlb20gPSBnYy5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICAgIHZhciBob2xlQ29tcCA9IHRoaXNHZW9tLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlckdlb20sIGNvbXApO1xuICAgICAgICBpZiAoaG9sZUNvbXAgIT09IDApIHsgcmV0dXJuIGhvbGVDb21wIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBuMSkgeyByZXR1cm4gMSB9XG4gICAgICBpZiAoaSA8IG4yKSB7IHJldHVybiAtMSB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaV0uYXBwbHkoZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2kkMV0uYXBwbHkoZmlsdGVyJDEpO1xuICAgICAgICBpZiAoZmlsdGVyJDEuaXNEb25lKCkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyJDEuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQyLmZpbHRlcih0aGlzKTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaSQyXS5hcHBseShmaWx0ZXIkMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUNvbXBvbmVudEZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQzLmZpbHRlcih0aGlzKTtcbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpJDMrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaSQzXS5hcHBseShmaWx0ZXIkMyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyk7XG4gICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnYyA9IEdlb21ldHJ5JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGdjLl9nZW9tZXRyaWVzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2MuX2dlb21ldHJpZXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdjXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ0dlb21ldHJ5Q29sbGVjdGlvbidcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJpZXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzJDEuX2dlb21ldHJpZXNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTU2OTQ3Mjc3MjYzOTUwMjE0NjcgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlDb2xsZWN0aW9uLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uO1xufShHZW9tZXRyeSkpO1xuXG52YXIgTXVsdGlMaW5lU3RyaW5nID0gKGZ1bmN0aW9uIChHZW9tZXRyeUNvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTXVsdGlMaW5lU3RyaW5nICgpIHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICkgTXVsdGlMaW5lU3RyaW5nLl9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSAmJiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aUxpbmVTdHJpbmc7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX01VTFRJTElORVNUUklOR1xuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcywgb3RoZXIsIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuTGluZXMgPSB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB2YXIgcmV2TGluZXMgPSBuZXcgQXJyYXkobkxpbmVzKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV2TGluZXNbbkxpbmVzIC0gMSAtIGldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhyZXZMaW5lcylcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kYXJ5T3AodGhpcykuZ2V0Qm91bmRhcnkoKVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdNdWx0aUxpbmVTdHJpbmcnXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxpbmVTdHJpbmdzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVTdHJpbmdzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtMaW5lYWxdXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE11bHRpTGluZVN0cmluZ1xuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA4MTY2NjY1MTMyNDQ1NDMzNzQxIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpTGluZVN0cmluZywgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE11bHRpTGluZVN0cmluZztcbn0oR2VvbWV0cnlDb2xsZWN0aW9uKSk7XG5cbnZhciBCb3VuZGFyeU9wID0gZnVuY3Rpb24gQm91bmRhcnlPcCAoKSB7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdCA9IG51bGw7XG4gIHRoaXMuX2JuUnVsZSA9IG51bGw7XG4gIHRoaXMuX2VuZHBvaW50TWFwID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm5SdWxlID0gQm91bmRhcnlOb2RlUnVsZS5NT0QyX0JPVU5EQVJZX1JVTEU7XG4gICAgdGhpcy5fZ2VvbSA9IGdlb207XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBnZW9tLmdldEZhY3RvcnkoKTtcbiAgICB0aGlzLl9iblJ1bGUgPSBiblJ1bGU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJuUnVsZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2dlb20gPSBnZW9tJDE7XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBnZW9tJDEuZ2V0RmFjdG9yeSgpO1xuICAgIHRoaXMuX2JuUnVsZSA9IGJuUnVsZSQxO1xuICB9XG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBib3VuZGFyeU11bHRpTGluZVN0cmluZyAobUxpbmUpIHtcbiAgaWYgKHRoaXMuX2dlb20uaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KClcbiAgfVxuICB2YXIgYmR5UHRzID0gdGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyhtTGluZSk7XG4gIGlmIChiZHlQdHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KGJkeVB0c1swXSlcbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoYmR5UHRzKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICBpZiAodGhpcy5fZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuX2dlb20pIH1cbiAgaWYgKHRoaXMuX2dlb20gaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5fZ2VvbSkgfVxuICByZXR1cm4gdGhpcy5fZ2VvbS5nZXRCb3VuZGFyeSgpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuYm91bmRhcnlMaW5lU3RyaW5nID0gZnVuY3Rpb24gYm91bmRhcnlMaW5lU3RyaW5nIChsaW5lKSB7XG4gIGlmICh0aGlzLl9nZW9tLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpXG4gIH1cbiAgaWYgKGxpbmUuaXNDbG9zZWQoKSkge1xuICAgIHZhciBjbG9zZWRFbmRwb2ludE9uQm91bmRhcnkgPSB0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpO1xuICAgIGlmIChjbG9zZWRFbmRwb2ludE9uQm91bmRhcnkpIHtcbiAgICAgIHJldHVybiBsaW5lLmdldFN0YXJ0UG9pbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFtsaW5lLmdldFN0YXJ0UG9pbnQoKSwgbGluZS5nZXRFbmRQb2ludCgpXSlcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5nZXRFbXB0eU11bHRpUG9pbnQgPSBmdW5jdGlvbiBnZXRFbXB0eU11bHRpUG9pbnQgKCkge1xuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyAobUxpbmUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgYmR5UHRzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9lbmRwb2ludE1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbUxpbmUuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IG1MaW5lLmdldEdlb21ldHJ5TihpKTtcbiAgICBpZiAobGluZS5nZXROdW1Qb2ludHMoKSA9PT0gMCkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmFkZEVuZHBvaW50KGxpbmUuZ2V0Q29vcmRpbmF0ZU4oMCkpO1xuICAgIHRoaXMkMS5hZGRFbmRwb2ludChsaW5lLmdldENvb3JkaW5hdGVOKGxpbmUuZ2V0TnVtUG9pbnRzKCkgLSAxKSk7XG4gIH1cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZW50cnkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGNvdW50ZXIgPSBlbnRyeS5nZXRWYWx1ZSgpO1xuICAgIHZhciB2YWxlbmNlID0gY291bnRlci5jb3VudDtcbiAgICBpZiAodGhpcyQxLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KHZhbGVuY2UpKSB7XG4gICAgICBiZHlQdHMuYWRkKGVudHJ5LmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheXMudG9Db29yZGluYXRlQXJyYXkoYmR5UHRzKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmFkZEVuZHBvaW50ID0gZnVuY3Rpb24gYWRkRW5kcG9pbnQgKHB0KSB7XG4gIHZhciBjb3VudGVyID0gdGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHB0KTtcbiAgaWYgKGNvdW50ZXIgPT09IG51bGwpIHtcbiAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoKTtcbiAgICB0aGlzLl9lbmRwb2ludE1hcC5wdXQocHQsIGNvdW50ZXIpO1xuICB9XG4gIGNvdW50ZXIuY291bnQrKztcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCb3VuZGFyeU9wXG59O1xuQm91bmRhcnlPcC5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm9wID0gbmV3IEJvdW5kYXJ5T3AoZyk7XG4gICAgcmV0dXJuIGJvcC5nZXRCb3VuZGFyeSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJuUnVsZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm9wJDEgPSBuZXcgQm91bmRhcnlPcChnJDEsIGJuUnVsZSk7XG4gICAgcmV0dXJuIGJvcCQxLmdldEJvdW5kYXJ5KClcbiAgfVxufTtcblxudmFyIENvdW50ZXIgPSBmdW5jdGlvbiBDb3VudGVyICgpIHtcbiAgdGhpcy5jb3VudCA9IG51bGw7XG59O1xuQ291bnRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvdW50ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ291bnRlclxufTtcblxuLy8gYm91bmRhcnlcblxuZnVuY3Rpb24gUHJpbnRTdHJlYW0gKCkge31cblxuZnVuY3Rpb24gU3RyaW5nUmVhZGVyICgpIHt9XG5cbnZhciBEZWNpbWFsRm9ybWF0ID0gZnVuY3Rpb24gRGVjaW1hbEZvcm1hdCAoKSB7fTtcblxuZnVuY3Rpb24gQnl0ZUFycmF5T3V0cHV0U3RyZWFtICgpIHt9XG5cbmZ1bmN0aW9uIElPRXhjZXB0aW9uICgpIHt9XG5cbmZ1bmN0aW9uIExpbmVOdW1iZXJSZWFkZXIgKCkge31cblxudmFyIFN0cmluZ1V0aWwgPSBmdW5jdGlvbiBTdHJpbmdVdGlsICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE1ID0geyBORVdMSU5FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNJTVBMRV9PUkRJTkFURV9GT1JNQVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuU3RyaW5nVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblN0cmluZ1V0aWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3RyaW5nVXRpbFxufTtcblN0cmluZ1V0aWwuY2hhcnMgPSBmdW5jdGlvbiBjaGFycyAoYywgbikge1xuICB2YXIgY2ggPSBuZXcgQXJyYXkobikuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjaFtpXSA9IGM7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhjaClcbn07XG5TdHJpbmdVdGlsLmdldFN0YWNrVHJhY2UgPSBmdW5jdGlvbiBnZXRTdGFja1RyYWNlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgdCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3MgPSBuZXcgQnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgdmFyIHBzID0gbmV3IFByaW50U3RyZWFtKG9zKTtcbiAgICB0LnByaW50U3RhY2tUcmFjZShwcyk7XG4gICAgcmV0dXJuIG9zLnRvU3RyaW5nKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGVwdGggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHN0YWNrVHJhY2UgPSAnJztcbiAgICB2YXIgc3RyaW5nUmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihTdHJpbmdVdGlsLmdldFN0YWNrVHJhY2UodCQxKSk7XG4gICAgdmFyIGxpbmVOdW1iZXJSZWFkZXIgPSBuZXcgTGluZU51bWJlclJlYWRlcihzdHJpbmdSZWFkZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwdGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhY2tUcmFjZSArPSBsaW5lTnVtYmVyUmVhZGVyLnJlYWRMaW5lKCkgKyBTdHJpbmdVdGlsLk5FV0xJTkU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSU9FeGNlcHRpb24pIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgICAgfSBlbHNlIHsgdGhyb3cgZSB9XG4gICAgICB9IGZpbmFsbHkge31cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrVHJhY2VcbiAgfVxufTtcblN0cmluZ1V0aWwuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAocywgc2VwYXJhdG9yKSB7XG4gIHZhciBzZXBhcmF0b3JsZW4gPSBzZXBhcmF0b3IubGVuZ3RoO1xuICB2YXIgdG9rZW5MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgdG1wU3RyaW5nID0gJycgKyBzO1xuICB2YXIgcG9zID0gdG1wU3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHRva2VuID0gdG1wU3RyaW5nLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIHRva2VuTGlzdC5hZGQodG9rZW4pO1xuICAgIHRtcFN0cmluZyA9IHRtcFN0cmluZy5zdWJzdHJpbmcocG9zICsgc2VwYXJhdG9ybGVuKTtcbiAgICBwb3MgPSB0bXBTdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuICB9XG4gIGlmICh0bXBTdHJpbmcubGVuZ3RoID4gMCkgeyB0b2tlbkxpc3QuYWRkKHRtcFN0cmluZyk7IH1cbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh0b2tlbkxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tpXSA9IHRva2VuTGlzdC5nZXQoaSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufTtcblN0cmluZ1V0aWwudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGQgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIFN0cmluZ1V0aWwuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQoZClcbiAgfVxufTtcblN0cmluZ1V0aWwuc3BhY2VzID0gZnVuY3Rpb24gc3BhY2VzIChuKSB7XG4gIHJldHVybiBTdHJpbmdVdGlsLmNoYXJzKCcgJywgbilcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTUuTkVXTElORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTeXN0ZW0uZ2V0UHJvcGVydHkoJ2xpbmUuc2VwYXJhdG9yJykgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNS5TSU1QTEVfT1JESU5BVEVfRk9STUFULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEZWNpbWFsRm9ybWF0KCcwLiMnKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RyaW5nVXRpbCwgc3RhdGljQWNjZXNzb3JzJDE1ICk7XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VzID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlcyAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlcy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlc1xufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuY29weUNvb3JkID0gZnVuY3Rpb24gY29weUNvb3JkIChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcykge1xuICB2YXIgbWluRGltID0gTWF0aC5taW4oc3JjLmdldERpbWVuc2lvbigpLCBkZXN0LmdldERpbWVuc2lvbigpKTtcbiAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbWluRGltOyBkaW0rKykge1xuICAgIGRlc3Quc2V0T3JkaW5hdGUoZGVzdFBvcywgZGltLCBzcmMuZ2V0T3JkaW5hdGUoc3JjUG9zLCBkaW0pKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuaXNSaW5nID0gZnVuY3Rpb24gaXNSaW5nIChzZXEpIHtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBpZiAobiA9PT0gMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChuIDw9IDMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpICYmIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWSkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbCAoY3MxLCBjczIpIHtcbiAgdmFyIGNzMVNpemUgPSBjczEuc2l6ZSgpO1xuICB2YXIgY3MyU2l6ZSA9IGNzMi5zaXplKCk7XG4gIGlmIChjczFTaXplICE9PSBjczJTaXplKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaW0gPSBNYXRoLm1pbihjczEuZ2V0RGltZW5zaW9uKCksIGNzMi5nZXREaW1lbnNpb24oKSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3MxU2l6ZTsgaSsrKSB7XG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykge1xuICAgICAgdmFyIHYxID0gY3MxLmdldE9yZGluYXRlKGksIGQpO1xuICAgICAgdmFyIHYyID0gY3MyLmdldE9yZGluYXRlKGksIGQpO1xuICAgICAgaWYgKGNzMS5nZXRPcmRpbmF0ZShpLCBkKSA9PT0gY3MyLmdldE9yZGluYXRlKGksIGQpKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChEb3VibGUuaXNOYU4odjEpICYmIERvdWJsZS5pc05hTih2MikpIHsgY29udGludWUgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKGZhY3QsIHNlcSwgc2l6ZSkge1xuICB2YXIgbmV3c2VxID0gZmFjdC5jcmVhdGUoc2l6ZSwgc2VxLmdldERpbWVuc2lvbigpKTtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCAwLCBuZXdzZXEsIDAsIG4pO1xuICBpZiAobiA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gbjsgaSA8IHNpemU7IGkrKykgeyBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCBuIC0gMSwgbmV3c2VxLCBpLCAxKTsgfVxuICB9XG4gIHJldHVybiBuZXdzZXFcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlIChzZXEpIHtcbiAgdmFyIGxhc3QgPSBzZXEuc2l6ZSgpIC0gMTtcbiAgdmFyIG1pZCA9IE1hdGgudHJ1bmMobGFzdCAvIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaWQ7IGkrKykge1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMuc3dhcChzZXEsIGksIGxhc3QgLSBpKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuc3dhcCA9IGZ1bmN0aW9uIHN3YXAgKHNlcSwgaSwgaikge1xuICBpZiAoaSA9PT0gaikgeyByZXR1cm4gbnVsbCB9XG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHNlcS5nZXREaW1lbnNpb24oKTsgZGltKyspIHtcbiAgICB2YXIgdG1wID0gc2VxLmdldE9yZGluYXRlKGksIGRpbSk7XG4gICAgc2VxLnNldE9yZGluYXRlKGksIGRpbSwgc2VxLmdldE9yZGluYXRlKGosIGRpbSkpO1xuICAgIHNlcS5zZXRPcmRpbmF0ZShqLCBkaW0sIHRtcCk7XG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHlDb29yZChzcmMsIHNyY1BvcyArIGksIGRlc3QsIGRlc3RQb3MgKyBpKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGNzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzaXplID0gY3Muc2l6ZSgpO1xuICAgIGlmIChzaXplID09PSAwKSB7IHJldHVybiAnKCknIH1cbiAgICB2YXIgZGltID0gY3MuZ2V0RGltZW5zaW9uKCk7XG4gICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgICBidWYuYXBwZW5kKCcoJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBidWYuYXBwZW5kKCcgJyk7IH1cbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHtcbiAgICAgICAgaWYgKGQgPiAwKSB7IGJ1Zi5hcHBlbmQoJywnKTsgfVxuICAgICAgICBidWYuYXBwZW5kKFN0cmluZ1V0aWwudG9TdHJpbmcoY3MuZ2V0T3JkaW5hdGUoaSwgZCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmLmFwcGVuZCgnKScpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoKVxuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5lbnN1cmVWYWxpZFJpbmcgPSBmdW5jdGlvbiBlbnN1cmVWYWxpZFJpbmcgKGZhY3QsIHNlcSkge1xuICB2YXIgbiA9IHNlcS5zaXplKCk7XG4gIGlmIChuID09PSAwKSB7IHJldHVybiBzZXEgfVxuICBpZiAobiA8PSAzKSB7IHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcoZmFjdCwgc2VxLCA0KSB9XG4gIHZhciBpc0Nsb3NlZCA9IHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpICYmIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWSkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpO1xuICBpZiAoaXNDbG9zZWQpIHsgcmV0dXJuIHNlcSB9XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcoZmFjdCwgc2VxLCBuICsgMSlcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcgPSBmdW5jdGlvbiBjcmVhdGVDbG9zZWRSaW5nIChmYWN0LCBzZXEsIHNpemUpIHtcbiAgdmFyIG5ld3NlcSA9IGZhY3QuY3JlYXRlKHNpemUsIHNlcS5nZXREaW1lbnNpb24oKSk7XG4gIHZhciBuID0gc2VxLnNpemUoKTtcbiAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgMCwgbmV3c2VxLCAwLCBuKTtcbiAgZm9yICh2YXIgaSA9IG47IGkgPCBzaXplOyBpKyspIHsgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgMCwgbmV3c2VxLCBpLCAxKTsgfVxuICByZXR1cm4gbmV3c2VxXG59O1xuXG52YXIgTGluZVN0cmluZyA9IChmdW5jdGlvbiAoR2VvbWV0cnkkJDEpIHtcbiAgZnVuY3Rpb24gTGluZVN0cmluZyAocG9pbnRzLCBmYWN0b3J5KSB7XG4gICAgR2VvbWV0cnkkJDEuY2FsbCh0aGlzLCBmYWN0b3J5KTtcbiAgICB0aGlzLl9wb2ludHMgPSBudWxsO1xuICAgIHRoaXMuaW5pdChwb2ludHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIExpbmVTdHJpbmcuX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkkJDEgJiYgR2VvbWV0cnkkJDEucHJvdG90eXBlICk7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZVN0cmluZztcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbXB1dGVFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBFbnZlbG9wZSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IEVudmVsb3BlKCkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzUmluZyA9IGZ1bmN0aW9uIGlzUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDbG9zZWQoKSAmJiB0aGlzLmlzU2ltcGxlKClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkkJDEuU09SVElOREVYX0xJTkVTVFJJTkdcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy50b0Nvb3JkaW5hdGVBcnJheSgpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdmFyIG90aGVyTGluZVN0cmluZyA9IG90aGVyO1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5zaXplKCkgIT09IG90aGVyTGluZVN0cmluZy5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9pbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcyQxLmVxdWFsKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSksIG90aGVyTGluZVN0cmluZy5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSksIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLnRydW5jKHRoaXMuX3BvaW50cy5zaXplKCkgLyAyKTsgaSsrKSB7XG4gICAgICB2YXIgaiA9IHRoaXMkMS5fcG9pbnRzLnNpemUoKSAtIDEgLSBpO1xuICAgICAgaWYgKCF0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmVxdWFscyh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGopKSkge1xuICAgICAgICBpZiAodGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKS5jb21wYXJlVG8odGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShqKSkgPiAwKSB7XG4gICAgICAgICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlKHRoaXMkMS5fcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKDApXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpIC0gMSkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEVuZFBvaW50ID0gZnVuY3Rpb24gZ2V0RW5kUG9pbnQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCkgLSAxKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtcy5jb21wdXRlTGVuZ3RoKHRoaXMuX3BvaW50cylcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3BvaW50cy5jb3B5KCk7XG4gICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlKHNlcSk7XG4gICAgdmFyIHJldkxpbmUgPSB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHNlcSk7XG4gICAgcmV0dXJuIHJldkxpbmVcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lID0gbztcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5fcG9pbnRzLnNpemUoKSAmJiBqIDwgbGluZS5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkuY29tcGFyZVRvKGxpbmUuX3BvaW50cy5nZXRDb29yZGluYXRlKGopKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyaXNvblxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgICBpZiAoaiA8IGxpbmUuX3BvaW50cy5zaXplKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG8kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxpbmUkMSA9IG8kMTtcbiAgICAgIHJldHVybiBjb21wLmNvbXBhcmUodGhpcy5fcG9pbnRzLCBsaW5lJDEuX3BvaW50cylcbiAgICB9XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgZmlsdGVyLmZpbHRlcih0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLl9wb2ludHMuc2l6ZSgpID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX3BvaW50cy5zaXplKCk7IGkkMSsrKSB7XG4gICAgICAgIGZpbHRlciQxLmZpbHRlcih0aGlzJDEuX3BvaW50cywgaSQxKTtcbiAgICAgICAgaWYgKGZpbHRlciQxLmlzRG9uZSgpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIkMS5pc0dlb21ldHJ5Q2hhbmdlZCgpKSB7IHRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCk7IH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDIuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMy5maWx0ZXIodGhpcyk7XG4gICAgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kYXJ5T3AodGhpcykuZ2V0Qm91bmRhcnkoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0VxdWl2YWxlbnRDbGFzcyA9IGZ1bmN0aW9uIGlzRXF1aXZhbGVudENsYXNzIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVTdHJpbmdcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIGxzID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgbHMuX3BvaW50cyA9IHRoaXMuX3BvaW50cy5jbG9uZSgpO1xuICAgIHJldHVybiBsc1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlTiA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVOIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdMaW5lU3RyaW5nJ1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuX3BvaW50cy5jb3B5KCksIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVTZXF1ZW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50c1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKCkgPT09IDBcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKHBvaW50cykge1xuICAgIGlmIChwb2ludHMgPT09IG51bGwpIHtcbiAgICAgIHBvaW50cyA9IHRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pO1xuICAgIH1cbiAgICBpZiAocG9pbnRzLnNpemUoKSA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kICcgKyBwb2ludHMuc2l6ZSgpICsgJyAtIG11c3QgYmUgMCBvciA+PSAyKScpXG4gICAgfVxuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNDb29yZGluYXRlID0gZnVuY3Rpb24gaXNDb29yZGluYXRlIChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGlmICh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmVxdWFscyhwdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFN0YXJ0UG9pbnQgPSBmdW5jdGlvbiBnZXRTdGFydFBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBvaW50TigwKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRQb2ludE4gPSBmdW5jdGlvbiBnZXRQb2ludE4gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUobikpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbTGluZWFsXVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTGluZVN0cmluZ1xuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMTEwNjY5ODI4MDY1MzY1NTYwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpbmVTdHJpbmcsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMaW5lU3RyaW5nO1xufShHZW9tZXRyeSkpO1xuXG52YXIgUHVudGFsID0gZnVuY3Rpb24gUHVudGFsICgpIHt9O1xuXG5QdW50YWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5QdW50YWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUHVudGFsXG59O1xuXG52YXIgUG9pbnQgPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIFBvaW50IChjb29yZGluYXRlcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcyB8fCBudWxsO1xuICAgIHRoaXMuaW5pdCh0aGlzLl9jb29yZGluYXRlcyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5JCQxICkgUG9pbnQuX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIFBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBQb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIFBvaW50LnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgRW52ZWxvcGUoKVxuICAgIH1cbiAgICB2YXIgZW52ID0gbmV3IEVudmVsb3BlKCk7XG4gICAgZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlcy5nZXRYKDApLCB0aGlzLl9jb29yZGluYXRlcy5nZXRZKDApKTtcbiAgICByZXR1cm4gZW52XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeSQkMS5TT1JUSU5ERVhfUE9JTlRcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IFtdIDogW3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpICE9PSBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbChvdGhlci5nZXRDb29yZGluYXRlKCksIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7fTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpICE9PSAwID8gdGhpcy5fY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKSA6IG51bGxcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gMCA6IDFcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5KClcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYICgpIHtcbiAgICBpZiAodGhpcy5nZXRDb29yZGluYXRlKCkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBvaW50JDEgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8ocG9pbnQkMS5nZXRDb29yZGluYXRlKCkpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHBvaW50ID0gb3RoZXIkMTtcbiAgICAgIHJldHVybiBjb21wLmNvbXBhcmUodGhpcy5fY29vcmRpbmF0ZXMsIHBvaW50Ll9jb29yZGluYXRlcylcbiAgICB9XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGZpbHRlci5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGZpbHRlciQxLmZpbHRlcih0aGlzLl9jb29yZGluYXRlcywgMCk7XG4gICAgICBpZiAoZmlsdGVyJDEuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQyLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDMuZmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbClcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBwID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgcC5fY29vcmRpbmF0ZXMgPSB0aGlzLl9jb29yZGluYXRlcy5jbG9uZSgpO1xuICAgIHJldHVybiBwXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnUG9pbnQnXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl9jb29yZGluYXRlcy5jb3B5KCksIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlU2VxdWVuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1xuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKCkge1xuICAgIGlmICh0aGlzLmdldENvb3JkaW5hdGUoKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKSA9PT0gMFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGNvb3JkaW5hdGVzID09PSBudWxsKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pO1xuICAgIH1cbiAgICBBc3NlcnQuaXNUcnVlKGNvb3JkaW5hdGVzLnNpemUoKSA8PSAxKTtcbiAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaXNTaW1wbGUgPSBmdW5jdGlvbiBpc1NpbXBsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbUHVudGFsXVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFBvaW50XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQ5MDIwMjI3MDI3NDY2MTQ1NzAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUG9pbnQsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBQb2ludDtcbn0oR2VvbWV0cnkpKTtcblxudmFyIFBvbHlnb25hbCA9IGZ1bmN0aW9uIFBvbHlnb25hbCAoKSB7fTtcblxuUG9seWdvbmFsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9seWdvbmFsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25hbFxufTtcblxudmFyIFBvbHlnb24gPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIFBvbHlnb24gKHNoZWxsLCBob2xlcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fc2hlbGwgPSBudWxsO1xuICAgIHRoaXMuX2hvbGVzID0gbnVsbDtcbiAgICBpZiAoc2hlbGwgPT09IG51bGwpIHtcbiAgICAgIHNoZWxsID0gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpO1xuICAgIH1cbiAgICBpZiAoaG9sZXMgPT09IG51bGwpIHtcbiAgICAgIGhvbGVzID0gW107XG4gICAgfVxuICAgIGlmIChHZW9tZXRyeSQkMS5oYXNOdWxsRWxlbWVudHMoaG9sZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHMnKVxuICAgIH1cbiAgICBpZiAoc2hlbGwuaXNFbXB0eSgpICYmIEdlb21ldHJ5JCQxLmhhc05vbkVtcHR5RWxlbWVudHMoaG9sZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdCcpXG4gICAgfVxuICAgIHRoaXMuX3NoZWxsID0gc2hlbGw7XG4gICAgdGhpcy5faG9sZXMgPSBob2xlcztcbiAgfVxuXG4gIGlmICggR2VvbWV0cnkkJDEgKSBQb2x5Z29uLl9fcHJvdG9fXyA9IEdlb21ldHJ5JCQxO1xuICBQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHlnb247XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9QT0xZR09OXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7XG4gICAgdmFyIGsgPSAtMTtcbiAgICB2YXIgc2hlbGxDb29yZGluYXRlcyA9IHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBzaGVsbENvb3JkaW5hdGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICBrKys7XG4gICAgICBjb29yZGluYXRlc1trXSA9IHNoZWxsQ29vcmRpbmF0ZXNbeF07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZENvb3JkaW5hdGVzID0gdGhpcyQxLl9ob2xlc1tpXS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZENvb3JkaW5hdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGsrKztcbiAgICAgICAgY29vcmRpbmF0ZXNba10gPSBjaGlsZENvb3JkaW5hdGVzW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXNcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uIGdldEFyZWEgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgYXJlYSArPSBNYXRoLmFicyhDR0FsZ29yaXRobXMuc2lnbmVkQXJlYSh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZWEgLT0gTWF0aC5hYnMoQ0dBbGdvcml0aG1zLnNpZ25lZEFyZWEodGhpcyQxLl9ob2xlc1tpXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5pc1JlY3RhbmdsZSA9IGZ1bmN0aW9uIGlzUmVjdGFuZ2xlICgpIHtcbiAgICBpZiAodGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSAhPT0gMCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLl9zaGVsbCA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKSAhPT0gNSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzZXEgPSB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtcbiAgICB2YXIgZW52ID0gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIHZhciB4ID0gc2VxLmdldFgoaSk7XG4gICAgICBpZiAoISh4ID09PSBlbnYuZ2V0TWluWCgpIHx8IHggPT09IGVudi5nZXRNYXhYKCkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgeSA9IHNlcS5nZXRZKGkpO1xuICAgICAgaWYgKCEoeSA9PT0gZW52LmdldE1pblkoKSB8fCB5ID09PSBlbnYuZ2V0TWF4WSgpKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICB2YXIgcHJldlggPSBzZXEuZ2V0WCgwKTtcbiAgICB2YXIgcHJldlkgPSBzZXEuZ2V0WSgwKTtcbiAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPD0gNDsgaSQxKyspIHtcbiAgICAgIHZhciB4JDEgPSBzZXEuZ2V0WChpJDEpO1xuICAgICAgdmFyIHkkMSA9IHNlcS5nZXRZKGkkMSk7XG4gICAgICB2YXIgeENoYW5nZWQgPSB4JDEgIT09IHByZXZYO1xuICAgICAgdmFyIHlDaGFuZ2VkID0geSQxICE9PSBwcmV2WTtcbiAgICAgIGlmICh4Q2hhbmdlZCA9PT0geUNoYW5nZWQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHByZXZYID0geCQxO1xuICAgICAgcHJldlkgPSB5JDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdmFyIG90aGVyUG9seWdvbiA9IG90aGVyO1xuICAgICAgdmFyIHRoaXNTaGVsbCA9IHRoaXMuX3NoZWxsO1xuICAgICAgdmFyIG90aGVyUG9seWdvblNoZWxsID0gb3RoZXJQb2x5Z29uLl9zaGVsbDtcbiAgICAgIGlmICghdGhpc1NoZWxsLmVxdWFsc0V4YWN0KG90aGVyUG9seWdvblNoZWxsLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hvbGVzLmxlbmd0aCAhPT0gb3RoZXJQb2x5Z29uLl9ob2xlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcyQxLl9ob2xlc1tpXS5lcXVhbHNFeGFjdChvdGhlclBvbHlnb24uX2hvbGVzW2ldLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSh0aGlzLl9zaGVsbCwgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5ub3JtYWxpemUodGhpcyQxLl9ob2xlc1tpXSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgQXJyYXlzLnNvcnQodGhpcy5faG9sZXMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY2xvY2t3aXNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHJpbmcuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB2YXIgdW5pcXVlQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkocmluZy5nZXRDb29yZGluYXRlcygpLmxlbmd0aCAtIDEpLmZpbGwobnVsbCk7XG4gICAgICBTeXN0ZW0uYXJyYXljb3B5KHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSwgMCwgdW5pcXVlQ29vcmRpbmF0ZXMsIDAsIHVuaXF1ZUNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICB2YXIgbWluQ29vcmRpbmF0ZSA9IENvb3JkaW5hdGVBcnJheXMubWluQ29vcmRpbmF0ZShyaW5nLmdldENvb3JkaW5hdGVzKCkpO1xuICAgICAgQ29vcmRpbmF0ZUFycmF5cy5zY3JvbGwodW5pcXVlQ29vcmRpbmF0ZXMsIG1pbkNvb3JkaW5hdGUpO1xuICAgICAgU3lzdGVtLmFycmF5Y29weSh1bmlxdWVDb29yZGluYXRlcywgMCwgcmluZy5nZXRDb29yZGluYXRlcygpLCAwLCB1bmlxdWVDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgICAgcmluZy5nZXRDb29yZGluYXRlcygpW3VuaXF1ZUNvb3JkaW5hdGVzLmxlbmd0aF0gPSB1bmlxdWVDb29yZGluYXRlc1swXTtcbiAgICAgIGlmIChDR0FsZ29yaXRobXMuaXNDQ1cocmluZy5nZXRDb29yZGluYXRlcygpKSA9PT0gY2xvY2t3aXNlKSB7XG4gICAgICAgIENvb3JkaW5hdGVBcnJheXMucmV2ZXJzZShyaW5nLmdldENvb3JkaW5hdGVzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlKClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TnVtSW50ZXJpb3JSaW5nID0gZnVuY3Rpb24gZ2V0TnVtSW50ZXJpb3JSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG9sZXMubGVuZ3RoXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsZW4gPSAwLjA7XG4gICAgbGVuICs9IHRoaXMuX3NoZWxsLmdldExlbmd0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbiArPSB0aGlzJDEuX2hvbGVzW2ldLmdldExlbmd0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVuXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbnVtUG9pbnRzID0gdGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbnVtUG9pbnRzICs9IHRoaXMkMS5faG9sZXNbaV0uZ2V0TnVtUG9pbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1Qb2ludHNcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHkgPSB0aGlzLmNvcHkoKTtcbiAgICBwb2x5Ll9zaGVsbCA9IHRoaXMuX3NoZWxsLmNvcHkoKS5yZXZlcnNlKCk7XG4gICAgcG9seS5faG9sZXMgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHkuX2hvbGVzW2ldID0gdGhpcyQxLl9ob2xlc1tpXS5jb3B5KCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9seVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb252ZXhIdWxsID0gZnVuY3Rpb24gY29udmV4SHVsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbXBhcmVUb1NhbWVDbGFzcyA9IGZ1bmN0aW9uIGNvbXBhcmVUb1NhbWVDbGFzcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdGhpc1NoZWxsID0gdGhpcy5fc2hlbGw7XG4gICAgICB2YXIgb3RoZXJTaGVsbCA9IG8uX3NoZWxsO1xuICAgICAgcmV0dXJuIHRoaXNTaGVsbC5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXJTaGVsbClcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBwb2x5ID0gbyQxO1xuICAgICAgdmFyIHRoaXNTaGVsbCQxID0gdGhpcy5fc2hlbGw7XG4gICAgICB2YXIgb3RoZXJTaGVsbCQxID0gcG9seS5fc2hlbGw7XG4gICAgICB2YXIgc2hlbGxDb21wID0gdGhpc1NoZWxsJDEuY29tcGFyZVRvU2FtZUNsYXNzKG90aGVyU2hlbGwkMSwgY29tcCk7XG4gICAgICBpZiAoc2hlbGxDb21wICE9PSAwKSB7IHJldHVybiBzaGVsbENvbXAgfVxuICAgICAgdmFyIG5Ib2xlMSA9IHRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7XG4gICAgICB2YXIgbkhvbGUyID0gcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbkhvbGUxICYmIGkgPCBuSG9sZTIpIHtcbiAgICAgICAgdmFyIHRoaXNIb2xlID0gdGhpcyQxLmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICAgIHZhciBvdGhlckhvbGUgPSBwb2x5LmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICAgIHZhciBob2xlQ29tcCA9IHRoaXNIb2xlLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlckhvbGUsIGNvbXApO1xuICAgICAgICBpZiAoaG9sZUNvbXAgIT09IDApIHsgcmV0dXJuIGhvbGVDb21wIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBuSG9sZTEpIHsgcmV0dXJuIDEgfVxuICAgICAgaWYgKGkgPCBuSG9sZTIpIHsgcmV0dXJuIC0xIH1cbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChmaWx0ZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdGhpcy5fc2hlbGwuYXBwbHkoZmlsdGVyKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9ob2xlc1tpJDFdLmFwcGx5KGZpbHRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIpKSB7XG4gICAgICB0aGlzLl9zaGVsbC5hcHBseShmaWx0ZXIpO1xuICAgICAgaWYgKCFmaWx0ZXIuaXNEb25lKCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgIHRoaXMkMS5faG9sZXNbaSQyXS5hcHBseShmaWx0ZXIpO1xuICAgICAgICAgIGlmIChmaWx0ZXIuaXNEb25lKCkpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLmlzR2VvbWV0cnlDaGFuZ2VkKCkpIHsgdGhpcy5nZW9tZXRyeUNoYW5nZWQoKTsgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgR2VvbWV0cnlGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMpO1xuICAgICAgdGhpcy5fc2hlbGwuYXBwbHkoZmlsdGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLl9ob2xlc1tpXS5hcHBseShmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgcmluZ3MgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoICsgMSkuZmlsbChudWxsKTtcbiAgICByaW5nc1swXSA9IHRoaXMuX3NoZWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJpbmdzW2kgKyAxXSA9IHRoaXMkMS5faG9sZXNbaV07XG4gICAgfVxuICAgIGlmIChyaW5ncy5sZW5ndGggPD0gMSkgeyByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhyaW5nc1swXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkgfVxuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocmluZ3MpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHkgPSBHZW9tZXRyeSQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBwb2x5Ll9zaGVsbCA9IHRoaXMuX3NoZWxsLmNsb25lKCk7XG4gICAgcG9seS5faG9sZXMgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHkuX2hvbGVzW2ldID0gdGhpcyQxLl9ob2xlc1tpXS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9seVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnUG9seWdvbidcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNoZWxsID0gdGhpcy5fc2hlbGwuY29weSgpO1xuICAgIHZhciBob2xlcyA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaG9sZXNbaV0gPSB0aGlzJDEuX2hvbGVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNoZWxsLCBob2xlcywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0RXh0ZXJpb3JSaW5nID0gZnVuY3Rpb24gZ2V0RXh0ZXJpb3JSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGxcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbC5pc0VtcHR5KClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0SW50ZXJpb3JSaW5nTiA9IGZ1bmN0aW9uIGdldEludGVyaW9yUmluZ04gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5faG9sZXNbbl1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQb2x5Z29uYWxdXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBQb2x5Z29uXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0zNDk0NzkyMjAwODIxNzY0NTMzIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBvbHlnb24sIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBQb2x5Z29uO1xufShHZW9tZXRyeSkpO1xuXG52YXIgTXVsdGlQb2ludCA9IChmdW5jdGlvbiAoR2VvbWV0cnlDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE11bHRpUG9pbnQgKCkge1xuICAgIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgKSBNdWx0aVBvaW50Ll9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgJiYgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9pbnQ7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSVBPSU5UXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsIG90aGVyLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlKClcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTXVsdGlQb2ludCdcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9pbnRzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KHBvaW50cywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQdW50YWxdXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNdWx0aVBvaW50XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC04MDQ4NDc0ODc0MTc1MzU1NDQ5IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpUG9pbnQsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBNdWx0aVBvaW50O1xufShHZW9tZXRyeUNvbGxlY3Rpb24pKTtcblxudmFyIExpbmVhclJpbmcgPSAoZnVuY3Rpb24gKExpbmVTdHJpbmckJDEpIHtcbiAgZnVuY3Rpb24gTGluZWFyUmluZyAocG9pbnRzLCBmYWN0b3J5KSB7XG4gICAgaWYgKHBvaW50cyBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgZmFjdG9yeSBpbnN0YW5jZW9mIEdlb21ldHJ5RmFjdG9yeSkge1xuICAgICAgcG9pbnRzID0gZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHBvaW50cyk7XG4gICAgfVxuICAgIExpbmVTdHJpbmckJDEuY2FsbCh0aGlzLCBwb2ludHMsIGZhY3RvcnkpO1xuICAgIHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKTtcbiAgfVxuXG4gIGlmICggTGluZVN0cmluZyQkMSApIExpbmVhclJpbmcuX19wcm90b19fID0gTGluZVN0cmluZyQkMTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU3RyaW5nJCQxICYmIExpbmVTdHJpbmckJDEucHJvdG90eXBlICk7XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZWFyUmluZztcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBNSU5JTVVNX1ZBTElEX1NJWkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeS5TT1JUSU5ERVhfTElORUFSUklOR1xuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIExpbmVTdHJpbmckJDEucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcylcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciBzZXEgPSB0aGlzLl9wb2ludHMuY29weSgpO1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMucmV2ZXJzZShzZXEpO1xuICAgIHZhciByZXYgPSB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHNlcSk7XG4gICAgcmV0dXJuIHJldlxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS52YWxpZGF0ZUNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RydWN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpICYmICFMaW5lU3RyaW5nJCQxLnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpID49IDEgJiYgdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkgPCBMaW5lYXJSaW5nLk1JTklNVU1fVkFMSURfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kICcgKyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKSArICcgLSBtdXN0IGJlIDAgb3IgPj0gNCknKVxuICAgIH1cbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ0xpbmVhclJpbmcnXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJpbmcodGhpcy5fcG9pbnRzLmNvcHkoKSwgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBMaW5lYXJSaW5nXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5NSU5JTVVNX1ZBTElEX1NJWkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNCB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNDI2MTE0MjA4NDA4NTg1MTgyOSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lYXJSaW5nLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGluZWFyUmluZztcbn0oTGluZVN0cmluZykpO1xuXG52YXIgTXVsdGlQb2x5Z29uID0gKGZ1bmN0aW9uIChHZW9tZXRyeUNvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2x5Z29uICgpIHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICkgTXVsdGlQb2x5Z29uLl9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSAmJiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aVBvbHlnb247XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9MWUdPTlxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcywgb3RoZXIsIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbiA9IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO1xuICAgIHZhciByZXZHZW9tcyA9IG5ldyBBcnJheShuKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV2R2VvbXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKHJldkdlb21zKVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGFsbFJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvbHlnb24gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgcmluZ3MgPSBwb2x5Z29uLmdldEJvdW5kYXJ5KCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdzLmdldE51bUdlb21ldHJpZXMoKTsgaisrKSB7XG4gICAgICAgIGFsbFJpbmdzLmFkZChyaW5ncy5nZXRHZW9tZXRyeU4oaikpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWxsUmluZ3NBcnJheSA9IG5ldyBBcnJheShhbGxSaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhhbGxSaW5ncy50b0FycmF5KGFsbFJpbmdzQXJyYXkpKVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdNdWx0aVBvbHlnb24nXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHlnb25zW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQb2x5Z29uYWxdXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE11bHRpUG9seWdvblxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNTUxMDMzNTI5NzY2OTc1ODc1IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpUG9seWdvbiwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE11bHRpUG9seWdvbjtcbn0oR2VvbWV0cnlDb2xsZWN0aW9uKSk7XG5cbnZhciBHZW9tZXRyeUVkaXRvciA9IGZ1bmN0aW9uIEdlb21ldHJ5RWRpdG9yIChmYWN0b3J5KSB7XG4gIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5IHx8IG51bGw7XG4gIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQgPSBmYWxzZTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTYgPSB7IE5vT3BHZW9tZXRyeU9wZXJhdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDb29yZGluYXRlT3BlcmF0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLnNldENvcHlVc2VyRGF0YSA9IGZ1bmN0aW9uIHNldENvcHlVc2VyRGF0YSAoaXNVc2VyRGF0YUNvcGllZCkge1xuICB0aGlzLl9pc1VzZXJEYXRhQ29waWVkID0gaXNVc2VyRGF0YUNvcGllZDtcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBvcGVyYXRpb24pIHtcbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMuZWRpdEludGVybmFsKGdlb21ldHJ5LCBvcGVyYXRpb24pO1xuICBpZiAodGhpcy5faXNVc2VyRGF0YUNvcGllZCkge1xuICAgIHJlc3VsdC5zZXRVc2VyRGF0YShnZW9tZXRyeS5nZXRVc2VyRGF0YSgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRJbnRlcm5hbCA9IGZ1bmN0aW9uIGVkaXRJbnRlcm5hbCAoZ2VvbWV0cnksIG9wZXJhdGlvbikge1xuICBpZiAodGhpcy5fZmFjdG9yeSA9PT0gbnVsbCkgeyB0aGlzLl9mYWN0b3J5ID0gZ2VvbWV0cnkuZ2V0RmFjdG9yeSgpOyB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cnksIG9wZXJhdGlvbilcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdFBvbHlnb24oZ2VvbWV0cnksIG9wZXJhdGlvbilcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHJldHVybiBvcGVyYXRpb24uZWRpdChnZW9tZXRyeSwgdGhpcy5fZmFjdG9yeSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5lZGl0KGdlb21ldHJ5LCB0aGlzLl9mYWN0b3J5KVxuICB9XG4gIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnVW5zdXBwb3J0ZWQgR2VvbWV0cnkgY2xhc3M6ICcgKyBnZW9tZXRyeS5nZXRDbGFzcygpLmdldE5hbWUoKSk7XG4gIHJldHVybiBudWxsXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBlZGl0R2VvbWV0cnlDb2xsZWN0aW9uIChjb2xsZWN0aW9uLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29sbGVjdGlvbkZvclR5cGUgPSBvcGVyYXRpb24uZWRpdChjb2xsZWN0aW9uLCB0aGlzLl9mYWN0b3J5KTtcbiAgdmFyIGdlb21ldHJpZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbkZvclR5cGUuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzJDEuZWRpdChjb2xsZWN0aW9uRm9yVHlwZS5nZXRHZW9tZXRyeU4oaSksIG9wZXJhdGlvbik7XG4gICAgaWYgKGdlb21ldHJ5ID09PSBudWxsIHx8IGdlb21ldHJ5LmlzRW1wdHkoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZ2VvbWV0cmllcy5hZGQoZ2VvbWV0cnkpO1xuICB9XG4gIGlmIChjb2xsZWN0aW9uRm9yVHlwZS5nZXRDbGFzcygpID09PSBNdWx0aVBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChnZW9tZXRyaWVzLnRvQXJyYXkoW10pKVxuICB9XG4gIGlmIChjb2xsZWN0aW9uRm9yVHlwZS5nZXRDbGFzcygpID09PSBNdWx0aUxpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cmllcy50b0FycmF5KFtdKSlcbiAgfVxuICBpZiAoY29sbGVjdGlvbkZvclR5cGUuZ2V0Q2xhc3MoKSA9PT0gTXVsdGlQb2x5Z29uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGdlb21ldHJpZXMudG9BcnJheShbXSkpXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMudG9BcnJheShbXSkpXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRQb2x5Z29uID0gZnVuY3Rpb24gZWRpdFBvbHlnb24gKHBvbHlnb24sIG9wZXJhdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBuZXdQb2x5Z29uID0gb3BlcmF0aW9uLmVkaXQocG9seWdvbiwgdGhpcy5fZmFjdG9yeSk7XG4gIGlmIChuZXdQb2x5Z29uID09PSBudWxsKSB7IG5ld1BvbHlnb24gPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24obnVsbCk7IH1cbiAgaWYgKG5ld1BvbHlnb24uaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIG5ld1BvbHlnb25cbiAgfVxuICB2YXIgc2hlbGwgPSB0aGlzLmVkaXQobmV3UG9seWdvbi5nZXRFeHRlcmlvclJpbmcoKSwgb3BlcmF0aW9uKTtcbiAgaWYgKHNoZWxsID09PSBudWxsIHx8IHNoZWxsLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKVxuICB9XG4gIHZhciBob2xlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQb2x5Z29uLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICB2YXIgaG9sZSA9IHRoaXMkMS5lZGl0KG5ld1BvbHlnb24uZ2V0SW50ZXJpb3JSaW5nTihpKSwgb3BlcmF0aW9uKTtcbiAgICBpZiAoaG9sZSA9PT0gbnVsbCB8fCBob2xlLmlzRW1wdHkoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaG9sZXMuYWRkKGhvbGUpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oc2hlbGwsIGhvbGVzLnRvQXJyYXkoW10pKVxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlFZGl0b3Jcbn07XG5HZW9tZXRyeUVkaXRvci5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbiA9IGZ1bmN0aW9uIEdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uICgpIHt9O1xuc3RhdGljQWNjZXNzb3JzJDE2Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBOb09wR2VvbWV0cnlPcGVyYXRpb24gfTtcbnN0YXRpY0FjY2Vzc29ycyQxNi5Db29yZGluYXRlT3BlcmF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvb3JkaW5hdGVPcGVyYXRpb24gfTtcbnN0YXRpY0FjY2Vzc29ycyQxNi5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUVkaXRvciwgc3RhdGljQWNjZXNzb3JzJDE2ICk7XG5cbnZhciBOb09wR2VvbWV0cnlPcGVyYXRpb24gPSBmdW5jdGlvbiBOb09wR2VvbWV0cnlPcGVyYXRpb24gKCkge307XG5cbk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBmYWN0b3J5KSB7XG4gIHJldHVybiBnZW9tZXRyeVxufTtcbk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuTm9PcEdlb21ldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vT3BHZW9tZXRyeU9wZXJhdGlvblxufTtcblxudmFyIENvb3JkaW5hdGVPcGVyYXRpb24gPSBmdW5jdGlvbiBDb29yZGluYXRlT3BlcmF0aW9uICgpIHt9O1xuXG5Db29yZGluYXRlT3BlcmF0aW9uLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gZWRpdCAoZ2VvbWV0cnksIGZhY3RvcnkpIHtcbiAgdmFyIGNvb3JkcyA9IHRoaXMuZWRpdENvb3JkaW5hdGVzKGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCksIGdlb21ldHJ5KTtcbiAgaWYgKGNvb3JkcyA9PT0gbnVsbCkgeyByZXR1cm4gZ2VvbWV0cnkgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb29yZHMpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29vcmRzKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQb2ludChjb29yZHNbMF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVBvaW50KClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuQ29vcmRpbmF0ZU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuQ29vcmRpbmF0ZU9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlT3BlcmF0aW9uXG59O1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uICgpIHt9O1xuXG5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24ucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChnZW9tZXRyeSwgZmFjdG9yeSkge1xuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb21ldHJ5KSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb21ldHJ5KSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuZWRpdChnZW9tZXRyeS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbWV0cnkpKVxuICB9XG4gIHJldHVybiBnZW9tZXRyeVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvblxufTtcblxudmFyIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UgKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9kaW1lbnNpb24gPSAzO1xuICB0aGlzLl9jb29yZGluYXRlcyA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX2RpbWVuc2lvbiA9IDM7XG4gICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoc2l6ZSkuZmlsbChudWxsKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkU2VxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGNvb3JkU2VxID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KDApLmZpbGwobnVsbCk7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSBjb29yZFNlcS5nZXREaW1lbnNpb24oKTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KGNvb3JkU2VxLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9jb29yZGluYXRlc1tpJDFdID0gY29vcmRTZXEuZ2V0Q29vcmRpbmF0ZUNvcHkoaSQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaW1lbnNpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuICAgICAgdGhpcy5fZGltZW5zaW9uID0gZGltZW5zaW9uO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzID09PSBudWxsKSB7IHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KDApLmZpbGwobnVsbCk7IH1cbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHZhciBzaXplJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGltZW5zaW9uJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheShzaXplJDEpLmZpbGwobnVsbCk7XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSBkaW1lbnNpb24kMTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHNpemUkMTsgaSQyKyspIHtcbiAgICAgICAgdGhpcyQxLl9jb29yZGluYXRlc1tpJDJdID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTggPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5zZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldE9yZGluYXRlIChpbmRleCwgb3JkaW5hdGVJbmRleCwgdmFsdWUpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWDpcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS54ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlk6XG4gICAgICB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueSA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5aOlxuICAgICAgdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnogPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2ludmFsaWQgb3JkaW5hdGVJbmRleCcpXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4KSB7XG4gIHN3aXRjaCAob3JkaW5hdGVJbmRleCkge1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlg6XG4gICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnhcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5ZOlxuICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWjpcbiAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0uelxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgcmV0dXJuIERvdWJsZS5OYU5cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBpID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpXVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzFdO1xuICAgIGNvb3JkLnggPSB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueDtcbiAgICBjb29yZC55ID0gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnk7XG4gICAgY29vcmQueiA9IHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS56O1xuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVDb3B5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUNvcHkgKGkpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGltZW5zaW9uXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYIChpbmRleCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnhcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNsb25lQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjbG9uZUNvb3JkaW5hdGVzW2ldID0gdGhpcyQxLl9jb29yZGluYXRlc1tpXS5jbG9uZSgpO1xuICB9XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY2xvbmVDb29yZGluYXRlcywgdGhpcy5fZGltZW5zaW9uKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5leHBhbmRFbnZlbG9wZSA9IGZ1bmN0aW9uIGV4cGFuZEVudmVsb3BlIChlbnYpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZW52XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2xvbmVDb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNsb25lQ29vcmRpbmF0ZXNbaV0gPSB0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldLmNvcHkoKTtcbiAgfVxuICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKGNsb25lQ29vcmRpbmF0ZXMsIHRoaXMuX2RpbWVuc2lvbilcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc3RyQnVmID0gbmV3IFN0cmluZ0J1ZmZlcigxNyAqIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgc3RyQnVmLmFwcGVuZCgnKCcpO1xuICAgIHN0ckJ1Zi5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0ckJ1Zi5hcHBlbmQoJywgJyk7XG4gICAgICBzdHJCdWYuYXBwZW5kKHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0pO1xuICAgIH1cbiAgICBzdHJCdWYuYXBwZW5kKCcpJyk7XG4gICAgcmV0dXJuIHN0ckJ1Zi50b1N0cmluZygpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcoKSdcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlLCBTZXJpYWxpemFibGVdXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2Vcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTguc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtOTE1NDM4NTAxNjAxODQwNjUwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSwgc3RhdGljQWNjZXNzb3JzJDE4ICk7XG5cbnZhciBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTcgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5zdGFuY2VPYmplY3Q6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5yZWFkUmVzb2x2ZSA9IGZ1bmN0aW9uIHJlYWRSZXNvbHZlICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5pbnN0YW5jZSgpXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShjb29yZGluYXRlcylcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZFNlcSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY29vcmRTZXEpXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGltZW5zaW9uID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkaW1lbnNpb24gPiAzKSB7IGRpbWVuc2lvbiA9IDM7IH1cbiAgICBpZiAoZGltZW5zaW9uIDwgMikgeyByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHNpemUpIH1cbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHNpemUsIGRpbWVuc2lvbilcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSwgU2VyaWFsaXphYmxlXVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3Rvcnlcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2VPYmplY3Rcbn07XG5cbnN0YXRpY0FjY2Vzc29ycyQxNy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC00MDk5NTc3MDk5NjA3NTUxNjU3IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTcuaW5zdGFuY2VPYmplY3QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeSgpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnksIHN0YXRpY0FjY2Vzc29ycyQxNyApO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0hhc2hNYXAuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuTWFwfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSGFzaE1hcCA9IChmdW5jdGlvbiAoTWFwSW50ZXJmYWNlKSB7XG4gIGZ1bmN0aW9uIEhhc2hNYXAgKCkge1xuICAgIE1hcEludGVyZmFjZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWFwXyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGlmICggTWFwSW50ZXJmYWNlICkgSGFzaE1hcC5fX3Byb3RvX18gPSBNYXBJbnRlcmZhY2U7XG4gIEhhc2hNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwSW50ZXJmYWNlICYmIE1hcEludGVyZmFjZS5wcm90b3R5cGUgKTtcbiAgSGFzaE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoTWFwO1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcF8uZ2V0KGtleSkgfHwgbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIHB1dCAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubWFwXy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICB2YXIgYXJyYXlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHZhciBpdCA9IHRoaXMubWFwXy52YWx1ZXMoKTtcbiAgICB2YXIgbyA9IGl0Lm5leHQoKTtcbiAgICB3aGlsZSAoIW8uZG9uZSkge1xuICAgICAgYXJyYXlMaXN0LmFkZChvLnZhbHVlKTtcbiAgICAgIG8gPSBpdC5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUxpc3RcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5lbnRyeVNldCA9IGZ1bmN0aW9uIGVudHJ5U2V0ICgpIHtcbiAgICB2YXIgaGFzaFNldCA9IG5ldyBIYXNoU2V0KCk7XG4gICAgdGhpcy5tYXBfLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gaGFzaFNldC5hZGQoZW50cnkpOyB9KTtcbiAgICByZXR1cm4gaGFzaFNldFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfLnNpemUoKVxuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufShNYXAkMSkpO1xuXG52YXIgUHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBQcmVjaXNpb25Nb2RlbCAoKSB7XG4gIHRoaXMuX21vZGVsVHlwZSA9IG51bGw7XG4gIHRoaXMuX3NjYWxlID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9tb2RlbFR5cGUgPSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgIHZhciBtb2RlbFR5cGUgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gICAgICBpZiAobW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKDEuMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHNjYWxlID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbW9kZWxUeXBlID0gUHJlY2lzaW9uTW9kZWwuRklYRUQ7XG4gICAgICB0aGlzLnNldFNjYWxlKHNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFByZWNpc2lvbk1vZGVsKSB7XG4gICAgICB2YXIgcG0gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9tb2RlbFR5cGUgPSBwbS5fbW9kZWxUeXBlO1xuICAgICAgdGhpcy5fc2NhbGUgPSBwbS5fc2NhbGU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE5ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG1heGltdW1QcmVjaXNlVmFsdWU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJlY2lzaW9uTW9kZWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIG90aGVyUHJlY2lzaW9uTW9kZWwgPSBvdGhlcjtcbiAgcmV0dXJuIHRoaXMuX21vZGVsVHlwZSA9PT0gb3RoZXJQcmVjaXNpb25Nb2RlbC5fbW9kZWxUeXBlICYmIHRoaXMuX3NjYWxlID09PSBvdGhlclByZWNpc2lvbk1vZGVsLl9zY2FsZVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgdmFyIHNpZ0RpZ2l0cyA9IHRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7XG4gIHZhciBvdGhlclNpZ0RpZ2l0cyA9IG90aGVyLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO1xuICByZXR1cm4gbmV3IEludGVnZXIoc2lnRGlnaXRzKS5jb21wYXJlVG8obmV3IEludGVnZXIob3RoZXJTaWdEaWdpdHMpKVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NjYWxlXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmlzRmxvYXRpbmcgPSBmdW5jdGlvbiBpc0Zsb2F0aW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcgfHwgdGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEVcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWxUeXBlXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgZGVzY3JpcHRpb24gPSAnVU5LTk9XTic7XG4gIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRmxvYXRpbmcnO1xuICB9IGVsc2UgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRmxvYXRpbmctU2luZ2xlJztcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRml4ZWQgKFNjYWxlPScgKyB0aGlzLmdldFNjYWxlKCkgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0aW9uXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLm1ha2VQcmVjaXNlID0gZnVuY3Rpb24gbWFrZVByZWNpc2UgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChEb3VibGUuaXNOYU4odmFsKSkgeyByZXR1cm4gdmFsIH1cbiAgICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEUpIHtcbiAgICAgIHZhciBmbG9hdFNpbmdsZVZhbCA9IHZhbDtcbiAgICAgIHJldHVybiBmbG9hdFNpbmdsZVZhbFxuICAgIH1cbiAgICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsICogdGhpcy5fc2NhbGUpIC8gdGhpcy5fc2NhbGVcbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcpIHsgcmV0dXJuIG51bGwgfVxuICAgIGNvb3JkLnggPSB0aGlzLm1ha2VQcmVjaXNlKGNvb3JkLngpO1xuICAgIGNvb3JkLnkgPSB0aGlzLm1ha2VQcmVjaXNlKGNvb3JkLnkpO1xuICB9XG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uIGdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cyAoKSB7XG4gIHZhciBtYXhTaWdEaWdpdHMgPSAxNjtcbiAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcpIHtcbiAgICBtYXhTaWdEaWdpdHMgPSAxNjtcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSkge1xuICAgIG1heFNpZ0RpZ2l0cyA9IDY7XG4gIH0gZWxzZSBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgIG1heFNpZ0RpZ2l0cyA9IDEgKyBNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpIC8gTWF0aC5sb2coMTApKSk7XG4gIH1cbiAgcmV0dXJuIG1heFNpZ0RpZ2l0c1xufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIHNldFNjYWxlIChzY2FsZSkge1xuICB0aGlzLl9zY2FsZSA9IE1hdGguYWJzKHNjYWxlKTtcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlLCBDb21wYXJhYmxlXVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFByZWNpc2lvbk1vZGVsXG59O1xuUHJlY2lzaW9uTW9kZWwubW9zdFByZWNpc2UgPSBmdW5jdGlvbiBtb3N0UHJlY2lzZSAocG0xLCBwbTIpIHtcbiAgaWYgKHBtMS5jb21wYXJlVG8ocG0yKSA+PSAwKSB7IHJldHVybiBwbTEgfVxuICByZXR1cm4gcG0yXG59O1xuc3RhdGljQWNjZXNzb3JzJDE5LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzc3NzI2MzU3ODc3NzgwMzgzNSB9O1xuc3RhdGljQWNjZXNzb3JzJDE5Lm1heGltdW1QcmVjaXNlVmFsdWUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gOTAwNzE5OTI1NDc0MDk5Mi4wIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQcmVjaXNpb25Nb2RlbCwgc3RhdGljQWNjZXNzb3JzJDE5ICk7XG5cbnZhciBUeXBlID0gZnVuY3Rpb24gVHlwZSAobmFtZSkge1xuICB0aGlzLl9uYW1lID0gbmFtZSB8fCBudWxsO1xuICBUeXBlLm5hbWVUb1R5cGVNYXAucHV0KG5hbWUsIHRoaXMpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxJDEgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbmFtZVRvVHlwZU1hcDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuVHlwZS5wcm90b3R5cGUucmVhZFJlc29sdmUgPSBmdW5jdGlvbiByZWFkUmVzb2x2ZSAoKSB7XG4gIHJldHVybiBUeXBlLm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMuX25hbWUpXG59O1xuVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiB0aGlzLl9uYW1lXG59O1xuVHlwZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlXVxufTtcblR5cGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVHlwZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxJDEuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNTUyODYwMjYzMTczMTU4OTgyMiB9O1xuc3RhdGljQWNjZXNzb3JzJDEkMS5uYW1lVG9UeXBlTWFwLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBIYXNoTWFwKCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFR5cGUsIHN0YXRpY0FjY2Vzc29ycyQxJDEgKTtcblxuUHJlY2lzaW9uTW9kZWwuVHlwZSA9IFR5cGU7XG5QcmVjaXNpb25Nb2RlbC5GSVhFRCA9IG5ldyBUeXBlKCdGSVhFRCcpO1xuUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcgPSBuZXcgVHlwZSgnRkxPQVRJTkcnKTtcblByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSA9IG5ldyBUeXBlKCdGTE9BVElORyBTSU5HTEUnKTtcblxudmFyIEdlb21ldHJ5RmFjdG9yeSA9IGZ1bmN0aW9uIEdlb21ldHJ5RmFjdG9yeSAoKSB7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbmV3IFByZWNpc2lvbk1vZGVsKCk7XG4gIHRoaXMuX1NSSUQgPSAwO1xuICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gR2VvbWV0cnlGYWN0b3J5LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkpKSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUHJlY2lzaW9uTW9kZWwpIHtcbiAgICAgIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fU1JJRCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fU1JJRCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gYXJndW1lbnRzWzJdO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUudG9HZW9tZXRyeSA9IGZ1bmN0aW9uIHRvR2VvbWV0cnkgKGVudmVsb3BlKSB7XG4gIGlmIChlbnZlbG9wZS5pc051bGwoKSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwpXG4gIH1cbiAgaWYgKGVudmVsb3BlLmdldE1pblgoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WCgpICYmIGVudmVsb3BlLmdldE1pblkoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpKVxuICB9XG4gIGlmIChlbnZlbG9wZS5nZXRNaW5YKCkgPT09IGVudmVsb3BlLmdldE1heFgoKSB8fCBlbnZlbG9wZS5nZXRNaW5ZKCkgPT09IGVudmVsb3BlLmdldE1heFkoKSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWF4WCgpLCBlbnZlbG9wZS5nZXRNYXhZKCkpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1heFkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1heFgoKSwgZW52ZWxvcGUuZ2V0TWF4WSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWF4WCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1pblkoKSldKSwgbnVsbClcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBjcmVhdGVMaW5lU3RyaW5nIChjb29yZGluYXRlcykge1xuICBpZiAoIWNvb3JkaW5hdGVzKSB7IHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pLCB0aGlzKSB9XG4gIGVsc2UgaWYgKGNvb3JkaW5hdGVzIGluc3RhbmNlb2YgQXJyYXkpIHsgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcyksIHRoaXMpIH1cbiAgZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGNvb3JkaW5hdGVzLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7IHJldHVybiBuZXcgTGluZVN0cmluZyhjb29yZGluYXRlcywgdGhpcykgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gY3JlYXRlTXVsdGlMaW5lU3RyaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGluZVN0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmJ1aWxkR2VvbWV0cnkgPSBmdW5jdGlvbiBidWlsZEdlb21ldHJ5IChnZW9tTGlzdCkge1xuICB2YXIgZ2VvbUNsYXNzID0gbnVsbDtcbiAgdmFyIGlzSGV0ZXJvZ2VuZW91cyA9IGZhbHNlO1xuICB2YXIgaGFzR2VvbWV0cnlDb2xsZWN0aW9uID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBnZW9tTGlzdC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZ2VvbSA9IGkubmV4dCgpO1xuICAgIHZhciBwYXJ0Q2xhc3MgPSBnZW9tLmdldENsYXNzKCk7XG4gICAgaWYgKGdlb21DbGFzcyA9PT0gbnVsbCkge1xuICAgICAgZ2VvbUNsYXNzID0gcGFydENsYXNzO1xuICAgIH1cbiAgICBpZiAocGFydENsYXNzICE9PSBnZW9tQ2xhc3MpIHtcbiAgICAgIGlzSGV0ZXJvZ2VuZW91cyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChnZW9tLmlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCkpIHsgaGFzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHJ1ZTsgfVxuICB9XG4gIGlmIChnZW9tQ2xhc3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKVxuICB9XG4gIGlmIChpc0hldGVyb2dlbmVvdXMgfHwgaGFzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEdlb21ldHJ5RmFjdG9yeS50b0dlb21ldHJ5QXJyYXkoZ2VvbUxpc3QpKVxuICB9XG4gIHZhciBnZW9tMCA9IGdlb21MaXN0Lml0ZXJhdG9yKCkubmV4dCgpO1xuICB2YXIgaXNDb2xsZWN0aW9uID0gZ2VvbUxpc3Quc2l6ZSgpID4gMTtcbiAgaWYgKGlzQ29sbGVjdGlvbikge1xuICAgIGlmIChnZW9tMCBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihHZW9tZXRyeUZhY3RvcnkudG9Qb2x5Z29uQXJyYXkoZ2VvbUxpc3QpKVxuICAgIH0gZWxzZSBpZiAoZ2VvbTAgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoR2VvbWV0cnlGYWN0b3J5LnRvTGluZVN0cmluZ0FycmF5KGdlb21MaXN0KSlcbiAgICB9IGVsc2UgaWYgKGdlb20wIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoR2VvbWV0cnlGYWN0b3J5LnRvUG9pbnRBcnJheShnZW9tTGlzdCkpXG4gICAgfVxuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnVW5oYW5kbGVkIGNsYXNzOiAnICsgZ2VvbTAuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO1xuICB9XG4gIHJldHVybiBnZW9tMFxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMgPSBmdW5jdGlvbiBjcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyAoY29vcmRpbmF0ZXMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChjb29yZGluYXRlcyAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcykgOiBudWxsKVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlUG9pbnQgPSBmdW5jdGlvbiBjcmVhdGVQb2ludCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBjb29yZGluYXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQoY29vcmRpbmF0ZSAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbY29vcmRpbmF0ZV0pIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoY29vcmRpbmF0ZXMsIHRoaXMpXG4gICAgfVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gY3JlYXRlUG9seWdvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKG51bGwsIG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcykpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcyQxKSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHtcbiAgICAgIHZhciBzaGVsbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24oc2hlbGwsIG51bGwpXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2hlbGwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaG9sZXMgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNoZWxsJDEsIGhvbGVzLCB0aGlzKVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRTUklEID0gZnVuY3Rpb24gZ2V0U1JJRCAoKSB7XG4gIHJldHVybiB0aGlzLl9TUklEXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gY3JlYXRlR2VvbWV0cnkgKGcpIHtcbiAgdmFyIGVkaXRvciA9IG5ldyBHZW9tZXRyeUVkaXRvcih0aGlzKTtcbiAgcmV0dXJuIGVkaXRvci5lZGl0KGcsIHtcbiAgICBlZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgY29vcmRTZXEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIC8vIGNvbnN0IGdlb21ldHJ5ID0gYXJndW1lbnRzWzFdXG4gICAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZShjb29yZFNlcSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIGdldFByZWNpc2lvbk1vZGVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByZWNpc2lvbk1vZGVsXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVMaW5lYXJSaW5nID0gZnVuY3Rpb24gY3JlYXRlTGluZWFyUmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcoY29vcmRpbmF0ZXMgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKGNvb3JkaW5hdGVzJDEsIHRoaXMpXG4gICAgfVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBjcmVhdGVNdWx0aVBvbHlnb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwb2x5Z29ucyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgdGhpcylcbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlQb2ludCA9IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUG9pbnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KHBvaW50LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoY29vcmRpbmF0ZXMgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzJDEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSlcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoY29vcmRpbmF0ZXMkMS5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzJDEuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIHB0U2VxID0gdGhpcyQxLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSwgY29vcmRpbmF0ZXMkMS5nZXREaW1lbnNpb24oKSk7XG4gICAgICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShjb29yZGluYXRlcyQxLCBpLCBwdFNlcSwgMCwgMSk7XG4gICAgICAgIHBvaW50c1tpXSA9IHRoaXMkMS5jcmVhdGVQb2ludChwdFNlcSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KHBvaW50cylcbiAgICB9XG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZV1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlGYWN0b3J5XG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTXVsdGlQb2x5Z29uQXJyYXkgPSBmdW5jdGlvbiB0b011bHRpUG9seWdvbkFycmF5IChtdWx0aVBvbHlnb25zKSB7XG4gIHZhciBtdWx0aVBvbHlnb25BcnJheSA9IG5ldyBBcnJheShtdWx0aVBvbHlnb25zLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIG11bHRpUG9seWdvbnMudG9BcnJheShtdWx0aVBvbHlnb25BcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5ID0gZnVuY3Rpb24gdG9HZW9tZXRyeUFycmF5IChnZW9tZXRyaWVzKSB7XG4gIGlmIChnZW9tZXRyaWVzID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGdlb21ldHJ5QXJyYXkgPSBuZXcgQXJyYXkoZ2VvbWV0cmllcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBnZW9tZXRyaWVzLnRvQXJyYXkoZ2VvbWV0cnlBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2UoKVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b011bHRpTGluZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gdG9NdWx0aUxpbmVTdHJpbmdBcnJheSAobXVsdGlMaW5lU3RyaW5ncykge1xuICB2YXIgbXVsdGlMaW5lU3RyaW5nQXJyYXkgPSBuZXcgQXJyYXkobXVsdGlMaW5lU3RyaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBtdWx0aUxpbmVTdHJpbmdzLnRvQXJyYXkobXVsdGlMaW5lU3RyaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTGluZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gdG9MaW5lU3RyaW5nQXJyYXkgKGxpbmVTdHJpbmdzKSB7XG4gIHZhciBsaW5lU3RyaW5nQXJyYXkgPSBuZXcgQXJyYXkobGluZVN0cmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbGluZVN0cmluZ3MudG9BcnJheShsaW5lU3RyaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTXVsdGlQb2ludEFycmF5ID0gZnVuY3Rpb24gdG9NdWx0aVBvaW50QXJyYXkgKG11bHRpUG9pbnRzKSB7XG4gIHZhciBtdWx0aVBvaW50QXJyYXkgPSBuZXcgQXJyYXkobXVsdGlQb2ludHMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbXVsdGlQb2ludHMudG9BcnJheShtdWx0aVBvaW50QXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTGluZWFyUmluZ0FycmF5ID0gZnVuY3Rpb24gdG9MaW5lYXJSaW5nQXJyYXkgKGxpbmVhclJpbmdzKSB7XG4gIHZhciBsaW5lYXJSaW5nQXJyYXkgPSBuZXcgQXJyYXkobGluZWFyUmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbGluZWFyUmluZ3MudG9BcnJheShsaW5lYXJSaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvUG9pbnRBcnJheSA9IGZ1bmN0aW9uIHRvUG9pbnRBcnJheSAocG9pbnRzKSB7XG4gIHZhciBwb2ludEFycmF5ID0gbmV3IEFycmF5KHBvaW50cy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBwb2ludHMudG9BcnJheShwb2ludEFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b1BvbHlnb25BcnJheSA9IGZ1bmN0aW9uIHRvUG9seWdvbkFycmF5IChwb2x5Z29ucykge1xuICB2YXIgcG9seWdvbkFycmF5ID0gbmV3IEFycmF5KHBvbHlnb25zLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIHBvbHlnb25zLnRvQXJyYXkocG9seWdvbkFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkID0gZnVuY3Rpb24gY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCAoY29vcmQsIGV4ZW1wbGFyKSB7XG4gIGV4ZW1wbGFyLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UoY29vcmQpO1xuICByZXR1cm4gZXhlbXBsYXIuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KGNvb3JkKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTY4MjA1MjQ3NTMwOTQwOTU2MzUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5RmFjdG9yeSwgc3RhdGljQWNjZXNzb3JzJDIgKTtcblxudmFyIGdlb21ldHJ5VHlwZXMgPSBbJ1BvaW50JywgJ011bHRpUG9pbnQnLCAnTGluZVN0cmluZycsICdNdWx0aUxpbmVTdHJpbmcnLCAnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBXZWxsLUtub3duIFRleHQuQ3JlYXRlIGEgbmV3IHBhcnNlciBmb3IgR2VvSlNPTlxuICogTk9URTogQWRhcHRlZCBmcm9tIE9wZW5MYXllcnMgMi4xMSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwYXJzZXIgZm9yIEdlb0pTT05cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIEdlb0pzb25QYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBHZW9KU09OUGFyc2VyID0gZnVuY3Rpb24gR2VvSlNPTlBhcnNlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMuZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5IHx8IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbn07XG4vKipcbiAqIERlc2VyaWFsaXplIGEgR2VvSlNPTiBvYmplY3QgYW5kIHJldHVybiB0aGUgR2VvbWV0cnkgb3IgRmVhdHVyZShDb2xsZWN0aW9uKSB3aXRoIEpTVFMgR2VvbWV0cmllc1xuICpcbiAqIEBwYXJhbSB7fVxuICogICAgICAgIEEgR2VvSlNPTiBvYmplY3QuXG4gKiBAcmV0dXJuIHt9IEEgR2VvbWV0cnkgaW5zdGFuY2Ugb3Igb2JqZWN0IHJlcHJlc2VudGluZyBhIEZlYXR1cmUoQ29sbGVjdGlvbikgd2l0aCBHZW9tZXRyeSBpbnN0YW5jZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5HZW9KU09OUGFyc2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAoanNvbikge1xuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShqc29uKTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSBqc29uO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBvYmoudHlwZTtcblxuICBpZiAoIXBhcnNlW3R5cGVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb0pTT04gdHlwZTogJyArIG9iai50eXBlKVxuICB9XG5cbiAgaWYgKGdlb21ldHJ5VHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcGFyc2VbdHlwZV0uYXBwbHkodGhpcywgW29iai5jb29yZGluYXRlc10pXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICByZXR1cm4gcGFyc2VbdHlwZV0uYXBwbHkodGhpcywgW29iai5nZW9tZXRyaWVzXSlcbiAgfVxuXG4gIC8vIGZlYXR1cmUgb3IgZmVhdHVyZSBjb2xsZWN0aW9uXG4gIHJldHVybiBwYXJzZVt0eXBlXS5hcHBseSh0aGlzLCBbb2JqXSlcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgR2VvbWV0cnkgb2JqZWN0IGludG8gR2VvSlNPTlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9XG4gKiAgICAgICAgZ2VvbWV0cnkgQSBHZW9tZXRyeSBvciBhcnJheSBvZiBHZW9tZXRyaWVzLlxuICogQHJldHVybiB7T2JqZWN0fSBBIEdlb0pTT04gb2JqZWN0IHJlcHJlc3RpbmcgdGhlIGlucHV0IEdlb21ldHJ5L0dlb21ldHJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5HZW9KU09OUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChnZW9tZXRyeSkge1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldEdlb21ldHJ5VHlwZSgpO1xuXG4gIGlmICghZXh0cmFjdFt0eXBlXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZCcpXG4gIH1cblxuICByZXR1cm4gZXh0cmFjdFt0eXBlXS5hcHBseSh0aGlzLCBbZ2VvbWV0cnldKVxufTtcblxudmFyIHBhcnNlID0ge1xuICAvKipcbiAgICogUGFyc2UgYSBHZW9KU09OIEZlYXR1cmUgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiAgICAgICAgICBvYmogT2JqZWN0IHRvIHBhcnNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEZlYXR1cmUgd2l0aCBnZW9tZXRyeS9iYm94IGNvbnZlcnRlZCB0byBKU1RTIEdlb21ldHJpZXMuXG4gICAqL1xuICBGZWF0dXJlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZlYXR1cmUgPSB7fTtcblxuICAgIC8vIGNvcHkgZmVhdHVyZXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBmZWF0dXJlW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBnZW9tZXRyeVxuICAgIGlmIChvYmouZ2VvbWV0cnkpIHtcbiAgICAgIHZhciB0eXBlID0gb2JqLmdlb21ldHJ5LnR5cGU7XG4gICAgICBpZiAoIXBhcnNlW3R5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9KU09OIHR5cGU6ICcgKyBvYmoudHlwZSlcbiAgICAgIH1cbiAgICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSB0aGlzLnJlYWQob2JqLmdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICAvLyBiYm94XG4gICAgaWYgKG9iai5iYm94KSB7XG4gICAgICBmZWF0dXJlLmJib3ggPSBwYXJzZS5iYm94LmFwcGx5KHRoaXMsIFtvYmouYmJveF0pO1xuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlXG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqICAgICAgICAgIG9iaiBPYmplY3QgdG8gcGFyc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRmVhdHVyZUNvbGxlY3Rpb24gd2l0aCBnZW9tZXRyeS9iYm94IGNvbnZlcnRlZCB0byBKU1RTIEdlb21ldHJpZXMuXG4gICAqL1xuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZlYXR1cmVDb2xsZWN0aW9uID0ge307XG5cbiAgICBpZiAob2JqLmZlYXR1cmVzKSB7XG4gICAgICBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5mZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5wdXNoKHRoaXMkMS5yZWFkKG9iai5mZWF0dXJlc1tpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmouYmJveCkge1xuICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uYmJveCA9IHRoaXMucGFyc2UuYmJveC5hcHBseSh0aGlzLCBbb2JqLmJib3hdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb25cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgb3JkaW5hdGVzIGluIGFuIGFycmF5IHRvIGFuIGFycmF5IG9mIENvb3JkaW5hdGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGgge051bWJlcn1zLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBDb29yZGluYXRlcy5cbiAgICovXG4gIGNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV07XG4gICAgICBjb29yZGluYXRlcy5wdXNoKG5ldyBDb29yZGluYXRlKHN1YlswXSwgc3ViWzFdKSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlc1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBiYm94IHRvIGEgTGluZWFyUmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIFt4TWluLCB5TWluLCB4TWF4LCB5TWF4XS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBiYm94OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbMV0pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMl0sIGFycmF5WzFdKSxcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzJdLCBhcnJheVszXSksXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbM10pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzFdKVxuICAgIF0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBvcmRpbmF0ZXMgdG8gYSBQb2ludFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIG9yZGluYXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7UG9pbnR9IFBvaW50LlxuICAgKi9cbiAgUG9pbnQ6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb29yZGluYXRlID0gbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoY29vcmRpbmF0ZSlcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIGNvb3JkaW5hdGVzIHRvIGEgTXVsdGlQb2ludFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvaW50fSBNdWx0aVBvaW50LlxuICAgKi9cbiAgTXVsdGlQb2ludDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnRzLnB1c2gocGFyc2UuUG9pbnQuYXBwbHkodGhpcyQxLCBbYXJyYXlbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHBvaW50cylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIGNvb3JkaW5hdGVzIHRvIGEgTGluZVN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBMaW5lU3RyaW5nLlxuICAgKi9cbiAgTGluZVN0cmluZzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gcGFyc2UuY29vcmRpbmF0ZXMuYXBwbHkodGhpcywgW2FycmF5XSk7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBjb29yZGluYXRlcyB0byBhIE11bHRpTGluZVN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IE11bHRpTGluZVN0cmluZy5cbiAgICovXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGluZVN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lU3RyaW5ncy5wdXNoKHBhcnNlLkxpbmVTdHJpbmcuYXBwbHkodGhpcyQxLCBbYXJyYXlbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgdG8gYSBQb2x5Z29uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggc2hlbGwgYW5kIGhvbGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2x5Z29ufSBQb2x5Z29uLlxuICAgKi9cbiAgUG9seWdvbjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2hlbGxDb29yZGluYXRlcyA9IHBhcnNlLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsIFthcnJheVswXV0pO1xuICAgIHZhciBzaGVsbCA9IHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoc2hlbGxDb29yZGluYXRlcyk7XG4gICAgdmFyIGhvbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGhvbGUgPSBhcnJheVtpXTtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHBhcnNlLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMkMSwgW2hvbGVdKTtcbiAgICAgIHZhciBsaW5lYXJSaW5nID0gdGhpcyQxLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkaW5hdGVzKTtcbiAgICAgIGhvbGVzLnB1c2gobGluZWFyUmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB0byBhIE11bHRpUG9seWdvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSBvZiBhcnJheXMgd2l0aCBzaGVsbCBhbmQgcmluZ3MuXG4gICAqXG4gICAqIEByZXR1cm4ge011bHRpUG9seWdvbn0gTXVsdGlQb2x5Z29uLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gYXJyYXlbaV07XG4gICAgICBwb2x5Z29ucy5wdXNoKHBhcnNlLlBvbHlnb24uYXBwbHkodGhpcyQxLCBbcG9seWdvbl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihwb2x5Z29ucylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB0byBhIEdlb21ldHJ5Q29sbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSBvZiBHZW9KU09OIGdlb21ldHJpZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5Q29sbGVjdGlvbn0gR2VvbWV0cnlDb2xsZWN0aW9uLlxuICAgKi9cbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gYXJyYXlbaV07XG4gICAgICBnZW9tZXRyaWVzLnB1c2godGhpcyQxLnJlYWQoZ2VvbWV0cnkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKVxuICB9XG59O1xuXG52YXIgZXh0cmFjdCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSBDb29yZGluYXRlIHRvIGFuIEFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX1cbiAgICogICAgICAgICAgY29vcmRpbmF0ZSBDb29yZGluYXRlIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBvcmRpbmF0ZXMuXG4gICAqL1xuICBjb29yZGluYXRlOiBmdW5jdGlvbiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiBbY29vcmRpbmF0ZS54LCBjb29yZGluYXRlLnldXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBQb2ludCB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9XG4gICAqICAgICAgICAgIHBvaW50IFBvaW50IHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiAyIG9yZGluYXRlcyAocGFpcmVkIHRvIGEgY29vcmRpbmF0ZSkuXG4gICAqL1xuICBQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGFycmF5ID0gZXh0cmFjdC5jb29yZGluYXRlLmFwcGx5KHRoaXMsIFtwb2ludC5nZXRDb29yZGluYXRlKCldKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIE11bHRpUG9pbnQgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpUG9pbnR9XG4gICAqICAgICAgICAgIG11bHRpcG9pbnQgTXVsdGlQb2ludCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBNdWx0aVBvaW50OiBmdW5jdGlvbiAobXVsdGlwb2ludCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aXBvaW50Ll9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcG9pbnQgPSBtdWx0aXBvaW50Ll9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGdlb0pzb24gPSBleHRyYWN0LlBvaW50LmFwcGx5KHRoaXMkMSwgW3BvaW50XSk7XG4gICAgICBhcnJheS5wdXNoKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTGluZVN0cmluZyB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ31cbiAgICogICAgICAgICAgbGluZXN0cmluZyBMaW5lU3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBjb29yZGluYXRlcy5cbiAgICovXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChsaW5lc3RyaW5nKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBsaW5lc3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdC5jb29yZGluYXRlLmFwcGx5KHRoaXMkMSwgW2Nvb3JkaW5hdGVdKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBNdWx0aUxpbmVTdHJpbmcgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpTGluZVN0cmluZ31cbiAgICogICAgICAgICAgbXVsdGlsaW5lc3RyaW5nIE11bHRpTGluZVN0cmluZyB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uIChtdWx0aWxpbmVzdHJpbmcpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlsaW5lc3RyaW5nLl9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZXN0cmluZyA9IG11bHRpbGluZXN0cmluZy5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciBnZW9Kc29uID0gZXh0cmFjdC5MaW5lU3RyaW5nLmFwcGx5KHRoaXMkMSwgW2xpbmVzdHJpbmddKTtcbiAgICAgIGFycmF5LnB1c2goZ2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIFBvbHlnb24gdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHlnb259XG4gICAqICAgICAgICAgIHBvbHlnb24gUG9seWdvbiB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBzaGVsbCwgaG9sZXMuXG4gICAqL1xuICBQb2x5Z29uOiBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHNoZWxsR2VvSnNvbiA9IGV4dHJhY3QuTGluZVN0cmluZy5hcHBseSh0aGlzLCBbcG9seWdvbi5fc2hlbGxdKTtcbiAgICBhcnJheS5wdXNoKHNoZWxsR2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLl9ob2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGhvbGUgPSBwb2x5Z29uLl9ob2xlc1tpXTtcbiAgICAgIHZhciBob2xlR2VvSnNvbiA9IGV4dHJhY3QuTGluZVN0cmluZy5hcHBseSh0aGlzJDEsIFtob2xlXSk7XG4gICAgICBhcnJheS5wdXNoKGhvbGVHZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIE11bHRpUG9seWdvbiB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2x5Z29ufVxuICAgKiAgICAgICAgICBtdWx0aXBvbHlnb24gTXVsdGlQb2x5Z29uIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBwb2x5Z29ucy5cbiAgICovXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKG11bHRpcG9seWdvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aXBvbHlnb24uX2dlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gbXVsdGlwb2x5Z29uLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGdlb0pzb24gPSBleHRyYWN0LlBvbHlnb24uYXBwbHkodGhpcyQxLCBbcG9seWdvbl0pO1xuICAgICAgYXJyYXkucHVzaChnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdWx0aVBvbHlnb24nLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgR2VvbWV0cnlDb2xsZWN0aW9uIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtHZW9tZXRyeUNvbGxlY3Rpb259XG4gICAqICAgICAgICAgIGNvbGxlY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBnZW9tZXRyaWVzLlxuICAgKi9cbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIHR5cGUgPSBnZW9tZXRyeS5nZXRHZW9tZXRyeVR5cGUoKTtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdFt0eXBlXS5hcHBseSh0aGlzJDEsIFtnZW9tZXRyeV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgZ2VvbWV0cmllczogYXJyYXlcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBnZW9tZXRyeSBpbiBHZW9KU09OIHRvIGEge0BsaW5rIEdlb21ldHJ5fS5cbiAqL1xuXG4vKipcbiAqIEEgPGNvZGU+R2VvSlNPTlJlYWRlcjwvY29kZT4gaXMgcGFyYW1ldGVyaXplZCBieSBhIDxjb2RlPkdlb21ldHJ5RmFjdG9yeTwvY29kZT4sXG4gKiB0byBhbGxvdyBpdCB0byBjcmVhdGUgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IG9iamVjdHMgb2YgdGhlIGFwcHJvcHJpYXRlXG4gKiBpbXBsZW1lbnRhdGlvbi4gSW4gcGFydGljdWxhciwgdGhlIDxjb2RlPkdlb21ldHJ5RmFjdG9yeTwvY29kZT4gZGV0ZXJtaW5lc1xuICogdGhlIDxjb2RlPlByZWNpc2lvbk1vZGVsPC9jb2RlPiBhbmQgPGNvZGU+U1JJRDwvY29kZT4gdGhhdCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR2VvSlNPTlJlYWRlciA9IGZ1bmN0aW9uIEdlb0pTT05SZWFkZXIgKGdlb21ldHJ5RmFjdG9yeSkge1xuICB0aGlzLmdlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeSB8fCBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG4gIHRoaXMucHJlY2lzaW9uTW9kZWwgPSB0aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpO1xuICB0aGlzLnBhcnNlciA9IG5ldyBHZW9KU09OUGFyc2VyKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtcbn07XG4vKipcbiAqIFJlYWRzIGEgR2VvSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBHZW9tZXRyeX1cbiAqXG4gKiBXaWxsIGFsc28gcGFyc2UgR2VvSlNPTiBGZWF0dXJlcy9GZWF0dXJlQ29sbGVjdGlvbnMgYXMgY3VzdG9tIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBnZW9Kc29uIGEgR2VvSlNPTiBPYmplY3Qgb3IgU3RyaW5nLlxuICogQHJldHVybiB7R2VvbWV0cnl8T2JqZWN0fSBhIDxjb2RlPkdlb21ldHJ5IG9yIEZlYXR1cmUvRmVhdHVyZUNvbGxlY3Rpb24gcmVwcmVzZW50YXRpb24uPC9jb2RlPlxuICogQG1lbWJlcm9mIEdlb0pTT05SZWFkZXJcbiAqL1xuR2VvSlNPTlJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIHJlYWQgKGdlb0pzb24pIHtcbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5wYXJzZXIucmVhZChnZW9Kc29uKTtcblxuICBpZiAodGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCkgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgdGhpcy5yZWR1Y2VQcmVjaXNpb24oZ2VvbWV0cnkpO1xuICB9XG5cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuXG4vLyBOT1RFOiB0aGlzIGlzIGEgaGFja1xuR2VvSlNPTlJlYWRlci5wcm90b3R5cGUucmVkdWNlUHJlY2lzaW9uID0gZnVuY3Rpb24gcmVkdWNlUHJlY2lzaW9uIChnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpLCBsZW47XG5cbiAgaWYgKGdlb21ldHJ5LmNvb3JkaW5hdGUpIHtcbiAgICB0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGdlb21ldHJ5LmNvb3JkaW5hdGUpO1xuICB9IGVsc2UgaWYgKGdlb21ldHJ5LnBvaW50cykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcyQxLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGdlb21ldHJ5LnBvaW50c1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdlb21ldHJ5Lmdlb21ldHJpZXMpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzJDEucmVkdWNlUHJlY2lzaW9uKGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIEdlb0pTT05Xcml0ZXJcbiAqL1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgR2VvSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBHZW9tZXRyeX0uIFRoZVxuICogVGhlIEdlb0pTT04gZm9ybWF0IGlzIGRlZmluZWQgPEFcbiAqIEhSRUY9XCJodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWxcIj5oZXJlPC9BPi5cbiAqL1xuXG4vKipcbiAqIFRoZSA8Y29kZT5HZW9KU09OV3JpdGVyPC9jb2RlPiBvdXRwdXRzIGNvb3JkaW5hdGVzIHJvdW5kZWQgdG8gdGhlIHByZWNpc2lvblxuICogbW9kZWwuIE9ubHkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlXG4gKiBvcmRpbmF0ZXMgdG8gdGhlIHJlcXVpcmVkIHByZWNpc2lvbiB3aWxsIGJlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdlb0pTT05Xcml0ZXIgPSBmdW5jdGlvbiBHZW9KU09OV3JpdGVyICgpIHtcbiAgdGhpcy5wYXJzZXIgPSBuZXcgR2VvSlNPTlBhcnNlcih0aGlzLmdlb21ldHJ5RmFjdG9yeSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBpdHMgR2VvSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fVxuICogICAgICAgIGdlb21ldHJ5IGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHZW9KU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHZW9tZXRyeS5cbiAqIEBtZW1iZXJvZiBHZW9KU09OV3JpdGVyXG4gKi9cbkdlb0pTT05Xcml0ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlci53cml0ZShnZW9tZXRyeSlcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbi8vIGlvXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIwID0geyBPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxMRUZUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFJJR0hUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9zaXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9zaXRpb25cbn07XG5Qb3NpdGlvbi5vcHBvc2l0ZSA9IGZ1bmN0aW9uIG9wcG9zaXRlIChwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxFRlQpIHsgcmV0dXJuIFBvc2l0aW9uLlJJR0hUIH1cbiAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SSUdIVCkgeyByZXR1cm4gUG9zaXRpb24uTEVGVCB9XG4gIHJldHVybiBwb3NpdGlvblxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMC5PTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjAuTEVGVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjAuUklHSFQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUG9zaXRpb24sIHN0YXRpY0FjY2Vzc29ycyQyMCApO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVtcHR5U3RhY2tFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbkVtcHR5U3RhY2tFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuRW1wdHlTdGFja0V4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdFbXB0eVN0YWNrRXhjZXB0aW9uJztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9TdGFjay5odG1sXG4gKlxuICogQGV4dGVuZHMge0xpc3R9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0YWNrICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYXJyYXlfID0gW107XG59XG5TdGFjay5wcm90b3R5cGUgPSBuZXcgTGlzdCgpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TdGFjay5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhpcy5hcnJheV8ucHVzaChlKTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblN0YWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNpemUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpXG4gIH1cblxuICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdXG59O1xuXG4vKipcbiAqIFB1c2hlcyBhbiBpdGVtIG9udG8gdGhlIHRvcCBvZiB0aGlzIHN0YWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLmFycmF5Xy5wdXNoKGUpO1xuICByZXR1cm4gZVxufTtcblxuLyoqXG4gKiBQdXNoZXMgYW4gaXRlbSBvbnRvIHRoZSB0b3Agb2YgdGhpcyBzdGFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAodGhpcy5hcnJheV8ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5U3RhY2tFeGNlcHRpb24oKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpXG59O1xuXG4vKipcbiAqIExvb2tzIGF0IHRoZSBvYmplY3QgYXQgdGhlIHRvcCBvZiB0aGlzIHN0YWNrIHdpdGhvdXQgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcbiAqIHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFbXB0eVN0YWNrRXhjZXB0aW9uKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGggLSAxXVxufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIHN0YWNrIGlzIGVtcHR5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHN0YWNrIGNvbnRhaW5zIG5vIGl0ZW1zOyBmYWxzZVxuICogICAgICAgICBvdGhlcndpc2UuXG4gKi9cblN0YWNrLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU3RhY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVtcHR5KClcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgMS1iYXNlZCBwb3NpdGlvbiB3aGVyZSBhbiBvYmplY3QgaXMgb24gdGhpcyBzdGFjay4gSWYgdGhlIG9iamVjdFxuICogbyBvY2N1cnMgYXMgYW4gaXRlbSBpbiB0aGlzIHN0YWNrLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZVxuICogdG9wIG9mIHRoZSBzdGFjayBvZiB0aGUgb2NjdXJyZW5jZSBuZWFyZXN0IHRoZSB0b3Agb2YgdGhlIHN0YWNrOyB0aGUgdG9wbW9zdFxuICogaXRlbSBvbiB0aGUgc3RhY2sgaXMgY29uc2lkZXJlZCB0byBiZSBhdCBkaXN0YW5jZSAxLiBUaGUgZXF1YWxzIG1ldGhvZCBpc1xuICogdXNlZCB0byBjb21wYXJlIG8gdG8gdGhlIGl0ZW1zIGluIHRoaXMgc3RhY2suXG4gKlxuICogTk9URTogZG9lcyBub3QgY3VycmVudGx5IGFjdHVhbGx5IHVzZSBlcXVhbHMuICg9PT0gaXMgdXNlZClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMS1iYXNlZCBwb3NpdGlvbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHdoZXJlIHRoZVxuICogICAgICAgICBvYmplY3QgaXMgbG9jYXRlZDsgdGhlIHJldHVybiB2YWx1ZSAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgb2JqZWN0IGlzXG4gKiAgICAgICAgIG5vdCBvbiB0aGUgc3RhY2suXG4gKi9cblN0YWNrLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gdGhpcy5hcnJheV8uaW5kZXhPZihvKVxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAZXhwb3J0XG4gKi9cblN0YWNrLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TdGFjay5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVxufTtcblxudmFyIFJpZ2h0bW9zdEVkZ2VGaW5kZXIgPSBmdW5jdGlvbiBSaWdodG1vc3RFZGdlRmluZGVyICgpIHtcbiAgdGhpcy5fbWluSW5kZXggPSAtMTtcbiAgdGhpcy5fbWluQ29vcmQgPSBudWxsO1xuICB0aGlzLl9taW5EZSA9IG51bGw7XG4gIHRoaXMuX29yaWVudGVkRGUgPSBudWxsO1xufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pbkNvb3JkXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0U2lkZSA9IGZ1bmN0aW9uIGdldFJpZ2h0bW9zdFNpZGUgKGRlLCBpbmRleCkge1xuICB2YXIgc2lkZSA9IHRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudChkZSwgaW5kZXgpO1xuICBpZiAoc2lkZSA8IDApIHsgc2lkZSA9IHRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudChkZSwgaW5kZXggLSAxKTsgfVxuICBpZiAoc2lkZSA8IDApIHtcbiAgICB0aGlzLl9taW5Db29yZCA9IG51bGw7XG4gICAgdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUoZGUpO1xuICB9XG4gIHJldHVybiBzaWRlXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCA9IGZ1bmN0aW9uIGZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXggKCkge1xuICB2YXIgcHRzID0gdGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gIEFzc2VydC5pc1RydWUodGhpcy5fbWluSW5kZXggPiAwICYmIHRoaXMuX21pbkluZGV4IDwgcHRzLmxlbmd0aCwgJ3JpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZScpO1xuICB2YXIgcFByZXYgPSBwdHNbdGhpcy5fbWluSW5kZXggLSAxXTtcbiAgdmFyIHBOZXh0ID0gcHRzW3RoaXMuX21pbkluZGV4ICsgMV07XG4gIHZhciBvcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24odGhpcy5fbWluQ29vcmQsIHBOZXh0LCBwUHJldik7XG4gIHZhciB1c2VQcmV2ID0gZmFsc2U7XG4gIGlmIChwUHJldi55IDwgdGhpcy5fbWluQ29vcmQueSAmJiBwTmV4dC55IDwgdGhpcy5fbWluQ29vcmQueSAmJiBvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UpIHtcbiAgICB1c2VQcmV2ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwUHJldi55ID4gdGhpcy5fbWluQ29vcmQueSAmJiBwTmV4dC55ID4gdGhpcy5fbWluQ29vcmQueSAmJiBvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSkge1xuICAgIHVzZVByZXYgPSB0cnVlO1xuICB9XG4gIGlmICh1c2VQcmV2KSB7XG4gICAgdGhpcy5fbWluSW5kZXggPSB0aGlzLl9taW5JbmRleCAtIDE7XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50ID0gZnVuY3Rpb24gZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCAoZGUsIGkpIHtcbiAgdmFyIGUgPSBkZS5nZXRFZGdlKCk7XG4gIHZhciBjb29yZCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKGkgPCAwIHx8IGkgKyAxID49IGNvb3JkLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAoY29vcmRbaV0ueSA9PT0gY29vcmRbaSArIDFdLnkpIHsgcmV0dXJuIC0xIH1cbiAgdmFyIHBvcyA9IFBvc2l0aW9uLkxFRlQ7XG4gIGlmIChjb29yZFtpXS55IDwgY29vcmRbaSArIDFdLnkpIHsgcG9zID0gUG9zaXRpb24uUklHSFQ7IH1cbiAgcmV0dXJuIHBvc1xufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX29yaWVudGVkRGVcbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBjaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUgKGRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkID0gZGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5fbWluQ29vcmQgPT09IG51bGwgfHwgY29vcmRbaV0ueCA+IHRoaXMkMS5fbWluQ29vcmQueCkge1xuICAgICAgdGhpcyQxLl9taW5EZSA9IGRlO1xuICAgICAgdGhpcyQxLl9taW5JbmRleCA9IGk7XG4gICAgICB0aGlzJDEuX21pbkNvb3JkID0gY29vcmRbaV07XG4gICAgfVxuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUgPSBmdW5jdGlvbiBmaW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5fbWluRGUuZ2V0Tm9kZSgpO1xuICB2YXIgc3RhciA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdGhpcy5fbWluRGUgPSBzdGFyLmdldFJpZ2h0bW9zdEVkZ2UoKTtcbiAgaWYgKCF0aGlzLl9taW5EZS5pc0ZvcndhcmQoKSkge1xuICAgIHRoaXMuX21pbkRlID0gdGhpcy5fbWluRGUuZ2V0U3ltKCk7XG4gICAgdGhpcy5fbWluSW5kZXggPSB0aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGggLSAxO1xuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZEVkZ2UgPSBmdW5jdGlvbiBmaW5kRWRnZSAoZGlyRWRnZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgaWYgKCFkZS5pc0ZvcndhcmQoKSkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShkZSk7XG4gIH1cbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9taW5JbmRleCAhPT0gMCB8fCB0aGlzLl9taW5Db29yZC5lcXVhbHModGhpcy5fbWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSwgJ2luY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmcnKTtcbiAgaWYgKHRoaXMuX21pbkluZGV4ID09PSAwKSB7XG4gICAgdGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpO1xuICB9XG4gIHRoaXMuX29yaWVudGVkRGUgPSB0aGlzLl9taW5EZTtcbiAgdmFyIHJpZ2h0bW9zdFNpZGUgPSB0aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5fbWluRGUsIHRoaXMuX21pbkluZGV4KTtcbiAgaWYgKHJpZ2h0bW9zdFNpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHtcbiAgICB0aGlzLl9vcmllbnRlZERlID0gdGhpcy5fbWluRGUuZ2V0U3ltKCk7XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBSaWdodG1vc3RFZGdlRmluZGVyXG59O1xuXG52YXIgVG9wb2xvZ3lFeGNlcHRpb24gPSAoZnVuY3Rpb24gKFJ1bnRpbWVFeGNlcHRpb24kJDEpIHtcbiAgZnVuY3Rpb24gVG9wb2xvZ3lFeGNlcHRpb24gKG1zZywgcHQpIHtcbiAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcywgVG9wb2xvZ3lFeGNlcHRpb24ubXNnV2l0aENvb3JkKG1zZywgcHQpKTtcbiAgICB0aGlzLnB0ID0gcHQgPyBuZXcgQ29vcmRpbmF0ZShwdCkgOiBudWxsO1xuICAgIHRoaXMubmFtZSA9ICdUb3BvbG9neUV4Y2VwdGlvbic7XG4gIH1cblxuICBpZiAoIFJ1bnRpbWVFeGNlcHRpb24kJDEgKSBUb3BvbG9neUV4Y2VwdGlvbi5fX3Byb3RvX18gPSBSdW50aW1lRXhjZXB0aW9uJCQxO1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSdW50aW1lRXhjZXB0aW9uJCQxICYmIFJ1bnRpbWVFeGNlcHRpb24kJDEucHJvdG90eXBlICk7XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcG9sb2d5RXhjZXB0aW9uO1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnB0XG4gIH07XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBUb3BvbG9neUV4Y2VwdGlvblxuICB9O1xuICBUb3BvbG9neUV4Y2VwdGlvbi5tc2dXaXRoQ29vcmQgPSBmdW5jdGlvbiBtc2dXaXRoQ29vcmQgKG1zZywgcHQpIHtcbiAgICBpZiAoIXB0KSB7IHJldHVybiBtc2cgKyAnIFsgJyArIHB0ICsgJyBdJyB9XG4gICAgcmV0dXJuIG1zZ1xuICB9O1xuXG4gIHJldHVybiBUb3BvbG9neUV4Y2VwdGlvbjtcbn0oUnVudGltZUV4Y2VwdGlvbikpO1xuXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uIExpbmtlZExpc3QgKCkge1xuICB0aGlzLmFycmF5XyA9IFtdO1xufTtcbkxpbmtlZExpc3QucHJvdG90eXBlLmFkZExhc3QgPSBmdW5jdGlvbiBhZGRMYXN0IChlKSB7XG4gIHRoaXMuYXJyYXlfLnB1c2goZSk7XG59O1xuTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlRmlyc3QgPSBmdW5jdGlvbiByZW1vdmVGaXJzdCAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpXG59O1xuTGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoID09PSAwXG59O1xuXG52YXIgQnVmZmVyU3ViZ3JhcGggPSBmdW5jdGlvbiBCdWZmZXJTdWJncmFwaCAoKSB7XG4gIHRoaXMuX2ZpbmRlciA9IG51bGw7XG4gIHRoaXMuX2RpckVkZ2VMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ub2RlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fcmlnaHRNb3N0Q29vcmQgPSBudWxsO1xuICB0aGlzLl9lbnYgPSBudWxsO1xuICB0aGlzLl9maW5kZXIgPSBuZXcgUmlnaHRtb3N0RWRnZUZpbmRlcigpO1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jbGVhclZpc2l0ZWRFZGdlcyA9IGZ1bmN0aW9uIGNsZWFyVmlzaXRlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIGRlLnNldFZpc2l0ZWQoZmFsc2UpO1xuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldFJpZ2h0bW9zdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkXG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXB1dGVOb2RlRGVwdGggPSBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRoIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0RWRnZSA9IG51bGw7XG4gIGZvciAodmFyIGkgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgaWYgKGRlLmlzVmlzaXRlZCgpIHx8IGRlLmdldFN5bSgpLmlzVmlzaXRlZCgpKSB7XG4gICAgICBzdGFydEVkZ2UgPSBkZTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChzdGFydEVkZ2UgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCd1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0ICcgKyBuLmdldENvb3JkaW5hdGUoKSkgfVxuICBuLmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhzdGFydEVkZ2UpO1xuICBmb3IgKHZhciBpJDEgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUkMSA9IGkkMS5uZXh0KCk7XG4gICAgZGUkMS5zZXRWaXNpdGVkKHRydWUpO1xuICAgIHRoaXMkMS5jb3B5U3ltRGVwdGhzKGRlJDEpO1xuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXB1dGVEZXB0aCA9IGZ1bmN0aW9uIGNvbXB1dGVEZXB0aCAob3V0c2lkZURlcHRoKSB7XG4gIHRoaXMuY2xlYXJWaXNpdGVkRWRnZXMoKTtcbiAgdmFyIGRlID0gdGhpcy5fZmluZGVyLmdldEVkZ2UoKTtcbiAgLy8gY29uc3QgbiA9IGRlLmdldE5vZGUoKVxuICAvLyBjb25zdCBsYWJlbCA9IGRlLmdldExhYmVsKClcbiAgZGUuc2V0RWRnZURlcHRocyhQb3NpdGlvbi5SSUdIVCwgb3V0c2lkZURlcHRoKTtcbiAgdGhpcy5jb3B5U3ltRGVwdGhzKGRlKTtcbiAgdGhpcy5jb21wdXRlRGVwdGhzKGRlKTtcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChub2RlKSB7XG4gIHRoaXMuYWRkUmVhY2hhYmxlKG5vZGUpO1xuICB0aGlzLl9maW5kZXIuZmluZEVkZ2UodGhpcy5fZGlyRWRnZUxpc3QpO1xuICB0aGlzLl9yaWdodE1vc3RDb29yZCA9IHRoaXMuX2ZpbmRlci5nZXRDb29yZGluYXRlKCk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmZpbmRSZXN1bHRFZGdlcyA9IGZ1bmN0aW9uIGZpbmRSZXN1bHRFZGdlcyAoKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZGUuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpID49IDEgJiYgZGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCkgPD0gMCAmJiAhZGUuaXNJbnRlcmlvckFyZWFFZGdlKCkpIHtcbiAgICAgIGRlLnNldEluUmVzdWx0KHRydWUpO1xuICAgIH1cbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb21wdXRlRGVwdGhzID0gZnVuY3Rpb24gY29tcHV0ZURlcHRocyAoc3RhcnRFZGdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVzVmlzaXRlZCA9IG5ldyBIYXNoU2V0KCk7XG4gIHZhciBub2RlUXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgc3RhcnROb2RlID0gc3RhcnRFZGdlLmdldE5vZGUoKTtcbiAgbm9kZVF1ZXVlLmFkZExhc3Qoc3RhcnROb2RlKTtcbiAgbm9kZXNWaXNpdGVkLmFkZChzdGFydE5vZGUpO1xuICBzdGFydEVkZ2Uuc2V0VmlzaXRlZCh0cnVlKTtcbiAgd2hpbGUgKCFub2RlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgdmFyIG4gPSBub2RlUXVldWUucmVtb3ZlRmlyc3QoKTtcbiAgICBub2Rlc1Zpc2l0ZWQuYWRkKG4pO1xuICAgIHRoaXMkMS5jb21wdXRlTm9kZURlcHRoKG4pO1xuICAgIGZvciAodmFyIGkgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgICAgIGlmIChzeW0uaXNWaXNpdGVkKCkpIHsgY29udGludWUgfVxuICAgICAgdmFyIGFkak5vZGUgPSBzeW0uZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCFub2Rlc1Zpc2l0ZWQuY29udGFpbnMoYWRqTm9kZSkpIHtcbiAgICAgICAgbm9kZVF1ZXVlLmFkZExhc3QoYWRqTm9kZSk7XG4gICAgICAgIG5vZGVzVmlzaXRlZC5hZGQoYWRqTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgZ3JhcGggPSBvO1xuICBpZiAodGhpcy5fcmlnaHRNb3N0Q29vcmQueCA8IGdyYXBoLl9yaWdodE1vc3RDb29yZC54KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHRoaXMuX3JpZ2h0TW9zdENvb3JkLnggPiBncmFwaC5fcmlnaHRNb3N0Q29vcmQueCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9lbnYgPT09IG51bGwpIHtcbiAgICB2YXIgZWRnZUVudiA9IG5ldyBFbnZlbG9wZSgpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRpckVkZ2UgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgcHRzID0gZGlyRWRnZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBlZGdlRW52LmV4cGFuZFRvSW5jbHVkZShwdHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lbnYgPSBlZGdlRW52O1xuICB9XG4gIHJldHVybiB0aGlzLl9lbnZcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuYWRkUmVhY2hhYmxlID0gZnVuY3Rpb24gYWRkUmVhY2hhYmxlIChzdGFydE5vZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZVN0YWNrID0gbmV3IFN0YWNrKCk7XG4gIG5vZGVTdGFjay5hZGQoc3RhcnROb2RlKTtcbiAgd2hpbGUgKCFub2RlU3RhY2suZW1wdHkoKSkge1xuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMkMS5hZGQobm9kZSwgbm9kZVN0YWNrKTtcbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb3B5U3ltRGVwdGhzID0gZnVuY3Rpb24gY29weVN5bURlcHRocyAoZGUpIHtcbiAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICBzeW0uc2V0RGVwdGgoUG9zaXRpb24uTEVGVCwgZGUuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpKTtcbiAgc3ltLnNldERlcHRoKFBvc2l0aW9uLlJJR0hULCBkZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKSk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobm9kZSwgbm9kZVN0YWNrKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgbm9kZS5zZXRWaXNpdGVkKHRydWUpO1xuICB0aGlzLl9ub2Rlcy5hZGQobm9kZSk7XG4gIGZvciAodmFyIGkgPSBub2RlLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgdGhpcyQxLl9kaXJFZGdlTGlzdC5hZGQoZGUpO1xuICAgIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgICB2YXIgc3ltTm9kZSA9IHN5bS5nZXROb2RlKCk7XG4gICAgaWYgKCFzeW1Ob2RlLmlzVmlzaXRlZCgpKSB7IG5vZGVTdGFjay5wdXNoKHN5bU5vZGUpOyB9XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiBnZXROb2RlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlc1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gZ2V0RGlyZWN0ZWRFZGdlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXJFZGdlTGlzdFxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlclN1YmdyYXBoXG59O1xuXG52YXIgVG9wb2xvZ3lMb2NhdGlvbiA9IGZ1bmN0aW9uIFRvcG9sb2d5TG9jYXRpb24gKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChsb2NhdGlvbi5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICB2YXIgb24gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoMSk7XG4gICAgICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSA9IG9uO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVG9wb2xvZ3lMb2NhdGlvbikge1xuICAgICAgdmFyIGdsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGdsLmxvY2F0aW9uLmxlbmd0aCk7XG4gICAgICBpZiAoZ2wgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcyQxLmxvY2F0aW9uW2ldID0gZ2wubG9jYXRpb25baV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBvbiQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciByaWdodCA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLmluaXQoMyk7XG4gICAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl0gPSBvbiQxO1xuICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0gPSBsZWZ0O1xuICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdID0gcmlnaHQ7XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnMgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnMgKGxvY1ZhbHVlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcyQxLmxvY2F0aW9uW2ldID0gbG9jVmFsdWU7XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gIT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldEFsbExvY2F0aW9uc0lmTnVsbCA9IGZ1bmN0aW9uIHNldEFsbExvY2F0aW9uc0lmTnVsbCAobG9jVmFsdWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldID09PSBMb2NhdGlvbi5OT05FKSB7IHRoaXMkMS5sb2NhdGlvbltpXSA9IGxvY1ZhbHVlOyB9XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0xpbmUgPSBmdW5jdGlvbiBpc0xpbmUgKCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGggPT09IDFcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChnbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnbC5sb2NhdGlvbi5sZW5ndGggPiB0aGlzLmxvY2F0aW9uLmxlbmd0aCkge1xuICAgIHZhciBuZXdMb2MgPSBuZXcgQXJyYXkoMykuZmlsbChudWxsKTtcbiAgICBuZXdMb2NbUG9zaXRpb24uT05dID0gdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl07XG4gICAgbmV3TG9jW1Bvc2l0aW9uLkxFRlRdID0gTG9jYXRpb24uTk9ORTtcbiAgICBuZXdMb2NbUG9zaXRpb24uUklHSFRdID0gTG9jYXRpb24uTk9ORTtcbiAgICB0aGlzLmxvY2F0aW9uID0gbmV3TG9jO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gPT09IExvY2F0aW9uLk5PTkUgJiYgaSA8IGdsLmxvY2F0aW9uLmxlbmd0aCkgeyB0aGlzJDEubG9jYXRpb25baV0gPSBnbC5sb2NhdGlvbltpXTsgfVxuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZ2V0TG9jYXRpb25zID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRpb25cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gZmxpcCAoKSB7XG4gIGlmICh0aGlzLmxvY2F0aW9uLmxlbmd0aCA8PSAxKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHRlbXAgPSB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdO1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdID0gdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF07XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdID0gdGVtcDtcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgaWYgKHRoaXMubG9jYXRpb24ubGVuZ3RoID4gMSkgeyBidWYuYXBwZW5kKExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXSkpOyB9XG4gIGJ1Zi5hcHBlbmQoTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSkpO1xuICBpZiAodGhpcy5sb2NhdGlvbi5sZW5ndGggPiAxKSB7IGJ1Zi5hcHBlbmQoTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSkpOyB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldExvY2F0aW9ucyA9IGZ1bmN0aW9uIHNldExvY2F0aW9ucyAob24sIGxlZnQsIHJpZ2h0KSB7XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dID0gb247XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0gPSBsZWZ0O1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSA9IHJpZ2h0O1xufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocG9zSW5kZXgpIHtcbiAgaWYgKHBvc0luZGV4IDwgdGhpcy5sb2NhdGlvbi5sZW5ndGgpIHsgcmV0dXJuIHRoaXMubG9jYXRpb25bcG9zSW5kZXhdIH1cbiAgcmV0dXJuIExvY2F0aW9uLk5PTkVcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0FyZWEgPSBmdW5jdGlvbiBpc0FyZWEgKCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGggPiAxXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNBbnlOdWxsID0gZnVuY3Rpb24gaXNBbnlOdWxsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIHNldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbG9jVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRMb2NhdGlvbihQb3NpdGlvbi5PTiwgbG9jVmFsdWUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbG9jSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvY1ZhbHVlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5sb2NhdGlvbltsb2NJbmRleF0gPSBsb2NWYWx1ZSQxO1xuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKHNpemUpIHtcbiAgdGhpcy5sb2NhdGlvbiA9IG5ldyBBcnJheShzaXplKS5maWxsKG51bGwpO1xuICB0aGlzLnNldEFsbExvY2F0aW9ucyhMb2NhdGlvbi5OT05FKTtcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0VxdWFsT25TaWRlID0gZnVuY3Rpb24gaXNFcXVhbE9uU2lkZSAobGUsIGxvY0luZGV4KSB7XG4gIHJldHVybiB0aGlzLmxvY2F0aW9uW2xvY0luZGV4XSA9PT0gbGUubG9jYXRpb25bbG9jSW5kZXhdXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuYWxsUG9zaXRpb25zRXF1YWwgPSBmdW5jdGlvbiBhbGxQb3NpdGlvbnNFcXVhbCAobG9jKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSAhPT0gbG9jKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUb3BvbG9neUxvY2F0aW9uXG59O1xuXG52YXIgTGFiZWwgPSBmdW5jdGlvbiBMYWJlbCAoKSB7XG4gIHRoaXMuZWx0ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgdmFyIG9uTG9jID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyk7XG4gICAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKG9uTG9jKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExhYmVsKSB7XG4gICAgICB2YXIgbGJsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihsYmwuZWx0WzBdKTtcbiAgICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24obGJsLmVsdFsxXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvbkxvYyQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldExvY2F0aW9uKG9uTG9jJDEpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgb25Mb2MkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGVmdExvYyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcmlnaHRMb2MgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyQyLCBsZWZ0TG9jLCByaWdodExvYyk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyQyLCBsZWZ0TG9jLCByaWdodExvYyk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb25Mb2MkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbGVmdExvYyQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByaWdodExvYyQxID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXgkMV0uc2V0TG9jYXRpb25zKG9uTG9jJDMsIGxlZnRMb2MkMSwgcmlnaHRMb2MkMSk7XG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuZ2V0R2VvbWV0cnlDb3VudCA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5Q291bnQgKCkge1xuICB2YXIgY291bnQgPSAwO1xuICBpZiAoIXRoaXMuZWx0WzBdLmlzTnVsbCgpKSB7IGNvdW50Kys7IH1cbiAgaWYgKCF0aGlzLmVsdFsxXS5pc051bGwoKSkgeyBjb3VudCsrOyB9XG4gIHJldHVybiBjb3VudFxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnMgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnMgKGdlb21JbmRleCwgbG9jYXRpb24pIHtcbiAgdGhpcy5lbHRbZ2VvbUluZGV4XS5zZXRBbGxMb2NhdGlvbnMobG9jYXRpb24pO1xufTtcbkxhYmVsLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc051bGwoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnNJZk51bGwgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnNJZk51bGwgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLCBsb2NhdGlvbik7XG4gICAgdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSwgbG9jYXRpb24pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NhdGlvbiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleF0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKGxvY2F0aW9uJDEpO1xuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmlzTGluZSA9IGZ1bmN0aW9uIGlzTGluZSAoZ2VvbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmlzTGluZSgpXG59O1xuTGFiZWwucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UgKGxibCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5lbHRbaV0gPT09IG51bGwgJiYgbGJsLmVsdFtpXSAhPT0gbnVsbCkge1xuICAgICAgdGhpcyQxLmVsdFtpXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKGxibC5lbHRbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzJDEuZWx0W2ldLm1lcmdlKGxibC5lbHRbaV0pO1xuICAgIH1cbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gZmxpcCAoKSB7XG4gIHRoaXMuZWx0WzBdLmZsaXAoKTtcbiAgdGhpcy5lbHRbMV0uZmxpcCgpO1xufTtcbkxhYmVsLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmdldChQb3NpdGlvbi5PTilcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb3NJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4JDFdLmdldChwb3NJbmRleClcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgaWYgKHRoaXMuZWx0WzBdICE9PSBudWxsKSB7XG4gICAgYnVmLmFwcGVuZCgnQTonKTtcbiAgICBidWYuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmICh0aGlzLmVsdFsxXSAhPT0gbnVsbCkge1xuICAgIGJ1Zi5hcHBlbmQoJyBCOicpO1xuICAgIGJ1Zi5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuTGFiZWwucHJvdG90eXBlLmlzQXJlYSA9IGZ1bmN0aW9uIGlzQXJlYSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpIHx8IHRoaXMuZWx0WzFdLmlzQXJlYSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uaXNBcmVhKClcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0FueU51bGwgPSBmdW5jdGlvbiBpc0FueU51bGwgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc0FueU51bGwoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIHNldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldExvY2F0aW9uKFBvc2l0aW9uLk9OLCBsb2NhdGlvbik7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4JDFdLnNldExvY2F0aW9uKHBvc0luZGV4LCBsb2NhdGlvbiQxKTtcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0VxdWFsT25TaWRlID0gZnVuY3Rpb24gaXNFcXVhbE9uU2lkZSAobGJsLCBzaWRlKSB7XG4gIHJldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKGxibC5lbHRbMF0sIHNpZGUpICYmIHRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUobGJsLmVsdFsxXSwgc2lkZSlcbn07XG5MYWJlbC5wcm90b3R5cGUuYWxsUG9zaXRpb25zRXF1YWwgPSBmdW5jdGlvbiBhbGxQb3NpdGlvbnNFcXVhbCAoZ2VvbUluZGV4LCBsb2MpIHtcbiAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uYWxsUG9zaXRpb25zRXF1YWwobG9jKVxufTtcbkxhYmVsLnByb3RvdHlwZS50b0xpbmUgPSBmdW5jdGlvbiB0b0xpbmUgKGdlb21JbmRleCkge1xuICBpZiAodGhpcy5lbHRbZ2VvbUluZGV4XS5pc0FyZWEoKSkgeyB0aGlzLmVsdFtnZW9tSW5kZXhdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24odGhpcy5lbHRbZ2VvbUluZGV4XS5sb2NhdGlvblswXSk7IH1cbn07XG5MYWJlbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxhYmVsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExhYmVsXG59O1xuTGFiZWwudG9MaW5lTGFiZWwgPSBmdW5jdGlvbiB0b0xpbmVMYWJlbCAobGFiZWwpIHtcbiAgdmFyIGxpbmVMYWJlbCA9IG5ldyBMYWJlbChMb2NhdGlvbi5OT05FKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBsaW5lTGFiZWwuc2V0TG9jYXRpb24oaSwgbGFiZWwuZ2V0TG9jYXRpb24oaSkpO1xuICB9XG4gIHJldHVybiBsaW5lTGFiZWxcbn07XG5cbnZhciBFZGdlUmluZyA9IGZ1bmN0aW9uIEVkZ2VSaW5nICgpIHtcbiAgdGhpcy5fc3RhcnREZSA9IG51bGw7XG4gIHRoaXMuX21heE5vZGVEZWdyZWUgPSAtMTtcbiAgdGhpcy5fZWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3B0cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoTG9jYXRpb24uTk9ORSk7XG4gIHRoaXMuX3JpbmcgPSBudWxsO1xuICB0aGlzLl9pc0hvbGUgPSBudWxsO1xuICB0aGlzLl9zaGVsbCA9IG51bGw7XG4gIHRoaXMuX2hvbGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbiAgdGhpcy5jb21wdXRlUG9pbnRzKHN0YXJ0KTtcbiAgdGhpcy5jb21wdXRlUmluZygpO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5jb21wdXRlUmluZyA9IGZ1bmN0aW9uIGNvbXB1dGVSaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5fcmluZyAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjb29yZCA9IG5ldyBBcnJheSh0aGlzLl9wdHMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3B0cy5zaXplKCk7IGkrKykge1xuICAgIGNvb3JkW2ldID0gdGhpcyQxLl9wdHMuZ2V0KGkpO1xuICB9XG4gIHRoaXMuX3JpbmcgPSB0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb29yZCk7XG4gIHRoaXMuX2lzSG9sZSA9IENHQWxnb3JpdGhtcy5pc0NDVyh0aGlzLl9yaW5nLmdldENvb3JkaW5hdGVzKCkpO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5pc0lzb2xhdGVkID0gZnVuY3Rpb24gaXNJc29sYXRlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPT09IDFcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29tcHV0ZVBvaW50cyA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludHMgKHN0YXJ0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fc3RhcnREZSA9IHN0YXJ0O1xuICB2YXIgZGUgPSBzdGFydDtcbiAgdmFyIGlzRmlyc3RFZGdlID0gdHJ1ZTtcbiAgZG8ge1xuICAgIGlmIChkZSA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ0ZvdW5kIG51bGwgRGlyZWN0ZWRFZGdlJykgfVxuICAgIGlmIChkZS5nZXRFZGdlUmluZygpID09PSB0aGlzJDEpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgJyArIGRlLmdldENvb3JkaW5hdGUoKSkgfVxuICAgIHRoaXMkMS5fZWRnZXMuYWRkKGRlKTtcbiAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgIEFzc2VydC5pc1RydWUobGFiZWwuaXNBcmVhKCkpO1xuICAgIHRoaXMkMS5tZXJnZUxhYmVsKGxhYmVsKTtcbiAgICB0aGlzJDEuYWRkUG9pbnRzKGRlLmdldEVkZ2UoKSwgZGUuaXNGb3J3YXJkKCksIGlzRmlyc3RFZGdlKTtcbiAgICBpc0ZpcnN0RWRnZSA9IGZhbHNlO1xuICAgIHRoaXMkMS5zZXRFZGdlUmluZyhkZSwgdGhpcyQxKTtcbiAgICBkZSA9IHRoaXMkMS5nZXROZXh0KGRlKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldExpbmVhclJpbmcgPSBmdW5jdGlvbiBnZXRMaW5lYXJSaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jpbmdcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0cy5nZXQoaSlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29tcHV0ZU1heE5vZGVEZWdyZWUgPSBmdW5jdGlvbiBjb21wdXRlTWF4Tm9kZURlZ3JlZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fbWF4Tm9kZURlZ3JlZSA9IDA7XG4gIHZhciBkZSA9IHRoaXMuX3N0YXJ0RGU7XG4gIGRvIHtcbiAgICB2YXIgbm9kZSA9IGRlLmdldE5vZGUoKTtcbiAgICB2YXIgZGVncmVlID0gbm9kZS5nZXRFZGdlcygpLmdldE91dGdvaW5nRGVncmVlKHRoaXMkMSk7XG4gICAgaWYgKGRlZ3JlZSA+IHRoaXMkMS5fbWF4Tm9kZURlZ3JlZSkgeyB0aGlzJDEuX21heE5vZGVEZWdyZWUgPSBkZWdyZWU7IH1cbiAgICBkZSA9IHRoaXMkMS5nZXROZXh0KGRlKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG4gIHRoaXMuX21heE5vZGVEZWdyZWUgKj0gMjtcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuYWRkUG9pbnRzID0gZnVuY3Rpb24gYWRkUG9pbnRzIChlZGdlLCBpc0ZvcndhcmQsIGlzRmlyc3RFZGdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVkZ2VQdHMgPSBlZGdlLmdldENvb3JkaW5hdGVzKCk7XG4gIGlmIChpc0ZvcndhcmQpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDE7XG4gICAgaWYgKGlzRmlyc3RFZGdlKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlZGdlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzJDEuX3B0cy5hZGQoZWRnZVB0c1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzdGFydEluZGV4JDEgPSBlZGdlUHRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKGlzRmlyc3RFZGdlKSB7IHN0YXJ0SW5kZXgkMSA9IGVkZ2VQdHMubGVuZ3RoIC0gMTsgfVxuICAgIGZvciAodmFyIGkkMSA9IHN0YXJ0SW5kZXgkMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB0aGlzJDEuX3B0cy5hZGQoZWRnZVB0c1tpJDFdKTtcbiAgICB9XG4gIH1cbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaXNIb2xlID0gZnVuY3Rpb24gaXNIb2xlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSG9sZVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5zZXRJblJlc3VsdCA9IGZ1bmN0aW9uIHNldEluUmVzdWx0ICgpIHtcbiAgdmFyIGRlID0gdGhpcy5fc3RhcnREZTtcbiAgZG8ge1xuICAgIGRlLmdldEVkZ2UoKS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgICBkZSA9IGRlLmdldE5leHQoKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50IChwKSB7XG4gIHZhciBzaGVsbCA9IHRoaXMuZ2V0TGluZWFyUmluZygpO1xuICB2YXIgZW52ID0gc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICBpZiAoIWVudi5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIUNHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nKHAsIHNoZWxsLmdldENvb3JkaW5hdGVzKCkpKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSB0aGlzLl9ob2xlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgaG9sZSA9IGkubmV4dCgpO1xuICAgIGlmIChob2xlLmNvbnRhaW5zUG9pbnQocCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24gYWRkSG9sZSAocmluZykge1xuICB0aGlzLl9ob2xlcy5hZGQocmluZyk7XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmlzU2hlbGwgPSBmdW5jdGlvbiBpc1NoZWxsICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NoZWxsID09PSBudWxsXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWxcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlc1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRNYXhOb2RlRGVncmVlID0gZnVuY3Rpb24gZ2V0TWF4Tm9kZURlZ3JlZSAoKSB7XG4gIGlmICh0aGlzLl9tYXhOb2RlRGVncmVlIDwgMCkgeyB0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCk7IH1cbiAgcmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWVcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0U2hlbGwgPSBmdW5jdGlvbiBnZXRTaGVsbCAoKSB7XG4gIHJldHVybiB0aGlzLl9zaGVsbFxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5tZXJnZUxhYmVsID0gZnVuY3Rpb24gbWVyZ2VMYWJlbCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRlTGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5tZXJnZUxhYmVsKGRlTGFiZWwsIDApO1xuICAgIHRoaXMubWVyZ2VMYWJlbChkZUxhYmVsLCAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlTGFiZWwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2MgPSBkZUxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCk7XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCkgPT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICAgIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGdlb21JbmRleCwgbG9jKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLnNldFNoZWxsID0gZnVuY3Rpb24gc2V0U2hlbGwgKHNoZWxsKSB7XG4gIHRoaXMuX3NoZWxsID0gc2hlbGw7XG4gIGlmIChzaGVsbCAhPT0gbnVsbCkgeyBzaGVsbC5hZGRIb2xlKHRoaXMpOyB9XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLnRvUG9seWdvbiA9IGZ1bmN0aW9uIHRvUG9seWdvbiAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGhvbGVMUiA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMuc2l6ZSgpOyBpKyspIHtcbiAgICBob2xlTFJbaV0gPSB0aGlzJDEuX2hvbGVzLmdldChpKS5nZXRMaW5lYXJSaW5nKCk7XG4gIH1cbiAgdmFyIHBvbHkgPSBnZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSwgaG9sZUxSKTtcbiAgcmV0dXJuIHBvbHlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VSaW5nXG59O1xuXG52YXIgTWluaW1hbEVkZ2VSaW5nID0gKGZ1bmN0aW9uIChFZGdlUmluZyQkMSkge1xuICBmdW5jdGlvbiBNaW5pbWFsRWRnZVJpbmcgKCkge1xuICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICAgIEVkZ2VSaW5nJCQxLmNhbGwodGhpcywgc3RhcnQsIGdlb21ldHJ5RmFjdG9yeSk7XG4gIH1cblxuICBpZiAoIEVkZ2VSaW5nJCQxICkgTWluaW1hbEVkZ2VSaW5nLl9fcHJvdG9fXyA9IEVkZ2VSaW5nJCQxO1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZVJpbmckJDEgJiYgRWRnZVJpbmckJDEucHJvdG90eXBlICk7XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaW5pbWFsRWRnZVJpbmc7XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZGUsIGVyKSB7XG4gICAgZGUuc2V0TWluRWRnZVJpbmcoZXIpO1xuICB9O1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiBnZXROZXh0IChkZSkge1xuICAgIHJldHVybiBkZS5nZXROZXh0TWluKClcbiAgfTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTWluaW1hbEVkZ2VSaW5nXG4gIH07XG5cbiAgcmV0dXJuIE1pbmltYWxFZGdlUmluZztcbn0oRWRnZVJpbmcpKTtcblxudmFyIE1heGltYWxFZGdlUmluZyA9IChmdW5jdGlvbiAoRWRnZVJpbmckJDEpIHtcbiAgZnVuY3Rpb24gTWF4aW1hbEVkZ2VSaW5nICgpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBFZGdlUmluZyQkMS5jYWxsKHRoaXMsIHN0YXJ0LCBnZW9tZXRyeUZhY3RvcnkpO1xuICB9XG5cbiAgaWYgKCBFZGdlUmluZyQkMSApIE1heGltYWxFZGdlUmluZy5fX3Byb3RvX18gPSBFZGdlUmluZyQkMTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VSaW5nJCQxICYmIEVkZ2VSaW5nJCQxLnByb3RvdHlwZSApO1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWF4aW1hbEVkZ2VSaW5nO1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmJ1aWxkTWluaW1hbFJpbmdzID0gZnVuY3Rpb24gYnVpbGRNaW5pbWFsUmluZ3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1pbkVkZ2VSaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICAgIGRvIHtcbiAgICAgIGlmIChkZS5nZXRNaW5FZGdlUmluZygpID09PSBudWxsKSB7XG4gICAgICAgIHZhciBtaW5FciA9IG5ldyBNaW5pbWFsRWRnZVJpbmcoZGUsIHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5KTtcbiAgICAgICAgbWluRWRnZVJpbmdzLmFkZChtaW5Fcik7XG4gICAgICB9XG4gICAgICBkZSA9IGRlLmdldE5leHQoKTtcbiAgICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbiAgICByZXR1cm4gbWluRWRnZVJpbmdzXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZGUsIGVyKSB7XG4gICAgZGUuc2V0RWRnZVJpbmcoZXIpO1xuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICAgIGRvIHtcbiAgICAgIHZhciBub2RlID0gZGUuZ2V0Tm9kZSgpO1xuICAgICAgbm9kZS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzJDEpO1xuICAgICAgZGUgPSBkZS5nZXROZXh0KCk7XG4gICAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uIGdldE5leHQgKGRlKSB7XG4gICAgcmV0dXJuIGRlLmdldE5leHQoKVxuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNYXhpbWFsRWRnZVJpbmdcbiAgfTtcblxuICByZXR1cm4gTWF4aW1hbEVkZ2VSaW5nO1xufShFZGdlUmluZykpO1xuXG52YXIgR3JhcGhDb21wb25lbnQgPSBmdW5jdGlvbiBHcmFwaENvbXBvbmVudCAoKSB7XG4gIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgdGhpcy5faXNJblJlc3VsdCA9IGZhbHNlO1xuICB0aGlzLl9pc0NvdmVyZWQgPSBmYWxzZTtcbiAgdGhpcy5faXNDb3ZlcmVkU2V0ID0gZmFsc2U7XG4gIHRoaXMuX2lzVmlzaXRlZCA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICB9XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldFZpc2l0ZWQgPSBmdW5jdGlvbiBzZXRWaXNpdGVkIChpc1Zpc2l0ZWQpIHtcbiAgdGhpcy5faXNWaXNpdGVkID0gaXNWaXNpdGVkO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRJblJlc3VsdCA9IGZ1bmN0aW9uIHNldEluUmVzdWx0IChpc0luUmVzdWx0KSB7XG4gIHRoaXMuX2lzSW5SZXN1bHQgPSBpc0luUmVzdWx0O1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc0NvdmVyZWQgPSBmdW5jdGlvbiBpc0NvdmVyZWQgKCkge1xuICByZXR1cm4gdGhpcy5faXNDb3ZlcmVkXG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzQ292ZXJlZFNldCA9IGZ1bmN0aW9uIGlzQ292ZXJlZFNldCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0NvdmVyZWRTZXRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbiBzZXRMYWJlbCAobGFiZWwpIHtcbiAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb3ZlcmVkID0gZnVuY3Rpb24gc2V0Q292ZXJlZCAoaXNDb3ZlcmVkKSB7XG4gIHRoaXMuX2lzQ292ZXJlZCA9IGlzQ292ZXJlZDtcbiAgdGhpcy5faXNDb3ZlcmVkU2V0ID0gdHJ1ZTtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSU0gPSBmdW5jdGlvbiB1cGRhdGVJTSAoaW0pIHtcbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPj0gMiwgJ2ZvdW5kIHBhcnRpYWwgbGFiZWwnKTtcbiAgdGhpcy5jb21wdXRlSU0oaW0pO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc0luUmVzdWx0ID0gZnVuY3Rpb24gaXNJblJlc3VsdCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0luUmVzdWx0XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaXRlZCA9IGZ1bmN0aW9uIGlzVmlzaXRlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc1Zpc2l0ZWRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdyYXBoQ29tcG9uZW50XG59O1xuXG52YXIgTm9kZSA9IChmdW5jdGlvbiAoR3JhcGhDb21wb25lbnQkJDEpIHtcbiAgZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgR3JhcGhDb21wb25lbnQkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9jb29yZCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZXMgPSBudWxsO1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fY29vcmQgPSBjb29yZDtcbiAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKDAsIExvY2F0aW9uLk5PTkUpO1xuICB9XG5cbiAgaWYgKCBHcmFwaENvbXBvbmVudCQkMSApIE5vZGUuX19wcm90b19fID0gR3JhcGhDb21wb25lbnQkJDE7XG4gIE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR3JhcGhDb21wb25lbnQkJDEgJiYgR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlICk7XG4gIE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZTtcbiAgTm9kZS5wcm90b3R5cGUuaXNJbmNpZGVudEVkZ2VJblJlc3VsdCA9IGZ1bmN0aW9uIGlzSW5jaWRlbnRFZGdlSW5SZXN1bHQgKCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgaWYgKGRlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuaXNJc29sYXRlZCA9IGZ1bmN0aW9uIGlzSXNvbGF0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPT09IDFcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZFxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICBvdXQucHJpbnRsbignbm9kZSAnICsgdGhpcy5fY29vcmQgKyAnIGxibDogJyArIHRoaXMuX2xhYmVsKTtcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuY29tcHV0ZUlNID0gZnVuY3Rpb24gY29tcHV0ZUlNIChpbSkge307XG4gIE5vZGUucHJvdG90eXBlLmNvbXB1dGVNZXJnZWRMb2NhdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVNZXJnZWRMb2NhdGlvbiAobGFiZWwyLCBlbHRJbmRleCkge1xuICAgIHZhciBsb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGxvYyA9IHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGVsdEluZGV4KTtcbiAgICBpZiAoIWxhYmVsMi5pc051bGwoZWx0SW5kZXgpKSB7XG4gICAgICB2YXIgbkxvYyA9IGxhYmVsMi5nZXRMb2NhdGlvbihlbHRJbmRleCk7XG4gICAgICBpZiAobG9jICE9PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBsb2MgPSBuTG9jOyB9XG4gICAgfVxuICAgIHJldHVybiBsb2NcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbiBzZXRMYWJlbCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBvbkxvY2F0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHRoaXMuX2xhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7IHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTsgfVxuICAgIH0gZWxzZSB7IHJldHVybiBHcmFwaENvbXBvbmVudCQkMS5wcm90b3R5cGUuc2V0TGFiZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGdlc1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5tZXJnZUxhYmVsID0gZnVuY3Rpb24gbWVyZ2VMYWJlbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLm1lcmdlTGFiZWwobi5fbGFiZWwpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbDIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gdGhpcyQxLmNvbXB1dGVNZXJnZWRMb2NhdGlvbihsYWJlbDIsIGkpO1xuICAgICAgICB2YXIgdGhpc0xvYyA9IHRoaXMkMS5fbGFiZWwuZ2V0TG9jYXRpb24oaSk7XG4gICAgICAgIGlmICh0aGlzTG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHRoaXMkMS5fbGFiZWwuc2V0TG9jYXRpb24oaSwgbG9jKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gICAgdGhpcy5fZWRnZXMuaW5zZXJ0KGUpO1xuICAgIGUuc2V0Tm9kZSh0aGlzKTtcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuc2V0TGFiZWxCb3VuZGFyeSA9IGZ1bmN0aW9uIHNldExhYmVsQm91bmRhcnkgKGFyZ0luZGV4KSB7XG4gICAgaWYgKHRoaXMuX2xhYmVsID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICBpZiAodGhpcy5fbGFiZWwgIT09IG51bGwpIHsgbG9jID0gdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oYXJnSW5kZXgpOyB9XG4gICAgdmFyIG5ld0xvYyA9IG51bGw7XG4gICAgc3dpdGNoIChsb2MpIHtcbiAgICAgIGNhc2UgTG9jYXRpb24uQk9VTkRBUlk6XG4gICAgICAgIG5ld0xvYyA9IExvY2F0aW9uLklOVEVSSU9SO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBMb2NhdGlvbi5JTlRFUklPUjpcbiAgICAgICAgbmV3TG9jID0gTG9jYXRpb24uQk9VTkRBUlk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXdMb2MgPSBMb2NhdGlvbi5CT1VOREFSWTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG5ld0xvYyk7XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTm9kZVxuICB9O1xuXG4gIHJldHVybiBOb2RlO1xufShHcmFwaENvbXBvbmVudCkpO1xuXG52YXIgTm9kZU1hcCA9IGZ1bmN0aW9uIE5vZGVNYXAgKCkge1xuICB0aGlzLm5vZGVNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICB0aGlzLm5vZGVGYWN0ID0gbnVsbDtcbiAgdmFyIG5vZGVGYWN0ID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLm5vZGVGYWN0ID0gbm9kZUZhY3Q7XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKGNvb3JkKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAuZ2V0KGNvb3JkKVxufTtcbk5vZGVNYXAucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiBhZGROb2RlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXAuZ2V0KGNvb3JkKTtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgbm9kZSA9IHRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZShjb29yZCk7XG4gICAgICB0aGlzLm5vZGVNYXAucHV0KGNvb3JkLCBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMubm9kZU1hcC5nZXQobi5nZXRDb29yZGluYXRlKCkpO1xuICAgIGlmIChub2RlJDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZU1hcC5wdXQobi5nZXRDb29yZGluYXRlKCksIG4pO1xuICAgICAgcmV0dXJuIG5cbiAgICB9XG4gICAgbm9kZSQxLm1lcmdlTGFiZWwobik7XG4gICAgcmV0dXJuIG5vZGUkMVxuICB9XG59O1xuTm9kZU1hcC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG4gPSBpdC5uZXh0KCk7XG4gICAgbi5wcmludChvdXQpO1xuICB9XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKVxufTtcbk5vZGVNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKClcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5nZXRCb3VuZGFyeU5vZGVzID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlOb2RlcyAoZ2VvbUluZGV4KSB7XG4gIHZhciBiZHlOb2RlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBpLm5leHQoKTtcbiAgICBpZiAobm9kZS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGdlb21JbmRleCkgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGJkeU5vZGVzLmFkZChub2RlKTsgfVxuICB9XG4gIHJldHVybiBiZHlOb2Rlc1xufTtcbk5vZGVNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICB2YXIgcCA9IGUuZ2V0Q29vcmRpbmF0ZSgpO1xuICB2YXIgbiA9IHRoaXMuYWRkTm9kZShwKTtcbiAgbi5hZGQoZSk7XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVNYXAucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZU1hcFxufTtcblxudmFyIFF1YWRyYW50ID0gZnVuY3Rpb24gUXVhZHJhbnQgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjEgPSB7IE5FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5XOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNXOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblF1YWRyYW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUXVhZHJhbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUXVhZHJhbnRcbn07XG5RdWFkcmFudC5pc05vcnRoZXJuID0gZnVuY3Rpb24gaXNOb3J0aGVybiAocXVhZCkge1xuICByZXR1cm4gcXVhZCA9PT0gUXVhZHJhbnQuTkUgfHwgcXVhZCA9PT0gUXVhZHJhbnQuTldcbn07XG5RdWFkcmFudC5pc09wcG9zaXRlID0gZnVuY3Rpb24gaXNPcHBvc2l0ZSAocXVhZDEsIHF1YWQyKSB7XG4gIGlmIChxdWFkMSA9PT0gcXVhZDIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGRpZmYgPSAocXVhZDEgLSBxdWFkMiArIDQpICUgNDtcbiAgaWYgKGRpZmYgPT09IDIpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5RdWFkcmFudC5jb21tb25IYWxmUGxhbmUgPSBmdW5jdGlvbiBjb21tb25IYWxmUGxhbmUgKHF1YWQxLCBxdWFkMikge1xuICBpZiAocXVhZDEgPT09IHF1YWQyKSB7IHJldHVybiBxdWFkMSB9XG4gIHZhciBkaWZmID0gKHF1YWQxIC0gcXVhZDIgKyA0KSAlIDQ7XG4gIGlmIChkaWZmID09PSAyKSB7IHJldHVybiAtMSB9XG4gIHZhciBtaW4gPSBxdWFkMSA8IHF1YWQyID8gcXVhZDEgOiBxdWFkMjtcbiAgdmFyIG1heCA9IHF1YWQxID4gcXVhZDIgPyBxdWFkMSA6IHF1YWQyO1xuICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMykgeyByZXR1cm4gMyB9XG4gIHJldHVybiBtaW5cbn07XG5RdWFkcmFudC5pc0luSGFsZlBsYW5lID0gZnVuY3Rpb24gaXNJbkhhbGZQbGFuZSAocXVhZCwgaGFsZlBsYW5lKSB7XG4gIGlmIChoYWxmUGxhbmUgPT09IFF1YWRyYW50LlNFKSB7XG4gICAgcmV0dXJuIHF1YWQgPT09IFF1YWRyYW50LlNFIHx8IHF1YWQgPT09IFF1YWRyYW50LlNXXG4gIH1cbiAgcmV0dXJuIHF1YWQgPT09IGhhbGZQbGFuZSB8fCBxdWFkID09PSBoYWxmUGxhbmUgKyAxXG59O1xuUXVhZHJhbnQucXVhZHJhbnQgPSBmdW5jdGlvbiBxdWFkcmFudCAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHZhciBkeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGR4ID09PSAwLjAgJiYgZHkgPT09IDAuMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHBvaW50ICggJyArIGR4ICsgJywgJyArIGR5ICsgJyApJykgfVxuICAgIGlmIChkeCA+PSAwLjApIHtcbiAgICAgIGlmIChkeSA+PSAwLjApIHsgcmV0dXJuIFF1YWRyYW50Lk5FOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU0UgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHkgPj0gMC4wKSB7IHJldHVybiBRdWFkcmFudC5OVzsgfSBlbHNlIHsgcmV0dXJuIFF1YWRyYW50LlNXIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAocDEueCA9PT0gcDAueCAmJiBwMS55ID09PSBwMC55KSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgJyArIHAwKSB9XG4gICAgaWYgKHAxLnggPj0gcDAueCkge1xuICAgICAgaWYgKHAxLnkgPj0gcDAueSkgeyByZXR1cm4gUXVhZHJhbnQuTkU7IH0gZWxzZSB7IHJldHVybiBRdWFkcmFudC5TRSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwMS55ID49IHAwLnkpIHsgcmV0dXJuIFF1YWRyYW50Lk5XOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU1cgfVxuICAgIH1cbiAgfVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjEuTlcuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDIxLlNXLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5TRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBRdWFkcmFudCwgc3RhdGljQWNjZXNzb3JzJDIxICk7XG5cbnZhciBFZGdlRW5kID0gZnVuY3Rpb24gRWRnZUVuZCAoKSB7XG4gIHRoaXMuX2VkZ2UgPSBudWxsO1xuICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gIHRoaXMuX25vZGUgPSBudWxsO1xuICB0aGlzLl9wMCA9IG51bGw7XG4gIHRoaXMuX3AxID0gbnVsbDtcbiAgdGhpcy5fZHggPSBudWxsO1xuICB0aGlzLl9keSA9IG51bGw7XG4gIHRoaXMuX3F1YWRyYW50ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9lZGdlID0gZWRnZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGVkZ2UkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBsYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZSA9IGVkZ2UkMTtcbiAgICB0aGlzLmluaXQocDAsIHAxKTtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZWRnZSQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBsYWJlbCQxID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuX2VkZ2UgPSBlZGdlJDI7XG4gICAgdGhpcy5pbml0KHAwJDEsIHAxJDEpO1xuICAgIHRoaXMuX2xhYmVsID0gbGFiZWwkMTtcbiAgfVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmNvbXBhcmVEaXJlY3Rpb24gPSBmdW5jdGlvbiBjb21wYXJlRGlyZWN0aW9uIChlKSB7XG4gIGlmICh0aGlzLl9keCA9PT0gZS5fZHggJiYgdGhpcy5fZHkgPT09IGUuX2R5KSB7IHJldHVybiAwIH1cbiAgaWYgKHRoaXMuX3F1YWRyYW50ID4gZS5fcXVhZHJhbnQpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fcXVhZHJhbnQgPCBlLl9xdWFkcmFudCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihlLl9wMCwgZS5fcDEsIHRoaXMuX3AxKVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldER5ID0gZnVuY3Rpb24gZ2V0RHkgKCkge1xuICByZXR1cm4gdGhpcy5fZHlcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wMFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbiBzZXROb2RlIChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xufTtcbkVkZ2VFbmQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuX2R5LCB0aGlzLl9keCk7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpO1xuICB2YXIgbGFzdERvdFBvcyA9IGNsYXNzTmFtZS5sYXN0SW5kZXhPZignLicpO1xuICB2YXIgbmFtZSA9IGNsYXNzTmFtZS5zdWJzdHJpbmcobGFzdERvdFBvcyArIDEpO1xuICBvdXQucHJpbnQoJyAgJyArIG5hbWUgKyAnOiAnICsgdGhpcy5fcDAgKyAnIC0gJyArIHRoaXMuX3AxICsgJyAnICsgdGhpcy5fcXVhZHJhbnQgKyAnOicgKyBhbmdsZSArICcgICAnICsgdGhpcy5fbGFiZWwpO1xufTtcbkVkZ2VFbmQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBlID0gb2JqO1xuICByZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RGlyZWN0ZWRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0RGlyZWN0ZWRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3AxXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RHggPSBmdW5jdGlvbiBnZXREeCAoKSB7XG4gIHJldHVybiB0aGlzLl9keFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWxcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0UXVhZHJhbnQgPSBmdW5jdGlvbiBnZXRRdWFkcmFudCAoKSB7XG4gIHJldHVybiB0aGlzLl9xdWFkcmFudFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVcbn07XG5FZGdlRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLl9keSwgdGhpcy5fZHgpO1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKTtcbiAgdmFyIGxhc3REb3RQb3MgPSBjbGFzc05hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgdmFyIG5hbWUgPSBjbGFzc05hbWUuc3Vic3RyaW5nKGxhc3REb3RQb3MgKyAxKTtcbiAgcmV0dXJuICcgICcgKyBuYW1lICsgJzogJyArIHRoaXMuX3AwICsgJyAtICcgKyB0aGlzLl9wMSArICcgJyArIHRoaXMuX3F1YWRyYW50ICsgJzonICsgYW5nbGUgKyAnICAgJyArIHRoaXMuX2xhYmVsXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsIChib3VuZGFyeU5vZGVSdWxlKSB7fTtcbkVkZ2VFbmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChwMCwgcDEpIHtcbiAgdGhpcy5fcDAgPSBwMDtcbiAgdGhpcy5fcDEgPSBwMTtcbiAgdGhpcy5fZHggPSBwMS54IC0gcDAueDtcbiAgdGhpcy5fZHkgPSBwMS55IC0gcDAueTtcbiAgdGhpcy5fcXVhZHJhbnQgPSBRdWFkcmFudC5xdWFkcmFudCh0aGlzLl9keCwgdGhpcy5fZHkpO1xuICBBc3NlcnQuaXNUcnVlKCEodGhpcy5fZHggPT09IDAgJiYgdGhpcy5fZHkgPT09IDApLCAnRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmQnKTtcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUVuZFxufTtcblxudmFyIERpcmVjdGVkRWRnZSA9IChmdW5jdGlvbiAoRWRnZUVuZCQkMSkge1xuICBmdW5jdGlvbiBEaXJlY3RlZEVkZ2UgKCkge1xuICAgIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpc0ZvcndhcmQgPSBhcmd1bWVudHNbMV07XG4gICAgRWRnZUVuZCQkMS5jYWxsKHRoaXMsIGVkZ2UpO1xuICAgIHRoaXMuX2lzRm9yd2FyZCA9IG51bGw7XG4gICAgdGhpcy5faXNJblJlc3VsdCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVmlzaXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N5bSA9IG51bGw7XG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fbmV4dE1pbiA9IG51bGw7XG4gICAgdGhpcy5fZWRnZVJpbmcgPSBudWxsO1xuICAgIHRoaXMuX21pbkVkZ2VSaW5nID0gbnVsbDtcbiAgICB0aGlzLl9kZXB0aCA9IFswLCAtOTk5LCAtOTk5XTtcbiAgICB0aGlzLl9pc0ZvcndhcmQgPSBpc0ZvcndhcmQ7XG4gICAgaWYgKGlzRm9yd2FyZCkge1xuICAgICAgdGhpcy5pbml0KGVkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwgZWRnZS5nZXRDb29yZGluYXRlKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG4gPSBlZGdlLmdldE51bVBvaW50cygpIC0gMTtcbiAgICAgIHRoaXMuaW5pdChlZGdlLmdldENvb3JkaW5hdGUobiksIGVkZ2UuZ2V0Q29vcmRpbmF0ZShuIC0gMSkpO1xuICAgIH1cbiAgICB0aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCk7XG4gIH1cblxuICBpZiAoIEVkZ2VFbmQkJDEgKSBEaXJlY3RlZEVkZ2UuX19wcm90b19fID0gRWRnZUVuZCQkMTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VFbmQkJDEgJiYgRWRnZUVuZCQkMS5wcm90b3R5cGUgKTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGVkRWRnZTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXROZXh0TWluID0gZnVuY3Rpb24gZ2V0TmV4dE1pbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRNaW5cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFtwb3NpdGlvbl1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRWaXNpdGVkID0gZnVuY3Rpb24gc2V0VmlzaXRlZCAoaXNWaXNpdGVkKSB7XG4gICAgdGhpcy5faXNWaXNpdGVkID0gaXNWaXNpdGVkO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmNvbXB1dGVEaXJlY3RlZExhYmVsID0gZnVuY3Rpb24gY29tcHV0ZURpcmVjdGVkTGFiZWwgKCkge1xuICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKHRoaXMuX2VkZ2UuZ2V0TGFiZWwoKSk7XG4gICAgaWYgKCF0aGlzLl9pc0ZvcndhcmQpIHsgdGhpcy5fbGFiZWwuZmxpcCgpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uIGdldE5leHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aCAocG9zaXRpb24sIGRlcHRoVmFsKSB7XG4gICAgaWYgKHRoaXMuX2RlcHRoW3Bvc2l0aW9uXSAhPT0gLTk5OSkge1xuICAgICAgaWYgKHRoaXMuX2RlcHRoW3Bvc2l0aW9uXSAhPT0gZGVwdGhWYWwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoJywgdGhpcy5nZXRDb29yZGluYXRlKCkpIH1cbiAgICB9XG4gICAgdGhpcy5fZGVwdGhbcG9zaXRpb25dID0gZGVwdGhWYWw7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNJbnRlcmlvckFyZWFFZGdlID0gZnVuY3Rpb24gaXNJbnRlcmlvckFyZWFFZGdlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpc0ludGVyaW9yQXJlYUVkZ2UgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBpZiAoISh0aGlzJDEuX2xhYmVsLmlzQXJlYShpKSAmJiB0aGlzJDEuX2xhYmVsLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQpID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiB0aGlzJDEuX2xhYmVsLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLlJJR0hUKSA9PT0gTG9jYXRpb24uSU5URVJJT1IpKSB7XG4gICAgICAgIGlzSW50ZXJpb3JBcmVhRWRnZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNJbnRlcmlvckFyZWFFZGdlXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TmV4dE1pbiA9IGZ1bmN0aW9uIHNldE5leHRNaW4gKG5leHRNaW4pIHtcbiAgICB0aGlzLl9uZXh0TWluID0gbmV4dE1pbjtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICBFZGdlRW5kJCQxLnByb3RvdHlwZS5wcmludC5jYWxsKHRoaXMsIG91dCk7XG4gICAgb3V0LnByaW50KCcgJyArIHRoaXMuX2RlcHRoW1Bvc2l0aW9uLkxFRlRdICsgJy8nICsgdGhpcy5fZGVwdGhbUG9zaXRpb24uUklHSFRdKTtcbiAgICBvdXQucHJpbnQoJyAoJyArIHRoaXMuZ2V0RGVwdGhEZWx0YSgpICsgJyknKTtcbiAgICBpZiAodGhpcy5faXNJblJlc3VsdCkgeyBvdXQucHJpbnQoJyBpblJlc3VsdCcpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TWluRWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRNaW5FZGdlUmluZyAobWluRWRnZVJpbmcpIHtcbiAgICB0aGlzLl9taW5FZGdlUmluZyA9IG1pbkVkZ2VSaW5nO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzTGluZUVkZ2UgPSBmdW5jdGlvbiBpc0xpbmVFZGdlICgpIHtcbiAgICB2YXIgaXNMaW5lID0gdGhpcy5fbGFiZWwuaXNMaW5lKDApIHx8IHRoaXMuX2xhYmVsLmlzTGluZSgxKTtcbiAgICB2YXIgaXNFeHRlcmlvcklmQXJlYTAgPSAhdGhpcy5fbGFiZWwuaXNBcmVhKDApIHx8IHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgICB2YXIgaXNFeHRlcmlvcklmQXJlYTEgPSAhdGhpcy5fbGFiZWwuaXNBcmVhKDEpIHx8IHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgICByZXR1cm4gaXNMaW5lICYmIGlzRXh0ZXJpb3JJZkFyZWEwICYmIGlzRXh0ZXJpb3JJZkFyZWExXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZWRnZVJpbmcpIHtcbiAgICB0aGlzLl9lZGdlUmluZyA9IGVkZ2VSaW5nO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldE1pbkVkZ2VSaW5nID0gZnVuY3Rpb24gZ2V0TWluRWRnZVJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5FZGdlUmluZ1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldERlcHRoRGVsdGEgPSBmdW5jdGlvbiBnZXREZXB0aERlbHRhICgpIHtcbiAgICB2YXIgZGVwdGhEZWx0YSA9IHRoaXMuX2VkZ2UuZ2V0RGVwdGhEZWx0YSgpO1xuICAgIGlmICghdGhpcy5faXNGb3J3YXJkKSB7IGRlcHRoRGVsdGEgPSAtZGVwdGhEZWx0YTsgfVxuICAgIHJldHVybiBkZXB0aERlbHRhXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0SW5SZXN1bHQgPSBmdW5jdGlvbiBzZXRJblJlc3VsdCAoaXNJblJlc3VsdCkge1xuICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBpc0luUmVzdWx0O1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldFN5bSA9IGZ1bmN0aW9uIGdldFN5bSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzRm9yd2FyZCA9IGZ1bmN0aW9uIGlzRm9yd2FyZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRm9yd2FyZFxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRnZVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnByaW50RWRnZSA9IGZ1bmN0aW9uIHByaW50RWRnZSAob3V0KSB7XG4gICAgdGhpcy5wcmludChvdXQpO1xuICAgIG91dC5wcmludCgnICcpO1xuICAgIGlmICh0aGlzLl9pc0ZvcndhcmQpIHsgdGhpcy5fZWRnZS5wcmludChvdXQpOyB9IGVsc2UgeyB0aGlzLl9lZGdlLnByaW50UmV2ZXJzZShvdXQpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0U3ltID0gZnVuY3Rpb24gc2V0U3ltIChkZSkge1xuICAgIHRoaXMuX3N5bSA9IGRlO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldFZpc2l0ZWRFZGdlID0gZnVuY3Rpb24gc2V0VmlzaXRlZEVkZ2UgKGlzVmlzaXRlZCkge1xuICAgIHRoaXMuc2V0VmlzaXRlZChpc1Zpc2l0ZWQpO1xuICAgIHRoaXMuX3N5bS5zZXRWaXNpdGVkKGlzVmlzaXRlZCk7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RWRnZURlcHRocyA9IGZ1bmN0aW9uIHNldEVkZ2VEZXB0aHMgKHBvc2l0aW9uLCBkZXB0aCkge1xuICAgIHZhciBkZXB0aERlbHRhID0gdGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO1xuICAgIGlmICghdGhpcy5faXNGb3J3YXJkKSB7IGRlcHRoRGVsdGEgPSAtZGVwdGhEZWx0YTsgfVxuICAgIHZhciBkaXJlY3Rpb25GYWN0b3IgPSAxO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTEVGVCkgeyBkaXJlY3Rpb25GYWN0b3IgPSAtMTsgfVxuICAgIHZhciBvcHBvc2l0ZVBvcyA9IFBvc2l0aW9uLm9wcG9zaXRlKHBvc2l0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkZXB0aERlbHRhICogZGlyZWN0aW9uRmFjdG9yO1xuICAgIHZhciBvcHBvc2l0ZURlcHRoID0gZGVwdGggKyBkZWx0YTtcbiAgICB0aGlzLnNldERlcHRoKHBvc2l0aW9uLCBkZXB0aCk7XG4gICAgdGhpcy5zZXREZXB0aChvcHBvc2l0ZVBvcywgb3Bwb3NpdGVEZXB0aCk7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBnZXRFZGdlUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkZ2VSaW5nXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNJblJlc3VsdCA9IGZ1bmN0aW9uIGlzSW5SZXN1bHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0luUmVzdWx0XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIHNldE5leHQgKG5leHQpIHtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc1Zpc2l0ZWQgPSBmdW5jdGlvbiBpc1Zpc2l0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Zpc2l0ZWRcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gRGlyZWN0ZWRFZGdlXG4gIH07XG4gIERpcmVjdGVkRWRnZS5kZXB0aEZhY3RvciA9IGZ1bmN0aW9uIGRlcHRoRmFjdG9yIChjdXJyTG9jYXRpb24sIG5leHRMb2NhdGlvbikge1xuICAgIGlmIChjdXJyTG9jYXRpb24gPT09IExvY2F0aW9uLkVYVEVSSU9SICYmIG5leHRMb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIDE7IH0gZWxzZSBpZiAoY3VyckxvY2F0aW9uID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBuZXh0TG9jYXRpb24gPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiAtMSB9XG4gICAgcmV0dXJuIDBcbiAgfTtcblxuICByZXR1cm4gRGlyZWN0ZWRFZGdlO1xufShFZGdlRW5kKSk7XG5cbnZhciBOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIE5vZGVGYWN0b3J5ICgpIHt9O1xuXG5Ob2RlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKGNvb3JkKSB7XG4gIHJldHVybiBuZXcgTm9kZShjb29yZCwgbnVsbClcbn07XG5Ob2RlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVGYWN0b3J5XG59O1xuXG52YXIgUGxhbmFyR3JhcGggPSBmdW5jdGlvbiBQbGFuYXJHcmFwaCAoKSB7XG4gIHRoaXMuX2VkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ub2RlcyA9IG51bGw7XG4gIHRoaXMuX2VkZ2VFbmRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX25vZGVzID0gbmV3IE5vZGVNYXAobmV3IE5vZGVGYWN0b3J5KCkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZUZhY3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbm9kZXMgPSBuZXcgTm9kZU1hcChub2RlRmFjdCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUucHJpbnRFZGdlcyA9IGZ1bmN0aW9uIHByaW50RWRnZXMgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG91dC5wcmludGxuKCdFZGdlczonKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5zaXplKCk7IGkrKykge1xuICAgIG91dC5wcmludGxuKCdlZGdlICcgKyBpICsgJzonKTtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGkpO1xuICAgIGUucHJpbnQob3V0KTtcbiAgICBlLmVpTGlzdC5wcmludChvdXQpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kIChjb29yZCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMuZmluZChjb29yZClcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKG5vZGUpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZShjb29yZClcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXROb2RlSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXROb2RlSXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZGVidWdQcmludGxuID0gZnVuY3Rpb24gZGVidWdQcmludGxuIChvKSB7XG4gIFN5c3RlbS5vdXQucHJpbnRsbihvKTtcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuaXNCb3VuZGFyeU5vZGUgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5Tm9kZSAoZ2VvbUluZGV4LCBjb29yZCkge1xuICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzLmZpbmQoY29vcmQpO1xuICBpZiAobm9kZSA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgbGFiZWwgPSBub2RlLmdldExhYmVsKCk7XG4gIGlmIChsYWJlbCAhPT0gbnVsbCAmJiBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgpID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5saW5rQWxsRGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtBbGxEaXJlY3RlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUubWF0Y2hJblNhbWVEaXJlY3Rpb24gPSBmdW5jdGlvbiBtYXRjaEluU2FtZURpcmVjdGlvbiAocDAsIHAxLCBlcDAsIGVwMSkge1xuICBpZiAoIXAwLmVxdWFscyhlcDApKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHAwLCBwMSwgZXAxKSA9PT0gQ0dBbGdvcml0aG1zLkNPTExJTkVBUiAmJiBRdWFkcmFudC5xdWFkcmFudChwMCwgcDEpID09PSBRdWFkcmFudC5xdWFkcmFudChlcDAsIGVwMSkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZUVuZHMgPSBmdW5jdGlvbiBnZXRFZGdlRW5kcyAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlRW5kTGlzdFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5kZWJ1Z1ByaW50ID0gZnVuY3Rpb24gZGVidWdQcmludCAobykge1xuICBTeXN0ZW0ub3V0LnByaW50KG8pO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXRFZGdlSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRFZGdlSXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kRWRnZUluU2FtZURpcmVjdGlvbiA9IGZ1bmN0aW9uIGZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uIChwMCwgcDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VzLmdldChpKTtcbiAgICB2YXIgZUNvb3JkID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmICh0aGlzJDEubWF0Y2hJblNhbWVEaXJlY3Rpb24ocDAsIHAxLCBlQ29vcmRbMF0sIGVDb29yZFsxXSkpIHsgcmV0dXJuIGUgfVxuICAgIGlmICh0aGlzJDEubWF0Y2hJblNhbWVEaXJlY3Rpb24ocDAsIHAxLCBlQ29vcmRbZUNvb3JkLmxlbmd0aCAtIDFdLCBlQ29vcmRbZUNvb3JkLmxlbmd0aCAtIDJdKSkgeyByZXR1cm4gZSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuaW5zZXJ0RWRnZSA9IGZ1bmN0aW9uIGluc2VydEVkZ2UgKGUpIHtcbiAgdGhpcy5fZWRnZXMuYWRkKGUpO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kRWRnZUVuZCA9IGZ1bmN0aW9uIGZpbmRFZGdlRW5kIChlKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVlID0gaS5uZXh0KCk7XG4gICAgaWYgKGVlLmdldEVkZ2UoKSA9PT0gZSkgeyByZXR1cm4gZWUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmFkZEVkZ2VzID0gZnVuY3Rpb24gYWRkRWRnZXMgKGVkZ2VzVG9BZGQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IGVkZ2VzVG9BZGQuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHRoaXMkMS5fZWRnZXMuYWRkKGUpO1xuICAgIHZhciBkZTEgPSBuZXcgRGlyZWN0ZWRFZGdlKGUsIHRydWUpO1xuICAgIHZhciBkZTIgPSBuZXcgRGlyZWN0ZWRFZGdlKGUsIGZhbHNlKTtcbiAgICBkZTEuc2V0U3ltKGRlMik7XG4gICAgZGUyLnNldFN5bShkZTEpO1xuICAgIHRoaXMkMS5hZGQoZGUxKTtcbiAgICB0aGlzJDEuYWRkKGRlMik7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gIHRoaXMuX25vZGVzLmFkZChlKTtcbiAgdGhpcy5fZWRnZUVuZExpc3QuYWRkKGUpO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uIGdldE5vZGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLnZhbHVlcygpXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmRFZGdlID0gZnVuY3Rpb24gZmluZEVkZ2UgKHAwLCBwMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGkpO1xuICAgIHZhciBlQ29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHAwLmVxdWFscyhlQ29vcmRbMF0pICYmIHAxLmVxdWFscyhlQ29vcmRbMV0pKSB7IHJldHVybiBlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUGxhbmFyR3JhcGhcbn07XG5QbGFuYXJHcmFwaC5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzIChub2Rlcykge1xuICBmb3IgKHZhciBub2RlaXQgPSBub2Rlcy5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICBub2RlLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTtcbiAgfVxufTtcblxudmFyIFBvbHlnb25CdWlsZGVyID0gZnVuY3Rpb24gUG9seWdvbkJ1aWxkZXIgKCkge1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9zaGVsbExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuc29ydFNoZWxsc0FuZEhvbGVzID0gZnVuY3Rpb24gc29ydFNoZWxsc0FuZEhvbGVzIChlZGdlUmluZ3MsIHNoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KSB7XG4gIGZvciAodmFyIGl0ID0gZWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmlzSG9sZSgpKSB7XG4gICAgICBmcmVlSG9sZUxpc3QuYWRkKGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hlbGxMaXN0LmFkZChlcik7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVQb2x5Z29ucyA9IGZ1bmN0aW9uIGNvbXB1dGVQb2x5Z29ucyAoc2hlbGxMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJlc3VsdFBvbHlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpdCA9IHNoZWxsTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIHZhciBwb2x5ID0gZXIudG9Qb2x5Z29uKHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5KTtcbiAgICByZXN1bHRQb2x5TGlzdC5hZGQocG9seSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFBvbHlMaXN0XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLnBsYWNlRnJlZUhvbGVzID0gZnVuY3Rpb24gcGxhY2VGcmVlSG9sZXMgKHNoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSBmcmVlSG9sZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBob2xlID0gaXQubmV4dCgpO1xuICAgIGlmIChob2xlLmdldFNoZWxsKCkgPT09IG51bGwpIHtcbiAgICAgIHZhciBzaGVsbCA9IHRoaXMkMS5maW5kRWRnZVJpbmdDb250YWluaW5nKGhvbGUsIHNoZWxsTGlzdCk7XG4gICAgICBpZiAoc2hlbGwgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCd1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbCcsIGhvbGUuZ2V0Q29vcmRpbmF0ZSgwKSkgfVxuICAgICAgaG9sZS5zZXRTaGVsbChzaGVsbCk7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGJ1aWxkTWluaW1hbEVkZ2VSaW5ncyAobWF4RWRnZVJpbmdzLCBzaGVsbExpc3QsIGZyZWVIb2xlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlZGdlUmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGl0ID0gbWF4RWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmdldE1heE5vZGVEZWdyZWUoKSA+IDIpIHtcbiAgICAgIGVyLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO1xuICAgICAgdmFyIG1pbkVkZ2VSaW5ncyA9IGVyLmJ1aWxkTWluaW1hbFJpbmdzKCk7XG4gICAgICB2YXIgc2hlbGwgPSB0aGlzJDEuZmluZFNoZWxsKG1pbkVkZ2VSaW5ncyk7XG4gICAgICBpZiAoc2hlbGwgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcyQxLnBsYWNlUG9seWdvbkhvbGVzKHNoZWxsLCBtaW5FZGdlUmluZ3MpO1xuICAgICAgICBzaGVsbExpc3QuYWRkKHNoZWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyZWVIb2xlTGlzdC5hZGRBbGwobWluRWRnZVJpbmdzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZVJpbmdzLmFkZChlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZGdlUmluZ3Ncbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQgKHApIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9zaGVsbExpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuY29udGFpbnNQb2ludChwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyAoZGlyRWRnZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbWF4RWRnZVJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpdCA9IGRpckVkZ2VzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGRlLmlzSW5SZXN1bHQoKSAmJiBkZS5nZXRMYWJlbCgpLmlzQXJlYSgpKSB7XG4gICAgICBpZiAoZGUuZ2V0RWRnZVJpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXIgPSBuZXcgTWF4aW1hbEVkZ2VSaW5nKGRlLCB0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeSk7XG4gICAgICAgIG1heEVkZ2VSaW5ncy5hZGQoZXIpO1xuICAgICAgICBlci5zZXRJblJlc3VsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4RWRnZVJpbmdzXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLnBsYWNlUG9seWdvbkhvbGVzID0gZnVuY3Rpb24gcGxhY2VQb2x5Z29uSG9sZXMgKHNoZWxsLCBtaW5FZGdlUmluZ3MpIHtcbiAgZm9yICh2YXIgaXQgPSBtaW5FZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuaXNIb2xlKCkpIHtcbiAgICAgIGVyLnNldFNoZWxsKHNoZWxsKTtcbiAgICB9XG4gIH1cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZ2V0UG9seWdvbnMgPSBmdW5jdGlvbiBnZXRQb2x5Z29ucyAoKSB7XG4gIHZhciByZXN1bHRQb2x5TGlzdCA9IHRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCk7XG4gIHJldHVybiByZXN1bHRQb2x5TGlzdFxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5maW5kRWRnZVJpbmdDb250YWluaW5nID0gZnVuY3Rpb24gZmluZEVkZ2VSaW5nQ29udGFpbmluZyAodGVzdEVyLCBzaGVsbExpc3QpIHtcbiAgdmFyIHRlc3RSaW5nID0gdGVzdEVyLmdldExpbmVhclJpbmcoKTtcbiAgdmFyIHRlc3RFbnYgPSB0ZXN0UmluZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciB0ZXN0UHQgPSB0ZXN0UmluZy5nZXRDb29yZGluYXRlTigwKTtcbiAgdmFyIG1pblNoZWxsID0gbnVsbDtcbiAgdmFyIG1pbkVudiA9IG51bGw7XG4gIGZvciAodmFyIGl0ID0gc2hlbGxMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgdHJ5U2hlbGwgPSBpdC5uZXh0KCk7XG4gICAgdmFyIHRyeVJpbmcgPSB0cnlTaGVsbC5nZXRMaW5lYXJSaW5nKCk7XG4gICAgdmFyIHRyeUVudiA9IHRyeVJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICAgIGlmIChtaW5TaGVsbCAhPT0gbnVsbCkgeyBtaW5FbnYgPSBtaW5TaGVsbC5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpOyB9XG4gICAgdmFyIGlzQ29udGFpbmVkID0gZmFsc2U7XG4gICAgaWYgKHRyeUVudi5jb250YWlucyh0ZXN0RW52KSAmJiBDR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyh0ZXN0UHQsIHRyeVJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSkpIHsgaXNDb250YWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICBpZiAobWluU2hlbGwgPT09IG51bGwgfHwgbWluRW52LmNvbnRhaW5zKHRyeUVudikpIHtcbiAgICAgICAgbWluU2hlbGwgPSB0cnlTaGVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblNoZWxsXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmZpbmRTaGVsbCA9IGZ1bmN0aW9uIGZpbmRTaGVsbCAobWluRWRnZVJpbmdzKSB7XG4gIHZhciBzaGVsbENvdW50ID0gMDtcbiAgdmFyIHNoZWxsID0gbnVsbDtcbiAgZm9yICh2YXIgaXQgPSBtaW5FZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoIWVyLmlzSG9sZSgpKSB7XG4gICAgICBzaGVsbCA9IGVyO1xuICAgICAgc2hlbGxDb3VudCsrO1xuICAgIH1cbiAgfVxuICBBc3NlcnQuaXNUcnVlKHNoZWxsQ291bnQgPD0gMSwgJ2ZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3QnKTtcbiAgcmV0dXJuIHNoZWxsXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdyYXBoID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuYWRkKGdyYXBoLmdldEVkZ2VFbmRzKCksIGdyYXBoLmdldE5vZGVzKCkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGlyRWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGVzID0gYXJndW1lbnRzWzFdO1xuICAgIFBsYW5hckdyYXBoLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKG5vZGVzKTtcbiAgICB2YXIgbWF4RWRnZVJpbmdzID0gdGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3MoZGlyRWRnZXMpO1xuICAgIHZhciBmcmVlSG9sZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdmFyIGVkZ2VSaW5ncyA9IHRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKG1heEVkZ2VSaW5ncywgdGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICAgIHRoaXMuc29ydFNoZWxsc0FuZEhvbGVzKGVkZ2VSaW5ncywgdGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICAgIHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2x5Z29uQnVpbGRlclxufTtcblxudmFyIEJvdW5kYWJsZSA9IGZ1bmN0aW9uIEJvdW5kYWJsZSAoKSB7fTtcblxuQm91bmRhYmxlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMgKCkge307XG5Cb3VuZGFibGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Cb3VuZGFibGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhYmxlXG59O1xuXG52YXIgSXRlbUJvdW5kYWJsZSA9IGZ1bmN0aW9uIEl0ZW1Cb3VuZGFibGUgKCkge1xuICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgdmFyIGJvdW5kcyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcbiAgdGhpcy5faXRlbSA9IGl0ZW07XG59O1xuSXRlbUJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIGdldEl0ZW0gKCkge1xuICByZXR1cm4gdGhpcy5faXRlbVxufTtcbkl0ZW1Cb3VuZGFibGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyAoKSB7XG4gIHJldHVybiB0aGlzLl9ib3VuZHNcbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEl0ZW1Cb3VuZGFibGVcbn07XG5cbnZhciBQcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSAoKSB7XG4gIHRoaXMuX3NpemUgPSBudWxsO1xuICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gIHRoaXMuX3NpemUgPSAwO1xuICB0aGlzLl9pdGVtcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5faXRlbXMuYWRkKG51bGwpO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiBwb2xsICgpIHtcbiAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG1pbkl0ZW0gPSB0aGlzLl9pdGVtcy5nZXQoMSk7XG4gIHRoaXMuX2l0ZW1zLnNldCgxLCB0aGlzLl9pdGVtcy5nZXQodGhpcy5fc2l6ZSkpO1xuICB0aGlzLl9zaXplIC09IDE7XG4gIHRoaXMucmVvcmRlcigxKTtcbiAgcmV0dXJuIG1pbkl0ZW1cbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9zaXplXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVvcmRlciA9IGZ1bmN0aW9uIHJlb3JkZXIgKGhvbGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBudWxsO1xuICB2YXIgdG1wID0gdGhpcy5faXRlbXMuZ2V0KGhvbGUpO1xuICBmb3IgKDsgaG9sZSAqIDIgPD0gdGhpcy5fc2l6ZTsgaG9sZSA9IGNoaWxkKSB7XG4gICAgY2hpbGQgPSBob2xlICogMjtcbiAgICBpZiAoY2hpbGQgIT09IHRoaXMkMS5fc2l6ZSAmJiB0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCArIDEpLmNvbXBhcmVUbyh0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCkpIDwgMCkgeyBjaGlsZCsrOyB9XG4gICAgaWYgKHRoaXMkMS5faXRlbXMuZ2V0KGNoaWxkKS5jb21wYXJlVG8odG1wKSA8IDApIHsgdGhpcyQxLl9pdGVtcy5zZXQoaG9sZSwgdGhpcyQxLl9pdGVtcy5nZXQoY2hpbGQpKTsgfSBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHRoaXMuX2l0ZW1zLnNldChob2xlLCB0bXApO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICB0aGlzLl9zaXplID0gMDtcbiAgdGhpcy5faXRlbXMuY2xlYXIoKTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiB0aGlzLl9zaXplID09PSAwXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICh4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5faXRlbXMuYWRkKG51bGwpO1xuICB0aGlzLl9zaXplICs9IDE7XG4gIHZhciBob2xlID0gdGhpcy5fc2l6ZTtcbiAgdGhpcy5faXRlbXMuc2V0KDAsIHgpO1xuICBmb3IgKDsgeC5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoaG9sZSAvIDIpKSkgPCAwOyBob2xlIC89IDIpIHtcbiAgICB0aGlzJDEuX2l0ZW1zLnNldChob2xlLCB0aGlzJDEuX2l0ZW1zLmdldChNYXRoLnRydW5jKGhvbGUgLyAyKSkpO1xuICB9XG4gIHRoaXMuX2l0ZW1zLnNldChob2xlLCB4KTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQcmlvcml0eVF1ZXVlXG59O1xuXG52YXIgSXRlbVZpc2l0b3IgPSBmdW5jdGlvbiBJdGVtVmlzaXRvciAoKSB7fTtcblxuSXRlbVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SXRlbSA9IGZ1bmN0aW9uIHZpc2l0SXRlbSAoaXRlbSkge307XG5JdGVtVmlzaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkl0ZW1WaXNpdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEl0ZW1WaXNpdG9yXG59O1xuXG52YXIgU3BhdGlhbEluZGV4ID0gZnVuY3Rpb24gU3BhdGlhbEluZGV4ICgpIHt9O1xuXG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaXRlbUVudiwgaXRlbSkge307XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaXRlbUVudiwgaXRlbSkge307XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICAvLyBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAvLyBjb25zdCBzZWFyY2hFbnYgPSBhcmd1bWVudHNbMF1cbiAgLy8gfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gIC8vIGNvbnN0IHNlYXJjaEVudiA9IGFyZ3VtZW50c1swXVxuICAvLyBjb25zdCB2aXNpdG9yID0gYXJndW1lbnRzWzFdXG4gIC8vIH1cbn07XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3BhdGlhbEluZGV4XG59O1xuXG52YXIgQWJzdHJhY3ROb2RlID0gZnVuY3Rpb24gQWJzdHJhY3ROb2RlICgpIHtcbiAgdGhpcy5fY2hpbGRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICB0aGlzLl9sZXZlbCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxldmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjIgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbiBnZXRMZXZlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbFxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLnNpemUoKVxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRCb3VuZGFibGVzID0gZnVuY3Rpb24gZ2V0Q2hpbGRCb3VuZGFibGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlc1xufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuYWRkQ2hpbGRCb3VuZGFibGUgPSBmdW5jdGlvbiBhZGRDaGlsZEJvdW5kYWJsZSAoY2hpbGRCb3VuZGFibGUpIHtcbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9ib3VuZHMgPT09IG51bGwpO1xuICB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuYWRkKGNoaWxkQm91bmRhYmxlKTtcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5pc0VtcHR5KClcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZHMgPT09IG51bGwpIHtcbiAgICB0aGlzLl9ib3VuZHMgPSB0aGlzLmNvbXB1dGVCb3VuZHMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYm91bmRzXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQWJzdHJhY3ROb2RlXG59O1xuc3RhdGljQWNjZXNzb3JzJDIyLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNjQ5MzcyMjE4NTkwOTU3MzcwOCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQWJzdHJhY3ROb2RlLCBzdGF0aWNBY2Nlc3NvcnMkMjIgKTtcblxudmFyIENvbGxlY3Rpb25zID0gZnVuY3Rpb24gQ29sbGVjdGlvbnMgKCkge307XG5cbkNvbGxlY3Rpb25zLnJldmVyc2VPcmRlciA9IGZ1bmN0aW9uIHJldmVyc2VPcmRlciAoKSB7XG4gIHJldHVybiB7XG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICAgICAgcmV0dXJuIGIuY29tcGFyZVRvKGEpXG4gICAgfVxuICB9XG59O1xuQ29sbGVjdGlvbnMubWluID0gZnVuY3Rpb24gbWluIChsKSB7XG4gIENvbGxlY3Rpb25zLnNvcnQobCk7XG4gIHJldHVybiBsLmdldCgwKVxufTtcbkNvbGxlY3Rpb25zLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChsLCBjKSB7XG4gIHZhciBhID0gbC50b0FycmF5KCk7XG4gIGlmIChjKSB7XG4gICAgQXJyYXlzLnNvcnQoYSwgYyk7XG4gIH0gZWxzZSB7XG4gICAgQXJyYXlzLnNvcnQoYSk7XG4gIH1cbiAgdmFyIGkgPSBsLml0ZXJhdG9yKCk7XG4gIGZvciAodmFyIHBvcyA9IDAsIGFsZW4gPSBhLmxlbmd0aDsgcG9zIDwgYWxlbjsgcG9zKyspIHtcbiAgICBpLm5leHQoKTtcbiAgICBpLnNldChhW3Bvc10pO1xuICB9XG59O1xuQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdCA9IGZ1bmN0aW9uIHNpbmdsZXRvbkxpc3QgKG8pIHtcbiAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgYXJyYXlMaXN0LmFkZChvKTtcbiAgcmV0dXJuIGFycmF5TGlzdFxufTtcblxudmFyIEJvdW5kYWJsZVBhaXIgPSBmdW5jdGlvbiBCb3VuZGFibGVQYWlyICgpIHtcbiAgdGhpcy5fYm91bmRhYmxlMSA9IG51bGw7XG4gIHRoaXMuX2JvdW5kYWJsZTIgPSBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX2l0ZW1EaXN0YW5jZSA9IG51bGw7XG4gIHZhciBib3VuZGFibGUxID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYm91bmRhYmxlMiA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGl0ZW1EaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fYm91bmRhYmxlMSA9IGJvdW5kYWJsZTE7XG4gIHRoaXMuX2JvdW5kYWJsZTIgPSBib3VuZGFibGUyO1xuICB0aGlzLl9pdGVtRGlzdGFuY2UgPSBpdGVtRGlzdGFuY2U7XG4gIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSgpO1xufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmV4cGFuZFRvUXVldWUgPSBmdW5jdGlvbiBleHBhbmRUb1F1ZXVlIChwcmlRLCBtaW5EaXN0YW5jZSkge1xuICB2YXIgaXNDb21wMSA9IEJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSk7XG4gIHZhciBpc0NvbXAyID0gQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtcbiAgaWYgKGlzQ29tcDEgJiYgaXNDb21wMikge1xuICAgIGlmIChCb3VuZGFibGVQYWlyLmFyZWEodGhpcy5fYm91bmRhYmxlMSkgPiBCb3VuZGFibGVQYWlyLmFyZWEodGhpcy5fYm91bmRhYmxlMikpIHtcbiAgICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsIHRoaXMuX2JvdW5kYWJsZTIsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsIHRoaXMuX2JvdW5kYWJsZTEsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQ29tcDEpIHtcbiAgICB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLCB0aGlzLl9ib3VuZGFibGUyLCBwcmlRLCBtaW5EaXN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIGlmIChpc0NvbXAyKSB7XG4gICAgdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMiwgdGhpcy5fYm91bmRhYmxlMSwgcHJpUSwgbWluRGlzdGFuY2UpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignbmVpdGhlciBib3VuZGFibGUgaXMgY29tcG9zaXRlJylcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5pc0xlYXZlcyA9IGZ1bmN0aW9uIGlzTGVhdmVzICgpIHtcbiAgcmV0dXJuICEoQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKSB8fCBCb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpKVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgbmQgPSBvO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPCBuZC5fZGlzdGFuY2UpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2Rpc3RhbmNlID4gbmQuX2Rpc3RhbmNlKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQgKGJuZENvbXBvc2l0ZSwgYm5kT3RoZXIsIHByaVEsIG1pbkRpc3RhbmNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gYm5kQ29tcG9zaXRlLmdldENoaWxkQm91bmRhYmxlcygpO1xuICBmb3IgKHZhciBpID0gY2hpbGRyZW4uaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGNoaWxkID0gaS5uZXh0KCk7XG4gICAgdmFyIGJwID0gbmV3IEJvdW5kYWJsZVBhaXIoY2hpbGQsIGJuZE90aGVyLCB0aGlzJDEuX2l0ZW1EaXN0YW5jZSk7XG4gICAgaWYgKGJwLmdldERpc3RhbmNlKCkgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgcHJpUS5hZGQoYnApO1xuICAgIH1cbiAgfVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmdldEJvdW5kYWJsZSA9IGZ1bmN0aW9uIGdldEJvdW5kYWJsZSAoaSkge1xuICBpZiAoaSA9PT0gMCkgeyByZXR1cm4gdGhpcy5fYm91bmRhYmxlMSB9XG4gIHJldHVybiB0aGlzLl9ib3VuZGFibGUyXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXN0YW5jZVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAodGhpcy5pc0xlYXZlcygpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUxLCB0aGlzLl9ib3VuZGFibGUyKVxuICB9XG4gIHJldHVybiB0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJvdW5kYWJsZVBhaXJcbn07XG5Cb3VuZGFibGVQYWlyLmFyZWEgPSBmdW5jdGlvbiBhcmVhIChiKSB7XG4gIHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKVxufTtcbkJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUgPSBmdW5jdGlvbiBpc0NvbXBvc2l0ZSAoaXRlbSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZVxufTtcblxudmFyIEFic3RyYWN0U1RSdHJlZSA9IGZ1bmN0aW9uIEFic3RyYWN0U1RSdHJlZSAoKSB7XG4gIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB0aGlzLl9idWlsdCA9IGZhbHNlO1xuICB0aGlzLl9pdGVtQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbm9kZUNhcGFjaXR5ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgbm9kZUNhcGFjaXR5ID0gQWJzdHJhY3RTVFJ0cmVlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWTtcbiAgICB0aGlzLl9ub2RlQ2FwYWNpdHkgPSBub2RlQ2FwYWNpdHk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlQ2FwYWNpdHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBBc3NlcnQuaXNUcnVlKG5vZGVDYXBhY2l0eSQxID4gMSwgJ05vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgIHRoaXMuX25vZGVDYXBhY2l0eSA9IG5vZGVDYXBhY2l0eSQxO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIzID0geyBJbnRlcnNlY3RzT3A6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX05PREVfQ0FQQUNJVFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZ2V0Tm9kZUNhcGFjaXR5ID0gZnVuY3Rpb24gZ2V0Tm9kZUNhcGFjaXR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVDYXBhY2l0eVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUubGFzdE5vZGUgPSBmdW5jdGlvbiBsYXN0Tm9kZSAobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzLmdldChub2Rlcy5zaXplKCkgLSAxKVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSh0aGlzLl9yb290KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICBzaXplICs9IHRoaXMkMS5zaXplKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgIHNpemUgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemVcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0gKG5vZGUsIGl0ZW0pIHtcbiAgdmFyIGNoaWxkVG9SZW1vdmUgPSBudWxsO1xuICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpID09PSBpdGVtKSB7IGNoaWxkVG9SZW1vdmUgPSBjaGlsZEJvdW5kYWJsZTsgfVxuICAgIH1cbiAgfVxuICBpZiAoY2hpbGRUb1JlbW92ZSAhPT0gbnVsbCkge1xuICAgIG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGNoaWxkVG9SZW1vdmUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pdGVtc1RyZWUgPSBmdW5jdGlvbiBpdGVtc1RyZWUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIHZhciB2YWx1ZXNUcmVlID0gdGhpcy5pdGVtc1RyZWUodGhpcy5fcm9vdCk7XG4gICAgaWYgKHZhbHVlc1RyZWUgPT09IG51bGwpIHsgcmV0dXJuIG5ldyBBcnJheUxpc3QoKSB9XG4gICAgcmV0dXJuIHZhbHVlc1RyZWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHZhbHVlc1RyZWVGb3JOb2RlID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlc1RyZWVGb3JDaGlsZCA9IHRoaXMkMS5pdGVtc1RyZWUoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgICBpZiAodmFsdWVzVHJlZUZvckNoaWxkICE9PSBudWxsKSB7IHZhbHVlc1RyZWVGb3JOb2RlLmFkZCh2YWx1ZXNUcmVlRm9yQ2hpbGQpOyB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICB2YWx1ZXNUcmVlRm9yTm9kZS5hZGQoY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVzVHJlZUZvck5vZGUuc2l6ZSgpIDw9IDApIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiB2YWx1ZXNUcmVlRm9yTm9kZVxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGJvdW5kcywgaXRlbSkge1xuICBBc3NlcnQuaXNUcnVlKCF0aGlzLl9idWlsdCwgJ0Nhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC4nKTtcbiAgdGhpcy5faXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBJdGVtQm91bmRhYmxlKGJvdW5kcywgaXRlbSkpO1xufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuYm91bmRhYmxlc0F0TGV2ZWwgPSBmdW5jdGlvbiBib3VuZGFibGVzQXRMZXZlbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5ib3VuZGFibGVzQXRMZXZlbChsZXZlbCwgdGhpcy5fcm9vdCwgYm91bmRhYmxlcyk7XG4gICAgcmV0dXJuIGJvdW5kYWJsZXNcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGxldmVsJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHRvcCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm91bmRhYmxlcyQxID0gYXJndW1lbnRzWzJdO1xuICAgIEFzc2VydC5pc1RydWUobGV2ZWwkMSA+IC0yKTtcbiAgICBpZiAodG9wLmdldExldmVsKCkgPT09IGxldmVsJDEpIHtcbiAgICAgIGJvdW5kYWJsZXMkMS5hZGQodG9wKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSB0b3AuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgYm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoYm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIHRoaXMkMS5ib3VuZGFibGVzQXRMZXZlbChsZXZlbCQxLCBib3VuZGFibGUsIGJvdW5kYWJsZXMkMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBc3NlcnQuaXNUcnVlKGJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpO1xuICAgICAgICBpZiAobGV2ZWwkMSA9PT0gLTEpIHtcbiAgICAgICAgICBib3VuZGFibGVzJDEuYWRkKGJvdW5kYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzXG4gICAgfVxuICAgIGlmICh0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzKSkge1xuICAgICAgdGhpcy5xdWVyeShzZWFyY2hCb3VuZHMsIHRoaXMuX3Jvb3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHZpc2l0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMSkpIHtcbiAgICAgIHRoaXMucXVlcnkoc2VhcmNoQm91bmRzJDEsIHRoaXMuX3Jvb3QsIHZpc2l0b3IpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIEl0ZW1WaXNpdG9yKSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkpIHtcbiAgICAgIHZhciBzZWFyY2hCb3VuZHMkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBub2RlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHZpc2l0b3IkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZXMgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEJvdW5kYWJsZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gY2hpbGRCb3VuZGFibGVzLmdldChpKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhjaGlsZEJvdW5kYWJsZS5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzJDIpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgICB0aGlzJDEucXVlcnkoc2VhcmNoQm91bmRzJDIsIGNoaWxkQm91bmRhYmxlLCB2aXNpdG9yJDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICAgIHZpc2l0b3IkMS52aXNpdEl0ZW0oY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICB2YXIgc2VhcmNoQm91bmRzJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbm9kZSQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIG1hdGNoZXMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZXMkMSA9IG5vZGUkMS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkQm91bmRhYmxlcyQxLnNpemUoKTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRhYmxlJDEgPSBjaGlsZEJvdW5kYWJsZXMkMS5nZXQoaSQxKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhjaGlsZEJvdW5kYWJsZSQxLmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSQxIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgICAgdGhpcyQxLnF1ZXJ5KHNlYXJjaEJvdW5kcyQzLCBjaGlsZEJvdW5kYWJsZSQxLCBtYXRjaGVzJDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlJDEgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgICAgbWF0Y2hlcyQxLmFkZChjaGlsZEJvdW5kYWJsZSQxLmdldEl0ZW0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQgKCkge1xuICBpZiAodGhpcy5fYnVpbHQpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9yb290ID0gdGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpID8gdGhpcy5jcmVhdGVOb2RlKDApIDogdGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5faXRlbUJvdW5kYWJsZXMsIC0xKTtcbiAgdGhpcy5faXRlbUJvdW5kYWJsZXMgPSBudWxsO1xuICB0aGlzLl9idWlsdCA9IHRydWU7XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gZ2V0Um9vdCAoKSB7XG4gIHRoaXMuYnVpbGQoKTtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Rcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICBpZiAodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcykpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShzZWFyY2hCb3VuZHMsIHRoaXMuX3Jvb3QsIGl0ZW0pXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGl0ZW0kMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZm91bmQgPSB0aGlzLnJlbW92ZUl0ZW0obm9kZSwgaXRlbSQxKTtcbiAgICBpZiAoZm91bmQpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBjaGlsZFRvUHJ1bmUgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoIXRoaXMkMS5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMSkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICBmb3VuZCA9IHRoaXMkMS5yZW1vdmUoc2VhcmNoQm91bmRzJDEsIGNoaWxkQm91bmRhYmxlLCBpdGVtJDEpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICBjaGlsZFRvUHJ1bmUgPSBjaGlsZEJvdW5kYWJsZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZFRvUHJ1bmUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZFRvUHJ1bmUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpKSB7XG4gICAgICAgIG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGNoaWxkVG9QcnVuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVIaWdoZXJMZXZlbHMgPSBmdW5jdGlvbiBjcmVhdGVIaWdoZXJMZXZlbHMgKGJvdW5kYWJsZXNPZkFMZXZlbCwgbGV2ZWwpIHtcbiAgQXNzZXJ0LmlzVHJ1ZSghYm91bmRhYmxlc09mQUxldmVsLmlzRW1wdHkoKSk7XG4gIHZhciBwYXJlbnRCb3VuZGFibGVzID0gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKGJvdW5kYWJsZXNPZkFMZXZlbCwgbGV2ZWwgKyAxKTtcbiAgaWYgKHBhcmVudEJvdW5kYWJsZXMuc2l6ZSgpID09PSAxKSB7XG4gICAgcmV0dXJuIHBhcmVudEJvdW5kYWJsZXMuZ2V0KDApXG4gIH1cbiAgcmV0dXJuIHRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHBhcmVudEJvdW5kYWJsZXMsIGxldmVsICsgMSlcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmRlcHRoID0gZnVuY3Rpb24gZGVwdGggKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGgodGhpcy5fcm9vdClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heENoaWxkRGVwdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkRGVwdGggPSB0aGlzJDEuZGVwdGgoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgICBpZiAoY2hpbGREZXB0aCA+IG1heENoaWxkRGVwdGgpIHsgbWF4Q2hpbGREZXB0aCA9IGNoaWxkRGVwdGg7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heENoaWxkRGVwdGggKyAxXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzIChjaGlsZEJvdW5kYWJsZXMsIG5ld0xldmVsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgQXNzZXJ0LmlzVHJ1ZSghY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKSk7XG4gIHZhciBwYXJlbnRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBwYXJlbnRCb3VuZGFibGVzLmFkZCh0aGlzLmNyZWF0ZU5vZGUobmV3TGV2ZWwpKTtcbiAgdmFyIHNvcnRlZENoaWxkQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoY2hpbGRCb3VuZGFibGVzKTtcbiAgQ29sbGVjdGlvbnMuc29ydChzb3J0ZWRDaGlsZEJvdW5kYWJsZXMsIHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtcbiAgZm9yICh2YXIgaSA9IHNvcnRlZENoaWxkQm91bmRhYmxlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICBpZiAodGhpcyQxLmxhc3ROb2RlKHBhcmVudEJvdW5kYWJsZXMpLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKSA9PT0gdGhpcyQxLmdldE5vZGVDYXBhY2l0eSgpKSB7XG4gICAgICBwYXJlbnRCb3VuZGFibGVzLmFkZCh0aGlzJDEuY3JlYXRlTm9kZShuZXdMZXZlbCkpO1xuICAgIH1cbiAgICB0aGlzJDEubGFzdE5vZGUocGFyZW50Qm91bmRhYmxlcykuYWRkQ2hpbGRCb3VuZGFibGUoY2hpbGRCb3VuZGFibGUpO1xuICB9XG4gIHJldHVybiBwYXJlbnRCb3VuZGFibGVzXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIGlmICghdGhpcy5fYnVpbHQpIHsgcmV0dXJuIHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKSB9XG4gIHJldHVybiB0aGlzLl9yb290LmlzRW1wdHkoKVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlXVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBYnN0cmFjdFNUUnRyZWVcbn07XG5BYnN0cmFjdFNUUnRyZWUuY29tcGFyZURvdWJsZXMgPSBmdW5jdGlvbiBjb21wYXJlRG91YmxlcyAoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDBcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjMuSW50ZXJzZWN0c09wLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEludGVyc2VjdHNPcCB9O1xuc3RhdGljQWNjZXNzb3JzJDIzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTM4ODY0MzU4MTQzNjAyNDEzMzcgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMy5ERUZBVUxUX05PREVfQ0FQQUNJVFkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEFic3RyYWN0U1RSdHJlZSwgc3RhdGljQWNjZXNzb3JzJDIzICk7XG5cbnZhciBJbnRlcnNlY3RzT3AgPSBmdW5jdGlvbiBJbnRlcnNlY3RzT3AgKCkge307XG5cbnZhciBJdGVtRGlzdGFuY2UgPSBmdW5jdGlvbiBJdGVtRGlzdGFuY2UgKCkge307XG5cbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoaXRlbTEsIGl0ZW0yKSB7fTtcbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJdGVtRGlzdGFuY2Vcbn07XG5cbnZhciBTVFJ0cmVlID0gKGZ1bmN0aW9uIChBYnN0cmFjdFNUUnRyZWUkJDEpIHtcbiAgZnVuY3Rpb24gU1RSdHJlZSAobm9kZUNhcGFjaXR5KSB7XG4gICAgbm9kZUNhcGFjaXR5ID0gbm9kZUNhcGFjaXR5IHx8IFNUUnRyZWUuREVGQVVMVF9OT0RFX0NBUEFDSVRZO1xuICAgIEFic3RyYWN0U1RSdHJlZSQkMS5jYWxsKHRoaXMsIG5vZGVDYXBhY2l0eSk7XG4gIH1cblxuICBpZiAoIEFic3RyYWN0U1RSdHJlZSQkMSApIFNUUnRyZWUuX19wcm90b19fID0gQWJzdHJhY3RTVFJ0cmVlJCQxO1xuICBTVFJ0cmVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0U1RSdHJlZSQkMSAmJiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlICk7XG4gIFNUUnRyZWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1RSdHJlZTtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBTVFJ0cmVlTm9kZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHhDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHlDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGludGVyc2VjdHNPcDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX05PREVfQ0FQQUNJVFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMgKHZlcnRpY2FsU2xpY2VzLCBuZXdMZXZlbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgQXNzZXJ0LmlzVHJ1ZSh2ZXJ0aWNhbFNsaWNlcy5sZW5ndGggPiAwKTtcbiAgICB2YXIgcGFyZW50Qm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2FsU2xpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJlbnRCb3VuZGFibGVzLmFkZEFsbCh0aGlzJDEuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHZlcnRpY2FsU2xpY2VzW2ldLCBuZXdMZXZlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Qm91bmRhYmxlc1xuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlTm9kZSAobGV2ZWwpIHtcbiAgICByZXR1cm4gbmV3IFNUUnRyZWVOb2RlKGxldmVsKVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnNpemUuY2FsbCh0aGlzKVxuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBpdGVtRW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoaXRlbUVudi5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBpdGVtRW52LCBpdGVtKTtcbiAgICB9IGVsc2UgeyByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmdldEludGVyc2VjdHNPcCA9IGZ1bmN0aW9uIGdldEludGVyc2VjdHNPcCAoKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUuaW50ZXJzZWN0c09wXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnZlcnRpY2FsU2xpY2VzID0gZnVuY3Rpb24gdmVydGljYWxTbGljZXMgKGNoaWxkQm91bmRhYmxlcywgc2xpY2VDb3VudCkge1xuICAgIHZhciBzbGljZUNhcGFjaXR5ID0gTWF0aC50cnVuYyhNYXRoLmNlaWwoY2hpbGRCb3VuZGFibGVzLnNpemUoKSAvIHNsaWNlQ291bnQpKTtcbiAgICB2YXIgc2xpY2VzID0gbmV3IEFycmF5KHNsaWNlQ291bnQpLmZpbGwobnVsbCk7XG4gICAgdmFyIGkgPSBjaGlsZEJvdW5kYWJsZXMuaXRlcmF0b3IoKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNsaWNlQ291bnQ7IGorKykge1xuICAgICAgc2xpY2VzW2pdID0gbmV3IEFycmF5TGlzdCgpO1xuICAgICAgdmFyIGJvdW5kYWJsZXNBZGRlZFRvU2xpY2UgPSAwO1xuICAgICAgd2hpbGUgKGkuaGFzTmV4dCgpICYmIGJvdW5kYWJsZXNBZGRlZFRvU2xpY2UgPCBzbGljZUNhcGFjaXR5KSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgICBzbGljZXNbal0uYWRkKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgICAgYm91bmRhYmxlc0FkZGVkVG9TbGljZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xpY2VzXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2VhcmNoRW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hFbnYpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgc2VhcmNoRW52JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdmlzaXRvciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hFbnYkMSwgdmlzaXRvcik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgSXRlbVZpc2l0b3IpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSkge1xuICAgICAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZpc2l0b3IkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIHNlYXJjaEJvdW5kcywgbm9kZSwgdmlzaXRvciQxKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICAgIHZhciBzZWFyY2hCb3VuZHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIG5vZGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hCb3VuZHMkMSwgbm9kZSQxLCBtYXRjaGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmdldENvbXBhcmF0b3IgPSBmdW5jdGlvbiBnZXRDb21wYXJhdG9yICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZS55Q29tcGFyYXRvclxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UgKGNoaWxkQm91bmRhYmxlcywgbmV3TGV2ZWwpIHtcbiAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcywgY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbClcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGl0ZW1FbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIGl0ZW1FbnYsIGl0ZW0pXG4gICAgfSBlbHNlIHsgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uIGRlcHRoICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuZGVwdGguY2FsbCh0aGlzKVxuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmRlcHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzID0gZnVuY3Rpb24gY3JlYXRlUGFyZW50Qm91bmRhYmxlcyAoY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbCkge1xuICAgIEFzc2VydC5pc1RydWUoIWNoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCkpO1xuICAgIHZhciBtaW5MZWFmQ291bnQgPSBNYXRoLnRydW5jKE1hdGguY2VpbChjaGlsZEJvdW5kYWJsZXMuc2l6ZSgpIC8gdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpO1xuICAgIHZhciBzb3J0ZWRDaGlsZEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KGNoaWxkQm91bmRhYmxlcyk7XG4gICAgQ29sbGVjdGlvbnMuc29ydChzb3J0ZWRDaGlsZEJvdW5kYWJsZXMsIFNUUnRyZWUueENvbXBhcmF0b3IpO1xuICAgIHZhciB2ZXJ0aWNhbFNsaWNlcyA9IHRoaXMudmVydGljYWxTbGljZXMoc29ydGVkQ2hpbGRCb3VuZGFibGVzLCBNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobWluTGVhZkNvdW50KSkpKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHZlcnRpY2FsU2xpY2VzLCBuZXdMZXZlbClcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUubmVhcmVzdE5laWdoYm91ciA9IGZ1bmN0aW9uIG5lYXJlc3ROZWlnaGJvdXIgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgSXRlbURpc3RhbmNlKSkge1xuICAgICAgICB2YXIgaXRlbURpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBicCA9IG5ldyBCb3VuZGFibGVQYWlyKHRoaXMuZ2V0Um9vdCgpLCB0aGlzLmdldFJvb3QoKSwgaXRlbURpc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGJwKVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBCb3VuZGFibGVQYWlyKSB7XG4gICAgICAgIHZhciBpbml0Qm5kUGFpciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihpbml0Qm5kUGFpciwgRG91YmxlLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNUUnRyZWUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgSXRlbURpc3RhbmNlKSkge1xuICAgICAgICB2YXIgdHJlZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGl0ZW1EaXN0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBicCQxID0gbmV3IEJvdW5kYWJsZVBhaXIodGhpcy5nZXRSb290KCksIHRyZWUuZ2V0Um9vdCgpLCBpdGVtRGlzdCQxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihicCQxKVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBCb3VuZGFibGVQYWlyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBpbml0Qm5kUGFpciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBkaXN0YW5jZUxvd2VyQm91bmQgPSBtYXhEaXN0YW5jZTtcbiAgICAgICAgdmFyIG1pblBhaXIgPSBudWxsO1xuICAgICAgICB2YXIgcHJpUSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gICAgICAgIHByaVEuYWRkKGluaXRCbmRQYWlyJDEpO1xuICAgICAgICB3aGlsZSAoIXByaVEuaXNFbXB0eSgpICYmIGRpc3RhbmNlTG93ZXJCb3VuZCA+IDAuMCkge1xuICAgICAgICAgIHZhciBibmRQYWlyID0gcHJpUS5wb2xsKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IGJuZFBhaXIuZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgICBpZiAoY3VycmVudERpc3RhbmNlID49IGRpc3RhbmNlTG93ZXJCb3VuZCkgeyBicmVhayB9XG4gICAgICAgICAgaWYgKGJuZFBhaXIuaXNMZWF2ZXMoKSkge1xuICAgICAgICAgICAgZGlzdGFuY2VMb3dlckJvdW5kID0gY3VycmVudERpc3RhbmNlO1xuICAgICAgICAgICAgbWluUGFpciA9IGJuZFBhaXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJuZFBhaXIuZXhwYW5kVG9RdWV1ZShwcmlRLCBkaXN0YW5jZUxvd2VyQm91bmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pblBhaXIuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSwgbWluUGFpci5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIGVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGl0ZW1EaXN0JDIgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgYm5kID0gbmV3IEl0ZW1Cb3VuZGFibGUoZW52LCBpdGVtKTtcbiAgICAgIHZhciBicCQyID0gbmV3IEJvdW5kYWJsZVBhaXIodGhpcy5nZXRSb290KCksIGJuZCwgaXRlbURpc3QkMik7XG4gICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGJwJDIpWzBdXG4gICAgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1NwYXRpYWxJbmRleCwgU2VyaWFsaXphYmxlXVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZVxuICB9O1xuICBTVFJ0cmVlLmNlbnRyZVggPSBmdW5jdGlvbiBjZW50cmVYIChlKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUuYXZnKGUuZ2V0TWluWCgpLCBlLmdldE1heFgoKSlcbiAgfTtcbiAgU1RSdHJlZS5hdmcgPSBmdW5jdGlvbiBhdmcgKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgKyBiKSAvIDJcbiAgfTtcbiAgU1RSdHJlZS5jZW50cmVZID0gZnVuY3Rpb24gY2VudHJlWSAoZSkge1xuICAgIHJldHVybiBTVFJ0cmVlLmF2ZyhlLmdldE1pblkoKSwgZS5nZXRNYXhZKCkpXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5TVFJ0cmVlTm9kZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTVFJ0cmVlTm9kZSB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyNTkyNzQ3MDIzNjg5NTY5MDAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnhDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtDb21wYXJhdG9yXVxuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5jb21wYXJlRG91YmxlcyhTVFJ0cmVlLmNlbnRyZVgobzEuZ2V0Qm91bmRzKCkpLCBTVFJ0cmVlLmNlbnRyZVgobzIuZ2V0Qm91bmRzKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnlDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtDb21wYXJhdG9yXVxuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5jb21wYXJlRG91YmxlcyhTVFJ0cmVlLmNlbnRyZVkobzEuZ2V0Qm91bmRzKCkpLCBTVFJ0cmVlLmNlbnRyZVkobzIuZ2V0Qm91bmRzKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLmludGVyc2VjdHNPcC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbQWJzdHJhY3RTVFJ0cmVlJCQxLkludGVyc2VjdHNPcF1cbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYUJvdW5kcywgYkJvdW5kcykge1xuICAgICAgICByZXR1cm4gYUJvdW5kcy5pbnRlcnNlY3RzKGJCb3VuZHMpXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNUUnRyZWUsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBTVFJ0cmVlO1xufShBYnN0cmFjdFNUUnRyZWUpKTtcblxudmFyIFNUUnRyZWVOb2RlID0gKGZ1bmN0aW9uIChBYnN0cmFjdE5vZGUkJDEpIHtcbiAgZnVuY3Rpb24gU1RSdHJlZU5vZGUgKCkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50c1swXTtcbiAgICBBYnN0cmFjdE5vZGUkJDEuY2FsbCh0aGlzLCBsZXZlbCk7XG4gIH1cblxuICBpZiAoIEFic3RyYWN0Tm9kZSQkMSApIFNUUnRyZWVOb2RlLl9fcHJvdG9fXyA9IEFic3RyYWN0Tm9kZSQkMTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3ROb2RlJCQxICYmIEFic3RyYWN0Tm9kZSQkMS5wcm90b3R5cGUgKTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1RSdHJlZU5vZGU7XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5jb21wdXRlQm91bmRzID0gZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyAoKSB7XG4gICAgdmFyIGJvdW5kcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChib3VuZHMgPT09IG51bGwpIHtcbiAgICAgICAgYm91bmRzID0gbmV3IEVudmVsb3BlKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5leHBhbmRUb0luY2x1ZGUoY2hpbGRCb3VuZGFibGUuZ2V0Qm91bmRzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzXG4gIH07XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTVFJ0cmVlTm9kZVxuICB9O1xuXG4gIHJldHVybiBTVFJ0cmVlTm9kZTtcbn0oQWJzdHJhY3ROb2RlKSk7XG5cbnZhciBTZWdtZW50UG9pbnRDb21wYXJhdG9yID0gZnVuY3Rpb24gU2VnbWVudFBvaW50Q29tcGFyYXRvciAoKSB7fTtcblxuU2VnbWVudFBvaW50Q29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvclxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IucmVsYXRpdmVTaWduID0gZnVuY3Rpb24gcmVsYXRpdmVTaWduICh4MCwgeDEpIHtcbiAgaWYgKHgwIDwgeDEpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHgwID4geDEpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG9jdGFudCwgcDAsIHAxKSB7XG4gIGlmIChwMC5lcXVhbHMyRChwMSkpIHsgcmV0dXJuIDAgfVxuICB2YXIgeFNpZ24gPSBTZWdtZW50UG9pbnRDb21wYXJhdG9yLnJlbGF0aXZlU2lnbihwMC54LCBwMS54KTtcbiAgdmFyIHlTaWduID0gU2VnbWVudFBvaW50Q29tcGFyYXRvci5yZWxhdGl2ZVNpZ24ocDAueSwgcDEueSk7XG4gIHN3aXRjaCAob2N0YW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHhTaWduLCB5U2lnbilcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoeVNpZ24sIHhTaWduKVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSh5U2lnbiwgLXhTaWduKVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteFNpZ24sIHlTaWduKVxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteFNpZ24sIC15U2lnbilcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoLXlTaWduLCAteFNpZ24pXG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKC15U2lnbiwgeFNpZ24pXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHhTaWduLCAteVNpZ24pXG4gICAgZGVmYXVsdDpcbiAgfVxuICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ2ludmFsaWQgb2N0YW50IHZhbHVlJyk7XG4gIHJldHVybiAwXG59O1xuU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUgPSBmdW5jdGlvbiBjb21wYXJlVmFsdWUgKGNvbXBhcmVTaWduMCwgY29tcGFyZVNpZ24xKSB7XG4gIGlmIChjb21wYXJlU2lnbjAgPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmIChjb21wYXJlU2lnbjAgPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKGNvbXBhcmVTaWduMSA8IDApIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGNvbXBhcmVTaWduMSA+IDApIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblxudmFyIFNlZ21lbnROb2RlID0gZnVuY3Rpb24gU2VnbWVudE5vZGUgKCkge1xuICB0aGlzLl9zZWdTdHJpbmcgPSBudWxsO1xuICB0aGlzLmNvb3JkID0gbnVsbDtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBudWxsO1xuICB0aGlzLl9zZWdtZW50T2N0YW50ID0gbnVsbDtcbiAgdGhpcy5faXNJbnRlcmlvciA9IG51bGw7XG4gIHZhciBzZWdTdHJpbmcgPSBhcmd1bWVudHNbMF07XG4gIHZhciBjb29yZCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHNlZ21lbnRPY3RhbnQgPSBhcmd1bWVudHNbM107XG4gIHRoaXMuX3NlZ1N0cmluZyA9IHNlZ1N0cmluZztcbiAgdGhpcy5jb29yZCA9IG5ldyBDb29yZGluYXRlKGNvb3JkKTtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gIHRoaXMuX3NlZ21lbnRPY3RhbnQgPSBzZWdtZW50T2N0YW50O1xuICB0aGlzLl9pc0ludGVyaW9yID0gIWNvb3JkLmVxdWFsczJEKHNlZ1N0cmluZy5nZXRDb29yZGluYXRlKHNlZ21lbnRJbmRleCkpO1xufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBvdXQucHJpbnQodGhpcy5jb29yZCk7XG4gIG91dC5wcmludCgnIHNlZyAjID0gJyArIHRoaXMuc2VnbWVudEluZGV4KTtcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvYmopIHtcbiAgdmFyIG90aGVyID0gb2JqO1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPCBvdGhlci5zZWdtZW50SW5kZXgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID4gb3RoZXIuc2VnbWVudEluZGV4KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuY29vcmQuZXF1YWxzMkQob3RoZXIuY29vcmQpKSB7IHJldHVybiAwIH1cbiAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZSh0aGlzLl9zZWdtZW50T2N0YW50LCB0aGlzLmNvb3JkLCBvdGhlci5jb29yZClcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuaXNFbmRQb2ludCA9IGZ1bmN0aW9uIGlzRW5kUG9pbnQgKG1heFNlZ21lbnRJbmRleCkge1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IDAgJiYgIXRoaXMuX2lzSW50ZXJpb3IpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IG1heFNlZ21lbnRJbmRleCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5pc0ludGVyaW9yID0gZnVuY3Rpb24gaXNJbnRlcmlvciAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0ludGVyaW9yXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudE5vZGVcbn07XG5cbi8vIGltcG9ydCBJdGVyYXRvciBmcm9tICcuLi8uLi8uLi8uLi9qYXZhL3V0aWwvSXRlcmF0b3InXG52YXIgU2VnbWVudE5vZGVMaXN0ID0gZnVuY3Rpb24gU2VnbWVudE5vZGVMaXN0ICgpIHtcbiAgdGhpcy5fbm9kZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuX2VkZ2UgPSBudWxsO1xuICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZWRnZSA9IGVkZ2U7XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5nZXRTcGxpdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0U3BsaXRDb29yZGluYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCgpO1xuICB0aGlzLmFkZEVuZHBvaW50cygpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdGhpcyQxLmFkZEVkZ2VDb29yZGluYXRlcyhlaVByZXYsIGVpLCBjb29yZExpc3QpO1xuICAgIGVpUHJldiA9IGVpO1xuICB9XG4gIHJldHVybiBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkQ29sbGFwc2VkTm9kZXMgPSBmdW5jdGlvbiBhZGRDb2xsYXBzZWROb2RlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvbGxhcHNlZFZlcnRleEluZGV4ZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKGNvbGxhcHNlZFZlcnRleEluZGV4ZXMpO1xuICB0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyhjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzKTtcbiAgZm9yICh2YXIgaXQgPSBjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgdmVydGV4SW5kZXggPSBpdC5uZXh0KCkuaW50VmFsdWUoKTtcbiAgICB0aGlzJDEuYWRkKHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKHZlcnRleEluZGV4KSwgdmVydGV4SW5kZXgpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50bG4oJ0ludGVyc2VjdGlvbnM6Jyk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIGVpLnByaW50KG91dCk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyA9IGZ1bmN0aW9uIGZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyAoY29sbGFwc2VkVmVydGV4SW5kZXhlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZS5zaXplKCkgLSAyOyBpKyspIHtcbiAgICB2YXIgcDAgPSB0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpKTtcbiAgICAvLyBjb25zdCBwMSA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpICsgMSlcbiAgICB2YXIgcDIgPSB0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpICsgMik7XG4gICAgaWYgKHAwLmVxdWFsczJEKHAyKSkge1xuICAgICAgY29sbGFwc2VkVmVydGV4SW5kZXhlcy5hZGQobmV3IEludGVnZXIoaSArIDEpKTtcbiAgICB9XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZEVkZ2VDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGFkZEVkZ2VDb29yZGluYXRlcyAoZWkwLCBlaTEsIGNvb3JkTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGxldCBucHRzID0gZWkxLnNlZ21lbnRJbmRleCAtIGVpMC5zZWdtZW50SW5kZXggKyAyXG4gIHZhciBsYXN0U2VnU3RhcnRQdCA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlaTEuc2VnbWVudEluZGV4KTtcbiAgdmFyIHVzZUludFB0MSA9IGVpMS5pc0ludGVyaW9yKCkgfHwgIWVpMS5jb29yZC5lcXVhbHMyRChsYXN0U2VnU3RhcnRQdCk7XG4gIC8vIGlmICghdXNlSW50UHQxKSB7XG4gIC8vIG5wdHMtLVxuICAvLyB9XG4gIC8vIGNvbnN0IGlwdCA9IDBcbiAgY29vcmRMaXN0LmFkZChuZXcgQ29vcmRpbmF0ZShlaTAuY29vcmQpLCBmYWxzZSk7XG4gIGZvciAodmFyIGkgPSBlaTAuc2VnbWVudEluZGV4ICsgMTsgaSA8PSBlaTEuc2VnbWVudEluZGV4OyBpKyspIHtcbiAgICBjb29yZExpc3QuYWRkKHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKGkpKTtcbiAgfVxuICBpZiAodXNlSW50UHQxKSB7XG4gICAgY29vcmRMaXN0LmFkZChuZXcgQ29vcmRpbmF0ZShlaTEuY29vcmQpKTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKClcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZFNwbGl0RWRnZXMgPSBmdW5jdGlvbiBhZGRTcGxpdEVkZ2VzIChlZGdlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuYWRkRW5kcG9pbnRzKCk7XG4gIHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHZhciBuZXdFZGdlID0gdGhpcyQxLmNyZWF0ZVNwbGl0RWRnZShlaVByZXYsIGVpKTtcbiAgICBlZGdlTGlzdC5hZGQobmV3RWRnZSk7XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZUluZGV4ID0gZnVuY3Rpb24gZmluZENvbGxhcHNlSW5kZXggKGVpMCwgZWkxLCBjb2xsYXBzZWRWZXJ0ZXhJbmRleCkge1xuICBpZiAoIWVpMC5jb29yZC5lcXVhbHMyRChlaTEuY29vcmQpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBudW1WZXJ0aWNlc0JldHdlZW4gPSBlaTEuc2VnbWVudEluZGV4IC0gZWkwLnNlZ21lbnRJbmRleDtcbiAgaWYgKCFlaTEuaXNJbnRlcmlvcigpKSB7XG4gICAgbnVtVmVydGljZXNCZXR3ZWVuLS07XG4gIH1cbiAgaWYgKG51bVZlcnRpY2VzQmV0d2VlbiA9PT0gMSkge1xuICAgIGNvbGxhcHNlZFZlcnRleEluZGV4WzBdID0gZWkwLnNlZ21lbnRJbmRleCArIDE7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlcyA9IGZ1bmN0aW9uIGZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlcyAoY29sbGFwc2VkVmVydGV4SW5kZXhlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb2xsYXBzZWRWZXJ0ZXhJbmRleCA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGlzQ29sbGFwc2VkID0gdGhpcyQxLmZpbmRDb2xsYXBzZUluZGV4KGVpUHJldiwgZWksIGNvbGxhcHNlZFZlcnRleEluZGV4KTtcbiAgICBpZiAoaXNDb2xsYXBzZWQpIHsgY29sbGFwc2VkVmVydGV4SW5kZXhlcy5hZGQobmV3IEludGVnZXIoY29sbGFwc2VkVmVydGV4SW5kZXhbMF0pKTsgfVxuICAgIGVpUHJldiA9IGVpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGRFbmRwb2ludHMgPSBmdW5jdGlvbiBhZGRFbmRwb2ludHMgKCkge1xuICB2YXIgbWF4U2VnSW5kZXggPSB0aGlzLl9lZGdlLnNpemUoKSAtIDE7XG4gIHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwgMCk7XG4gIHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShtYXhTZWdJbmRleCksIG1heFNlZ0luZGV4KTtcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmNyZWF0ZVNwbGl0RWRnZSA9IGZ1bmN0aW9uIGNyZWF0ZVNwbGl0RWRnZSAoZWkwLCBlaTEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbnB0cyA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4ICsgMjtcbiAgdmFyIGxhc3RTZWdTdGFydFB0ID0gdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGVpMS5zZWdtZW50SW5kZXgpO1xuICB2YXIgdXNlSW50UHQxID0gZWkxLmlzSW50ZXJpb3IoKSB8fCAhZWkxLmNvb3JkLmVxdWFsczJEKGxhc3RTZWdTdGFydFB0KTtcbiAgaWYgKCF1c2VJbnRQdDEpIHtcbiAgICBucHRzLS07XG4gIH1cbiAgdmFyIHB0cyA9IG5ldyBBcnJheShucHRzKS5maWxsKG51bGwpO1xuICB2YXIgaXB0ID0gMDtcbiAgcHRzW2lwdCsrXSA9IG5ldyBDb29yZGluYXRlKGVpMC5jb29yZCk7XG4gIGZvciAodmFyIGkgPSBlaTAuc2VnbWVudEluZGV4ICsgMTsgaSA8PSBlaTEuc2VnbWVudEluZGV4OyBpKyspIHtcbiAgICBwdHNbaXB0KytdID0gdGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUoaSk7XG4gIH1cbiAgaWYgKHVzZUludFB0MSkgeyBwdHNbaXB0XSA9IG5ldyBDb29yZGluYXRlKGVpMS5jb29yZCk7IH1cbiAgcmV0dXJuIG5ldyBOb2RlZFNlZ21lbnRTdHJpbmcocHRzLCB0aGlzLl9lZGdlLmdldERhdGEoKSlcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoaW50UHQsIHNlZ21lbnRJbmRleCkge1xuICB2YXIgZWlOZXcgPSBuZXcgU2VnbWVudE5vZGUodGhpcy5fZWRnZSwgaW50UHQsIHNlZ21lbnRJbmRleCwgdGhpcy5fZWRnZS5nZXRTZWdtZW50T2N0YW50KHNlZ21lbnRJbmRleCkpO1xuICB2YXIgZWkgPSB0aGlzLl9ub2RlTWFwLmdldChlaU5ldyk7XG4gIGlmIChlaSAhPT0gbnVsbCkge1xuICAgIEFzc2VydC5pc1RydWUoZWkuY29vcmQuZXF1YWxzMkQoaW50UHQpLCAnRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXMnKTtcbiAgICByZXR1cm4gZWlcbiAgfVxuICB0aGlzLl9ub2RlTWFwLnB1dChlaU5ldywgZWlOZXcpO1xuICByZXR1cm4gZWlOZXdcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzID0gZnVuY3Rpb24gY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3MgKHNwbGl0RWRnZXMpIHtcbiAgdmFyIGVkZ2VQdHMgPSB0aGlzLl9lZGdlLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBzcGxpdDAgPSBzcGxpdEVkZ2VzLmdldCgwKTtcbiAgdmFyIHB0MCA9IHNwbGl0MC5nZXRDb29yZGluYXRlKDApO1xuICBpZiAoIXB0MC5lcXVhbHMyRChlZGdlUHRzWzBdKSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignYmFkIHNwbGl0IGVkZ2Ugc3RhcnQgcG9pbnQgYXQgJyArIHB0MCkgfVxuICB2YXIgc3BsaXRuID0gc3BsaXRFZGdlcy5nZXQoc3BsaXRFZGdlcy5zaXplKCkgLSAxKTtcbiAgdmFyIHNwbGl0blB0cyA9IHNwbGl0bi5nZXRDb29yZGluYXRlcygpO1xuICB2YXIgcHRuID0gc3BsaXRuUHRzW3NwbGl0blB0cy5sZW5ndGggLSAxXTtcbiAgaWYgKCFwdG4uZXF1YWxzMkQoZWRnZVB0c1tlZGdlUHRzLmxlbmd0aCAtIDFdKSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0ICcgKyBwdG4pIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudE5vZGVMaXN0XG59O1xuXG5cblxuLy8gY2xhc3MgTm9kZVZlcnRleEl0ZXJhdG9yIHtcbi8vICAgY29uc3RydWN0b3IgKCkge1xuLy8gICAgIHRoaXMuX25vZGVMaXN0ID0gbnVsbFxuLy8gICAgIHRoaXMuX2VkZ2UgPSBudWxsXG4vLyAgICAgdGhpcy5fbm9kZUl0ID0gbnVsbFxuLy8gICAgIHRoaXMuX2N1cnJOb2RlID0gbnVsbFxuLy8gICAgIHRoaXMuX25leHROb2RlID0gbnVsbFxuLy8gICAgIHRoaXMuX2N1cnJTZWdJbmRleCA9IDBcbi8vICAgICBsZXQgbm9kZUxpc3QgPSBhcmd1bWVudHNbMF1cbi8vICAgICB0aGlzLl9ub2RlTGlzdCA9IG5vZGVMaXN0XG4vLyAgICAgdGhpcy5fZWRnZSA9IG5vZGVMaXN0LmdldEVkZ2UoKVxuLy8gICAgIHRoaXMuX25vZGVJdCA9IG5vZGVMaXN0Lml0ZXJhdG9yKClcbi8vICAgICB0aGlzLnJlYWROZXh0Tm9kZSgpXG4vLyAgIH1cbi8vICAgbmV4dCAoKSB7XG4vLyAgICAgaWYgKHRoaXMuX2N1cnJOb2RlID09PSBudWxsKSB7XG4vLyAgICAgICB0aGlzLl9jdXJyTm9kZSA9IHRoaXMuX25leHROb2RlXG4vLyAgICAgICB0aGlzLl9jdXJyU2VnSW5kZXggPSB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXhcbi8vICAgICAgIHRoaXMucmVhZE5leHROb2RlKClcbi8vICAgICAgIHJldHVybiB0aGlzLl9jdXJyTm9kZVxuLy8gICAgIH1cbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUgPT09IG51bGwpIHJldHVybiBudWxsXG4vLyAgICAgaWYgKHRoaXMuX25leHROb2RlLnNlZ21lbnRJbmRleCA9PT0gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4KSB7XG4vLyAgICAgICB0aGlzLl9jdXJyTm9kZSA9IHRoaXMuX25leHROb2RlXG4vLyAgICAgICB0aGlzLl9jdXJyU2VnSW5kZXggPSB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXhcbi8vICAgICAgIHRoaXMucmVhZE5leHROb2RlKClcbi8vICAgICAgIHJldHVybiB0aGlzLl9jdXJyTm9kZVxuLy8gICAgIH1cbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUuc2VnbWVudEluZGV4ID4gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4KSB7fVxuLy8gICAgIHJldHVybiBudWxsXG4vLyAgIH1cbi8vICAgcmVtb3ZlICgpIHtcbi8vICAgICAvLyB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSlcbi8vICAgfVxuLy8gICBoYXNOZXh0ICgpIHtcbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZVxuLy8gICAgIHJldHVybiB0cnVlXG4vLyAgIH1cbi8vICAgcmVhZE5leHROb2RlICgpIHtcbi8vICAgICBpZiAodGhpcy5fbm9kZUl0Lmhhc05leHQoKSkgdGhpcy5fbmV4dE5vZGUgPSB0aGlzLl9ub2RlSXQubmV4dCgpOyBlbHNlIHRoaXMuX25leHROb2RlID0gbnVsbFxuLy8gICB9XG4vLyAgIGludGVyZmFjZXNfICgpIHtcbi8vICAgICByZXR1cm4gW0l0ZXJhdG9yXVxuLy8gICB9XG4vLyAgIGdldENsYXNzICgpIHtcbi8vICAgICByZXR1cm4gTm9kZVZlcnRleEl0ZXJhdG9yXG4vLyAgIH1cbi8vIH1cblxudmFyIE9jdGFudCA9IGZ1bmN0aW9uIE9jdGFudCAoKSB7fTtcblxuT2N0YW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2N0YW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9jdGFudFxufTtcbk9jdGFudC5vY3RhbnQgPSBmdW5jdGlvbiBvY3RhbnQgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGR5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkeCA9PT0gMC4wICYmIGR5ID09PSAwLjApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCAnICsgZHggKyAnLCAnICsgZHkgKyAnICknKSB9XG4gICAgdmFyIGFkeCA9IE1hdGguYWJzKGR4KTtcbiAgICB2YXIgYWR5ID0gTWF0aC5hYnMoZHkpO1xuICAgIGlmIChkeCA+PSAwKSB7XG4gICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICBpZiAoYWR4ID49IGFkeSkgeyByZXR1cm4gMDsgfSBlbHNlIHsgcmV0dXJuIDEgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDc7IH0gZWxzZSB7IHJldHVybiA2IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR5ID49IDApIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDM7IH0gZWxzZSB7IHJldHVybiAyIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhZHggPj0gYWR5KSB7IHJldHVybiA0OyB9IGVsc2UgeyByZXR1cm4gNSB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGR4JDEgPSBwMS54IC0gcDAueDtcbiAgICB2YXIgZHkkMSA9IHAxLnkgLSBwMC55O1xuICAgIGlmIChkeCQxID09PSAwLjAgJiYgZHkkMSA9PT0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzICcgKyBwMCkgfVxuICAgIHJldHVybiBPY3RhbnQub2N0YW50KGR4JDEsIGR5JDEpXG4gIH1cbn07XG5cbnZhciBTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gU2VnbWVudFN0cmluZyAoKSB7fTtcblxuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhIChkYXRhKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudFN0cmluZ1xufTtcblxudmFyIE5vZGFibGVTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gTm9kYWJsZVNlZ21lbnRTdHJpbmcgKCkge307XG5cbk5vZGFibGVTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb24gKGludFB0LCBzZWdtZW50SW5kZXgpIHt9O1xuTm9kYWJsZVNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRTdHJpbmddXG59O1xuTm9kYWJsZVNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kYWJsZVNlZ21lbnRTdHJpbmdcbn07XG5cbnZhciBOb2RlZFNlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBOb2RlZFNlZ21lbnRTdHJpbmcgKCkge1xuICB0aGlzLl9ub2RlTGlzdCA9IG5ldyBTZWdtZW50Tm9kZUxpc3QodGhpcyk7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHMubGVuZ3RoXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRzW2ldXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGggLSAxXSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldFNlZ21lbnRPY3RhbnQgPSBmdW5jdGlvbiBnZXRTZWdtZW50T2N0YW50IChpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHRoaXMuX3B0cy5sZW5ndGggLSAxKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiB0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKGluZGV4KSwgdGhpcy5nZXRDb29yZGluYXRlKGluZGV4ICsgMSkpXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSkge1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNhZmVPY3RhbnQgPSBmdW5jdGlvbiBzYWZlT2N0YW50IChwMCwgcDEpIHtcbiAgaWYgKHAwLmVxdWFsczJEKHAxKSkgeyByZXR1cm4gMCB9XG4gIHJldHVybiBPY3RhbnQub2N0YW50KHAwLCBwMSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGFcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGludFB0JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmFkZEludGVyc2VjdGlvbk5vZGUoaW50UHQkMSwgc2VnbWVudEluZGV4KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdtZW50SW5kZXgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAvLyBjb25zdCBnZW9tSW5kZXggPSBhcmd1bWVudHNbMl1cbiAgICB2YXIgaW50SW5kZXggPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGludFB0ID0gbmV3IENvb3JkaW5hdGUobGkuZ2V0SW50ZXJzZWN0aW9uKGludEluZGV4KSk7XG4gICAgdGhpcy5hZGRJbnRlcnNlY3Rpb24oaW50UHQsIHNlZ21lbnRJbmRleCQxKTtcbiAgfVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSh0aGlzLl9wdHMpKVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Tm9kZUxpc3QgPSBmdW5jdGlvbiBnZXROb2RlTGlzdCAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTGlzdFxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9uTm9kZSA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbk5vZGUgKGludFB0LCBzZWdtZW50SW5kZXgpIHtcbiAgdmFyIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gIHZhciBuZXh0U2VnSW5kZXggPSBub3JtYWxpemVkU2VnbWVudEluZGV4ICsgMTtcbiAgaWYgKG5leHRTZWdJbmRleCA8IHRoaXMuX3B0cy5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dFB0ID0gdGhpcy5fcHRzW25leHRTZWdJbmRleF07XG4gICAgaWYgKGludFB0LmVxdWFsczJEKG5leHRQdCkpIHtcbiAgICAgIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBuZXh0U2VnSW5kZXg7XG4gICAgfVxuICB9XG4gIHZhciBlaSA9IHRoaXMuX25vZGVMaXN0LmFkZChpbnRQdCwgbm9ybWFsaXplZFNlZ21lbnRJbmRleCk7XG4gIHJldHVybiBlaVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGkrKykge1xuICAgIHRoaXMkMS5hZGRJbnRlcnNlY3Rpb24obGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4LCBpKTtcbiAgfVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kYWJsZVNlZ21lbnRTdHJpbmddXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVkU2VnbWVudFN0cmluZ1xufTtcbk5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByZXN1bHRFZGdlbGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKHNlZ1N0cmluZ3MsIHJlc3VsdEVkZ2VsaXN0KTtcbiAgICByZXR1cm4gcmVzdWx0RWRnZWxpc3RcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNlZ1N0cmluZ3MkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmVzdWx0RWRnZWxpc3QkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBmb3IgKHZhciBpID0gc2VnU3RyaW5ncyQxLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICBzcy5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXMocmVzdWx0RWRnZWxpc3QkMSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgTGluZVNlZ21lbnQgPSBmdW5jdGlvbiBMaW5lU2VnbWVudCAoKSB7XG4gIHRoaXMucDAgPSBudWxsO1xuICB0aGlzLnAxID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnAwID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLnAxID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMucDAgPSBuZXcgQ29vcmRpbmF0ZShscy5wMCk7XG4gICAgdGhpcy5wMSA9IG5ldyBDb29yZGluYXRlKGxzLnAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5wMCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnAxID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgeDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkwID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB4MSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5wMCA9IG5ldyBDb29yZGluYXRlKHgwLCB5MCk7XG4gICAgdGhpcy5wMSA9IG5ldyBDb29yZGluYXRlKHgxLCB5MSk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjQgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5taW5YID0gZnVuY3Rpb24gbWluWCAoKSB7XG4gIHJldHVybiBNYXRoLm1pbih0aGlzLnAwLngsIHRoaXMucDEueClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUub3JpZW50YXRpb25JbmRleCA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXggKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpIHtcbiAgICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcmllbnQwID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCwgdGhpcy5wMSwgc2VnLnAwKTtcbiAgICB2YXIgb3JpZW50MSA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsIHRoaXMucDEsIHNlZy5wMSk7XG4gICAgaWYgKG9yaWVudDAgPj0gMCAmJiBvcmllbnQxID49IDApIHsgcmV0dXJuIE1hdGgubWF4KG9yaWVudDAsIG9yaWVudDEpIH1cbiAgICBpZiAob3JpZW50MCA8PSAwICYmIG9yaWVudDEgPD0gMCkgeyByZXR1cm4gTWF0aC5tYXgob3JpZW50MCwgb3JpZW50MSkgfVxuICAgIHJldHVybiAwXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLCB0aGlzLnAxLCBwKVxuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnRvR2VvbWV0cnkgPSBmdW5jdGlvbiB0b0dlb21ldHJ5IChnZW9tRmFjdG9yeSkge1xuICByZXR1cm4gZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCwgdGhpcy5wMV0pXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmlzVmVydGljYWwgPSBmdW5jdGlvbiBpc1ZlcnRpY2FsICgpIHtcbiAgcmV0dXJuIHRoaXMucDAueCA9PT0gdGhpcy5wMS54XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIG90aGVyID0gbztcbiAgcmV0dXJuIHRoaXMucDAuZXF1YWxzKG90aGVyLnAwKSAmJiB0aGlzLnAxLmVxdWFscyhvdGhlci5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChsaW5lKSB7XG4gIHZhciBsaSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLCB0aGlzLnAxLCBsaW5lLnAwLCBsaW5lLnAxKTtcbiAgaWYgKGxpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiBsaS5nZXRJbnRlcnNlY3Rpb24oMCkgfVxuICByZXR1cm4gbnVsbFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gcHJvamVjdCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHAuZXF1YWxzKHRoaXMucDApIHx8IHAuZXF1YWxzKHRoaXMucDEpKSB7IHJldHVybiBuZXcgQ29vcmRpbmF0ZShwKSB9XG4gICAgdmFyIHIgPSB0aGlzLnByb2plY3Rpb25GYWN0b3IocCk7XG4gICAgdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICBjb29yZC54ID0gdGhpcy5wMC54ICsgciAqICh0aGlzLnAxLnggLSB0aGlzLnAwLngpO1xuICAgIGNvb3JkLnkgPSB0aGlzLnAwLnkgKyByICogKHRoaXMucDEueSAtIHRoaXMucDAueSk7XG4gICAgcmV0dXJuIGNvb3JkXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpIHtcbiAgICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwZjAgPSB0aGlzLnByb2plY3Rpb25GYWN0b3Ioc2VnLnAwKTtcbiAgICB2YXIgcGYxID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKHNlZy5wMSk7XG4gICAgaWYgKHBmMCA+PSAxLjAgJiYgcGYxID49IDEuMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHBmMCA8PSAwLjAgJiYgcGYxIDw9IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG5ld3AwID0gdGhpcy5wcm9qZWN0KHNlZy5wMCk7XG4gICAgaWYgKHBmMCA8IDAuMCkgeyBuZXdwMCA9IHRoaXMucDA7IH1cbiAgICBpZiAocGYwID4gMS4wKSB7IG5ld3AwID0gdGhpcy5wMTsgfVxuICAgIHZhciBuZXdwMSA9IHRoaXMucHJvamVjdChzZWcucDEpO1xuICAgIGlmIChwZjEgPCAwLjApIHsgbmV3cDEgPSB0aGlzLnAwOyB9XG4gICAgaWYgKHBmMSA+IDEuMCkgeyBuZXdwMSA9IHRoaXMucDE7IH1cbiAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KG5ld3AwLCBuZXdwMSlcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICBpZiAodGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCkgPCAwKSB7IHRoaXMucmV2ZXJzZSgpOyB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmFuZ2xlID0gZnVuY3Rpb24gYW5nbGUgKCkge1xuICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnkgLSB0aGlzLnAwLnksIHRoaXMucDEueCAtIHRoaXMucDAueClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgaWYgKGkgPT09IDApIHsgcmV0dXJuIHRoaXMucDAgfVxuICByZXR1cm4gdGhpcy5wMVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiBkaXN0YW5jZVBlcnBlbmRpY3VsYXIgKHApIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIocCwgdGhpcy5wMCwgdGhpcy5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWluWSA9IGZ1bmN0aW9uIG1pblkgKCkge1xuICByZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LCB0aGlzLnAxLnkpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1pZFBvaW50ID0gZnVuY3Rpb24gbWlkUG9pbnQgKCkge1xuICByZXR1cm4gTGluZVNlZ21lbnQubWlkUG9pbnQodGhpcy5wMCwgdGhpcy5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucHJvamVjdGlvbkZhY3RvciA9IGZ1bmN0aW9uIHByb2plY3Rpb25GYWN0b3IgKHApIHtcbiAgaWYgKHAuZXF1YWxzKHRoaXMucDApKSB7IHJldHVybiAwLjAgfVxuICBpZiAocC5lcXVhbHModGhpcy5wMSkpIHsgcmV0dXJuIDEuMCB9XG4gIHZhciBkeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDtcbiAgdmFyIGR5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55O1xuICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gIGlmIChsZW4gPD0gMC4wKSB7IHJldHVybiBEb3VibGUuTmFOIH1cbiAgdmFyIHIgPSAoKHAueCAtIHRoaXMucDAueCkgKiBkeCArIChwLnkgLSB0aGlzLnAwLnkpICogZHkpIC8gbGVuO1xuICByZXR1cm4gclxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRzID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50cyAobGluZSkge1xuICB2YXIgaW50UHQgPSB0aGlzLmludGVyc2VjdGlvbihsaW5lKTtcbiAgaWYgKGludFB0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtpbnRQdCwgaW50UHRdXG4gIH1cbiAgdmFyIGNsb3Nlc3RQdCA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB2YXIgbWluRGlzdGFuY2UgPSBEb3VibGUuTUFYX1ZBTFVFO1xuICB2YXIgZGlzdCA9IG51bGw7XG4gIHZhciBjbG9zZTAwID0gdGhpcy5jbG9zZXN0UG9pbnQobGluZS5wMCk7XG4gIG1pbkRpc3RhbmNlID0gY2xvc2UwMC5kaXN0YW5jZShsaW5lLnAwKTtcbiAgY2xvc2VzdFB0WzBdID0gY2xvc2UwMDtcbiAgY2xvc2VzdFB0WzFdID0gbGluZS5wMDtcbiAgdmFyIGNsb3NlMDEgPSB0aGlzLmNsb3Nlc3RQb2ludChsaW5lLnAxKTtcbiAgZGlzdCA9IGNsb3NlMDEuZGlzdGFuY2UobGluZS5wMSk7XG4gIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgY2xvc2VzdFB0WzBdID0gY2xvc2UwMTtcbiAgICBjbG9zZXN0UHRbMV0gPSBsaW5lLnAxO1xuICB9XG4gIHZhciBjbG9zZTEwID0gbGluZS5jbG9zZXN0UG9pbnQodGhpcy5wMCk7XG4gIGRpc3QgPSBjbG9zZTEwLmRpc3RhbmNlKHRoaXMucDApO1xuICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgIGNsb3Nlc3RQdFswXSA9IHRoaXMucDA7XG4gICAgY2xvc2VzdFB0WzFdID0gY2xvc2UxMDtcbiAgfVxuICB2YXIgY2xvc2UxMSA9IGxpbmUuY2xvc2VzdFBvaW50KHRoaXMucDEpO1xuICBkaXN0ID0gY2xvc2UxMS5kaXN0YW5jZSh0aGlzLnAxKTtcbiAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICBjbG9zZXN0UHRbMF0gPSB0aGlzLnAxO1xuICAgIGNsb3Nlc3RQdFsxXSA9IGNsb3NlMTE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQdFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnQgKHApIHtcbiAgdmFyIGZhY3RvciA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihwKTtcbiAgaWYgKGZhY3RvciA+IDAgJiYgZmFjdG9yIDwgMSkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3QocClcbiAgfVxuICB2YXIgZGlzdDAgPSB0aGlzLnAwLmRpc3RhbmNlKHApO1xuICB2YXIgZGlzdDEgPSB0aGlzLnAxLmRpc3RhbmNlKHApO1xuICBpZiAoZGlzdDAgPCBkaXN0MSkgeyByZXR1cm4gdGhpcy5wMCB9XG4gIHJldHVybiB0aGlzLnAxXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1heFggPSBmdW5jdGlvbiBtYXhYICgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMucDAueCwgdGhpcy5wMS54KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICByZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgdmFyIGNvbXAwID0gdGhpcy5wMC5jb21wYXJlVG8ob3RoZXIucDApO1xuICBpZiAoY29tcDAgIT09IDApIHsgcmV0dXJuIGNvbXAwIH1cbiAgcmV0dXJuIHRoaXMucDEuY29tcGFyZVRvKG90aGVyLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gIHZhciB0ZW1wID0gdGhpcy5wMDtcbiAgdGhpcy5wMCA9IHRoaXMucDE7XG4gIHRoaXMucDEgPSB0ZW1wO1xufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5lcXVhbHNUb3BvID0gZnVuY3Rpb24gZXF1YWxzVG9wbyAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMucDAuZXF1YWxzKG90aGVyLnAwKSAmJlxuICAgICAgICAodGhpcy5wMS5lcXVhbHMob3RoZXIucDEpIHx8IHRoaXMucDAuZXF1YWxzKG90aGVyLnAxKSkgJiZcbiAgICAgICAgIHRoaXMucDEuZXF1YWxzKG90aGVyLnAwKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5saW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gbGluZUludGVyc2VjdGlvbiAobGluZSkge1xuICB0cnkge1xuICAgIHZhciBpbnRQdCA9IEhDb29yZGluYXRlLmludGVyc2VjdGlvbih0aGlzLnAwLCB0aGlzLnAxLCBsaW5lLnAwLCBsaW5lLnAxKTtcbiAgICByZXR1cm4gaW50UHRcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKSB7fSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbiAgcmV0dXJuIG51bGxcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWF4WSA9IGZ1bmN0aW9uIG1heFkgKCkge1xuICByZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LCB0aGlzLnAxLnkpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnBvaW50QWxvbmdPZmZzZXQgPSBmdW5jdGlvbiBwb2ludEFsb25nT2Zmc2V0IChzZWdtZW50TGVuZ3RoRnJhY3Rpb24sIG9mZnNldERpc3RhbmNlKSB7XG4gIHZhciBzZWd4ID0gdGhpcy5wMC54ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueCAtIHRoaXMucDAueCk7XG4gIHZhciBzZWd5ID0gdGhpcy5wMC55ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueSAtIHRoaXMucDAueSk7XG4gIHZhciBkeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDtcbiAgdmFyIGR5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55O1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHV4ID0gMC4wO1xuICB2YXIgdXkgPSAwLjA7XG4gIGlmIChvZmZzZXREaXN0YW5jZSAhPT0gMC4wKSB7XG4gICAgaWYgKGxlbiA8PSAwLjApIHsgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnQnKSB9XG4gICAgdXggPSBvZmZzZXREaXN0YW5jZSAqIGR4IC8gbGVuO1xuICAgIHV5ID0gb2Zmc2V0RGlzdGFuY2UgKiBkeSAvIGxlbjtcbiAgfVxuICB2YXIgb2Zmc2V0eCA9IHNlZ3ggLSB1eTtcbiAgdmFyIG9mZnNldHkgPSBzZWd5ICsgdXg7XG4gIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKG9mZnNldHgsIG9mZnNldHkpO1xuICByZXR1cm4gY29vcmRcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMobHMucDAsIGxzLnAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnAwLnggPSBwMC54O1xuICAgIHRoaXMucDAueSA9IHAwLnk7XG4gICAgdGhpcy5wMS54ID0gcDEueDtcbiAgICB0aGlzLnAxLnkgPSBwMS55O1xuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnNlZ21lbnRGcmFjdGlvbiA9IGZ1bmN0aW9uIHNlZ21lbnRGcmFjdGlvbiAoaW5wdXRQdCkge1xuICB2YXIgc2VnRnJhYyA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihpbnB1dFB0KTtcbiAgaWYgKHNlZ0ZyYWMgPCAwLjApIHsgc2VnRnJhYyA9IDAuMDsgfSBlbHNlIGlmIChzZWdGcmFjID4gMS4wIHx8IERvdWJsZS5pc05hTihzZWdGcmFjKSkgeyBzZWdGcmFjID0gMS4wOyB9XG4gIHJldHVybiBzZWdGcmFjXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ0xJTkVTVFJJTkcoICcgKyB0aGlzLnAwLnggKyAnICcgKyB0aGlzLnAwLnkgKyAnLCAnICsgdGhpcy5wMS54ICsgJyAnICsgdGhpcy5wMS55ICsgJyknXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbCAoKSB7XG4gIHJldHVybiB0aGlzLnAwLnkgPT09IHRoaXMucDEueVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50KSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLCB0aGlzLnAxLCBscy5wMCwgbHMucDEpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocCwgdGhpcy5wMCwgdGhpcy5wMSlcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wb2ludEFsb25nID0gZnVuY3Rpb24gcG9pbnRBbG9uZyAoc2VnbWVudExlbmd0aEZyYWN0aW9uKSB7XG4gIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIGNvb3JkLnggPSB0aGlzLnAwLnggKyBzZWdtZW50TGVuZ3RoRnJhY3Rpb24gKiAodGhpcy5wMS54IC0gdGhpcy5wMC54KTtcbiAgY29vcmQueSA9IHRoaXMucDAueSArIHNlZ21lbnRMZW5ndGhGcmFjdGlvbiAqICh0aGlzLnAxLnkgLSB0aGlzLnAwLnkpO1xuICByZXR1cm4gY29vcmRcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHZhciBiaXRzMCA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7XG4gIGJpdHMwIF49IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSkgKiAzMTtcbiAgdmFyIGhhc2gwID0gTWF0aC50cnVuYyhiaXRzMCkgXiBNYXRoLnRydW5jKGJpdHMwID4+IDMyKTtcbiAgdmFyIGJpdHMxID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS54KTtcbiAgYml0czEgXj0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KSAqIDMxO1xuICB2YXIgaGFzaDEgPSBNYXRoLnRydW5jKGJpdHMxKSBeIE1hdGgudHJ1bmMoYml0czEgPj4gMzIpO1xuICByZXR1cm4gaGFzaDAgXiBoYXNoMVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZVNlZ21lbnRcbn07XG5MaW5lU2VnbWVudC5taWRQb2ludCA9IGZ1bmN0aW9uIG1pZFBvaW50IChwMCwgcDEpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKChwMC54ICsgcDEueCkgLyAyLCAocDAueSArIHAxLnkpIC8gMilcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjQuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMjUyMDA1ODMzNDY2MjU2MjI3IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lU2VnbWVudCwgc3RhdGljQWNjZXNzb3JzJDI0ICk7XG5cbnZhciBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uICgpIHtcbiAgdGhpcy50ZW1wRW52MSA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLnRlbXBFbnYyID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMuX292ZXJsYXBTZWcxID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX292ZXJsYXBTZWcyID0gbmV3IExpbmVTZWdtZW50KCk7XG59O1xuTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLm92ZXJsYXAgPSBmdW5jdGlvbiBvdmVybGFwICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBjb25zdCBzZWcxID0gYXJndW1lbnRzWzBdXG4gICAgLy8gY29uc3Qgc2VnMiA9IGFyZ3VtZW50c1sxXVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgbWMxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgc3RhcnQyID0gYXJndW1lbnRzWzNdO1xuICAgIG1jMS5nZXRMaW5lU2VnbWVudChzdGFydDEsIHRoaXMuX292ZXJsYXBTZWcxKTtcbiAgICBtYzIuZ2V0TGluZVNlZ21lbnQoc3RhcnQyLCB0aGlzLl9vdmVybGFwU2VnMik7XG4gICAgdGhpcy5vdmVybGFwKHRoaXMuX292ZXJsYXBTZWcxLCB0aGlzLl9vdmVybGFwU2VnMik7XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uXG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW4gKCkge1xuICB0aGlzLl9wdHMgPSBudWxsO1xuICB0aGlzLl9zdGFydCA9IG51bGw7XG4gIHRoaXMuX2VuZCA9IG51bGw7XG4gIHRoaXMuX2VudiA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICB0aGlzLl9pZCA9IG51bGw7XG4gIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gIHZhciBzdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM107XG4gIHRoaXMuX3B0cyA9IHB0cztcbiAgdGhpcy5fc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5fZW5kID0gZW5kO1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uIGdldExpbmVTZWdtZW50IChpbmRleCwgbHMpIHtcbiAgbHMucDAgPSB0aGlzLl9wdHNbaW5kZXhdO1xuICBscy5wMSA9IHRoaXMuX3B0c1tpbmRleCArIDFdO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmNvbXB1dGVTZWxlY3QgPSBmdW5jdGlvbiBjb21wdXRlU2VsZWN0IChzZWFyY2hFbnYsIHN0YXJ0MCwgZW5kMCwgbWNzKSB7XG4gIHZhciBwMCA9IHRoaXMuX3B0c1tzdGFydDBdO1xuICB2YXIgcDEgPSB0aGlzLl9wdHNbZW5kMF07XG4gIG1jcy50ZW1wRW52MS5pbml0KHAwLCBwMSk7XG4gIGlmIChlbmQwIC0gc3RhcnQwID09PSAxKSB7XG4gICAgbWNzLnNlbGVjdCh0aGlzLCBzdGFydDApO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKCFzZWFyY2hFbnYuaW50ZXJzZWN0cyhtY3MudGVtcEVudjEpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG1pZCA9IE1hdGgudHJ1bmMoKHN0YXJ0MCArIGVuZDApIC8gMik7XG4gIGlmIChzdGFydDAgPCBtaWQpIHtcbiAgICB0aGlzLmNvbXB1dGVTZWxlY3Qoc2VhcmNoRW52LCBzdGFydDAsIG1pZCwgbWNzKTtcbiAgfVxuICBpZiAobWlkIDwgZW5kMCkge1xuICAgIHRoaXMuY29tcHV0ZVNlbGVjdChzZWFyY2hFbnYsIG1pZCwgZW5kMCwgbWNzKTtcbiAgfVxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZCA9IG5ldyBBcnJheSh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCArIDEpLmZpbGwobnVsbCk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9zdGFydDsgaSA8PSB0aGlzLl9lbmQ7IGkrKykge1xuICAgIGNvb3JkW2luZGV4KytdID0gdGhpcyQxLl9wdHNbaV07XG4gIH1cbiAgcmV0dXJuIGNvb3JkXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuY29tcHV0ZU92ZXJsYXBzID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXBzIChtYywgbWNvKSB7XG4gIHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodGhpcy5fc3RhcnQsIHRoaXMuX2VuZCwgbWMsIG1jLl9zdGFydCwgbWMuX2VuZCwgbWNvKTtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICB0aGlzLl9pZCA9IGlkO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCAoc2VhcmNoRW52LCBtY3MpIHtcbiAgdGhpcy5jb21wdXRlU2VsZWN0KHNlYXJjaEVudiwgdGhpcy5fc3RhcnQsIHRoaXMuX2VuZCwgbWNzKTtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldEVudmVsb3BlICgpIHtcbiAgaWYgKHRoaXMuX2VudiA9PT0gbnVsbCkge1xuICAgIHZhciBwMCA9IHRoaXMuX3B0c1t0aGlzLl9zdGFydF07XG4gICAgdmFyIHAxID0gdGhpcy5fcHRzW3RoaXMuX2VuZF07XG4gICAgdGhpcy5fZW52ID0gbmV3IEVudmVsb3BlKHAwLCBwMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VudlxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldEVuZEluZGV4ID0gZnVuY3Rpb24gZ2V0RW5kSW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fZW5kXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0U3RhcnRJbmRleCA9IGZ1bmN0aW9uIGdldFN0YXJ0SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fc3RhcnRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoKSB7XG4gIHJldHVybiB0aGlzLl9jb250ZXh0XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pZFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmNvbXB1dGVPdmVybGFwc0ludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwgKHN0YXJ0MCwgZW5kMCwgbWMsIHN0YXJ0MSwgZW5kMSwgbWNvKSB7XG4gIHZhciBwMDAgPSB0aGlzLl9wdHNbc3RhcnQwXTtcbiAgdmFyIHAwMSA9IHRoaXMuX3B0c1tlbmQwXTtcbiAgdmFyIHAxMCA9IG1jLl9wdHNbc3RhcnQxXTtcbiAgdmFyIHAxMSA9IG1jLl9wdHNbZW5kMV07XG4gIGlmIChlbmQwIC0gc3RhcnQwID09PSAxICYmIGVuZDEgLSBzdGFydDEgPT09IDEpIHtcbiAgICBtY28ub3ZlcmxhcCh0aGlzLCBzdGFydDAsIG1jLCBzdGFydDEpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbWNvLnRlbXBFbnYxLmluaXQocDAwLCBwMDEpO1xuICBtY28udGVtcEVudjIuaW5pdChwMTAsIHAxMSk7XG4gIGlmICghbWNvLnRlbXBFbnYxLmludGVyc2VjdHMobWNvLnRlbXBFbnYyKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBtaWQwID0gTWF0aC50cnVuYygoc3RhcnQwICsgZW5kMCkgLyAyKTtcbiAgdmFyIG1pZDEgPSBNYXRoLnRydW5jKChzdGFydDEgKyBlbmQxKSAvIDIpO1xuICBpZiAoc3RhcnQwIDwgbWlkMCkge1xuICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoc3RhcnQwLCBtaWQwLCBtYywgc3RhcnQxLCBtaWQxLCBtY28pOyB9XG4gICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoc3RhcnQwLCBtaWQwLCBtYywgbWlkMSwgZW5kMSwgbWNvKTsgfVxuICB9XG4gIGlmIChtaWQwIDwgZW5kMCkge1xuICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwobWlkMCwgZW5kMCwgbWMsIHN0YXJ0MSwgbWlkMSwgbWNvKTsgfVxuICAgIGlmIChtaWQxIDwgZW5kMSkgeyB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKG1pZDAsIGVuZDAsIG1jLCBtaWQxLCBlbmQxLCBtY28pOyB9XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluXG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbkJ1aWxkZXIgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluQnVpbGRlciAoKSB7fTtcblxuTW9ub3RvbmVDaGFpbkJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluQnVpbGRlclxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWluU3RhcnRJbmRpY2VzID0gZnVuY3Rpb24gZ2V0Q2hhaW5TdGFydEluZGljZXMgKHB0cykge1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgc3RhcnRJbmRleExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHN0YXJ0SW5kZXhMaXN0LmFkZChuZXcgSW50ZWdlcihzdGFydCkpO1xuICBkbyB7XG4gICAgdmFyIGxhc3QgPSBNb25vdG9uZUNoYWluQnVpbGRlci5maW5kQ2hhaW5FbmQocHRzLCBzdGFydCk7XG4gICAgc3RhcnRJbmRleExpc3QuYWRkKG5ldyBJbnRlZ2VyKGxhc3QpKTtcbiAgICBzdGFydCA9IGxhc3Q7XG4gIH0gd2hpbGUgKHN0YXJ0IDwgcHRzLmxlbmd0aCAtIDEpXG4gIHZhciBzdGFydEluZGV4ID0gTW9ub3RvbmVDaGFpbkJ1aWxkZXIudG9JbnRBcnJheShzdGFydEluZGV4TGlzdCk7XG4gIHJldHVybiBzdGFydEluZGV4XG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZmluZENoYWluRW5kID0gZnVuY3Rpb24gZmluZENoYWluRW5kIChwdHMsIHN0YXJ0KSB7XG4gIHZhciBzYWZlU3RhcnQgPSBzdGFydDtcbiAgd2hpbGUgKHNhZmVTdGFydCA8IHB0cy5sZW5ndGggLSAxICYmIHB0c1tzYWZlU3RhcnRdLmVxdWFsczJEKHB0c1tzYWZlU3RhcnQgKyAxXSkpIHtcbiAgICBzYWZlU3RhcnQrKztcbiAgfVxuICBpZiAoc2FmZVN0YXJ0ID49IHB0cy5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHB0cy5sZW5ndGggLSAxXG4gIH1cbiAgdmFyIGNoYWluUXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tzYWZlU3RhcnRdLCBwdHNbc2FmZVN0YXJ0ICsgMV0pO1xuICB2YXIgbGFzdCA9IHN0YXJ0ICsgMTtcbiAgd2hpbGUgKGxhc3QgPCBwdHMubGVuZ3RoKSB7XG4gICAgaWYgKCFwdHNbbGFzdCAtIDFdLmVxdWFsczJEKHB0c1tsYXN0XSkpIHtcbiAgICAgIHZhciBxdWFkID0gUXVhZHJhbnQucXVhZHJhbnQocHRzW2xhc3QgLSAxXSwgcHRzW2xhc3RdKTtcbiAgICAgIGlmIChxdWFkICE9PSBjaGFpblF1YWQpIHsgYnJlYWsgfVxuICAgIH1cbiAgICBsYXN0Kys7XG4gIH1cbiAgcmV0dXJuIGxhc3QgLSAxXG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5zID0gZnVuY3Rpb24gZ2V0Q2hhaW5zICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBNb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpbnMocHRzLCBudWxsKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcHRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IE1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWluU3RhcnRJbmRpY2VzKHB0cyQxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgbWMgPSBuZXcgTW9ub3RvbmVDaGFpbihwdHMkMSwgc3RhcnRJbmRleFtpXSwgc3RhcnRJbmRleFtpICsgMV0sIGNvbnRleHQpO1xuICAgICAgbWNMaXN0LmFkZChtYyk7XG4gICAgfVxuICAgIHJldHVybiBtY0xpc3RcbiAgfVxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLnRvSW50QXJyYXkgPSBmdW5jdGlvbiB0b0ludEFycmF5IChsaXN0KSB7XG4gIHZhciBhcnJheSA9IG5ldyBBcnJheShsaXN0LnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gbGlzdC5nZXQoaSkuaW50VmFsdWUoKTtcbiAgfVxuICByZXR1cm4gYXJyYXlcbn07XG5cbnZhciBOb2RlciA9IGZ1bmN0aW9uIE5vZGVyICgpIHt9O1xuXG5Ob2Rlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChzZWdTdHJpbmdzKSB7fTtcbk5vZGVyLnByb3RvdHlwZS5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge307XG5Ob2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVyXG59O1xuXG52YXIgU2luZ2xlUGFzc05vZGVyID0gZnVuY3Rpb24gU2luZ2xlUGFzc05vZGVyICgpIHtcbiAgdGhpcy5fc2VnSW50ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VnSW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHNlZ0ludCk7XG4gIH1cbn07XG5TaW5nbGVQYXNzTm9kZXIucHJvdG90eXBlLnNldFNlZ21lbnRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIHNldFNlZ21lbnRJbnRlcnNlY3RvciAoc2VnSW50KSB7XG4gIHRoaXMuX3NlZ0ludCA9IHNlZ0ludDtcbn07XG5TaW5nbGVQYXNzTm9kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW05vZGVyXVxufTtcblNpbmdsZVBhc3NOb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTaW5nbGVQYXNzTm9kZXJcbn07XG5cbnZhciBNQ0luZGV4Tm9kZXIgPSAoZnVuY3Rpb24gKFNpbmdsZVBhc3NOb2RlciQkMSkge1xuICBmdW5jdGlvbiBNQ0luZGV4Tm9kZXIgKHNpKSB7XG4gICAgaWYgKHNpKSB7IFNpbmdsZVBhc3NOb2RlciQkMS5jYWxsKHRoaXMsIHNpKTsgfVxuICAgIGVsc2UgeyBTaW5nbGVQYXNzTm9kZXIkJDEuY2FsbCh0aGlzKTsgfVxuICAgIHRoaXMuX21vbm9DaGFpbnMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5faW5kZXggPSBuZXcgU1RSdHJlZSgpO1xuICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gbnVsbDtcbiAgICB0aGlzLl9uT3ZlcmxhcHMgPSAwO1xuICB9XG5cbiAgaWYgKCBTaW5nbGVQYXNzTm9kZXIkJDEgKSBNQ0luZGV4Tm9kZXIuX19wcm90b19fID0gU2luZ2xlUGFzc05vZGVyJCQxO1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2luZ2xlUGFzc05vZGVyJCQxICYmIFNpbmdsZVBhc3NOb2RlciQkMS5wcm90b3R5cGUgKTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1DSW5kZXhOb2RlcjtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBTZWdtZW50T3ZlcmxhcEFjdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmdldE1vbm90b25lQ2hhaW5zID0gZnVuY3Rpb24gZ2V0TW9ub3RvbmVDaGFpbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb25vQ2hhaW5zXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgICByZXR1cm4gTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiBnZXRJbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChzZWdTdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzZWdDaGFpbnMgPSBNb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpbnMoc2VnU3RyLmdldENvb3JkaW5hdGVzKCksIHNlZ1N0cik7XG4gICAgZm9yICh2YXIgaSA9IHNlZ0NoYWlucy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBtYyA9IGkubmV4dCgpO1xuICAgICAgbWMuc2V0SWQodGhpcyQxLl9pZENvdW50ZXIrKyk7XG4gICAgICB0aGlzJDEuX2luZGV4Lmluc2VydChtYy5nZXRFbnZlbG9wZSgpLCBtYyk7XG4gICAgICB0aGlzJDEuX21vbm9DaGFpbnMuYWRkKG1jKTtcbiAgICB9XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChpbnB1dFNlZ1N0cmluZ3MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuX25vZGVkU2VnU3RyaW5ncyA9IGlucHV0U2VnU3RyaW5ncztcbiAgICBmb3IgKHZhciBpID0gaW5wdXRTZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJzZWN0Q2hhaW5zKCk7XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuaW50ZXJzZWN0Q2hhaW5zID0gZnVuY3Rpb24gaW50ZXJzZWN0Q2hhaW5zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvdmVybGFwQWN0aW9uID0gbmV3IFNlZ21lbnRPdmVybGFwQWN0aW9uKHRoaXMuX3NlZ0ludCk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX21vbm9DaGFpbnMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgcXVlcnlDaGFpbiA9IGkubmV4dCgpO1xuICAgICAgdmFyIG92ZXJsYXBDaGFpbnMgPSB0aGlzJDEuX2luZGV4LnF1ZXJ5KHF1ZXJ5Q2hhaW4uZ2V0RW52ZWxvcGUoKSk7XG4gICAgICBmb3IgKHZhciBqID0gb3ZlcmxhcENoYWlucy5pdGVyYXRvcigpOyBqLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIHRlc3RDaGFpbiA9IGoubmV4dCgpO1xuICAgICAgICBpZiAodGVzdENoYWluLmdldElkKCkgPiBxdWVyeUNoYWluLmdldElkKCkpIHtcbiAgICAgICAgICBxdWVyeUNoYWluLmNvbXB1dGVPdmVybGFwcyh0ZXN0Q2hhaW4sIG92ZXJsYXBBY3Rpb24pO1xuICAgICAgICAgIHRoaXMkMS5fbk92ZXJsYXBzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMkMS5fc2VnSW50LmlzRG9uZSgpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE1DSW5kZXhOb2RlclxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuU2VnbWVudE92ZXJsYXBBY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VnbWVudE92ZXJsYXBBY3Rpb24gfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTUNJbmRleE5vZGVyLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTUNJbmRleE5vZGVyO1xufShTaW5nbGVQYXNzTm9kZXIpKTtcblxudmFyIFNlZ21lbnRPdmVybGFwQWN0aW9uID0gKGZ1bmN0aW9uIChNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBTZWdtZW50T3ZlcmxhcEFjdGlvbiAoKSB7XG4gICAgTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zaSA9IG51bGw7XG4gICAgdmFyIHNpID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX3NpID0gc2k7XG4gIH1cblxuICBpZiAoIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxICkgU2VnbWVudE92ZXJsYXBBY3Rpb24uX19wcm90b19fID0gTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDE7XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxICYmIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWdtZW50T3ZlcmxhcEFjdGlvbjtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLm92ZXJsYXAgPSBmdW5jdGlvbiBvdmVybGFwICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIG1jMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbWMyID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHN0YXJ0MiA9IGFyZ3VtZW50c1szXTtcbiAgICAgIHZhciBzczEgPSBtYzEuZ2V0Q29udGV4dCgpO1xuICAgICAgdmFyIHNzMiA9IG1jMi5nZXRDb250ZXh0KCk7XG4gICAgICB0aGlzLl9zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhzczEsIHN0YXJ0MSwgc3MyLCBzdGFydDIpO1xuICAgIH0gZWxzZSB7IHJldHVybiBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMS5wcm90b3R5cGUub3ZlcmxhcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNlZ21lbnRPdmVybGFwQWN0aW9uXG4gIH07XG5cbiAgcmV0dXJuIFNlZ21lbnRPdmVybGFwQWN0aW9uO1xufShNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbikpO1xuXG52YXIgQnVmZmVyUGFyYW1ldGVycyA9IGZ1bmN0aW9uIEJ1ZmZlclBhcmFtZXRlcnMgKCkge1xuICB0aGlzLl9xdWFkcmFudFNlZ21lbnRzID0gQnVmZmVyUGFyYW1ldGVycy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTO1xuICB0aGlzLl9lbmRDYXBTdHlsZSA9IEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EO1xuICB0aGlzLl9qb2luU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fUk9VTkQ7XG4gIHRoaXMuX21pdHJlTGltaXQgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfTUlUUkVfTElNSVQ7XG4gIHRoaXMuX2lzU2luZ2xlU2lkZWQgPSBmYWxzZTtcbiAgdGhpcy5fc2ltcGxpZnlGYWN0b3IgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBlbmRDYXBTdHlsZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyQxKTtcbiAgICB0aGlzLnNldEVuZENhcFN0eWxlKGVuZENhcFN0eWxlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZW5kQ2FwU3R5bGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgam9pblN0eWxlID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBtaXRyZUxpbWl0ID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzJDIpO1xuICAgIHRoaXMuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUkMSk7XG4gICAgdGhpcy5zZXRKb2luU3R5bGUoam9pblN0eWxlKTtcbiAgICB0aGlzLnNldE1pdHJlTGltaXQobWl0cmVMaW1pdCk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjUgPSB7IENBUF9ST1VORDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfRkxBVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfU1FVQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEpPSU5fUk9VTkQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSk9JTl9NSVRSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxKT0lOX0JFVkVMOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9NSVRSRV9MSU1JVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0RW5kQ2FwU3R5bGUgPSBmdW5jdGlvbiBnZXRFbmRDYXBTdHlsZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lbmRDYXBTdHlsZVxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmlzU2luZ2xlU2lkZWQgPSBmdW5jdGlvbiBpc1NpbmdsZVNpZGVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWRcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRRdWFkcmFudFNlZ21lbnRzID0gZnVuY3Rpb24gc2V0UXVhZHJhbnRTZWdtZW50cyAocXVhZFNlZ3MpIHtcbiAgdGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9IHF1YWRTZWdzO1xuICBpZiAodGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9PT0gMCkgeyB0aGlzLl9qb2luU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fQkVWRUw7IH1cbiAgaWYgKHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPCAwKSB7XG4gICAgdGhpcy5fam9pblN0eWxlID0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX01JVFJFO1xuICAgIHRoaXMuX21pdHJlTGltaXQgPSBNYXRoLmFicyh0aGlzLl9xdWFkcmFudFNlZ21lbnRzKTtcbiAgfVxuICBpZiAocXVhZFNlZ3MgPD0gMCkge1xuICAgIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSAxO1xuICB9XG4gIGlmICh0aGlzLl9qb2luU3R5bGUgIT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9ST1VORCkge1xuICAgIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM7XG4gIH1cbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRKb2luU3R5bGUgPSBmdW5jdGlvbiBnZXRKb2luU3R5bGUgKCkge1xuICByZXR1cm4gdGhpcy5fam9pblN0eWxlXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0Sm9pblN0eWxlID0gZnVuY3Rpb24gc2V0Sm9pblN0eWxlIChqb2luU3R5bGUpIHtcbiAgdGhpcy5fam9pblN0eWxlID0gam9pblN0eWxlO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldFNpbXBsaWZ5RmFjdG9yID0gZnVuY3Rpb24gc2V0U2ltcGxpZnlGYWN0b3IgKHNpbXBsaWZ5RmFjdG9yKSB7XG4gIHRoaXMuX3NpbXBsaWZ5RmFjdG9yID0gc2ltcGxpZnlGYWN0b3IgPCAwID8gMCA6IHNpbXBsaWZ5RmFjdG9yO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldFNpbXBsaWZ5RmFjdG9yID0gZnVuY3Rpb24gZ2V0U2ltcGxpZnlGYWN0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fc2ltcGxpZnlGYWN0b3Jcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRRdWFkcmFudFNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0UXVhZHJhbnRTZWdtZW50cyAoKSB7XG4gIHJldHVybiB0aGlzLl9xdWFkcmFudFNlZ21lbnRzXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0RW5kQ2FwU3R5bGUgPSBmdW5jdGlvbiBzZXRFbmRDYXBTdHlsZSAoZW5kQ2FwU3R5bGUpIHtcbiAgdGhpcy5fZW5kQ2FwU3R5bGUgPSBlbmRDYXBTdHlsZTtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRNaXRyZUxpbWl0ID0gZnVuY3Rpb24gZ2V0TWl0cmVMaW1pdCAoKSB7XG4gIHJldHVybiB0aGlzLl9taXRyZUxpbWl0XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0TWl0cmVMaW1pdCA9IGZ1bmN0aW9uIHNldE1pdHJlTGltaXQgKG1pdHJlTGltaXQpIHtcbiAgdGhpcy5fbWl0cmVMaW1pdCA9IG1pdHJlTGltaXQ7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0U2luZ2xlU2lkZWQgPSBmdW5jdGlvbiBzZXRTaW5nbGVTaWRlZCAoaXNTaW5nbGVTaWRlZCkge1xuICB0aGlzLl9pc1NpbmdsZVNpZGVkID0gaXNTaW5nbGVTaWRlZDtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzXG59O1xuQnVmZmVyUGFyYW1ldGVycy5idWZmZXJEaXN0YW5jZUVycm9yID0gZnVuY3Rpb24gYnVmZmVyRGlzdGFuY2VFcnJvciAocXVhZFNlZ3MpIHtcbiAgdmFyIGFscGhhID0gTWF0aC5QSSAvIDIuMCAvIHF1YWRTZWdzO1xuICByZXR1cm4gMSAtIE1hdGguY29zKGFscGhhIC8gMi4wKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5DQVBfUk9VTkQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkNBUF9GTEFULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5DQVBfU1FVQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX1JPVU5ELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX01JVFJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX0JFVkVMLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDggfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5ERUZBVUxUX01JVFJFX0xJTUlULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDUuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlclBhcmFtZXRlcnMsIHN0YXRpY0FjY2Vzc29ycyQyNSApO1xuXG52YXIgQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllciA9IGZ1bmN0aW9uIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIgKGlucHV0TGluZSkge1xuICB0aGlzLl9kaXN0YW5jZVRvbCA9IG51bGw7XG4gIHRoaXMuX2lzRGVsZXRlZCA9IG51bGw7XG4gIHRoaXMuX2FuZ2xlT3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRTtcbiAgdGhpcy5faW5wdXRMaW5lID0gaW5wdXRMaW5lIHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI2ID0geyBJTklUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFTEVURTogeyBjb25maWd1cmFibGU6IHRydWUgfSxLRUVQOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5VTV9QVFNfVE9fQ0hFQ0s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzRGVsZXRhYmxlID0gZnVuY3Rpb24gaXNEZWxldGFibGUgKGkwLCBpMSwgaTIsIGRpc3RhbmNlVG9sKSB7XG4gIHZhciBwMCA9IHRoaXMuX2lucHV0TGluZVtpMF07XG4gIHZhciBwMSA9IHRoaXMuX2lucHV0TGluZVtpMV07XG4gIHZhciBwMiA9IHRoaXMuX2lucHV0TGluZVtpMl07XG4gIGlmICghdGhpcy5pc0NvbmNhdmUocDAsIHAxLCBwMikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCF0aGlzLmlzU2hhbGxvdyhwMCwgcDEsIHAyLCBkaXN0YW5jZVRvbCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRoaXMuaXNTaGFsbG93U2FtcGxlZChwMCwgcDEsIGkwLCBpMiwgZGlzdGFuY2VUb2wpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzID0gZnVuY3Rpb24gZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaW5kZXggPSAxO1xuICAvLyBjb25zdCBtYXhJbmRleCA9IHRoaXMuX2lucHV0TGluZS5sZW5ndGggLSAxXG4gIHZhciBtaWRJbmRleCA9IHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoaW5kZXgpO1xuICB2YXIgbGFzdEluZGV4ID0gdGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChtaWRJbmRleCk7XG4gIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgd2hpbGUgKGxhc3RJbmRleCA8IHRoaXMuX2lucHV0TGluZS5sZW5ndGgpIHtcbiAgICB2YXIgaXNNaWRkbGVWZXJ0ZXhEZWxldGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMkMS5pc0RlbGV0YWJsZShpbmRleCwgbWlkSW5kZXgsIGxhc3RJbmRleCwgdGhpcyQxLl9kaXN0YW5jZVRvbCkpIHtcbiAgICAgIHRoaXMkMS5faXNEZWxldGVkW21pZEluZGV4XSA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFO1xuICAgICAgaXNNaWRkbGVWZXJ0ZXhEZWxldGVkID0gdHJ1ZTtcbiAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc01pZGRsZVZlcnRleERlbGV0ZWQpIHsgaW5kZXggPSBsYXN0SW5kZXg7IH0gZWxzZSB7IGluZGV4ID0gbWlkSW5kZXg7IH1cbiAgICBtaWRJbmRleCA9IHRoaXMkMS5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChpbmRleCk7XG4gICAgbGFzdEluZGV4ID0gdGhpcyQxLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KG1pZEluZGV4KTtcbiAgfVxuICByZXR1cm4gaXNDaGFuZ2VkXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNTaGFsbG93Q29uY2F2aXR5ID0gZnVuY3Rpb24gaXNTaGFsbG93Q29uY2F2aXR5IChwMCwgcDEsIHAyLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgb3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHAwLCBwMSwgcDIpO1xuICB2YXIgaXNBbmdsZVRvU2ltcGxpZnkgPSBvcmllbnRhdGlvbiA9PT0gdGhpcy5fYW5nbGVPcmllbnRhdGlvbjtcbiAgaWYgKCFpc0FuZ2xlVG9TaW1wbGlmeSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMSwgcDAsIHAyKTtcbiAgcmV0dXJuIGRpc3QgPCBkaXN0YW5jZVRvbFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzU2hhbGxvd1NhbXBsZWQgPSBmdW5jdGlvbiBpc1NoYWxsb3dTYW1wbGVkIChwMCwgcDIsIGkwLCBpMiwgZGlzdGFuY2VUb2wpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaW5jID0gTWF0aC50cnVuYygoaTIgLSBpMCkgLyBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLk5VTV9QVFNfVE9fQ0hFQ0spO1xuICBpZiAoaW5jIDw9IDApIHsgaW5jID0gMTsgfVxuICBmb3IgKHZhciBpID0gaTA7IGkgPCBpMjsgaSArPSBpbmMpIHtcbiAgICBpZiAoIXRoaXMkMS5pc1NoYWxsb3cocDAsIHAyLCB0aGlzJDEuX2lucHV0TGluZVtpXSwgZGlzdGFuY2VUb2wpKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc0NvbmNhdmUgPSBmdW5jdGlvbiBpc0NvbmNhdmUgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwMCwgcDEsIHAyKTtcbiAgdmFyIGlzQ29uY2F2ZSA9IG9yaWVudGF0aW9uID09PSB0aGlzLl9hbmdsZU9yaWVudGF0aW9uO1xuICByZXR1cm4gaXNDb25jYXZlXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuc2ltcGxpZnkgPSBmdW5jdGlvbiBzaW1wbGlmeSAoZGlzdGFuY2VUb2wpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9kaXN0YW5jZVRvbCA9IE1hdGguYWJzKGRpc3RhbmNlVG9sKTtcbiAgaWYgKGRpc3RhbmNlVG9sIDwgMCkgeyB0aGlzLl9hbmdsZU9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRTsgfVxuICB0aGlzLl9pc0RlbGV0ZWQgPSBuZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICBkbyB7XG4gICAgaXNDaGFuZ2VkID0gdGhpcyQxLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpO1xuICB9IHdoaWxlIChpc0NoYW5nZWQpXG4gIHJldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuZmluZE5leHROb25EZWxldGVkSW5kZXggPSBmdW5jdGlvbiBmaW5kTmV4dE5vbkRlbGV0ZWRJbmRleCAoaW5kZXgpIHtcbiAgdmFyIG5leHQgPSBpbmRleCArIDE7XG4gIHdoaWxlIChuZXh0IDwgdGhpcy5faW5wdXRMaW5lLmxlbmd0aCAmJiB0aGlzLl9pc0RlbGV0ZWRbbmV4dF0gPT09IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFKSB7IG5leHQrKzsgfVxuICByZXR1cm4gbmV4dFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzU2hhbGxvdyA9IGZ1bmN0aW9uIGlzU2hhbGxvdyAocDAsIHAxLCBwMiwgZGlzdGFuY2VUb2wpIHtcbiAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocDEsIHAwLCBwMik7XG4gIHJldHVybiBkaXN0IDwgZGlzdGFuY2VUb2xcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5jb2xsYXBzZUxpbmUgPSBmdW5jdGlvbiBjb2xsYXBzZUxpbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnB1dExpbmUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9pc0RlbGV0ZWRbaV0gIT09IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFKSB7IGNvb3JkTGlzdC5hZGQodGhpcyQxLl9pbnB1dExpbmVbaV0pOyB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllclxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkgPSBmdW5jdGlvbiBzaW1wbGlmeSAoaW5wdXRMaW5lLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgc2ltcCA9IG5ldyBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyKGlucHV0TGluZSk7XG4gIHJldHVybiBzaW1wLnNpbXBsaWZ5KGRpc3RhbmNlVG9sKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5JTklULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5ERUxFVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI2LktFRVAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI2Lk5VTV9QVFNfVE9fQ0hFQ0suZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIsIHN0YXRpY0FjY2Vzc29ycyQyNiApO1xuXG52YXIgT2Zmc2V0U2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIE9mZnNldFNlZ21lbnRTdHJpbmcgKCkge1xuICB0aGlzLl9wdExpc3QgPSBudWxsO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZSA9IDAuMDtcbiAgdGhpcy5fcHRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyOCA9IHsgQ09PUkRJTkFURV9BUlJBWV9UWVBFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgdmFyIGNvb3JkID0gdGhpcy5fcHRMaXN0LnRvQXJyYXkoT2Zmc2V0U2VnbWVudFN0cmluZy5DT09SRElOQVRFX0FSUkFZX1RZUEUpO1xuICByZXR1cm4gY29vcmRcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIHNldFByZWNpc2lvbk1vZGVsIChwcmVjaXNpb25Nb2RlbCkge1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZFB0ID0gZnVuY3Rpb24gYWRkUHQgKHB0KSB7XG4gIHZhciBidWZQdCA9IG5ldyBDb29yZGluYXRlKHB0KTtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoYnVmUHQpO1xuICBpZiAodGhpcy5pc1JlZHVuZGFudChidWZQdCkpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9wdExpc3QuYWRkKGJ1ZlB0KTtcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5yZXZlcmUgPSBmdW5jdGlvbiByZXZlcmUgKCkge307XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRQdHMgPSBmdW5jdGlvbiBhZGRQdHMgKHB0LCBpc0ZvcndhcmQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaXNGb3J3YXJkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcyQxLmFkZFB0KHB0W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSQxID0gcHQubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB0aGlzJDEuYWRkUHQocHRbaSQxXSk7XG4gICAgfVxuICB9XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNSZWR1bmRhbnQgPSBmdW5jdGlvbiBpc1JlZHVuZGFudCAocHQpIHtcbiAgaWYgKHRoaXMuX3B0TGlzdC5zaXplKCkgPCAxKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBsYXN0UHQgPSB0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCkgLSAxKTtcbiAgdmFyIHB0RGlzdCA9IHB0LmRpc3RhbmNlKGxhc3RQdCk7XG4gIGlmIChwdERpc3QgPCB0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2UpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGZhY3QgPSBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG4gIHZhciBsaW5lID0gZmFjdC5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIHJldHVybiBsaW5lLnRvU3RyaW5nKClcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5jbG9zZVJpbmcgPSBmdW5jdGlvbiBjbG9zZVJpbmcgKCkge1xuICBpZiAodGhpcy5fcHRMaXN0LnNpemUoKSA8IDEpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgc3RhcnRQdCA9IG5ldyBDb29yZGluYXRlKHRoaXMuX3B0TGlzdC5nZXQoMCkpO1xuICB2YXIgbGFzdFB0ID0gdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpIC0gMSk7XG4gIC8vIGNvbnN0IGxhc3QyUHQgPSBudWxsXG4gIC8vIGlmICh0aGlzLl9wdExpc3Quc2l6ZSgpID49IDIpIGxhc3QyUHQgPSB0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCkgLSAyKVxuICBpZiAoc3RhcnRQdC5lcXVhbHMobGFzdFB0KSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX3B0TGlzdC5hZGQoc3RhcnRQdCk7XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0TWluaW11bVZlcnRleERpc3RhbmNlID0gZnVuY3Rpb24gc2V0TWluaW11bVZlcnRleERpc3RhbmNlIChtaW5pbWltVmVydGV4RGlzdGFuY2UpIHtcbiAgdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlID0gbWluaW1pbVZlcnRleERpc3RhbmNlO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldFNlZ21lbnRTdHJpbmdcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjguQ09PUkRJTkFURV9BUlJBWV9UWVBFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBcnJheSgwKS5maWxsKG51bGwpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPZmZzZXRTZWdtZW50U3RyaW5nLCBzdGF0aWNBY2Nlc3NvcnMkMjggKTtcblxudmFyIEFuZ2xlID0gZnVuY3Rpb24gQW5nbGUgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjkgPSB7IFBJX1RJTUVTXzI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUElfT1ZFUl8yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBJX09WRVJfNDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT1VOVEVSQ0xPQ0tXSVNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxOT05FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkFuZ2xlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQW5nbGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQW5nbGVcbn07XG5BbmdsZS50b0RlZ3JlZXMgPSBmdW5jdGlvbiB0b0RlZ3JlZXMgKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJXG59O1xuQW5nbGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplIChhbmdsZSkge1xuICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJKSB7IGFuZ2xlIC09IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgd2hpbGUgKGFuZ2xlIDw9IC1NYXRoLlBJKSB7IGFuZ2xlICs9IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgcmV0dXJuIGFuZ2xlXG59O1xuQW5nbGUuYW5nbGUgPSBmdW5jdGlvbiBhbmdsZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocC55LCBwLngpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoZHksIGR4KVxuICB9XG59O1xuQW5nbGUuaXNBY3V0ZSA9IGZ1bmN0aW9uIGlzQWN1dGUgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGR4MCA9IHAwLnggLSBwMS54O1xuICB2YXIgZHkwID0gcDAueSAtIHAxLnk7XG4gIHZhciBkeDEgPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5MSA9IHAyLnkgLSBwMS55O1xuICB2YXIgZG90cHJvZCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgcmV0dXJuIGRvdHByb2QgPiAwXG59O1xuQW5nbGUuaXNPYnR1c2UgPSBmdW5jdGlvbiBpc09idHVzZSAocDAsIHAxLCBwMikge1xuICB2YXIgZHgwID0gcDAueCAtIHAxLng7XG4gIHZhciBkeTAgPSBwMC55IC0gcDEueTtcbiAgdmFyIGR4MSA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkxID0gcDIueSAtIHAxLnk7XG4gIHZhciBkb3Rwcm9kID0gZHgwICogZHgxICsgZHkwICogZHkxO1xuICByZXR1cm4gZG90cHJvZCA8IDBcbn07XG5BbmdsZS5pbnRlcmlvckFuZ2xlID0gZnVuY3Rpb24gaW50ZXJpb3JBbmdsZSAocDAsIHAxLCBwMikge1xuICB2YXIgYW5nbGVQcmV2ID0gQW5nbGUuYW5nbGUocDEsIHAwKTtcbiAgdmFyIGFuZ2xlTmV4dCA9IEFuZ2xlLmFuZ2xlKHAxLCBwMik7XG4gIHJldHVybiBNYXRoLmFicyhhbmdsZU5leHQgLSBhbmdsZVByZXYpXG59O1xuQW5nbGUubm9ybWFsaXplUG9zaXRpdmUgPSBmdW5jdGlvbiBub3JtYWxpemVQb3NpdGl2ZSAoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlIDwgMC4wKSB7XG4gICAgd2hpbGUgKGFuZ2xlIDwgMC4wKSB7IGFuZ2xlICs9IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgICBpZiAoYW5nbGUgPj0gQW5nbGUuUElfVElNRVNfMikgeyBhbmdsZSA9IDAuMDsgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChhbmdsZSA+PSBBbmdsZS5QSV9USU1FU18yKSB7IGFuZ2xlIC09IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgICBpZiAoYW5nbGUgPCAwLjApIHsgYW5nbGUgPSAwLjA7IH1cbiAgfVxuICByZXR1cm4gYW5nbGVcbn07XG5BbmdsZS5hbmdsZUJldHdlZW4gPSBmdW5jdGlvbiBhbmdsZUJldHdlZW4gKHRpcDEsIHRhaWwsIHRpcDIpIHtcbiAgdmFyIGExID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMSk7XG4gIHZhciBhMiA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDIpO1xuICByZXR1cm4gQW5nbGUuZGlmZihhMSwgYTIpXG59O1xuQW5nbGUuZGlmZiA9IGZ1bmN0aW9uIGRpZmYgKGFuZzEsIGFuZzIpIHtcbiAgdmFyIGRlbEFuZ2xlID0gbnVsbDtcbiAgaWYgKGFuZzEgPCBhbmcyKSB7XG4gICAgZGVsQW5nbGUgPSBhbmcyIC0gYW5nMTtcbiAgfSBlbHNlIHtcbiAgICBkZWxBbmdsZSA9IGFuZzEgLSBhbmcyO1xuICB9XG4gIGlmIChkZWxBbmdsZSA+IE1hdGguUEkpIHtcbiAgICBkZWxBbmdsZSA9IDIgKiBNYXRoLlBJIC0gZGVsQW5nbGU7XG4gIH1cbiAgcmV0dXJuIGRlbEFuZ2xlXG59O1xuQW5nbGUudG9SYWRpYW5zID0gZnVuY3Rpb24gdG9SYWRpYW5zIChhbmdsZURlZ3JlZXMpIHtcbiAgcmV0dXJuIGFuZ2xlRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMFxufTtcbkFuZ2xlLmdldFR1cm4gPSBmdW5jdGlvbiBnZXRUdXJuIChhbmcxLCBhbmcyKSB7XG4gIHZhciBjcm9zc3Byb2R1Y3QgPSBNYXRoLnNpbihhbmcyIC0gYW5nMSk7XG4gIGlmIChjcm9zc3Byb2R1Y3QgPiAwKSB7XG4gICAgcmV0dXJuIEFuZ2xlLkNPVU5URVJDTE9DS1dJU0VcbiAgfVxuICBpZiAoY3Jvc3Nwcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBBbmdsZS5DTE9DS1dJU0VcbiAgfVxuICByZXR1cm4gQW5nbGUuTk9ORVxufTtcbkFuZ2xlLmFuZ2xlQmV0d2Vlbk9yaWVudGVkID0gZnVuY3Rpb24gYW5nbGVCZXR3ZWVuT3JpZW50ZWQgKHRpcDEsIHRhaWwsIHRpcDIpIHtcbiAgdmFyIGExID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMSk7XG4gIHZhciBhMiA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDIpO1xuICB2YXIgYW5nRGVsID0gYTIgLSBhMTtcbiAgaWYgKGFuZ0RlbCA8PSAtTWF0aC5QSSkgeyByZXR1cm4gYW5nRGVsICsgQW5nbGUuUElfVElNRVNfMiB9XG4gIGlmIChhbmdEZWwgPiBNYXRoLlBJKSB7IHJldHVybiBhbmdEZWwgLSBBbmdsZS5QSV9USU1FU18yIH1cbiAgcmV0dXJuIGFuZ0RlbFxufTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5QSV9USU1FU18yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIuMCAqIE1hdGguUEkgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5QSV9PVkVSXzIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5QSSAvIDIuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LlBJX09WRVJfNC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLlBJIC8gNC4wIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuQ09VTlRFUkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRSB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuTk9ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09MTElORUFSIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBBbmdsZSwgc3RhdGljQWNjZXNzb3JzJDI5ICk7XG5cbnZhciBPZmZzZXRTZWdtZW50R2VuZXJhdG9yID0gZnVuY3Rpb24gT2Zmc2V0U2VnbWVudEdlbmVyYXRvciAoKSB7XG4gIHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yID0gMC4wO1xuICB0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gPSBudWxsO1xuICB0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID0gMTtcbiAgdGhpcy5fc2VnTGlzdCA9IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5fczAgPSBudWxsO1xuICB0aGlzLl9zMSA9IG51bGw7XG4gIHRoaXMuX3MyID0gbnVsbDtcbiAgdGhpcy5fc2VnMCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9zZWcxID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX29mZnNldDAgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fb2Zmc2V0MSA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9zaWRlID0gMDtcbiAgdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlID0gZmFsc2U7XG4gIHZhciBwcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJ1ZlBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXM7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gPSBNYXRoLlBJIC8gMi4wIC8gYnVmUGFyYW1zLmdldFF1YWRyYW50U2VnbWVudHMoKTtcbiAgaWYgKGJ1ZlBhcmFtcy5nZXRRdWFkcmFudFNlZ21lbnRzKCkgPj0gOCAmJiBidWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9ST1VORCkgeyB0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID0gT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUjsgfVxuICB0aGlzLmluaXQoZGlzdGFuY2UpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyNyA9IHsgT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTmV4dFNlZ21lbnQgPSBmdW5jdGlvbiBhZGROZXh0U2VnbWVudCAocCwgYWRkU3RhcnRQb2ludCkge1xuICB0aGlzLl9zMCA9IHRoaXMuX3MxO1xuICB0aGlzLl9zMSA9IHRoaXMuX3MyO1xuICB0aGlzLl9zMiA9IHA7XG4gIHRoaXMuX3NlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5fczAsIHRoaXMuX3MxKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcwLCB0aGlzLl9zaWRlLCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fb2Zmc2V0MCk7XG4gIHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLCB0aGlzLl9zaWRlLCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fb2Zmc2V0MSk7XG4gIGlmICh0aGlzLl9zMS5lcXVhbHModGhpcy5fczIpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLl9zMCwgdGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdmFyIG91dHNpZGVUdXJuID0gKG9yaWVudGF0aW9uID09PSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFICYmIHRoaXMuX3NpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHx8IChvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UgJiYgdGhpcy5fc2lkZSA9PT0gUG9zaXRpb24uUklHSFQpO1xuICBpZiAob3JpZW50YXRpb24gPT09IDApIHtcbiAgICB0aGlzLmFkZENvbGxpbmVhcihhZGRTdGFydFBvaW50KTtcbiAgfSBlbHNlIGlmIChvdXRzaWRlVHVybikge1xuICAgIHRoaXMuYWRkT3V0c2lkZVR1cm4ob3JpZW50YXRpb24sIGFkZFN0YXJ0UG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkSW5zaWRlVHVybihvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMaW5lRW5kQ2FwID0gZnVuY3Rpb24gYWRkTGluZUVuZENhcCAocDAsIHAxKSB7XG4gIHZhciBzZWcgPSBuZXcgTGluZVNlZ21lbnQocDAsIHAxKTtcbiAgdmFyIG9mZnNldEwgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChzZWcsIFBvc2l0aW9uLkxFRlQsIHRoaXMuX2Rpc3RhbmNlLCBvZmZzZXRMKTtcbiAgdmFyIG9mZnNldFIgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChzZWcsIFBvc2l0aW9uLlJJR0hULCB0aGlzLl9kaXN0YW5jZSwgb2Zmc2V0Uik7XG4gIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICBzd2l0Y2ggKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKSB7XG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9ST1VORDpcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0TC5wMSk7XG4gICAgICB0aGlzLmFkZEZpbGxldEFyYyhwMSwgYW5nbGUgKyBNYXRoLlBJIC8gMiwgYW5nbGUgLSBNYXRoLlBJIC8gMiwgQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSwgdGhpcy5fZGlzdGFuY2UpO1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRSLnAxKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUOlxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRMLnAxKTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0Ui5wMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFOlxuICAgICAgdmFyIHNxdWFyZUNhcFNpZGVPZmZzZXQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgICAgc3F1YXJlQ2FwU2lkZU9mZnNldC54ID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgc3F1YXJlQ2FwU2lkZU9mZnNldC55ID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIHNxdWFyZUNhcExPZmZzZXQgPSBuZXcgQ29vcmRpbmF0ZShvZmZzZXRMLnAxLnggKyBzcXVhcmVDYXBTaWRlT2Zmc2V0LngsIG9mZnNldEwucDEueSArIHNxdWFyZUNhcFNpZGVPZmZzZXQueSk7XG4gICAgICB2YXIgc3F1YXJlQ2FwUk9mZnNldCA9IG5ldyBDb29yZGluYXRlKG9mZnNldFIucDEueCArIHNxdWFyZUNhcFNpZGVPZmZzZXQueCwgb2Zmc2V0Ui5wMS55ICsgc3F1YXJlQ2FwU2lkZU9mZnNldC55KTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoc3F1YXJlQ2FwTE9mZnNldCk7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHNxdWFyZUNhcFJPZmZzZXQpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHZhciBwdHMgPSB0aGlzLl9zZWdMaXN0LmdldENvb3JkaW5hdGVzKCk7XG4gIHJldHVybiBwdHNcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNaXRyZUpvaW4gPSBmdW5jdGlvbiBhZGRNaXRyZUpvaW4gKHAsIG9mZnNldDAsIG9mZnNldDEsIGRpc3RhbmNlKSB7XG4gIHZhciBpc01pdHJlV2l0aGluTGltaXQgPSB0cnVlO1xuICB2YXIgaW50UHQgPSBudWxsO1xuICB0cnkge1xuICAgIGludFB0ID0gSENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uKG9mZnNldDAucDAsIG9mZnNldDAucDEsIG9mZnNldDEucDAsIG9mZnNldDEucDEpO1xuICAgIHZhciBtaXRyZVJhdGlvID0gZGlzdGFuY2UgPD0gMC4wID8gMS4wIDogaW50UHQuZGlzdGFuY2UocCkgLyBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgaWYgKG1pdHJlUmF0aW8gPiB0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKSB7IGlzTWl0cmVXaXRoaW5MaW1pdCA9IGZhbHNlOyB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbikge1xuICAgICAgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZSgwLCAwKTtcbiAgICAgIGlzTWl0cmVXaXRoaW5MaW1pdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG4gIGlmIChpc01pdHJlV2l0aGluTGltaXQpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGludFB0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4ob2Zmc2V0MCwgb2Zmc2V0MSwgZGlzdGFuY2UsIHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkRmlsbGV0Q29ybmVyID0gZnVuY3Rpb24gYWRkRmlsbGV0Q29ybmVyIChwLCBwMCwgcDEsIGRpcmVjdGlvbiwgcmFkaXVzKSB7XG4gIHZhciBkeDAgPSBwMC54IC0gcC54O1xuICB2YXIgZHkwID0gcDAueSAtIHAueTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKGR5MCwgZHgwKTtcbiAgdmFyIGR4MSA9IHAxLnggLSBwLng7XG4gIHZhciBkeTEgPSBwMS55IC0gcC55O1xuICB2YXIgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKGR5MSwgZHgxKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSkge1xuICAgIGlmIChzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7IHN0YXJ0QW5nbGUgKz0gMi4wICogTWF0aC5QSTsgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdGFydEFuZ2xlID49IGVuZEFuZ2xlKSB7IHN0YXJ0QW5nbGUgLT0gMi4wICogTWF0aC5QSTsgfVxuICB9XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQocDApO1xuICB0aGlzLmFkZEZpbGxldEFyYyhwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlyZWN0aW9uLCByYWRpdXMpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHAxKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRPdXRzaWRlVHVybiA9IGZ1bmN0aW9uIGFkZE91dHNpZGVUdXJuIChvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCkge1xuICBpZiAodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKSA8IHRoaXMuX2Rpc3RhbmNlICogT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUikge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fTUlUUkUpIHtcbiAgICB0aGlzLmFkZE1pdHJlSm9pbih0aGlzLl9zMSwgdGhpcy5fb2Zmc2V0MCwgdGhpcy5fb2Zmc2V0MSwgdGhpcy5fZGlzdGFuY2UpO1xuICB9IGVsc2UgaWYgKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX0JFVkVMKSB7XG4gICAgdGhpcy5hZGRCZXZlbEpvaW4odGhpcy5fb2Zmc2V0MCwgdGhpcy5fb2Zmc2V0MSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFkZFN0YXJ0UG9pbnQpIHsgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTsgfVxuICAgIHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuX3MxLCB0aGlzLl9vZmZzZXQwLnAxLCB0aGlzLl9vZmZzZXQxLnAwLCBvcmllbnRhdGlvbiwgdGhpcy5fZGlzdGFuY2UpO1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jcmVhdGVTcXVhcmUgPSBmdW5jdGlvbiBjcmVhdGVTcXVhcmUgKHApIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggKyB0aGlzLl9kaXN0YW5jZSwgcC55ICsgdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggKyB0aGlzLl9kaXN0YW5jZSwgcC55IC0gdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggLSB0aGlzLl9kaXN0YW5jZSwgcC55IC0gdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggLSB0aGlzLl9kaXN0YW5jZSwgcC55ICsgdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRTZWdtZW50cyA9IGZ1bmN0aW9uIGFkZFNlZ21lbnRzIChwdCwgaXNGb3J3YXJkKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHRzKHB0LCBpc0ZvcndhcmQpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEZpcnN0U2VnbWVudCA9IGZ1bmN0aW9uIGFkZEZpcnN0U2VnbWVudCAoKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGFzdFNlZ21lbnQgPSBmdW5jdGlvbiBhZGRMYXN0U2VnbWVudCAoKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMSk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW5pdFNpZGVTZWdtZW50cyA9IGZ1bmN0aW9uIGluaXRTaWRlU2VnbWVudHMgKHMxLCBzMiwgc2lkZSkge1xuICB0aGlzLl9zMSA9IHMxO1xuICB0aGlzLl9zMiA9IHMyO1xuICB0aGlzLl9zaWRlID0gc2lkZTtcbiAgdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyhzMSwgczIpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsIHNpZGUsIHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl9vZmZzZXQxKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMaW1pdGVkTWl0cmVKb2luID0gZnVuY3Rpb24gYWRkTGltaXRlZE1pdHJlSm9pbiAob2Zmc2V0MCwgb2Zmc2V0MSwgZGlzdGFuY2UsIG1pdHJlTGltaXQpIHtcbiAgdmFyIGJhc2VQdCA9IHRoaXMuX3NlZzAucDE7XG4gIHZhciBhbmcwID0gQW5nbGUuYW5nbGUoYmFzZVB0LCB0aGlzLl9zZWcwLnAwKTtcbiAgLy8gY29uc3QgYW5nMSA9IEFuZ2xlLmFuZ2xlKGJhc2VQdCwgdGhpcy5fc2VnMS5wMSlcbiAgdmFyIGFuZ0RpZmYgPSBBbmdsZS5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLl9zZWcwLnAwLCBiYXNlUHQsIHRoaXMuX3NlZzEucDEpO1xuICB2YXIgYW5nRGlmZkhhbGYgPSBhbmdEaWZmIC8gMjtcbiAgdmFyIG1pZEFuZyA9IEFuZ2xlLm5vcm1hbGl6ZShhbmcwICsgYW5nRGlmZkhhbGYpO1xuICB2YXIgbWl0cmVNaWRBbmcgPSBBbmdsZS5ub3JtYWxpemUobWlkQW5nICsgTWF0aC5QSSk7XG4gIHZhciBtaXRyZURpc3QgPSBtaXRyZUxpbWl0ICogZGlzdGFuY2U7XG4gIHZhciBiZXZlbERlbHRhID0gbWl0cmVEaXN0ICogTWF0aC5hYnMoTWF0aC5zaW4oYW5nRGlmZkhhbGYpKTtcbiAgdmFyIGJldmVsSGFsZkxlbiA9IGRpc3RhbmNlIC0gYmV2ZWxEZWx0YTtcbiAgdmFyIGJldmVsTWlkWCA9IGJhc2VQdC54ICsgbWl0cmVEaXN0ICogTWF0aC5jb3MobWl0cmVNaWRBbmcpO1xuICB2YXIgYmV2ZWxNaWRZID0gYmFzZVB0LnkgKyBtaXRyZURpc3QgKiBNYXRoLnNpbihtaXRyZU1pZEFuZyk7XG4gIHZhciBiZXZlbE1pZFB0ID0gbmV3IENvb3JkaW5hdGUoYmV2ZWxNaWRYLCBiZXZlbE1pZFkpO1xuICB2YXIgbWl0cmVNaWRMaW5lID0gbmV3IExpbmVTZWdtZW50KGJhc2VQdCwgYmV2ZWxNaWRQdCk7XG4gIHZhciBiZXZlbEVuZExlZnQgPSBtaXRyZU1pZExpbmUucG9pbnRBbG9uZ09mZnNldCgxLjAsIGJldmVsSGFsZkxlbik7XG4gIHZhciBiZXZlbEVuZFJpZ2h0ID0gbWl0cmVNaWRMaW5lLnBvaW50QWxvbmdPZmZzZXQoMS4wLCAtYmV2ZWxIYWxmTGVuKTtcbiAgaWYgKHRoaXMuX3NpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kTGVmdCk7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChiZXZlbEVuZFJpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kUmlnaHQpO1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoYmV2ZWxFbmRMZWZ0KTtcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmNvbXB1dGVPZmZzZXRTZWdtZW50ID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldFNlZ21lbnQgKHNlZywgc2lkZSwgZGlzdGFuY2UsIG9mZnNldCkge1xuICB2YXIgc2lkZVNpZ24gPSBzaWRlID09PSBQb3NpdGlvbi5MRUZUID8gMSA6IC0xO1xuICB2YXIgZHggPSBzZWcucDEueCAtIHNlZy5wMC54O1xuICB2YXIgZHkgPSBzZWcucDEueSAtIHNlZy5wMC55O1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHV4ID0gc2lkZVNpZ24gKiBkaXN0YW5jZSAqIGR4IC8gbGVuO1xuICB2YXIgdXkgPSBzaWRlU2lnbiAqIGRpc3RhbmNlICogZHkgLyBsZW47XG4gIG9mZnNldC5wMC54ID0gc2VnLnAwLnggLSB1eTtcbiAgb2Zmc2V0LnAwLnkgPSBzZWcucDAueSArIHV4O1xuICBvZmZzZXQucDEueCA9IHNlZy5wMS54IC0gdXk7XG4gIG9mZnNldC5wMS55ID0gc2VnLnAxLnkgKyB1eDtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRGaWxsZXRBcmMgPSBmdW5jdGlvbiBhZGRGaWxsZXRBcmMgKHAsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkaXJlY3Rpb24sIHJhZGl1cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBkaXJlY3Rpb25GYWN0b3IgPSBkaXJlY3Rpb24gPT09IENHQWxnb3JpdGhtcy5DTE9DS1dJU0UgPyAtMSA6IDE7XG4gIHZhciB0b3RhbEFuZ2xlID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcbiAgdmFyIG5TZWdzID0gTWF0aC50cnVuYyh0b3RhbEFuZ2xlIC8gdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtICsgMC41KTtcbiAgaWYgKG5TZWdzIDwgMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBpbml0QW5nbGUgPSAwLjA7XG4gIHZhciBjdXJyQW5nbGVJbmMgPSB0b3RhbEFuZ2xlIC8gblNlZ3M7XG4gIHZhciBjdXJyQW5nbGUgPSBpbml0QW5nbGU7XG4gIHZhciBwdCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHdoaWxlIChjdXJyQW5nbGUgPCB0b3RhbEFuZ2xlKSB7XG4gICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZSArIGRpcmVjdGlvbkZhY3RvciAqIGN1cnJBbmdsZTtcbiAgICBwdC54ID0gcC54ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHB0LnkgPSBwLnkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdGhpcyQxLl9zZWdMaXN0LmFkZFB0KHB0KTtcbiAgICBjdXJyQW5nbGUgKz0gY3VyckFuZ2xlSW5jO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkSW5zaWRlVHVybiA9IGZ1bmN0aW9uIGFkZEluc2lkZVR1cm4gKG9yaWVudGF0aW9uLCBhZGRTdGFydFBvaW50KSB7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fb2Zmc2V0MC5wMCwgdGhpcy5fb2Zmc2V0MC5wMSwgdGhpcy5fb2Zmc2V0MS5wMCwgdGhpcy5fb2Zmc2V0MS5wMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApIDwgdGhpcy5fZGlzdGFuY2UgKiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUikge1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtcbiAgICAgIGlmICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID4gMCkge1xuICAgICAgICB2YXIgbWlkMCA9IG5ldyBDb29yZGluYXRlKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MC5wMS54ICsgdGhpcy5fczEueCkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpLCAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciAqIHRoaXMuX29mZnNldDAucDEueSArIHRoaXMuX3MxLnkpIC8gKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKyAxKSk7XG4gICAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQobWlkMCk7XG4gICAgICAgIHZhciBtaWQxID0gbmV3IENvb3JkaW5hdGUoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKiB0aGlzLl9vZmZzZXQxLnAwLnggKyB0aGlzLl9zMS54KSAvICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICsgMSksICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MS5wMC55ICsgdGhpcy5fczEueSkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpKTtcbiAgICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChtaWQxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fczEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKTtcbiAgICB9XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiBjcmVhdGVDaXJjbGUgKHApIHtcbiAgdmFyIHB0ID0gbmV3IENvb3JkaW5hdGUocC54ICsgdGhpcy5fZGlzdGFuY2UsIHAueSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQocHQpO1xuICB0aGlzLmFkZEZpbGxldEFyYyhwLCAwLjAsIDIuMCAqIE1hdGguUEksIC0xLCB0aGlzLl9kaXN0YW5jZSk7XG4gIHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkQmV2ZWxKb2luID0gZnVuY3Rpb24gYWRkQmV2ZWxKb2luIChvZmZzZXQwLCBvZmZzZXQxKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0MC5wMSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0MS5wMCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yID0gZGlzdGFuY2UgKiAoMSAtIE1hdGguY29zKHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSAvIDIuMCkpO1xuICB0aGlzLl9zZWdMaXN0ID0gbmV3IE9mZnNldFNlZ21lbnRTdHJpbmcoKTtcbiAgdGhpcy5fc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9wcmVjaXNpb25Nb2RlbCk7XG4gIHRoaXMuX3NlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKGRpc3RhbmNlICogT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZENvbGxpbmVhciA9IGZ1bmN0aW9uIGFkZENvbGxpbmVhciAoYWRkU3RhcnRQb2ludCkge1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX3MwLCB0aGlzLl9zMSwgdGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdmFyIG51bUludCA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpO1xuICBpZiAobnVtSW50ID49IDIpIHtcbiAgICBpZiAodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fQkVWRUwgfHwgdGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fTUlUUkUpIHtcbiAgICAgIGlmIChhZGRTdGFydFBvaW50KSB7IHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7IH1cbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuX3MxLCB0aGlzLl9vZmZzZXQwLnAxLCB0aGlzLl9vZmZzZXQxLnAwLCBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgfVxuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuY2xvc2VSaW5nID0gZnVuY3Rpb24gY2xvc2VSaW5nICgpIHtcbiAgdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5oYXNOYXJyb3dDb25jYXZlQW5nbGUgPSBmdW5jdGlvbiBoYXNOYXJyb3dDb25jYXZlQW5nbGUgKCkge1xuICByZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlXG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0U2VnbWVudEdlbmVyYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxLjBFLTMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMS4wRS0zIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjcuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMEUtNiB9O1xuc3RhdGljQWNjZXNzb3JzJDI3Lk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDgwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMjcgKTtcblxudmFyIE9mZnNldEN1cnZlQnVpbGRlciA9IGZ1bmN0aW9uIE9mZnNldEN1cnZlQnVpbGRlciAoKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IG51bGw7XG4gIHZhciBwcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJ1ZlBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0T2Zmc2V0Q3VydmUgPSBmdW5jdGlvbiBnZXRPZmZzZXRDdXJ2ZSAoaW5wdXRQdHMsIGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGlzUmlnaHRTaWRlID0gZGlzdGFuY2UgPCAwLjA7XG4gIHZhciBwb3NEaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKTtcbiAgdmFyIHNlZ0dlbiA9IHRoaXMuZ2V0U2VnR2VuKHBvc0Rpc3RhbmNlKTtcbiAgaWYgKGlucHV0UHRzLmxlbmd0aCA8PSAxKSB7XG4gICAgdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZShpbnB1dFB0c1swXSwgc2VnR2VuKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZShpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbik7XG4gIH1cbiAgdmFyIGN1cnZlUHRzID0gc2VnR2VuLmdldENvb3JkaW5hdGVzKCk7XG4gIGlmIChpc1JpZ2h0U2lkZSkgeyBDb29yZGluYXRlQXJyYXlzLnJldmVyc2UoY3VydmVQdHMpOyB9XG4gIHJldHVybiBjdXJ2ZVB0c1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUgPSBmdW5jdGlvbiBjb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSAoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgaWYgKGlzUmlnaHRTaWRlKSB7XG4gICAgc2VnR2VuLmFkZFNlZ21lbnRzKGlucHV0UHRzLCB0cnVlKTtcbiAgICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gICAgdmFyIG4yID0gc2ltcDIubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMltuMl0sIHNpbXAyW24yIC0gMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gbjIgLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2ldLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VnR2VuLmFkZFNlZ21lbnRzKGlucHV0UHRzLCBmYWxzZSk7XG4gICAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gICAgdmFyIG4xID0gc2ltcDEubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMVswXSwgc2ltcDFbMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPD0gbjE7IGkkMSsrKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaSQxXSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlUmluZ0J1ZmZlckN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSAoaW5wdXRQdHMsIHNpZGUsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICBpZiAoc2lkZSA9PT0gUG9zaXRpb24uUklHSFQpIHsgZGlzdFRvbCA9IC1kaXN0VG9sOyB9XG4gIHZhciBzaW1wID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gIHZhciBuID0gc2ltcC5sZW5ndGggLSAxO1xuICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wW24gLSAxXSwgc2ltcFswXSwgc2lkZSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IG47IGkrKykge1xuICAgIHZhciBhZGRTdGFydFBvaW50ID0gaSAhPT0gMTtcbiAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcFtpXSwgYWRkU3RhcnRQb2ludCk7XG4gIH1cbiAgc2VnR2VuLmNsb3NlUmluZygpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVMaW5lQnVmZmVyQ3VydmUgKGlucHV0UHRzLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gIHZhciBuMSA9IHNpbXAxLmxlbmd0aCAtIDE7XG4gIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAxWzBdLCBzaW1wMVsxXSwgUG9zaXRpb24uTEVGVCk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDw9IG4xOyBpKyspIHtcbiAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaV0sIHRydWUpO1xuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uYWRkTGluZUVuZENhcChzaW1wMVtuMSAtIDFdLCBzaW1wMVtuMV0pO1xuICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gIHZhciBuMiA9IHNpbXAyLmxlbmd0aCAtIDE7XG4gIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAyW24yXSwgc2ltcDJbbjIgLSAxXSwgUG9zaXRpb24uTEVGVCk7XG4gIGZvciAodmFyIGkkMSA9IG4yIC0gMjsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2kkMV0sIHRydWUpO1xuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uYWRkTGluZUVuZENhcChzaW1wMlsxXSwgc2ltcDJbMF0pO1xuICBzZWdHZW4uY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlUG9pbnRDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludEN1cnZlIChwdCwgc2VnR2VuKSB7XG4gIHN3aXRjaCAodGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpIHtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EOlxuICAgICAgc2VnR2VuLmNyZWF0ZUNpcmNsZShwdCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFOlxuICAgICAgc2VnR2VuLmNyZWF0ZVNxdWFyZShwdCk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldExpbmVDdXJ2ZSA9IGZ1bmN0aW9uIGdldExpbmVDdXJ2ZSAoaW5wdXRQdHMsIGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGlmIChkaXN0YW5jZSA8IDAuMCAmJiAhdGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHBvc0Rpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICB2YXIgc2VnR2VuID0gdGhpcy5nZXRTZWdHZW4ocG9zRGlzdGFuY2UpO1xuICBpZiAoaW5wdXRQdHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0aGlzLmNvbXB1dGVQb2ludEN1cnZlKGlucHV0UHRzWzBdLCBzZWdHZW4pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKSB7XG4gICAgICB2YXIgaXNSaWdodFNpZGUgPSBkaXN0YW5jZSA8IDAuMDtcbiAgICAgIHRoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pO1xuICAgIH0gZWxzZSB7IHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZShpbnB1dFB0cywgc2VnR2VuKTsgfVxuICB9XG4gIHZhciBsaW5lQ29vcmQgPSBzZWdHZW4uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgcmV0dXJuIGxpbmVDb29yZFxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0QnVmZmVyUGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldEJ1ZmZlclBhcmFtZXRlcnMgKCkge1xuICByZXR1cm4gdGhpcy5fYnVmUGFyYW1zXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5zaW1wbGlmeVRvbGVyYW5jZSA9IGZ1bmN0aW9uIHNpbXBsaWZ5VG9sZXJhbmNlIChidWZEaXN0YW5jZSkge1xuICByZXR1cm4gYnVmRGlzdGFuY2UgKiB0aGlzLl9idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0UmluZ0N1cnZlID0gZnVuY3Rpb24gZ2V0UmluZ0N1cnZlIChpbnB1dFB0cywgc2lkZSwgZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgaWYgKGlucHV0UHRzLmxlbmd0aCA8PSAyKSB7IHJldHVybiB0aGlzLmdldExpbmVDdXJ2ZShpbnB1dFB0cywgZGlzdGFuY2UpIH1cbiAgaWYgKGRpc3RhbmNlID09PSAwLjApIHtcbiAgICByZXR1cm4gT2Zmc2V0Q3VydmVCdWlsZGVyLmNvcHlDb29yZGluYXRlcyhpbnB1dFB0cylcbiAgfVxuICB2YXIgc2VnR2VuID0gdGhpcy5nZXRTZWdHZW4oZGlzdGFuY2UpO1xuICB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUoaW5wdXRQdHMsIHNpZGUsIHNlZ0dlbik7XG4gIHJldHVybiBzZWdHZW4uZ2V0Q29vcmRpbmF0ZXMoKVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZU9mZnNldEN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldEN1cnZlIChpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICBpZiAoaXNSaWdodFNpZGUpIHtcbiAgICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gICAgdmFyIG4yID0gc2ltcDIubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMltuMl0sIHNpbXAyW24yIC0gMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gbjIgLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2ldLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gICAgdmFyIG4xID0gc2ltcDEubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMVswXSwgc2ltcDFbMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPD0gbjE7IGkkMSsrKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaSQxXSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0U2VnR2VuID0gZnVuY3Rpb24gZ2V0U2VnR2VuIChkaXN0YW5jZSkge1xuICByZXR1cm4gbmV3IE9mZnNldFNlZ21lbnRHZW5lcmF0b3IodGhpcy5fcHJlY2lzaW9uTW9kZWwsIHRoaXMuX2J1ZlBhcmFtcywgZGlzdGFuY2UpXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldEN1cnZlQnVpbGRlclxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5jb3B5Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjb3B5Q29vcmRpbmF0ZXMgKHB0cykge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShwdHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcbiAgICBjb3B5W2ldID0gbmV3IENvb3JkaW5hdGUocHRzW2ldKTtcbiAgfVxuICByZXR1cm4gY29weVxufTtcblxudmFyIFN1YmdyYXBoRGVwdGhMb2NhdGVyID0gZnVuY3Rpb24gU3ViZ3JhcGhEZXB0aExvY2F0ZXIgKCkge1xuICB0aGlzLl9zdWJncmFwaHMgPSBudWxsO1xuICB0aGlzLl9zZWcgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fY2dhID0gbmV3IENHQWxnb3JpdGhtcygpO1xuICB2YXIgc3ViZ3JhcGhzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9zdWJncmFwaHMgPSBzdWJncmFwaHM7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMwID0geyBEZXB0aFNlZ21lbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5maW5kU3RhYmJlZFNlZ21lbnRzID0gZnVuY3Rpb24gZmluZFN0YWJiZWRTZWdtZW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YWJiZWRTZWdtZW50cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc3ViZ3JhcGhzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGJzZyA9IGkubmV4dCgpO1xuICAgICAgdmFyIGVudiA9IGJzZy5nZXRFbnZlbG9wZSgpO1xuICAgICAgaWYgKHN0YWJiaW5nUmF5TGVmdFB0LnkgPCBlbnYuZ2V0TWluWSgpIHx8IHN0YWJiaW5nUmF5TGVmdFB0LnkgPiBlbnYuZ2V0TWF4WSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHRoaXMkMS5maW5kU3RhYmJlZFNlZ21lbnRzKHN0YWJiaW5nUmF5TGVmdFB0LCBic2cuZ2V0RGlyZWN0ZWRFZGdlcygpLCBzdGFiYmVkU2VnbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhYmJlZFNlZ21lbnRzXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBMaXN0KSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBEaXJlY3RlZEVkZ2UpKSB7XG4gICAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXJFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YWJiZWRTZWdtZW50cyQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHB0cyA9IGRpckVkZ2UuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoIC0gMTsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9zZWcucDAgPSBwdHNbaSQxXTtcbiAgICAgICAgdGhpcyQxLl9zZWcucDEgPSBwdHNbaSQxICsgMV07XG4gICAgICAgIGlmICh0aGlzJDEuX3NlZy5wMC55ID4gdGhpcyQxLl9zZWcucDEueSkgeyB0aGlzJDEuX3NlZy5yZXZlcnNlKCk7IH1cbiAgICAgICAgdmFyIG1heHggPSBNYXRoLm1heCh0aGlzJDEuX3NlZy5wMC54LCB0aGlzJDEuX3NlZy5wMS54KTtcbiAgICAgICAgaWYgKG1heHggPCBzdGFiYmluZ1JheUxlZnRQdCQxLngpIHsgY29udGludWUgfVxuICAgICAgICBpZiAodGhpcyQxLl9zZWcuaXNIb3Jpem9udGFsKCkpIHsgY29udGludWUgfVxuICAgICAgICBpZiAoc3RhYmJpbmdSYXlMZWZ0UHQkMS55IDwgdGhpcyQxLl9zZWcucDAueSB8fCBzdGFiYmluZ1JheUxlZnRQdCQxLnkgPiB0aGlzJDEuX3NlZy5wMS55KSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24odGhpcyQxLl9zZWcucDAsIHRoaXMkMS5fc2VnLnAxLCBzdGFiYmluZ1JheUxlZnRQdCQxKSA9PT0gQ0dBbGdvcml0aG1zLlJJR0hUKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIGRlcHRoID0gZGlyRWRnZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuX3NlZy5wMC5lcXVhbHMocHRzW2kkMV0pKSB7IGRlcHRoID0gZGlyRWRnZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCk7IH1cbiAgICAgICAgdmFyIGRzID0gbmV3IERlcHRoU2VnbWVudCh0aGlzJDEuX3NlZywgZGVwdGgpO1xuICAgICAgICBzdGFiYmVkU2VnbWVudHMkMS5hZGQoZHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgTGlzdCkpKSB7XG4gICAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXJFZGdlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzdGFiYmVkU2VnbWVudHMkMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkkMiA9IGRpckVkZ2VzLml0ZXJhdG9yKCk7IGkkMi5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBkZSA9IGkkMi5uZXh0KCk7XG4gICAgICAgIGlmICghZGUuaXNGb3J3YXJkKCkpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzJDEuZmluZFN0YWJiZWRTZWdtZW50cyhzdGFiYmluZ1JheUxlZnRQdCQyLCBkZSwgc3RhYmJlZFNlZ21lbnRzJDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoIChwKSB7XG4gIHZhciBzdGFiYmVkU2VnbWVudHMgPSB0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHMocCk7XG4gIGlmIChzdGFiYmVkU2VnbWVudHMuc2l6ZSgpID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGRzID0gQ29sbGVjdGlvbnMubWluKHN0YWJiZWRTZWdtZW50cyk7XG4gIHJldHVybiBkcy5fbGVmdERlcHRoXG59O1xuU3ViZ3JhcGhEZXB0aExvY2F0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TdWJncmFwaERlcHRoTG9jYXRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTdWJncmFwaERlcHRoTG9jYXRlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMC5EZXB0aFNlZ21lbnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVwdGhTZWdtZW50IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdWJncmFwaERlcHRoTG9jYXRlciwgc3RhdGljQWNjZXNzb3JzJDMwICk7XG5cbnZhciBEZXB0aFNlZ21lbnQgPSBmdW5jdGlvbiBEZXB0aFNlZ21lbnQgKCkge1xuICB0aGlzLl91cHdhcmRTZWcgPSBudWxsO1xuICB0aGlzLl9sZWZ0RGVwdGggPSBudWxsO1xuICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX3Vwd2FyZFNlZyA9IG5ldyBMaW5lU2VnbWVudChzZWcpO1xuICB0aGlzLl9sZWZ0RGVwdGggPSBkZXB0aDtcbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBvdGhlciA9IG9iajtcbiAgaWYgKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCkgPj0gb3RoZXIuX3Vwd2FyZFNlZy5tYXhYKCkpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fdXB3YXJkU2VnLm1heFgoKSA8PSBvdGhlci5fdXB3YXJkU2VnLm1pblgoKSkgeyByZXR1cm4gLTEgfVxuICB2YXIgb3JpZW50SW5kZXggPSB0aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChvdGhlci5fdXB3YXJkU2VnKTtcbiAgaWYgKG9yaWVudEluZGV4ICE9PSAwKSB7IHJldHVybiBvcmllbnRJbmRleCB9XG4gIG9yaWVudEluZGV4ID0gLTEgKiBvdGhlci5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy5fdXB3YXJkU2VnKTtcbiAgaWYgKG9yaWVudEluZGV4ICE9PSAwKSB7IHJldHVybiBvcmllbnRJbmRleCB9XG4gIHJldHVybiB0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKG90aGVyLl91cHdhcmRTZWcpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5jb21wYXJlWCA9IGZ1bmN0aW9uIGNvbXBhcmVYIChzZWcwLCBzZWcxKSB7XG4gIHZhciBjb21wYXJlMCA9IHNlZzAucDAuY29tcGFyZVRvKHNlZzEucDApO1xuICBpZiAoY29tcGFyZTAgIT09IDApIHsgcmV0dXJuIGNvbXBhcmUwIH1cbiAgcmV0dXJuIHNlZzAucDEuY29tcGFyZVRvKHNlZzEucDEpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy50b1N0cmluZygpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEZXB0aFNlZ21lbnRcbn07XG5cbnZhciBUcmlhbmdsZSA9IGZ1bmN0aW9uIFRyaWFuZ2xlIChwMCwgcDEsIHAyKSB7XG4gIHRoaXMucDAgPSBwMCB8fCBudWxsO1xuICB0aGlzLnAxID0gcDEgfHwgbnVsbDtcbiAgdGhpcy5wMiA9IHAyIHx8IG51bGw7XG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbiBhcmVhICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmFyZWEodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuc2lnbmVkQXJlYSA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuc2lnbmVkQXJlYSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVogPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZVogKHApIHtcbiAgaWYgKHAgPT09IG51bGwpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC4nKSB9XG4gIHJldHVybiBUcmlhbmdsZS5pbnRlcnBvbGF0ZVoocCwgdGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUubG9uZ2VzdFNpZGVMZW5ndGggPSBmdW5jdGlvbiBsb25nZXN0U2lkZUxlbmd0aCAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pc0FjdXRlID0gZnVuY3Rpb24gaXNBY3V0ZSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5pc0FjdXRlKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmNpcmN1bWNlbnRyZSA9IGZ1bmN0aW9uIGNpcmN1bWNlbnRyZSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5jaXJjdW1jZW50cmUodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuYXJlYTNEID0gZnVuY3Rpb24gYXJlYTNEICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmFyZWEzRCh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uIGNlbnRyb2lkICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmNlbnRyb2lkKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmluQ2VudHJlID0gZnVuY3Rpb24gaW5DZW50cmUgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuaW5DZW50cmUodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlXG59O1xuVHJpYW5nbGUuYXJlYSA9IGZ1bmN0aW9uIGFyZWEgKGEsIGIsIGMpIHtcbiAgcmV0dXJuIE1hdGguYWJzKCgoYy54IC0gYS54KSAqIChiLnkgLSBhLnkpIC0gKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSkgLyAyKVxufTtcblRyaWFuZ2xlLnNpZ25lZEFyZWEgPSBmdW5jdGlvbiBzaWduZWRBcmVhIChhLCBiLCBjKSB7XG4gIHJldHVybiAoKGMueCAtIGEueCkgKiAoYi55IC0gYS55KSAtIChiLnggLSBhLngpICogKGMueSAtIGEueSkpIC8gMlxufTtcblRyaWFuZ2xlLmRldCA9IGZ1bmN0aW9uIGRldCAobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHJldHVybiBtMDAgKiBtMTEgLSBtMDEgKiBtMTBcbn07XG5UcmlhbmdsZS5pbnRlcnBvbGF0ZVogPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZVogKHAsIHYwLCB2MSwgdjIpIHtcbiAgdmFyIHgwID0gdjAueDtcbiAgdmFyIHkwID0gdjAueTtcbiAgdmFyIGEgPSB2MS54IC0geDA7XG4gIHZhciBiID0gdjIueCAtIHgwO1xuICB2YXIgYyA9IHYxLnkgLSB5MDtcbiAgdmFyIGQgPSB2Mi55IC0geTA7XG4gIHZhciBkZXQgPSBhICogZCAtIGIgKiBjO1xuICB2YXIgZHggPSBwLnggLSB4MDtcbiAgdmFyIGR5ID0gcC55IC0geTA7XG4gIHZhciB0ID0gKGQgKiBkeCAtIGIgKiBkeSkgLyBkZXQ7XG4gIHZhciB1ID0gKC1jICogZHggKyBhICogZHkpIC8gZGV0O1xuICB2YXIgeiA9IHYwLnogKyB0ICogKHYxLnogLSB2MC56KSArIHUgKiAodjIueiAtIHYwLnopO1xuICByZXR1cm4gelxufTtcblRyaWFuZ2xlLmxvbmdlc3RTaWRlTGVuZ3RoID0gZnVuY3Rpb24gbG9uZ2VzdFNpZGVMZW5ndGggKGEsIGIsIGMpIHtcbiAgdmFyIGxlbkFCID0gYS5kaXN0YW5jZShiKTtcbiAgdmFyIGxlbkJDID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGxlbkNBID0gYy5kaXN0YW5jZShhKTtcbiAgdmFyIG1heExlbiA9IGxlbkFCO1xuICBpZiAobGVuQkMgPiBtYXhMZW4pIHsgbWF4TGVuID0gbGVuQkM7IH1cbiAgaWYgKGxlbkNBID4gbWF4TGVuKSB7IG1heExlbiA9IGxlbkNBOyB9XG4gIHJldHVybiBtYXhMZW5cbn07XG5UcmlhbmdsZS5pc0FjdXRlID0gZnVuY3Rpb24gaXNBY3V0ZSAoYSwgYiwgYykge1xuICBpZiAoIUFuZ2xlLmlzQWN1dGUoYSwgYiwgYykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFBbmdsZS5pc0FjdXRlKGIsIGMsIGEpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghQW5nbGUuaXNBY3V0ZShjLCBhLCBiKSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufTtcblRyaWFuZ2xlLmNpcmN1bWNlbnRyZSA9IGZ1bmN0aW9uIGNpcmN1bWNlbnRyZSAoYSwgYiwgYykge1xuICB2YXIgY3ggPSBjLng7XG4gIHZhciBjeSA9IGMueTtcbiAgdmFyIGF4ID0gYS54IC0gY3g7XG4gIHZhciBheSA9IGEueSAtIGN5O1xuICB2YXIgYnggPSBiLnggLSBjeDtcbiAgdmFyIGJ5ID0gYi55IC0gY3k7XG4gIHZhciBkZW5vbSA9IDIgKiBUcmlhbmdsZS5kZXQoYXgsIGF5LCBieCwgYnkpO1xuICB2YXIgbnVteCA9IFRyaWFuZ2xlLmRldChheSwgYXggKiBheCArIGF5ICogYXksIGJ5LCBieCAqIGJ4ICsgYnkgKiBieSk7XG4gIHZhciBudW15ID0gVHJpYW5nbGUuZGV0KGF4LCBheCAqIGF4ICsgYXkgKiBheSwgYngsIGJ4ICogYnggKyBieSAqIGJ5KTtcbiAgdmFyIGNjeCA9IGN4IC0gbnVteCAvIGRlbm9tO1xuICB2YXIgY2N5ID0gY3kgKyBudW15IC8gZGVub207XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZShjY3gsIGNjeSlcbn07XG5UcmlhbmdsZS5wZXJwZW5kaWN1bGFyQmlzZWN0b3IgPSBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyQmlzZWN0b3IgKGEsIGIpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54O1xuICB2YXIgZHkgPSBiLnkgLSBhLnk7XG4gIHZhciBsMSA9IG5ldyBIQ29vcmRpbmF0ZShhLnggKyBkeCAvIDIuMCwgYS55ICsgZHkgLyAyLjAsIDEuMCk7XG4gIHZhciBsMiA9IG5ldyBIQ29vcmRpbmF0ZShhLnggLSBkeSArIGR4IC8gMi4wLCBhLnkgKyBkeCArIGR5IC8gMi4wLCAxLjApO1xuICByZXR1cm4gbmV3IEhDb29yZGluYXRlKGwxLCBsMilcbn07XG5UcmlhbmdsZS5hbmdsZUJpc2VjdG9yID0gZnVuY3Rpb24gYW5nbGVCaXNlY3RvciAoYSwgYiwgYykge1xuICB2YXIgbGVuMCA9IGIuZGlzdGFuY2UoYSk7XG4gIHZhciBsZW4yID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGZyYWMgPSBsZW4wIC8gKGxlbjAgKyBsZW4yKTtcbiAgdmFyIGR4ID0gYy54IC0gYS54O1xuICB2YXIgZHkgPSBjLnkgLSBhLnk7XG4gIHZhciBzcGxpdFB0ID0gbmV3IENvb3JkaW5hdGUoYS54ICsgZnJhYyAqIGR4LCBhLnkgKyBmcmFjICogZHkpO1xuICByZXR1cm4gc3BsaXRQdFxufTtcblRyaWFuZ2xlLmFyZWEzRCA9IGZ1bmN0aW9uIGFyZWEzRCAoYSwgYiwgYykge1xuICB2YXIgdXggPSBiLnggLSBhLng7XG4gIHZhciB1eSA9IGIueSAtIGEueTtcbiAgdmFyIHV6ID0gYi56IC0gYS56O1xuICB2YXIgdnggPSBjLnggLSBhLng7XG4gIHZhciB2eSA9IGMueSAtIGEueTtcbiAgdmFyIHZ6ID0gYy56IC0gYS56O1xuICB2YXIgY3Jvc3N4ID0gdXkgKiB2eiAtIHV6ICogdnk7XG4gIHZhciBjcm9zc3kgPSB1eiAqIHZ4IC0gdXggKiB2ejtcbiAgdmFyIGNyb3NzeiA9IHV4ICogdnkgLSB1eSAqIHZ4O1xuICB2YXIgYWJzU3EgPSBjcm9zc3ggKiBjcm9zc3ggKyBjcm9zc3kgKiBjcm9zc3kgKyBjcm9zc3ogKiBjcm9zc3o7XG4gIHZhciBhcmVhM0QgPSBNYXRoLnNxcnQoYWJzU3EpIC8gMjtcbiAgcmV0dXJuIGFyZWEzRFxufTtcblRyaWFuZ2xlLmNlbnRyb2lkID0gZnVuY3Rpb24gY2VudHJvaWQgKGEsIGIsIGMpIHtcbiAgdmFyIHggPSAoYS54ICsgYi54ICsgYy54KSAvIDM7XG4gIHZhciB5ID0gKGEueSArIGIueSArIGMueSkgLyAzO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoeCwgeSlcbn07XG5UcmlhbmdsZS5pbkNlbnRyZSA9IGZ1bmN0aW9uIGluQ2VudHJlIChhLCBiLCBjKSB7XG4gIHZhciBsZW4wID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGxlbjEgPSBhLmRpc3RhbmNlKGMpO1xuICB2YXIgbGVuMiA9IGEuZGlzdGFuY2UoYik7XG4gIHZhciBjaXJjdW0gPSBsZW4wICsgbGVuMSArIGxlbjI7XG4gIHZhciBpbkNlbnRyZVggPSAobGVuMCAqIGEueCArIGxlbjEgKiBiLnggKyBsZW4yICogYy54KSAvIGNpcmN1bTtcbiAgdmFyIGluQ2VudHJlWSA9IChsZW4wICogYS55ICsgbGVuMSAqIGIueSArIGxlbjIgKiBjLnkpIC8gY2lyY3VtO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoaW5DZW50cmVYLCBpbkNlbnRyZVkpXG59O1xuXG52YXIgT2Zmc2V0Q3VydmVTZXRCdWlsZGVyID0gZnVuY3Rpb24gT2Zmc2V0Q3VydmVTZXRCdWlsZGVyICgpIHtcbiAgdGhpcy5faW5wdXRHZW9tID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9jdXJ2ZUJ1aWxkZXIgPSBudWxsO1xuICB0aGlzLl9jdXJ2ZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBpbnB1dEdlb20gPSBhcmd1bWVudHNbMF07XG4gIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGN1cnZlQnVpbGRlciA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5faW5wdXRHZW9tID0gaW5wdXRHZW9tO1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB0aGlzLl9jdXJ2ZUJ1aWxkZXIgPSBjdXJ2ZUJ1aWxkZXI7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50IChwKSB7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8PSAwLjApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY29vcmQgPSBwLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBjdXJ2ZSA9IHRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoY29vcmQsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgdGhpcy5hZGRDdXJ2ZShjdXJ2ZSwgTG9jYXRpb24uRVhURVJJT1IsIExvY2F0aW9uLklOVEVSSU9SKTtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbiBhZGRQb2x5Z29uIChwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9mZnNldERpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2U7XG4gIHZhciBvZmZzZXRTaWRlID0gUG9zaXRpb24uTEVGVDtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wKSB7XG4gICAgb2Zmc2V0RGlzdGFuY2UgPSAtdGhpcy5fZGlzdGFuY2U7XG4gICAgb2Zmc2V0U2lkZSA9IFBvc2l0aW9uLlJJR0hUO1xuICB9XG4gIHZhciBzaGVsbCA9IHAuZ2V0RXh0ZXJpb3JSaW5nKCk7XG4gIHZhciBzaGVsbENvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhzaGVsbC5nZXRDb29yZGluYXRlcygpKTtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wICYmIHRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KHNoZWxsLCB0aGlzLl9kaXN0YW5jZSkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPD0gMC4wICYmIHNoZWxsQ29vcmQubGVuZ3RoIDwgMykgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuYWRkUG9seWdvblJpbmcoc2hlbGxDb29yZCwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFNpZGUsIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSBwLmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgdmFyIGhvbGVDb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaG9sZS5nZXRDb29yZGluYXRlcygpKTtcbiAgICBpZiAodGhpcyQxLl9kaXN0YW5jZSA+IDAuMCAmJiB0aGlzJDEuaXNFcm9kZWRDb21wbGV0ZWx5KGhvbGUsIC10aGlzJDEuX2Rpc3RhbmNlKSkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmFkZFBvbHlnb25SaW5nKGhvbGVDb29yZCwgb2Zmc2V0RGlzdGFuY2UsIFBvc2l0aW9uLm9wcG9zaXRlKG9mZnNldFNpZGUpLCBMb2NhdGlvbi5JTlRFUklPUiwgTG9jYXRpb24uRVhURVJJT1IpO1xuICB9XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSA9IGZ1bmN0aW9uIGlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5ICh0cmlhbmdsZUNvb3JkLCBidWZmZXJEaXN0YW5jZSkge1xuICB2YXIgdHJpID0gbmV3IFRyaWFuZ2xlKHRyaWFuZ2xlQ29vcmRbMF0sIHRyaWFuZ2xlQ29vcmRbMV0sIHRyaWFuZ2xlQ29vcmRbMl0pO1xuICB2YXIgaW5DZW50cmUgPSB0cmkuaW5DZW50cmUoKTtcbiAgdmFyIGRpc3RUb0NlbnRyZSA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShpbkNlbnRyZSwgdHJpLnAwLCB0cmkucDEpO1xuICByZXR1cm4gZGlzdFRvQ2VudHJlIDwgTWF0aC5hYnMoYnVmZmVyRGlzdGFuY2UpXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRMaW5lU3RyaW5nID0gZnVuY3Rpb24gYWRkTGluZVN0cmluZyAobGluZSkge1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPD0gMC4wICYmICF0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobGluZS5nZXRDb29yZGluYXRlcygpKTtcbiAgdmFyIGN1cnZlID0gdGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShjb29yZCwgdGhpcy5fZGlzdGFuY2UpO1xuICB0aGlzLmFkZEN1cnZlKGN1cnZlLCBMb2NhdGlvbi5FWFRFUklPUiwgTG9jYXRpb24uSU5URVJJT1IpO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkQ3VydmUgPSBmdW5jdGlvbiBhZGRDdXJ2ZSAoY29vcmQsIGxlZnRMb2MsIHJpZ2h0TG9jKSB7XG4gIGlmIChjb29yZCA9PT0gbnVsbCB8fCBjb29yZC5sZW5ndGggPCAyKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGUgPSBuZXcgTm9kZWRTZWdtZW50U3RyaW5nKGNvb3JkLCBuZXcgTGFiZWwoMCwgTG9jYXRpb24uQk9VTkRBUlksIGxlZnRMb2MsIHJpZ2h0TG9jKSk7XG4gIHRoaXMuX2N1cnZlTGlzdC5hZGQoZSk7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5nZXRDdXJ2ZXMgPSBmdW5jdGlvbiBnZXRDdXJ2ZXMgKCkge1xuICB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pO1xuICByZXR1cm4gdGhpcy5fY3VydmVMaXN0XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRQb2x5Z29uUmluZyA9IGZ1bmN0aW9uIGFkZFBvbHlnb25SaW5nIChjb29yZCwgb2Zmc2V0RGlzdGFuY2UsIHNpZGUsIGN3TGVmdExvYywgY3dSaWdodExvYykge1xuICBpZiAob2Zmc2V0RGlzdGFuY2UgPT09IDAuMCAmJiBjb29yZC5sZW5ndGggPCBMaW5lYXJSaW5nLk1JTklNVU1fVkFMSURfU0laRSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBsZWZ0TG9jID0gY3dMZWZ0TG9jO1xuICB2YXIgcmlnaHRMb2MgPSBjd1JpZ2h0TG9jO1xuICBpZiAoY29vcmQubGVuZ3RoID49IExpbmVhclJpbmcuTUlOSU1VTV9WQUxJRF9TSVpFICYmIENHQWxnb3JpdGhtcy5pc0NDVyhjb29yZCkpIHtcbiAgICBsZWZ0TG9jID0gY3dSaWdodExvYztcbiAgICByaWdodExvYyA9IGN3TGVmdExvYztcbiAgICBzaWRlID0gUG9zaXRpb24ub3Bwb3NpdGUoc2lkZSk7XG4gIH1cbiAgdmFyIGN1cnZlID0gdGhpcy5fY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZShjb29yZCwgc2lkZSwgb2Zmc2V0RGlzdGFuY2UpO1xuICB0aGlzLmFkZEN1cnZlKGN1cnZlLCBsZWZ0TG9jLCByaWdodExvYyk7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGcpIHtcbiAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGcgaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuYWRkUG9seWdvbihnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLmFkZExpbmVTdHJpbmcoZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIFBvaW50KSB7IHRoaXMuYWRkUG9pbnQoZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9pbnQpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIC8vIGVsc2UgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGcuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5pc0Vyb2RlZENvbXBsZXRlbHkgPSBmdW5jdGlvbiBpc0Vyb2RlZENvbXBsZXRlbHkgKHJpbmcsIGJ1ZmZlckRpc3RhbmNlKSB7XG4gIHZhciByaW5nQ29vcmQgPSByaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gIC8vIGNvbnN0IG1pbkRpYW0gPSAwLjBcbiAgaWYgKHJpbmdDb29yZC5sZW5ndGggPCA0KSB7IHJldHVybiBidWZmZXJEaXN0YW5jZSA8IDAgfVxuICBpZiAocmluZ0Nvb3JkLmxlbmd0aCA9PT0gNCkgeyByZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShyaW5nQ29vcmQsIGJ1ZmZlckRpc3RhbmNlKSB9XG4gIHZhciBlbnYgPSByaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIGVudk1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGVudi5nZXRIZWlnaHQoKSwgZW52LmdldFdpZHRoKCkpO1xuICBpZiAoYnVmZmVyRGlzdGFuY2UgPCAwLjAgJiYgMiAqIE1hdGguYWJzKGJ1ZmZlckRpc3RhbmNlKSA+IGVudk1pbkRpbWVuc2lvbikgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGFkZENvbGxlY3Rpb24gKGdjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkpO1xuICAgIHRoaXMkMS5hZGQoZyk7XG4gIH1cbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0Q3VydmVTZXRCdWlsZGVyXG59O1xuXG52YXIgUG9pbnRPbkdlb21ldHJ5TG9jYXRvciA9IGZ1bmN0aW9uIFBvaW50T25HZW9tZXRyeUxvY2F0b3IgKCkge307XG5cblBvaW50T25HZW9tZXRyeUxvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCkge307XG5Qb2ludE9uR2VvbWV0cnlMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRPbkdlb21ldHJ5TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludE9uR2VvbWV0cnlMb2NhdG9yXG59O1xuXG52YXIgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvciAoKSB7XG4gIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIHRoaXMuX2F0U3RhcnQgPSBudWxsO1xuICB0aGlzLl9tYXggPSBudWxsO1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG4gIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG51bGw7XG4gIHZhciBwYXJlbnQgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fYXRTdGFydCA9IHRydWU7XG4gIHRoaXMuX2luZGV4ID0gMDtcbiAgdGhpcy5fbWF4ID0gcGFyZW50LmdldE51bUdlb21ldHJpZXMoKTtcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICBpZiAodGhpcy5fYXRTdGFydCkge1xuICAgIHRoaXMuX2F0U3RhcnQgPSBmYWxzZTtcbiAgICBpZiAoR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IuaXNBdG9taWModGhpcy5fcGFyZW50KSkgeyB0aGlzLl9pbmRleCsrOyB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICB9XG4gIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgIT09IG51bGwpIHtcbiAgICBpZiAodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX21heCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgfVxuICB2YXIgb2JqID0gdGhpcy5fcGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLl9pbmRleCsrKTtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvcihvYmopO1xuICAgIHJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpXG4gIH1cbiAgcmV0dXJuIG9ialxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSlcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge1xuICBpZiAodGhpcy5fYXRTdGFydCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciAhPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9tYXgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtJdGVyYXRvcl1cbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvclxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLmlzQXRvbWljID0gZnVuY3Rpb24gaXNBdG9taWMgKGdlb20pIHtcbiAgcmV0dXJuICEoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbilcbn07XG5cbnZhciBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IgPSBmdW5jdGlvbiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwKSB7XG4gIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IubG9jYXRlKHAsIHRoaXMuX2dlb20pXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtQb2ludE9uR2VvbWV0cnlMb2NhdG9yXVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3Jcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuaXNQb2ludEluUmluZyA9IGZ1bmN0aW9uIGlzUG9pbnRJblJpbmcgKHAsIHJpbmcpIHtcbiAgaWYgKCFyaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHApKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBDR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyhwLCByaW5nLmdldENvb3JkaW5hdGVzKCkpXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnRJblBvbHlnb24gPSBmdW5jdGlvbiBjb250YWluc1BvaW50SW5Qb2x5Z29uIChwLCBwb2x5KSB7XG4gIGlmIChwb2x5LmlzRW1wdHkoKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc2hlbGwgPSBwb2x5LmdldEV4dGVyaW9yUmluZygpO1xuICBpZiAoIVNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5pc1BvaW50SW5SaW5nKHAsIHNoZWxsKSkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgIHZhciBob2xlID0gcG9seS5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgIGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuaXNQb2ludEluUmluZyhwLCBob2xlKSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50IChwLCBnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludEluUG9seWdvbihwLCBnZW9tKVxuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgZ2VvbWkgPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IoZ2VvbSk7XG4gICAgd2hpbGUgKGdlb21pLmhhc05leHQoKSkge1xuICAgICAgdmFyIGcyID0gZ2VvbWkubmV4dCgpO1xuICAgICAgaWYgKGcyICE9PSBnZW9tKSB7IGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludChwLCBnMikpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHAsIGdlb20pIHtcbiAgaWYgKGdlb20uaXNFbXB0eSgpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludChwLCBnZW9tKSkgeyByZXR1cm4gTG9jYXRpb24uSU5URVJJT1IgfVxuICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5cbnZhciBFZGdlRW5kU3RhciA9IGZ1bmN0aW9uIEVkZ2VFbmRTdGFyICgpIHtcbiAgdGhpcy5fZWRnZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuX2VkZ2VMaXN0ID0gbnVsbDtcbiAgdGhpcy5fcHRJbkFyZWFMb2NhdGlvbiA9IFtMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FXTtcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0TmV4dENXID0gZnVuY3Rpb24gZ2V0TmV4dENXIChlZSkge1xuICB0aGlzLmdldEVkZ2VzKCk7XG4gIHZhciBpID0gdGhpcy5fZWRnZUxpc3QuaW5kZXhPZihlZSk7XG4gIHZhciBpTmV4dENXID0gaSAtIDE7XG4gIGlmIChpID09PSAwKSB7IGlOZXh0Q1cgPSB0aGlzLl9lZGdlTGlzdC5zaXplKCkgLSAxOyB9XG4gIHJldHVybiB0aGlzLl9lZGdlTGlzdC5nZXQoaU5leHRDVylcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUucHJvcGFnYXRlU2lkZUxhYmVscyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZVNpZGVMYWJlbHMgKGdlb21JbmRleCkge1xuICB2YXIgc3RhcnRMb2MgPSBMb2NhdGlvbi5OT05FO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBpZiAobGFiZWwuaXNBcmVhKGdlb21JbmRleCkgJiYgbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKSAhPT0gTG9jYXRpb24uTk9ORSkgeyBzdGFydExvYyA9IGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7IH1cbiAgfVxuICBpZiAoc3RhcnRMb2MgPT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY3VyckxvYyA9IHN0YXJ0TG9jO1xuICBmb3IgKHZhciBpdCQxID0gdGhpcy5pdGVyYXRvcigpOyBpdCQxLmhhc05leHQoKTspIHtcbiAgICB2YXIgZSQxID0gaXQkMS5uZXh0KCk7XG4gICAgdmFyIGxhYmVsJDEgPSBlJDEuZ2V0TGFiZWwoKTtcbiAgICBpZiAobGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLk9OKSA9PT0gTG9jYXRpb24uTk9ORSkgeyBsYWJlbCQxLnNldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uT04sIGN1cnJMb2MpOyB9XG4gICAgaWYgKGxhYmVsJDEuaXNBcmVhKGdlb21JbmRleCkpIHtcbiAgICAgIHZhciBsZWZ0TG9jID0gbGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpO1xuICAgICAgdmFyIHJpZ2h0TG9jID0gbGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLlJJR0hUKTtcbiAgICAgIGlmIChyaWdodExvYyAhPT0gTG9jYXRpb24uTk9ORSkge1xuICAgICAgICBpZiAocmlnaHRMb2MgIT09IGN1cnJMb2MpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdzaWRlIGxvY2F0aW9uIGNvbmZsaWN0JywgZSQxLmdldENvb3JkaW5hdGUoKSkgfVxuICAgICAgICBpZiAobGVmdExvYyA9PT0gTG9jYXRpb24uTk9ORSkge1xuICAgICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgJyArIGUkMS5nZXRDb29yZGluYXRlKCkgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJMb2MgPSBsZWZ0TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQXNzZXJ0LmlzVHJ1ZShsYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCkgPT09IExvY2F0aW9uLk5PTkUsICdmb3VuZCBzaW5nbGUgbnVsbCBzaWRlJyk7XG4gICAgICAgIGxhYmVsJDEuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCwgY3VyckxvYyk7XG4gICAgICAgIGxhYmVsJDEuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZULCBjdXJyTG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIGlmICghaXQuaGFzTmV4dCgpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gIHJldHVybiBlLmdldENvb3JkaW5hdGUoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKCdFZGdlRW5kU3RhcjogICAnICsgdGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIGUucHJpbnQob3V0KTtcbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50ID0gZnVuY3Rpb24gaXNBcmVhTGFiZWxzQ29uc2lzdGVudCAoZ2VvbUdyYXBoKSB7XG4gIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHMoZ2VvbUdyYXBoLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSk7XG4gIHJldHVybiB0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCA9IGZ1bmN0aW9uIGNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQgKGdlb21JbmRleCkge1xuICB2YXIgZWRnZXMgPSB0aGlzLmdldEVkZ2VzKCk7XG4gIGlmIChlZGdlcy5zaXplKCkgPD0gMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBsYXN0RWRnZUluZGV4ID0gZWRnZXMuc2l6ZSgpIC0gMTtcbiAgdmFyIHN0YXJ0TGFiZWwgPSBlZGdlcy5nZXQobGFzdEVkZ2VJbmRleCkuZ2V0TGFiZWwoKTtcbiAgdmFyIHN0YXJ0TG9jID0gc3RhcnRMYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpO1xuICBBc3NlcnQuaXNUcnVlKHN0YXJ0TG9jICE9PSBMb2NhdGlvbi5OT05FLCAnRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2UnKTtcbiAgdmFyIGN1cnJMb2MgPSBzdGFydExvYztcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgQXNzZXJ0LmlzVHJ1ZShsYWJlbC5pc0FyZWEoZ2VvbUluZGV4KSwgJ0ZvdW5kIG5vbi1hcmVhIGVkZ2UnKTtcbiAgICB2YXIgbGVmdExvYyA9IGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7XG4gICAgdmFyIHJpZ2h0TG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCk7XG4gICAgaWYgKGxlZnRMb2MgPT09IHJpZ2h0TG9jKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHJpZ2h0TG9jICE9PSBjdXJyTG9jKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgY3VyckxvYyA9IGxlZnRMb2M7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gZmluZEluZGV4IChlU2VhcmNoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5pdGVyYXRvcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VMaXN0LnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VMaXN0LmdldChpKTtcbiAgICBpZiAoZSA9PT0gZVNlYXJjaCkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gIGlmICh0aGlzLl9lZGdlTGlzdCA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2VkZ2VMaXN0ID0gbmV3IEFycmF5TGlzdCh0aGlzLl9lZGdlTWFwLnZhbHVlcygpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZWRnZUxpc3Rcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoZ2VvbUluZGV4LCBwLCBnZW9tKSB7XG4gIGlmICh0aGlzLl9wdEluQXJlYUxvY2F0aW9uW2dlb21JbmRleF0gPT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICB0aGlzLl9wdEluQXJlYUxvY2F0aW9uW2dlb21JbmRleF0gPSBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IubG9jYXRlKHAsIGdlb21bZ2VvbUluZGV4XS5nZXRHZW9tZXRyeSgpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcHRJbkFyZWFMb2NhdGlvbltnZW9tSW5kZXhdXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBidWYuYXBwZW5kKCdFZGdlRW5kU3RhcjogICAnICsgdGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICBidWYuYXBwZW5kKCdcXG4nKTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICBidWYuYXBwZW5kKGUpO1xuICAgIGJ1Zi5hcHBlbmQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5jb21wdXRlRWRnZUVuZExhYmVscyA9IGZ1bmN0aW9uIGNvbXB1dGVFZGdlRW5kTGFiZWxzIChib3VuZGFyeU5vZGVSdWxlKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVlID0gaXQubmV4dCgpO1xuICAgIGVlLmNvbXB1dGVMYWJlbChib3VuZGFyeU5vZGVSdWxlKTtcbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsbGluZyAoZ2VvbUdyYXBoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyhnZW9tR3JhcGhbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKTtcbiAgdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApO1xuICB0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7XG4gIHZhciBoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZSA9IFtmYWxzZSwgZmFsc2VdO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBmb3IgKHZhciBnZW9taSA9IDA7IGdlb21pIDwgMjsgZ2VvbWkrKykge1xuICAgICAgaWYgKGxhYmVsLmlzTGluZShnZW9taSkgJiYgbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbWkpID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZVtnZW9taV0gPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgIHZhciBlJDEgPSBpdCQxLm5leHQoKTtcbiAgICB2YXIgbGFiZWwkMSA9IGUkMS5nZXRMYWJlbCgpO1xuICAgIGZvciAodmFyIGdlb21pJDEgPSAwOyBnZW9taSQxIDwgMjsgZ2VvbWkkMSsrKSB7XG4gICAgICBpZiAobGFiZWwkMS5pc0FueU51bGwoZ2VvbWkkMSkpIHtcbiAgICAgICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgICAgIGlmIChoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZVtnZW9taSQxXSkge1xuICAgICAgICAgIGxvYyA9IExvY2F0aW9uLkVYVEVSSU9SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwID0gZSQxLmdldENvb3JkaW5hdGUoKTtcbiAgICAgICAgICBsb2MgPSB0aGlzJDEuZ2V0TG9jYXRpb24oZ2VvbWkkMSwgcCwgZ2VvbUdyYXBoKTtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbCQxLnNldEFsbExvY2F0aW9uc0lmTnVsbChnZW9taSQxLCBsb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXREZWdyZWUgPSBmdW5jdGlvbiBnZXREZWdyZWUgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZU1hcC5zaXplKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuaW5zZXJ0RWRnZUVuZCA9IGZ1bmN0aW9uIGluc2VydEVkZ2VFbmQgKGUsIG9iaikge1xuICB0aGlzLl9lZGdlTWFwLnB1dChlLCBvYmopO1xuICB0aGlzLl9lZGdlTGlzdCA9IG51bGw7XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlRW5kU3RhclxufTtcblxudmFyIERpcmVjdGVkRWRnZVN0YXIgPSAoZnVuY3Rpb24gKEVkZ2VFbmRTdGFyJCQxKSB7XG4gIGZ1bmN0aW9uIERpcmVjdGVkRWRnZVN0YXIgKCkge1xuICAgIEVkZ2VFbmRTdGFyJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0ID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HID0gMTtcbiAgICB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HID0gMjtcbiAgfVxuXG4gIGlmICggRWRnZUVuZFN0YXIkJDEgKSBEaXJlY3RlZEVkZ2VTdGFyLl9fcHJvdG9fXyA9IEVkZ2VFbmRTdGFyJCQxO1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VFbmRTdGFyJCQxICYmIEVkZ2VFbmRTdGFyJCQxLnByb3RvdHlwZSApO1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGVkRWRnZVN0YXI7XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtcbiAgICB2YXIgZmlyc3RPdXQgPSBudWxsO1xuICAgIHZhciBpbmNvbWluZyA9IG51bGw7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTsgaSsrKSB7XG4gICAgICB2YXIgbmV4dE91dCA9IHRoaXMkMS5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKCFuZXh0T3V0LmdldExhYmVsKCkuaXNBcmVhKCkpIHsgY29udGludWUgfVxuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsICYmIG5leHRPdXQuaXNJblJlc3VsdCgpKSB7IGZpcnN0T3V0ID0gbmV4dE91dDsgfVxuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOlxuICAgICAgICAgIGlmICghbmV4dEluLmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcgPSBuZXh0SW47XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc6XG4gICAgICAgICAgaWYgKCFuZXh0T3V0LmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcuc2V0TmV4dChuZXh0T3V0KTtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5fTElOS0lOR19UT19PVVRHT0lORykge1xuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignbm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZCcsIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgICBBc3NlcnQuaXNUcnVlKGZpcnN0T3V0LmlzSW5SZXN1bHQoKSwgJ3VuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZScpO1xuICAgICAgaW5jb21pbmcuc2V0TmV4dChmaXJzdE91dCk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGVlKSB7XG4gICAgdmFyIGRlID0gZWU7XG4gICAgdGhpcy5pbnNlcnRFZGdlRW5kKGRlLCBkZSk7XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldFJpZ2h0bW9zdEVkZ2UgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RFZGdlICgpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEVkZ2VzKCk7XG4gICAgdmFyIHNpemUgPSBlZGdlcy5zaXplKCk7XG4gICAgaWYgKHNpemUgPCAxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgZGUwID0gZWRnZXMuZ2V0KDApO1xuICAgIGlmIChzaXplID09PSAxKSB7IHJldHVybiBkZTAgfVxuICAgIHZhciBkZUxhc3QgPSBlZGdlcy5nZXQoc2l6ZSAtIDEpO1xuICAgIHZhciBxdWFkMCA9IGRlMC5nZXRRdWFkcmFudCgpO1xuICAgIHZhciBxdWFkMSA9IGRlTGFzdC5nZXRRdWFkcmFudCgpO1xuICAgIGlmIChRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQwKSAmJiBRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQxKSkgeyByZXR1cm4gZGUwOyB9IGVsc2UgaWYgKCFRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQwKSAmJiAhUXVhZHJhbnQuaXNOb3J0aGVybihxdWFkMSkpIHsgcmV0dXJuIGRlTGFzdDsgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnN0IG5vbkhvcml6b250YWxFZGdlID0gbnVsbFxuICAgICAgaWYgKGRlMC5nZXREeSgpICE9PSAwKSB7IHJldHVybiBkZTA7IH0gZWxzZSBpZiAoZGVMYXN0LmdldER5KCkgIT09IDApIHsgcmV0dXJuIGRlTGFzdCB9XG4gICAgfVxuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZScpO1xuICAgIHJldHVybiBudWxsXG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIFN5c3RlbS5vdXQucHJpbnRsbignRGlyZWN0ZWRFZGdlU3RhcjogJyArIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgb3V0LnByaW50KCdvdXQgJyk7XG4gICAgICBkZS5wcmludChvdXQpO1xuICAgICAgb3V0LnByaW50bG4oKTtcbiAgICAgIG91dC5wcmludCgnaW4gJyk7XG4gICAgICBkZS5nZXRTeW0oKS5wcmludChvdXQpO1xuICAgICAgb3V0LnByaW50bG4oKTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldFJlc3VsdEFyZWFFZGdlcyA9IGZ1bmN0aW9uIGdldFJlc3VsdEFyZWFFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0ICE9PSBudWxsKSB7IHJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QgfVxuICAgIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSB8fCBkZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpIHsgdGhpcyQxLl9yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGRlKTsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsbGluZyAobm9kZUxhYmVsKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gICAgICBsYWJlbC5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCwgbm9kZUxhYmVsLmdldExvY2F0aW9uKDApKTtcbiAgICAgIGxhYmVsLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLCBub2RlTGFiZWwuZ2V0TG9jYXRpb24oMSkpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubGlua0FsbERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rQWxsRGlyZWN0ZWRFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmdldEVkZ2VzKCk7XG4gICAgdmFyIHByZXZPdXQgPSBudWxsO1xuICAgIHZhciBmaXJzdEluID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZWRnZUxpc3Quc2l6ZSgpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBuZXh0T3V0ID0gdGhpcyQxLl9lZGdlTGlzdC5nZXQoaSk7XG4gICAgICB2YXIgbmV4dEluID0gbmV4dE91dC5nZXRTeW0oKTtcbiAgICAgIGlmIChmaXJzdEluID09PSBudWxsKSB7IGZpcnN0SW4gPSBuZXh0SW47IH1cbiAgICAgIGlmIChwcmV2T3V0ICE9PSBudWxsKSB7IG5leHRJbi5zZXROZXh0KHByZXZPdXQpOyB9XG4gICAgICBwcmV2T3V0ID0gbmV4dE91dDtcbiAgICB9XG4gICAgZmlyc3RJbi5zZXROZXh0KHByZXZPdXQpO1xuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5jb21wdXRlRGVwdGhzID0gZnVuY3Rpb24gY29tcHV0ZURlcHRocyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGVkZ2VJbmRleCA9IHRoaXMuZmluZEluZGV4KGRlKTtcbiAgICAgIC8vIGNvbnN0IGxhYmVsID0gZGUuZ2V0TGFiZWwoKVxuICAgICAgdmFyIHN0YXJ0RGVwdGggPSBkZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKTtcbiAgICAgIHZhciB0YXJnZXRMYXN0RGVwdGggPSBkZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCk7XG4gICAgICB2YXIgbmV4dERlcHRoID0gdGhpcy5jb21wdXRlRGVwdGhzKGVkZ2VJbmRleCArIDEsIHRoaXMuX2VkZ2VMaXN0LnNpemUoKSwgc3RhcnREZXB0aCk7XG4gICAgICB2YXIgbGFzdERlcHRoID0gdGhpcy5jb21wdXRlRGVwdGhzKDAsIGVkZ2VJbmRleCwgbmV4dERlcHRoKTtcbiAgICAgIGlmIChsYXN0RGVwdGggIT09IHRhcmdldExhc3REZXB0aCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ2RlcHRoIG1pc21hdGNoIGF0ICcgKyBkZS5nZXRDb29yZGluYXRlKCkpIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGVuZEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YXJ0RGVwdGgkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjdXJyRGVwdGggPSBzdGFydERlcHRoJDE7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdmFyIG5leHREZSA9IHRoaXMkMS5fZWRnZUxpc3QuZ2V0KGkpO1xuICAgICAgICAvLyBjb25zdCBsYWJlbCA9IG5leHREZS5nZXRMYWJlbCgpXG4gICAgICAgIG5leHREZS5zZXRFZGdlRGVwdGhzKFBvc2l0aW9uLlJJR0hULCBjdXJyRGVwdGgpO1xuICAgICAgICBjdXJyRGVwdGggPSBuZXh0RGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyckRlcHRoXG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5tZXJnZVN5bUxhYmVscyA9IGZ1bmN0aW9uIG1lcmdlU3ltTGFiZWxzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgICAgIGxhYmVsLm1lcmdlKGRlLmdldFN5bSgpLmdldExhYmVsKCkpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua01pbmltYWxEaXJlY3RlZEVkZ2VzIChlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0T3V0ID0gbnVsbDtcbiAgICB2YXIgaW5jb21pbmcgPSBudWxsO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbmV4dE91dCA9IHRoaXMkMS5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsICYmIG5leHRPdXQuZ2V0RWRnZVJpbmcoKSA9PT0gZXIpIHsgZmlyc3RPdXQgPSBuZXh0T3V0OyB9XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgdGhpcyQxLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6XG4gICAgICAgICAgaWYgKG5leHRJbi5nZXRFZGdlUmluZygpICE9PSBlcikgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcgPSBuZXh0SW47XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc6XG4gICAgICAgICAgaWYgKG5leHRPdXQuZ2V0RWRnZVJpbmcoKSAhPT0gZXIpIHsgY29udGludWUgfVxuICAgICAgICAgIGluY29taW5nLnNldE5leHRNaW4obmV4dE91dCk7XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpIHtcbiAgICAgIEFzc2VydC5pc1RydWUoZmlyc3RPdXQgIT09IG51bGwsICdmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlJyk7XG4gICAgICBBc3NlcnQuaXNUcnVlKGZpcnN0T3V0LmdldEVkZ2VSaW5nKCkgPT09IGVyLCAndW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlJyk7XG4gICAgICBpbmNvbWluZy5zZXROZXh0TWluKGZpcnN0T3V0KTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldE91dGdvaW5nRGVncmVlID0gZnVuY3Rpb24gZ2V0T3V0Z29pbmdEZWdyZWUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSkgeyBkZWdyZWUrKzsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZ3JlZVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRlZ3JlZSQxID0gMDtcbiAgICAgIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZGUkMSA9IGl0JDEubmV4dCgpO1xuICAgICAgICBpZiAoZGUkMS5nZXRFZGdlUmluZygpID09PSBlcikgeyBkZWdyZWUkMSsrOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVncmVlJDFcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICAgIHJldHVybiB0aGlzLl9sYWJlbFxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5maW5kQ292ZXJlZExpbmVFZGdlcyA9IGZ1bmN0aW9uIGZpbmRDb3ZlcmVkTGluZUVkZ2VzICgpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbmV4dE91dCA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKCFuZXh0T3V0LmlzTGluZUVkZ2UoKSkge1xuICAgICAgICBpZiAobmV4dE91dC5pc0luUmVzdWx0KCkpIHtcbiAgICAgICAgICBzdGFydExvYyA9IExvY2F0aW9uLklOVEVSSU9SO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRJbi5pc0luUmVzdWx0KCkpIHtcbiAgICAgICAgICBzdGFydExvYyA9IExvY2F0aW9uLkVYVEVSSU9SO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0TG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY3VyckxvYyA9IHN0YXJ0TG9jO1xuICAgIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5leHRPdXQkMSA9IGl0JDEubmV4dCgpO1xuICAgICAgdmFyIG5leHRJbiQxID0gbmV4dE91dCQxLmdldFN5bSgpO1xuICAgICAgaWYgKG5leHRPdXQkMS5pc0xpbmVFZGdlKCkpIHtcbiAgICAgICAgbmV4dE91dCQxLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGN1cnJMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXh0T3V0JDEuaXNJblJlc3VsdCgpKSB7IGN1cnJMb2MgPSBMb2NhdGlvbi5FWFRFUklPUjsgfVxuICAgICAgICBpZiAobmV4dEluJDEuaXNJblJlc3VsdCgpKSB7IGN1cnJMb2MgPSBMb2NhdGlvbi5JTlRFUklPUjsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbGxpbmcgKGdlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEVkZ2VFbmRTdGFyJCQxLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcywgZ2VvbSk7XG4gICAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoTG9jYXRpb24uTk9ORSk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBlID0gZWUuZ2V0RWRnZSgpO1xuICAgICAgdmFyIGVMYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBlTG9jID0gZUxhYmVsLmdldExvY2F0aW9uKGkpO1xuICAgICAgICBpZiAoZUxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IgfHwgZUxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgdGhpcyQxLl9sYWJlbC5zZXRMb2NhdGlvbihpLCBMb2NhdGlvbi5JTlRFUklPUik7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gRGlyZWN0ZWRFZGdlU3RhclxuICB9O1xuXG4gIHJldHVybiBEaXJlY3RlZEVkZ2VTdGFyO1xufShFZGdlRW5kU3RhcikpO1xuXG52YXIgT3ZlcmxheU5vZGVGYWN0b3J5ID0gKGZ1bmN0aW9uIChOb2RlRmFjdG9yeSQkMSkge1xuICBmdW5jdGlvbiBPdmVybGF5Tm9kZUZhY3RvcnkgKCkge1xuICAgIE5vZGVGYWN0b3J5JCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIE5vZGVGYWN0b3J5JCQxICkgT3ZlcmxheU5vZGVGYWN0b3J5Ll9fcHJvdG9fXyA9IE5vZGVGYWN0b3J5JCQxO1xuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTm9kZUZhY3RvcnkkJDEgJiYgTm9kZUZhY3RvcnkkJDEucHJvdG90eXBlICk7XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPdmVybGF5Tm9kZUZhY3Rvcnk7XG5cbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlTm9kZSAoY29vcmQpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUoY29vcmQsIG5ldyBEaXJlY3RlZEVkZ2VTdGFyKCkpXG4gIH07XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE92ZXJsYXlOb2RlRmFjdG9yeVxuICB9O1xuXG4gIHJldHVybiBPdmVybGF5Tm9kZUZhY3Rvcnk7XG59KE5vZGVGYWN0b3J5KSk7XG5cbnZhciBPcmllbnRlZENvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5ICgpIHtcbiAgdGhpcy5fcHRzID0gbnVsbDtcbiAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wdHMgPSBwdHM7XG4gIHRoaXMuX29yaWVudGF0aW9uID0gT3JpZW50ZWRDb29yZGluYXRlQXJyYXkub3JpZW50YXRpb24ocHRzKTtcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvMSkge1xuICB2YXIgb2NhID0gbzE7XG4gIHZhciBjb21wID0gT3JpZW50ZWRDb29yZGluYXRlQXJyYXkuY29tcGFyZU9yaWVudGVkKHRoaXMuX3B0cywgdGhpcy5fb3JpZW50YXRpb24sIG9jYS5fcHRzLCBvY2EuX29yaWVudGF0aW9uKTtcbiAgcmV0dXJuIGNvbXBcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPcmllbnRlZENvb3JkaW5hdGVBcnJheVxufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5Lm9yaWVudGF0aW9uID0gZnVuY3Rpb24gb3JpZW50YXRpb24gKHB0cykge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uKHB0cykgPT09IDFcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5jb21wYXJlT3JpZW50ZWQgPSBmdW5jdGlvbiBjb21wYXJlT3JpZW50ZWQgKHB0czEsIG9yaWVudGF0aW9uMSwgcHRzMiwgb3JpZW50YXRpb24yKSB7XG4gIHZhciBkaXIxID0gb3JpZW50YXRpb24xID8gMSA6IC0xO1xuICB2YXIgZGlyMiA9IG9yaWVudGF0aW9uMiA/IDEgOiAtMTtcbiAgdmFyIGxpbWl0MSA9IG9yaWVudGF0aW9uMSA/IHB0czEubGVuZ3RoIDogLTE7XG4gIHZhciBsaW1pdDIgPSBvcmllbnRhdGlvbjIgPyBwdHMyLmxlbmd0aCA6IC0xO1xuICB2YXIgaTEgPSBvcmllbnRhdGlvbjEgPyAwIDogcHRzMS5sZW5ndGggLSAxO1xuICB2YXIgaTIgPSBvcmllbnRhdGlvbjIgPyAwIDogcHRzMi5sZW5ndGggLSAxO1xuICAvLyBjb25zdCBjb21wID0gMFxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBjb21wUHQgPSBwdHMxW2kxXS5jb21wYXJlVG8ocHRzMltpMl0pO1xuICAgIGlmIChjb21wUHQgIT09IDApIHsgcmV0dXJuIGNvbXBQdCB9XG4gICAgaTEgKz0gZGlyMTtcbiAgICBpMiArPSBkaXIyO1xuICAgIHZhciBkb25lMSA9IGkxID09PSBsaW1pdDE7XG4gICAgdmFyIGRvbmUyID0gaTIgPT09IGxpbWl0MjtcbiAgICBpZiAoZG9uZTEgJiYgIWRvbmUyKSB7IHJldHVybiAtMSB9XG4gICAgaWYgKCFkb25lMSAmJiBkb25lMikgeyByZXR1cm4gMSB9XG4gICAgaWYgKGRvbmUxICYmIGRvbmUyKSB7IHJldHVybiAwIH1cbiAgfVxufTtcblxudmFyIEVkZ2VMaXN0ID0gZnVuY3Rpb24gRWRnZUxpc3QgKCkge1xuICB0aGlzLl9lZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fb2NhTWFwID0gbmV3IFRyZWVNYXAoKTtcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgb3V0LnByaW50KCdNVUxUSUxJTkVTVFJJTkcgKCAnKTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9lZGdlcy5zaXplKCk7IGorKykge1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlcy5nZXQoaik7XG4gICAgaWYgKGogPiAwKSB7IG91dC5wcmludCgnLCcpOyB9XG4gICAgb3V0LnByaW50KCcoJyk7XG4gICAgdmFyIHB0cyA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7IG91dC5wcmludCgnLCcpOyB9XG4gICAgICBvdXQucHJpbnQocHRzW2ldLnggKyAnICcgKyBwdHNbaV0ueSk7XG4gICAgfVxuICAgIG91dC5wcmludGxuKCcpJyk7XG4gIH1cbiAgb3V0LnByaW50KCcpICAnKTtcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChlZGdlQ29sbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSBlZGdlQ29sbC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgfVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5maW5kRWRnZUluZGV4ID0gZnVuY3Rpb24gZmluZEVkZ2VJbmRleCAoZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9lZGdlcy5nZXQoaSkuZXF1YWxzKGUpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXNcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlcy5nZXQoaSlcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZmluZEVxdWFsRWRnZSA9IGZ1bmN0aW9uIGZpbmRFcXVhbEVkZ2UgKGUpIHtcbiAgdmFyIG9jYSA9IG5ldyBPcmllbnRlZENvb3JkaW5hdGVBcnJheShlLmdldENvb3JkaW5hdGVzKCkpO1xuICB2YXIgbWF0Y2hFZGdlID0gdGhpcy5fb2NhTWFwLmdldChvY2EpO1xuICByZXR1cm4gbWF0Y2hFZGdlXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICB0aGlzLl9lZGdlcy5hZGQoZSk7XG4gIHZhciBvY2EgPSBuZXcgT3JpZW50ZWRDb29yZGluYXRlQXJyYXkoZS5nZXRDb29yZGluYXRlcygpKTtcbiAgdGhpcy5fb2NhTWFwLnB1dChvY2EsIGUpO1xufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUxpc3Rcbn07XG5cbnZhciBTZWdtZW50SW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBTZWdtZW50SW50ZXJzZWN0b3IgKCkge307XG5cblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge307XG5TZWdtZW50SW50ZXJzZWN0b3IucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7fTtcblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50SW50ZXJzZWN0b3Jcbn07XG5cbnZhciBJbnRlcnNlY3Rpb25BZGRlciA9IGZ1bmN0aW9uIEludGVyc2VjdGlvbkFkZGVyICgpIHtcbiAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlciA9IGZhbHNlO1xuICB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvciA9IGZhbHNlO1xuICB0aGlzLl9oYXNJbnRlcmlvciA9IGZhbHNlO1xuICB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5udW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bVRlc3RzID0gMDtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9saSA9IGxpO1xufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pc1RyaXZpYWxJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc1RyaXZpYWxJbnRlcnNlY3Rpb24gKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSkge1xuICAgIGlmICh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSA9PT0gMSkge1xuICAgICAgaWYgKEludGVyc2VjdGlvbkFkZGVyLmlzQWRqYWNlbnRTZWdtZW50cyhzZWdJbmRleDAsIHNlZ0luZGV4MSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKGUwLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgdmFyIG1heFNlZ0luZGV4ID0gZTAuc2l6ZSgpIC0gMTtcbiAgICAgICAgaWYgKChzZWdJbmRleDAgPT09IDAgJiYgc2VnSW5kZXgxID09PSBtYXhTZWdJbmRleCkgfHxcbiAgICAgICAgICAgIChzZWdJbmRleDEgPT09IDAgJiYgc2VnSW5kZXgwID09PSBtYXhTZWdJbmRleCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFByb3BlckludGVyc2VjdGlvblBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50XG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3Jcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuZ2V0TGluZUludGVyc2VjdG9yID0gZnVuY3Rpb24gZ2V0TGluZUludGVyc2VjdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xpXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc1Byb3BlckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc1Byb3BlckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNQcm9wZXJcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5udW1UZXN0cysrO1xuICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgdGhpcy5udW1JbnRlcnNlY3Rpb25zKys7XG4gICAgaWYgKHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMrKztcbiAgICAgIHRoaXMuX2hhc0ludGVyaW9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbihlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSkge1xuICAgICAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGUwLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MCwgMCk7XG4gICAgICBlMS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDEsIDEpO1xuICAgICAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHtcbiAgICAgICAgdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKys7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvblxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNJbnRlcmlvclxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50SW50ZXJzZWN0b3JdXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJzZWN0aW9uQWRkZXJcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5pc0FkamFjZW50U2VnbWVudHMgPSBmdW5jdGlvbiBpc0FkamFjZW50U2VnbWVudHMgKGkxLCBpMikge1xuICByZXR1cm4gTWF0aC5hYnMoaTEgLSBpMikgPT09IDFcbn07XG5cbnZhciBFZGdlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gRWRnZUludGVyc2VjdGlvbiAoKSB7XG4gIHRoaXMuY29vcmQgPSBudWxsO1xuICB0aGlzLnNlZ21lbnRJbmRleCA9IG51bGw7XG4gIHRoaXMuZGlzdCA9IG51bGw7XG4gIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGRpc3QgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuY29vcmQgPSBuZXcgQ29vcmRpbmF0ZShjb29yZCk7XG4gIHRoaXMuc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICB0aGlzLmRpc3QgPSBkaXN0O1xufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLnNlZ21lbnRJbmRleFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuY29vcmRcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50KHRoaXMuY29vcmQpO1xuICBvdXQucHJpbnQoJyBzZWcgIyA9ICcgKyB0aGlzLnNlZ21lbnRJbmRleCk7XG4gIG91dC5wcmludGxuKCcgZGlzdCA9ICcgKyB0aGlzLmRpc3QpO1xufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBvdGhlciA9IG9iajtcbiAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlci5zZWdtZW50SW5kZXgsIG90aGVyLmRpc3QpXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuaXNFbmRQb2ludCA9IGZ1bmN0aW9uIGlzRW5kUG9pbnQgKG1heFNlZ21lbnRJbmRleCkge1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IDAgJiYgdGhpcy5kaXN0ID09PSAwLjApIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IG1heFNlZ21lbnRJbmRleCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5jb29yZCArICcgc2VnICMgPSAnICsgdGhpcy5zZWdtZW50SW5kZXggKyAnIGRpc3QgPSAnICsgdGhpcy5kaXN0XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLmRpc3Rcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoc2VnbWVudEluZGV4LCBkaXN0KSB7XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA8IHNlZ21lbnRJbmRleCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPiBzZWdtZW50SW5kZXgpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5kaXN0IDwgZGlzdCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5kaXN0ID4gZGlzdCkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VJbnRlcnNlY3Rpb25cbn07XG5cbnZhciBFZGdlSW50ZXJzZWN0aW9uTGlzdCA9IGZ1bmN0aW9uIEVkZ2VJbnRlcnNlY3Rpb25MaXN0ICgpIHtcbiAgdGhpcy5fbm9kZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuZWRnZSA9IG51bGw7XG4gIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLmVkZ2UgPSBlZGdlO1xufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50bG4oJ0ludGVyc2VjdGlvbnM6Jyk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIGVpLnByaW50KG91dCk7XG4gIH1cbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKClcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuYWRkU3BsaXRFZGdlcyA9IGZ1bmN0aW9uIGFkZFNwbGl0RWRnZXMgKGVkZ2VMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5hZGRFbmRwb2ludHMoKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHZhciBuZXdFZGdlID0gdGhpcyQxLmNyZWF0ZVNwbGl0RWRnZShlaVByZXYsIGVpKTtcbiAgICBlZGdlTGlzdC5hZGQobmV3RWRnZSk7XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuYWRkRW5kcG9pbnRzID0gZnVuY3Rpb24gYWRkRW5kcG9pbnRzICgpIHtcbiAgdmFyIG1heFNlZ0luZGV4ID0gdGhpcy5lZGdlLnB0cy5sZW5ndGggLSAxO1xuICB0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLCAwLCAwLjApO1xuICB0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW21heFNlZ0luZGV4XSwgbWF4U2VnSW5kZXgsIDAuMCk7XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmNyZWF0ZVNwbGl0RWRnZSA9IGZ1bmN0aW9uIGNyZWF0ZVNwbGl0RWRnZSAoZWkwLCBlaTEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbnB0cyA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4ICsgMjtcbiAgdmFyIGxhc3RTZWdTdGFydFB0ID0gdGhpcy5lZGdlLnB0c1tlaTEuc2VnbWVudEluZGV4XTtcbiAgdmFyIHVzZUludFB0MSA9IGVpMS5kaXN0ID4gMC4wIHx8ICFlaTEuY29vcmQuZXF1YWxzMkQobGFzdFNlZ1N0YXJ0UHQpO1xuICBpZiAoIXVzZUludFB0MSkge1xuICAgIG5wdHMtLTtcbiAgfVxuICB2YXIgcHRzID0gbmV3IEFycmF5KG5wdHMpLmZpbGwobnVsbCk7XG4gIHZhciBpcHQgPSAwO1xuICBwdHNbaXB0KytdID0gbmV3IENvb3JkaW5hdGUoZWkwLmNvb3JkKTtcbiAgZm9yICh2YXIgaSA9IGVpMC5zZWdtZW50SW5kZXggKyAxOyBpIDw9IGVpMS5zZWdtZW50SW5kZXg7IGkrKykge1xuICAgIHB0c1tpcHQrK10gPSB0aGlzJDEuZWRnZS5wdHNbaV07XG4gIH1cbiAgaWYgKHVzZUludFB0MSkgeyBwdHNbaXB0XSA9IGVpMS5jb29yZDsgfVxuICByZXR1cm4gbmV3IEVkZ2UocHRzLCBuZXcgTGFiZWwodGhpcy5lZGdlLl9sYWJlbCkpXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoaW50UHQsIHNlZ21lbnRJbmRleCwgZGlzdCkge1xuICB2YXIgZWlOZXcgPSBuZXcgRWRnZUludGVyc2VjdGlvbihpbnRQdCwgc2VnbWVudEluZGV4LCBkaXN0KTtcbiAgdmFyIGVpID0gdGhpcy5fbm9kZU1hcC5nZXQoZWlOZXcpO1xuICBpZiAoZWkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZWlcbiAgfVxuICB0aGlzLl9ub2RlTWFwLnB1dChlaU5ldywgZWlOZXcpO1xuICByZXR1cm4gZWlOZXdcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc0ludGVyc2VjdGlvbiAocHQpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVpLmNvb3JkLmVxdWFscyhwdCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUludGVyc2VjdGlvbkxpc3Rcbn07XG5cbnZhciBNb25vdG9uZUNoYWluSW5kZXhlciA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5JbmRleGVyICgpIHt9O1xuXG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuZ2V0Q2hhaW5TdGFydEluZGljZXMgPSBmdW5jdGlvbiBnZXRDaGFpblN0YXJ0SW5kaWNlcyAocHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHN0YXJ0SW5kZXhMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIoc3RhcnQpKTtcbiAgZG8ge1xuICAgIHZhciBsYXN0ID0gdGhpcyQxLmZpbmRDaGFpbkVuZChwdHMsIHN0YXJ0KTtcbiAgICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIobGFzdCkpO1xuICAgIHN0YXJ0ID0gbGFzdDtcbiAgfSB3aGlsZSAoc3RhcnQgPCBwdHMubGVuZ3RoIC0gMSlcbiAgdmFyIHN0YXJ0SW5kZXggPSBNb25vdG9uZUNoYWluSW5kZXhlci50b0ludEFycmF5KHN0YXJ0SW5kZXhMaXN0KTtcbiAgcmV0dXJuIHN0YXJ0SW5kZXhcbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuZmluZENoYWluRW5kID0gZnVuY3Rpb24gZmluZENoYWluRW5kIChwdHMsIHN0YXJ0KSB7XG4gIHZhciBjaGFpblF1YWQgPSBRdWFkcmFudC5xdWFkcmFudChwdHNbc3RhcnRdLCBwdHNbc3RhcnQgKyAxXSk7XG4gIHZhciBsYXN0ID0gc3RhcnQgKyAxO1xuICB3aGlsZSAobGFzdCA8IHB0cy5sZW5ndGgpIHtcbiAgICB2YXIgcXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tsYXN0IC0gMV0sIHB0c1tsYXN0XSk7XG4gICAgaWYgKHF1YWQgIT09IGNoYWluUXVhZCkgeyBicmVhayB9XG4gICAgbGFzdCsrO1xuICB9XG4gIHJldHVybiBsYXN0IC0gMVxufTtcbk1vbm90b25lQ2hhaW5JbmRleGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbkluZGV4ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbkluZGV4ZXJcbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci50b0ludEFycmF5ID0gZnVuY3Rpb24gdG9JbnRBcnJheSAobGlzdCkge1xuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGlzdC5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGxpc3QuZ2V0KGkpLmludFZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5XG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbkVkZ2UgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluRWRnZSAoKSB7XG4gIHRoaXMuZSA9IG51bGw7XG4gIHRoaXMucHRzID0gbnVsbDtcbiAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgdGhpcy5lbnYxID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMuZW52MiA9IG5ldyBFbnZlbG9wZSgpO1xuICB2YXIgZSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5lID0gZTtcbiAgdGhpcy5wdHMgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBtY2IgPSBuZXcgTW9ub3RvbmVDaGFpbkluZGV4ZXIoKTtcbiAgdGhpcy5zdGFydEluZGV4ID0gbWNiLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKTtcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLnB0c1xufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gZ2V0TWF4WCAoY2hhaW5JbmRleCkge1xuICB2YXIgeDEgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleF1dLng7XG4gIHZhciB4MiA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4ICsgMV1dLng7XG4gIHJldHVybiB4MSA+IHgyID8geDEgOiB4MlxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gZ2V0TWluWCAoY2hhaW5JbmRleCkge1xuICB2YXIgeDEgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleF1dLng7XG4gIHZhciB4MiA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4ICsgMV1dLng7XG4gIHJldHVybiB4MSA8IHgyID8geDEgOiB4MlxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGNoYWluSW5kZXgwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtY2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNoYWluSW5kZXgxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzaSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXgwXSwgdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXgwICsgMV0sIG1jZSwgbWNlLnN0YXJ0SW5kZXhbY2hhaW5JbmRleDFdLCBtY2Uuc3RhcnRJbmRleFtjaGFpbkluZGV4MSArIDFdLCBzaSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNikge1xuICAgIHZhciBzdGFydDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGVuZDAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jZSQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGVuZDEgPSBhcmd1bWVudHNbNF07XG4gICAgdmFyIGVpID0gYXJndW1lbnRzWzVdO1xuICAgIHZhciBwMDAgPSB0aGlzLnB0c1tzdGFydDBdO1xuICAgIHZhciBwMDEgPSB0aGlzLnB0c1tlbmQwXTtcbiAgICB2YXIgcDEwID0gbWNlJDEucHRzW3N0YXJ0MV07XG4gICAgdmFyIHAxMSA9IG1jZSQxLnB0c1tlbmQxXTtcbiAgICBpZiAoZW5kMCAtIHN0YXJ0MCA9PT0gMSAmJiBlbmQxIC0gc3RhcnQxID09PSAxKSB7XG4gICAgICBlaS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSwgc3RhcnQwLCBtY2UkMS5lLCBzdGFydDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhpcy5lbnYxLmluaXQocDAwLCBwMDEpO1xuICAgIHRoaXMuZW52Mi5pbml0KHAxMCwgcDExKTtcbiAgICBpZiAoIXRoaXMuZW52MS5pbnRlcnNlY3RzKHRoaXMuZW52MikpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBtaWQwID0gTWF0aC50cnVuYygoc3RhcnQwICsgZW5kMCkgLyAyKTtcbiAgICB2YXIgbWlkMSA9IE1hdGgudHJ1bmMoKHN0YXJ0MSArIGVuZDEpIC8gMik7XG4gICAgaWYgKHN0YXJ0MCA8IG1pZDApIHtcbiAgICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihzdGFydDAsIG1pZDAsIG1jZSQxLCBzdGFydDEsIG1pZDEsIGVpKTsgfVxuICAgICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihzdGFydDAsIG1pZDAsIG1jZSQxLCBtaWQxLCBlbmQxLCBlaSk7IH1cbiAgICB9XG4gICAgaWYgKG1pZDAgPCBlbmQwKSB7XG4gICAgICBpZiAoc3RhcnQxIDwgbWlkMSkgeyB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obWlkMCwgZW5kMCwgbWNlJDEsIHN0YXJ0MSwgbWlkMSwgZWkpOyB9XG4gICAgICBpZiAobWlkMSA8IGVuZDEpIHsgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG1pZDAsIGVuZDAsIG1jZSQxLCBtaWQxLCBlbmQxLCBlaSk7IH1cbiAgICB9XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0U3RhcnRJbmRleGVzID0gZnVuY3Rpb24gZ2V0U3RhcnRJbmRleGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleFxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3RzIChtY2UsIHNpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtY2Uuc3RhcnRJbmRleC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgIHRoaXMkMS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGksIG1jZSwgaiwgc2kpO1xuICAgIH1cbiAgfVxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbkVkZ2Vcbn07XG5cbnZhciBEZXB0aCA9IGZ1bmN0aW9uIERlcHRoICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fZGVwdGggPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDMpOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IERlcHRoLk5VTExfVkFMVUU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMxID0geyBOVUxMX1ZBTFVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5EZXB0aC5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAoZ2VvbUluZGV4LCBwb3NJbmRleCkge1xuICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF1cbn07XG5EZXB0aC5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aCAoZ2VvbUluZGV4LCBwb3NJbmRleCwgZGVwdGhWYWx1ZSkge1xuICB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XSA9IGRlcHRoVmFsdWU7XG59O1xuRGVwdGgucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMkMS5fZGVwdGhbaV1bal0gIT09IERlcHRoLk5VTExfVkFMVUUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVsxXSA9PT0gRGVwdGguTlVMTF9WQUxVRVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvc0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFtnZW9tSW5kZXgkMV1bcG9zSW5kZXhdID09PSBEZXB0aC5OVUxMX1ZBTFVFXG4gIH1cbn07XG5EZXB0aC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGlmICghdGhpcyQxLmlzTnVsbChpKSkge1xuICAgICAgdmFyIG1pbkRlcHRoID0gdGhpcyQxLl9kZXB0aFtpXVsxXTtcbiAgICAgIGlmICh0aGlzJDEuX2RlcHRoW2ldWzJdIDwgbWluRGVwdGgpIHsgbWluRGVwdGggPSB0aGlzJDEuX2RlcHRoW2ldWzJdOyB9XG4gICAgICBpZiAobWluRGVwdGggPCAwKSB7IG1pbkRlcHRoID0gMDsgfVxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCAzOyBqKyspIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKHRoaXMkMS5fZGVwdGhbaV1bal0gPiBtaW5EZXB0aCkgeyBuZXdWYWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkRlcHRoLnByb3RvdHlwZS5nZXREZWx0YSA9IGZ1bmN0aW9uIGdldERlbHRhIChnZW9tSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bUG9zaXRpb24uUklHSFRdIC0gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtQb3NpdGlvbi5MRUZUXVxufTtcbkRlcHRoLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uIChnZW9tSW5kZXgsIHBvc0luZGV4KSB7XG4gIGlmICh0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XSA8PSAwKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIHJldHVybiBMb2NhdGlvbi5JTlRFUklPUlxufTtcbkRlcHRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdBOiAnICsgdGhpcy5fZGVwdGhbMF1bMV0gKyAnLCcgKyB0aGlzLl9kZXB0aFswXVsyXSArICcgQjogJyArIHRoaXMuX2RlcHRoWzFdWzFdICsgJywnICsgdGhpcy5fZGVwdGhbMV1bMl1cbn07XG5EZXB0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsYmwgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIHZhciBsb2MgPSBsYmwuZ2V0TG9jYXRpb24oaSwgaik7XG4gICAgICAgIGlmIChsb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SIHx8IGxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHtcbiAgICAgICAgICBpZiAodGhpcyQxLmlzTnVsbChpLCBqKSkge1xuICAgICAgICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IERlcHRoLmRlcHRoQXRMb2NhdGlvbihsb2MpO1xuICAgICAgICAgIH0gZWxzZSB7IHRoaXMkMS5fZGVwdGhbaV1bal0gKz0gRGVwdGguZGVwdGhBdExvY2F0aW9uKGxvYyk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF0rKzsgfVxuICB9XG59O1xuRGVwdGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EZXB0aC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEZXB0aFxufTtcbkRlcHRoLmRlcHRoQXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGRlcHRoQXRMb2NhdGlvbiAobG9jYXRpb24pIHtcbiAgaWYgKGxvY2F0aW9uID09PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gMCB9XG4gIGlmIChsb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gRGVwdGguTlVMTF9WQUxVRVxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMS5OVUxMX1ZBTFVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEZXB0aCwgc3RhdGljQWNjZXNzb3JzJDMxICk7XG5cbnZhciBFZGdlID0gKGZ1bmN0aW9uIChHcmFwaENvbXBvbmVudCQkMSkge1xuICBmdW5jdGlvbiBFZGdlICgpIHtcbiAgICBHcmFwaENvbXBvbmVudCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMucHRzID0gbnVsbDtcbiAgICB0aGlzLl9lbnYgPSBudWxsO1xuICAgIHRoaXMuZWlMaXN0ID0gbmV3IEVkZ2VJbnRlcnNlY3Rpb25MaXN0KHRoaXMpO1xuICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICAgIHRoaXMuX21jZSA9IG51bGw7XG4gICAgdGhpcy5faXNJc29sYXRlZCA9IHRydWU7XG4gICAgdGhpcy5fZGVwdGggPSBuZXcgRGVwdGgoKTtcbiAgICB0aGlzLl9kZXB0aERlbHRhID0gMDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIEVkZ2UuY2FsbCh0aGlzLCBwdHMsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHB0cyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5wdHMgPSBwdHMkMTtcbiAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBHcmFwaENvbXBvbmVudCQkMSApIEVkZ2UuX19wcm90b19fID0gR3JhcGhDb21wb25lbnQkJDE7XG4gIEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR3JhcGhDb21wb25lbnQkJDEgJiYgR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlICk7XG4gIEVkZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRnZTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvbGxhcHNlZEVkZ2UgPSBmdW5jdGlvbiBnZXRDb2xsYXBzZWRFZGdlICgpIHtcbiAgICB2YXIgbmV3UHRzID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgbmV3UHRzWzBdID0gdGhpcy5wdHNbMF07XG4gICAgbmV3UHRzWzFdID0gdGhpcy5wdHNbMV07XG4gICAgdmFyIG5ld2UgPSBuZXcgRWRnZShuZXdQdHMsIExhYmVsLnRvTGluZUxhYmVsKHRoaXMuX2xhYmVsKSk7XG4gICAgcmV0dXJuIG5ld2VcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaXNJc29sYXRlZCA9IGZ1bmN0aW9uIGlzSXNvbGF0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0lzb2xhdGVkXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnB0c1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5zZXRJc29sYXRlZCA9IGZ1bmN0aW9uIHNldElzb2xhdGVkIChpc0lzb2xhdGVkKSB7XG4gICAgdGhpcy5faXNJc29sYXRlZCA9IGlzSXNvbGF0ZWQ7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiBzZXROYW1lIChuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCEobyBpbnN0YW5jZW9mIEVkZ2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGUgPSBvO1xuICAgIGlmICh0aGlzLnB0cy5sZW5ndGggIT09IGUucHRzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBpc0VxdWFsRm9yd2FyZCA9IHRydWU7XG4gICAgdmFyIGlzRXF1YWxSZXZlcnNlID0gdHJ1ZTtcbiAgICB2YXIgaVJldiA9IHRoaXMucHRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbaV0pKSB7XG4gICAgICAgIGlzRXF1YWxGb3J3YXJkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbLS1pUmV2XSkpIHtcbiAgICAgICAgaXNFcXVhbFJldmVyc2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFcXVhbEZvcndhcmQgJiYgIWlzRXF1YWxSZXZlcnNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucHRzLmxlbmd0aCA+IDApIHsgcmV0dXJuIHRoaXMucHRzWzBdIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgaSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnB0c1tpXVxuICAgIH1cbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBvdXQucHJpbnQoJ2VkZ2UgJyArIHRoaXMuX25hbWUgKyAnOiAnKTtcbiAgICBvdXQucHJpbnQoJ0xJTkVTVFJJTkcgKCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBvdXQucHJpbnQoJywnKTsgfVxuICAgICAgb3V0LnByaW50KHRoaXMkMS5wdHNbaV0ueCArICcgJyArIHRoaXMkMS5wdHNbaV0ueSk7XG4gICAgfVxuICAgIG91dC5wcmludCgnKSAgJyArIHRoaXMuX2xhYmVsICsgJyAnICsgdGhpcy5fZGVwdGhEZWx0YSk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmNvbXB1dGVJTSA9IGZ1bmN0aW9uIGNvbXB1dGVJTSAoaW0pIHtcbiAgICBFZGdlLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLCBpbSk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzQ29sbGFwc2VkID0gZnVuY3Rpb24gaXNDb2xsYXBzZWQgKCkge1xuICAgIGlmICghdGhpcy5fbGFiZWwuaXNBcmVhKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcy5wdHMubGVuZ3RoICE9PSAzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aCAtIDFdKVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRNYXhpbXVtU2VnbWVudEluZGV4ID0gZnVuY3Rpb24gZ2V0TWF4aW11bVNlZ21lbnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzLmxlbmd0aCAtIDFcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGhEZWx0YSA9IGZ1bmN0aW9uIGdldERlcHRoRGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXB0aERlbHRhXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzLmxlbmd0aFxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5wcmludFJldmVyc2UgPSBmdW5jdGlvbiBwcmludFJldmVyc2UgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgb3V0LnByaW50KCdlZGdlICcgKyB0aGlzLl9uYW1lICsgJzogJyk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBvdXQucHJpbnQodGhpcyQxLnB0c1tpXSArICcgJyk7XG4gICAgfVxuICAgIG91dC5wcmludGxuKCcnKTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UgPSBmdW5jdGlvbiBnZXRNb25vdG9uZUNoYWluRWRnZSAoKSB7XG4gICAgaWYgKHRoaXMuX21jZSA9PT0gbnVsbCkgeyB0aGlzLl9tY2UgPSBuZXcgTW9ub3RvbmVDaGFpbkVkZ2UodGhpcyk7IH1cbiAgICByZXR1cm4gdGhpcy5fbWNlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldEVudmVsb3BlID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2VudiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW52ID0gbmV3IEVudmVsb3BlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5fZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzJDEucHRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudlxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb24gKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCwgaW50SW5kZXgpIHtcbiAgICB2YXIgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZShsaS5nZXRJbnRlcnNlY3Rpb24oaW50SW5kZXgpKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgICB2YXIgZGlzdCA9IGxpLmdldEVkZ2VEaXN0YW5jZShnZW9tSW5kZXgsIGludEluZGV4KTtcbiAgICB2YXIgbmV4dFNlZ0luZGV4ID0gbm9ybWFsaXplZFNlZ21lbnRJbmRleCArIDE7XG4gICAgaWYgKG5leHRTZWdJbmRleCA8IHRoaXMucHRzLmxlbmd0aCkge1xuICAgICAgdmFyIG5leHRQdCA9IHRoaXMucHRzW25leHRTZWdJbmRleF07XG4gICAgICBpZiAoaW50UHQuZXF1YWxzMkQobmV4dFB0KSkge1xuICAgICAgICBub3JtYWxpemVkU2VnbWVudEluZGV4ID0gbmV4dFNlZ0luZGV4O1xuICAgICAgICBkaXN0ID0gMC4wO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVpTGlzdC5hZGQoaW50UHQsIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXgsIGRpc3QpO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gICAgYnVmLmFwcGVuZCgnZWRnZSAnICsgdGhpcy5fbmFtZSArICc6ICcpO1xuICAgIGJ1Zi5hcHBlbmQoJ0xJTkVTVFJJTkcgKCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBidWYuYXBwZW5kKCcsJyk7IH1cbiAgICAgIGJ1Zi5hcHBlbmQodGhpcyQxLnB0c1tpXS54ICsgJyAnICsgdGhpcyQxLnB0c1tpXS55KTtcbiAgICB9XG4gICAgYnVmLmFwcGVuZCgnKSAgJyArIHRoaXMuX2xhYmVsICsgJyAnICsgdGhpcy5fZGVwdGhEZWx0YSk7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzUG9pbnR3aXNlRXF1YWwgPSBmdW5jdGlvbiBpc1BvaW50d2lzZUVxdWFsIChlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wdHMubGVuZ3RoICE9PSBlLnB0cy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5zZXREZXB0aERlbHRhID0gZnVuY3Rpb24gc2V0RGVwdGhEZWx0YSAoZGVwdGhEZWx0YSkge1xuICAgIHRoaXMuX2RlcHRoRGVsdGEgPSBkZXB0aERlbHRhO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCA9IGZ1bmN0aW9uIGdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5laUxpc3RcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaSsrKSB7XG4gICAgICB0aGlzJDEuYWRkSW50ZXJzZWN0aW9uKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCwgaSk7XG4gICAgfVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEVkZ2VcbiAgfTtcbiAgRWRnZS51cGRhdGVJTSA9IGZ1bmN0aW9uIHVwZGF0ZUlNICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGltID0gYXJndW1lbnRzWzFdO1xuICAgICAgaW0uc2V0QXRMZWFzdElmVmFsaWQobGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uT04pLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5PTiksIDEpO1xuICAgICAgaWYgKGxhYmVsLmlzQXJlYSgpKSB7XG4gICAgICAgIGltLnNldEF0TGVhc3RJZlZhbGlkKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLkxFRlQpLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5MRUZUKSwgMik7XG4gICAgICAgIGltLnNldEF0TGVhc3RJZlZhbGlkKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uUklHSFQpLCAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyByZXR1cm4gR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlLnVwZGF0ZUlNLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuXG4gIHJldHVybiBFZGdlO1xufShHcmFwaENvbXBvbmVudCkpO1xuXG52YXIgQnVmZmVyQnVpbGRlciA9IGZ1bmN0aW9uIEJ1ZmZlckJ1aWxkZXIgKGJ1ZlBhcmFtcykge1xuICB0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl93b3JraW5nTm9kZXIgPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdCA9IG51bGw7XG4gIHRoaXMuX2dyYXBoID0gbnVsbDtcbiAgdGhpcy5fZWRnZUxpc3QgPSBuZXcgRWRnZUxpc3QoKTtcbiAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zIHx8IG51bGw7XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsIChwbSkge1xuICB0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWwgPSBwbTtcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5pbnNlcnRVbmlxdWVFZGdlID0gZnVuY3Rpb24gaW5zZXJ0VW5pcXVlRWRnZSAoZSkge1xuICB2YXIgZXhpc3RpbmdFZGdlID0gdGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZShlKTtcbiAgaWYgKGV4aXN0aW5nRWRnZSAhPT0gbnVsbCkge1xuICAgIHZhciBleGlzdGluZ0xhYmVsID0gZXhpc3RpbmdFZGdlLmdldExhYmVsKCk7XG4gICAgdmFyIGxhYmVsVG9NZXJnZSA9IGUuZ2V0TGFiZWwoKTtcbiAgICBpZiAoIWV4aXN0aW5nRWRnZS5pc1BvaW50d2lzZUVxdWFsKGUpKSB7XG4gICAgICBsYWJlbFRvTWVyZ2UgPSBuZXcgTGFiZWwoZS5nZXRMYWJlbCgpKTtcbiAgICAgIGxhYmVsVG9NZXJnZS5mbGlwKCk7XG4gICAgfVxuICAgIGV4aXN0aW5nTGFiZWwubWVyZ2UobGFiZWxUb01lcmdlKTtcbiAgICB2YXIgbWVyZ2VEZWx0YSA9IEJ1ZmZlckJ1aWxkZXIuZGVwdGhEZWx0YShsYWJlbFRvTWVyZ2UpO1xuICAgIHZhciBleGlzdGluZ0RlbHRhID0gZXhpc3RpbmdFZGdlLmdldERlcHRoRGVsdGEoKTtcbiAgICB2YXIgbmV3RGVsdGEgPSBleGlzdGluZ0RlbHRhICsgbWVyZ2VEZWx0YTtcbiAgICBleGlzdGluZ0VkZ2Uuc2V0RGVwdGhEZWx0YShuZXdEZWx0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZWRnZUxpc3QuYWRkKGUpO1xuICAgIGUuc2V0RGVwdGhEZWx0YShCdWZmZXJCdWlsZGVyLmRlcHRoRGVsdGEoZS5nZXRMYWJlbCgpKSk7XG4gIH1cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZFN1YmdyYXBocyA9IGZ1bmN0aW9uIGJ1aWxkU3ViZ3JhcGhzIChzdWJncmFwaExpc3QsIHBvbHlCdWlsZGVyKSB7XG4gIHZhciBwcm9jZXNzZWRHcmFwaHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBzdWJncmFwaExpc3QuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHN1YmdyYXBoID0gaS5uZXh0KCk7XG4gICAgdmFyIHAgPSBzdWJncmFwaC5nZXRSaWdodG1vc3RDb29yZGluYXRlKCk7XG4gICAgdmFyIGxvY2F0ZXIgPSBuZXcgU3ViZ3JhcGhEZXB0aExvY2F0ZXIocHJvY2Vzc2VkR3JhcGhzKTtcbiAgICB2YXIgb3V0c2lkZURlcHRoID0gbG9jYXRlci5nZXREZXB0aChwKTtcbiAgICBzdWJncmFwaC5jb21wdXRlRGVwdGgob3V0c2lkZURlcHRoKTtcbiAgICBzdWJncmFwaC5maW5kUmVzdWx0RWRnZXMoKTtcbiAgICBwcm9jZXNzZWRHcmFwaHMuYWRkKHN1YmdyYXBoKTtcbiAgICBwb2x5QnVpbGRlci5hZGQoc3ViZ3JhcGguZ2V0RGlyZWN0ZWRFZGdlcygpLCBzdWJncmFwaC5nZXROb2RlcygpKTtcbiAgfVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVN1YmdyYXBocyA9IGZ1bmN0aW9uIGNyZWF0ZVN1YmdyYXBocyAoZ3JhcGgpIHtcbiAgdmFyIHN1YmdyYXBoTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IGdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBpLm5leHQoKTtcbiAgICBpZiAoIW5vZGUuaXNWaXNpdGVkKCkpIHtcbiAgICAgIHZhciBzdWJncmFwaCA9IG5ldyBCdWZmZXJTdWJncmFwaCgpO1xuICAgICAgc3ViZ3JhcGguY3JlYXRlKG5vZGUpO1xuICAgICAgc3ViZ3JhcGhMaXN0LmFkZChzdWJncmFwaCk7XG4gICAgfVxuICB9XG4gIENvbGxlY3Rpb25zLnNvcnQoc3ViZ3JhcGhMaXN0LCBDb2xsZWN0aW9ucy5yZXZlcnNlT3JkZXIoKSk7XG4gIHJldHVybiBzdWJncmFwaExpc3Rcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSAoKSB7XG4gIHZhciBlbXB0eUdlb20gPSB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7XG4gIHJldHVybiBlbXB0eUdlb21cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5nZXROb2RlciA9IGZ1bmN0aW9uIGdldE5vZGVyIChwcmVjaXNpb25Nb2RlbCkge1xuICBpZiAodGhpcy5fd29ya2luZ05vZGVyICE9PSBudWxsKSB7IHJldHVybiB0aGlzLl93b3JraW5nTm9kZXIgfVxuICB2YXIgbm9kZXIgPSBuZXcgTUNJbmRleE5vZGVyKCk7XG4gIHZhciBsaSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgbGkuc2V0UHJlY2lzaW9uTW9kZWwocHJlY2lzaW9uTW9kZWwpO1xuICBub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IEludGVyc2VjdGlvbkFkZGVyKGxpKSk7XG4gIHJldHVybiBub2RlclxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uIGJ1ZmZlciAoZywgZGlzdGFuY2UpIHtcbiAgdmFyIHByZWNpc2lvbk1vZGVsID0gdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsO1xuICBpZiAocHJlY2lzaW9uTW9kZWwgPT09IG51bGwpIHsgcHJlY2lzaW9uTW9kZWwgPSBnLmdldFByZWNpc2lvbk1vZGVsKCk7IH1cbiAgdGhpcy5fZ2VvbUZhY3QgPSBnLmdldEZhY3RvcnkoKTtcbiAgdmFyIGN1cnZlQnVpbGRlciA9IG5ldyBPZmZzZXRDdXJ2ZUJ1aWxkZXIocHJlY2lzaW9uTW9kZWwsIHRoaXMuX2J1ZlBhcmFtcyk7XG4gIHZhciBjdXJ2ZVNldEJ1aWxkZXIgPSBuZXcgT2Zmc2V0Q3VydmVTZXRCdWlsZGVyKGcsIGRpc3RhbmNlLCBjdXJ2ZUJ1aWxkZXIpO1xuICB2YXIgYnVmZmVyU2VnU3RyTGlzdCA9IGN1cnZlU2V0QnVpbGRlci5nZXRDdXJ2ZXMoKTtcbiAgaWYgKGJ1ZmZlclNlZ1N0ckxpc3Quc2l6ZSgpIDw9IDApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KClcbiAgfVxuICB0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKGJ1ZmZlclNlZ1N0ckxpc3QsIHByZWNpc2lvbk1vZGVsKTtcbiAgdGhpcy5fZ3JhcGggPSBuZXcgUGxhbmFyR3JhcGgobmV3IE92ZXJsYXlOb2RlRmFjdG9yeSgpKTtcbiAgdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gIHZhciBzdWJncmFwaExpc3QgPSB0aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLl9ncmFwaCk7XG4gIHZhciBwb2x5QnVpbGRlciA9IG5ldyBQb2x5Z29uQnVpbGRlcih0aGlzLl9nZW9tRmFjdCk7XG4gIHRoaXMuYnVpbGRTdWJncmFwaHMoc3ViZ3JhcGhMaXN0LCBwb2x5QnVpbGRlcik7XG4gIHZhciByZXN1bHRQb2x5TGlzdCA9IHBvbHlCdWlsZGVyLmdldFBvbHlnb25zKCk7XG4gIGlmIChyZXN1bHRQb2x5TGlzdC5zaXplKCkgPD0gMCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKVxuICB9XG4gIHZhciByZXN1bHRHZW9tID0gdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShyZXN1bHRQb2x5TGlzdCk7XG4gIHJldHVybiByZXN1bHRHZW9tXG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVkRWRnZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZWRFZGdlcyAoYnVmZmVyU2VnU3RyTGlzdCwgcHJlY2lzaW9uTW9kZWwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXIgPSB0aGlzLmdldE5vZGVyKHByZWNpc2lvbk1vZGVsKTtcbiAgbm9kZXIuY29tcHV0ZU5vZGVzKGJ1ZmZlclNlZ1N0ckxpc3QpO1xuICB2YXIgbm9kZWRTZWdTdHJpbmdzID0gbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7XG4gIGZvciAodmFyIGkgPSBub2RlZFNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHNlZ1N0ciA9IGkubmV4dCgpO1xuICAgIHZhciBwdHMgPSBzZWdTdHIuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAocHRzLmxlbmd0aCA9PT0gMiAmJiBwdHNbMF0uZXF1YWxzMkQocHRzWzFdKSkgeyBjb250aW51ZSB9XG4gICAgdmFyIG9sZExhYmVsID0gc2VnU3RyLmdldERhdGEoKTtcbiAgICB2YXIgZWRnZSA9IG5ldyBFZGdlKHNlZ1N0ci5nZXRDb29yZGluYXRlcygpLCBuZXcgTGFiZWwob2xkTGFiZWwpKTtcbiAgICB0aGlzJDEuaW5zZXJ0VW5pcXVlRWRnZShlZGdlKTtcbiAgfVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLnNldE5vZGVyID0gZnVuY3Rpb24gc2V0Tm9kZXIgKG5vZGVyKSB7XG4gIHRoaXMuX3dvcmtpbmdOb2RlciA9IG5vZGVyO1xufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlckJ1aWxkZXJcbn07XG5CdWZmZXJCdWlsZGVyLmRlcHRoRGVsdGEgPSBmdW5jdGlvbiBkZXB0aERlbHRhIChsYWJlbCkge1xuICB2YXIgbExvYyA9IGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLkxFRlQpO1xuICB2YXIgckxvYyA9IGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKTtcbiAgaWYgKGxMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIHJMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiAxOyB9IGVsc2UgaWYgKGxMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SICYmIHJMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiAwXG59O1xuQnVmZmVyQnVpbGRlci5jb252ZXJ0U2VnU3RyaW5ncyA9IGZ1bmN0aW9uIGNvbnZlcnRTZWdTdHJpbmdzIChpdCkge1xuICB2YXIgZmFjdCA9IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIHNzID0gaXQubmV4dCgpO1xuICAgIHZhciBsaW5lID0gZmFjdC5jcmVhdGVMaW5lU3RyaW5nKHNzLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIGxpbmVzLmFkZChsaW5lKTtcbiAgfVxuICByZXR1cm4gZmFjdC5idWlsZEdlb21ldHJ5KGxpbmVzKVxufTtcblxudmFyIFNjYWxlZE5vZGVyID0gZnVuY3Rpb24gU2NhbGVkTm9kZXIgKCkge1xuICB0aGlzLl9ub2RlciA9IG51bGw7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gbnVsbDtcbiAgdGhpcy5fb2Zmc2V0WCA9IG51bGw7XG4gIHRoaXMuX29mZnNldFkgPSBudWxsO1xuICB0aGlzLl9pc1NjYWxlZCA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBub2RlciA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbm9kZXIgPSBub2RlcjtcbiAgICB0aGlzLl9zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuX29mZnNldFggPSAwLjA7XG4gICAgdGhpcy5fb2Zmc2V0WSA9IDAuMDtcbiAgICB0aGlzLl9pc1NjYWxlZCA9ICF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgbm9kZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2NhbGVGYWN0b3IkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2Zmc2V0WCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgb2Zmc2V0WSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLl9ub2RlciA9IG5vZGVyJDE7XG4gICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvciQxO1xuICAgIHRoaXMuX29mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMuX29mZnNldFkgPSBvZmZzZXRZO1xuICAgIHRoaXMuX2lzU2NhbGVkID0gIXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCk7XG4gIH1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUucmVzY2FsZSA9IGZ1bmN0aW9uIHJlc2NhbGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSkge1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSBzZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICB0aGlzJDEucmVzY2FsZShzcy5nZXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgIC8vIGxldCBwMCA9IG51bGxcbiAgICAvLyBsZXQgcDEgPSBudWxsXG4gICAgLy8gaWYgKHB0cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBwMCA9IG5ldyBDb29yZGluYXRlKHB0c1swXSlcbiAgICAvLyBwMSA9IG5ldyBDb29yZGluYXRlKHB0c1sxXSlcbiAgICAvLyB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHRzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIHB0c1tpJDFdLnggPSBwdHNbaSQxXS54IC8gdGhpcyQxLl9zY2FsZUZhY3RvciArIHRoaXMkMS5fb2Zmc2V0WDtcbiAgICAgIHB0c1tpJDFdLnkgPSBwdHNbaSQxXS55IC8gdGhpcyQxLl9zY2FsZUZhY3RvciArIHRoaXMkMS5fb2Zmc2V0WTtcbiAgICB9XG4gICAgaWYgKHB0cy5sZW5ndGggPT09IDIgJiYgcHRzWzBdLmVxdWFsczJEKHB0c1sxXSkpIHtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihwdHMpO1xuICAgIH1cbiAgfVxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikpIHtcbiAgICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZWRTZWdtZW50U3RyaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgbm9kZWRTZWdtZW50U3RyaW5ncy5hZGQobmV3IE5vZGVkU2VnbWVudFN0cmluZyh0aGlzJDEuc2NhbGUoc3MuZ2V0Q29vcmRpbmF0ZXMoKSksIHNzLmdldERhdGEoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZWRTZWdtZW50U3RyaW5nc1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcm91bmRQdHMgPSBuZXcgQXJyYXkocHRzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgcm91bmRQdHNbaSQxXSA9IG5ldyBDb29yZGluYXRlKE1hdGgucm91bmQoKHB0c1tpJDFdLnggLSB0aGlzJDEuX29mZnNldFgpICogdGhpcyQxLl9zY2FsZUZhY3RvciksIE1hdGgucm91bmQoKHB0c1tpJDFdLnkgLSB0aGlzJDEuX29mZnNldFkpICogdGhpcyQxLl9zY2FsZUZhY3RvciksIHB0c1tpJDFdLnopO1xuICAgIH1cbiAgICB2YXIgcm91bmRQdHNOb0R1cCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMocm91bmRQdHMpO1xuICAgIHJldHVybiByb3VuZFB0c05vRHVwXG4gIH1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuaXNJbnRlZ2VyUHJlY2lzaW9uID0gZnVuY3Rpb24gaXNJbnRlZ2VyUHJlY2lzaW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NjYWxlRmFjdG9yID09PSAxLjBcbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgdmFyIHNwbGl0U1MgPSB0aGlzLl9ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtcbiAgaWYgKHRoaXMuX2lzU2NhbGVkKSB7IHRoaXMucmVzY2FsZShzcGxpdFNTKTsgfVxuICByZXR1cm4gc3BsaXRTU1xufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZXMgKGlucHV0U2VnU3RyaW5ncykge1xuICB2YXIgaW50U2VnU3RyaW5ncyA9IGlucHV0U2VnU3RyaW5ncztcbiAgaWYgKHRoaXMuX2lzU2NhbGVkKSB7IGludFNlZ1N0cmluZ3MgPSB0aGlzLnNjYWxlKGlucHV0U2VnU3RyaW5ncyk7IH1cbiAgdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKGludFNlZ1N0cmluZ3MpO1xufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtOb2Rlcl1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTY2FsZWROb2RlclxufTtcblxudmFyIE5vZGluZ1ZhbGlkYXRvciA9IGZ1bmN0aW9uIE5vZGluZ1ZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gbnVsbDtcbiAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3NlZ1N0cmluZ3MgPSBzZWdTdHJpbmdzO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzMyA9IHsgZmFjdDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICB2YXIgcHRzID0gc3MuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHRoaXMkMS5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhwdHNbMF0sIHRoaXMkMS5fc2VnU3RyaW5ncyk7XG4gICAgICB0aGlzJDEuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMocHRzW3B0cy5sZW5ndGggLSAxXSwgdGhpcyQxLl9zZWdTdHJpbmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB0ZXN0UHQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMV07XG4gICAgZm9yICh2YXIgaSQxID0gc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzJDEgPSBpJDEubmV4dCgpO1xuICAgICAgdmFyIHB0cyQxID0gc3MkMS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwdHMkMS5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgaWYgKHB0cyQxW2pdLmVxdWFscyh0ZXN0UHQpKSB7IHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggJyArIGogKyAnIDpwdCAnICsgdGVzdFB0KSB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzMCA9IGkubmV4dCgpO1xuICAgICAgZm9yICh2YXIgaiA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgai5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBzczEgPSBqLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHNzMCwgc3MxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzczAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3MxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0czAgPSBzczAkMS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBwdHMxID0gc3MxJDEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpMCA9IDA7IGkwIDwgcHRzMC5sZW5ndGggLSAxOyBpMCsrKSB7XG4gICAgICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgcHRzMS5sZW5ndGggLSAxOyBpMSsrKSB7XG4gICAgICAgIHRoaXMkMS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhzczAkMSwgaTAsIHNzMSQxLCBpMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZTAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ0luZGV4MCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHNlZ0luZGV4MSA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICAgIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICAgIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gICAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gICAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICAgIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkgfHwgdGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSwgcDAwLCBwMDEpIHx8IHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksIHAxMCwgcDExKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCAnICsgcDAwICsgJy0nICsgcDAxICsgJyBhbmQgJyArIHAxMCArICctJyArIHAxMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkICgpIHtcbiAgdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpO1xuICB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuY2hlY2tDb2xsYXBzZXMoKTtcbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrQ29sbGFwc2VzID0gZnVuY3Rpb24gY2hlY2tDb2xsYXBzZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIHRoaXMkMS5jaGVja0NvbGxhcHNlcyhzcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc3MkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHRzID0gc3MkMS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHB0cy5sZW5ndGggLSAyOyBpJDErKykge1xuICAgICAgdGhpcyQxLmNoZWNrQ29sbGFwc2UocHRzW2kkMV0sIHB0c1tpJDEgKyAxXSwgcHRzW2kkMSArIDJdKTtcbiAgICB9XG4gIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gKGxpLCBwMCwgcDEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaSsrKSB7XG4gICAgdmFyIGludFB0ID0gbGkuZ2V0SW50ZXJzZWN0aW9uKGkpO1xuICAgIGlmICghKGludFB0LmVxdWFscyhwMCkgfHwgaW50UHQuZXF1YWxzKHAxKSkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tDb2xsYXBzZSA9IGZ1bmN0aW9uIGNoZWNrQ29sbGFwc2UgKHAwLCBwMSwgcDIpIHtcbiAgaWYgKHAwLmVxdWFscyhwMikpIHsgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2ZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCAnICsgTm9kaW5nVmFsaWRhdG9yLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbcDAsIHAxLCBwMl0pKSB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGluZ1ZhbGlkYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMy5mYWN0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBHZW9tZXRyeUZhY3RvcnkoKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTm9kaW5nVmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMzMgKTtcblxudmFyIEhvdFBpeGVsID0gZnVuY3Rpb24gSG90UGl4ZWwgKCkge1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX3B0ID0gbnVsbDtcbiAgdGhpcy5fb3JpZ2luYWxQdCA9IG51bGw7XG4gIHRoaXMuX3B0U2NhbGVkID0gbnVsbDtcbiAgdGhpcy5fcDBTY2FsZWQgPSBudWxsO1xuICB0aGlzLl9wMVNjYWxlZCA9IG51bGw7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gbnVsbDtcbiAgdGhpcy5fbWlueCA9IG51bGw7XG4gIHRoaXMuX21heHggPSBudWxsO1xuICB0aGlzLl9taW55ID0gbnVsbDtcbiAgdGhpcy5fbWF4eSA9IG51bGw7XG4gIHRoaXMuX2Nvcm5lciA9IG5ldyBBcnJheSg0KS5maWxsKG51bGwpO1xuICB0aGlzLl9zYWZlRW52ID0gbnVsbDtcbiAgdmFyIHB0ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgc2NhbGVGYWN0b3IgPSBhcmd1bWVudHNbMV07XG4gIHZhciBsaSA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fb3JpZ2luYWxQdCA9IHB0O1xuICB0aGlzLl9wdCA9IHB0O1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICB0aGlzLl9saSA9IGxpO1xuICBpZiAoc2NhbGVGYWN0b3IgPD0gMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVybycpIH1cbiAgaWYgKHNjYWxlRmFjdG9yICE9PSAxLjApIHtcbiAgICB0aGlzLl9wdCA9IG5ldyBDb29yZGluYXRlKHRoaXMuc2NhbGUocHQueCksIHRoaXMuc2NhbGUocHQueSkpO1xuICAgIHRoaXMuX3AwU2NhbGVkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLl9wMVNjYWxlZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIH1cbiAgdGhpcy5pbml0Q29ybmVycyh0aGlzLl9wdCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM0ID0geyBTQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0c1NjYWxlZCA9IGZ1bmN0aW9uIGludGVyc2VjdHNTY2FsZWQgKHAwLCBwMSkge1xuICB2YXIgc2VnTWlueCA9IE1hdGgubWluKHAwLngsIHAxLngpO1xuICB2YXIgc2VnTWF4eCA9IE1hdGgubWF4KHAwLngsIHAxLngpO1xuICB2YXIgc2VnTWlueSA9IE1hdGgubWluKHAwLnksIHAxLnkpO1xuICB2YXIgc2VnTWF4eSA9IE1hdGgubWF4KHAwLnksIHAxLnkpO1xuICB2YXIgaXNPdXRzaWRlUGl4ZWxFbnYgPSB0aGlzLl9tYXh4IDwgc2VnTWlueCB8fCB0aGlzLl9taW54ID4gc2VnTWF4eCB8fCB0aGlzLl9tYXh5IDwgc2VnTWlueSB8fCB0aGlzLl9taW55ID4gc2VnTWF4eTtcbiAgaWYgKGlzT3V0c2lkZVBpeGVsRW52KSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBpbnRlcnNlY3RzID0gdGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHAwLCBwMSk7XG4gIEFzc2VydC5pc1RydWUoIShpc091dHNpZGVQaXhlbEVudiAmJiBpbnRlcnNlY3RzKSwgJ0ZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0Jyk7XG4gIHJldHVybiBpbnRlcnNlY3RzXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmluaXRDb3JuZXJzID0gZnVuY3Rpb24gaW5pdENvcm5lcnMgKHB0KSB7XG4gIHZhciB0b2xlcmFuY2UgPSAwLjU7XG4gIHRoaXMuX21pbnggPSBwdC54IC0gdG9sZXJhbmNlO1xuICB0aGlzLl9tYXh4ID0gcHQueCArIHRvbGVyYW5jZTtcbiAgdGhpcy5fbWlueSA9IHB0LnkgLSB0b2xlcmFuY2U7XG4gIHRoaXMuX21heHkgPSBwdC55ICsgdG9sZXJhbmNlO1xuICB0aGlzLl9jb3JuZXJbMF0gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXh4LCB0aGlzLl9tYXh5KTtcbiAgdGhpcy5fY29ybmVyWzFdID0gbmV3IENvb3JkaW5hdGUodGhpcy5fbWlueCwgdGhpcy5fbWF4eSk7XG4gIHRoaXMuX2Nvcm5lclsyXSA9IG5ldyBDb29yZGluYXRlKHRoaXMuX21pbngsIHRoaXMuX21pbnkpO1xuICB0aGlzLl9jb3JuZXJbM10gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXh4LCB0aGlzLl9taW55KTtcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHAwLCBwMSkge1xuICBpZiAodGhpcy5fc2NhbGVGYWN0b3IgPT09IDEuMCkgeyByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHAwLCBwMSkgfVxuICB0aGlzLmNvcHlTY2FsZWQocDAsIHRoaXMuX3AwU2NhbGVkKTtcbiAgdGhpcy5jb3B5U2NhbGVkKHAxLCB0aGlzLl9wMVNjYWxlZCk7XG4gIHJldHVybiB0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5fcDBTY2FsZWQsIHRoaXMuX3AxU2NhbGVkKVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlICh2YWwpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsICogdGhpcy5fc2NhbGVGYWN0b3IpXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX29yaWdpbmFsUHRcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuY29weVNjYWxlZCA9IGZ1bmN0aW9uIGNvcHlTY2FsZWQgKHAsIHBTY2FsZWQpIHtcbiAgcFNjYWxlZC54ID0gdGhpcy5zY2FsZShwLngpO1xuICBwU2NhbGVkLnkgPSB0aGlzLnNjYWxlKHAueSk7XG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmdldFNhZmVFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldFNhZmVFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9zYWZlRW52ID09PSBudWxsKSB7XG4gICAgdmFyIHNhZmVUb2xlcmFuY2UgPSBIb3RQaXhlbC5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SIC8gdGhpcy5fc2NhbGVGYWN0b3I7XG4gICAgdGhpcy5fc2FmZUVudiA9IG5ldyBFbnZlbG9wZSh0aGlzLl9vcmlnaW5hbFB0LnggLSBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnggKyBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnkgLSBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnkgKyBzYWZlVG9sZXJhbmNlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fc2FmZUVudlxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzUGl4ZWxDbG9zdXJlID0gZnVuY3Rpb24gaW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSAocDAsIHAxKSB7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMF0sIHRoaXMuX2Nvcm5lclsxXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMV0sIHRoaXMuX2Nvcm5lclsyXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMl0sIHRoaXMuX2Nvcm5lclszXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbM10sIHRoaXMuX2Nvcm5lclswXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlID0gZnVuY3Rpb24gaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSAocDAsIHAxKSB7XG4gIHZhciBpbnRlcnNlY3RzTGVmdCA9IGZhbHNlO1xuICB2YXIgaW50ZXJzZWN0c0JvdHRvbSA9IGZhbHNlO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzBdLCB0aGlzLl9jb3JuZXJbMV0pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMV0sIHRoaXMuX2Nvcm5lclsyXSk7XG4gIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IGludGVyc2VjdHNMZWZ0ID0gdHJ1ZTsgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzJdLCB0aGlzLl9jb3JuZXJbM10pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyBpbnRlcnNlY3RzQm90dG9tID0gdHJ1ZTsgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzNdLCB0aGlzLl9jb3JuZXJbMF0pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChpbnRlcnNlY3RzTGVmdCAmJiBpbnRlcnNlY3RzQm90dG9tKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHAwLmVxdWFscyh0aGlzLl9wdCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocDEuZXF1YWxzKHRoaXMuX3B0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5hZGRTbmFwcGVkTm9kZSA9IGZ1bmN0aW9uIGFkZFNuYXBwZWROb2RlIChzZWdTdHIsIHNlZ0luZGV4KSB7XG4gIHZhciBwMCA9IHNlZ1N0ci5nZXRDb29yZGluYXRlKHNlZ0luZGV4KTtcbiAgdmFyIHAxID0gc2VnU3RyLmdldENvb3JkaW5hdGUoc2VnSW5kZXggKyAxKTtcbiAgaWYgKHRoaXMuaW50ZXJzZWN0cyhwMCwgcDEpKSB7XG4gICAgc2VnU3RyLmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSwgc2VnSW5kZXgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBIb3RQaXhlbFxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNC5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuNzUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEhvdFBpeGVsLCBzdGF0aWNBY2Nlc3NvcnMkMzQgKTtcblxudmFyIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24gPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uICgpIHtcbiAgdGhpcy50ZW1wRW52MSA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLnNlbGVjdGVkU2VnbWVudCA9IG5ldyBMaW5lU2VnbWVudCgpO1xufTtcbk1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gY29uc3Qgc2VnID0gYXJndW1lbnRzWzBdXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBtYyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBtYy5nZXRMaW5lU2VnbWVudChzdGFydEluZGV4LCB0aGlzLnNlbGVjdGVkU2VnbWVudCk7XG4gICAgdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpO1xuICB9XG59O1xuTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvblxufTtcblxudmFyIE1DSW5kZXhQb2ludFNuYXBwZXIgPSBmdW5jdGlvbiBNQ0luZGV4UG9pbnRTbmFwcGVyICgpIHtcbiAgdGhpcy5faW5kZXggPSBudWxsO1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2luZGV4ID0gaW5kZXg7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM1ID0geyBIb3RQaXhlbFNuYXBBY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk1DSW5kZXhQb2ludFNuYXBwZXIucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbiBzbmFwICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaG90UGl4ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuc25hcChob3RQaXhlbCwgbnVsbCwgLTEpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBob3RQaXhlbCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwYXJlbnRFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBob3RQaXhlbFZlcnRleEluZGV4ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBwaXhlbEVudiA9IGhvdFBpeGVsJDEuZ2V0U2FmZUVudmVsb3BlKCk7XG4gICAgdmFyIGhvdFBpeGVsU25hcEFjdGlvbiA9IG5ldyBIb3RQaXhlbFNuYXBBY3Rpb24oaG90UGl4ZWwkMSwgcGFyZW50RWRnZSwgaG90UGl4ZWxWZXJ0ZXhJbmRleCk7XG4gICAgdGhpcy5faW5kZXgucXVlcnkocGl4ZWxFbnYsIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbSXRlbVZpc2l0b3JdXG4gICAgICB9LFxuICAgICAgdmlzaXRJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdGVzdENoYWluID0gaXRlbTtcbiAgICAgICAgdGVzdENoYWluLnNlbGVjdChwaXhlbEVudiwgaG90UGl4ZWxTbmFwQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaG90UGl4ZWxTbmFwQWN0aW9uLmlzTm9kZUFkZGVkKClcbiAgfVxufTtcbk1DSW5kZXhQb2ludFNuYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5NQ0luZGV4UG9pbnRTbmFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1DSW5kZXhQb2ludFNuYXBwZXJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzUuSG90UGl4ZWxTbmFwQWN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhvdFBpeGVsU25hcEFjdGlvbiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTUNJbmRleFBvaW50U25hcHBlciwgc3RhdGljQWNjZXNzb3JzJDM1ICk7XG5cbnZhciBIb3RQaXhlbFNuYXBBY3Rpb24gPSAoZnVuY3Rpb24gKE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gSG90UGl4ZWxTbmFwQWN0aW9uICgpIHtcbiAgICBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5faG90UGl4ZWwgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudEVkZ2UgPSBudWxsO1xuICAgIHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXggPSBudWxsO1xuICAgIHRoaXMuX2lzTm9kZUFkZGVkID0gZmFsc2U7XG4gICAgdmFyIGhvdFBpeGVsID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwYXJlbnRFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBob3RQaXhlbFZlcnRleEluZGV4ID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2hvdFBpeGVsID0gaG90UGl4ZWw7XG4gICAgdGhpcy5fcGFyZW50RWRnZSA9IHBhcmVudEVkZ2U7XG4gICAgdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCA9IGhvdFBpeGVsVmVydGV4SW5kZXg7XG4gIH1cblxuICBpZiAoIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEgKSBIb3RQaXhlbFNuYXBBY3Rpb24uX19wcm90b19fID0gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEgJiYgTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhvdFBpeGVsU25hcEFjdGlvbjtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5pc05vZGVBZGRlZCA9IGZ1bmN0aW9uIGlzTm9kZUFkZGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNOb2RlQWRkZWRcbiAgfTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbWMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzcyA9IG1jLmdldENvbnRleHQoKTtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRFZGdlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzcyA9PT0gdGhpcy5fcGFyZW50RWRnZSAmJiBzdGFydEluZGV4ID09PSB0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4KSB7IHJldHVybiBudWxsIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzTm9kZUFkZGVkID0gdGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUoc3MsIHN0YXJ0SW5kZXgpO1xuICAgIH0gZWxzZSB7IHJldHVybiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxLnByb3RvdHlwZS5zZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEhvdFBpeGVsU25hcEFjdGlvblxuICB9O1xuXG4gIHJldHVybiBIb3RQaXhlbFNuYXBBY3Rpb247XG59KE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24pKTtcblxudmFyIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIgPSBmdW5jdGlvbiBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyICgpIHtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMgPSBudWxsO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xpID0gbGk7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IG5ldyBBcnJheUxpc3QoKTtcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICBpZiAodGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKSB7XG4gICAgICBmb3IgKHZhciBpbnRJbmRleCA9IDA7IGludEluZGV4IDwgdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGludEluZGV4KyspIHtcbiAgICAgICAgdGhpcyQxLl9pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMkMS5fbGkuZ2V0SW50ZXJzZWN0aW9uKGludEluZGV4KSk7XG4gICAgICB9XG4gICAgICBlMC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDAsIDApO1xuICAgICAgZTEuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgxLCAxKTtcbiAgICB9XG4gIH1cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcmlvckludGVyc2VjdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudEludGVyc2VjdG9yXVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlclxufTtcblxudmFyIE1DSW5kZXhTbmFwUm91bmRlciA9IGZ1bmN0aW9uIE1DSW5kZXhTbmFwUm91bmRlciAoKSB7XG4gIHRoaXMuX3BtID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IG51bGw7XG4gIHRoaXMuX25vZGVyID0gbnVsbDtcbiAgdGhpcy5fcG9pbnRTbmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gbnVsbDtcbiAgdmFyIHBtID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wbSA9IHBtO1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwocG0pO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IHBtLmdldFNjYWxlKCk7XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5jaGVja0NvcnJlY3RuZXNzID0gZnVuY3Rpb24gY2hlY2tDb3JyZWN0bmVzcyAoaW5wdXRTZWdtZW50U3RyaW5ncykge1xuICB2YXIgcmVzdWx0U2VnU3RyaW5ncyA9IE5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3MoaW5wdXRTZWdtZW50U3RyaW5ncyk7XG4gIHZhciBudiA9IG5ldyBOb2RpbmdWYWxpZGF0b3IocmVzdWx0U2VnU3RyaW5ncyk7XG4gIHRyeSB7XG4gICAgbnYuY2hlY2tWYWxpZCgpO1xuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIEV4Y2VwdGlvbikge1xuICAgICAgZXgucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7XG4gIHJldHVybiBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncylcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLnNuYXBSb3VuZCA9IGZ1bmN0aW9uIHNuYXBSb3VuZCAoc2VnU3RyaW5ncywgbGkpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSB0aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnMoc2VnU3RyaW5ncywgbGkpO1xuICB0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhpbnRlcnNlY3Rpb25zKTtcbiAgdGhpcy5jb21wdXRlVmVydGV4U25hcHMoc2VnU3RyaW5ncyk7XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyAoc2VnU3RyaW5ncywgbGkpIHtcbiAgdmFyIGludEZpbmRlckFkZGVyID0gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIobGkpO1xuICB0aGlzLl9ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IoaW50RmluZGVyQWRkZXIpO1xuICB0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoc2VnU3RyaW5ncyk7XG4gIHJldHVybiBpbnRGaW5kZXJBZGRlci5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuY29tcHV0ZVZlcnRleFNuYXBzID0gZnVuY3Rpb24gY29tcHV0ZVZlcnRleFNuYXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikpIHtcbiAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaTAgPSBlZGdlcy5pdGVyYXRvcigpOyBpMC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZWRnZTAgPSBpMC5uZXh0KCk7XG4gICAgICB0aGlzJDEuY29tcHV0ZVZlcnRleFNuYXBzKGVkZ2UwKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZWRTZWdtZW50U3RyaW5nKSB7XG4gICAgdmFyIGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0czAgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaG90UGl4ZWwgPSBuZXcgSG90UGl4ZWwocHRzMFtpXSwgdGhpcyQxLl9zY2FsZUZhY3RvciwgdGhpcyQxLl9saSk7XG4gICAgICB2YXIgaXNOb2RlQWRkZWQgPSB0aGlzJDEuX3BvaW50U25hcHBlci5zbmFwKGhvdFBpeGVsLCBlLCBpKTtcbiAgICAgIGlmIChpc05vZGVBZGRlZCkge1xuICAgICAgICBlLmFkZEludGVyc2VjdGlvbihwdHMwW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlcyAoaW5wdXRTZWdtZW50U3RyaW5ncykge1xuICB0aGlzLl9ub2RlZFNlZ1N0cmluZ3MgPSBpbnB1dFNlZ21lbnRTdHJpbmdzO1xuICB0aGlzLl9ub2RlciA9IG5ldyBNQ0luZGV4Tm9kZXIoKTtcbiAgdGhpcy5fcG9pbnRTbmFwcGVyID0gbmV3IE1DSW5kZXhQb2ludFNuYXBwZXIodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSk7XG4gIHRoaXMuc25hcFJvdW5kKGlucHV0U2VnbWVudFN0cmluZ3MsIHRoaXMuX2xpKTtcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyAoc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gc25hcFB0cy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHNuYXBQdCA9IGl0Lm5leHQoKTtcbiAgICB2YXIgaG90UGl4ZWwgPSBuZXcgSG90UGl4ZWwoc25hcFB0LCB0aGlzJDEuX3NjYWxlRmFjdG9yLCB0aGlzJDEuX2xpKTtcbiAgICB0aGlzJDEuX3BvaW50U25hcHBlci5zbmFwKGhvdFBpeGVsKTtcbiAgfVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kZXJdXG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1DSW5kZXhTbmFwUm91bmRlclxufTtcblxudmFyIEJ1ZmZlck9wID0gZnVuY3Rpb24gQnVmZmVyT3AgKCkge1xuICB0aGlzLl9hcmdHZW9tID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBuZXcgQnVmZmVyUGFyYW1ldGVycygpO1xuICB0aGlzLl9yZXN1bHRHZW9tZXRyeSA9IG51bGw7XG4gIHRoaXMuX3NhdmVFeGNlcHRpb24gPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2FyZ0dlb20gPSBnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBidWZQYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fYXJnR2VvbSA9IGckMTtcbiAgICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXM7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzIgPSB7IENBUF9ST1VORDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfQlVUVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfRkxBVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfU1FVQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9QUkVDSVNJT05fRElHSVRTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJPcC5wcm90b3R5cGUuYnVmZmVyRml4ZWRQcmVjaXNpb24gPSBmdW5jdGlvbiBidWZmZXJGaXhlZFByZWNpc2lvbiAoZml4ZWRQTSkge1xuICB2YXIgbm9kZXIgPSBuZXcgU2NhbGVkTm9kZXIobmV3IE1DSW5kZXhTbmFwUm91bmRlcihuZXcgUHJlY2lzaW9uTW9kZWwoMS4wKSksIGZpeGVkUE0uZ2V0U2NhbGUoKSk7XG4gIHZhciBidWZCdWlsZGVyID0gbmV3IEJ1ZmZlckJ1aWxkZXIodGhpcy5fYnVmUGFyYW1zKTtcbiAgYnVmQnVpbGRlci5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwoZml4ZWRQTSk7XG4gIGJ1ZkJ1aWxkZXIuc2V0Tm9kZXIobm9kZXIpO1xuICB0aGlzLl9yZXN1bHRHZW9tZXRyeSA9IGJ1ZkJ1aWxkZXIuYnVmZmVyKHRoaXMuX2FyZ0dlb20sIHRoaXMuX2Rpc3RhbmNlKTtcbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuYnVmZmVyUmVkdWNlZFByZWNpc2lvbiA9IGZ1bmN0aW9uIGJ1ZmZlclJlZHVjZWRQcmVjaXNpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgcHJlY0RpZ2l0cyA9IEJ1ZmZlck9wLk1BWF9QUkVDSVNJT05fRElHSVRTOyBwcmVjRGlnaXRzID49IDA7IHByZWNEaWdpdHMtLSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcyQxLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24ocHJlY0RpZ2l0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUb3BvbG9neUV4Y2VwdGlvbikge1xuICAgICAgICAgIHRoaXMkMS5fc2F2ZUV4Y2VwdGlvbiA9IGV4O1xuICAgICAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gICAgICB9IGZpbmFsbHkge31cbiAgICAgIGlmICh0aGlzJDEuX3Jlc3VsdEdlb21ldHJ5ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvblxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHJlY2lzaW9uRGlnaXRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzaXplQmFzZWRTY2FsZUZhY3RvciA9IEJ1ZmZlck9wLnByZWNpc2lvblNjYWxlRmFjdG9yKHRoaXMuX2FyZ0dlb20sIHRoaXMuX2Rpc3RhbmNlLCBwcmVjaXNpb25EaWdpdHMpO1xuICAgIHZhciBmaXhlZFBNID0gbmV3IFByZWNpc2lvbk1vZGVsKHNpemVCYXNlZFNjYWxlRmFjdG9yKTtcbiAgICB0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKGZpeGVkUE0pO1xuICB9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmNvbXB1dGVHZW9tZXRyeSA9IGZ1bmN0aW9uIGNvbXB1dGVHZW9tZXRyeSAoKSB7XG4gIHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKTtcbiAgaWYgKHRoaXMuX3Jlc3VsdEdlb21ldHJ5ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGFyZ1BNID0gdGhpcy5fYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTtcbiAgaWYgKGFyZ1BNLmdldFR5cGUoKSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHsgdGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihhcmdQTSk7IH0gZWxzZSB7IHRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpOyB9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLnNldFF1YWRyYW50U2VnbWVudHMgPSBmdW5jdGlvbiBzZXRRdWFkcmFudFNlZ21lbnRzIChxdWFkcmFudFNlZ21lbnRzKSB7XG4gIHRoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5idWZmZXJPcmlnaW5hbFByZWNpc2lvbiA9IGZ1bmN0aW9uIGJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmQnVpbGRlciA9IG5ldyBCdWZmZXJCdWlsZGVyKHRoaXMuX2J1ZlBhcmFtcyk7XG4gICAgdGhpcy5fcmVzdWx0R2VvbWV0cnkgPSBidWZCdWlsZGVyLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLCB0aGlzLl9kaXN0YW5jZSk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgUnVudGltZUV4Y2VwdGlvbikge1xuICAgICAgdGhpcy5fc2F2ZUV4Y2VwdGlvbiA9IGV4O1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmdldFJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0UmVzdWx0R2VvbWV0cnkgKGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIHRoaXMuY29tcHV0ZUdlb21ldHJ5KCk7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRHZW9tZXRyeVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5zZXRFbmRDYXBTdHlsZSA9IGZ1bmN0aW9uIHNldEVuZENhcFN0eWxlIChlbmRDYXBTdHlsZSkge1xuICB0aGlzLl9idWZQYXJhbXMuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUpO1xufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyT3Bcbn07XG5CdWZmZXJPcC5idWZmZXJPcCA9IGZ1bmN0aW9uIGJ1ZmZlck9wICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGdCdWYgPSBuZXcgQnVmZmVyT3AoZyk7XG4gICAgdmFyIGdlb21CdWYgPSBnQnVmLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlKTtcbiAgICByZXR1cm4gZ2VvbUJ1ZlxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGlzdGFuY2UkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBxdWFkcmFudFNlZ21lbnRzID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGJ1Zk9wID0gbmV3IEJ1ZmZlck9wKGckMSk7XG4gICAgICBidWZPcC5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xuICAgICAgdmFyIGdlb21CdWYkMSA9IGJ1Zk9wLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlJDEpO1xuICAgICAgcmV0dXJuIGdlb21CdWYkMVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQnVmZmVyUGFyYW1ldGVycyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgZyQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpc3RhbmNlJDIgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGJ1Zk9wJDEgPSBuZXcgQnVmZmVyT3AoZyQyLCBwYXJhbXMpO1xuICAgICAgdmFyIGdlb21CdWYkMiA9IGJ1Zk9wJDEuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UkMik7XG4gICAgICByZXR1cm4gZ2VvbUJ1ZiQyXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZyQzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkaXN0YW5jZSQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxdWFkcmFudFNlZ21lbnRzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGVuZENhcFN0eWxlID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBidWZPcCQyID0gbmV3IEJ1ZmZlck9wKGckMyk7XG4gICAgYnVmT3AkMi5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMkMSk7XG4gICAgYnVmT3AkMi5zZXRFbmRDYXBTdHlsZShlbmRDYXBTdHlsZSk7XG4gICAgdmFyIGdlb21CdWYkMyA9IGJ1Zk9wJDIuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UkMyk7XG4gICAgcmV0dXJuIGdlb21CdWYkM1xuICB9XG59O1xuQnVmZmVyT3AucHJlY2lzaW9uU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiBwcmVjaXNpb25TY2FsZUZhY3RvciAoZywgZGlzdGFuY2UsIG1heFByZWNpc2lvbkRpZ2l0cykge1xuICB2YXIgZW52ID0gZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBlbnZNYXggPSBNYXRoVXRpbC5tYXgoTWF0aC5hYnMoZW52LmdldE1heFgoKSksIE1hdGguYWJzKGVudi5nZXRNYXhZKCkpLCBNYXRoLmFicyhlbnYuZ2V0TWluWCgpKSwgTWF0aC5hYnMoZW52LmdldE1pblkoKSkpO1xuICB2YXIgZXhwYW5kQnlEaXN0YW5jZSA9IGRpc3RhbmNlID4gMC4wID8gZGlzdGFuY2UgOiAwLjA7XG4gIHZhciBidWZFbnZNYXggPSBlbnZNYXggKyAyICogZXhwYW5kQnlEaXN0YW5jZTtcbiAgdmFyIGJ1ZkVudlByZWNpc2lvbkRpZ2l0cyA9IE1hdGgudHJ1bmMoTWF0aC5sb2coYnVmRW52TWF4KSAvIE1hdGgubG9nKDEwKSArIDEuMCk7XG4gIHZhciBtaW5Vbml0TG9nMTAgPSBtYXhQcmVjaXNpb25EaWdpdHMgLSBidWZFbnZQcmVjaXNpb25EaWdpdHM7XG4gIHZhciBzY2FsZUZhY3RvciA9IE1hdGgucG93KDEwLjAsIG1pblVuaXRMb2cxMCk7XG4gIHJldHVybiBzY2FsZUZhY3RvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfUk9VTkQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfUk9VTkQgfTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfQlVUVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuQ0FQX0ZMQVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfRkxBVCB9O1xuc3RhdGljQWNjZXNzb3JzJDMyLkNBUF9TUVVBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuTUFYX1BSRUNJU0lPTl9ESUdJVFMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlck9wLCBzdGF0aWNBY2Nlc3NvcnMkMzIgKTtcblxudmFyIFBvaW50UGFpckRpc3RhbmNlID0gZnVuY3Rpb24gUG9pbnRQYWlyRGlzdGFuY2UgKCkge1xuICB0aGlzLl9wdCA9IFtuZXcgQ29vcmRpbmF0ZSgpLCBuZXcgQ29vcmRpbmF0ZSgpXTtcbiAgdGhpcy5fZGlzdGFuY2UgPSBEb3VibGUuTmFOO1xuICB0aGlzLl9pc051bGwgPSB0cnVlO1xufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdFtpXVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5zZXRNaW5pbXVtID0gZnVuY3Rpb24gc2V0TWluaW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1pbmltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA8IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2lzTnVsbCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZShwMCk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgdGhpcy5faXNOdWxsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwJDEpO1xuICAgIHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUocDEkMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLnNldE1heGltdW0gPSBmdW5jdGlvbiBzZXRNYXhpbXVtICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TWF4aW11bShwdERpc3QuX3B0WzBdLCBwdERpc3QuX3B0WzFdKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5faXNOdWxsKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUocDAsIHAxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBkaXN0ID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIGlmIChkaXN0ID4gdGhpcy5fZGlzdGFuY2UpIHsgdGhpcy5pbml0aWFsaXplKHAwLCBwMSwgZGlzdCk7IH1cbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRQYWlyRGlzdGFuY2Vcbn07XG5cbnZhciBEaXN0YW5jZVRvUG9pbnRGaW5kZXIgPSBmdW5jdGlvbiBEaXN0YW5jZVRvUG9pbnRGaW5kZXIgKCkge307XG5cbkRpc3RhbmNlVG9Qb2ludEZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpc3RhbmNlVG9Qb2ludEZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXN0YW5jZVRvUG9pbnRGaW5kZXJcbn07XG5EaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZURpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGNvb3JkcyA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgdGVtcFNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHRlbXBTZWdtZW50LnNldENvb3JkaW5hdGVzKGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSk7XG4gICAgICB2YXIgY2xvc2VzdFB0ID0gdGVtcFNlZ21lbnQuY2xvc2VzdFBvaW50KHB0KTtcbiAgICAgIHB0RGlzdC5zZXRNaW5pbXVtKGNsb3Nlc3RQdCwgcHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9seWdvbiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpJDErKykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEludGVyaW9yUmluZ04oaSQxKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDIgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBnYyA9IGdlb207XG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkkMisrKSB7XG4gICAgICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkkMik7XG4gICAgICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UoZywgcHQkMiwgcHREaXN0JDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdERpc3QkMi5zZXRNaW5pbXVtKGdlb20uZ2V0Q29vcmRpbmF0ZSgpLCBwdCQyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDMgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQzID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBjbG9zZXN0UHQkMSA9IHNlZ21lbnQuY2xvc2VzdFBvaW50KHB0JDMpO1xuICAgIHB0RGlzdCQzLnNldE1pbmltdW0oY2xvc2VzdFB0JDEsIHB0JDMpO1xuICB9XG59O1xuXG52YXIgQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIgPSBmdW5jdGlvbiBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlciAoaW5wdXRHZW9tKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9pbnB1dEdlb20gPSBpbnB1dEdlb20gfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzYgPSB7IE1heFBvaW50RGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1heE1pZHBvaW50RGlzdGFuY2UgKGN1cnZlKSB7XG4gIHZhciBkaXN0RmlsdGVyID0gbmV3IE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIodGhpcy5faW5wdXRHZW9tKTtcbiAgY3VydmUuYXBwbHkoZGlzdEZpbHRlcik7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKGRpc3RGaWx0ZXIuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKTtcbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuY29tcHV0ZU1heFZlcnRleERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1heFZlcnRleERpc3RhbmNlIChjdXJ2ZSkge1xuICB2YXIgZGlzdEZpbHRlciA9IG5ldyBNYXhQb2ludERpc3RhbmNlRmlsdGVyKHRoaXMuX2lucHV0R2VvbSk7XG4gIGN1cnZlLmFwcGx5KGRpc3RGaWx0ZXIpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bShkaXN0RmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmZpbmREaXN0YW5jZSA9IGZ1bmN0aW9uIGZpbmREaXN0YW5jZSAoYnVmZmVyQ3VydmUpIHtcbiAgdGhpcy5jb21wdXRlTWF4VmVydGV4RGlzdGFuY2UoYnVmZmVyQ3VydmUpO1xuICB0aGlzLmNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlKGJ1ZmZlckN1cnZlKTtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdC5nZXREaXN0YW5jZSgpXG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmdldERpc3RhbmNlUG9pbnRzID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2VQb2ludHMgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNi5NYXhQb2ludERpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgfTtcbnN0YXRpY0FjY2Vzc29ycyQzNi5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLCBzdGF0aWNBY2Nlc3NvcnMkMzYgKTtcblxudmFyIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiBNYXhQb2ludERpc3RhbmNlRmlsdGVyIChnZW9tKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fZ2VvbSA9IGdlb20gfHwgbnVsbDtcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHB0KSB7XG4gIHRoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCk7XG4gIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSwgcHQsIHRoaXMuX21pblB0RGlzdCk7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCk7XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZUZpbHRlcl1cbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXJcbn07XG5cbnZhciBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyID0gZnVuY3Rpb24gTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlciAoZ2VvbSkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fbWluUHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX2dlb20gPSBnZW9tIHx8IG51bGw7XG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChzZXEsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwMCA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4IC0gMSk7XG4gIHZhciBwMSA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4KTtcbiAgdmFyIG1pZFB0ID0gbmV3IENvb3JkaW5hdGUoKHAwLnggKyBwMS54KSAvIDIsIChwMC55ICsgcDEueSkgLyAyKTtcbiAgdGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKTtcbiAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLCBtaWRQdCwgdGhpcy5fbWluUHREaXN0KTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KTtcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXVxufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlclxufTtcblxudmFyIFBvbHlnb25FeHRyYWN0ZXIgPSBmdW5jdGlvbiBQb2x5Z29uRXh0cmFjdGVyIChjb21wcykge1xuICB0aGlzLl9jb21wcyA9IGNvbXBzIHx8IG51bGw7XG59O1xuUG9seWdvbkV4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikgeyB0aGlzLl9jb21wcy5hZGQoZ2VvbSk7IH1cbn07XG5Qb2x5Z29uRXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Qb2x5Z29uRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25FeHRyYWN0ZXJcbn07XG5Qb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zID0gZnVuY3Rpb24gZ2V0UG9seWdvbnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGdlb20sIG5ldyBBcnJheUxpc3QoKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgICAgbGlzdC5hZGQoZ2VvbSQxKTtcbiAgICB9IGVsc2UgaWYgKGdlb20kMSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgZ2VvbSQxLmFwcGx5KG5ldyBQb2x5Z29uRXh0cmFjdGVyKGxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxufTtcblxudmFyIExpbmVhckNvbXBvbmVudEV4dHJhY3RlciA9IGZ1bmN0aW9uIExpbmVhckNvbXBvbmVudEV4dHJhY3RlciAoKSB7XG4gIHRoaXMuX2xpbmVzID0gbnVsbDtcbiAgdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcgPSBmYWxzZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGluZXMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbGluZXMgPSBsaW5lcztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGxpbmVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGlzRm9yY2VkVG9MaW5lU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2xpbmVzID0gbGluZXMkMTtcbiAgICB0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyA9IGlzRm9yY2VkVG9MaW5lU3RyaW5nO1xuICB9XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgaWYgKHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nICYmIGdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgdmFyIGxpbmUgPSBnZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO1xuICAgIHRoaXMuX2xpbmVzLmFkZChsaW5lKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLl9saW5lcy5hZGQoZ2VvbSk7IH1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLnNldEZvcmNlVG9MaW5lU3RyaW5nID0gZnVuY3Rpb24gc2V0Rm9yY2VUb0xpbmVTdHJpbmcgKGlzRm9yY2VkVG9MaW5lU3RyaW5nKSB7XG4gIHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nID0gaXNGb3JjZWRUb0xpbmVTdHJpbmc7XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUNvbXBvbmVudEZpbHRlcl1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyXG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBnZW9tLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGdlb20kMS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZ2VvbSQxLCBmb3JjZVRvTGluZVN0cmluZykpXG4gIH1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tLCBmYWxzZSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZXMkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSBnZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGcgPSBpLm5leHQoKTtcbiAgICAgICAgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGcsIGxpbmVzJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzJDFcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBmb3JjZVRvTGluZVN0cmluZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsaW5lcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICAgIGdlb20kMS5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzLCBmb3JjZVRvTGluZVN0cmluZykpO1xuICAgICAgcmV0dXJuIGxpbmVzXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGdlb20kMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lcyQyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGdlb20kMiBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgICAgbGluZXMkMi5hZGQoZ2VvbSQyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlb20kMi5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzJDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcyQyXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkpIHtcbiAgICAgIHZhciBnZW9tcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDMgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmckMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGdlb21zJDEuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGckMSA9IGkkMS5uZXh0KCk7XG4gICAgICAgIExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnJDEsIGxpbmVzJDMsIGZvcmNlVG9MaW5lU3RyaW5nJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzJDNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29sbGVjdGlvbikpKSB7XG4gICAgICB2YXIgZ2VvbSQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDQgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmckMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGdlb20kMy5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzJDQsIGZvcmNlVG9MaW5lU3RyaW5nJDIpKTtcbiAgICAgIHJldHVybiBsaW5lcyQ0XG4gICAgfVxuICB9XG59O1xuXG52YXIgUG9pbnRMb2NhdG9yID0gZnVuY3Rpb24gUG9pbnRMb2NhdG9yICgpIHtcbiAgdGhpcy5fYm91bmRhcnlSdWxlID0gQm91bmRhcnlOb2RlUnVsZS5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU7XG4gIHRoaXMuX2lzSW4gPSBudWxsO1xuICB0aGlzLl9udW1Cb3VuZGFyaWVzID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYm91bmRhcnlSdWxlID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChib3VuZGFyeVJ1bGUgPT09IG51bGwpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUnVsZSBtdXN0IGJlIG5vbi1udWxsJykgfVxuICAgIHRoaXMuX2JvdW5kYXJ5UnVsZSA9IGJvdW5kYXJ5UnVsZTtcbiAgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUubG9jYXRlSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2NhdGVJbnRlcm5hbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChwb2x5LmlzRW1wdHkoKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICAgIHZhciBzaGVsbCA9IHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCk7XG4gICAgdmFyIHNoZWxsTG9jID0gdGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHAsIHNoZWxsKTtcbiAgICBpZiAoc2hlbGxMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgaWYgKHNoZWxsTG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgICB2YXIgaG9sZSA9IHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICAgIHZhciBob2xlTG9jID0gdGhpcyQxLmxvY2F0ZUluUG9seWdvblJpbmcocCwgaG9sZSk7XG4gICAgICBpZiAoaG9sZUxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgICAgIGlmIChob2xlTG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICAgIH1cbiAgICByZXR1cm4gTG9jYXRpb24uSU5URVJJT1JcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICB2YXIgcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICghbC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhwJDEpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgdmFyIHB0ID0gbC5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmICghbC5pc0Nsb3NlZCgpKSB7XG4gICAgICBpZiAocCQxLmVxdWFscyhwdFswXSkgfHwgcCQxLmVxdWFscyhwdFtwdC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDR0FsZ29yaXRobXMuaXNPbkxpbmUocCQxLCBwdCkpIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1JcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgdmFyIHAkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHRDb29yZCA9IHB0JDEuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgIGlmIChwdENvb3JkLmVxdWFsczJEKHAkMikpIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1JcbiAgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUubG9jYXRlSW5Qb2x5Z29uUmluZyA9IGZ1bmN0aW9uIGxvY2F0ZUluUG9seWdvblJpbmcgKHAsIHJpbmcpIHtcbiAgaWYgKCFyaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHApKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIHJldHVybiBDR0FsZ29yaXRobXMubG9jYXRlUG9pbnRJblJpbmcocCwgcmluZy5nZXRDb29yZGluYXRlcygpKVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHAsIGdlb20pIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRlKHAsIGdlb20pICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUudXBkYXRlTG9jYXRpb25JbmZvID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25JbmZvIChsb2MpIHtcbiAgaWYgKGxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgdGhpcy5faXNJbiA9IHRydWU7IH1cbiAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgdGhpcy5fbnVtQm91bmRhcmllcysrOyB9XG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5jb21wdXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjb21wdXRlTG9jYXRpb24gKHAsIGdlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKSk7XG4gIH1cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKSk7XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICB0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pKTtcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7XG4gICAgdmFyIG1sID0gZ2VvbTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1sLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgICB2YXIgbCA9IG1sLmdldEdlb21ldHJ5TihpKTtcbiAgICAgIHRoaXMkMS51cGRhdGVMb2NhdGlvbkluZm8odGhpcyQxLmxvY2F0ZUludGVybmFsKHAsIGwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikge1xuICAgIHZhciBtcG9seSA9IGdlb207XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbXBvbHkuZ2V0TnVtR2VvbWV0cmllcygpOyBpJDErKykge1xuICAgICAgdmFyIHBvbHkgPSBtcG9seS5nZXRHZW9tZXRyeU4oaSQxKTtcbiAgICAgIHRoaXMkMS51cGRhdGVMb2NhdGlvbkluZm8odGhpcyQxLmxvY2F0ZUludGVybmFsKHAsIHBvbHkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHZhciBnZW9taSA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvcihnZW9tKTtcbiAgICB3aGlsZSAoZ2VvbWkuaGFzTmV4dCgpKSB7XG4gICAgICB2YXIgZzIgPSBnZW9taS5uZXh0KCk7XG4gICAgICBpZiAoZzIgIT09IGdlb20pIHsgdGhpcyQxLmNvbXB1dGVMb2NhdGlvbihwLCBnMik7IH1cbiAgICB9XG4gIH1cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCwgZ2VvbSkge1xuICBpZiAoZ2VvbS5pc0VtcHR5KCkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSlcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHJldHVybiB0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pXG4gIH1cbiAgdGhpcy5faXNJbiA9IGZhbHNlO1xuICB0aGlzLl9udW1Cb3VuZGFyaWVzID0gMDtcbiAgdGhpcy5jb21wdXRlTG9jYXRpb24ocCwgZ2VvbSk7XG4gIGlmICh0aGlzLl9ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMuX251bUJvdW5kYXJpZXMpKSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gIGlmICh0aGlzLl9udW1Cb3VuZGFyaWVzID4gMCB8fCB0aGlzLl9pc0luKSB7IHJldHVybiBMb2NhdGlvbi5JTlRFUklPUiB9XG4gIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludExvY2F0b3Jcbn07XG5cbnZhciBHZW9tZXRyeUxvY2F0aW9uID0gZnVuY3Rpb24gR2VvbWV0cnlMb2NhdGlvbiAoKSB7XG4gIHRoaXMuX2NvbXBvbmVudCA9IG51bGw7XG4gIHRoaXMuX3NlZ0luZGV4ID0gbnVsbDtcbiAgdGhpcy5fcHQgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBjb21wb25lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgIEdlb21ldHJ5TG9jYXRpb24uY2FsbCh0aGlzLCBjb21wb25lbnQsIEdlb21ldHJ5TG9jYXRpb24uSU5TSURFX0FSRUEsIHB0KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGNvbXBvbmVudCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9jb21wb25lbnQgPSBjb21wb25lbnQkMTtcbiAgICB0aGlzLl9zZWdJbmRleCA9IHNlZ0luZGV4O1xuICAgIHRoaXMuX3B0ID0gcHQkMTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzOCA9IHsgSU5TSURFX0FSRUE6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmlzSW5zaWRlQXJlYSA9IGZ1bmN0aW9uIGlzSW5zaWRlQXJlYSAoKSB7XG4gIHJldHVybiB0aGlzLl9zZWdJbmRleCA9PT0gR2VvbWV0cnlMb2NhdGlvbi5JTlNJREVfQVJFQVxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0XG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeUNvbXBvbmVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9jb21wb25lbnRcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5nZXRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiBnZXRTZWdtZW50SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fc2VnSW5kZXhcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUxvY2F0aW9uXG59O1xuc3RhdGljQWNjZXNzb3JzJDM4LklOU0lERV9BUkVBLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUxvY2F0aW9uLCBzdGF0aWNBY2Nlc3NvcnMkMzggKTtcblxudmFyIFBvaW50RXh0cmFjdGVyID0gZnVuY3Rpb24gUG9pbnRFeHRyYWN0ZXIgKHB0cykge1xuICB0aGlzLl9wdHMgPSBwdHMgfHwgbnVsbDtcbn07XG5Qb2ludEV4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9pbnQpIHsgdGhpcy5fcHRzLmFkZChnZW9tKTsgfVxufTtcblBvaW50RXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Qb2ludEV4dHJhY3Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludEV4dHJhY3RlclxufTtcblBvaW50RXh0cmFjdGVyLmdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgcmV0dXJuIENvbGxlY3Rpb25zLnNpbmdsZXRvbkxpc3QoZ2VvbSlcbiAgICB9XG4gICAgcmV0dXJuIFBvaW50RXh0cmFjdGVyLmdldFBvaW50cyhnZW9tLCBuZXcgQXJyYXlMaXN0KCkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpc3QgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGdlb20kMSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICBsaXN0LmFkZChnZW9tJDEpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICBnZW9tJDEuYXBwbHkobmV3IFBvaW50RXh0cmFjdGVyKGxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxufTtcblxudmFyIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlciA9IGZ1bmN0aW9uIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlciAoKSB7XG4gIHRoaXMuX2xvY2F0aW9ucyA9IG51bGw7XG4gIHZhciBsb2NhdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xvY2F0aW9ucyA9IGxvY2F0aW9ucztcbn07XG5Db25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50IHx8IGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nIHx8IGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuX2xvY2F0aW9ucy5hZGQobmV3IEdlb21ldHJ5TG9jYXRpb24oZ2VvbSwgMCwgZ2VvbS5nZXRDb29yZGluYXRlKCkpKTsgfVxufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlGaWx0ZXJdXG59O1xuQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlclxufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5nZXRMb2NhdGlvbnMgPSBmdW5jdGlvbiBnZXRMb2NhdGlvbnMgKGdlb20pIHtcbiAgdmFyIGxvY2F0aW9ucyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZ2VvbS5hcHBseShuZXcgQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyKGxvY2F0aW9ucykpO1xuICByZXR1cm4gbG9jYXRpb25zXG59O1xuXG52YXIgRGlzdGFuY2VPcCA9IGZ1bmN0aW9uIERpc3RhbmNlT3AgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fdGVybWluYXRlRGlzdGFuY2UgPSAwLjA7XG4gIHRoaXMuX3B0TG9jYXRvciA9IG5ldyBQb2ludExvY2F0b3IoKTtcbiAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX21pbkRpc3RhbmNlID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2dlb20gPSBbZzAsIGcxXTtcbiAgICB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSA9IDAuMDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHRlcm1pbmF0ZURpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2dlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLl9nZW9tWzBdID0gZzAkMTtcbiAgICB0aGlzLl9nZW9tWzFdID0gZzEkMTtcbiAgICB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSA9IHRlcm1pbmF0ZURpc3RhbmNlO1xuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgbG9jUHRQb2x5ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLCBsb2NQdFBvbHkpO1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLCBsb2NQdFBvbHkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcG9seUdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jUHRQb2x5JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uc0luZGV4ID0gMSAtIHBvbHlHZW9tSW5kZXg7XG4gICAgdmFyIHBvbHlzID0gUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyh0aGlzLl9nZW9tW3BvbHlHZW9tSW5kZXhdKTtcbiAgICBpZiAocG9seXMuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIGluc2lkZUxvY3MgPSBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIuZ2V0TG9jYXRpb25zKHRoaXMuX2dlb21bbG9jYXRpb25zSW5kZXhdKTtcbiAgICAgIHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaW5zaWRlTG9jcywgcG9seXMsIGxvY1B0UG9seSQxKTtcbiAgICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkge1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW2xvY2F0aW9uc0luZGV4XSA9IGxvY1B0UG9seSQxWzBdO1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3BvbHlHZW9tSW5kZXhdID0gbG9jUHRQb2x5JDFbMV07XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIExpc3QpICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIExpc3QpKSkge1xuICAgICAgdmFyIGxvY3MgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcG9seXMkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NQdFBvbHkkMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5zaXplKCk7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gbG9jcy5nZXQoaSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seXMkMS5zaXplKCk7IGorKykge1xuICAgICAgICAgIHRoaXMkMS5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShsb2MsIHBvbHlzJDEuZ2V0KGopLCBsb2NQdFBvbHkkMik7XG4gICAgICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEFycmF5ICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeUxvY2F0aW9uICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvbHlnb24pKSB7XG4gICAgICB2YXIgcHRMb2MgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcG9seSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NQdFBvbHkkMyA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBwdCA9IHB0TG9jLmdldENvb3JkaW5hdGUoKTtcbiAgICAgIGlmIChMb2NhdGlvbi5FWFRFUklPUiAhPT0gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShwdCwgcG9seSkpIHtcbiAgICAgICAgdGhpcy5fbWluRGlzdGFuY2UgPSAwLjA7XG4gICAgICAgIGxvY1B0UG9seSQzWzBdID0gcHRMb2M7XG4gICAgICAgIGxvY1B0UG9seSQzWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocG9seSwgcHQpO1xuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyAobGluZXMsIHBvaW50cywgbG9jR2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzLmdldChpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5zaXplKCk7IGorKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzLmdldChqKTtcbiAgICAgIHRoaXMkMS5jb21wdXRlTWluRGlzdGFuY2UobGluZSwgcHQsIGxvY0dlb20pO1xuICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZUZhY2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRmFjZXREaXN0YW5jZSAoKSB7XG4gIHZhciBsb2NHZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHZhciBsaW5lczAgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXModGhpcy5fZ2VvbVswXSk7XG4gIHZhciBsaW5lczEgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSk7XG4gIHZhciBwdHMwID0gUG9pbnRFeHRyYWN0ZXIuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMF0pO1xuICB2YXIgcHRzMSA9IFBvaW50RXh0cmFjdGVyLmdldFBvaW50cyh0aGlzLl9nZW9tWzFdKTtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhsaW5lczAsIGxpbmVzMSwgbG9jR2VvbSk7XG4gIHRoaXMudXBkYXRlTWluRGlzdGFuY2UobG9jR2VvbSwgZmFsc2UpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICBsb2NHZW9tWzBdID0gbnVsbDtcbiAgbG9jR2VvbVsxXSA9IG51bGw7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobGluZXMwLCBwdHMxLCBsb2NHZW9tKTtcbiAgdGhpcy51cGRhdGVNaW5EaXN0YW5jZShsb2NHZW9tLCBmYWxzZSk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gIGxvY0dlb21bMF0gPSBudWxsO1xuICBsb2NHZW9tWzFdID0gbnVsbDtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhsaW5lczEsIHB0czAsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIHRydWUpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICBsb2NHZW9tWzBdID0gbnVsbDtcbiAgbG9jR2VvbVsxXSA9IG51bGw7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHB0czAsIHB0czEsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIGZhbHNlKTtcbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5uZWFyZXN0TG9jYXRpb25zID0gZnVuY3Rpb24gbmVhcmVzdExvY2F0aW9ucyAoKSB7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7XG4gIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUudXBkYXRlTWluRGlzdGFuY2UgPSBmdW5jdGlvbiB1cGRhdGVNaW5EaXN0YW5jZSAobG9jR2VvbSwgZmxpcCkge1xuICBpZiAobG9jR2VvbVswXSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChmbGlwKSB7XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXSA9IGxvY0dlb21bMV07XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXSA9IGxvY0dlb21bMF07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXSA9IGxvY0dlb21bMF07XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXSA9IGxvY0dlb21bMV07XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5uZWFyZXN0UG9pbnRzID0gZnVuY3Rpb24gbmVhcmVzdFBvaW50cyAoKSB7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7XG4gIHZhciBuZWFyZXN0UHRzID0gW3RoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV07XG4gIHJldHVybiBuZWFyZXN0UHRzXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1pbkRpc3RhbmNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpO1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NHZW9tID0gYXJndW1lbnRzWzJdO1xuICAgICAgaWYgKGxpbmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHB0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkgPiB0aGlzLl9taW5EaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB2YXIgY29vcmQwID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIGNvb3JkID0gcHQuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZDAubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKGNvb3JkLCBjb29yZDBbaV0sIGNvb3JkMFtpICsgMV0pO1xuICAgICAgICBpZiAoZGlzdCA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICB0aGlzJDEuX21pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICB2YXIgc2VnID0gbmV3IExpbmVTZWdtZW50KGNvb3JkMFtpXSwgY29vcmQwW2kgKyAxXSk7XG4gICAgICAgICAgdmFyIHNlZ0Nsb3Nlc3RQb2ludCA9IHNlZy5jbG9zZXN0UG9pbnQoY29vcmQpO1xuICAgICAgICAgIGxvY0dlb21bMF0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihsaW5lLCBpLCBzZWdDbG9zZXN0UG9pbnQpO1xuICAgICAgICAgIGxvY0dlb21bMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwdCwgMCwgY29vcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgTGluZVN0cmluZykpIHtcbiAgICAgIHZhciBsaW5lMCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NHZW9tJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAobGluZTAuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGxpbmUxLmdldEVudmVsb3BlSW50ZXJuYWwoKSkgPiB0aGlzLl9taW5EaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB2YXIgY29vcmQwJDEgPSBsaW5lMC5nZXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIGNvb3JkMSA9IGxpbmUxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjb29yZDAkMS5sZW5ndGggLSAxOyBpJDErKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvb3JkMS5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICB2YXIgZGlzdCQxID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlTGluZUxpbmUoY29vcmQwJDFbaSQxXSwgY29vcmQwJDFbaSQxICsgMV0sIGNvb3JkMVtqXSwgY29vcmQxW2ogKyAxXSk7XG4gICAgICAgICAgaWYgKGRpc3QkMSA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5fbWluRGlzdGFuY2UgPSBkaXN0JDE7XG4gICAgICAgICAgICB2YXIgc2VnMCA9IG5ldyBMaW5lU2VnbWVudChjb29yZDAkMVtpJDFdLCBjb29yZDAkMVtpJDEgKyAxXSk7XG4gICAgICAgICAgICB2YXIgc2VnMSA9IG5ldyBMaW5lU2VnbWVudChjb29yZDFbal0sIGNvb3JkMVtqICsgMV0pO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3RQdCA9IHNlZzAuY2xvc2VzdFBvaW50cyhzZWcxKTtcbiAgICAgICAgICAgIGxvY0dlb20kMVswXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKGxpbmUwLCBpJDEsIGNsb3Nlc3RQdFswXSk7XG4gICAgICAgICAgICBsb2NHZW9tJDFbMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihsaW5lMSwgaiwgY2xvc2VzdFB0WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2VQb2ludHMgKHBvaW50czAsIHBvaW50czEsIGxvY0dlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czAuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgcHQwID0gcG9pbnRzMC5nZXQoaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMxLnNpemUoKTsgaisrKSB7XG4gICAgICB2YXIgcHQxID0gcG9pbnRzMS5nZXQoaik7XG4gICAgICB2YXIgZGlzdCA9IHB0MC5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UocHQxLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICBpZiAoZGlzdCA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcyQxLl9taW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgIGxvY0dlb21bMF0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwdDAsIDAsIHB0MC5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgICBsb2NHZW9tWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocHQxLCAwLCBwdDEuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAodGhpcy5fZ2VvbVswXSA9PT0gbnVsbCB8fCB0aGlzLl9nZW9tWzFdID09PSBudWxsKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ251bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZCcpIH1cbiAgaWYgKHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpIHx8IHRoaXMuX2dlb21bMV0uaXNFbXB0eSgpKSB7IHJldHVybiAwLjAgfVxuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO1xuICByZXR1cm4gdGhpcy5fbWluRGlzdGFuY2Vcbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzIChsaW5lczAsIGxpbmVzMSwgbG9jR2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMwLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGxpbmUwID0gbGluZXMwLmdldChpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzMS5zaXplKCk7IGorKykge1xuICAgICAgdmFyIGxpbmUxID0gbGluZXMxLmdldChqKTtcbiAgICAgIHRoaXMkMS5jb21wdXRlTWluRGlzdGFuY2UobGluZTAsIGxpbmUxLCBsb2NHZW9tKTtcbiAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc3RhbmNlT3Bcbn07XG5EaXN0YW5jZU9wLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGcwLCBnMSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxKTtcbiAgcmV0dXJuIGRpc3RPcC5kaXN0YW5jZSgpXG59O1xuRGlzdGFuY2VPcC5pc1dpdGhpbkRpc3RhbmNlID0gZnVuY3Rpb24gaXNXaXRoaW5EaXN0YW5jZSAoZzAsIGcxLCBkaXN0YW5jZSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxLCBkaXN0YW5jZSk7XG4gIHJldHVybiBkaXN0T3AuZGlzdGFuY2UoKSA8PSBkaXN0YW5jZVxufTtcbkRpc3RhbmNlT3AubmVhcmVzdFBvaW50cyA9IGZ1bmN0aW9uIG5lYXJlc3RQb2ludHMgKGcwLCBnMSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxKTtcbiAgcmV0dXJuIGRpc3RPcC5uZWFyZXN0UG9pbnRzKClcbn07XG5cbnZhciBQb2ludFBhaXJEaXN0YW5jZSQyID0gZnVuY3Rpb24gUG9pbnRQYWlyRGlzdGFuY2UgKCkge1xuICB0aGlzLl9wdCA9IFtuZXcgQ29vcmRpbmF0ZSgpLCBuZXcgQ29vcmRpbmF0ZSgpXTtcbiAgdGhpcy5fZGlzdGFuY2UgPSBEb3VibGUuTmFOO1xuICB0aGlzLl9pc051bGwgPSB0cnVlO1xufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRbaV1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5zZXRNaW5pbXVtID0gZnVuY3Rpb24gc2V0TWluaW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1pbmltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA8IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5faXNOdWxsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwKTtcbiAgICB0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKHAxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHAwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUocDAkMSk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSQxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHRoaXMuX2lzTnVsbCA9IGZhbHNlO1xuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHRoaXMuX3B0WzBdLCB0aGlzLl9wdFsxXSlcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuc2V0TWF4aW11bSA9IGZ1bmN0aW9uIHNldE1heGltdW0gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRNYXhpbXVtKHB0RGlzdC5fcHRbMF0sIHB0RGlzdC5fcHRbMV0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLl9pc051bGwpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGRpc3QgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgaWYgKGRpc3QgPiB0aGlzLl9kaXN0YW5jZSkgeyB0aGlzLmluaXRpYWxpemUocDAsIHAxLCBkaXN0KTsgfVxuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRQYWlyRGlzdGFuY2UkMlxufTtcblxudmFyIERpc3RhbmNlVG9Qb2ludCA9IGZ1bmN0aW9uIERpc3RhbmNlVG9Qb2ludCAoKSB7fTtcblxuRGlzdGFuY2VUb1BvaW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzdGFuY2VUb1BvaW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc3RhbmNlVG9Qb2ludFxufTtcbkRpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRGlzdGFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB0ZW1wU2VnbWVudCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICAgIHZhciBjb29yZHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB0ZW1wU2VnbWVudC5zZXRDb29yZGluYXRlcyhjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pO1xuICAgICAgdmFyIGNsb3Nlc3RQdCA9IHRlbXBTZWdtZW50LmNsb3Nlc3RQb2ludChwdCk7XG4gICAgICBwdERpc3Quc2V0TWluaW11bShjbG9zZXN0UHQsIHB0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9seWdvbiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpJDErKykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEludGVyaW9yUmluZ04oaSQxKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMiA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgdmFyIGdjID0gZ2VvbTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSQyKyspIHtcbiAgICAgICAgdmFyIGcgPSBnYy5nZXRHZW9tZXRyeU4oaSQyKTtcbiAgICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShnLCBwdCQyLCBwdERpc3QkMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB0RGlzdCQyLnNldE1pbmltdW0oZ2VvbS5nZXRDb29yZGluYXRlKCksIHB0JDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBzZWdtZW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY2xvc2VzdFB0JDEgPSBzZWdtZW50LmNsb3Nlc3RQb2ludChwdCQzKTtcbiAgICBwdERpc3QkMy5zZXRNaW5pbXVtKGNsb3Nlc3RQdCQxLCBwdCQzKTtcbiAgfVxufTtcblxudmFyIERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UgPSBmdW5jdGlvbiBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlICgpIHtcbiAgdGhpcy5fZzAgPSBudWxsO1xuICB0aGlzLl9nMSA9IG51bGw7XG4gIHRoaXMuX3B0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX2RlbnNpZnlGcmFjID0gMC4wO1xuICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fZzAgPSBnMDtcbiAgdGhpcy5fZzEgPSBnMTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzkgPSB7IE1heFBvaW50RGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuc2V0RGVuc2lmeUZyYWN0aW9uID0gZnVuY3Rpb24gc2V0RGVuc2lmeUZyYWN0aW9uIChkZW5zaWZ5RnJhYykge1xuICBpZiAoZGVuc2lmeUZyYWMgPiAxLjAgfHwgZGVuc2lmeUZyYWMgPD0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ZyYWN0aW9uIGlzIG5vdCBpbiByYW5nZSAoMC4wIC0gMS4wXScpIH1cbiAgdGhpcy5fZGVuc2lmeUZyYWMgPSBkZW5zaWZ5RnJhYztcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSAoZzAsIGcxKSB7XG4gIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UoZzAsIGcxLCB0aGlzLl9wdERpc3QpO1xuICB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGcxLCBnMCwgdGhpcy5fcHREaXN0KTtcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgdGhpcy5jb21wdXRlKHRoaXMuX2cwLCB0aGlzLl9nMSk7XG4gIHJldHVybiB0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UgKGRpc2NyZXRlR2VvbSwgZ2VvbSwgcHREaXN0KSB7XG4gIHZhciBkaXN0RmlsdGVyID0gbmV3IE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMShnZW9tKTtcbiAgZGlzY3JldGVHZW9tLmFwcGx5KGRpc3RGaWx0ZXIpO1xuICBwdERpc3Quc2V0TWF4aW11bShkaXN0RmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG4gIGlmICh0aGlzLl9kZW5zaWZ5RnJhYyA+IDApIHtcbiAgICB2YXIgZnJhY0ZpbHRlciA9IG5ldyBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIoZ2VvbSwgdGhpcy5fZGVuc2lmeUZyYWMpO1xuICAgIGRpc2NyZXRlR2VvbS5hcHBseShmcmFjRmlsdGVyKTtcbiAgICBwdERpc3Quc2V0TWF4aW11bShmcmFjRmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG4gIH1cbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5vcmllbnRlZERpc3RhbmNlID0gZnVuY3Rpb24gb3JpZW50ZWREaXN0YW5jZSAoKSB7XG4gIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodGhpcy5fZzAsIHRoaXMuX2cxLCB0aGlzLl9wdERpc3QpO1xuICByZXR1cm4gdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKClcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkaXN0ID0gbmV3IERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UoZzAsIGcxKTtcbiAgICByZXR1cm4gZGlzdC5kaXN0YW5jZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZW5zaWZ5RnJhYyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZGlzdCQxID0gbmV3IERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UoZzAkMSwgZzEkMSk7XG4gICAgZGlzdCQxLnNldERlbnNpZnlGcmFjdGlvbihkZW5zaWZ5RnJhYyk7XG4gICAgcmV0dXJuIGRpc3QkMS5kaXN0YW5jZSgpXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzkuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQzOS5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLCBzdGF0aWNBY2Nlc3NvcnMkMzkgKTtcblxudmFyIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMSA9IGZ1bmN0aW9uIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgKCkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9ldWNsaWRlYW5EaXN0ID0gbmV3IERpc3RhbmNlVG9Qb2ludCgpO1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwdCkge1xuICB0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sIHB0LCB0aGlzLl9taW5QdERpc3QpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlRmlsdGVyXVxufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDFcbn07XG5cbnZhciBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIgKCkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fbnVtU3ViU2VncyA9IDA7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZnJhY3Rpb24gPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xuICB0aGlzLl9udW1TdWJTZWdzID0gTWF0aC50cnVuYyhNYXRoLnJvdW5kKDEuMCAvIGZyYWN0aW9uKSk7XG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaW5kZXggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcDAgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCAtIDEpO1xuICB2YXIgcDEgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCk7XG4gIHZhciBkZWx4ID0gKHAxLnggLSBwMC54KSAvIHRoaXMuX251bVN1YlNlZ3M7XG4gIHZhciBkZWx5ID0gKHAxLnkgLSBwMC55KSAvIHRoaXMuX251bVN1YlNlZ3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbnVtU3ViU2VnczsgaSsrKSB7XG4gICAgdmFyIHggPSBwMC54ICsgaSAqIGRlbHg7XG4gICAgdmFyIHkgPSBwMC55ICsgaSAqIGRlbHk7XG4gICAgdmFyIHB0ID0gbmV3IENvb3JkaW5hdGUoeCwgeSk7XG4gICAgdGhpcyQxLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UodGhpcyQxLl9nZW9tLCBwdCwgdGhpcyQxLl9taW5QdERpc3QpO1xuICAgIHRoaXMkMS5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcyQxLl9taW5QdERpc3QpO1xuICB9XG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmlzR2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNoYW5nZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldE1heFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRNYXhQb2ludERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXVxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXJcbn07XG5cbnZhciBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvciA9IGZ1bmN0aW9uIEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yIChpbnB1dCwgYnVmRGlzdGFuY2UsIHJlc3VsdCkge1xuICB0aGlzLl9taW5WYWxpZERpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgPSBudWxsO1xuICB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID0gbnVsbDtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHRoaXMuX2Vyck1zZyA9IG51bGw7XG4gIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBudWxsO1xuICB0aGlzLl9lcnJvckluZGljYXRvciA9IG51bGw7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXQgfHwgbnVsbDtcbiAgdGhpcy5fYnVmRGlzdGFuY2UgPSBidWZEaXN0YW5jZSB8fCBudWxsO1xuICB0aGlzLl9yZXN1bHQgPSByZXN1bHQgfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzcgPSB7IFZFUkJPU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX0RJU1RBTkNFX0RJRkZfRlJBQzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrTWF4aW11bURpc3RhbmNlID0gZnVuY3Rpb24gY2hlY2tNYXhpbXVtRGlzdGFuY2UgKGlucHV0LCBidWZDdXJ2ZSwgbWF4RGlzdCkge1xuICB2YXIgaGF1cyA9IG5ldyBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlKGJ1ZkN1cnZlLCBpbnB1dCk7XG4gIGhhdXMuc2V0RGVuc2lmeUZyYWN0aW9uKDAuMjUpO1xuICB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID0gaGF1cy5vcmllbnRlZERpc3RhbmNlKCk7XG4gIGlmICh0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID4gbWF4RGlzdCkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgcHRzID0gaGF1cy5nZXRDb29yZGluYXRlcygpO1xuICAgIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBwdHNbMV07XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBpbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhwdHMpO1xuICAgIHRoaXMuX2Vyck1zZyA9ICdEaXN0YW5jZSBiZXR3ZWVuIGJ1ZmZlciBjdXJ2ZSBhbmQgaW5wdXQgaXMgdG9vIGxhcmdlICgnICsgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCArICcgYXQgJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcocHRzWzBdLCBwdHNbMV0pICsgJyknO1xuICB9XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdmFyIHBvc0Rpc3RhbmNlID0gTWF0aC5hYnModGhpcy5fYnVmRGlzdGFuY2UpO1xuICB2YXIgZGlzdERlbHRhID0gQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IuTUFYX0RJU1RBTkNFX0RJRkZfRlJBQyAqIHBvc0Rpc3RhbmNlO1xuICB0aGlzLl9taW5WYWxpZERpc3RhbmNlID0gcG9zRGlzdGFuY2UgLSBkaXN0RGVsdGE7XG4gIHRoaXMuX21heFZhbGlkRGlzdGFuY2UgPSBwb3NEaXN0YW5jZSArIGRpc3REZWx0YTtcbiAgaWYgKHRoaXMuX2lucHV0LmlzRW1wdHkoKSB8fCB0aGlzLl9yZXN1bHQuaXNFbXB0eSgpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuX2J1ZkRpc3RhbmNlID4gMC4wKSB7XG4gICAgdGhpcy5jaGVja1Bvc2l0aXZlVmFsaWQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrTmVnYXRpdmVWYWxpZCgpO1xuICB9XG4gIGlmIChCdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5WRVJCT1NFKSB7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKCdNaW4gRGlzdD0gJyArIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgKyAnICBlcnI9ICcgKyAoMS4wIC0gdGhpcy5fbWluRGlzdGFuY2VGb3VuZCAvIHRoaXMuX2J1ZkRpc3RhbmNlKSArICcgIE1heCBEaXN0PSAnICsgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCArICcgIGVycj0gJyArICh0aGlzLl9tYXhEaXN0YW5jZUZvdW5kIC8gdGhpcy5fYnVmRGlzdGFuY2UgLSAxLjApKTtcbiAgfVxuICByZXR1cm4gdGhpcy5faXNWYWxpZFxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja05lZ2F0aXZlVmFsaWQgPSBmdW5jdGlvbiBjaGVja05lZ2F0aXZlVmFsaWQgKCkge1xuICBpZiAoISh0aGlzLl9pbnB1dCBpbnN0YW5jZW9mIFBvbHlnb24gfHwgdGhpcy5faW5wdXQgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24gfHwgdGhpcy5faW5wdXQgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgaW5wdXRDdXJ2ZSA9IHRoaXMuZ2V0UG9seWdvbkxpbmVzKHRoaXMuX2lucHV0KTtcbiAgdGhpcy5jaGVja01pbmltdW1EaXN0YW5jZShpbnB1dEN1cnZlLCB0aGlzLl9yZXN1bHQsIHRoaXMuX21pblZhbGlkRGlzdGFuY2UpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmNoZWNrTWF4aW11bURpc3RhbmNlKGlucHV0Q3VydmUsIHRoaXMuX3Jlc3VsdCwgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSk7XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9ySW5kaWNhdG9yID0gZnVuY3Rpb24gZ2V0RXJyb3JJbmRpY2F0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JJbmRpY2F0b3Jcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tNaW5pbXVtRGlzdGFuY2UgPSBmdW5jdGlvbiBjaGVja01pbmltdW1EaXN0YW5jZSAoZzEsIGcyLCBtaW5EaXN0KSB7XG4gIHZhciBkaXN0T3AgPSBuZXcgRGlzdGFuY2VPcChnMSwgZzIsIG1pbkRpc3QpO1xuICB0aGlzLl9taW5EaXN0YW5jZUZvdW5kID0gZGlzdE9wLmRpc3RhbmNlKCk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZUZvdW5kIDwgbWluRGlzdCkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgcHRzID0gZGlzdE9wLm5lYXJlc3RQb2ludHMoKTtcbiAgICB0aGlzLl9lcnJvckxvY2F0aW9uID0gZGlzdE9wLm5lYXJlc3RQb2ludHMoKVsxXTtcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IGcxLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHB0cyk7XG4gICAgdGhpcy5fZXJyTXNnID0gJ0Rpc3RhbmNlIGJldHdlZW4gYnVmZmVyIGN1cnZlIGFuZCBpbnB1dCBpcyB0b28gc21hbGwgKCcgKyB0aGlzLl9taW5EaXN0YW5jZUZvdW5kICsgJyBhdCAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhwdHNbMF0sIHB0c1sxXSkgKyAnICknO1xuICB9XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrUG9zaXRpdmVWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrUG9zaXRpdmVWYWxpZCAoKSB7XG4gIHZhciBidWZDdXJ2ZSA9IHRoaXMuX3Jlc3VsdC5nZXRCb3VuZGFyeSgpO1xuICB0aGlzLmNoZWNrTWluaW11bURpc3RhbmNlKHRoaXMuX2lucHV0LCBidWZDdXJ2ZSwgdGhpcy5fbWluVmFsaWREaXN0YW5jZSk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuY2hlY2tNYXhpbXVtRGlzdGFuY2UodGhpcy5faW5wdXQsIGJ1ZkN1cnZlLCB0aGlzLl9tYXhWYWxpZERpc3RhbmNlKTtcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEVycm9yTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JMb2NhdGlvblxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRQb2x5Z29uTGluZXMgPSBmdW5jdGlvbiBnZXRQb2x5Z29uTGluZXMgKGcpIHtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgbGluZUV4dHJhY3RlciA9IG5ldyBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIobGluZXMpO1xuICB2YXIgcG9seXMgPSBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGcpO1xuICBmb3IgKHZhciBpID0gcG9seXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHBvbHkgPSBpLm5leHQoKTtcbiAgICBwb2x5LmFwcGx5KGxpbmVFeHRyYWN0ZXIpO1xuICB9XG4gIHJldHVybiBnLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGxpbmVzKVxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyTXNnXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNy5WRVJCT1NFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzcuTUFYX0RJU1RBTkNFX0RJRkZfRlJBQy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjAxMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQzNyApO1xuXG52YXIgQnVmZmVyUmVzdWx0VmFsaWRhdG9yID0gZnVuY3Rpb24gQnVmZmVyUmVzdWx0VmFsaWRhdG9yIChpbnB1dCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgdGhpcy5fZXJyb3JNc2cgPSBudWxsO1xuICB0aGlzLl9lcnJvckxvY2F0aW9uID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBudWxsO1xuICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2UgfHwgbnVsbDtcbiAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0IHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQwID0geyBWRVJCT1NFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9FTlZfRElGRl9GUkFDOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdGhpcy5jaGVja1BvbHlnb25hbCgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrRXhwZWN0ZWRFbXB0eSgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrRW52ZWxvcGUoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0FyZWEoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0Rpc3RhbmNlKCk7XG4gIHJldHVybiB0aGlzLl9pc1ZhbGlkXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0VudmVsb3BlID0gZnVuY3Rpb24gY2hlY2tFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwYWRkaW5nID0gdGhpcy5fZGlzdGFuY2UgKiBCdWZmZXJSZXN1bHRWYWxpZGF0b3IuTUFYX0VOVl9ESUZGX0ZSQUM7XG4gIGlmIChwYWRkaW5nID09PSAwLjApIHsgcGFkZGluZyA9IDAuMDAxOyB9XG4gIHZhciBleHBlY3RlZEVudiA9IG5ldyBFbnZlbG9wZSh0aGlzLl9pbnB1dC5nZXRFbnZlbG9wZUludGVybmFsKCkpO1xuICBleHBlY3RlZEVudi5leHBhbmRCeSh0aGlzLl9kaXN0YW5jZSk7XG4gIHZhciBidWZFbnYgPSBuZXcgRW52ZWxvcGUodGhpcy5fcmVzdWx0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7XG4gIGJ1ZkVudi5leHBhbmRCeShwYWRkaW5nKTtcbiAgaWYgKCFidWZFbnYuY29udGFpbnMoZXhwZWN0ZWRFbnYpKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ0J1ZmZlciBlbnZlbG9wZSBpcyBpbmNvcnJlY3QnO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoYnVmRW52KTtcbiAgfVxuICB0aGlzLnJlcG9ydCgnRW52ZWxvcGUnKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrRGlzdGFuY2UgPSBmdW5jdGlvbiBjaGVja0Rpc3RhbmNlICgpIHtcbiAgdmFyIGRpc3RWYWxpZCA9IG5ldyBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvcih0aGlzLl9pbnB1dCwgdGhpcy5fZGlzdGFuY2UsIHRoaXMuX3Jlc3VsdCk7XG4gIGlmICghZGlzdFZhbGlkLmlzVmFsaWQoKSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9IGRpc3RWYWxpZC5nZXRFcnJvck1lc3NhZ2UoKTtcbiAgICB0aGlzLl9lcnJvckxvY2F0aW9uID0gZGlzdFZhbGlkLmdldEVycm9yTG9jYXRpb24oKTtcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IGRpc3RWYWxpZC5nZXRFcnJvckluZGljYXRvcigpO1xuICB9XG4gIHRoaXMucmVwb3J0KCdEaXN0YW5jZScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tBcmVhID0gZnVuY3Rpb24gY2hlY2tBcmVhICgpIHtcbiAgdmFyIGlucHV0QXJlYSA9IHRoaXMuX2lucHV0LmdldEFyZWEoKTtcbiAgdmFyIHJlc3VsdEFyZWEgPSB0aGlzLl9yZXN1bHQuZ2V0QXJlYSgpO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPiAwLjAgJiYgaW5wdXRBcmVhID4gcmVzdWx0QXJlYSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9ICdBcmVhIG9mIHBvc2l0aXZlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gaW5wdXQnO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5fcmVzdWx0O1xuICB9XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCAmJiBpbnB1dEFyZWEgPCByZXN1bHRBcmVhKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ0FyZWEgb2YgbmVnYXRpdmUgYnVmZmVyIGlzIGxhcmdlciB0aGFuIGlucHV0JztcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgfVxuICB0aGlzLnJlcG9ydCgnQXJlYScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tQb2x5Z29uYWwgPSBmdW5jdGlvbiBjaGVja1BvbHlnb25hbCAoKSB7XG4gIGlmICghKHRoaXMuX3Jlc3VsdCBpbnN0YW5jZW9mIFBvbHlnb24gfHwgdGhpcy5fcmVzdWx0IGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSkgeyB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7IH1cbiAgdGhpcy5fZXJyb3JNc2cgPSAnUmVzdWx0IGlzIG5vdCBwb2x5Z29uYWwnO1xuICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgdGhpcy5yZXBvcnQoJ1BvbHlnb25hbCcpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JJbmRpY2F0b3IgPSBmdW5jdGlvbiBnZXRFcnJvckluZGljYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvckluZGljYXRvclxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEVycm9yTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JMb2NhdGlvblxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZEVtcHR5ID0gZnVuY3Rpb24gY2hlY2tFeHBlY3RlZEVtcHR5ICgpIHtcbiAgaWYgKHRoaXMuX2lucHV0LmdldERpbWVuc2lvbigpID49IDIpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPiAwLjApIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoIXRoaXMuX3Jlc3VsdC5pc0VtcHR5KCkpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSAnUmVzdWx0IGlzIG5vbi1lbXB0eSc7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9yZXN1bHQ7XG4gIH1cbiAgdGhpcy5yZXBvcnQoJ0V4cGVjdGVkRW1wdHknKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLnJlcG9ydCA9IGZ1bmN0aW9uIHJlcG9ydCAoY2hlY2tOYW1lKSB7XG4gIGlmICghQnVmZmVyUmVzdWx0VmFsaWRhdG9yLlZFUkJPU0UpIHsgcmV0dXJuIG51bGwgfVxuICBTeXN0ZW0ub3V0LnByaW50bG4oJ0NoZWNrICcgKyBjaGVja05hbWUgKyAnOiAnICsgKHRoaXMuX2lzVmFsaWQgPyAncGFzc2VkJyA6ICdGQUlMRUQnKSk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JNc2dcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyUmVzdWx0VmFsaWRhdG9yXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLmlzVmFsaWRNc2cgPSBmdW5jdGlvbiBpc1ZhbGlkTXNnIChnLCBkaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgQnVmZmVyUmVzdWx0VmFsaWRhdG9yKGcsIGRpc3RhbmNlLCByZXN1bHQpO1xuICBpZiAoIXZhbGlkYXRvci5pc1ZhbGlkKCkpIHsgcmV0dXJuIHZhbGlkYXRvci5nZXRFcnJvck1lc3NhZ2UoKSB9XG4gIHJldHVybiBudWxsXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChnLCBkaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgQnVmZmVyUmVzdWx0VmFsaWRhdG9yKGcsIGRpc3RhbmNlLCByZXN1bHQpO1xuICBpZiAodmFsaWRhdG9yLmlzVmFsaWQoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0MC5WRVJCT1NFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5zdGF0aWNBY2Nlc3NvcnMkNDAuTUFYX0VOVl9ESUZGX0ZSQUMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC4wMTIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlclJlc3VsdFZhbGlkYXRvciwgc3RhdGljQWNjZXNzb3JzJDQwICk7XG5cbi8vIG9wZXJhdGlvbi5idWZmZXJcblxudmFyIEJhc2ljU2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIEJhc2ljU2VnbWVudFN0cmluZyAoKSB7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHMubGVuZ3RoXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRzW2ldXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGggLSAxXSlcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldFNlZ21lbnRPY3RhbnQgPSBmdW5jdGlvbiBnZXRTZWdtZW50T2N0YW50IChpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHRoaXMuX3B0cy5sZW5ndGggLSAxKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiBPY3RhbnQub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCksIHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCArIDEpKVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEgKGRhdGEpIHtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSAoKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHRoaXMuX3B0cykpXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50U3RyaW5nXVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCYXNpY1NlZ21lbnRTdHJpbmdcbn07XG5cbnZhciBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlciA9IGZ1bmN0aW9uIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyICgpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSA9IGZhbHNlO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5faW50U2VnbWVudHMgPSBudWxsO1xuICB0aGlzLl9pbnRlcnNlY3Rpb25zID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudCA9IDA7XG4gIHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9saSA9IGxpO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiA9IG51bGw7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldEludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0Q2hlY2tFbmRTZWdtZW50c09ubHkgPSBmdW5jdGlvbiBzZXRDaGVja0VuZFNlZ21lbnRzT25seSAoaXNDaGVja0VuZFNlZ21lbnRzT25seSkge1xuICB0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5ID0gaXNDaGVja0VuZFNlZ21lbnRzT25seTtcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25TZWdtZW50cyAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRTZWdtZW50c1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIGNvdW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbnNcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyAoZmluZEFsbEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmaW5kQWxsSW50ZXJzZWN0aW9ucztcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0S2VlcEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRLZWVwSW50ZXJzZWN0aW9ucyAoa2VlcEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fa2VlcEludGVyc2VjdGlvbnMgPSBrZWVwSW50ZXJzZWN0aW9ucztcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zICYmIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpIHtcbiAgICB2YXIgaXNFbmRTZWdQcmVzZW50ID0gdGhpcy5pc0VuZFNlZ21lbnQoZTAsIHNlZ0luZGV4MCkgfHwgdGhpcy5pc0VuZFNlZ21lbnQoZTEsIHNlZ0luZGV4MSk7XG4gICAgaWYgKCFpc0VuZFNlZ1ByZXNlbnQpIHsgcmV0dXJuIG51bGwgfVxuICB9XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICBpZiAodGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKSB7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50cyA9IG5ldyBBcnJheSg0KS5maWxsKG51bGwpO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbMF0gPSBwMDA7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50c1sxXSA9IHAwMTtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzWzJdID0gcDEwO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbM10gPSBwMTE7XG4gICAgICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKTtcbiAgICAgIGlmICh0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucykgeyB0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbik7IH1cbiAgICAgIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50Kys7XG4gICAgfVxuICB9XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmlzRW5kU2VnbWVudCA9IGZ1bmN0aW9uIGlzRW5kU2VnbWVudCAoc2VnU3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IDApIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoaW5kZXggPj0gc2VnU3RyLnNpemUoKSAtIDIpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uICE9PSBudWxsXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIGlmICh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gIT09IG51bGxcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudEludGVyc2VjdG9yXVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIuY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlciA9IGZ1bmN0aW9uIGNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIgKGxpKSB7XG4gIHZhciBmaW5kZXIgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpO1xuICBmaW5kZXIuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIHJldHVybiBmaW5kZXJcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5jcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIgKGxpKSB7XG4gIHJldHVybiBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIuY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXIgKGxpKSB7XG4gIHZhciBmaW5kZXIgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpO1xuICBmaW5kZXIuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIGZpbmRlci5zZXRLZWVwSW50ZXJzZWN0aW9ucyhmYWxzZSk7XG4gIHJldHVybiBmaW5kZXJcbn07XG5cbnZhciBGYXN0Tm9kaW5nVmFsaWRhdG9yID0gZnVuY3Rpb24gRmFzdE5vZGluZ1ZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gbnVsbDtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5fc2VnSW50ID0gbnVsbDtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gc2VnU3RyaW5ncztcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSAoKSB7XG4gIGlmICh0aGlzLl9zZWdJbnQgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCk7XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbnMoKVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdGhpcy5leGVjdXRlKCk7XG4gIHJldHVybiB0aGlzLl9pc1ZhbGlkXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyAoZmluZEFsbEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmaW5kQWxsSW50ZXJzZWN0aW9ucztcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zICgpIHtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHRoaXMuX3NlZ0ludCA9IG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlcih0aGlzLl9saSk7XG4gIHRoaXMuX3NlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyk7XG4gIHZhciBub2RlciA9IG5ldyBNQ0luZGV4Tm9kZXIoKTtcbiAgbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCk7XG4gIG5vZGVyLmNvbXB1dGVOb2Rlcyh0aGlzLl9zZWdTdHJpbmdzKTtcbiAgaWYgKHRoaXMuX3NlZ0ludC5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICB0aGlzLmV4ZWN1dGUoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLCB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkgfVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZSAoKSB7XG4gIGlmICh0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiAnbm8gaW50ZXJzZWN0aW9ucyBmb3VuZCcgfVxuICB2YXIgaW50U2VncyA9IHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO1xuICByZXR1cm4gJ2ZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYmV0d2VlbiAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhpbnRTZWdzWzBdLCBpbnRTZWdzWzFdKSArICcgYW5kICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKGludFNlZ3NbMl0sIGludFNlZ3NbM10pXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRmFzdE5vZGluZ1ZhbGlkYXRvclxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IuY29tcHV0ZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9ucyAoc2VnU3RyaW5ncykge1xuICB2YXIgbnYgPSBuZXcgRmFzdE5vZGluZ1ZhbGlkYXRvcihzZWdTdHJpbmdzKTtcbiAgbnYuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIG52LmlzVmFsaWQoKTtcbiAgcmV0dXJuIG52LmdldEludGVyc2VjdGlvbnMoKVxufTtcblxudmFyIEVkZ2VOb2RpbmdWYWxpZGF0b3IgPSBmdW5jdGlvbiBFZGdlTm9kaW5nVmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fbnYgPSBudWxsO1xuICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX252ID0gbmV3IEZhc3ROb2RpbmdWYWxpZGF0b3IoRWRnZU5vZGluZ1ZhbGlkYXRvci50b1NlZ21lbnRTdHJpbmdzKGVkZ2VzKSk7XG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICB0aGlzLl9udi5jaGVja1ZhbGlkKCk7XG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZU5vZGluZ1ZhbGlkYXRvclxufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IudG9TZWdtZW50U3RyaW5ncyA9IGZ1bmN0aW9uIHRvU2VnbWVudFN0cmluZ3MgKGVkZ2VzKSB7XG4gIHZhciBzZWdTdHJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICBzZWdTdHJpbmdzLmFkZChuZXcgQmFzaWNTZWdtZW50U3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSwgZSkpO1xuICB9XG4gIHJldHVybiBzZWdTdHJpbmdzXG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoZWRnZXMpIHtcbiAgdmFyIHZhbGlkYXRvciA9IG5ldyBFZGdlTm9kaW5nVmFsaWRhdG9yKGVkZ2VzKTtcbiAgdmFsaWRhdG9yLmNoZWNrVmFsaWQoKTtcbn07XG5cbnZhciBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIgKG1hcE9wKSB7XG4gIHRoaXMuX21hcE9wID0gbWFwT3A7XG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGdjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG1hcHBlZCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBnID0gdGhpcyQxLl9tYXBPcC5tYXAoZ2MuZ2V0R2VvbWV0cnlOKGkpKTtcbiAgICBpZiAoIWcuaXNFbXB0eSgpKSB7IG1hcHBlZC5hZGQoZyk7IH1cbiAgfVxuICByZXR1cm4gZ2MuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihHZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5KG1hcHBlZCkpXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlclxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5tYXAgPSBmdW5jdGlvbiBtYXAgKGdjLCBvcCkge1xuICB2YXIgbWFwcGVyID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlcihvcCk7XG4gIHJldHVybiBtYXBwZXIubWFwKGdjKVxufTtcblxudmFyIExpbmVCdWlsZGVyID0gZnVuY3Rpb24gTGluZUJ1aWxkZXIgKCkge1xuICB0aGlzLl9vcCA9IG51bGw7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3B0TG9jYXRvciA9IG51bGw7XG4gIHRoaXMuX2xpbmVFZGdlc0xpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3Jlc3VsdExpbmVMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgb3AgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIHZhciBwdExvY2F0b3IgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX29wID0gb3A7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbiAgdGhpcy5fcHRMb2NhdG9yID0gcHRMb2NhdG9yO1xufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb2xsZWN0TGluZXMgPSBmdW5jdGlvbiBjb2xsZWN0TGluZXMgKG9wQ29kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgdGhpcyQxLmNvbGxlY3RMaW5lRWRnZShkZSwgb3BDb2RlLCB0aGlzJDEuX2xpbmVFZGdlc0xpc3QpO1xuICAgIHRoaXMkMS5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UoZGUsIG9wQ29kZSwgdGhpcyQxLl9saW5lRWRnZXNMaXN0KTtcbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5sYWJlbElzb2xhdGVkTGluZSA9IGZ1bmN0aW9uIGxhYmVsSXNvbGF0ZWRMaW5lIChlLCB0YXJnZXRJbmRleCkge1xuICB2YXIgbG9jID0gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShlLmdldENvb3JkaW5hdGUoKSwgdGhpcy5fb3AuZ2V0QXJnR2VvbWV0cnkodGFyZ2V0SW5kZXgpKTtcbiAgZS5nZXRMYWJlbCgpLnNldExvY2F0aW9uKHRhcmdldEluZGV4LCBsb2MpO1xufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkIChvcENvZGUpIHtcbiAgdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpO1xuICB0aGlzLmNvbGxlY3RMaW5lcyhvcENvZGUpO1xuICB0aGlzLmJ1aWxkTGluZXMob3BDb2RlKTtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdExpbmVMaXN0XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbGxlY3RMaW5lRWRnZSA9IGZ1bmN0aW9uIGNvbGxlY3RMaW5lRWRnZSAoZGUsIG9wQ29kZSwgZWRnZXMpIHtcbiAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgdmFyIGUgPSBkZS5nZXRFZGdlKCk7XG4gIGlmIChkZS5pc0xpbmVFZGdlKCkpIHtcbiAgICBpZiAoIWRlLmlzVmlzaXRlZCgpICYmIE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwsIG9wQ29kZSkgJiYgIWUuaXNDb3ZlcmVkKCkpIHtcbiAgICAgIGVkZ2VzLmFkZChlKTtcbiAgICAgIGRlLnNldFZpc2l0ZWRFZGdlKHRydWUpO1xuICAgIH1cbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5maW5kQ292ZXJlZExpbmVFZGdlcyA9IGZ1bmN0aW9uIGZpbmRDb3ZlcmVkTGluZUVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCk7XG4gIH1cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgZSA9IGRlLmdldEVkZ2UoKTtcbiAgICBpZiAoZGUuaXNMaW5lRWRnZSgpICYmICFlLmlzQ292ZXJlZFNldCgpKSB7XG4gICAgICB2YXIgaXNDb3ZlcmVkID0gdGhpcyQxLl9vcC5pc0NvdmVyZWRCeUEoZGUuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIGUuc2V0Q292ZXJlZChpc0NvdmVyZWQpO1xuICAgIH1cbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5sYWJlbElzb2xhdGVkTGluZXMgPSBmdW5jdGlvbiBsYWJlbElzb2xhdGVkTGluZXMgKGVkZ2VzTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gZWRnZXNMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgaWYgKGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICBpZiAobGFiZWwuaXNOdWxsKDApKSB7IHRoaXMkMS5sYWJlbElzb2xhdGVkTGluZShlLCAwKTsgfSBlbHNlIHsgdGhpcyQxLmxhYmVsSXNvbGF0ZWRMaW5lKGUsIDEpOyB9XG4gICAgfVxuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTGluZXMgPSBmdW5jdGlvbiBidWlsZExpbmVzIChvcENvZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IHRoaXMuX2xpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIC8vIGNvbnN0IGxhYmVsID0gZS5nZXRMYWJlbCgpXG4gICAgdmFyIGxpbmUgPSB0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgdGhpcyQxLl9yZXN1bHRMaW5lTGlzdC5hZGQobGluZSk7XG4gICAgZS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UgPSBmdW5jdGlvbiBjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UgKGRlLCBvcENvZGUsIGVkZ2VzKSB7XG4gIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gIGlmIChkZS5pc0xpbmVFZGdlKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuaXNWaXNpdGVkKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuaXNJbnRlcmlvckFyZWFFZGdlKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIEFzc2VydC5pc1RydWUoIShkZS5pc0luUmVzdWx0KCkgfHwgZGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSB8fCAhZGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSk7XG4gIGlmIChPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLCBvcENvZGUpICYmIG9wQ29kZSA9PT0gT3ZlcmxheU9wLklOVEVSU0VDVElPTikge1xuICAgIGVkZ2VzLmFkZChkZS5nZXRFZGdlKCkpO1xuICAgIGRlLnNldFZpc2l0ZWRFZGdlKHRydWUpO1xuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lQnVpbGRlclxufTtcblxudmFyIFBvaW50QnVpbGRlciA9IGZ1bmN0aW9uIFBvaW50QnVpbGRlciAoKSB7XG4gIHRoaXMuX29wID0gbnVsbDtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgb3AgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIC8vIGNvbnN0IHB0TG9jYXRvciA9IGFyZ3VtZW50c1syXVxuICB0aGlzLl9vcCA9IG9wO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3Rvcnk7XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQgPSBmdW5jdGlvbiBmaWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQgKG4pIHtcbiAgdmFyIGNvb3JkID0gbi5nZXRDb29yZGluYXRlKCk7XG4gIGlmICghdGhpcy5fb3AuaXNDb3ZlcmVkQnlMQShjb29yZCkpIHtcbiAgICB2YXIgcHQgPSB0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoY29vcmQpO1xuICAgIHRoaXMuX3Jlc3VsdFBvaW50TGlzdC5hZGQocHQpO1xuICB9XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzID0gZnVuY3Rpb24gZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlcyAob3BDb2RlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG4gPSBub2RlaXQubmV4dCgpO1xuICAgIGlmIChuLmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgaWYgKG4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAobi5nZXRFZGdlcygpLmdldERlZ3JlZSgpID09PSAwIHx8IG9wQ29kZSA9PT0gT3ZlcmxheU9wLklOVEVSU0VDVElPTikge1xuICAgICAgdmFyIGxhYmVsID0gbi5nZXRMYWJlbCgpO1xuICAgICAgaWYgKE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwsIG9wQ29kZSkpIHtcbiAgICAgICAgdGhpcyQxLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQgKG9wQ29kZSkge1xuICB0aGlzLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXMob3BDb2RlKTtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdFBvaW50TGlzdFxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludEJ1aWxkZXJcbn07XG5cbnZhciBHZW9tZXRyeVRyYW5zZm9ybWVyID0gZnVuY3Rpb24gR2VvbWV0cnlUcmFuc2Zvcm1lciAoKSB7XG4gIHRoaXMuX2lucHV0R2VvbSA9IG51bGw7XG4gIHRoaXMuX2ZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnkgPSB0cnVlO1xuICB0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGUgPSB0cnVlO1xuICB0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuX3ByZXNlcnZlVHlwZSA9IGZhbHNlO1xufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQgKGdlb20sIHBhcmVudCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb20pKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvbHlnb24gPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2x5Z29uIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaXNBbGxWYWxpZExpbmVhclJpbmdzID0gdHJ1ZTtcbiAgdmFyIHNoZWxsID0gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKGdlb20uZ2V0RXh0ZXJpb3JSaW5nKCksIGdlb20pO1xuICBpZiAoc2hlbGwgPT09IG51bGwgfHwgIShzaGVsbCBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHx8IHNoZWxsLmlzRW1wdHkoKSkgeyBpc0FsbFZhbGlkTGluZWFyUmluZ3MgPSBmYWxzZTsgfVxuICB2YXIgaG9sZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSB0aGlzJDEudHJhbnNmb3JtTGluZWFyUmluZyhnZW9tLmdldEludGVyaW9yUmluZ04oaSksIGdlb20pO1xuICAgIGlmIChob2xlID09PSBudWxsIHx8IGhvbGUuaXNFbXB0eSgpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoIShob2xlIGluc3RhbmNlb2YgTGluZWFyUmluZykpIHsgaXNBbGxWYWxpZExpbmVhclJpbmdzID0gZmFsc2U7IH1cbiAgICBob2xlcy5hZGQoaG9sZSk7XG4gIH1cbiAgaWYgKGlzQWxsVmFsaWRMaW5lYXJSaW5ncykgeyByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcy50b0FycmF5KFtdKSk7IH0gZWxzZSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgaWYgKHNoZWxsICE9PSBudWxsKSB7IGNvbXBvbmVudHMuYWRkKHNoZWxsKTsgfVxuICAgIGNvbXBvbmVudHMuYWRkQWxsKGhvbGVzKTtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGNvbXBvbmVudHMpXG4gIH1cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBjcmVhdGVDb29yZGluYXRlU2VxdWVuY2UgKGNvb3Jkcykge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3Jkcylcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRJbnB1dEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0SW5wdXRHZW9tZXRyeSAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dEdlb21cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiB0cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcgKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm1MaW5lU3RyaW5nKGdlb20uZ2V0R2VvbWV0cnlOKGkpLCBnZW9tKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRyYW5zR2VvbUxpc3QpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Db29yZGluYXRlcyAoY29vcmRzLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHRoaXMuY29weShjb29yZHMpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTGluZVN0cmluZyA9IGZ1bmN0aW9uIHRyYW5zZm9ybUxpbmVTdHJpbmcgKGdlb20sIHBhcmVudCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXMoZ2VvbS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbSkpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2ludCA9IGZ1bmN0aW9uIHRyYW5zZm9ybU11bHRpUG9pbnQgKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm1Qb2ludChnZW9tLmdldEdlb21ldHJ5TihpKSwgZ2VvbSk7XG4gICAgaWYgKHRyYW5zZm9ybUdlb20gPT09IG51bGwpIHsgY29udGludWUgfVxuICAgIGlmICh0cmFuc2Zvcm1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgdHJhbnNHZW9tTGlzdC5hZGQodHJhbnNmb3JtR2VvbSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0cmFuc0dlb21MaXN0KVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybU11bHRpUG9seWdvbiAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHRyYW5zR2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciB0cmFuc2Zvcm1HZW9tID0gdGhpcyQxLnRyYW5zZm9ybVBvbHlnb24oZ2VvbS5nZXRHZW9tZXRyeU4oaSksIGdlb20pO1xuICAgIGlmICh0cmFuc2Zvcm1HZW9tID09PSBudWxsKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAodHJhbnNmb3JtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIHRyYW5zR2VvbUxpc3QuYWRkKHRyYW5zZm9ybUdlb20pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoc2VxKSB7XG4gIHJldHVybiBzZXEuY29weSgpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gdHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHJhbnNHZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUdlb20gPSB0aGlzJDEudHJhbnNmb3JtKGdlb20uZ2V0R2VvbWV0cnlOKGkpKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRoaXMkMS5fcHJ1bmVFbXB0eUdlb21ldHJ5ICYmIHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICBpZiAodGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihHZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5KHRyYW5zR2VvbUxpc3QpKSB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKGlucHV0R2VvbSkge1xuICB0aGlzLl9pbnB1dEdlb20gPSBpbnB1dEdlb207XG4gIHRoaXMuX2ZhY3RvcnkgPSBpbnB1dEdlb20uZ2V0RmFjdG9yeSgpO1xuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgUG9pbnQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBNdWx0aVBvaW50KSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgUG9seWdvbikgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbihpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24oaW5wdXRHZW9tLCBudWxsKSB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vua25vd24gR2VvbWV0cnkgc3VidHlwZTogJyArIGlucHV0R2VvbS5nZXRDbGFzcygpLmdldE5hbWUoKSlcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1MaW5lYXJSaW5nID0gZnVuY3Rpb24gdHJhbnNmb3JtTGluZWFyUmluZyAoZ2VvbSwgcGFyZW50KSB7XG4gIHZhciBzZXEgPSB0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb20pO1xuICBpZiAoc2VxID09PSBudWxsKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCkgfVxuICB2YXIgc2VxU2l6ZSA9IHNlcS5zaXplKCk7XG4gIGlmIChzZXFTaXplID4gMCAmJiBzZXFTaXplIDwgNCAmJiAhdGhpcy5fcHJlc2VydmVUeXBlKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoc2VxKSB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoc2VxKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5VHJhbnNmb3JtZXJcbn07XG5cbnZhciBMaW5lU3RyaW5nU25hcHBlciA9IGZ1bmN0aW9uIExpbmVTdHJpbmdTbmFwcGVyICgpIHtcbiAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IDAuMDtcbiAgdGhpcy5fc3JjUHRzID0gbnVsbDtcbiAgdGhpcy5fc2VnID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzID0gZmFsc2U7XG4gIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHNyY0xpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNuYXBUb2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgTGluZVN0cmluZ1NuYXBwZXIuY2FsbCh0aGlzLCBzcmNMaW5lLmdldENvb3JkaW5hdGVzKCksIHNuYXBUb2xlcmFuY2UpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHNyY1B0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc25hcFRvbGVyYW5jZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX3NyY1B0cyA9IHNyY1B0cztcbiAgICB0aGlzLl9pc0Nsb3NlZCA9IExpbmVTdHJpbmdTbmFwcGVyLmlzQ2xvc2VkKHNyY1B0cyk7XG4gICAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IHNuYXBUb2xlcmFuY2UkMTtcbiAgfVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zbmFwVmVydGljZXMgPSBmdW5jdGlvbiBzbmFwVmVydGljZXMgKHNyY0Nvb3Jkcywgc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbmQgPSB0aGlzLl9pc0Nsb3NlZCA/IHNyY0Nvb3Jkcy5zaXplKCkgLSAxIDogc3JjQ29vcmRzLnNpemUoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBzcmNQdCA9IHNyY0Nvb3Jkcy5nZXQoaSk7XG4gICAgdmFyIHNuYXBWZXJ0ID0gdGhpcyQxLmZpbmRTbmFwRm9yVmVydGV4KHNyY1B0LCBzbmFwUHRzKTtcbiAgICBpZiAoc25hcFZlcnQgIT09IG51bGwpIHtcbiAgICAgIHNyY0Nvb3Jkcy5zZXQoaSwgbmV3IENvb3JkaW5hdGUoc25hcFZlcnQpKTtcbiAgICAgIGlmIChpID09PSAwICYmIHRoaXMkMS5faXNDbG9zZWQpIHsgc3JjQ29vcmRzLnNldChzcmNDb29yZHMuc2l6ZSgpIC0gMSwgbmV3IENvb3JkaW5hdGUoc25hcFZlcnQpKTsgfVxuICAgIH1cbiAgfVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5maW5kU25hcEZvclZlcnRleCA9IGZ1bmN0aW9uIGZpbmRTbmFwRm9yVmVydGV4IChwdCwgc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc25hcFB0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwdC5lcXVhbHMyRChzbmFwUHRzW2ldKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHB0LmRpc3RhbmNlKHNuYXBQdHNbaV0pIDwgdGhpcyQxLl9zbmFwVG9sZXJhbmNlKSB7IHJldHVybiBzbmFwUHRzW2ldIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zbmFwVG8gPSBmdW5jdGlvbiBzbmFwVG8gKHNuYXBQdHMpIHtcbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCh0aGlzLl9zcmNQdHMpO1xuICB0aGlzLnNuYXBWZXJ0aWNlcyhjb29yZExpc3QsIHNuYXBQdHMpO1xuICB0aGlzLnNuYXBTZWdtZW50cyhjb29yZExpc3QsIHNuYXBQdHMpO1xuICB2YXIgbmV3UHRzID0gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7XG4gIHJldHVybiBuZXdQdHNcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc25hcFNlZ21lbnRzID0gZnVuY3Rpb24gc25hcFNlZ21lbnRzIChzcmNDb29yZHMsIHNuYXBQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoc25hcFB0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZGlzdGluY3RQdENvdW50ID0gc25hcFB0cy5sZW5ndGg7XG4gIGlmIChzbmFwUHRzWzBdLmVxdWFsczJEKHNuYXBQdHNbc25hcFB0cy5sZW5ndGggLSAxXSkpIHsgZGlzdGluY3RQdENvdW50ID0gc25hcFB0cy5sZW5ndGggLSAxOyB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdGluY3RQdENvdW50OyBpKyspIHtcbiAgICB2YXIgc25hcFB0ID0gc25hcFB0c1tpXTtcbiAgICB2YXIgaW5kZXggPSB0aGlzJDEuZmluZFNlZ21lbnRJbmRleFRvU25hcChzbmFwUHQsIHNyY0Nvb3Jkcyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHNyY0Nvb3Jkcy5hZGQoaW5kZXggKyAxLCBuZXcgQ29vcmRpbmF0ZShzbmFwUHQpLCBmYWxzZSk7XG4gICAgfVxuICB9XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAgPSBmdW5jdGlvbiBmaW5kU2VnbWVudEluZGV4VG9TbmFwIChzbmFwUHQsIHNyY0Nvb3Jkcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtaW5EaXN0ID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgdmFyIHNuYXBJbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY0Nvb3Jkcy5zaXplKCkgLSAxOyBpKyspIHtcbiAgICB0aGlzJDEuX3NlZy5wMCA9IHNyY0Nvb3Jkcy5nZXQoaSk7XG4gICAgdGhpcyQxLl9zZWcucDEgPSBzcmNDb29yZHMuZ2V0KGkgKyAxKTtcbiAgICBpZiAodGhpcyQxLl9zZWcucDAuZXF1YWxzMkQoc25hcFB0KSB8fCB0aGlzJDEuX3NlZy5wMS5lcXVhbHMyRChzbmFwUHQpKSB7XG4gICAgICBpZiAodGhpcyQxLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcykgeyBjb250aW51ZTsgfSBlbHNlIHsgcmV0dXJuIC0xIH1cbiAgICB9XG4gICAgdmFyIGRpc3QgPSB0aGlzJDEuX3NlZy5kaXN0YW5jZShzbmFwUHQpO1xuICAgIGlmIChkaXN0IDwgdGhpcyQxLl9zbmFwVG9sZXJhbmNlICYmIGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIHNuYXBJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzbmFwSW5kZXhcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgPSBmdW5jdGlvbiBzZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyAoYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpIHtcbiAgdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgPSBhbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcztcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVTdHJpbmdTbmFwcGVyXG59O1xuTGluZVN0cmluZ1NuYXBwZXIuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAocHRzKSB7XG4gIGlmIChwdHMubGVuZ3RoIDw9IDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHB0c1swXS5lcXVhbHMyRChwdHNbcHRzLmxlbmd0aCAtIDFdKVxufTtcblxudmFyIEdlb21ldHJ5U25hcHBlciA9IGZ1bmN0aW9uIEdlb21ldHJ5U25hcHBlciAoc3JjR2VvbSkge1xuICB0aGlzLl9zcmNHZW9tID0gc3JjR2VvbSB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0MSA9IHsgU05BUF9QUkVDSVNJT05fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLnNuYXBUbyA9IGZ1bmN0aW9uIHNuYXBUbyAoc25hcEdlb20sIHNuYXBUb2xlcmFuY2UpIHtcbiAgdmFyIHNuYXBQdHMgPSB0aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyhzbmFwR2VvbSk7XG4gIHZhciBzbmFwVHJhbnMgPSBuZXcgU25hcFRyYW5zZm9ybWVyKHNuYXBUb2xlcmFuY2UsIHNuYXBQdHMpO1xuICByZXR1cm4gc25hcFRyYW5zLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKVxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuc25hcFRvU2VsZiA9IGZ1bmN0aW9uIHNuYXBUb1NlbGYgKHNuYXBUb2xlcmFuY2UsIGNsZWFuUmVzdWx0KSB7XG4gIHZhciBzbmFwUHRzID0gdGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSk7XG4gIHZhciBzbmFwVHJhbnMgPSBuZXcgU25hcFRyYW5zZm9ybWVyKHNuYXBUb2xlcmFuY2UsIHNuYXBQdHMsIHRydWUpO1xuICB2YXIgc25hcHBlZEdlb20gPSBzbmFwVHJhbnMudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pO1xuICB2YXIgcmVzdWx0ID0gc25hcHBlZEdlb207XG4gIGlmIChjbGVhblJlc3VsdCAmJiBoYXNJbnRlcmZhY2UocmVzdWx0LCBQb2x5Z29uYWwpKSB7XG4gICAgcmVzdWx0ID0gc25hcHBlZEdlb20uYnVmZmVyKDApO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmNvbXB1dGVTbmFwVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZVNuYXBUb2xlcmFuY2UgKHJpbmdQdHMpIHtcbiAgdmFyIG1pblNlZ0xlbiA9IHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHJpbmdQdHMpO1xuICB2YXIgc25hcFRvbCA9IG1pblNlZ0xlbiAvIDEwO1xuICByZXR1cm4gc25hcFRvbFxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzIChnKSB7XG4gIHZhciBwdFNldCA9IG5ldyBUcmVlU2V0KCk7XG4gIHZhciBwdHMgPSBnLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcHRTZXQuYWRkKHB0c1tpXSk7XG4gIH1cbiAgcmV0dXJuIHB0U2V0LnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGggPSBmdW5jdGlvbiBjb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGggKHB0cykge1xuICB2YXIgbWluU2VnTGVuID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIHNlZ0xlbiA9IHB0c1tpXS5kaXN0YW5jZShwdHNbaSArIDFdKTtcbiAgICBpZiAoc2VnTGVuIDwgbWluU2VnTGVuKSB7IG1pblNlZ0xlbiA9IHNlZ0xlbjsgfVxuICB9XG4gIHJldHVybiBtaW5TZWdMZW5cbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlTbmFwcGVyXG59O1xuR2VvbWV0cnlTbmFwcGVyLnNuYXAgPSBmdW5jdGlvbiBzbmFwIChnMCwgZzEsIHNuYXBUb2xlcmFuY2UpIHtcbiAgdmFyIHNuYXBHZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHZhciBzbmFwcGVyMCA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZzApO1xuICBzbmFwR2VvbVswXSA9IHNuYXBwZXIwLnNuYXBUbyhnMSwgc25hcFRvbGVyYW5jZSk7XG4gIHZhciBzbmFwcGVyMSA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZzEpO1xuICBzbmFwR2VvbVsxXSA9IHNuYXBwZXIxLnNuYXBUbyhzbmFwR2VvbVswXSwgc25hcFRvbGVyYW5jZSk7XG4gIHJldHVybiBzbmFwR2VvbVxufTtcbkdlb21ldHJ5U25hcHBlci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzbmFwVG9sZXJhbmNlID0gR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcpO1xuICAgIHZhciBwbSA9IGcuZ2V0UHJlY2lzaW9uTW9kZWwoKTtcbiAgICBpZiAocG0uZ2V0VHlwZSgpID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgdmFyIGZpeGVkU25hcFRvbCA9IDEgLyBwbS5nZXRTY2FsZSgpICogMiAvIDEuNDE1O1xuICAgICAgaWYgKGZpeGVkU25hcFRvbCA+IHNuYXBUb2xlcmFuY2UpIHsgc25hcFRvbGVyYW5jZSA9IGZpeGVkU25hcFRvbDsgfVxuICAgIH1cbiAgICByZXR1cm4gc25hcFRvbGVyYW5jZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiBNYXRoLm1pbihHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKGcwKSwgR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShnMSkpXG4gIH1cbn07XG5HZW9tZXRyeVNuYXBwZXIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSAoZykge1xuICB2YXIgZW52ID0gZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihlbnYuZ2V0SGVpZ2h0KCksIGVudi5nZXRXaWR0aCgpKTtcbiAgdmFyIHNuYXBUb2wgPSBtaW5EaW1lbnNpb24gKiBHZW9tZXRyeVNuYXBwZXIuU05BUF9QUkVDSVNJT05fRkFDVE9SO1xuICByZXR1cm4gc25hcFRvbFxufTtcbkdlb21ldHJ5U25hcHBlci5zbmFwVG9TZWxmID0gZnVuY3Rpb24gc25hcFRvU2VsZiAoZ2VvbSwgc25hcFRvbGVyYW5jZSwgY2xlYW5SZXN1bHQpIHtcbiAgdmFyIHNuYXBwZXIwID0gbmV3IEdlb21ldHJ5U25hcHBlcihnZW9tKTtcbiAgcmV0dXJuIHNuYXBwZXIwLnNuYXBUb1NlbGYoc25hcFRvbGVyYW5jZSwgY2xlYW5SZXN1bHQpXG59O1xuc3RhdGljQWNjZXNzb3JzJDQxLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxZS05IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeVNuYXBwZXIsIHN0YXRpY0FjY2Vzc29ycyQ0MSApO1xuXG52YXIgU25hcFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChHZW9tZXRyeVRyYW5zZm9ybWVyJCQxKSB7XG4gIGZ1bmN0aW9uIFNuYXBUcmFuc2Zvcm1lciAoc25hcFRvbGVyYW5jZSwgc25hcFB0cywgaXNTZWxmU25hcCkge1xuICAgIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gc25hcFRvbGVyYW5jZSB8fCBudWxsO1xuICAgIHRoaXMuX3NuYXBQdHMgPSBzbmFwUHRzIHx8IG51bGw7XG4gICAgdGhpcy5faXNTZWxmU25hcCA9IChpc1NlbGZTbmFwICE9PSB1bmRlZmluZWQpID8gaXNTZWxmU25hcCA6IGZhbHNlO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxICkgU25hcFRyYW5zZm9ybWVyLl9fcHJvdG9fXyA9IEdlb21ldHJ5VHJhbnNmb3JtZXIkJDE7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxICYmIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEucHJvdG90eXBlICk7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbmFwVHJhbnNmb3JtZXI7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuc25hcExpbmUgPSBmdW5jdGlvbiBzbmFwTGluZSAoc3JjUHRzLCBzbmFwUHRzKSB7XG4gICAgdmFyIHNuYXBwZXIgPSBuZXcgTGluZVN0cmluZ1NuYXBwZXIoc3JjUHRzLCB0aGlzLl9zbmFwVG9sZXJhbmNlKTtcbiAgICBzbmFwcGVyLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuX2lzU2VsZlNuYXApO1xuICAgIHJldHVybiBzbmFwcGVyLnNuYXBUbyhzbmFwUHRzKVxuICB9O1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gdHJhbnNmb3JtQ29vcmRpbmF0ZXMgKGNvb3JkcywgcGFyZW50KSB7XG4gICAgdmFyIHNyY1B0cyA9IGNvb3Jkcy50b0Nvb3JkaW5hdGVBcnJheSgpO1xuICAgIHZhciBuZXdQdHMgPSB0aGlzLnNuYXBMaW5lKHNyY1B0cywgdGhpcy5fc25hcFB0cyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShuZXdQdHMpXG4gIH07XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNuYXBUcmFuc2Zvcm1lclxuICB9O1xuXG4gIHJldHVybiBTbmFwVHJhbnNmb3JtZXI7XG59KEdlb21ldHJ5VHJhbnNmb3JtZXIpKTtcblxudmFyIENvbW1vbkJpdHMgPSBmdW5jdGlvbiBDb21tb25CaXRzICgpIHtcbiAgdGhpcy5faXNGaXJzdCA9IHRydWU7XG4gIHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50ID0gNTM7XG4gIHRoaXMuX2NvbW1vbkJpdHMgPSAwO1xuICB0aGlzLl9jb21tb25TaWduRXhwID0gbnVsbDtcbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5nZXRDb21tb24gPSBmdW5jdGlvbiBnZXRDb21tb24gKCkge1xuICByZXR1cm4gRG91YmxlLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cylcbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICB2YXIgbnVtQml0cyA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKG51bSk7XG4gIGlmICh0aGlzLl9pc0ZpcnN0KSB7XG4gICAgdGhpcy5fY29tbW9uQml0cyA9IG51bUJpdHM7XG4gICAgdGhpcy5fY29tbW9uU2lnbkV4cCA9IENvbW1vbkJpdHMuc2lnbkV4cEJpdHModGhpcy5fY29tbW9uQml0cyk7XG4gICAgdGhpcy5faXNGaXJzdCA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIG51bVNpZ25FeHAgPSBDb21tb25CaXRzLnNpZ25FeHBCaXRzKG51bUJpdHMpO1xuICBpZiAobnVtU2lnbkV4cCAhPT0gdGhpcy5fY29tbW9uU2lnbkV4cCkge1xuICAgIHRoaXMuX2NvbW1vbkJpdHMgPSAwO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQgPSBDb21tb25CaXRzLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5fY29tbW9uQml0cywgbnVtQml0cyk7XG4gIHRoaXMuX2NvbW1vbkJpdHMgPSBDb21tb25CaXRzLnplcm9Mb3dlckJpdHModGhpcy5fY29tbW9uQml0cywgNjQgLSAoMTIgKyB0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCkpO1xufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBiaXRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4ID0gRG91YmxlLmxvbmdCaXRzVG9Eb3VibGUoYml0cyk7XG4gICAgdmFyIG51bVN0ciA9IERvdWJsZS50b0JpbmFyeVN0cmluZyhiaXRzKTtcbiAgICB2YXIgcGFkU3RyID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICsgbnVtU3RyO1xuICAgIHZhciBiaXRTdHIgPSBwYWRTdHIuc3Vic3RyaW5nKHBhZFN0ci5sZW5ndGggLSA2NCk7XG4gICAgdmFyIHN0ciA9IGJpdFN0ci5zdWJzdHJpbmcoMCwgMSkgKyAnICAnICsgYml0U3RyLnN1YnN0cmluZygxLCAxMikgKyAnKGV4cCkgJyArIGJpdFN0ci5zdWJzdHJpbmcoMTIpICsgJyBbICcgKyB4ICsgJyBdJztcbiAgICByZXR1cm4gc3RyXG4gIH1cbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb21tb25CaXRzXG59O1xuQ29tbW9uQml0cy5nZXRCaXQgPSBmdW5jdGlvbiBnZXRCaXQgKGJpdHMsIGkpIHtcbiAgdmFyIG1hc2sgPSAxIDw8IGk7XG4gIHJldHVybiAoYml0cyAmIG1hc2spICE9PSAwID8gMSA6IDBcbn07XG5Db21tb25CaXRzLnNpZ25FeHBCaXRzID0gZnVuY3Rpb24gc2lnbkV4cEJpdHMgKG51bSkge1xuICByZXR1cm4gbnVtID4+IDUyXG59O1xuQ29tbW9uQml0cy56ZXJvTG93ZXJCaXRzID0gZnVuY3Rpb24gemVyb0xvd2VyQml0cyAoYml0cywgbkJpdHMpIHtcbiAgdmFyIGludk1hc2sgPSAoMSA8PCBuQml0cykgLSAxO1xuICB2YXIgbWFzayA9IH5pbnZNYXNrO1xuICB2YXIgemVyb2VkID0gYml0cyAmIG1hc2s7XG4gIHJldHVybiB6ZXJvZWRcbn07XG5Db21tb25CaXRzLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHMgPSBmdW5jdGlvbiBudW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzIChudW0xLCBudW0yKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSA1MjsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoQ29tbW9uQml0cy5nZXRCaXQobnVtMSwgaSkgIT09IENvbW1vbkJpdHMuZ2V0Qml0KG51bTIsIGkpKSB7IHJldHVybiBjb3VudCB9XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gNTJcbn07XG5cbnZhciBDb21tb25CaXRzUmVtb3ZlciA9IGZ1bmN0aW9uIENvbW1vbkJpdHNSZW1vdmVyICgpIHtcbiAgdGhpcy5fY29tbW9uQ29vcmQgPSBudWxsO1xuICB0aGlzLl9jY0ZpbHRlciA9IG5ldyBDb21tb25Db29yZGluYXRlRmlsdGVyKCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQyID0geyBDb21tb25Db29yZGluYXRlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRyYW5zbGF0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5hZGRDb21tb25CaXRzID0gZnVuY3Rpb24gYWRkQ29tbW9uQml0cyAoZ2VvbSkge1xuICB2YXIgdHJhbnMgPSBuZXcgVHJhbnNsYXRlcih0aGlzLl9jb21tb25Db29yZCk7XG4gIGdlb20uYXBwbHkodHJhbnMpO1xuICBnZW9tLmdlb21ldHJ5Q2hhbmdlZCgpO1xufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5yZW1vdmVDb21tb25CaXRzID0gZnVuY3Rpb24gcmVtb3ZlQ29tbW9uQml0cyAoZ2VvbSkge1xuICBpZiAodGhpcy5fY29tbW9uQ29vcmQueCA9PT0gMC4wICYmIHRoaXMuX2NvbW1vbkNvb3JkLnkgPT09IDAuMCkgeyByZXR1cm4gZ2VvbSB9XG4gIHZhciBpbnZDb29yZCA9IG5ldyBDb29yZGluYXRlKHRoaXMuX2NvbW1vbkNvb3JkKTtcbiAgaW52Q29vcmQueCA9IC1pbnZDb29yZC54O1xuICBpbnZDb29yZC55ID0gLWludkNvb3JkLnk7XG4gIHZhciB0cmFucyA9IG5ldyBUcmFuc2xhdGVyKGludkNvb3JkKTtcbiAgZ2VvbS5hcHBseSh0cmFucyk7XG4gIGdlb20uZ2VvbWV0cnlDaGFuZ2VkKCk7XG4gIHJldHVybiBnZW9tXG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmdldENvbW1vbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb21tb25Db29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkXG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZ2VvbSkge1xuICBnZW9tLmFwcGx5KHRoaXMuX2NjRmlsdGVyKTtcbiAgdGhpcy5fY29tbW9uQ29vcmQgPSB0aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCk7XG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb21tb25CaXRzUmVtb3ZlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0Mi5Db21tb25Db29yZGluYXRlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0Mi5UcmFuc2xhdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRyYW5zbGF0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvbW1vbkJpdHNSZW1vdmVyLCBzdGF0aWNBY2Nlc3NvcnMkNDIgKTtcblxudmFyIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIgPSBmdW5jdGlvbiBDb21tb25Db29yZGluYXRlRmlsdGVyICgpIHtcbiAgdGhpcy5fY29tbW9uQml0c1ggPSBuZXcgQ29tbW9uQml0cygpO1xuICB0aGlzLl9jb21tb25CaXRzWSA9IG5ldyBDb21tb25CaXRzKCk7XG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChjb29yZCkge1xuICB0aGlzLl9jb21tb25CaXRzWC5hZGQoY29vcmQueCk7XG4gIHRoaXMuX2NvbW1vbkJpdHNZLmFkZChjb29yZC55KTtcbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRDb21tb25Db29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29tbW9uQ29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSwgdGhpcy5fY29tbW9uQml0c1kuZ2V0Q29tbW9uKCkpXG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZUZpbHRlcl1cbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXJcbn07XG5cbnZhciBUcmFuc2xhdGVyID0gZnVuY3Rpb24gVHJhbnNsYXRlciAoKSB7XG4gIHRoaXMudHJhbnMgPSBudWxsO1xuICB2YXIgdHJhbnMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMudHJhbnMgPSB0cmFucztcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaSkge1xuICB2YXIgeHAgPSBzZXEuZ2V0T3JkaW5hdGUoaSwgMCkgKyB0aGlzLnRyYW5zLng7XG4gIHZhciB5cCA9IHNlcS5nZXRPcmRpbmF0ZShpLCAxKSArIHRoaXMudHJhbnMueTtcbiAgc2VxLnNldE9yZGluYXRlKGksIDAsIHhwKTtcbiAgc2VxLnNldE9yZGluYXRlKGksIDEsIHlwKTtcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgcmV0dXJuIHRydWVcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJdXG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUcmFuc2xhdGVyXG59O1xuXG52YXIgU25hcE92ZXJsYXlPcCA9IGZ1bmN0aW9uIFNuYXBPdmVybGF5T3AgKGcxLCBnMikge1xuICB0aGlzLl9nZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBudWxsO1xuICB0aGlzLl9jYnIgPSBudWxsO1xuICB0aGlzLl9nZW9tWzBdID0gZzE7XG4gIHRoaXMuX2dlb21bMV0gPSBnMjtcbiAgdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpO1xufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnNlbGZTbmFwID0gZnVuY3Rpb24gc2VsZlNuYXAgKGdlb20pIHtcbiAgdmFyIHNuYXBwZXIwID0gbmV3IEdlb21ldHJ5U25hcHBlcihnZW9tKTtcbiAgdmFyIHNuYXBHZW9tID0gc25hcHBlcjAuc25hcFRvKGdlb20sIHRoaXMuX3NuYXBUb2xlcmFuY2UpO1xuICByZXR1cm4gc25hcEdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5yZW1vdmVDb21tb25CaXRzID0gZnVuY3Rpb24gcmVtb3ZlQ29tbW9uQml0cyAoZ2VvbSkge1xuICB0aGlzLl9jYnIgPSBuZXcgQ29tbW9uQml0c1JlbW92ZXIoKTtcbiAgdGhpcy5fY2JyLmFkZChnZW9tWzBdKTtcbiAgdGhpcy5fY2JyLmFkZChnZW9tWzFdKTtcbiAgdmFyIHJlbUdlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgcmVtR2VvbVswXSA9IHRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKGdlb21bMF0uY29weSgpKTtcbiAgcmVtR2VvbVsxXSA9IHRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKGdlb21bMV0uY29weSgpKTtcbiAgcmV0dXJuIHJlbUdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5wcmVwYXJlUmVzdWx0ID0gZnVuY3Rpb24gcHJlcGFyZVJlc3VsdCAoZ2VvbSkge1xuICB0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyhnZW9tKTtcbiAgcmV0dXJuIGdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChvcENvZGUpIHtcbiAgdmFyIHByZXBHZW9tID0gdGhpcy5zbmFwKHRoaXMuX2dlb20pO1xuICB2YXIgcmVzdWx0ID0gT3ZlcmxheU9wLm92ZXJsYXlPcChwcmVwR2VvbVswXSwgcHJlcEdlb21bMV0sIG9wQ29kZSk7XG4gIHJldHVybiB0aGlzLnByZXBhcmVSZXN1bHQocmVzdWx0KVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkIChnKSB7XG4gIGlmICghZy5pc1ZhbGlkKCkpIHtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ1NuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZCcpO1xuICB9XG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZVNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlU25hcFRvbGVyYW5jZSAoKSB7XG4gIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuX2dlb21bMF0sIHRoaXMuX2dlb21bMV0pO1xufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbiBzbmFwIChnZW9tKSB7XG4gIHZhciByZW1HZW9tID0gdGhpcy5yZW1vdmVDb21tb25CaXRzKGdlb20pO1xuICB2YXIgc25hcEdlb20gPSBHZW9tZXRyeVNuYXBwZXIuc25hcChyZW1HZW9tWzBdLCByZW1HZW9tWzFdLCB0aGlzLl9zbmFwVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHNuYXBHZW9tXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcFxufTtcblNuYXBPdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gb3ZlcmxheU9wIChnMCwgZzEsIG9wQ29kZSkge1xuICB2YXIgb3AgPSBuZXcgU25hcE92ZXJsYXlPcChnMCwgZzEpO1xuICByZXR1cm4gb3AuZ2V0UmVzdWx0R2VvbWV0cnkob3BDb2RlKVxufTtcblNuYXBPdmVybGF5T3AudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5VTklPTilcbn07XG5TbmFwT3ZlcmxheU9wLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pXG59O1xuU25hcE92ZXJsYXlPcC5zeW1EaWZmZXJlbmNlID0gZnVuY3Rpb24gc3ltRGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFKVxufTtcblNuYXBPdmVybGF5T3AuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5cbnZhciBTbmFwSWZOZWVkZWRPdmVybGF5T3AgPSBmdW5jdGlvbiBTbmFwSWZOZWVkZWRPdmVybGF5T3AgKGcxLCBnMikge1xuICB0aGlzLl9nZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2dlb21bMF0gPSBnMTtcbiAgdGhpcy5fZ2VvbVsxXSA9IGcyO1xufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRSZXN1bHRHZW9tZXRyeSAob3BDb2RlKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgaXNTdWNjZXNzID0gZmFsc2U7XG4gIHZhciBzYXZlZEV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gT3ZlcmxheU9wLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLCB0aGlzLl9nZW9tWzFdLCBvcENvZGUpO1xuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICBpZiAoaXNWYWxpZCkgeyBpc1N1Y2Nlc3MgPSB0cnVlOyB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgUnVudGltZUV4Y2VwdGlvbikge1xuICAgICAgc2F2ZWRFeGNlcHRpb24gPSBleDtcbiAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxuICBpZiAoIWlzU3VjY2Vzcykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLCB0aGlzLl9nZW9tWzFdLCBvcENvZGUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBSdW50aW1lRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IHNhdmVkRXhjZXB0aW9uXG4gICAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gICAgfSBmaW5hbGx5IHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Bcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gb3ZlcmxheU9wIChnMCwgZzEsIG9wQ29kZSkge1xuICB2YXIgb3AgPSBuZXcgU25hcElmTmVlZGVkT3ZlcmxheU9wKGcwLCBnMSk7XG4gIHJldHVybiBvcC5nZXRSZXN1bHRHZW9tZXRyeShvcENvZGUpXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKGcwLCBnMSkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5VTklPTilcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuSU5URVJTRUNUSU9OKVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5zeW1EaWZmZXJlbmNlID0gZnVuY3Rpb24gc3ltRGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UpXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiBkaWZmZXJlbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5cbnZhciBNb25vdG9uZUNoYWluJDIgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluICgpIHtcbiAgdGhpcy5tY2UgPSBudWxsO1xuICB0aGlzLmNoYWluSW5kZXggPSBudWxsO1xuICB2YXIgbWNlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgY2hhaW5JbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5tY2UgPSBtY2U7XG4gIHRoaXMuY2hhaW5JbmRleCA9IGNoYWluSW5kZXg7XG59O1xuTW9ub3RvbmVDaGFpbiQyLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25zIChtYywgc2kpIHtcbiAgdGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsIG1jLm1jZSwgbWMuY2hhaW5JbmRleCwgc2kpO1xufTtcbk1vbm90b25lQ2hhaW4kMi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW4kMi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluJDJcbn07XG5cbnZhciBTd2VlcExpbmVFdmVudCA9IGZ1bmN0aW9uIFN3ZWVwTGluZUV2ZW50ICgpIHtcbiAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICB0aGlzLl94VmFsdWUgPSBudWxsO1xuICB0aGlzLl9ldmVudFR5cGUgPSBudWxsO1xuICB0aGlzLl9pbnNlcnRFdmVudCA9IG51bGw7XG4gIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXggPSBudWxsO1xuICB0aGlzLl9vYmogPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpbnNlcnRFdmVudCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9ldmVudFR5cGUgPSBTd2VlcExpbmVFdmVudC5ERUxFVEU7XG4gICAgdGhpcy5feFZhbHVlID0geDtcbiAgICB0aGlzLl9pbnNlcnRFdmVudCA9IGluc2VydEV2ZW50O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2V2ZW50VHlwZSA9IFN3ZWVwTGluZUV2ZW50LklOU0VSVDtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMuX3hWYWx1ZSA9IHgkMTtcbiAgICB0aGlzLl9vYmogPSBvYmo7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDMgPSB7IElOU0VSVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUxFVEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pc0RlbGV0ZSA9IGZ1bmN0aW9uIGlzRGVsZXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50VHlwZSA9PT0gU3dlZXBMaW5lRXZlbnQuREVMRVRFXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLnNldERlbGV0ZUV2ZW50SW5kZXggPSBmdW5jdGlvbiBzZXREZWxldGVFdmVudEluZGV4IChkZWxldGVFdmVudEluZGV4KSB7XG4gIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXggPSBkZWxldGVFdmVudEluZGV4O1xufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXRPYmplY3QgPSBmdW5jdGlvbiBnZXRPYmplY3QgKCkge1xuICByZXR1cm4gdGhpcy5fb2JqXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgcGUgPSBvO1xuICBpZiAodGhpcy5feFZhbHVlIDwgcGUuX3hWYWx1ZSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5feFZhbHVlID4gcGUuX3hWYWx1ZSkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9ldmVudFR5cGUgPCBwZS5fZXZlbnRUeXBlKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9ldmVudFR5cGUgPiBwZS5fZXZlbnRUeXBlKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuZ2V0SW5zZXJ0RXZlbnQgPSBmdW5jdGlvbiBnZXRJbnNlcnRFdmVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnNlcnRFdmVudFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pc0luc2VydCA9IGZ1bmN0aW9uIGlzSW5zZXJ0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50VHlwZSA9PT0gU3dlZXBMaW5lRXZlbnQuSU5TRVJUXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmlzU2FtZUxhYmVsID0gZnVuY3Rpb24gaXNTYW1lTGFiZWwgKGV2KSB7XG4gIGlmICh0aGlzLl9sYWJlbCA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5fbGFiZWwgPT09IGV2Ll9sYWJlbFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXREZWxldGVFdmVudEluZGV4ID0gZnVuY3Rpb24gZ2V0RGVsZXRlRXZlbnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLl9kZWxldGVFdmVudEluZGV4XG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3dlZXBMaW5lRXZlbnRcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDMuSU5TRVJULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0My5ERUxFVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3dlZXBMaW5lRXZlbnQsIHN0YXRpY0FjY2Vzc29ycyQ0MyApO1xuXG52YXIgRWRnZVNldEludGVyc2VjdG9yID0gZnVuY3Rpb24gRWRnZVNldEludGVyc2VjdG9yICgpIHt9O1xuXG5FZGdlU2V0SW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlU2V0SW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZVNldEludGVyc2VjdG9yXG59O1xuXG52YXIgU2VnbWVudEludGVyc2VjdG9yJDIgPSBmdW5jdGlvbiBTZWdtZW50SW50ZXJzZWN0b3IgKCkge1xuICB0aGlzLl9oYXNJbnRlcnNlY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5faGFzUHJvcGVyID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gZmFsc2U7XG4gIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50ID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pbmNsdWRlUHJvcGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjb3JkSXNvbGF0ZWQgPSBudWxsO1xuICB0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb24gPSBudWxsO1xuICB0aGlzLl9udW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1UZXN0cyA9IDA7XG4gIHRoaXMuX2JkeU5vZGVzID0gbnVsbDtcbiAgdGhpcy5faXNEb25lID0gZmFsc2U7XG4gIHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQgPSBmYWxzZTtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB2YXIgaW5jbHVkZVByb3BlciA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHJlY29yZElzb2xhdGVkID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9saSA9IGxpO1xuICB0aGlzLl9pbmNsdWRlUHJvcGVyID0gaW5jbHVkZVByb3BlcjtcbiAgdGhpcy5fcmVjb3JkSXNvbGF0ZWQgPSByZWNvcmRJc29sYXRlZDtcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNUcml2aWFsSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNUcml2aWFsSW50ZXJzZWN0aW9uIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmIChlMCA9PT0gZTEpIHtcbiAgICBpZiAodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkgPT09IDEpIHtcbiAgICAgIGlmIChTZWdtZW50SW50ZXJzZWN0b3IkMi5pc0FkamFjZW50U2VnbWVudHMoc2VnSW5kZXgwLCBzZWdJbmRleDEpKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChlMC5pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHZhciBtYXhTZWdJbmRleCA9IGUwLmdldE51bVBvaW50cygpIC0gMTtcbiAgICAgICAgaWYgKChzZWdJbmRleDAgPT09IDAgJiYgc2VnSW5kZXgxID09PSBtYXhTZWdJbmRleCkgfHxcbiAgICAgICAgICAgIChzZWdJbmRleDEgPT09IDAgJiYgc2VnSW5kZXgwID09PSBtYXhTZWdJbmRleCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFByb3BlckludGVyc2VjdGlvblBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLnNldElzRG9uZUlmUHJvcGVySW50ID0gZnVuY3Rpb24gc2V0SXNEb25lSWZQcm9wZXJJbnQgKGlzRG9uZVdoZW5Qcm9wZXJJbnQpIHtcbiAgdGhpcy5faXNEb25lV2hlblByb3BlckludCA9IGlzRG9uZVdoZW5Qcm9wZXJJbnQ7XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3Jcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCAobGksIGJkeU5vZGVzKSB7XG4gIGZvciAodmFyIGkgPSBiZHlOb2Rlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IGkubmV4dCgpO1xuICAgIHZhciBwdCA9IG5vZGUuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgIGlmIChsaS5pc0ludGVyc2VjdGlvbihwdCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5oYXNQcm9wZXJJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNQcm9wZXJJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVyXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmhhc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb25cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRG9uZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pc0JvdW5kYXJ5UG9pbnQgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5UG9pbnQgKGxpLCBiZHlOb2Rlcykge1xuICBpZiAoYmR5Tm9kZXMgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKHRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwobGksIGJkeU5vZGVzWzBdKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKGxpLCBiZHlOb2Rlc1sxXSkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuc2V0Qm91bmRhcnlOb2RlcyA9IGZ1bmN0aW9uIHNldEJvdW5kYXJ5Tm9kZXMgKGJkeU5vZGVzMCwgYmR5Tm9kZXMxKSB7XG4gIHRoaXMuX2JkeU5vZGVzID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2JkeU5vZGVzWzBdID0gYmR5Tm9kZXMwO1xuICB0aGlzLl9iZHlOb2Rlc1sxXSA9IGJkeU5vZGVzMTtcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMubnVtVGVzdHMrKztcbiAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIGlmICh0aGlzLl9yZWNvcmRJc29sYXRlZCkge1xuICAgICAgZTAuc2V0SXNvbGF0ZWQoZmFsc2UpO1xuICAgICAgZTEuc2V0SXNvbGF0ZWQoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLl9udW1JbnRlcnNlY3Rpb25zKys7XG4gICAgaWYgKCF0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbihlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSkge1xuICAgICAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9pbmNsdWRlUHJvcGVyIHx8ICF0aGlzLl9saS5pc1Byb3BlcigpKSB7XG4gICAgICAgIGUwLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MCwgMCk7XG4gICAgICAgIGUxLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkge1xuICAgICAgICB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCk7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlciA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50KSB7XG4gICAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMuX2xpLCB0aGlzLl9iZHlOb2RlcykpIHsgdGhpcy5faGFzUHJvcGVySW50ZXJpb3IgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50SW50ZXJzZWN0b3IkMlxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLmlzQWRqYWNlbnRTZWdtZW50cyA9IGZ1bmN0aW9uIGlzQWRqYWNlbnRTZWdtZW50cyAoaTEsIGkyKSB7XG4gIHJldHVybiBNYXRoLmFicyhpMSAtIGkyKSA9PT0gMVxufTtcblxudmFyIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IgPSAoZnVuY3Rpb24gKEVkZ2VTZXRJbnRlcnNlY3RvciQkMSkge1xuICBmdW5jdGlvbiBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yICgpIHtcbiAgICBFZGdlU2V0SW50ZXJzZWN0b3IkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLm5PdmVybGFwcyA9IG51bGw7XG4gIH1cblxuICBpZiAoIEVkZ2VTZXRJbnRlcnNlY3RvciQkMSApIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IuX19wcm90b19fID0gRWRnZVNldEludGVyc2VjdG9yJCQxO1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VTZXRJbnRlcnNlY3RvciQkMSAmJiBFZGdlU2V0SW50ZXJzZWN0b3IkJDEucHJvdG90eXBlICk7XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvcjtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJlcGFyZUV2ZW50cyA9IGZ1bmN0aW9uIHByZXBhcmVFdmVudHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgQ29sbGVjdGlvbnMuc29ydCh0aGlzLmV2ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5zaXplKCk7IGkrKykge1xuICAgICAgdmFyIGV2ID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICBpZiAoZXYuaXNEZWxldGUoKSkge1xuICAgICAgICBldi5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2kgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLm5PdmVybGFwcyA9IDA7XG4gICAgICB0aGlzLnByZXBhcmVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICAgIGlmIChldi5pc0luc2VydCgpKSB7XG4gICAgICAgICAgdGhpcyQxLnByb2Nlc3NPdmVybGFwcyhpLCBldi5nZXREZWxldGVFdmVudEluZGV4KCksIGV2LCBzaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpLmlzRG9uZSgpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFNlZ21lbnRJbnRlcnNlY3RvciQyICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBMaXN0KSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBMaXN0KSkpIHtcbiAgICAgICAgdmFyIGVkZ2VzMCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGVkZ2VzMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHNpJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHRoaXMuYWRkRWRnZXMoZWRnZXMwLCBlZGdlczApO1xuICAgICAgICB0aGlzLmFkZEVkZ2VzKGVkZ2VzMSwgZWRnZXMxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzaSQxKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBMaXN0KSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBTZWdtZW50SW50ZXJzZWN0b3IkMikpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgc2kkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHRlc3RBbGxTZWdtZW50cyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKHRlc3RBbGxTZWdtZW50cykgeyB0aGlzLmFkZEVkZ2VzKGVkZ2VzLCBudWxsKTsgfSBlbHNlIHsgdGhpcy5hZGRFZGdlcyhlZGdlcyk7IH1cbiAgICAgICAgdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzaSQyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbiBhZGRFZGdlIChlZGdlLCBlZGdlU2V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbWNlID0gZWRnZS5nZXRNb25vdG9uZUNoYWluRWRnZSgpO1xuICAgIHZhciBzdGFydEluZGV4ID0gbWNlLmdldFN0YXJ0SW5kZXhlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRJbmRleC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtYyA9IG5ldyBNb25vdG9uZUNoYWluJDIobWNlLCBpKTtcbiAgICAgIHZhciBpbnNlcnRFdmVudCA9IG5ldyBTd2VlcExpbmVFdmVudChlZGdlU2V0LCBtY2UuZ2V0TWluWChpKSwgbWMpO1xuICAgICAgdGhpcyQxLmV2ZW50cy5hZGQoaW5zZXJ0RXZlbnQpO1xuICAgICAgdGhpcyQxLmV2ZW50cy5hZGQobmV3IFN3ZWVwTGluZUV2ZW50KG1jZS5nZXRNYXhYKGkpLCBpbnNlcnRFdmVudCkpO1xuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJvY2Vzc092ZXJsYXBzID0gZnVuY3Rpb24gcHJvY2Vzc092ZXJsYXBzIChzdGFydCwgZW5kLCBldjAsIHNpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbWMwID0gZXYwLmdldE9iamVjdCgpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZXYxID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICBpZiAoZXYxLmlzSW5zZXJ0KCkpIHtcbiAgICAgICAgdmFyIG1jMSA9IGV2MS5nZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKCFldjAuaXNTYW1lTGFiZWwoZXYxKSkge1xuICAgICAgICAgIG1jMC5jb21wdXRlSW50ZXJzZWN0aW9ucyhtYzEsIHNpKTtcbiAgICAgICAgICB0aGlzJDEubk92ZXJsYXBzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmFkZEVkZ2VzID0gZnVuY3Rpb24gYWRkRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBlZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSBlZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBpLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmFkZEVkZ2UoZWRnZSwgZWRnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZWRnZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBlZGdlU2V0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgZm9yICh2YXIgaSQxID0gZWRnZXMkMS5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZWRnZSQxID0gaSQxLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmFkZEVkZ2UoZWRnZSQxLCBlZGdlU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvclxuICB9O1xuXG4gIHJldHVybiBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yO1xufShFZGdlU2V0SW50ZXJzZWN0b3IpKTtcblxudmFyIEludGVydmFsUlRyZWVOb2RlID0gZnVuY3Rpb24gSW50ZXJ2YWxSVHJlZU5vZGUgKCkge1xuICB0aGlzLl9taW4gPSBEb3VibGUuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHRoaXMuX21heCA9IERvdWJsZS5ORUdBVElWRV9JTkZJTklUWTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDUgPSB7IE5vZGVDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuZ2V0TWluID0gZnVuY3Rpb24gZ2V0TWluICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pblxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAocXVlcnlNaW4sIHF1ZXJ5TWF4KSB7XG4gIGlmICh0aGlzLl9taW4gPiBxdWVyeU1heCB8fCB0aGlzLl9tYXggPCBxdWVyeU1pbikgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5nZXRNYXggPSBmdW5jdGlvbiBnZXRNYXggKCkge1xuICByZXR1cm4gdGhpcy5fbWF4XG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyhuZXcgQ29vcmRpbmF0ZSh0aGlzLl9taW4sIDApLCBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXgsIDApKVxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJ2YWxSVHJlZU5vZGVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDUuTm9kZUNvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTm9kZUNvbXBhcmF0b3IgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEludGVydmFsUlRyZWVOb2RlLCBzdGF0aWNBY2Nlc3NvcnMkNDUgKTtcblxudmFyIE5vZGVDb21wYXJhdG9yID0gZnVuY3Rpb24gTm9kZUNvbXBhcmF0b3IgKCkge307XG5cbk5vZGVDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBuMSA9IG8xO1xuICB2YXIgbjIgPSBvMjtcbiAgdmFyIG1pZDEgPSAobjEuX21pbiArIG4xLl9tYXgpIC8gMjtcbiAgdmFyIG1pZDIgPSAobjIuX21pbiArIG4yLl9tYXgpIC8gMjtcbiAgaWYgKG1pZDEgPCBtaWQyKSB7IHJldHVybiAtMSB9XG4gIGlmIChtaWQxID4gbWlkMikgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuTm9kZUNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmF0b3JdXG59O1xuTm9kZUNvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZUNvbXBhcmF0b3Jcbn07XG5cbnZhciBJbnRlcnZhbFJUcmVlTGVhZk5vZGUgPSAoZnVuY3Rpb24gKEludGVydmFsUlRyZWVOb2RlJCQxKSB7XG4gIGZ1bmN0aW9uIEludGVydmFsUlRyZWVMZWFmTm9kZSAoKSB7XG4gICAgSW50ZXJ2YWxSVHJlZU5vZGUkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICB2YXIgbWluID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fbWluID0gbWluO1xuICAgIHRoaXMuX21heCA9IG1heDtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuXG4gIGlmICggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgKSBJbnRlcnZhbFJUcmVlTGVhZk5vZGUuX19wcm90b19fID0gSW50ZXJ2YWxSVHJlZU5vZGUkJDE7XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcnZhbFJUcmVlTm9kZSQkMSAmJiBJbnRlcnZhbFJUcmVlTm9kZSQkMS5wcm90b3R5cGUgKTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVydmFsUlRyZWVMZWFmTm9kZTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhxdWVyeU1pbiwgcXVlcnlNYXgpKSB7IHJldHVybiBudWxsIH1cbiAgICB2aXNpdG9yLnZpc2l0SXRlbSh0aGlzLl9pdGVtKTtcbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWxSVHJlZUxlYWZOb2RlXG4gIH07XG5cbiAgcmV0dXJuIEludGVydmFsUlRyZWVMZWFmTm9kZTtcbn0oSW50ZXJ2YWxSVHJlZU5vZGUpKTtcblxudmFyIEludGVydmFsUlRyZWVCcmFuY2hOb2RlID0gKGZ1bmN0aW9uIChJbnRlcnZhbFJUcmVlTm9kZSQkMSkge1xuICBmdW5jdGlvbiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZSAoKSB7XG4gICAgSW50ZXJ2YWxSVHJlZU5vZGUkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9ub2RlMSA9IG51bGw7XG4gICAgdGhpcy5fbm9kZTIgPSBudWxsO1xuICAgIHZhciBuMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbjIgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbm9kZTEgPSBuMTtcbiAgICB0aGlzLl9ub2RlMiA9IG4yO1xuICAgIHRoaXMuYnVpbGRFeHRlbnQodGhpcy5fbm9kZTEsIHRoaXMuX25vZGUyKTtcbiAgfVxuXG4gIGlmICggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgKSBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5fX3Byb3RvX18gPSBJbnRlcnZhbFJUcmVlTm9kZSQkMTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgJiYgSW50ZXJ2YWxSVHJlZU5vZGUkJDEucHJvdG90eXBlICk7XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVydmFsUlRyZWVCcmFuY2hOb2RlO1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUuYnVpbGRFeHRlbnQgPSBmdW5jdGlvbiBidWlsZEV4dGVudCAobjEsIG4yKSB7XG4gICAgdGhpcy5fbWluID0gTWF0aC5taW4objEuX21pbiwgbjIuX21pbik7XG4gICAgdGhpcy5fbWF4ID0gTWF0aC5tYXgobjEuX21heCwgbjIuX21heCk7XG4gIH07XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhxdWVyeU1pbiwgcXVlcnlNYXgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5fbm9kZTEgIT09IG51bGwpIHsgdGhpcy5fbm9kZTEucXVlcnkocXVlcnlNaW4sIHF1ZXJ5TWF4LCB2aXNpdG9yKTsgfVxuICAgIGlmICh0aGlzLl9ub2RlMiAhPT0gbnVsbCkgeyB0aGlzLl9ub2RlMi5xdWVyeShxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpOyB9XG4gIH07XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZVxuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZTtcbn0oSW50ZXJ2YWxSVHJlZU5vZGUpKTtcblxudmFyIFNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUgPSBmdW5jdGlvbiBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlICgpIHtcbiAgdGhpcy5fbGVhdmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5fbGV2ZWwgPSAwO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmJ1aWxkVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkVHJlZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgQ29sbGVjdGlvbnMuc29ydCh0aGlzLl9sZWF2ZXMsIG5ldyBJbnRlcnZhbFJUcmVlTm9kZS5Ob2RlQ29tcGFyYXRvcigpKTtcbiAgdmFyIHNyYyA9IHRoaXMuX2xlYXZlcztcbiAgdmFyIHRlbXAgPSBudWxsO1xuICB2YXIgZGVzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0aGlzJDEuYnVpbGRMZXZlbChzcmMsIGRlc3QpO1xuICAgIGlmIChkZXN0LnNpemUoKSA9PT0gMSkgeyByZXR1cm4gZGVzdC5nZXQoMCkgfVxuICAgIHRlbXAgPSBzcmM7XG4gICAgc3JjID0gZGVzdDtcbiAgICBkZXN0ID0gdGVtcDtcbiAgfVxufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAobWluLCBtYXgsIGl0ZW0pIHtcbiAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkJykgfVxuICB0aGlzLl9sZWF2ZXMuYWRkKG5ldyBJbnRlcnZhbFJUcmVlTGVhZk5vZGUobWluLCBtYXgsIGl0ZW0pKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChtaW4sIG1heCwgdmlzaXRvcikge1xuICB0aGlzLmluaXQoKTtcbiAgdGhpcy5fcm9vdC5xdWVyeShtaW4sIG1heCwgdmlzaXRvcik7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuYnVpbGRSb290ID0gZnVuY3Rpb24gYnVpbGRSb290ICgpIHtcbiAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9yb290ID0gdGhpcy5idWlsZFRyZWUoKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5wcmludE5vZGUgPSBmdW5jdGlvbiBwcmludE5vZGUgKG5vZGUpIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGUobm9kZS5fbWluLCB0aGlzLl9sZXZlbCksIG5ldyBDb29yZGluYXRlKG5vZGUuX21heCwgdGhpcy5fbGV2ZWwpKSk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuYnVpbGRSb290KCk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuYnVpbGRMZXZlbCA9IGZ1bmN0aW9uIGJ1aWxkTGV2ZWwgKHNyYywgZGVzdCkge1xuICB0aGlzLl9sZXZlbCsrO1xuICBkZXN0LmNsZWFyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjLnNpemUoKTsgaSArPSAyKSB7XG4gICAgdmFyIG4xID0gc3JjLmdldChpKTtcbiAgICB2YXIgbjIgPSBpICsgMSA8IHNyYy5zaXplKCkgPyBzcmMuZ2V0KGkpIDogbnVsbDtcbiAgICBpZiAobjIgPT09IG51bGwpIHtcbiAgICAgIGRlc3QuYWRkKG4xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUoc3JjLmdldChpKSwgc3JjLmdldChpICsgMSkpO1xuICAgICAgZGVzdC5hZGQobm9kZSk7XG4gICAgfVxuICB9XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZVxufTtcblxudmFyIEFycmF5TGlzdFZpc2l0b3IgPSBmdW5jdGlvbiBBcnJheUxpc3RWaXNpdG9yICgpIHtcbiAgdGhpcy5faXRlbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJdGVtID0gZnVuY3Rpb24gdmlzaXRJdGVtIChpdGVtKSB7XG4gIHRoaXMuX2l0ZW1zLmFkZChpdGVtKTtcbn07XG5BcnJheUxpc3RWaXNpdG9yLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uIGdldEl0ZW1zICgpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW1zXG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbSXRlbVZpc2l0b3JdXG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBcnJheUxpc3RWaXNpdG9yXG59O1xuXG52YXIgSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciA9IGZ1bmN0aW9uIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IgKCkge1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG4gIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICBpZiAoIWhhc0ludGVyZmFjZShnLCBQb2x5Z29uYWwpKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0FyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsJykgfVxuICB0aGlzLl9pbmRleCA9IG5ldyBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeShnKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDQgPSB7IFNlZ21lbnRWaXNpdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEludGVydmFsSW5kZXhlZEdlb21ldHJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5JbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHApIHtcbiAgdmFyIHJjYyA9IG5ldyBSYXlDcm9zc2luZ0NvdW50ZXIocCk7XG4gIHZhciB2aXNpdG9yID0gbmV3IFNlZ21lbnRWaXNpdG9yKHJjYyk7XG4gIHRoaXMuX2luZGV4LnF1ZXJ5KHAueSwgcC55LCB2aXNpdG9yKTtcbiAgcmV0dXJuIHJjYy5nZXRMb2NhdGlvbigpXG59O1xuSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbUG9pbnRPbkdlb21ldHJ5TG9jYXRvcl1cbn07XG5JbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDQuU2VnbWVudFZpc2l0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VnbWVudFZpc2l0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0NC5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciwgc3RhdGljQWNjZXNzb3JzJDQ0ICk7XG5cbnZhciBTZWdtZW50VmlzaXRvciA9IGZ1bmN0aW9uIFNlZ21lbnRWaXNpdG9yICgpIHtcbiAgdGhpcy5fY291bnRlciA9IG51bGw7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9jb3VudGVyID0gY291bnRlcjtcbn07XG5TZWdtZW50VmlzaXRvci5wcm90b3R5cGUudmlzaXRJdGVtID0gZnVuY3Rpb24gdmlzaXRJdGVtIChpdGVtKSB7XG4gIHZhciBzZWcgPSBpdGVtO1xuICB0aGlzLl9jb3VudGVyLmNvdW50U2VnbWVudChzZWcuZ2V0Q29vcmRpbmF0ZSgwKSwgc2VnLmdldENvb3JkaW5hdGUoMSkpO1xufTtcblNlZ21lbnRWaXNpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtJdGVtVmlzaXRvcl1cbn07XG5TZWdtZW50VmlzaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50VmlzaXRvclxufTtcblxudmFyIEludGVydmFsSW5kZXhlZEdlb21ldHJ5ID0gZnVuY3Rpb24gSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkgKCkge1xuICB0aGlzLl9pbmRleCA9IG5ldyBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlKCk7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLmluaXQoZ2VvbSk7XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChnZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGxpbmVzID0gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGdlb20pO1xuICBmb3IgKHZhciBpID0gbGluZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGxpbmUgPSBpLm5leHQoKTtcbiAgICB2YXIgcHRzID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgIHRoaXMkMS5hZGRMaW5lKHB0cyk7XG4gIH1cbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uIGFkZExpbmUgKHB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZyA9IG5ldyBMaW5lU2VnbWVudChwdHNbaSAtIDFdLCBwdHNbaV0pO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihzZWcucDAueSwgc2VnLnAxLnkpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChzZWcucDAueSwgc2VnLnAxLnkpO1xuICAgIHRoaXMkMS5faW5kZXguaW5zZXJ0KG1pbiwgbWF4LCBzZWcpO1xuICB9XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBBcnJheUxpc3RWaXNpdG9yKCk7XG4gICAgdGhpcy5faW5kZXgucXVlcnkobWluLCBtYXgsIHZpc2l0b3IpO1xuICAgIHJldHVybiB2aXNpdG9yLmdldEl0ZW1zKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIG1pbiQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdmlzaXRvciQxID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2luZGV4LnF1ZXJ5KG1pbiQxLCBtYXgkMSwgdmlzaXRvciQxKTtcbiAgfVxufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnlcbn07XG5cbnZhciBHZW9tZXRyeUdyYXBoID0gKGZ1bmN0aW9uIChQbGFuYXJHcmFwaCQkMSkge1xuICBmdW5jdGlvbiBHZW9tZXRyeUdyYXBoICgpIHtcbiAgICBQbGFuYXJHcmFwaCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3BhcmVudEdlb20gPSBudWxsO1xuICAgIHRoaXMuX2xpbmVFZGdlTWFwID0gbmV3IEhhc2hNYXAoKTtcbiAgICB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlID0gbnVsbDtcbiAgICB0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9hcmdJbmRleCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRhcnlOb2RlcyA9IG51bGw7XG4gICAgdGhpcy5faGFzVG9vRmV3UG9pbnRzID0gZmFsc2U7XG4gICAgdGhpcy5faW52YWxpZFBvaW50ID0gbnVsbDtcbiAgICB0aGlzLl9hcmVhUHRMb2NhdG9yID0gbnVsbDtcbiAgICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwYXJlbnRHZW9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGJvdW5kYXJ5Tm9kZVJ1bGUgPSBCb3VuZGFyeU5vZGVSdWxlLk9HQ19TRlNfQk9VTkRBUllfUlVMRTtcbiAgICAgIHRoaXMuX2FyZ0luZGV4ID0gYXJnSW5kZXg7XG4gICAgICB0aGlzLl9wYXJlbnRHZW9tID0gcGFyZW50R2VvbTtcbiAgICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUgPSBib3VuZGFyeU5vZGVSdWxlO1xuICAgICAgaWYgKHBhcmVudEdlb20gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hZGQocGFyZW50R2VvbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgYXJnSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwYXJlbnRHZW9tJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgYm91bmRhcnlOb2RlUnVsZSQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdGhpcy5fYXJnSW5kZXggPSBhcmdJbmRleCQxO1xuICAgICAgdGhpcy5fcGFyZW50R2VvbSA9IHBhcmVudEdlb20kMTtcbiAgICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUgPSBib3VuZGFyeU5vZGVSdWxlJDE7XG4gICAgICBpZiAocGFyZW50R2VvbSQxICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYWRkKHBhcmVudEdlb20kMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCBQbGFuYXJHcmFwaCQkMSApIEdlb21ldHJ5R3JhcGguX19wcm90b19fID0gUGxhbmFyR3JhcGgkJDE7XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUGxhbmFyR3JhcGgkJDEgJiYgUGxhbmFyR3JhcGgkJDEucHJvdG90eXBlICk7XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnlHcmFwaDtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaW5zZXJ0Qm91bmRhcnlQb2ludCA9IGZ1bmN0aW9uIGluc2VydEJvdW5kYXJ5UG9pbnQgKGFyZ0luZGV4LCBjb29yZCkge1xuICAgIHZhciBuID0gdGhpcy5fbm9kZXMuYWRkTm9kZShjb29yZCk7XG4gICAgdmFyIGxibCA9IG4uZ2V0TGFiZWwoKTtcbiAgICB2YXIgYm91bmRhcnlDb3VudCA9IDE7XG4gICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgbG9jID0gbGJsLmdldExvY2F0aW9uKGFyZ0luZGV4LCBQb3NpdGlvbi5PTik7XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgYm91bmRhcnlDb3VudCsrOyB9XG4gICAgdmFyIG5ld0xvYyA9IEdlb21ldHJ5R3JhcGguZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5fYm91bmRhcnlOb2RlUnVsZSwgYm91bmRhcnlDb3VudCk7XG4gICAgbGJsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBuZXdMb2MpO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jb21wdXRlU2VsZk5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZVNlbGZOb2RlcyAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wdXRlUmluZ1NlbGZOb2RlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXMobGksIGNvbXB1dGVSaW5nU2VsZk5vZGVzLCBmYWxzZSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBsaSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXB1dGVSaW5nU2VsZk5vZGVzJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgaXNEb25lSWZQcm9wZXJJbnQgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgc2kgPSBuZXcgU2VnbWVudEludGVyc2VjdG9yJDIobGkkMSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgc2kuc2V0SXNEb25lSWZQcm9wZXJJbnQoaXNEb25lSWZQcm9wZXJJbnQpO1xuICAgICAgdmFyIGVzaSA9IHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCk7XG4gICAgICB2YXIgaXNSaW5ncyA9IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nIHx8IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBQb2x5Z29uIHx8IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBNdWx0aVBvbHlnb247XG4gICAgICB2YXIgY29tcHV0ZUFsbFNlZ21lbnRzID0gY29tcHV0ZVJpbmdTZWxmTm9kZXMkMSB8fCAhaXNSaW5ncztcbiAgICAgIGVzaS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcywgc2ksIGNvbXB1dGVBbGxTZWdtZW50cyk7XG4gICAgICB0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCk7XG4gICAgICByZXR1cm4gc2lcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbXB1dGVTcGxpdEVkZ2VzID0gZnVuY3Rpb24gY29tcHV0ZVNwbGl0RWRnZXMgKGVkZ2VsaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgIGUuZWlMaXN0LmFkZFNwbGl0RWRnZXMoZWRnZWxpc3QpO1xuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zIChnLCBsaSwgaW5jbHVkZVByb3Blcikge1xuICAgIHZhciBzaSA9IG5ldyBTZWdtZW50SW50ZXJzZWN0b3IkMihsaSwgaW5jbHVkZVByb3BlciwgdHJ1ZSk7XG4gICAgc2kuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSwgZy5nZXRCb3VuZGFyeU5vZGVzKCkpO1xuICAgIHZhciBlc2kgPSB0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpO1xuICAgIGVzaS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcywgZy5fZWRnZXMsIHNpKTtcbiAgICByZXR1cm4gc2lcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEdlb21cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmhhc1Rvb0Zld1BvaW50cyA9IGZ1bmN0aW9uIGhhc1Rvb0Zld1BvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvb3JkID0gcC5nZXRDb29yZGluYXRlKCk7XG4gICAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZCwgTG9jYXRpb24uSU5URVJJT1IpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHB0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgcHQsIExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbiBhZGRQb2x5Z29uIChwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmFkZFBvbHlnb25SaW5nKHAuZ2V0RXh0ZXJpb3JSaW5nKCksIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICAgIHZhciBob2xlID0gcC5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgICAgdGhpcyQxLmFkZFBvbHlnb25SaW5nKGhvbGUsIExvY2F0aW9uLklOVEVSSU9SLCBMb2NhdGlvbi5FWFRFUklPUik7XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRFZGdlID0gZnVuY3Rpb24gYWRkRWRnZSAoZSkge1xuICAgIHRoaXMuaW5zZXJ0RWRnZShlKTtcbiAgICB2YXIgY29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbMF0sIExvY2F0aW9uLkJPVU5EQVJZKTtcbiAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFtjb29yZC5sZW5ndGggLSAxXSwgTG9jYXRpb24uQk9VTkRBUlkpO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRMaW5lU3RyaW5nID0gZnVuY3Rpb24gYWRkTGluZVN0cmluZyAobGluZSkge1xuICAgIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobGluZS5nZXRDb29yZGluYXRlcygpKTtcbiAgICBpZiAoY29vcmQubGVuZ3RoIDwgMikge1xuICAgICAgdGhpcy5faGFzVG9vRmV3UG9pbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ludmFsaWRQb2ludCA9IGNvb3JkWzBdO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGUgPSBuZXcgRWRnZShjb29yZCwgbmV3IExhYmVsKHRoaXMuX2FyZ0luZGV4LCBMb2NhdGlvbi5JTlRFUklPUikpO1xuICAgIHRoaXMuX2xpbmVFZGdlTWFwLnB1dChsaW5lLCBlKTtcbiAgICB0aGlzLmluc2VydEVkZ2UoZSk7XG4gICAgQXNzZXJ0LmlzVHJ1ZShjb29yZC5sZW5ndGggPj0gMiwgJ2ZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnQnKTtcbiAgICB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkWzBdKTtcbiAgICB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkW2Nvb3JkLmxlbmd0aCAtIDFdKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0SW52YWxpZFBvaW50ID0gZnVuY3Rpb24gZ2V0SW52YWxpZFBvaW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZFBvaW50XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEJvdW5kYXJ5UG9pbnRzID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlQb2ludHMgKCkge1xuICAgIHZhciBjb2xsID0gdGhpcy5nZXRCb3VuZGFyeU5vZGVzKCk7XG4gICAgdmFyIHB0cyA9IG5ldyBBcnJheShjb2xsLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIgaXQgPSBjb2xsLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gaXQubmV4dCgpO1xuICAgICAgcHRzW2krK10gPSBub2RlLmdldENvb3JkaW5hdGUoKS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBwdHNcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlOb2RlcyA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5Tm9kZXMgKCkge1xuICAgIGlmICh0aGlzLl9ib3VuZGFyeU5vZGVzID09PSBudWxsKSB7IHRoaXMuX2JvdW5kYXJ5Tm9kZXMgPSB0aGlzLl9ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuX2FyZ0luZGV4KTsgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVzXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlID0gZnVuY3Rpb24gYWRkU2VsZkludGVyc2VjdGlvbk5vZGUgKGFyZ0luZGV4LCBjb29yZCwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaXNCb3VuZGFyeU5vZGUoYXJnSW5kZXgsIGNvb3JkKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkgJiYgdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZSkgeyB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQoYXJnSW5kZXgsIGNvb3JkKTsgfSBlbHNlIHsgdGhpcy5pbnNlcnRQb2ludChhcmdJbmRleCwgY29vcmQsIGxvYyk7IH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkUG9seWdvblJpbmcgPSBmdW5jdGlvbiBhZGRQb2x5Z29uUmluZyAobHIsIGN3TGVmdCwgY3dSaWdodCkge1xuICAgIGlmIChsci5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobHIuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgaWYgKGNvb3JkLmxlbmd0aCA8IDQpIHtcbiAgICAgIHRoaXMuX2hhc1Rvb0Zld1BvaW50cyA9IHRydWU7XG4gICAgICB0aGlzLl9pbnZhbGlkUG9pbnQgPSBjb29yZFswXTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBsZWZ0ID0gY3dMZWZ0O1xuICAgIHZhciByaWdodCA9IGN3UmlnaHQ7XG4gICAgaWYgKENHQWxnb3JpdGhtcy5pc0NDVyhjb29yZCkpIHtcbiAgICAgIGxlZnQgPSBjd1JpZ2h0O1xuICAgICAgcmlnaHQgPSBjd0xlZnQ7XG4gICAgfVxuICAgIHZhciBlID0gbmV3IEVkZ2UoY29vcmQsIG5ldyBMYWJlbCh0aGlzLl9hcmdJbmRleCwgTG9jYXRpb24uQk9VTkRBUlksIGxlZnQsIHJpZ2h0KSk7XG4gICAgdGhpcy5fbGluZUVkZ2VNYXAucHV0KGxyLCBlKTtcbiAgICB0aGlzLmluc2VydEVkZ2UoZSk7XG4gICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbMF0sIExvY2F0aW9uLkJPVU5EQVJZKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaW5zZXJ0UG9pbnQgPSBmdW5jdGlvbiBpbnNlcnRQb2ludCAoYXJnSW5kZXgsIGNvb3JkLCBvbkxvY2F0aW9uKSB7XG4gICAgdmFyIG4gPSB0aGlzLl9ub2Rlcy5hZGROb2RlKGNvb3JkKTtcbiAgICB2YXIgbGJsID0gbi5nZXRMYWJlbCgpO1xuICAgIGlmIChsYmwgPT09IG51bGwpIHtcbiAgICAgIG4uX2xhYmVsID0gbmV3IExhYmVsKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTtcbiAgICB9IGVsc2UgeyBsYmwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG9uTG9jYXRpb24pOyB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvciAoKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yKClcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzID0gZnVuY3Rpb24gYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzIChhcmdJbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBlTG9jID0gZS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGFyZ0luZGV4KTtcbiAgICAgIGZvciAodmFyIGVpSXQgPSBlLmVpTGlzdC5pdGVyYXRvcigpOyBlaUl0Lmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGVpID0gZWlJdC5uZXh0KCk7XG4gICAgICAgIHRoaXMkMS5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZShhcmdJbmRleCwgZWkuY29vcmQsIGVMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZSA9IGZhbHNlOyB9XG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIFBvbHlnb24pIHsgdGhpcy5hZGRQb2x5Z29uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLmFkZExpbmVTdHJpbmcoZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBQb2ludCkgeyB0aGlzLmFkZFBvaW50KGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2ludCkgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoZy5nZXRDbGFzcygpLmdldE5hbWUoKSkgfVxuICAgIH0gZWxzZSB7IHJldHVybiBQbGFuYXJHcmFwaCQkMS5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRDb2xsZWN0aW9uID0gZnVuY3Rpb24gYWRkQ29sbGVjdGlvbiAoZ2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkpO1xuICAgICAgdGhpcyQxLmFkZChnKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocHQpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKHRoaXMuX3BhcmVudEdlb20sIFBvbHlnb25hbCkgJiYgdGhpcy5fcGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCkgPiA1MCkge1xuICAgICAgaWYgKHRoaXMuX2FyZWFQdExvY2F0b3IgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYXJlYVB0TG9jYXRvciA9IG5ldyBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yKHRoaXMuX3BhcmVudEdlb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FyZWFQdExvY2F0b3IubG9jYXRlKHB0KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShwdCwgdGhpcy5fcGFyZW50R2VvbSlcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZmluZEVkZ2UgPSBmdW5jdGlvbiBmaW5kRWRnZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuX2xpbmVFZGdlTWFwLmdldChsaW5lKVxuICAgIH0gZWxzZSB7IHJldHVybiBQbGFuYXJHcmFwaCQkMS5wcm90b3R5cGUuZmluZEVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlHcmFwaFxuICB9O1xuICBHZW9tZXRyeUdyYXBoLmRldGVybWluZUJvdW5kYXJ5ID0gZnVuY3Rpb24gZGV0ZXJtaW5lQm91bmRhcnkgKGJvdW5kYXJ5Tm9kZVJ1bGUsIGJvdW5kYXJ5Q291bnQpIHtcbiAgICByZXR1cm4gYm91bmRhcnlOb2RlUnVsZS5pc0luQm91bmRhcnkoYm91bmRhcnlDb3VudCkgPyBMb2NhdGlvbi5CT1VOREFSWSA6IExvY2F0aW9uLklOVEVSSU9SXG4gIH07XG5cbiAgcmV0dXJuIEdlb21ldHJ5R3JhcGg7XG59KFBsYW5hckdyYXBoKSk7XG5cbnZhciBHZW9tZXRyeUdyYXBoT3AgPSBmdW5jdGlvbiBHZW9tZXRyeUdyYXBoT3AgKCkge1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9hcmcgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcwLmdldFByZWNpc2lvbk1vZGVsKCkpO1xuICAgIHRoaXMuX2FyZyA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICAgIHRoaXMuX2FyZ1swXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDAsIGcwKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3VuZGFyeU5vZGVSdWxlID0gQm91bmRhcnlOb2RlUnVsZS5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU7XG4gICAgaWYgKGcwJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZzEuZ2V0UHJlY2lzaW9uTW9kZWwoKSkgPj0gMCkgeyB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcwJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH0gZWxzZSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzEuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH1cbiAgICB0aGlzLl9hcmcgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLl9hcmdbMF0gPSBuZXcgR2VvbWV0cnlHcmFwaCgwLCBnMCQxLCBib3VuZGFyeU5vZGVSdWxlKTtcbiAgICB0aGlzLl9hcmdbMV0gPSBuZXcgR2VvbWV0cnlHcmFwaCgxLCBnMSwgYm91bmRhcnlOb2RlUnVsZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3VuZGFyeU5vZGVSdWxlJDEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGcwJDIuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZzEkMS5nZXRQcmVjaXNpb25Nb2RlbCgpKSA+PSAwKSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzAkMi5nZXRQcmVjaXNpb25Nb2RlbCgpKTsgfSBlbHNlIHsgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMSQxLmdldFByZWNpc2lvbk1vZGVsKCkpOyB9XG4gICAgdGhpcy5fYXJnID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5fYXJnWzBdID0gbmV3IEdlb21ldHJ5R3JhcGgoMCwgZzAkMiwgYm91bmRhcnlOb2RlUnVsZSQxKTtcbiAgICB0aGlzLl9hcmdbMV0gPSBuZXcgR2VvbWV0cnlHcmFwaCgxLCBnMSQxLCBib3VuZGFyeU5vZGVSdWxlJDEpO1xuICB9XG59O1xuR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZS5nZXRBcmdHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEFyZ0dlb21ldHJ5IChpKSB7XG4gIHJldHVybiB0aGlzLl9hcmdbaV0uZ2V0R2VvbWV0cnkoKVxufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24gPSBmdW5jdGlvbiBzZXRDb21wdXRhdGlvblByZWNpc2lvbiAocG0pIHtcbiAgdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwgPSBwbTtcbiAgdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwpO1xufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUdyYXBoT3Bcbn07XG5cbi8vIG9wZXJhdGlvbi5nZW9tZXRyeWdyYXBoXG5cbnZhciBHZW9tZXRyeU1hcHBlciA9IGZ1bmN0aW9uIEdlb21ldHJ5TWFwcGVyICgpIHt9O1xuXG5HZW9tZXRyeU1hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5TWFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5TWFwcGVyXG59O1xuR2VvbWV0cnlNYXBwZXIubWFwID0gZnVuY3Rpb24gbWFwICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIEdlb21ldHJ5TWFwcGVyLk1hcE9wKSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGVkID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgICAgdmFyIGcgPSBvcC5tYXAoZ2VvbS5nZXRHZW9tZXRyeU4oaSkpO1xuICAgICAgaWYgKGcgIT09IG51bGwpIHsgbWFwcGVkLmFkZChnKTsgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShtYXBwZWQpXG4gIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgR2VvbWV0cnlNYXBwZXIuTWFwT3ApKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwZWQkMSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpJDEgPSBnZW9tcy5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGckMSA9IGkkMS5uZXh0KCk7XG4gICAgICB2YXIgZ3IgPSBvcCQxLm1hcChnJDEpO1xuICAgICAgaWYgKGdyICE9PSBudWxsKSB7IG1hcHBlZCQxLmFkZChncik7IH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZCQxXG4gIH1cbn07XG5HZW9tZXRyeU1hcHBlci5NYXBPcCA9IGZ1bmN0aW9uIE1hcE9wICgpIHt9O1xuXG52YXIgT3ZlcmxheU9wID0gKGZ1bmN0aW9uIChHZW9tZXRyeUdyYXBoT3ApIHtcbiAgZnVuY3Rpb24gT3ZlcmxheU9wICgpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIEdlb21ldHJ5R3JhcGhPcC5jYWxsKHRoaXMsIGcwLCBnMSk7XG4gICAgdGhpcy5fcHRMb2NhdG9yID0gbmV3IFBvaW50TG9jYXRvcigpO1xuICAgIHRoaXMuX2dlb21GYWN0ID0gbnVsbDtcbiAgICB0aGlzLl9yZXN1bHRHZW9tID0gbnVsbDtcbiAgICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZUxpc3QgPSBuZXcgRWRnZUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRQb2x5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRMaW5lTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRQb2ludExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5fZ3JhcGggPSBuZXcgUGxhbmFyR3JhcGgobmV3IE92ZXJsYXlOb2RlRmFjdG9yeSgpKTtcbiAgICB0aGlzLl9nZW9tRmFjdCA9IGcwLmdldEZhY3RvcnkoKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlHcmFwaE9wICkgT3ZlcmxheU9wLl9fcHJvdG9fXyA9IEdlb21ldHJ5R3JhcGhPcDtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5R3JhcGhPcCAmJiBHZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlICk7XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPdmVybGF5T3A7XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaW5zZXJ0VW5pcXVlRWRnZSA9IGZ1bmN0aW9uIGluc2VydFVuaXF1ZUVkZ2UgKGUpIHtcbiAgICB2YXIgZXhpc3RpbmdFZGdlID0gdGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZShlKTtcbiAgICBpZiAoZXhpc3RpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhpc3RpbmdMYWJlbCA9IGV4aXN0aW5nRWRnZS5nZXRMYWJlbCgpO1xuICAgICAgdmFyIGxhYmVsVG9NZXJnZSA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIGlmICghZXhpc3RpbmdFZGdlLmlzUG9pbnR3aXNlRXF1YWwoZSkpIHtcbiAgICAgICAgbGFiZWxUb01lcmdlID0gbmV3IExhYmVsKGUuZ2V0TGFiZWwoKSk7XG4gICAgICAgIGxhYmVsVG9NZXJnZS5mbGlwKCk7XG4gICAgICB9XG4gICAgICB2YXIgZGVwdGggPSBleGlzdGluZ0VkZ2UuZ2V0RGVwdGgoKTtcbiAgICAgIGlmIChkZXB0aC5pc051bGwoKSkge1xuICAgICAgICBkZXB0aC5hZGQoZXhpc3RpbmdMYWJlbCk7XG4gICAgICB9XG4gICAgICBkZXB0aC5hZGQobGFiZWxUb01lcmdlKTtcbiAgICAgIGV4aXN0aW5nTGFiZWwubWVyZ2UobGFiZWxUb01lcmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZWRnZUxpc3QuYWRkKGUpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRHcmFwaCA9IGZ1bmN0aW9uIGdldEdyYXBoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcyA9IGZ1bmN0aW9uIGNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSAmJiBzeW0uaXNJblJlc3VsdCgpKSB7XG4gICAgICAgIGRlLnNldEluUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgc3ltLnNldEluUmVzdWx0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaXNDb3ZlcmVkQnlMQSA9IGZ1bmN0aW9uIGlzQ292ZXJlZEJ5TEEgKGNvb3JkKSB7XG4gICAgaWYgKHRoaXMuaXNDb3ZlcmVkKGNvb3JkLCB0aGlzLl9yZXN1bHRMaW5lTGlzdCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmICh0aGlzLmlzQ292ZXJlZChjb29yZCwgdGhpcy5fcmVzdWx0UG9seUxpc3QpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlR2VvbWV0cnkgPSBmdW5jdGlvbiBjb21wdXRlR2VvbWV0cnkgKHJlc3VsdFBvaW50TGlzdCwgcmVzdWx0TGluZUxpc3QsIHJlc3VsdFBvbHlMaXN0LCBvcGNvZGUpIHtcbiAgICB2YXIgZ2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZ2VvbUxpc3QuYWRkQWxsKHJlc3VsdFBvaW50TGlzdCk7XG4gICAgZ2VvbUxpc3QuYWRkQWxsKHJlc3VsdExpbmVMaXN0KTtcbiAgICBnZW9tTGlzdC5hZGRBbGwocmVzdWx0UG9seUxpc3QpO1xuICAgIGlmIChnZW9tTGlzdC5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChvcGNvZGUsIHRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLCB0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKSwgdGhpcy5fZ2VvbUZhY3QpIH1cbiAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShnZW9tTGlzdClcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5tZXJnZVN5bUxhYmVscyA9IGZ1bmN0aW9uIG1lcmdlU3ltTGFiZWxzICgpIHtcbiAgICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgICBub2RlLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaXNDb3ZlcmVkID0gZnVuY3Rpb24gaXNDb3ZlcmVkIChjb29yZCwgZ2VvbUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGl0ID0gZ2VvbUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGdlb20gPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbG9jID0gdGhpcyQxLl9wdExvY2F0b3IubG9jYXRlKGNvb3JkLCBnZW9tKTtcbiAgICAgIGlmIChsb2MgIT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUucmVwbGFjZUNvbGxhcHNlZEVkZ2VzID0gZnVuY3Rpb24gcmVwbGFjZUNvbGxhcHNlZEVkZ2VzICgpIHtcbiAgICB2YXIgbmV3RWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICAgIGlmIChlLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgaXQucmVtb3ZlKCk7XG4gICAgICAgIG5ld0VkZ2VzLmFkZChlLmdldENvbGxhcHNlZEVkZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VkZ2VMaXN0LmFkZEFsbChuZXdFZGdlcyk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUudXBkYXRlTm9kZUxhYmVsbGluZyA9IGZ1bmN0aW9uIHVwZGF0ZU5vZGVMYWJlbGxpbmcgKCkge1xuICAgIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICAgIHZhciBsYmwgPSBub2RlLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtcbiAgICAgIG5vZGUuZ2V0TGFiZWwoKS5tZXJnZShsYmwpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChvdmVybGF5T3BDb2RlKSB7XG4gICAgdGhpcy5jb21wdXRlT3ZlcmxheShvdmVybGF5T3BDb2RlKTtcbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0R2VvbVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmluc2VydFVuaXF1ZUVkZ2VzID0gZnVuY3Rpb24gaW5zZXJ0VW5pcXVlRWRnZXMgKGVkZ2VzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGkubmV4dCgpO1xuICAgICAgdGhpcyQxLmluc2VydFVuaXF1ZUVkZ2UoZSk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVPdmVybGF5ID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXkgKG9wQ29kZSkge1xuICAgIHRoaXMuY29weVBvaW50cygwKTtcbiAgICB0aGlzLmNvcHlQb2ludHMoMSk7XG4gICAgdGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksIGZhbHNlKTtcbiAgICB0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwgZmFsc2UpO1xuICAgIHRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLCB0aGlzLl9saSwgdHJ1ZSk7XG4gICAgdmFyIGJhc2VTcGxpdEVkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX2FyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhiYXNlU3BsaXRFZGdlcyk7XG4gICAgdGhpcy5fYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGJhc2VTcGxpdEVkZ2VzKTtcbiAgICAvLyBjb25zdCBzcGxpdEVkZ2VzID0gYmFzZVNwbGl0RWRnZXNcbiAgICB0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGJhc2VTcGxpdEVkZ2VzKTtcbiAgICB0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCk7XG4gICAgdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKTtcbiAgICBFZGdlTm9kaW5nVmFsaWRhdG9yLmNoZWNrVmFsaWQodGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gICAgdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gICAgdGhpcy5jb21wdXRlTGFiZWxsaW5nKCk7XG4gICAgdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpO1xuICAgIHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyhvcENvZGUpO1xuICAgIHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTtcbiAgICB2YXIgcG9seUJ1aWxkZXIgPSBuZXcgUG9seWdvbkJ1aWxkZXIodGhpcy5fZ2VvbUZhY3QpO1xuICAgIHBvbHlCdWlsZGVyLmFkZCh0aGlzLl9ncmFwaCk7XG4gICAgdGhpcy5fcmVzdWx0UG9seUxpc3QgPSBwb2x5QnVpbGRlci5nZXRQb2x5Z29ucygpO1xuICAgIHZhciBsaW5lQnVpbGRlciA9IG5ldyBMaW5lQnVpbGRlcih0aGlzLCB0aGlzLl9nZW9tRmFjdCwgdGhpcy5fcHRMb2NhdG9yKTtcbiAgICB0aGlzLl9yZXN1bHRMaW5lTGlzdCA9IGxpbmVCdWlsZGVyLmJ1aWxkKG9wQ29kZSk7XG4gICAgdmFyIHBvaW50QnVpbGRlciA9IG5ldyBQb2ludEJ1aWxkZXIodGhpcywgdGhpcy5fZ2VvbUZhY3QsIHRoaXMuX3B0TG9jYXRvcik7XG4gICAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0ID0gcG9pbnRCdWlsZGVyLmJ1aWxkKG9wQ29kZSk7XG4gICAgdGhpcy5fcmVzdWx0R2VvbSA9IHRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMuX3Jlc3VsdFBvaW50TGlzdCwgdGhpcy5fcmVzdWx0TGluZUxpc3QsIHRoaXMuX3Jlc3VsdFBvbHlMaXN0LCBvcENvZGUpO1xuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmxhYmVsSW5jb21wbGV0ZU5vZGUgPSBmdW5jdGlvbiBsYWJlbEluY29tcGxldGVOb2RlIChuLCB0YXJnZXRJbmRleCkge1xuICAgIHZhciBsb2MgPSB0aGlzLl9wdExvY2F0b3IubG9jYXRlKG4uZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLl9hcmdbdGFyZ2V0SW5kZXhdLmdldEdlb21ldHJ5KCkpO1xuICAgIG4uZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbih0YXJnZXRJbmRleCwgbG9jKTtcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb3B5UG9pbnRzID0gZnVuY3Rpb24gY29weVBvaW50cyAoYXJnSW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9hcmdbYXJnSW5kZXhdLmdldE5vZGVJdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBncmFwaE5vZGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBuZXdOb2RlID0gdGhpcyQxLl9ncmFwaC5hZGROb2RlKGdyYXBoTm9kZS5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgbmV3Tm9kZS5zZXRMYWJlbChhcmdJbmRleCwgZ3JhcGhOb2RlLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oYXJnSW5kZXgpKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZmluZFJlc3VsdEFyZWFFZGdlcyA9IGZ1bmN0aW9uIGZpbmRSZXN1bHRBcmVhRWRnZXMgKG9wQ29kZSkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgICAgaWYgKGxhYmVsLmlzQXJlYSgpICYmICFkZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSAmJiBPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uUklHSFQpLCBvcENvZGUpKSB7XG4gICAgICAgIGRlLnNldEluUmVzdWx0KHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlTGFiZWxzRnJvbURlcHRocyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxibCA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIHZhciBkZXB0aCA9IGUuZ2V0RGVwdGgoKTtcbiAgICAgIGlmICghZGVwdGguaXNOdWxsKCkpIHtcbiAgICAgICAgZGVwdGgubm9ybWFsaXplKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsYmwuaXNOdWxsKGkpICYmIGxibC5pc0FyZWEoKSAmJiAhZGVwdGguaXNOdWxsKGkpKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGguZ2V0RGVsdGEoaSkgPT09IDApIHtcbiAgICAgICAgICAgICAgbGJsLnRvTGluZShpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEFzc2VydC5pc1RydWUoIWRlcHRoLmlzTnVsbChpLCBQb3NpdGlvbi5MRUZUKSwgJ2RlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgICAgbGJsLnNldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQsIGRlcHRoLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQpKTtcbiAgICAgICAgICAgICAgQXNzZXJ0LmlzVHJ1ZSghZGVwdGguaXNOdWxsKGksIFBvc2l0aW9uLlJJR0hUKSwgJ2RlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgIGxibC5zZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5SSUdIVCwgZGVwdGguZ2V0TG9jYXRpb24oaSwgUG9zaXRpb24uUklHSFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbGxpbmcgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgICAgbm9kZS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcyQxLl9hcmcpO1xuICAgIH1cbiAgICB0aGlzLm1lcmdlU3ltTGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUubGFiZWxJbmNvbXBsZXRlTm9kZXMgPSBmdW5jdGlvbiBsYWJlbEluY29tcGxldGVOb2RlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvLyBsZXQgbm9kZUNvdW50ID0gMFxuICAgIGZvciAodmFyIG5pID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBuaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbiA9IG5pLm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IG4uZ2V0TGFiZWwoKTtcbiAgICAgIGlmIChuLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgICAvLyBub2RlQ291bnQrK1xuICAgICAgICBpZiAobGFiZWwuaXNOdWxsKDApKSB7IHRoaXMkMS5sYWJlbEluY29tcGxldGVOb2RlKG4sIDApOyB9IGVsc2UgeyB0aGlzJDEubGFiZWxJbmNvbXBsZXRlTm9kZShuLCAxKTsgfVxuICAgICAgfVxuICAgICAgbi5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhsYWJlbCk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmlzQ292ZXJlZEJ5QSA9IGZ1bmN0aW9uIGlzQ292ZXJlZEJ5QSAoY29vcmQpIHtcbiAgICBpZiAodGhpcy5pc0NvdmVyZWQoY29vcmQsIHRoaXMuX3Jlc3VsdFBvbHlMaXN0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE92ZXJsYXlPcFxuICB9O1xuXG4gIHJldHVybiBPdmVybGF5T3A7XG59KEdlb21ldHJ5R3JhcGhPcCkpO1xuXG5PdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gKGdlb20wLCBnZW9tMSwgb3BDb2RlKSB7XG4gIHZhciBnb3YgPSBuZXcgT3ZlcmxheU9wKGdlb20wLCBnZW9tMSk7XG4gIHZhciBnZW9tT3YgPSBnb3YuZ2V0UmVzdWx0R2VvbWV0cnkob3BDb2RlKTtcbiAgcmV0dXJuIGdlb21PdlxufTtcbk92ZXJsYXlPcC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpIHx8IG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04sIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICBpZiAoZy5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKSB7XG4gICAgdmFyIGcyID0gb3RoZXI7XG4gICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5tYXAoZywge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtHZW9tZXRyeU1hcHBlci5NYXBPcF1cbiAgICAgIH0sXG4gICAgICBtYXA6IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBnLmludGVyc2VjdGlvbihnMilcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLklOVEVSU0VDVElPTilcbn07XG5PdmVybGF5T3Auc3ltRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkgfHwgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgaWYgKGcuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFLCBnLCBvdGhlciwgZy5nZXRGYWN0b3J5KCkpIH1cbiAgICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG90aGVyLmNvcHkoKSB9XG4gICAgaWYgKG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gZy5jb3B5KCkgfVxuICB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UpXG59O1xuT3ZlcmxheU9wLnJlc3VsdERpbWVuc2lvbiA9IGZ1bmN0aW9uIChvcENvZGUsIGcwLCBnMSkge1xuICB2YXIgZGltMCA9IGcwLmdldERpbWVuc2lvbigpO1xuICB2YXIgZGltMSA9IGcxLmdldERpbWVuc2lvbigpO1xuICB2YXIgcmVzdWx0RGltZW5zaW9uID0gLTE7XG4gIHN3aXRjaCAob3BDb2RlKSB7XG4gICAgY2FzZSBPdmVybGF5T3AuSU5URVJTRUNUSU9OOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5taW4oZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgT3ZlcmxheU9wLlVOSU9OOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5tYXgoZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgT3ZlcmxheU9wLkRJRkZFUkVOQ0U6XG4gICAgICByZXN1bHREaW1lbnNpb24gPSBkaW0wO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5tYXgoZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgcmV0dXJuIHJlc3VsdERpbWVuc2lvblxufTtcbk92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdCA9IGZ1bmN0aW9uIChvdmVybGF5T3BDb2RlLCBhLCBiLCBnZW9tRmFjdCkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgc3dpdGNoIChPdmVybGF5T3AucmVzdWx0RGltZW5zaW9uKG92ZXJsYXlPcENvZGUsIGEsIGIpKSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgMDpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZVBvaW50KCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOlxuICAgICAgcmVzdWx0ID0gZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5PdmVybGF5T3AuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuRElGRkVSRU5DRSwgZywgb3RoZXIsIGcuZ2V0RmFjdG9yeSgpKSB9XG4gIGlmIChvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIGcuY29weSgpIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5PdmVybGF5T3AuaXNSZXN1bHRPZk9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3BDb2RlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2MwID0gbGFiZWwuZ2V0TG9jYXRpb24oMCk7XG4gICAgdmFyIGxvYzEgPSBsYWJlbC5nZXRMb2NhdGlvbigxKTtcbiAgICByZXR1cm4gT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsb2MwLCBsb2MxLCBvcENvZGUpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBsb2MwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvYzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb3ZlcmxheU9wQ29kZSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAobG9jMCQxID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBsb2MwJDEgPSBMb2NhdGlvbi5JTlRFUklPUjsgfVxuICAgIGlmIChsb2MxJDEgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGxvYzEkMSA9IExvY2F0aW9uLklOVEVSSU9SOyB9XG4gICAgc3dpdGNoIChvdmVybGF5T3BDb2RlKSB7XG4gICAgICBjYXNlIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT046XG4gICAgICAgIHJldHVybiBsb2MwJDEgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIGxvYzEkMSA9PT0gTG9jYXRpb24uSU5URVJJT1JcbiAgICAgIGNhc2UgT3ZlcmxheU9wLlVOSU9OOlxuICAgICAgICByZXR1cm4gbG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiB8fCBsb2MxJDEgPT09IExvY2F0aW9uLklOVEVSSU9SXG4gICAgICBjYXNlIE92ZXJsYXlPcC5ESUZGRVJFTkNFOlxuICAgICAgICByZXR1cm4gbG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBsb2MxJDEgIT09IExvY2F0aW9uLklOVEVSSU9SXG4gICAgICBjYXNlIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFOlxuICAgICAgICByZXR1cm4gKGxvYzAkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxICE9PSBMb2NhdGlvbi5JTlRFUklPUikgfHwgKGxvYzAkMSAhPT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxID09PSBMb2NhdGlvbi5JTlRFUklPUilcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuT3ZlcmxheU9wLklOVEVSU0VDVElPTiA9IDE7XG5PdmVybGF5T3AuVU5JT04gPSAyO1xuT3ZlcmxheU9wLkRJRkZFUkVOQ0UgPSAzO1xuT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UgPSA0O1xuXG52YXIgRnV6enlQb2ludExvY2F0b3IgPSBmdW5jdGlvbiBGdXp6eVBvaW50TG9jYXRvciAoKSB7XG4gIHRoaXMuX2cgPSBudWxsO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gbnVsbDtcbiAgdGhpcy5fbGluZXdvcmsgPSBudWxsO1xuICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gIHRoaXMuX3NlZyA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2cgPSBnO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZTtcbiAgdGhpcy5fbGluZXdvcmsgPSB0aGlzLmV4dHJhY3RMaW5ld29yayhnKTtcbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5IChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGluZXdvcmsuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5fbGluZXdvcmsuZ2V0R2VvbWV0cnlOKGkpO1xuICAgIHZhciBzZXEgPSBsaW5lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VxLnNpemUoKSAtIDE7IGorKykge1xuICAgICAgc2VxLmdldENvb3JkaW5hdGUoaiwgdGhpcyQxLl9zZWcucDApO1xuICAgICAgc2VxLmdldENvb3JkaW5hdGUoaiArIDEsIHRoaXMkMS5fc2VnLnAxKTtcbiAgICAgIHZhciBkaXN0ID0gdGhpcyQxLl9zZWcuZGlzdGFuY2UocHQpO1xuICAgICAgaWYgKGRpc3QgPD0gdGhpcyQxLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKHB0KSB7XG4gIGlmICh0aGlzLmlzV2l0aGluVG9sZXJhbmNlT2ZCb3VuZGFyeShwdCkpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgcmV0dXJuIHRoaXMuX3B0TG9jYXRvci5sb2NhdGUocHQsIHRoaXMuX2cpXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmV4dHJhY3RMaW5ld29yayA9IGZ1bmN0aW9uIGV4dHJhY3RMaW5ld29yayAoZykge1xuICB2YXIgZXh0cmFjdGVyID0gbmV3IFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyKCk7XG4gIGcuYXBwbHkoZXh0cmFjdGVyKTtcbiAgdmFyIGxpbmV3b3JrID0gZXh0cmFjdGVyLmdldExpbmV3b3JrKCk7XG4gIHZhciBsaW5lcyA9IEdlb21ldHJ5RmFjdG9yeS50b0xpbmVTdHJpbmdBcnJheShsaW5ld29yayk7XG4gIHJldHVybiBnLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobGluZXMpXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBGdXp6eVBvaW50TG9jYXRvclxufTtcblxudmFyIFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyID0gZnVuY3Rpb24gUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIgKCkge1xuICB0aGlzLl9saW5ld29yayA9IG51bGw7XG4gIHRoaXMuX2xpbmV3b3JrID0gbmV3IEFycmF5TGlzdCgpO1xufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRMaW5ld29yayA9IGZ1bmN0aW9uIGdldExpbmV3b3JrICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbmV3b3JrXG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHZhciBwb2x5ID0gZztcbiAgICB0aGlzLl9saW5ld29yay5hZGQocG9seS5nZXRFeHRlcmlvclJpbmcoKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICAgIHRoaXMkMS5fbGluZXdvcmsuYWRkKHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKSk7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RmlsdGVyXVxufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyXG59O1xuXG52YXIgT2Zmc2V0UG9pbnRHZW5lcmF0b3IgPSBmdW5jdGlvbiBPZmZzZXRQb2ludEdlbmVyYXRvciAoKSB7XG4gIHRoaXMuX2cgPSBudWxsO1xuICB0aGlzLl9kb0xlZnQgPSB0cnVlO1xuICB0aGlzLl9kb1JpZ2h0ID0gdHJ1ZTtcbiAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2cgPSBnO1xufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gZXh0cmFjdFBvaW50cyAobGluZSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBwdHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHRoaXMkMS5jb21wdXRlT2Zmc2V0UG9pbnRzKHB0c1tpXSwgcHRzW2kgKyAxXSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cyk7XG4gIH1cbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U2lkZXNUb0dlbmVyYXRlID0gZnVuY3Rpb24gc2V0U2lkZXNUb0dlbmVyYXRlIChkb0xlZnQsIGRvUmlnaHQpIHtcbiAgdGhpcy5fZG9MZWZ0ID0gZG9MZWZ0O1xuICB0aGlzLl9kb1JpZ2h0ID0gZG9SaWdodDtcbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzIChvZmZzZXREaXN0YW5jZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvZmZzZXRQdHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBsaW5lcyA9IExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyh0aGlzLl9nKTtcbiAgZm9yICh2YXIgaSA9IGxpbmVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBsaW5lID0gaS5uZXh0KCk7XG4gICAgdGhpcyQxLmV4dHJhY3RQb2ludHMobGluZSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cyk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFB0c1xufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5jb21wdXRlT2Zmc2V0UG9pbnRzID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldFBvaW50cyAocDAsIHAxLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0UHRzKSB7XG4gIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHZhciB1eCA9IG9mZnNldERpc3RhbmNlICogZHggLyBsZW47XG4gIHZhciB1eSA9IG9mZnNldERpc3RhbmNlICogZHkgLyBsZW47XG4gIHZhciBtaWRYID0gKHAxLnggKyBwMC54KSAvIDI7XG4gIHZhciBtaWRZID0gKHAxLnkgKyBwMC55KSAvIDI7XG4gIGlmICh0aGlzLl9kb0xlZnQpIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG5ldyBDb29yZGluYXRlKG1pZFggLSB1eSwgbWlkWSArIHV4KTtcbiAgICBvZmZzZXRQdHMuYWRkKG9mZnNldExlZnQpO1xuICB9XG4gIGlmICh0aGlzLl9kb1JpZ2h0KSB7XG4gICAgdmFyIG9mZnNldFJpZ2h0ID0gbmV3IENvb3JkaW5hdGUobWlkWCArIHV5LCBtaWRZIC0gdXgpO1xuICAgIG9mZnNldFB0cy5hZGQob2Zmc2V0UmlnaHQpO1xuICB9XG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRQb2ludEdlbmVyYXRvclxufTtcblxudmFyIE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IgPSBmdW5jdGlvbiBPdmVybGF5UmVzdWx0VmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHRoaXMuX2xvY0ZpbmRlciA9IG51bGw7XG4gIHRoaXMuX2xvY2F0aW9uID0gbmV3IEFycmF5KDMpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2ludmFsaWRMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBPdmVybGF5UmVzdWx0VmFsaWRhdG9yLlRPTEVSQU5DRTtcbiAgdGhpcy5fdGVzdENvb3JkcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5jb21wdXRlQm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZShhLCBiKTtcbiAgdGhpcy5fZ2VvbSA9IFthLCBiLCByZXN1bHRdO1xuICB0aGlzLl9sb2NGaW5kZXIgPSBbbmV3IEZ1enp5UG9pbnRMb2NhdG9yKHRoaXMuX2dlb21bMF0sIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpLCBuZXcgRnV6enlQb2ludExvY2F0b3IodGhpcy5fZ2VvbVsxXSwgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSksIG5ldyBGdXp6eVBvaW50TG9jYXRvcih0aGlzLl9nZW9tWzJdLCB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKV07XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQ2ID0geyBUT0xFUkFOQ0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLnJlcG9ydFJlc3VsdCA9IGZ1bmN0aW9uIHJlcG9ydFJlc3VsdCAob3ZlcmxheU9wLCBsb2NhdGlvbiwgZXhwZWN0ZWRJbnRlcmlvcikge1xuICBTeXN0ZW0ub3V0LnByaW50bG4oJ092ZXJsYXkgcmVzdWx0IGludmFsaWQgLSBBOicgKyBMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKGxvY2F0aW9uWzBdKSArICcgQjonICsgTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbChsb2NhdGlvblsxXSkgKyAnIGV4cGVjdGVkOicgKyAoZXhwZWN0ZWRJbnRlcmlvciA/ICdpJyA6ICdlJykgKyAnIGFjdHVhbDonICsgTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbChsb2NhdGlvblsyXSkpO1xufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChvdmVybGF5T3ApIHtcbiAgdGhpcy5hZGRUZXN0UHRzKHRoaXMuX2dlb21bMF0pO1xuICB0aGlzLmFkZFRlc3RQdHModGhpcy5fZ2VvbVsxXSk7XG4gIHZhciBpc1ZhbGlkID0gdGhpcy5jaGVja1ZhbGlkKG92ZXJsYXlPcCk7XG4gIHJldHVybiBpc1ZhbGlkXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG92ZXJsYXlPcCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Rlc3RDb29yZHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRoaXMkMS5fdGVzdENvb3Jkcy5nZXQoaSk7XG4gICAgICBpZiAoIXRoaXMkMS5jaGVja1ZhbGlkKG92ZXJsYXlPcCwgcHQpKSB7XG4gICAgICAgIHRoaXMkMS5faW52YWxpZExvY2F0aW9uID0gcHQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb3ZlcmxheU9wJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbG9jYXRpb25bMF0gPSB0aGlzLl9sb2NGaW5kZXJbMF0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgdGhpcy5fbG9jYXRpb25bMV0gPSB0aGlzLl9sb2NGaW5kZXJbMV0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgdGhpcy5fbG9jYXRpb25bMl0gPSB0aGlzLl9sb2NGaW5kZXJbMl0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgaWYgKE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuaGFzTG9jYXRpb24odGhpcy5fbG9jYXRpb24sIExvY2F0aW9uLkJPVU5EQVJZKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFJlc3VsdChvdmVybGF5T3AkMSwgdGhpcy5fbG9jYXRpb24pXG4gIH1cbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5hZGRUZXN0UHRzID0gZnVuY3Rpb24gYWRkVGVzdFB0cyAoZykge1xuICB2YXIgcHRHZW4gPSBuZXcgT2Zmc2V0UG9pbnRHZW5lcmF0b3IoZyk7XG4gIHRoaXMuX3Rlc3RDb29yZHMuYWRkQWxsKHB0R2VuLmdldFBvaW50cyg1ICogdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSkpO1xufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWRSZXN1bHQgPSBmdW5jdGlvbiBpc1ZhbGlkUmVzdWx0IChvdmVybGF5T3AsIGxvY2F0aW9uKSB7XG4gIHZhciBleHBlY3RlZEludGVyaW9yID0gT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsb2NhdGlvblswXSwgbG9jYXRpb25bMV0sIG92ZXJsYXlPcCk7XG4gIHZhciByZXN1bHRJbkludGVyaW9yID0gbG9jYXRpb25bMl0gPT09IExvY2F0aW9uLklOVEVSSU9SO1xuICB2YXIgaXNWYWxpZCA9ICEoZXhwZWN0ZWRJbnRlcmlvciBeIHJlc3VsdEluSW50ZXJpb3IpO1xuICBpZiAoIWlzVmFsaWQpIHsgdGhpcy5yZXBvcnRSZXN1bHQob3ZlcmxheU9wLCBsb2NhdGlvbiwgZXhwZWN0ZWRJbnRlcmlvcik7IH1cbiAgcmV0dXJuIGlzVmFsaWRcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRJbnZhbGlkTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRJbnZhbGlkTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5faW52YWxpZExvY2F0aW9uXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT3ZlcmxheVJlc3VsdFZhbGlkYXRvclxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuaGFzTG9jYXRpb24gPSBmdW5jdGlvbiBoYXNMb2NhdGlvbiAobG9jYXRpb24sIGxvYykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGlmIChsb2NhdGlvbltpXSA9PT0gbG9jKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLmNvbXB1dGVCb3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gTWF0aC5taW4oR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcwKSwgR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcxKSlcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChhLCBiLCBvdmVybGF5T3AsIHJlc3VsdCkge1xuICB2YXIgdmFsaWRhdG9yID0gbmV3IE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IoYSwgYiwgcmVzdWx0KTtcbiAgcmV0dXJuIHZhbGlkYXRvci5pc1ZhbGlkKG92ZXJsYXlPcClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDYuVE9MRVJBTkNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDAwMDAxIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPdmVybGF5UmVzdWx0VmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkNDYgKTtcblxuLy8gb3BlcmF0aW9uLm92ZXJsYXlcblxudmFyIEdlb21ldHJ5Q29tYmluZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbWJpbmVyIChnZW9tcykge1xuICB0aGlzLl9nZW9tRmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3NraXBFbXB0eSA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dEdlb21zID0gbnVsbDtcbiAgdGhpcy5fZ2VvbUZhY3RvcnkgPSBHZW9tZXRyeUNvbWJpbmVyLmV4dHJhY3RGYWN0b3J5KGdlb21zKTtcbiAgdGhpcy5faW5wdXRHZW9tcyA9IGdlb21zO1xufTtcbkdlb21ldHJ5Q29tYmluZXIucHJvdG90eXBlLmV4dHJhY3RFbGVtZW50cyA9IGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyAoZ2VvbSwgZWxlbXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZ2VvbSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBlbGVtR2VvbSA9IGdlb20uZ2V0R2VvbWV0cnlOKGkpO1xuICAgIGlmICh0aGlzJDEuX3NraXBFbXB0eSAmJiBlbGVtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIGVsZW1zLmFkZChlbGVtR2VvbSk7XG4gIH1cbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gY29tYmluZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsZW1zID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gdGhpcy5faW5wdXRHZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZyA9IGkubmV4dCgpO1xuICAgIHRoaXMkMS5leHRyYWN0RWxlbWVudHMoZywgZWxlbXMpO1xuICB9XG4gIGlmIChlbGVtcy5zaXplKCkgPT09IDApIHtcbiAgICBpZiAodGhpcy5fZ2VvbUZhY3RvcnkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShlbGVtcylcbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb21iaW5lci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbWJpbmVyXG59O1xuR2VvbWV0cnlDb21iaW5lci5jb21iaW5lID0gZnVuY3Rpb24gY29tYmluZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb21iaW5lciA9IG5ldyBHZW9tZXRyeUNvbWJpbmVyKGdlb21zKTtcbiAgICByZXR1cm4gY29tYmluZXIuY29tYmluZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvbWJpbmVyJDEgPSBuZXcgR2VvbWV0cnlDb21iaW5lcihHZW9tZXRyeUNvbWJpbmVyLmNyZWF0ZUxpc3QoZzAsIGcxKSk7XG4gICAgcmV0dXJuIGNvbWJpbmVyJDEuY29tYmluZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBnMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29tYmluZXIkMiA9IG5ldyBHZW9tZXRyeUNvbWJpbmVyKEdlb21ldHJ5Q29tYmluZXIuY3JlYXRlTGlzdChnMCQxLCBnMSQxLCBnMikpO1xuICAgIHJldHVybiBjb21iaW5lciQyLmNvbWJpbmUoKVxuICB9XG59O1xuR2VvbWV0cnlDb21iaW5lci5leHRyYWN0RmFjdG9yeSA9IGZ1bmN0aW9uIGV4dHJhY3RGYWN0b3J5IChnZW9tcykge1xuICBpZiAoZ2VvbXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIGdlb21zLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKVxufTtcbkdlb21ldHJ5Q29tYmluZXIuY3JlYXRlTGlzdCA9IGZ1bmN0aW9uIGNyZWF0ZUxpc3QgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBvYmowID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvYmoxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGxpc3QuYWRkKG9iajApO1xuICAgIGxpc3QuYWRkKG9iajEpO1xuICAgIHJldHVybiBsaXN0XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBvYmowJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9iajEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2JqMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbGlzdCQxID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGxpc3QkMS5hZGQob2JqMCQxKTtcbiAgICBsaXN0JDEuYWRkKG9iajEkMSk7XG4gICAgbGlzdCQxLmFkZChvYmoyKTtcbiAgICByZXR1cm4gbGlzdCQxXG4gIH1cbn07XG5cbnZhciBDYXNjYWRlZFBvbHlnb25VbmlvbiA9IGZ1bmN0aW9uIENhc2NhZGVkUG9seWdvblVuaW9uICgpIHtcbiAgdGhpcy5faW5wdXRQb2x5cyA9IG51bGw7XG4gIHRoaXMuX2dlb21GYWN0b3J5ID0gbnVsbDtcbiAgdmFyIHBvbHlzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9pbnB1dFBvbHlzID0gcG9seXM7XG4gIGlmICh0aGlzLl9pbnB1dFBvbHlzID09PSBudWxsKSB7IHRoaXMuX2lucHV0UG9seXMgPSBuZXcgQXJyYXlMaXN0KCk7IH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDcgPSB7IFNUUlRSRUVfTk9ERV9DQVBBQ0lUWTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnJlZHVjZVRvR2VvbWV0cmllcyA9IGZ1bmN0aW9uIHJlZHVjZVRvR2VvbWV0cmllcyAoZ2VvbVRyZWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZ2VvbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBnZW9tVHJlZS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbyA9IGkubmV4dCgpO1xuICAgIHZhciBnZW9tID0gbnVsbDtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKG8sIExpc3QpKSB7XG4gICAgICBnZW9tID0gdGhpcyQxLnVuaW9uVHJlZShvKTtcbiAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBHZW9tZXRyeSkge1xuICAgICAgZ2VvbSA9IG87XG4gICAgfVxuICAgIGdlb21zLmFkZChnZW9tKTtcbiAgfVxuICByZXR1cm4gZ2VvbXNcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuZXh0cmFjdEJ5RW52ZWxvcGUgPSBmdW5jdGlvbiBleHRyYWN0QnlFbnZlbG9wZSAoZW52LCBnZW9tLCBkaXNqb2ludEdlb21zKSB7XG4gIHZhciBpbnRlcnNlY3RpbmdHZW9tcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGVsZW0gPSBnZW9tLmdldEdlb21ldHJ5TihpKTtcbiAgICBpZiAoZWxlbS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlbnYpKSB7IGludGVyc2VjdGluZ0dlb21zLmFkZChlbGVtKTsgfSBlbHNlIHsgZGlzam9pbnRHZW9tcy5hZGQoZWxlbSk7IH1cbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShpbnRlcnNlY3RpbmdHZW9tcylcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25PcHRpbWl6ZWQgPSBmdW5jdGlvbiB1bmlvbk9wdGltaXplZCAoZzAsIGcxKSB7XG4gIHZhciBnMEVudiA9IGcwLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIGcxRW52ID0gZzEuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICBpZiAoIWcwRW52LmludGVyc2VjdHMoZzFFbnYpKSB7XG4gICAgdmFyIGNvbWJvID0gR2VvbWV0cnlDb21iaW5lci5jb21iaW5lKGcwLCBnMSk7XG4gICAgcmV0dXJuIGNvbWJvXG4gIH1cbiAgaWYgKGcwLmdldE51bUdlb21ldHJpZXMoKSA8PSAxICYmIGcxLmdldE51bUdlb21ldHJpZXMoKSA8PSAxKSB7IHJldHVybiB0aGlzLnVuaW9uQWN0dWFsKGcwLCBnMSkgfVxuICB2YXIgY29tbW9uRW52ID0gZzBFbnYuaW50ZXJzZWN0aW9uKGcxRW52KTtcbiAgcmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKGcwLCBnMSwgY29tbW9uRW52KVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uICgpIHtcbiAgaWYgKHRoaXMuX2lucHV0UG9seXMgPT09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlJykgfVxuICBpZiAodGhpcy5faW5wdXRQb2x5cy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9nZW9tRmFjdG9yeSA9IHRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO1xuICB2YXIgaW5kZXggPSBuZXcgU1RSdHJlZShDYXNjYWRlZFBvbHlnb25Vbmlvbi5TVFJUUkVFX05PREVfQ0FQQUNJVFkpO1xuICBmb3IgKHZhciBpID0gdGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgaXRlbSA9IGkubmV4dCgpO1xuICAgIGluZGV4Lmluc2VydChpdGVtLmdldEVudmVsb3BlSW50ZXJuYWwoKSwgaXRlbSk7XG4gIH1cbiAgdGhpcy5faW5wdXRQb2x5cyA9IG51bGw7XG4gIHZhciBpdGVtVHJlZSA9IGluZGV4Lml0ZW1zVHJlZSgpO1xuICB2YXIgdW5pb25BbGwgPSB0aGlzLnVuaW9uVHJlZShpdGVtVHJlZSk7XG4gIHJldHVybiB1bmlvbkFsbFxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5iaW5hcnlVbmlvbiA9IGZ1bmN0aW9uIGJpbmFyeVVuaW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMsIDAsIGdlb21zLnNpemUoKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGdlb21zJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDEpIHtcbiAgICAgIHZhciBnMCA9IENhc2NhZGVkUG9seWdvblVuaW9uLmdldEdlb21ldHJ5KGdlb21zJDEsIHN0YXJ0KTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uU2FmZShnMCwgbnVsbClcbiAgICB9IGVsc2UgaWYgKGVuZCAtIHN0YXJ0ID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmlvblNhZmUoQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkoZ2VvbXMkMSwgc3RhcnQpLCBDYXNjYWRlZFBvbHlnb25Vbmlvbi5nZXRHZW9tZXRyeShnZW9tcyQxLCBzdGFydCArIDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC50cnVuYygoZW5kICsgc3RhcnQpIC8gMik7XG4gICAgICB2YXIgZzAkMSA9IHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMkMSwgc3RhcnQsIG1pZCk7XG4gICAgICB2YXIgZzEgPSB0aGlzLmJpbmFyeVVuaW9uKGdlb21zJDEsIG1pZCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uU2FmZShnMCQxLCBnMSlcbiAgICB9XG4gIH1cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUucmVwZWF0ZWRVbmlvbiA9IGZ1bmN0aW9uIHJlcGVhdGVkVW5pb24gKGdlb21zKSB7XG4gIHZhciB1bmlvbiA9IG51bGw7XG4gIGZvciAodmFyIGkgPSBnZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZyA9IGkubmV4dCgpO1xuICAgIGlmICh1bmlvbiA9PT0gbnVsbCkgeyB1bmlvbiA9IGcuY29weSgpOyB9IGVsc2UgeyB1bmlvbiA9IHVuaW9uLnVuaW9uKGcpOyB9XG4gIH1cbiAgcmV0dXJuIHVuaW9uXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uU2FmZSA9IGZ1bmN0aW9uIHVuaW9uU2FmZSAoZzAsIGcxKSB7XG4gIGlmIChnMCA9PT0gbnVsbCAmJiBnMSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChnMCA9PT0gbnVsbCkgeyByZXR1cm4gZzEuY29weSgpIH1cbiAgaWYgKGcxID09PSBudWxsKSB7IHJldHVybiBnMC5jb3B5KCkgfVxuICByZXR1cm4gdGhpcy51bmlvbk9wdGltaXplZChnMCwgZzEpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uQWN0dWFsID0gZnVuY3Rpb24gdW5pb25BY3R1YWwgKGcwLCBnMSkge1xuICByZXR1cm4gQ2FzY2FkZWRQb2x5Z29uVW5pb24ucmVzdHJpY3RUb1BvbHlnb25zKGcwLnVuaW9uKGcxKSlcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25UcmVlID0gZnVuY3Rpb24gdW5pb25UcmVlIChnZW9tVHJlZSkge1xuICB2YXIgZ2VvbXMgPSB0aGlzLnJlZHVjZVRvR2VvbWV0cmllcyhnZW9tVHJlZSk7XG4gIHZhciB1bmlvbiA9IHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMpO1xuICByZXR1cm4gdW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gdW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uIChnMCwgZzEsIGNvbW1vbikge1xuICB2YXIgZGlzam9pbnRQb2x5cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGcwSW50ID0gdGhpcy5leHRyYWN0QnlFbnZlbG9wZShjb21tb24sIGcwLCBkaXNqb2ludFBvbHlzKTtcbiAgdmFyIGcxSW50ID0gdGhpcy5leHRyYWN0QnlFbnZlbG9wZShjb21tb24sIGcxLCBkaXNqb2ludFBvbHlzKTtcbiAgdmFyIHVuaW9uID0gdGhpcy51bmlvbkFjdHVhbChnMEludCwgZzFJbnQpO1xuICBkaXNqb2ludFBvbHlzLmFkZCh1bmlvbik7XG4gIHZhciBvdmVyYWxsVW5pb24gPSBHZW9tZXRyeUNvbWJpbmVyLmNvbWJpbmUoZGlzam9pbnRQb2x5cyk7XG4gIHJldHVybiBvdmVyYWxsVW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuYnVmZmVyVW5pb24gPSBmdW5jdGlvbiBidWZmZXJVbmlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBmYWN0b3J5ID0gZ2VvbXMuZ2V0KDApLmdldEZhY3RvcnkoKTtcbiAgICB2YXIgZ0NvbGwgPSBmYWN0b3J5LmJ1aWxkR2VvbWV0cnkoZ2VvbXMpO1xuICAgIHZhciB1bmlvbkFsbCA9IGdDb2xsLmJ1ZmZlcigwLjApO1xuICAgIHJldHVybiB1bmlvbkFsbFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBmYWN0b3J5JDEgPSBnMC5nZXRGYWN0b3J5KCk7XG4gICAgdmFyIGdDb2xsJDEgPSBmYWN0b3J5JDEuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFtnMCwgZzFdKTtcbiAgICB2YXIgdW5pb25BbGwkMSA9IGdDb2xsJDEuYnVmZmVyKDAuMCk7XG4gICAgcmV0dXJuIHVuaW9uQWxsJDFcbiAgfVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ2FzY2FkZWRQb2x5Z29uVW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5yZXN0cmljdFRvUG9seWdvbnMgPSBmdW5jdGlvbiByZXN0cmljdFRvUG9seWdvbnMgKGcpIHtcbiAgaWYgKGhhc0ludGVyZmFjZShnLCBQb2x5Z29uYWwpKSB7XG4gICAgcmV0dXJuIGdcbiAgfVxuICB2YXIgcG9seWdvbnMgPSBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGcpO1xuICBpZiAocG9seWdvbnMuc2l6ZSgpID09PSAxKSB7IHJldHVybiBwb2x5Z29ucy5nZXQoMCkgfVxuICByZXR1cm4gZy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKEdlb21ldHJ5RmFjdG9yeS50b1BvbHlnb25BcnJheShwb2x5Z29ucykpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAobGlzdCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIGxpc3QuZ2V0KGluZGV4KVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKHBvbHlzKSB7XG4gIHZhciBvcCA9IG5ldyBDYXNjYWRlZFBvbHlnb25Vbmlvbihwb2x5cyk7XG4gIHJldHVybiBvcC51bmlvbigpXG59O1xuc3RhdGljQWNjZXNzb3JzJDQ3LlNUUlRSRUVfTk9ERV9DQVBBQ0lUWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDYXNjYWRlZFBvbHlnb25Vbmlvbiwgc3RhdGljQWNjZXNzb3JzJDQ3ICk7XG5cbnZhciBVbmlvbk9wID0gZnVuY3Rpb24gVW5pb25PcCAoKSB7fTtcblxuVW5pb25PcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblVuaW9uT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVW5pb25PcFxufTtcblVuaW9uT3AudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgIGlmIChnLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuVU5JT04sIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICAgIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gb3RoZXIuY29weSgpIH1cbiAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBnLmNvcHkoKSB9XG4gIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuVU5JT04pXG59O1xuXG4vLyBvcGVyYXRpb24udW5pb25cblxuLy8gb3BlcmF0aW9uXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIElFIHN1cHBvcnRcbiAqL1xuXG5leHBvcnQgeyBHZW9KU09OUmVhZGVyLCBHZW9KU09OV3JpdGVyLCBPdmVybGF5T3AsIFVuaW9uT3AsIEJ1ZmZlck9wIH07XG4iXSwibmFtZXMiOlsiQXJyYXkiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwiZmlsbCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImFycmF5TGlrZSIsImxlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJyZWxhdGl2ZVN0YXJ0IiwiYXJndW1lbnRzIiwicGFyc2VJbnQiLCJOdW1iZXIiLCJyZWxhdGl2ZUVuZCIsIndyaXRhYmxlIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJ2YWwiLCJmbG9vciIsInBhcnNlRmxvYXQiLCJpc05hTiIsInRydW5jIiwieCIsImNlaWwiLCJOdW1iZXJVdGlsIiwiaW50ZXJmYWNlc18iLCJnZXRDbGFzcyIsImVxdWFsc1dpdGhUb2xlcmFuY2UiLCJ4MSIsIngyIiwidG9sZXJhbmNlIiwiYWJzIiwiSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIiwiRXJyb3IiLCJtZXNzYWdlIiwiY2FsbCIsIm5hbWUiLCJzdGFjayIsIl9fcHJvdG9fXyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiRG91YmxlIiwic3RhdGljQWNjZXNzb3JzJDEiLCJNQVhfVkFMVUUiLCJuIiwiZG91YmxlVG9Mb25nQml0cyIsImxvbmdCaXRzVG9Eb3VibGUiLCJpc0luZmluaXRlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydGllcyIsIkNvbXBhcmFibGUiLCJDbG9uYWJsZSIsIkNvbXBhcmF0b3IiLCJTZXJpYWxpemFibGUiLCJDb29yZGluYXRlIiwieSIsInoiLCJOVUxMX09SRElOQVRFIiwiYyIsInN0YXRpY0FjY2Vzc29ycyIsIkRpbWVuc2lvbmFsQ29tcGFyYXRvciIsInNlcmlhbFZlcnNpb25VSUQiLCJYIiwiWSIsIloiLCJzZXRPcmRpbmF0ZSIsIm9yZGluYXRlSW5kZXgiLCJlcXVhbHMyRCIsIm90aGVyIiwiZ2V0T3JkaW5hdGUiLCJlcXVhbHMzRCIsImVxdWFscyIsImVxdWFsSW5aIiwiY29tcGFyZVRvIiwibyIsImNsb25lIiwiY29weSIsInRvU3RyaW5nIiwiZGlzdGFuY2UzRCIsImR4IiwiZHkiLCJkeiIsInNxcnQiLCJkaXN0YW5jZSIsImhhc2hDb2RlIiwicmVzdWx0Iiwic2V0Q29vcmRpbmF0ZSIsImYiLCJOYU4iLCJkaW1lbnNpb25zVG9UZXN0IiwiX2RpbWVuc2lvbnNUb1Rlc3QiLCJkaW1lbnNpb25zVG9UZXN0JDEiLCJjb21wYXJlIiwibzEiLCJvMiIsImMxIiwiYzIiLCJjb21wWCIsImNvbXBZIiwiY29tcFoiLCJhIiwiYiIsIkNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkiLCJMb2NhdGlvbiIsInN0YXRpY0FjY2Vzc29ycyQ0IiwiSU5URVJJT1IiLCJCT1VOREFSWSIsIkVYVEVSSU9SIiwiTk9ORSIsInRvTG9jYXRpb25TeW1ib2wiLCJsb2NhdGlvblZhbHVlIiwiaGFzSW50ZXJmYWNlIiwiaSIsImluZGV4T2YiLCJNYXRoVXRpbCIsInN0YXRpY0FjY2Vzc29ycyQ1IiwiTE9HXzEwIiwibG9nMTAiLCJsbiIsImxvZyIsInYxIiwidjIiLCJ2MyIsInY0IiwiY2xhbXAiLCJ4JDEiLCJtaW4kMSIsIm1heCQxIiwid3JhcCIsImluZGV4IiwidjEkMSIsInYyJDEiLCJ2MyQxIiwiYXZlcmFnZSIsIlN0cmluZ0J1ZmZlciIsInN0ciIsImFwcGVuZCIsImUiLCJzZXRDaGFyQXQiLCJzdWJzdHIiLCJJbnRlZ2VyIiwiaW50VmFsdWUiLCJDaGFyYWN0ZXIiLCJpc1doaXRlc3BhY2UiLCJ0b1VwcGVyQ2FzZSIsIkREIiwiX2hpIiwiX2xvIiwiaW5pdCIsImRkIiwicGFyc2UiLCJoaSIsImxvIiwic3RhdGljQWNjZXNzb3JzJDciLCJQSSIsIlRXT19QSSIsIlBJXzIiLCJFIiwiRVBTIiwiU1BMSVQiLCJNQVhfUFJJTlRfRElHSVRTIiwiVEVOIiwiT05FIiwiU0NJX05PVF9FWFBPTkVOVF9DSEFSIiwiU0NJX05PVF9aRVJPIiwibGUiLCJleHRyYWN0U2lnbmlmaWNhbnREaWdpdHMiLCJpbnNlcnREZWNpbWFsUG9pbnQiLCJtYWduaXR1ZGUiLCJtYWciLCJzY2FsZSIsInBvdyIsImRpdmlkZSIsImd0IiwibHQiLCJtdWx0aXBseSIsImRlY2ltYWxQb2ludFBvcyIsImJ1ZiIsIm51bURpZ2l0cyIsImRpZ2l0IiwicmViaWFzQnkxMCIsImRpZ2l0Q2hhciIsInN1YnRyYWN0IiwidmFsdWVPZiIsInNlbGZBZGQiLCJjb250aW51ZUV4dHJhY3RpbmdEaWdpdHMiLCJyZW1NYWciLCJzcXIiLCJkb3VibGVWYWx1ZSIsImFkZCIsIm5lZ2F0ZSIsInkkMSIsImlzWmVybyIsInNlbGZTdWJ0cmFjdCIsImdldFNwZWNpYWxOdW1iZXJTdHJpbmciLCJzZWxmRGl2aWRlIiwieWhpIiwieWxvIiwiaGMiLCJ0YyIsImh5IiwidHkiLCJDIiwiVSIsInUiLCJkdW1wIiwiemhpIiwiemxvIiwiY3JlYXRlTmFOIiwiZ2UiLCJleHAiLCJyIiwicyIsInNlbGZNdWx0aXBseSIsInJlY2lwcm9jYWwiLCJmaGkiLCJmbG8iLCJyaW50IiwicGx1czUiLCJzZXRWYWx1ZSIsInZhbHVlJDEiLCJpc05lZ2F0aXZlIiwiYXgiLCJheGRkIiwiZGlmZlNxIiwiZDIiLCJIIiwiaCIsIlMiLCJIJDEiLCJoJDEiLCJUIiwidCIsIlMkMSIsInMkMSIsImUkMSIsImYkMSIsImh4IiwidHgiLCJzZWxmU3FyIiwidG9TdGFuZGFyZE5vdGF0aW9uIiwidG9TY2lOb3RhdGlvbiIsInNwZWNpYWxTdHIiLCJzaWdEaWdpdHMiLCJudW0iLCJjaGFyQXQiLCJzdHJpbmdPZkNoYXIiLCJudW1aZXJvZXMiLCJ6ZXJvZXMiLCJkaWdpdHMiLCJleHBTdHIiLCJ0cmFpbGluZ0RpZ2l0cyIsInN1YnN0cmluZyIsImRpZ2l0c1dpdGhEZWNpbWFsIiwiaXNQb3NpdGl2ZSIsInNpZ251bSIsInN0cmxlbiIsInNpZ25DaCIsIm51bUJlZm9yZURlYyIsImNoIiwiaXNEaWdpdCIsImQiLCJleCIsInZhbDIiLCJudW1EZWNQbGFjZXMiLCJzY2FsZSQxIiwieEFicyIsInhMb2cxMCIsInhNYWciLCJ4QXBwcm94IiwibGVuIiwiQ0dBbGdvcml0aG1zREQiLCJzdGF0aWNBY2Nlc3NvcnMkNiIsIkRQX1NBRkVfRVBTSUxPTiIsIm9yaWVudGF0aW9uSW5kZXgiLCJwMSIsInAyIiwicSIsIm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIiLCJkeDEiLCJkeTEiLCJkeDIiLCJkeTIiLCJzaWduT2ZEZXQyeDIiLCJ5MSIsInkyIiwiZGV0IiwiaW50ZXJzZWN0aW9uIiwicTEiLCJxMiIsImRlbm9tMSIsImRlbm9tMiIsImRlbm9tIiwibnVteDEiLCJudW14MiIsIm51bXgiLCJmcmFjUCIsIm51bXkxIiwibnVteTIiLCJudW15IiwiZnJhY1EiLCJwYSIsInBiIiwicGMiLCJkZXRzdW0iLCJkZXRsZWZ0IiwiZGV0cmlnaHQiLCJlcnJib3VuZCIsIkNvb3JkaW5hdGVTZXF1ZW5jZSIsInN0YXRpY0FjY2Vzc29ycyQ4IiwiTSIsInNpemUiLCJnZXRDb29yZGluYXRlIiwiZ2V0Q29vcmRpbmF0ZUNvcHkiLCJnZXREaW1lbnNpb24iLCJnZXRYIiwiZXhwYW5kRW52ZWxvcGUiLCJlbnYiLCJnZXRZIiwidG9Db29yZGluYXRlQXJyYXkiLCJFeGNlcHRpb24iLCJOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uIiwiRXhjZXB0aW9uJCQxIiwiU3lzdGVtIiwiYXJyYXljb3B5Iiwic3JjIiwic3JjUG9zIiwiZGVzdCIsImRlc3RQb3MiLCJnZXRQcm9wZXJ0eSIsIkhDb29yZGluYXRlIiwidyIsInAiLCJfeCIsIl95IiwicDEkMSIsInAyJDEiLCJfeCQxIiwiX3kkMSIsIl93IiwicDEkMiIsInAyJDIiLCJweCIsInB5IiwicHciLCJxeCIsInF5IiwicXciLCJ4SW50IiwieUludCIsIkVudmVsb3BlIiwiX21pbngiLCJfbWF4eCIsIl9taW55IiwiX21heHkiLCJzdGF0aWNBY2Nlc3NvcnMkOSIsImdldEFyZWEiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsIm90aGVyRW52ZWxvcGUiLCJpc051bGwiLCJnZXRNYXhYIiwiZ2V0TWF4WSIsImdldE1pblgiLCJnZXRNaW5ZIiwiaW50ZXJzZWN0cyIsImludE1pblgiLCJpbnRNaW5ZIiwiaW50TWF4WCIsImludE1heFkiLCJjb3ZlcnMiLCJleHBhbmRUb0luY2x1ZGUiLCJtaW5FeHRlbnQiLCJ0cmFuc2xhdGUiLCJ0cmFuc1giLCJ0cmFuc1kiLCJzZXRUb051bGwiLCJtYXhFeHRlbnQiLCJleHBhbmRCeSIsImRlbHRhWCIsImRlbHRhWSIsImNvbnRhaW5zIiwiY2VudHJlIiwibWlucSIsIm1heHEiLCJtaW5wIiwibWF4cCIsInJlZ0V4ZXMiLCJXS1RQYXJzZXIiLCJnZW9tZXRyeUZhY3RvcnkiLCJHZW9tZXRyeUZhY3RvcnkiLCJyZWFkIiwid2t0IiwiZ2VvbWV0cnkiLCJ0eXBlIiwicmVwbGFjZSIsIm1hdGNoZXMiLCJ0eXBlU3RyIiwiZXhlYyIsInNlYXJjaCIsImVtcHR5VHlwZVN0ciIsInRvTG93ZXJDYXNlIiwicGFyc2UkMSIsImFwcGx5Iiwid3JpdGUiLCJleHRyYWN0R2VvbWV0cnkiLCJnZXRHZW9tZXRyeVR5cGUiLCJleHRyYWN0JDEiLCJ3a3RUeXBlIiwiZGF0YSIsImlzRW1wdHkiLCJjb29yZGluYXRlIiwiY29vcmRpbmF0ZSQxIiwicG9pbnQiLCJwb2ludCQxIiwiX2Nvb3JkaW5hdGVzIiwibXVsdGlwb2ludCIsIm11bHRpcG9pbnQkMSIsInRoaXMkMSIsImFycmF5IiwiX2dlb21ldHJpZXMiLCJwdXNoIiwiam9pbiIsImxpbmVzdHJpbmciLCJsaW5lc3RyaW5nJDEiLCJfcG9pbnRzIiwibGluZWFycmluZyIsImxpbmVhcnJpbmckMSIsIm11bHRpbGluZXN0cmluZyIsIm11bHRpbGluZXN0cmluZyQxIiwicG9seWdvbiIsInBvbHlnb24kMSIsIl9zaGVsbCIsIl9ob2xlcyIsIm11bHRpcG9seWdvbiIsIm11bHRpcG9seWdvbiQxIiwiZ2VvbWV0cnljb2xsZWN0aW9uIiwiY29sbGVjdGlvbiIsImNyZWF0ZVBvaW50IiwiY29vcmRzIiwidHJpbSIsInNwbGl0Iiwic3BhY2VzIiwiY3JlYXRlTXVsdGlQb2ludCIsInBvaW50cyIsImNvbXBvbmVudHMiLCJ0cmltUGFyZW5zIiwiY3JlYXRlTGluZVN0cmluZyIsImNyZWF0ZUxpbmVhclJpbmciLCJjcmVhdGVNdWx0aUxpbmVTdHJpbmciLCJsaW5lIiwibGluZXMiLCJwYXJlbkNvbW1hIiwiY3JlYXRlUG9seWdvbiIsInJpbmciLCJyaW5ncyIsInNoZWxsIiwiaG9sZXMiLCJjcmVhdGVNdWx0aVBvbHlnb24iLCJwb2x5Z29ucyIsImRvdWJsZVBhcmVuQ29tbWEiLCJjcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24iLCJ3a3RBcnJheSIsIldLVFdyaXRlciIsInBhcnNlciIsInRvTGluZVN0cmluZyIsInAwIiwiUnVudGltZUV4Y2VwdGlvbiIsIkFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbiIsIlJ1bnRpbWVFeGNlcHRpb24kJDEiLCJBc3NlcnQiLCJzaG91bGROZXZlclJlYWNoSGVyZSIsImlzVHJ1ZSIsImFzc2VydGlvbiIsImV4cGVjdGVkVmFsdWUiLCJhY3R1YWxWYWx1ZSIsIkxpbmVJbnRlcnNlY3RvciIsIl9yZXN1bHQiLCJfaW5wdXRMaW5lcyIsIm1hcCIsIl9pbnRQdCIsIl9pbnRMaW5lSW5kZXgiLCJfaXNQcm9wZXIiLCJfcGEiLCJfcGIiLCJfcHJlY2lzaW9uTW9kZWwiLCJzdGF0aWNBY2Nlc3NvcnMkMTAiLCJET05UX0lOVEVSU0VDVCIsIkRPX0lOVEVSU0VDVCIsIkNPTExJTkVBUiIsIk5PX0lOVEVSU0VDVElPTiIsIlBPSU5UX0lOVEVSU0VDVElPTiIsIkNPTExJTkVBUl9JTlRFUlNFQ1RJT04iLCJnZXRJbmRleEFsb25nU2VnbWVudCIsInNlZ21lbnRJbmRleCIsImludEluZGV4IiwiY29tcHV0ZUludExpbmVJbmRleCIsImdldFRvcG9sb2d5U3VtbWFyeSIsImNhdEJ1ZiIsImlzRW5kUG9pbnQiLCJpc0NvbGxpbmVhciIsImNvbXB1dGVJbnRlcnNlY3Rpb24iLCJwMyIsInA0IiwiY29tcHV0ZUludGVyc2VjdCIsImdldEludGVyc2VjdGlvbk51bSIsImRpc3QwIiwiZ2V0RWRnZURpc3RhbmNlIiwiZGlzdDEiLCJpc1Byb3BlciIsImhhc0ludGVyc2VjdGlvbiIsInNldFByZWNpc2lvbk1vZGVsIiwicHJlY2lzaW9uTW9kZWwiLCJpc0ludGVyaW9ySW50ZXJzZWN0aW9uIiwiaW5wdXRMaW5lSW5kZXgiLCJnZXRJbnRlcnNlY3Rpb24iLCJkaXN0IiwiY29tcHV0ZUVkZ2VEaXN0YW5jZSIsImdldEVuZHBvaW50IiwicHRJbmRleCIsImlzSW50ZXJzZWN0aW9uIiwicHQiLCJnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQiLCJwZHgiLCJwZHkiLCJub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlIiwiUm9idXN0TGluZUludGVyc2VjdG9yIiwiTGluZUludGVyc2VjdG9yJCQxIiwiaXNJblNlZ21lbnRFbnZlbG9wZXMiLCJpbnRQdCIsImVudjAiLCJlbnYxIiwiQ0dBbGdvcml0aG1zIiwibm9ybWFsaXplVG9NaW5pbXVtIiwibjEiLCJuMiIsIm4zIiwibjQiLCJub3JtUHQiLCJzbWFsbGVzdEluQWJzVmFsdWUiLCJzYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24iLCJuZWFyZXN0RW5kcG9pbnQiLCJpbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbiIsIm1ha2VQcmVjaXNlIiwieDMiLCJ4NCIsInhhYnMiLCJjaGVja0REIiwiaW50UHRERCIsImlzSW4iLCJvdXQiLCJwcmludGxuIiwibm9ybWFsaXplVG9FbnZDZW50cmUiLCJjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uIiwicDFxMXAyIiwicDFxMnAyIiwicTFwMXEyIiwicTFwMnEyIiwibjAwIiwibjAxIiwibjEwIiwibjExIiwibWluWDAiLCJtaW5ZMCIsIm1heFgwIiwibWF4WTAiLCJtaW5YMSIsIm1pblkxIiwibWF4WDEiLCJtYXhZMSIsImludE1pZFgiLCJpbnRNaWRZIiwiUHExIiwiUHEyIiwiUXAxIiwiUXAyIiwiY29sbGluZWFyIiwibmVhcmVzdFB0IiwibWluRGlzdCIsImRpc3RhbmNlUG9pbnRMaW5lIiwiUm9idXN0RGV0ZXJtaW5hbnQiLCJzaWduIiwic3dhcCIsImsiLCJSYXlDcm9zc2luZ0NvdW50ZXIiLCJfcCIsIl9jcm9zc2luZ0NvdW50IiwiX2lzUG9pbnRPblNlZ21lbnQiLCJjb3VudFNlZ21lbnQiLCJtaW54IiwibWF4eCIsInhJbnRTaWduIiwiaXNQb2ludEluUG9seWdvbiIsImdldExvY2F0aW9uIiwiaXNPblNlZ21lbnQiLCJsb2NhdGVQb2ludEluUmluZyIsImNvdW50ZXIiLCJwJDEiLCJyaW5nJDEiLCJjb3VudGVyJDEiLCJpJDEiLCJzdGF0aWNBY2Nlc3NvcnMkMyIsIkNMT0NLV0lTRSIsIlJJR0hUIiwiQ09VTlRFUkNMT0NLV0lTRSIsIkxFRlQiLCJTVFJBSUdIVCIsInNpZ25lZEFyZWEiLCJzdW0iLCJ4MCIsIngwJDEiLCJzdW0kMSIsImRpc3RhbmNlTGluZUxpbmUiLCJBIiwiQiIsIkQiLCJub0ludGVyc2VjdGlvbiIsInJOdW1iIiwic051bSIsImlzUG9pbnRJblJpbmciLCJjb21wdXRlTGVuZ3RoIiwicHRzIiwieTAiLCJpc0NDVyIsIm5QdHMiLCJoaVB0IiwiaGlJbmRleCIsImlQcmV2IiwiaU5leHQiLCJwcmV2IiwibmV4dCIsImRpc2MiLCJjb21wdXRlT3JpZW50YXRpb24iLCJkaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIiLCJsZW4yIiwibWluRGlzdGFuY2UiLCJpc09uTGluZSIsImxpbmVJbnRlcnNlY3RvciIsIkdlb21ldHJ5Q29tcG9uZW50RmlsdGVyIiwiZmlsdGVyIiwiZ2VvbSIsIkdlb21ldHJ5IiwiZmFjdG9yeSIsIl9lbnZlbG9wZSIsIl9mYWN0b3J5IiwiX1NSSUQiLCJfdXNlckRhdGEiLCJnZXRTUklEIiwic3RhdGljQWNjZXNzb3JzJDExIiwiU09SVElOREVYX1BPSU5UIiwiU09SVElOREVYX01VTFRJUE9JTlQiLCJTT1JUSU5ERVhfTElORVNUUklORyIsIlNPUlRJTkRFWF9MSU5FQVJSSU5HIiwiU09SVElOREVYX01VTFRJTElORVNUUklORyIsIlNPUlRJTkRFWF9QT0xZR09OIiwiU09SVElOREVYX01VTFRJUE9MWUdPTiIsIlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04iLCJnZW9tZXRyeUNoYW5nZWRGaWx0ZXIiLCJpc0dlb21ldHJ5Q29sbGVjdGlvbiIsImdldFNvcnRJbmRleCIsImdldEZhY3RvcnkiLCJnZXRHZW9tZXRyeU4iLCJpc1JlY3RhbmdsZSIsImckMSIsImVxdWFsc1RvcG8iLCJnIiwiZXF1YWxzRXhhY3QiLCJnZW9tZXRyeUNoYW5nZWQiLCJnZW9tZXRyeUNoYW5nZWRBY3Rpb24iLCJlcXVhbHNOb3JtIiwibm9ybSIsImdldExlbmd0aCIsImdldE51bUdlb21ldHJpZXMiLCJjb21wYXJlVG9TYW1lQ2xhc3MiLCJvdGhlciQxIiwiY29tcCIsImdldFVzZXJEYXRhIiwiZ2V0RW52ZWxvcGUiLCJ0b0dlb21ldHJ5IiwiZ2V0RW52ZWxvcGVJbnRlcm5hbCIsImNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uIiwiZXF1YWwiLCJub3JtYWxpemUiLCJnZXRQcmVjaXNpb25Nb2RlbCIsImNvbXB1dGVFbnZlbG9wZUludGVybmFsIiwic2V0U1JJRCIsIlNSSUQiLCJzZXRVc2VyRGF0YSIsInVzZXJEYXRhIiwiaXRlcmF0b3IiLCJqIiwiaGFzTmV4dCIsImFFbGVtZW50IiwiYkVsZW1lbnQiLCJjb21wYXJpc29uIiwiaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQiLCJoYXNOb25FbXB0eUVsZW1lbnRzIiwiZ2VvbWV0cmllcyIsImhhc051bGxFbGVtZW50cyIsIkNvb3JkaW5hdGVGaWx0ZXIiLCJjb29yZCIsIkJvdW5kYXJ5Tm9kZVJ1bGUiLCJzdGF0aWNBY2Nlc3NvcnMkMTIiLCJNb2QyQm91bmRhcnlOb2RlUnVsZSIsIkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSIsIk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlIiwiTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSIsIk1PRDJfQk9VTkRBUllfUlVMRSIsIkVORFBPSU5UX0JPVU5EQVJZX1JVTEUiLCJNVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFIiwiTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFIiwiT0dDX1NGU19CT1VOREFSWV9SVUxFIiwiaXNJbkJvdW5kYXJ5IiwiYm91bmRhcnlDb3VudCIsIkNvbGxlY3Rpb24iLCJhZGRBbGwiLCJ0b0FycmF5IiwicmVtb3ZlIiwiSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiIsIkl0ZXJhdG9yIiwiTGlzdCIsIkNvbGxlY3Rpb24kJDEiLCJzZXQiLCJOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIiwiQXJyYXlMaXN0IiwiTGlzdCQkMSIsImFycmF5XyIsImVuc3VyZUNhcGFjaXR5Iiwic3BsaWNlIiwiY2xlYXIiLCJlbGVtZW50Iiwib2xkRWxlbWVudCIsIkl0ZXJhdG9yXyIsImZvdW5kIiwiSXRlcmF0b3IkJDEiLCJhcnJheUxpc3QiLCJhcnJheUxpc3RfIiwicG9zaXRpb25fIiwiQ29vcmRpbmF0ZUxpc3QiLCJBcnJheUxpc3QkJDEiLCJjb29yZCQxIiwiYWxsb3dSZXBlYXRlZCIsImNvb3JkQXJyYXlUeXBlIiwiY29sbCIsImlzQ2hhbmdlZCIsImNvb3JkJDIiLCJhbGxvd1JlcGVhdGVkJDEiLCJsYXN0Iiwib2JqIiwiYWxsb3dSZXBlYXRlZCQyIiwiY29vcmQkMyIsImFsbG93UmVwZWF0ZWQkMyIsImRpcmVjdGlvbiIsImkkMiIsImkkMyIsImNvb3JkJDQiLCJhbGxvd1JlcGVhdGVkJDQiLCJjb29yZCQ1IiwiYWxsb3dSZXBlYXRlZCQ1Iiwic3RhcnQiLCJlbmQiLCJpbmMiLCJjbG9zZVJpbmciLCJDb29yZGluYXRlQXJyYXlzIiwic3RhdGljQWNjZXNzb3JzJDEzIiwiRm9yd2FyZENvbXBhcmF0b3IiLCJCaWRpcmVjdGlvbmFsQ29tcGFyYXRvciIsImlzUmluZyIsInB0Tm90SW5MaXN0IiwidGVzdFB0cyIsInRlc3RQdCIsInNjcm9sbCIsImNvb3JkaW5hdGVzIiwiZmlyc3RDb29yZGluYXRlIiwibmV3Q29vcmRpbmF0ZXMiLCJjb29yZDEiLCJjb29yZDIiLCJjb29yZDEkMSIsImNvb3JkMiQxIiwiY29vcmRpbmF0ZUNvbXBhcmF0b3IiLCJjb29yZExpc3QiLCJoYXNSZXBlYXRlZFBvaW50cyIsInJlbW92ZVJlcGVhdGVkUG9pbnRzIiwicmV2ZXJzZSIsIm1pZCIsInRtcCIsInJlbW92ZU51bGwiLCJub25OdWxsIiwibmV3Q29vcmQiLCJjb3B5RGVlcCIsInNyY1N0YXJ0IiwiZGVzdFN0YXJ0IiwiaXNFcXVhbFJldmVyc2VkIiwicHRzMSIsInB0czIiLCJlbnZlbG9wZSIsImF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmciLCJpbmNyZWFzaW5nRGlyZWN0aW9uIiwibWluQ29vcmRpbmF0ZSIsIm1pbkNvb3JkIiwiZXh0cmFjdCIsIm5wdHMiLCJleHRyYWN0UHRzIiwiaVB0cyIsImZvcndhcmRDb21wIiwiaXNFcXVhbFJldiIsIk9MRGNvbXBhcmUiLCJkaXIxIiwiZGlyMiIsImkxIiwiaTIiLCJjb21wYXJlUHQiLCJNYXAkMSIsIk1hcCIsInB1dCIsInZhbHVlcyIsImVudHJ5U2V0IiwiU29ydGVkTWFwIiwiT3BlcmF0aW9uTm90U3VwcG9ydGVkIiwiU2V0IiwiSGFzaFNldCIsIlNldCQkMSIsIkl0ZXJhdG9yXyQxIiwiaGFzaFNldCIsImhhc2hTZXRfIiwiQkxBQ0siLCJSRUQiLCJjb2xvck9mIiwiY29sb3IiLCJwYXJlbnRPZiIsInBhcmVudCIsInNldENvbG9yIiwibGVmdE9mIiwibGVmdCIsInJpZ2h0T2YiLCJyaWdodCIsIlRyZWVNYXAiLCJyb290XyIsInNpemVfIiwia2V5IiwiY21wIiwiZ2V0VmFsdWUiLCJnZXRLZXkiLCJvbGRWYWx1ZSIsImZpeEFmdGVySW5zZXJ0aW9uIiwicm90YXRlTGVmdCIsInJvdGF0ZVJpZ2h0IiwiZ2V0Rmlyc3RFbnRyeSIsInN1Y2Nlc3NvciIsImwiLCJMaW5lYWwiLCJTb3J0ZWRTZXQiLCJUcmVlU2V0IiwiSXRlcmF0b3JfJDIiLCJ0cmVlU2V0IiwidHJlZVNldF8iLCJBcnJheXMiLCJzb3J0IiwiY29tcGFyYXRvciIsInNsaWNlIiwiY29uY2F0IiwiYXNMaXN0IiwiRGltZW5zaW9uIiwic3RhdGljQWNjZXNzb3JzJDE0IiwiUCIsIkwiLCJGQUxTRSIsIlRSVUUiLCJET05UQ0FSRSIsIlNZTV9GQUxTRSIsIlNZTV9UUlVFIiwiU1lNX0RPTlRDQVJFIiwiU1lNX1AiLCJTWU1fTCIsIlNZTV9BIiwidG9EaW1lbnNpb25TeW1ib2wiLCJkaW1lbnNpb25WYWx1ZSIsInRvRGltZW5zaW9uVmFsdWUiLCJkaW1lbnNpb25TeW1ib2wiLCJHZW9tZXRyeUZpbHRlciIsIkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlciIsInNlcSIsImlzRG9uZSIsImlzR2VvbWV0cnlDaGFuZ2VkIiwiR2VvbWV0cnlDb2xsZWN0aW9uIiwiR2VvbWV0cnkkJDEiLCJnZXRDb29yZGluYXRlcyIsImdldE51bVBvaW50cyIsImNoaWxkQ29vcmRpbmF0ZXMiLCJhcmVhIiwiaXNFcXVpdmFsZW50Q2xhc3MiLCJvdGhlckNvbGxlY3Rpb24iLCJnZXRCb3VuZGFyeURpbWVuc2lvbiIsImRpbWVuc2lvbiIsIm51bVBvaW50cyIsInJldkdlb21zIiwidGhlc2VFbGVtZW50cyIsIm90aGVyRWxlbWVudHMiLCJvJDEiLCJnYyIsInRoaXNHZW9tIiwib3RoZXJHZW9tIiwiaG9sZUNvbXAiLCJmaWx0ZXIkMSIsImZpbHRlciQyIiwiZmlsdGVyJDMiLCJnZXRCb3VuZGFyeSIsIk11bHRpTGluZVN0cmluZyIsIkdlb21ldHJ5Q29sbGVjdGlvbiQkMSIsImlzQ2xvc2VkIiwibkxpbmVzIiwicmV2TGluZXMiLCJCb3VuZGFyeU9wIiwibGluZVN0cmluZ3MiLCJfZ2VvbSIsIl9nZW9tRmFjdCIsIl9iblJ1bGUiLCJfZW5kcG9pbnRNYXAiLCJiblJ1bGUiLCJnZW9tJDEiLCJiblJ1bGUkMSIsImJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nIiwibUxpbmUiLCJnZXRFbXB0eU11bHRpUG9pbnQiLCJiZHlQdHMiLCJjb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyIsImNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzIiwiTGluZVN0cmluZyIsImJvdW5kYXJ5TGluZVN0cmluZyIsImNsb3NlZEVuZHBvaW50T25Cb3VuZGFyeSIsImdldFN0YXJ0UG9pbnQiLCJnZXRFbmRQb2ludCIsImFkZEVuZHBvaW50IiwiZ2V0Q29vcmRpbmF0ZU4iLCJpdCIsImVudHJ5IiwidmFsZW5jZSIsImNvdW50IiwiQ291bnRlciIsImJvcCIsImJvcCQxIiwiUHJpbnRTdHJlYW0iLCJTdHJpbmdSZWFkZXIiLCJEZWNpbWFsRm9ybWF0IiwiQnl0ZUFycmF5T3V0cHV0U3RyZWFtIiwiSU9FeGNlcHRpb24iLCJMaW5lTnVtYmVyUmVhZGVyIiwiU3RyaW5nVXRpbCIsInN0YXRpY0FjY2Vzc29ycyQxNSIsIk5FV0xJTkUiLCJTSU1QTEVfT1JESU5BVEVfRk9STUFUIiwiY2hhcnMiLCJTdHJpbmciLCJnZXRTdGFja1RyYWNlIiwib3MiLCJwcyIsInByaW50U3RhY2tUcmFjZSIsInQkMSIsImRlcHRoIiwic3RhY2tUcmFjZSIsInN0cmluZ1JlYWRlciIsImxpbmVOdW1iZXJSZWFkZXIiLCJyZWFkTGluZSIsInNlcGFyYXRvciIsInNlcGFyYXRvcmxlbiIsInRva2VuTGlzdCIsInRtcFN0cmluZyIsInBvcyIsInRva2VuIiwicmVzIiwiZm9ybWF0IiwiQ29vcmRpbmF0ZVNlcXVlbmNlcyIsImNvcHlDb29yZCIsIm1pbkRpbSIsImRpbSIsImlzRXF1YWwiLCJjczEiLCJjczIiLCJjczFTaXplIiwiY3MyU2l6ZSIsImV4dGVuZCIsImZhY3QiLCJuZXdzZXEiLCJjcyIsImVuc3VyZVZhbGlkUmluZyIsImNyZWF0ZUNsb3NlZFJpbmciLCJpc1NpbXBsZSIsIm90aGVyTGluZVN0cmluZyIsImdldFBvaW50TiIsInJldkxpbmUiLCJsaW5lJDEiLCJscyIsImdldENvb3JkaW5hdGVTZXF1ZW5jZSIsImdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkiLCJpc0Nvb3JkaW5hdGUiLCJQdW50YWwiLCJQb2ludCIsIlBvbHlnb25hbCIsIlBvbHlnb24iLCJzaGVsbENvb3JkaW5hdGVzIiwiZ2V0TnVtSW50ZXJpb3JSaW5nIiwicHJldlgiLCJwcmV2WSIsInhDaGFuZ2VkIiwieUNoYW5nZWQiLCJvdGhlclBvbHlnb24iLCJ0aGlzU2hlbGwiLCJvdGhlclBvbHlnb25TaGVsbCIsImNsb2Nrd2lzZSIsInVuaXF1ZUNvb3JkaW5hdGVzIiwicG9seSIsImNvbnZleEh1bGwiLCJnZXRFeHRlcmlvclJpbmciLCJvdGhlclNoZWxsIiwidGhpc1NoZWxsJDEiLCJvdGhlclNoZWxsJDEiLCJzaGVsbENvbXAiLCJuSG9sZTEiLCJuSG9sZTIiLCJ0aGlzSG9sZSIsImdldEludGVyaW9yUmluZ04iLCJvdGhlckhvbGUiLCJNdWx0aVBvaW50IiwiaXNWYWxpZCIsIkxpbmVhclJpbmciLCJMaW5lU3RyaW5nJCQxIiwidmFsaWRhdGVDb25zdHJ1Y3Rpb24iLCJNSU5JTVVNX1ZBTElEX1NJWkUiLCJyZXYiLCJNdWx0aVBvbHlnb24iLCJhbGxSaW5ncyIsImFsbFJpbmdzQXJyYXkiLCJHZW9tZXRyeUVkaXRvciIsIl9pc1VzZXJEYXRhQ29waWVkIiwic3RhdGljQWNjZXNzb3JzJDE2IiwiTm9PcEdlb21ldHJ5T3BlcmF0aW9uIiwiQ29vcmRpbmF0ZU9wZXJhdGlvbiIsIkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbiIsInNldENvcHlVc2VyRGF0YSIsImlzVXNlckRhdGFDb3BpZWQiLCJlZGl0Iiwib3BlcmF0aW9uIiwiZWRpdEludGVybmFsIiwiZWRpdEdlb21ldHJ5Q29sbGVjdGlvbiIsImVkaXRQb2x5Z29uIiwiZ2V0TmFtZSIsImNvbGxlY3Rpb25Gb3JUeXBlIiwibmV3UG9seWdvbiIsImhvbGUiLCJHZW9tZXRyeUVkaXRvck9wZXJhdGlvbiIsImVkaXRDb29yZGluYXRlcyIsIkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlIiwiX2RpbWVuc2lvbiIsImNvb3JkU2VxIiwic2l6ZSQxIiwiZGltZW5zaW9uJDEiLCJzdGF0aWNBY2Nlc3NvcnMkMTgiLCJjbG9uZUNvb3JkaW5hdGVzIiwic3RyQnVmIiwiQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5Iiwic3RhdGljQWNjZXNzb3JzJDE3IiwiaW5zdGFuY2VPYmplY3QiLCJyZWFkUmVzb2x2ZSIsImluc3RhbmNlIiwiSGFzaE1hcCIsIk1hcEludGVyZmFjZSIsIm1hcF8iLCJkb25lIiwiZW50cmllcyIsImZvckVhY2giLCJQcmVjaXNpb25Nb2RlbCIsIl9tb2RlbFR5cGUiLCJfc2NhbGUiLCJGTE9BVElORyIsIlR5cGUiLCJtb2RlbFR5cGUiLCJGSVhFRCIsInNldFNjYWxlIiwicG0iLCJzdGF0aWNBY2Nlc3NvcnMkMTkiLCJtYXhpbXVtUHJlY2lzZVZhbHVlIiwib3RoZXJQcmVjaXNpb25Nb2RlbCIsImdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cyIsIm90aGVyU2lnRGlnaXRzIiwiZ2V0U2NhbGUiLCJpc0Zsb2F0aW5nIiwiRkxPQVRJTkdfU0lOR0xFIiwiZ2V0VHlwZSIsImRlc2NyaXB0aW9uIiwiZmxvYXRTaW5nbGVWYWwiLCJyb3VuZCIsIm1heFNpZ0RpZ2l0cyIsIm1vc3RQcmVjaXNlIiwicG0xIiwicG0yIiwiX25hbWUiLCJuYW1lVG9UeXBlTWFwIiwic3RhdGljQWNjZXNzb3JzJDEkMSIsIl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5IiwiZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkiLCJzdGF0aWNBY2Nlc3NvcnMkMiIsImJ1aWxkR2VvbWV0cnkiLCJnZW9tTGlzdCIsImdlb21DbGFzcyIsImlzSGV0ZXJvZ2VuZW91cyIsImhhc0dlb21ldHJ5Q29sbGVjdGlvbiIsInBhcnRDbGFzcyIsInRvR2VvbWV0cnlBcnJheSIsImdlb20wIiwiaXNDb2xsZWN0aW9uIiwidG9Qb2x5Z29uQXJyYXkiLCJ0b0xpbmVTdHJpbmdBcnJheSIsInRvUG9pbnRBcnJheSIsImNvb3JkaW5hdGVzJDEiLCJzaGVsbCQxIiwiY3JlYXRlR2VvbWV0cnkiLCJlZGl0b3IiLCJwdFNlcSIsInRvTXVsdGlQb2x5Z29uQXJyYXkiLCJtdWx0aVBvbHlnb25zIiwibXVsdGlQb2x5Z29uQXJyYXkiLCJnZW9tZXRyeUFycmF5IiwidG9NdWx0aUxpbmVTdHJpbmdBcnJheSIsIm11bHRpTGluZVN0cmluZ3MiLCJtdWx0aUxpbmVTdHJpbmdBcnJheSIsImxpbmVTdHJpbmdBcnJheSIsInRvTXVsdGlQb2ludEFycmF5IiwibXVsdGlQb2ludHMiLCJtdWx0aVBvaW50QXJyYXkiLCJ0b0xpbmVhclJpbmdBcnJheSIsImxpbmVhclJpbmdzIiwibGluZWFyUmluZ0FycmF5IiwicG9pbnRBcnJheSIsInBvbHlnb25BcnJheSIsImNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQiLCJleGVtcGxhciIsImdlb21ldHJ5VHlwZXMiLCJHZW9KU09OUGFyc2VyIiwianNvbiIsIkpTT04iLCJGZWF0dXJlIiwiZmVhdHVyZSIsImJib3giLCJGZWF0dXJlQ29sbGVjdGlvbiIsImZlYXR1cmVDb2xsZWN0aW9uIiwiZmVhdHVyZXMiLCJzdWIiLCJsaW5lYXJSaW5nIiwiZ2VvSnNvbiIsInNoZWxsR2VvSnNvbiIsImhvbGVHZW9Kc29uIiwiR2VvSlNPTlJlYWRlciIsInJlZHVjZVByZWNpc2lvbiIsIkdlb0pTT05Xcml0ZXIiLCJQb3NpdGlvbiIsInN0YXRpY0FjY2Vzc29ycyQyMCIsIk9OIiwib3Bwb3NpdGUiLCJwb3NpdGlvbiIsIkVtcHR5U3RhY2tFeGNlcHRpb24iLCJTdGFjayIsInBvcCIsInBlZWsiLCJlbXB0eSIsIlJpZ2h0bW9zdEVkZ2VGaW5kZXIiLCJfbWluSW5kZXgiLCJfbWluQ29vcmQiLCJfbWluRGUiLCJfb3JpZW50ZWREZSIsImdldFJpZ2h0bW9zdFNpZGUiLCJkZSIsInNpZGUiLCJnZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50IiwiY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlIiwiZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCIsImdldEVkZ2UiLCJwUHJldiIsInBOZXh0Iiwib3JpZW50YXRpb24iLCJ1c2VQcmV2IiwiZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUiLCJub2RlIiwiZ2V0Tm9kZSIsInN0YXIiLCJnZXRFZGdlcyIsImdldFJpZ2h0bW9zdEVkZ2UiLCJpc0ZvcndhcmQiLCJnZXRTeW0iLCJmaW5kRWRnZSIsImRpckVkZ2VMaXN0IiwicmlnaHRtb3N0U2lkZSIsIlRvcG9sb2d5RXhjZXB0aW9uIiwibXNnIiwibXNnV2l0aENvb3JkIiwiTGlua2VkTGlzdCIsImFkZExhc3QiLCJyZW1vdmVGaXJzdCIsInNoaWZ0IiwiQnVmZmVyU3ViZ3JhcGgiLCJfZmluZGVyIiwiX2RpckVkZ2VMaXN0IiwiX25vZGVzIiwiX3JpZ2h0TW9zdENvb3JkIiwiX2VudiIsImNsZWFyVmlzaXRlZEVkZ2VzIiwic2V0VmlzaXRlZCIsImdldFJpZ2h0bW9zdENvb3JkaW5hdGUiLCJjb21wdXRlTm9kZURlcHRoIiwic3RhcnRFZGdlIiwiaXNWaXNpdGVkIiwiY29tcHV0ZURlcHRocyIsImRlJDEiLCJjb3B5U3ltRGVwdGhzIiwiY29tcHV0ZURlcHRoIiwib3V0c2lkZURlcHRoIiwic2V0RWRnZURlcHRocyIsImFkZFJlYWNoYWJsZSIsImZpbmRSZXN1bHRFZGdlcyIsImdldERlcHRoIiwiaXNJbnRlcmlvckFyZWFFZGdlIiwic2V0SW5SZXN1bHQiLCJub2Rlc1Zpc2l0ZWQiLCJub2RlUXVldWUiLCJzdGFydE5vZGUiLCJzeW0iLCJhZGpOb2RlIiwiZ3JhcGgiLCJlZGdlRW52IiwiZGlyRWRnZSIsIm5vZGVTdGFjayIsInNldERlcHRoIiwic3ltTm9kZSIsImdldE5vZGVzIiwiZ2V0RGlyZWN0ZWRFZGdlcyIsIlRvcG9sb2d5TG9jYXRpb24iLCJsb2NhdGlvbiIsIm9uIiwiZ2wiLCJvbiQxIiwic2V0QWxsTG9jYXRpb25zIiwibG9jVmFsdWUiLCJzZXRBbGxMb2NhdGlvbnNJZk51bGwiLCJpc0xpbmUiLCJtZXJnZSIsIm5ld0xvYyIsImdldExvY2F0aW9ucyIsImZsaXAiLCJ0ZW1wIiwic2V0TG9jYXRpb25zIiwicG9zSW5kZXgiLCJpc0FyZWEiLCJpc0FueU51bGwiLCJzZXRMb2NhdGlvbiIsImxvY0luZGV4IiwibG9jVmFsdWUkMSIsImlzRXF1YWxPblNpZGUiLCJhbGxQb3NpdGlvbnNFcXVhbCIsImxvYyIsIkxhYmVsIiwiZWx0Iiwib25Mb2MiLCJsYmwiLCJnZW9tSW5kZXgiLCJvbkxvYyQxIiwib25Mb2MkMiIsImxlZnRMb2MiLCJyaWdodExvYyIsImdlb21JbmRleCQxIiwib25Mb2MkMyIsImxlZnRMb2MkMSIsInJpZ2h0TG9jJDEiLCJnZXRHZW9tZXRyeUNvdW50IiwibG9jYXRpb24kMSIsInRvTGluZSIsInRvTGluZUxhYmVsIiwibGFiZWwiLCJsaW5lTGFiZWwiLCJFZGdlUmluZyIsIl9zdGFydERlIiwiX21heE5vZGVEZWdyZWUiLCJfZWRnZXMiLCJfcHRzIiwiX2xhYmVsIiwiX3JpbmciLCJfaXNIb2xlIiwiX2dlb21ldHJ5RmFjdG9yeSIsImNvbXB1dGVQb2ludHMiLCJjb21wdXRlUmluZyIsImlzSXNvbGF0ZWQiLCJpc0ZpcnN0RWRnZSIsImdldEVkZ2VSaW5nIiwiZ2V0TGFiZWwiLCJtZXJnZUxhYmVsIiwiYWRkUG9pbnRzIiwic2V0RWRnZVJpbmciLCJnZXROZXh0IiwiZ2V0TGluZWFyUmluZyIsImNvbXB1dGVNYXhOb2RlRGVncmVlIiwiZGVncmVlIiwiZ2V0T3V0Z29pbmdEZWdyZWUiLCJlZGdlIiwiZWRnZVB0cyIsInN0YXJ0SW5kZXgiLCJzdGFydEluZGV4JDEiLCJpc0hvbGUiLCJjb250YWluc1BvaW50IiwiYWRkSG9sZSIsImlzU2hlbGwiLCJnZXRNYXhOb2RlRGVncmVlIiwiZ2V0U2hlbGwiLCJkZUxhYmVsIiwiZGVMYWJlbCQxIiwic2V0U2hlbGwiLCJ0b1BvbHlnb24iLCJob2xlTFIiLCJNaW5pbWFsRWRnZVJpbmciLCJFZGdlUmluZyQkMSIsImVyIiwic2V0TWluRWRnZVJpbmciLCJnZXROZXh0TWluIiwiTWF4aW1hbEVkZ2VSaW5nIiwiYnVpbGRNaW5pbWFsUmluZ3MiLCJtaW5FZGdlUmluZ3MiLCJnZXRNaW5FZGdlUmluZyIsIm1pbkVyIiwibGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzIiwibGlua01pbmltYWxEaXJlY3RlZEVkZ2VzIiwiR3JhcGhDb21wb25lbnQiLCJfaXNJblJlc3VsdCIsIl9pc0NvdmVyZWQiLCJfaXNDb3ZlcmVkU2V0IiwiX2lzVmlzaXRlZCIsImlzSW5SZXN1bHQiLCJpc0NvdmVyZWQiLCJpc0NvdmVyZWRTZXQiLCJzZXRMYWJlbCIsInNldENvdmVyZWQiLCJ1cGRhdGVJTSIsImltIiwiY29tcHV0ZUlNIiwiTm9kZSIsIkdyYXBoQ29tcG9uZW50JCQxIiwiX2Nvb3JkIiwiZWRnZXMiLCJpc0luY2lkZW50RWRnZUluUmVzdWx0IiwicHJpbnQiLCJjb21wdXRlTWVyZ2VkTG9jYXRpb24iLCJsYWJlbDIiLCJlbHRJbmRleCIsIm5Mb2MiLCJhcmdJbmRleCIsIm9uTG9jYXRpb24iLCJ0aGlzTG9jIiwiaW5zZXJ0Iiwic2V0Tm9kZSIsInNldExhYmVsQm91bmRhcnkiLCJOb2RlTWFwIiwibm9kZU1hcCIsIm5vZGVGYWN0IiwiZmluZCIsImFkZE5vZGUiLCJjcmVhdGVOb2RlIiwibm9kZSQxIiwiZ2V0Qm91bmRhcnlOb2RlcyIsImJkeU5vZGVzIiwiUXVhZHJhbnQiLCJzdGF0aWNBY2Nlc3NvcnMkMjEiLCJORSIsIk5XIiwiU1ciLCJTRSIsImlzTm9ydGhlcm4iLCJxdWFkIiwiaXNPcHBvc2l0ZSIsInF1YWQxIiwicXVhZDIiLCJkaWZmIiwiY29tbW9uSGFsZlBsYW5lIiwiaXNJbkhhbGZQbGFuZSIsImhhbGZQbGFuZSIsInF1YWRyYW50IiwiRWRnZUVuZCIsIl9lZGdlIiwiX25vZGUiLCJfcDAiLCJfcDEiLCJfZHgiLCJfZHkiLCJfcXVhZHJhbnQiLCJlZGdlJDEiLCJlZGdlJDIiLCJwMCQxIiwibGFiZWwkMSIsImNvbXBhcmVEaXJlY3Rpb24iLCJnZXREeSIsImFuZ2xlIiwiYXRhbjIiLCJjbGFzc05hbWUiLCJsYXN0RG90UG9zIiwibGFzdEluZGV4T2YiLCJnZXREaXJlY3RlZENvb3JkaW5hdGUiLCJnZXREeCIsImdldFF1YWRyYW50IiwiY29tcHV0ZUxhYmVsIiwiYm91bmRhcnlOb2RlUnVsZSIsIkRpcmVjdGVkRWRnZSIsIkVkZ2VFbmQkJDEiLCJfaXNGb3J3YXJkIiwiX3N5bSIsIl9uZXh0IiwiX25leHRNaW4iLCJfZWRnZVJpbmciLCJfbWluRWRnZVJpbmciLCJfZGVwdGgiLCJjb21wdXRlRGlyZWN0ZWRMYWJlbCIsImRlcHRoVmFsIiwic2V0TmV4dE1pbiIsIm5leHRNaW4iLCJnZXREZXB0aERlbHRhIiwibWluRWRnZVJpbmciLCJpc0xpbmVFZGdlIiwiaXNFeHRlcmlvcklmQXJlYTAiLCJpc0V4dGVyaW9ySWZBcmVhMSIsImVkZ2VSaW5nIiwiZGVwdGhEZWx0YSIsInByaW50RWRnZSIsInByaW50UmV2ZXJzZSIsInNldFN5bSIsInNldFZpc2l0ZWRFZGdlIiwiZGlyZWN0aW9uRmFjdG9yIiwib3Bwb3NpdGVQb3MiLCJkZWx0YSIsIm9wcG9zaXRlRGVwdGgiLCJzZXROZXh0IiwiZGVwdGhGYWN0b3IiLCJjdXJyTG9jYXRpb24iLCJuZXh0TG9jYXRpb24iLCJOb2RlRmFjdG9yeSIsIlBsYW5hckdyYXBoIiwiX2VkZ2VFbmRMaXN0IiwicHJpbnRFZGdlcyIsImVpTGlzdCIsImdldE5vZGVJdGVyYXRvciIsImxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzIiwibm9kZWl0IiwiZGVidWdQcmludGxuIiwiaXNCb3VuZGFyeU5vZGUiLCJsaW5rQWxsRGlyZWN0ZWRFZGdlcyIsIm1hdGNoSW5TYW1lRGlyZWN0aW9uIiwiZXAwIiwiZXAxIiwiZ2V0RWRnZUVuZHMiLCJkZWJ1Z1ByaW50IiwiZ2V0RWRnZUl0ZXJhdG9yIiwiZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24iLCJlQ29vcmQiLCJpbnNlcnRFZGdlIiwiZmluZEVkZ2VFbmQiLCJlZSIsImFkZEVkZ2VzIiwiZWRnZXNUb0FkZCIsImRlMSIsImRlMiIsIm5vZGVzIiwiUG9seWdvbkJ1aWxkZXIiLCJfc2hlbGxMaXN0Iiwic29ydFNoZWxsc0FuZEhvbGVzIiwiZWRnZVJpbmdzIiwic2hlbGxMaXN0IiwiZnJlZUhvbGVMaXN0IiwiY29tcHV0ZVBvbHlnb25zIiwicmVzdWx0UG9seUxpc3QiLCJwbGFjZUZyZWVIb2xlcyIsImZpbmRFZGdlUmluZ0NvbnRhaW5pbmciLCJidWlsZE1pbmltYWxFZGdlUmluZ3MiLCJtYXhFZGdlUmluZ3MiLCJmaW5kU2hlbGwiLCJwbGFjZVBvbHlnb25Ib2xlcyIsImJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyIsImRpckVkZ2VzIiwiZ2V0UG9seWdvbnMiLCJ0ZXN0RXIiLCJ0ZXN0UmluZyIsInRlc3RFbnYiLCJtaW5TaGVsbCIsIm1pbkVudiIsInRyeVNoZWxsIiwidHJ5UmluZyIsInRyeUVudiIsImlzQ29udGFpbmVkIiwic2hlbGxDb3VudCIsIkJvdW5kYWJsZSIsImdldEJvdW5kcyIsIkl0ZW1Cb3VuZGFibGUiLCJfYm91bmRzIiwiX2l0ZW0iLCJib3VuZHMiLCJpdGVtIiwiZ2V0SXRlbSIsIlByaW9yaXR5UXVldWUiLCJfc2l6ZSIsIl9pdGVtcyIsInBvbGwiLCJtaW5JdGVtIiwicmVvcmRlciIsImNoaWxkIiwiSXRlbVZpc2l0b3IiLCJ2aXNpdEl0ZW0iLCJTcGF0aWFsSW5kZXgiLCJpdGVtRW52IiwicXVlcnkiLCJBYnN0cmFjdE5vZGUiLCJfY2hpbGRCb3VuZGFibGVzIiwiX2xldmVsIiwibGV2ZWwiLCJzdGF0aWNBY2Nlc3NvcnMkMjIiLCJnZXRMZXZlbCIsImdldENoaWxkQm91bmRhYmxlcyIsImFkZENoaWxkQm91bmRhYmxlIiwiY2hpbGRCb3VuZGFibGUiLCJjb21wdXRlQm91bmRzIiwiQ29sbGVjdGlvbnMiLCJyZXZlcnNlT3JkZXIiLCJhbGVuIiwic2luZ2xldG9uTGlzdCIsIkJvdW5kYWJsZVBhaXIiLCJfYm91bmRhYmxlMSIsIl9ib3VuZGFibGUyIiwiX2Rpc3RhbmNlIiwiX2l0ZW1EaXN0YW5jZSIsImJvdW5kYWJsZTEiLCJib3VuZGFibGUyIiwiaXRlbURpc3RhbmNlIiwiZXhwYW5kVG9RdWV1ZSIsInByaVEiLCJpc0NvbXAxIiwiaXNDb21wb3NpdGUiLCJpc0NvbXAyIiwiZXhwYW5kIiwiaXNMZWF2ZXMiLCJuZCIsImJuZENvbXBvc2l0ZSIsImJuZE90aGVyIiwiY2hpbGRyZW4iLCJicCIsImdldERpc3RhbmNlIiwiZ2V0Qm91bmRhYmxlIiwiQWJzdHJhY3RTVFJ0cmVlIiwiX3Jvb3QiLCJfYnVpbHQiLCJfaXRlbUJvdW5kYWJsZXMiLCJfbm9kZUNhcGFjaXR5Iiwibm9kZUNhcGFjaXR5IiwiREVGQVVMVF9OT0RFX0NBUEFDSVRZIiwibm9kZUNhcGFjaXR5JDEiLCJzdGF0aWNBY2Nlc3NvcnMkMjMiLCJJbnRlcnNlY3RzT3AiLCJnZXROb2RlQ2FwYWNpdHkiLCJsYXN0Tm9kZSIsImJ1aWxkIiwicmVtb3ZlSXRlbSIsImNoaWxkVG9SZW1vdmUiLCJpdGVtc1RyZWUiLCJ2YWx1ZXNUcmVlIiwidmFsdWVzVHJlZUZvck5vZGUiLCJ2YWx1ZXNUcmVlRm9yQ2hpbGQiLCJib3VuZGFibGVzQXRMZXZlbCIsImJvdW5kYWJsZXMiLCJsZXZlbCQxIiwidG9wIiwiYm91bmRhYmxlcyQxIiwiYm91bmRhYmxlIiwic2VhcmNoQm91bmRzIiwiZ2V0SW50ZXJzZWN0c09wIiwic2VhcmNoQm91bmRzJDEiLCJ2aXNpdG9yIiwic2VhcmNoQm91bmRzJDIiLCJ2aXNpdG9yJDEiLCJjaGlsZEJvdW5kYWJsZXMiLCJzZWFyY2hCb3VuZHMkMyIsIm1hdGNoZXMkMSIsImNoaWxkQm91bmRhYmxlcyQxIiwiY2hpbGRCb3VuZGFibGUkMSIsImNyZWF0ZUhpZ2hlckxldmVscyIsImdldFJvb3QiLCJpdGVtJDEiLCJjaGlsZFRvUHJ1bmUiLCJib3VuZGFibGVzT2ZBTGV2ZWwiLCJwYXJlbnRCb3VuZGFibGVzIiwiY3JlYXRlUGFyZW50Qm91bmRhYmxlcyIsIm1heENoaWxkRGVwdGgiLCJjaGlsZERlcHRoIiwibmV3TGV2ZWwiLCJzb3J0ZWRDaGlsZEJvdW5kYWJsZXMiLCJnZXRDb21wYXJhdG9yIiwiY29tcGFyZURvdWJsZXMiLCJJdGVtRGlzdGFuY2UiLCJpdGVtMSIsIml0ZW0yIiwiU1RSdHJlZSIsIkFic3RyYWN0U1RSdHJlZSQkMSIsIlNUUnRyZWVOb2RlIiwieENvbXBhcmF0b3IiLCJ5Q29tcGFyYXRvciIsImludGVyc2VjdHNPcCIsImNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMiLCJ2ZXJ0aWNhbFNsaWNlcyIsImNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSIsInNsaWNlQ291bnQiLCJzbGljZUNhcGFjaXR5Iiwic2xpY2VzIiwiYm91bmRhYmxlc0FkZGVkVG9TbGljZSIsInNlYXJjaEVudiIsInNlYXJjaEVudiQxIiwibWluTGVhZkNvdW50IiwibmVhcmVzdE5laWdoYm91ciIsIml0ZW1EaXN0IiwiaW5pdEJuZFBhaXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInRyZWUiLCJpdGVtRGlzdCQxIiwiYnAkMSIsImluaXRCbmRQYWlyJDEiLCJtYXhEaXN0YW5jZSIsImRpc3RhbmNlTG93ZXJCb3VuZCIsIm1pblBhaXIiLCJibmRQYWlyIiwiY3VycmVudERpc3RhbmNlIiwiaXRlbURpc3QkMiIsImJuZCIsImJwJDIiLCJjZW50cmVYIiwiYXZnIiwiY2VudHJlWSIsImFCb3VuZHMiLCJiQm91bmRzIiwiQWJzdHJhY3ROb2RlJCQxIiwiU2VnbWVudFBvaW50Q29tcGFyYXRvciIsInJlbGF0aXZlU2lnbiIsIm9jdGFudCIsInhTaWduIiwieVNpZ24iLCJjb21wYXJlVmFsdWUiLCJjb21wYXJlU2lnbjAiLCJjb21wYXJlU2lnbjEiLCJTZWdtZW50Tm9kZSIsIl9zZWdTdHJpbmciLCJfc2VnbWVudE9jdGFudCIsIl9pc0ludGVyaW9yIiwic2VnU3RyaW5nIiwic2VnbWVudE9jdGFudCIsIm1heFNlZ21lbnRJbmRleCIsImlzSW50ZXJpb3IiLCJTZWdtZW50Tm9kZUxpc3QiLCJfbm9kZU1hcCIsImdldFNwbGl0Q29vcmRpbmF0ZXMiLCJhZGRFbmRwb2ludHMiLCJlaVByZXYiLCJlaSIsImFkZEVkZ2VDb29yZGluYXRlcyIsImFkZENvbGxhcHNlZE5vZGVzIiwiY29sbGFwc2VkVmVydGV4SW5kZXhlcyIsImZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlcyIsImZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyIsInZlcnRleEluZGV4IiwiZWkwIiwiZWkxIiwibGFzdFNlZ1N0YXJ0UHQiLCJ1c2VJbnRQdDEiLCJhZGRTcGxpdEVkZ2VzIiwiZWRnZUxpc3QiLCJuZXdFZGdlIiwiY3JlYXRlU3BsaXRFZGdlIiwiZmluZENvbGxhcHNlSW5kZXgiLCJjb2xsYXBzZWRWZXJ0ZXhJbmRleCIsIm51bVZlcnRpY2VzQmV0d2VlbiIsImlzQ29sbGFwc2VkIiwibWF4U2VnSW5kZXgiLCJpcHQiLCJOb2RlZFNlZ21lbnRTdHJpbmciLCJnZXREYXRhIiwiZWlOZXciLCJnZXRTZWdtZW50T2N0YW50IiwiY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3MiLCJzcGxpdEVkZ2VzIiwic3BsaXQwIiwicHQwIiwic3BsaXRuIiwic3BsaXRuUHRzIiwicHRuIiwiT2N0YW50IiwiYWR4IiwiYWR5IiwiZHgkMSIsImR5JDEiLCJTZWdtZW50U3RyaW5nIiwic2V0RGF0YSIsIk5vZGFibGVTZWdtZW50U3RyaW5nIiwiYWRkSW50ZXJzZWN0aW9uIiwiX25vZGVMaXN0IiwiX2RhdGEiLCJzYWZlT2N0YW50IiwiaW50UHQkMSIsImFkZEludGVyc2VjdGlvbk5vZGUiLCJsaSIsInNlZ21lbnRJbmRleCQxIiwiZ2V0Tm9kZUxpc3QiLCJub3JtYWxpemVkU2VnbWVudEluZGV4IiwibmV4dFNlZ0luZGV4IiwibmV4dFB0IiwiYWRkSW50ZXJzZWN0aW9ucyIsImdldE5vZGVkU3Vic3RyaW5ncyIsInNlZ1N0cmluZ3MiLCJyZXN1bHRFZGdlbGlzdCIsInNlZ1N0cmluZ3MkMSIsInJlc3VsdEVkZ2VsaXN0JDEiLCJzcyIsIkxpbmVTZWdtZW50Iiwic3RhdGljQWNjZXNzb3JzJDI0IiwibWluWCIsInNlZyIsIm9yaWVudDAiLCJvcmllbnQxIiwiZ2VvbUZhY3RvcnkiLCJpc1ZlcnRpY2FsIiwicHJvamVjdCIsInByb2plY3Rpb25GYWN0b3IiLCJwZjAiLCJwZjEiLCJuZXdwMCIsIm5ld3AxIiwiZGlzdGFuY2VQZXJwZW5kaWN1bGFyIiwibWluWSIsIm1pZFBvaW50IiwiY2xvc2VzdFBvaW50cyIsImNsb3Nlc3RQdCIsImNsb3NlMDAiLCJjbG9zZXN0UG9pbnQiLCJjbG9zZTAxIiwiY2xvc2UxMCIsImNsb3NlMTEiLCJmYWN0b3IiLCJtYXhYIiwiY29tcDAiLCJsaW5lSW50ZXJzZWN0aW9uIiwibWF4WSIsInBvaW50QWxvbmdPZmZzZXQiLCJzZWdtZW50TGVuZ3RoRnJhY3Rpb24iLCJvZmZzZXREaXN0YW5jZSIsInNlZ3giLCJzZWd5IiwidXgiLCJ1eSIsIm9mZnNldHgiLCJvZmZzZXR5Iiwic2V0Q29vcmRpbmF0ZXMiLCJzZWdtZW50RnJhY3Rpb24iLCJpbnB1dFB0Iiwic2VnRnJhYyIsImlzSG9yaXpvbnRhbCIsInBvaW50QWxvbmciLCJiaXRzMCIsImhhc2gwIiwiYml0czEiLCJoYXNoMSIsIk1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uIiwidGVtcEVudjEiLCJ0ZW1wRW52MiIsIl9vdmVybGFwU2VnMSIsIl9vdmVybGFwU2VnMiIsIm92ZXJsYXAiLCJtYzEiLCJzdGFydDEiLCJtYzIiLCJzdGFydDIiLCJnZXRMaW5lU2VnbWVudCIsIk1vbm90b25lQ2hhaW4iLCJfc3RhcnQiLCJfZW5kIiwiX2NvbnRleHQiLCJfaWQiLCJjb250ZXh0IiwiY29tcHV0ZVNlbGVjdCIsInN0YXJ0MCIsImVuZDAiLCJtY3MiLCJzZWxlY3QiLCJjb21wdXRlT3ZlcmxhcHMiLCJtYyIsIm1jbyIsImNvbXB1dGVPdmVybGFwc0ludGVybmFsIiwic2V0SWQiLCJpZCIsImdldEVuZEluZGV4IiwiZ2V0U3RhcnRJbmRleCIsImdldENvbnRleHQiLCJnZXRJZCIsImVuZDEiLCJwMDAiLCJwMDEiLCJwMTAiLCJwMTEiLCJtaWQwIiwibWlkMSIsIk1vbm90b25lQ2hhaW5CdWlsZGVyIiwiZ2V0Q2hhaW5TdGFydEluZGljZXMiLCJzdGFydEluZGV4TGlzdCIsImZpbmRDaGFpbkVuZCIsInRvSW50QXJyYXkiLCJzYWZlU3RhcnQiLCJjaGFpblF1YWQiLCJnZXRDaGFpbnMiLCJwdHMkMSIsIm1jTGlzdCIsImxpc3QiLCJOb2RlciIsImNvbXB1dGVOb2RlcyIsIlNpbmdsZVBhc3NOb2RlciIsIl9zZWdJbnQiLCJzZWdJbnQiLCJzZXRTZWdtZW50SW50ZXJzZWN0b3IiLCJNQ0luZGV4Tm9kZXIiLCJTaW5nbGVQYXNzTm9kZXIkJDEiLCJzaSIsIl9tb25vQ2hhaW5zIiwiX2luZGV4IiwiX2lkQ291bnRlciIsIl9ub2RlZFNlZ1N0cmluZ3MiLCJfbk92ZXJsYXBzIiwiU2VnbWVudE92ZXJsYXBBY3Rpb24iLCJnZXRNb25vdG9uZUNoYWlucyIsImdldEluZGV4Iiwic2VnU3RyIiwic2VnQ2hhaW5zIiwiaW5wdXRTZWdTdHJpbmdzIiwiaW50ZXJzZWN0Q2hhaW5zIiwib3ZlcmxhcEFjdGlvbiIsInF1ZXJ5Q2hhaW4iLCJvdmVybGFwQ2hhaW5zIiwidGVzdENoYWluIiwiTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEiLCJfc2kiLCJzczEiLCJzczIiLCJwcm9jZXNzSW50ZXJzZWN0aW9ucyIsIkJ1ZmZlclBhcmFtZXRlcnMiLCJfcXVhZHJhbnRTZWdtZW50cyIsIkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMiLCJfZW5kQ2FwU3R5bGUiLCJDQVBfUk9VTkQiLCJfam9pblN0eWxlIiwiSk9JTl9ST1VORCIsIl9taXRyZUxpbWl0IiwiREVGQVVMVF9NSVRSRV9MSU1JVCIsIl9pc1NpbmdsZVNpZGVkIiwiX3NpbXBsaWZ5RmFjdG9yIiwiREVGQVVMVF9TSU1QTElGWV9GQUNUT1IiLCJxdWFkcmFudFNlZ21lbnRzIiwic2V0UXVhZHJhbnRTZWdtZW50cyIsInF1YWRyYW50U2VnbWVudHMkMSIsImVuZENhcFN0eWxlIiwic2V0RW5kQ2FwU3R5bGUiLCJxdWFkcmFudFNlZ21lbnRzJDIiLCJlbmRDYXBTdHlsZSQxIiwiam9pblN0eWxlIiwibWl0cmVMaW1pdCIsInNldEpvaW5TdHlsZSIsInNldE1pdHJlTGltaXQiLCJzdGF0aWNBY2Nlc3NvcnMkMjUiLCJDQVBfRkxBVCIsIkNBUF9TUVVBUkUiLCJKT0lOX01JVFJFIiwiSk9JTl9CRVZFTCIsImdldEVuZENhcFN0eWxlIiwiaXNTaW5nbGVTaWRlZCIsInF1YWRTZWdzIiwiZ2V0Sm9pblN0eWxlIiwic2V0U2ltcGxpZnlGYWN0b3IiLCJzaW1wbGlmeUZhY3RvciIsImdldFNpbXBsaWZ5RmFjdG9yIiwiZ2V0UXVhZHJhbnRTZWdtZW50cyIsImdldE1pdHJlTGltaXQiLCJzZXRTaW5nbGVTaWRlZCIsImJ1ZmZlckRpc3RhbmNlRXJyb3IiLCJhbHBoYSIsImNvcyIsIkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIiLCJpbnB1dExpbmUiLCJfZGlzdGFuY2VUb2wiLCJfaXNEZWxldGVkIiwiX2FuZ2xlT3JpZW50YXRpb24iLCJfaW5wdXRMaW5lIiwic3RhdGljQWNjZXNzb3JzJDI2IiwiSU5JVCIsIkRFTEVURSIsIktFRVAiLCJOVU1fUFRTX1RPX0NIRUNLIiwiaXNEZWxldGFibGUiLCJpMCIsImRpc3RhbmNlVG9sIiwiaXNDb25jYXZlIiwiaXNTaGFsbG93IiwiaXNTaGFsbG93U2FtcGxlZCIsImRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcyIsIm1pZEluZGV4IiwiZmluZE5leHROb25EZWxldGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJpc01pZGRsZVZlcnRleERlbGV0ZWQiLCJpc1NoYWxsb3dDb25jYXZpdHkiLCJpc0FuZ2xlVG9TaW1wbGlmeSIsInNpbXBsaWZ5IiwiY29sbGFwc2VMaW5lIiwic2ltcCIsIk9mZnNldFNlZ21lbnRTdHJpbmciLCJfcHRMaXN0IiwiX21pbmltaW1WZXJ0ZXhEaXN0YW5jZSIsInN0YXRpY0FjY2Vzc29ycyQyOCIsIkNPT1JESU5BVEVfQVJSQVlfVFlQRSIsImFkZFB0IiwiYnVmUHQiLCJpc1JlZHVuZGFudCIsInJldmVyZSIsImFkZFB0cyIsImxhc3RQdCIsInB0RGlzdCIsInN0YXJ0UHQiLCJzZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UiLCJtaW5pbWltVmVydGV4RGlzdGFuY2UiLCJBbmdsZSIsInN0YXRpY0FjY2Vzc29ycyQyOSIsIlBJX1RJTUVTXzIiLCJQSV9PVkVSXzIiLCJQSV9PVkVSXzQiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiaXNBY3V0ZSIsImR4MCIsImR5MCIsImRvdHByb2QiLCJpc09idHVzZSIsImludGVyaW9yQW5nbGUiLCJhbmdsZVByZXYiLCJhbmdsZU5leHQiLCJub3JtYWxpemVQb3NpdGl2ZSIsImFuZ2xlQmV0d2VlbiIsInRpcDEiLCJ0YWlsIiwidGlwMiIsImExIiwiYTIiLCJhbmcxIiwiYW5nMiIsImRlbEFuZ2xlIiwidG9SYWRpYW5zIiwiYW5nbGVEZWdyZWVzIiwiZ2V0VHVybiIsImNyb3NzcHJvZHVjdCIsInNpbiIsImFuZ2xlQmV0d2Vlbk9yaWVudGVkIiwiYW5nRGVsIiwiT2Zmc2V0U2VnbWVudEdlbmVyYXRvciIsIl9tYXhDdXJ2ZVNlZ21lbnRFcnJvciIsIl9maWxsZXRBbmdsZVF1YW50dW0iLCJfY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciIsIl9zZWdMaXN0IiwiX2J1ZlBhcmFtcyIsIl9saSIsIl9zMCIsIl9zMSIsIl9zMiIsIl9zZWcwIiwiX3NlZzEiLCJfb2Zmc2V0MCIsIl9vZmZzZXQxIiwiX3NpZGUiLCJfaGFzTmFycm93Q29uY2F2ZUFuZ2xlIiwiYnVmUGFyYW1zIiwiTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IiLCJzdGF0aWNBY2Nlc3NvcnMkMjciLCJPRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUiIsIklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUiIsIkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUiIsImFkZE5leHRTZWdtZW50IiwiYWRkU3RhcnRQb2ludCIsImNvbXB1dGVPZmZzZXRTZWdtZW50Iiwib3V0c2lkZVR1cm4iLCJhZGRDb2xsaW5lYXIiLCJhZGRPdXRzaWRlVHVybiIsImFkZEluc2lkZVR1cm4iLCJhZGRMaW5lRW5kQ2FwIiwib2Zmc2V0TCIsIm9mZnNldFIiLCJhZGRGaWxsZXRBcmMiLCJzcXVhcmVDYXBTaWRlT2Zmc2V0Iiwic3F1YXJlQ2FwTE9mZnNldCIsInNxdWFyZUNhcFJPZmZzZXQiLCJhZGRNaXRyZUpvaW4iLCJvZmZzZXQwIiwib2Zmc2V0MSIsImlzTWl0cmVXaXRoaW5MaW1pdCIsIm1pdHJlUmF0aW8iLCJhZGRMaW1pdGVkTWl0cmVKb2luIiwiYWRkRmlsbGV0Q29ybmVyIiwicmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYWRkQmV2ZWxKb2luIiwiY3JlYXRlU3F1YXJlIiwiYWRkU2VnbWVudHMiLCJhZGRGaXJzdFNlZ21lbnQiLCJhZGRMYXN0U2VnbWVudCIsImluaXRTaWRlU2VnbWVudHMiLCJzMSIsInMyIiwiYmFzZVB0IiwiYW5nMCIsImFuZ0RpZmYiLCJhbmdEaWZmSGFsZiIsIm1pZEFuZyIsIm1pdHJlTWlkQW5nIiwibWl0cmVEaXN0IiwiYmV2ZWxEZWx0YSIsImJldmVsSGFsZkxlbiIsImJldmVsTWlkWCIsImJldmVsTWlkWSIsImJldmVsTWlkUHQiLCJtaXRyZU1pZExpbmUiLCJiZXZlbEVuZExlZnQiLCJiZXZlbEVuZFJpZ2h0Iiwib2Zmc2V0Iiwic2lkZVNpZ24iLCJ0b3RhbEFuZ2xlIiwiblNlZ3MiLCJpbml0QW5nbGUiLCJjdXJyQW5nbGVJbmMiLCJjdXJyQW5nbGUiLCJjcmVhdGVDaXJjbGUiLCJudW1JbnQiLCJoYXNOYXJyb3dDb25jYXZlQW5nbGUiLCJPZmZzZXRDdXJ2ZUJ1aWxkZXIiLCJnZXRPZmZzZXRDdXJ2ZSIsImlucHV0UHRzIiwiaXNSaWdodFNpZGUiLCJwb3NEaXN0YW5jZSIsInNlZ0dlbiIsImdldFNlZ0dlbiIsImNvbXB1dGVQb2ludEN1cnZlIiwiY29tcHV0ZU9mZnNldEN1cnZlIiwiY3VydmVQdHMiLCJjb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSIsImRpc3RUb2wiLCJzaW1wbGlmeVRvbGVyYW5jZSIsInNpbXAyIiwic2ltcDEiLCJjb21wdXRlUmluZ0J1ZmZlckN1cnZlIiwiY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSIsImdldExpbmVDdXJ2ZSIsImxpbmVDb29yZCIsImdldEJ1ZmZlclBhcmFtZXRlcnMiLCJidWZEaXN0YW5jZSIsImdldFJpbmdDdXJ2ZSIsImNvcHlDb29yZGluYXRlcyIsIlN1YmdyYXBoRGVwdGhMb2NhdGVyIiwiX3N1YmdyYXBocyIsIl9zZWciLCJfY2dhIiwic3ViZ3JhcGhzIiwic3RhdGljQWNjZXNzb3JzJDMwIiwiRGVwdGhTZWdtZW50IiwiZmluZFN0YWJiZWRTZWdtZW50cyIsInN0YWJiaW5nUmF5TGVmdFB0Iiwic3RhYmJlZFNlZ21lbnRzIiwiYnNnIiwic3RhYmJpbmdSYXlMZWZ0UHQkMSIsInN0YWJiZWRTZWdtZW50cyQxIiwiZHMiLCJzdGFiYmluZ1JheUxlZnRQdCQyIiwic3RhYmJlZFNlZ21lbnRzJDIiLCJfbGVmdERlcHRoIiwiX3Vwd2FyZFNlZyIsIm9yaWVudEluZGV4IiwiY29tcGFyZVgiLCJzZWcwIiwic2VnMSIsImNvbXBhcmUwIiwiVHJpYW5nbGUiLCJpbnRlcnBvbGF0ZVoiLCJsb25nZXN0U2lkZUxlbmd0aCIsImNpcmN1bWNlbnRyZSIsImFyZWEzRCIsImNlbnRyb2lkIiwiaW5DZW50cmUiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJ2MCIsImxlbkFCIiwibGVuQkMiLCJsZW5DQSIsIm1heExlbiIsImN4IiwiY3kiLCJheSIsImJ4IiwiYnkiLCJjY3giLCJjY3kiLCJwZXJwZW5kaWN1bGFyQmlzZWN0b3IiLCJsMSIsImwyIiwiYW5nbGVCaXNlY3RvciIsImxlbjAiLCJmcmFjIiwic3BsaXRQdCIsInV6IiwidngiLCJ2eSIsInZ6IiwiY3Jvc3N4IiwiY3Jvc3N5IiwiY3Jvc3N6IiwiYWJzU3EiLCJsZW4xIiwiY2lyY3VtIiwiaW5DZW50cmVYIiwiaW5DZW50cmVZIiwiT2Zmc2V0Q3VydmVTZXRCdWlsZGVyIiwiX2lucHV0R2VvbSIsIl9jdXJ2ZUJ1aWxkZXIiLCJfY3VydmVMaXN0IiwiaW5wdXRHZW9tIiwiY3VydmVCdWlsZGVyIiwiYWRkUG9pbnQiLCJjdXJ2ZSIsImFkZEN1cnZlIiwiYWRkUG9seWdvbiIsIm9mZnNldFNpZGUiLCJzaGVsbENvb3JkIiwiaXNFcm9kZWRDb21wbGV0ZWx5IiwiYWRkUG9seWdvblJpbmciLCJob2xlQ29vcmQiLCJpc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSIsInRyaWFuZ2xlQ29vcmQiLCJidWZmZXJEaXN0YW5jZSIsInRyaSIsImRpc3RUb0NlbnRyZSIsImFkZExpbmVTdHJpbmciLCJnZXRDdXJ2ZXMiLCJjd0xlZnRMb2MiLCJjd1JpZ2h0TG9jIiwiYWRkQ29sbGVjdGlvbiIsInJpbmdDb29yZCIsImVudk1pbkRpbWVuc2lvbiIsIlBvaW50T25HZW9tZXRyeUxvY2F0b3IiLCJsb2NhdGUiLCJHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvciIsIl9wYXJlbnQiLCJfYXRTdGFydCIsIl9tYXgiLCJfc3ViY29sbGVjdGlvbkl0ZXJhdG9yIiwiaXNBdG9taWMiLCJTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IiLCJjb250YWluc1BvaW50SW5Qb2x5Z29uIiwiZ2VvbWkiLCJnMiIsIkVkZ2VFbmRTdGFyIiwiX2VkZ2VNYXAiLCJfZWRnZUxpc3QiLCJfcHRJbkFyZWFMb2NhdGlvbiIsImdldE5leHRDVyIsImlOZXh0Q1ciLCJwcm9wYWdhdGVTaWRlTGFiZWxzIiwic3RhcnRMb2MiLCJjdXJyTG9jIiwiaXQkMSIsImlzQXJlYUxhYmVsc0NvbnNpc3RlbnQiLCJnZW9tR3JhcGgiLCJjb21wdXRlRWRnZUVuZExhYmVscyIsImdldEJvdW5kYXJ5Tm9kZVJ1bGUiLCJjaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50IiwibGFzdEVkZ2VJbmRleCIsInN0YXJ0TGFiZWwiLCJmaW5kSW5kZXgiLCJlU2VhcmNoIiwiZ2V0R2VvbWV0cnkiLCJjb21wdXRlTGFiZWxsaW5nIiwiaGFzRGltZW5zaW9uYWxDb2xsYXBzZUVkZ2UiLCJnZW9taSQxIiwiZ2V0RGVncmVlIiwiaW5zZXJ0RWRnZUVuZCIsIkRpcmVjdGVkRWRnZVN0YXIiLCJFZGdlRW5kU3RhciQkMSIsIl9yZXN1bHRBcmVhRWRnZUxpc3QiLCJfU0NBTk5JTkdfRk9SX0lOQ09NSU5HIiwiX0xJTktJTkdfVE9fT1VUR09JTkciLCJnZXRSZXN1bHRBcmVhRWRnZXMiLCJmaXJzdE91dCIsImluY29taW5nIiwic3RhdGUiLCJuZXh0T3V0IiwibmV4dEluIiwiZGUwIiwiZGVMYXN0IiwicXVhZDAiLCJ1cGRhdGVMYWJlbGxpbmciLCJub2RlTGFiZWwiLCJwcmV2T3V0IiwiZmlyc3RJbiIsImVkZ2VJbmRleCIsInN0YXJ0RGVwdGgiLCJ0YXJnZXRMYXN0RGVwdGgiLCJuZXh0RGVwdGgiLCJsYXN0RGVwdGgiLCJlbmRJbmRleCIsInN0YXJ0RGVwdGgkMSIsImN1cnJEZXB0aCIsIm5leHREZSIsIm1lcmdlU3ltTGFiZWxzIiwiZGVncmVlJDEiLCJmaW5kQ292ZXJlZExpbmVFZGdlcyIsIm5leHRPdXQkMSIsIm5leHRJbiQxIiwiZUxhYmVsIiwiZUxvYyIsIk92ZXJsYXlOb2RlRmFjdG9yeSIsIk5vZGVGYWN0b3J5JCQxIiwiT3JpZW50ZWRDb29yZGluYXRlQXJyYXkiLCJfb3JpZW50YXRpb24iLCJvY2EiLCJjb21wYXJlT3JpZW50ZWQiLCJvcmllbnRhdGlvbjEiLCJvcmllbnRhdGlvbjIiLCJsaW1pdDEiLCJsaW1pdDIiLCJjb21wUHQiLCJkb25lMSIsImRvbmUyIiwiRWRnZUxpc3QiLCJfb2NhTWFwIiwiZWRnZUNvbGwiLCJmaW5kRWRnZUluZGV4IiwiZmluZEVxdWFsRWRnZSIsIm1hdGNoRWRnZSIsIlNlZ21lbnRJbnRlcnNlY3RvciIsImUwIiwic2VnSW5kZXgwIiwiZTEiLCJzZWdJbmRleDEiLCJJbnRlcnNlY3Rpb25BZGRlciIsIl9oYXNJbnRlcnNlY3Rpb24iLCJfaGFzUHJvcGVyIiwiX2hhc1Byb3BlckludGVyaW9yIiwiX2hhc0ludGVyaW9yIiwiX3Byb3BlckludGVyc2VjdGlvblBvaW50IiwiX2lzU2VsZkludGVyc2VjdGlvbiIsIm51bUludGVyc2VjdGlvbnMiLCJudW1JbnRlcmlvckludGVyc2VjdGlvbnMiLCJudW1Qcm9wZXJJbnRlcnNlY3Rpb25zIiwibnVtVGVzdHMiLCJpc1RyaXZpYWxJbnRlcnNlY3Rpb24iLCJpc0FkamFjZW50U2VnbWVudHMiLCJnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCIsImhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uIiwiZ2V0TGluZUludGVyc2VjdG9yIiwiaGFzUHJvcGVySW50ZXJzZWN0aW9uIiwiaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24iLCJFZGdlSW50ZXJzZWN0aW9uIiwiZ2V0U2VnbWVudEluZGV4IiwiRWRnZUludGVyc2VjdGlvbkxpc3QiLCJFZGdlIiwiTW9ub3RvbmVDaGFpbkluZGV4ZXIiLCJNb25vdG9uZUNoYWluRWRnZSIsImVudjIiLCJtY2IiLCJjaGFpbkluZGV4IiwiY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbiIsImNoYWluSW5kZXgwIiwibWNlIiwiY2hhaW5JbmRleDEiLCJtY2UkMSIsImdldFN0YXJ0SW5kZXhlcyIsImNvbXB1dGVJbnRlcnNlY3RzIiwiRGVwdGgiLCJOVUxMX1ZBTFVFIiwic3RhdGljQWNjZXNzb3JzJDMxIiwiZGVwdGhWYWx1ZSIsIm1pbkRlcHRoIiwibmV3VmFsdWUiLCJnZXREZWx0YSIsImRlcHRoQXRMb2NhdGlvbiIsIl9tY2UiLCJfaXNJc29sYXRlZCIsIl9kZXB0aERlbHRhIiwiZ2V0Q29sbGFwc2VkRWRnZSIsIm5ld1B0cyIsIm5ld2UiLCJzZXRJc29sYXRlZCIsInNldE5hbWUiLCJpc0VxdWFsRm9yd2FyZCIsImlzRXF1YWxSZXZlcnNlIiwiaVJldiIsImdldE1heGltdW1TZWdtZW50SW5kZXgiLCJnZXRNb25vdG9uZUNoYWluRWRnZSIsImlzUG9pbnR3aXNlRXF1YWwiLCJzZXREZXB0aERlbHRhIiwiZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QiLCJzZXRBdExlYXN0SWZWYWxpZCIsIkJ1ZmZlckJ1aWxkZXIiLCJfd29ya2luZ1ByZWNpc2lvbk1vZGVsIiwiX3dvcmtpbmdOb2RlciIsIl9ncmFwaCIsInNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCIsImluc2VydFVuaXF1ZUVkZ2UiLCJleGlzdGluZ0VkZ2UiLCJleGlzdGluZ0xhYmVsIiwibGFiZWxUb01lcmdlIiwibWVyZ2VEZWx0YSIsImV4aXN0aW5nRGVsdGEiLCJuZXdEZWx0YSIsImJ1aWxkU3ViZ3JhcGhzIiwic3ViZ3JhcGhMaXN0IiwicG9seUJ1aWxkZXIiLCJwcm9jZXNzZWRHcmFwaHMiLCJzdWJncmFwaCIsImxvY2F0ZXIiLCJjcmVhdGVTdWJncmFwaHMiLCJjcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5IiwiZW1wdHlHZW9tIiwiZ2V0Tm9kZXIiLCJub2RlciIsImJ1ZmZlciIsImN1cnZlU2V0QnVpbGRlciIsImJ1ZmZlclNlZ1N0ckxpc3QiLCJjb21wdXRlTm9kZWRFZGdlcyIsInJlc3VsdEdlb20iLCJub2RlZFNlZ1N0cmluZ3MiLCJvbGRMYWJlbCIsInNldE5vZGVyIiwibExvYyIsInJMb2MiLCJjb252ZXJ0U2VnU3RyaW5ncyIsIlNjYWxlZE5vZGVyIiwiX25vZGVyIiwiX3NjYWxlRmFjdG9yIiwiX29mZnNldFgiLCJfb2Zmc2V0WSIsIl9pc1NjYWxlZCIsInNjYWxlRmFjdG9yIiwiaXNJbnRlZ2VyUHJlY2lzaW9uIiwibm9kZXIkMSIsInNjYWxlRmFjdG9yJDEiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInJlc2NhbGUiLCJub2RlZFNlZ21lbnRTdHJpbmdzIiwicm91bmRQdHMiLCJyb3VuZFB0c05vRHVwIiwic3BsaXRTUyIsImludFNlZ1N0cmluZ3MiLCJOb2RpbmdWYWxpZGF0b3IiLCJfc2VnU3RyaW5ncyIsInN0YXRpY0FjY2Vzc29ycyQzMyIsImNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zIiwic3MkMSIsImNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zIiwic3MwIiwic3MwJDEiLCJzczEkMSIsInB0czAiLCJjaGVja1ZhbGlkIiwiY2hlY2tDb2xsYXBzZXMiLCJjaGVja0NvbGxhcHNlIiwiSG90UGl4ZWwiLCJfcHQiLCJfb3JpZ2luYWxQdCIsIl9wdFNjYWxlZCIsIl9wMFNjYWxlZCIsIl9wMVNjYWxlZCIsIl9jb3JuZXIiLCJfc2FmZUVudiIsImluaXRDb3JuZXJzIiwic3RhdGljQWNjZXNzb3JzJDM0IiwiU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUiIsImludGVyc2VjdHNTY2FsZWQiLCJzZWdNaW54Iiwic2VnTWF4eCIsInNlZ01pbnkiLCJzZWdNYXh5IiwiaXNPdXRzaWRlUGl4ZWxFbnYiLCJpbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlIiwiY29weVNjYWxlZCIsInBTY2FsZWQiLCJnZXRTYWZlRW52ZWxvcGUiLCJzYWZlVG9sZXJhbmNlIiwiaW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSIsImludGVyc2VjdHNMZWZ0IiwiaW50ZXJzZWN0c0JvdHRvbSIsImFkZFNuYXBwZWROb2RlIiwic2VnSW5kZXgiLCJNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uIiwic2VsZWN0ZWRTZWdtZW50IiwiTUNJbmRleFBvaW50U25hcHBlciIsInN0YXRpY0FjY2Vzc29ycyQzNSIsIkhvdFBpeGVsU25hcEFjdGlvbiIsInNuYXAiLCJob3RQaXhlbCIsImhvdFBpeGVsJDEiLCJwYXJlbnRFZGdlIiwiaG90UGl4ZWxWZXJ0ZXhJbmRleCIsInBpeGVsRW52IiwiaG90UGl4ZWxTbmFwQWN0aW9uIiwiaXNOb2RlQWRkZWQiLCJNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxIiwiX2hvdFBpeGVsIiwiX3BhcmVudEVkZ2UiLCJfaG90UGl4ZWxWZXJ0ZXhJbmRleCIsIl9pc05vZGVBZGRlZCIsIkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIiLCJfaW50ZXJpb3JJbnRlcnNlY3Rpb25zIiwiZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zIiwiTUNJbmRleFNuYXBSb3VuZGVyIiwiX3BtIiwiX3BvaW50U25hcHBlciIsImNoZWNrQ29ycmVjdG5lc3MiLCJpbnB1dFNlZ21lbnRTdHJpbmdzIiwicmVzdWx0U2VnU3RyaW5ncyIsIm52Iiwic25hcFJvdW5kIiwiaW50ZXJzZWN0aW9ucyIsImZpbmRJbnRlcmlvckludGVyc2VjdGlvbnMiLCJjb21wdXRlSW50ZXJzZWN0aW9uU25hcHMiLCJjb21wdXRlVmVydGV4U25hcHMiLCJpbnRGaW5kZXJBZGRlciIsImVkZ2UwIiwic25hcFB0cyIsInNuYXBQdCIsIkJ1ZmZlck9wIiwiX2FyZ0dlb20iLCJfcmVzdWx0R2VvbWV0cnkiLCJfc2F2ZUV4Y2VwdGlvbiIsInN0YXRpY0FjY2Vzc29ycyQzMiIsIkNBUF9CVVRUIiwiTUFYX1BSRUNJU0lPTl9ESUdJVFMiLCJidWZmZXJGaXhlZFByZWNpc2lvbiIsImZpeGVkUE0iLCJidWZCdWlsZGVyIiwiYnVmZmVyUmVkdWNlZFByZWNpc2lvbiIsInByZWNEaWdpdHMiLCJwcmVjaXNpb25EaWdpdHMiLCJzaXplQmFzZWRTY2FsZUZhY3RvciIsInByZWNpc2lvblNjYWxlRmFjdG9yIiwiY29tcHV0ZUdlb21ldHJ5IiwiYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24iLCJhcmdQTSIsImdldFJlc3VsdEdlb21ldHJ5IiwiYnVmZmVyT3AiLCJnQnVmIiwiZ2VvbUJ1ZiIsImRpc3RhbmNlJDEiLCJidWZPcCIsImdlb21CdWYkMSIsImckMiIsImRpc3RhbmNlJDIiLCJwYXJhbXMiLCJidWZPcCQxIiwiZ2VvbUJ1ZiQyIiwiZyQzIiwiZGlzdGFuY2UkMyIsImJ1Zk9wJDIiLCJnZW9tQnVmJDMiLCJtYXhQcmVjaXNpb25EaWdpdHMiLCJlbnZNYXgiLCJleHBhbmRCeURpc3RhbmNlIiwiYnVmRW52TWF4IiwiYnVmRW52UHJlY2lzaW9uRGlnaXRzIiwibWluVW5pdExvZzEwIiwiUG9pbnRQYWlyRGlzdGFuY2UiLCJfaXNOdWxsIiwic2V0TWluaW11bSIsImluaXRpYWxpemUiLCJzZXRNYXhpbXVtIiwiRGlzdGFuY2VUb1BvaW50RmluZGVyIiwiY29tcHV0ZURpc3RhbmNlIiwidGVtcFNlZ21lbnQiLCJwdCQxIiwicHREaXN0JDEiLCJwdCQyIiwicHREaXN0JDIiLCJzZWdtZW50IiwicHQkMyIsInB0RGlzdCQzIiwiY2xvc2VzdFB0JDEiLCJCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlciIsIl9tYXhQdERpc3QiLCJzdGF0aWNBY2Nlc3NvcnMkMzYiLCJNYXhQb2ludERpc3RhbmNlRmlsdGVyIiwiTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlciIsImNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlIiwiZGlzdEZpbHRlciIsImdldE1heFBvaW50RGlzdGFuY2UiLCJjb21wdXRlTWF4VmVydGV4RGlzdGFuY2UiLCJmaW5kRGlzdGFuY2UiLCJidWZmZXJDdXJ2ZSIsImdldERpc3RhbmNlUG9pbnRzIiwiX21pblB0RGlzdCIsIm1pZFB0IiwiUG9seWdvbkV4dHJhY3RlciIsImNvbXBzIiwiX2NvbXBzIiwiTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyIiwiX2xpbmVzIiwiX2lzRm9yY2VkVG9MaW5lU3RyaW5nIiwibGluZXMkMSIsImlzRm9yY2VkVG9MaW5lU3RyaW5nIiwic2V0Rm9yY2VUb0xpbmVTdHJpbmciLCJnZXRMaW5lcyIsImZvcmNlVG9MaW5lU3RyaW5nIiwiZ2VvbXMiLCJnZW9tJDIiLCJsaW5lcyQyIiwiZ2VvbXMkMSIsImxpbmVzJDMiLCJmb3JjZVRvTGluZVN0cmluZyQxIiwiZ2VvbSQzIiwibGluZXMkNCIsImZvcmNlVG9MaW5lU3RyaW5nJDIiLCJQb2ludExvY2F0b3IiLCJfYm91bmRhcnlSdWxlIiwiX2lzSW4iLCJfbnVtQm91bmRhcmllcyIsImJvdW5kYXJ5UnVsZSIsImxvY2F0ZUludGVybmFsIiwic2hlbGxMb2MiLCJsb2NhdGVJblBvbHlnb25SaW5nIiwiaG9sZUxvYyIsInAkMiIsInB0Q29vcmQiLCJ1cGRhdGVMb2NhdGlvbkluZm8iLCJjb21wdXRlTG9jYXRpb24iLCJtbCIsIm1wb2x5IiwiR2VvbWV0cnlMb2NhdGlvbiIsIl9jb21wb25lbnQiLCJfc2VnSW5kZXgiLCJjb21wb25lbnQiLCJJTlNJREVfQVJFQSIsImNvbXBvbmVudCQxIiwic3RhdGljQWNjZXNzb3JzJDM4IiwiaXNJbnNpZGVBcmVhIiwiZ2V0R2VvbWV0cnlDb21wb25lbnQiLCJQb2ludEV4dHJhY3RlciIsImdldFBvaW50cyIsIkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlciIsIl9sb2NhdGlvbnMiLCJsb2NhdGlvbnMiLCJEaXN0YW5jZU9wIiwiX3Rlcm1pbmF0ZURpc3RhbmNlIiwiX3B0TG9jYXRvciIsIl9taW5EaXN0YW5jZUxvY2F0aW9uIiwiX21pbkRpc3RhbmNlIiwiZzAiLCJnMSIsImcwJDEiLCJnMSQxIiwidGVybWluYXRlRGlzdGFuY2UiLCJjb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSIsImxvY1B0UG9seSIsInBvbHlHZW9tSW5kZXgiLCJsb2NQdFBvbHkkMSIsImxvY2F0aW9uc0luZGV4IiwicG9seXMiLCJpbnNpZGVMb2NzIiwibG9jcyIsInBvbHlzJDEiLCJsb2NQdFBvbHkkMiIsInB0TG9jIiwibG9jUHRQb2x5JDMiLCJjb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyIsImxvY0dlb20iLCJjb21wdXRlTWluRGlzdGFuY2UiLCJjb21wdXRlRmFjZXREaXN0YW5jZSIsImxpbmVzMCIsImxpbmVzMSIsImNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzIiwidXBkYXRlTWluRGlzdGFuY2UiLCJjb21wdXRlTWluRGlzdGFuY2VQb2ludHMiLCJuZWFyZXN0TG9jYXRpb25zIiwibmVhcmVzdFBvaW50cyIsIm5lYXJlc3RQdHMiLCJjb29yZDAiLCJzZWdDbG9zZXN0UG9pbnQiLCJsaW5lMCIsImxpbmUxIiwibG9jR2VvbSQxIiwiY29vcmQwJDEiLCJkaXN0JDEiLCJwb2ludHMwIiwicG9pbnRzMSIsInB0MSIsImRpc3RPcCIsImlzV2l0aGluRGlzdGFuY2UiLCJQb2ludFBhaXJEaXN0YW5jZSQyIiwiRGlzdGFuY2VUb1BvaW50IiwiRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZSIsIl9nMCIsIl9nMSIsIl9wdERpc3QiLCJfZGVuc2lmeUZyYWMiLCJzdGF0aWNBY2Nlc3NvcnMkMzkiLCJNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIiLCJzZXREZW5zaWZ5RnJhY3Rpb24iLCJkZW5zaWZ5RnJhYyIsImNvbXB1dGUiLCJjb21wdXRlT3JpZW50ZWREaXN0YW5jZSIsImRpc2NyZXRlR2VvbSIsIk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMSIsImZyYWNGaWx0ZXIiLCJvcmllbnRlZERpc3RhbmNlIiwiX2V1Y2xpZGVhbkRpc3QiLCJfbnVtU3ViU2VncyIsImZyYWN0aW9uIiwiZGVseCIsImRlbHkiLCJCdWZmZXJEaXN0YW5jZVZhbGlkYXRvciIsImlucHV0IiwiX21pblZhbGlkRGlzdGFuY2UiLCJfbWF4VmFsaWREaXN0YW5jZSIsIl9taW5EaXN0YW5jZUZvdW5kIiwiX21heERpc3RhbmNlRm91bmQiLCJfaXNWYWxpZCIsIl9lcnJNc2ciLCJfZXJyb3JMb2NhdGlvbiIsIl9lcnJvckluZGljYXRvciIsIl9pbnB1dCIsIl9idWZEaXN0YW5jZSIsInN0YXRpY0FjY2Vzc29ycyQzNyIsIlZFUkJPU0UiLCJNQVhfRElTVEFOQ0VfRElGRl9GUkFDIiwiY2hlY2tNYXhpbXVtRGlzdGFuY2UiLCJidWZDdXJ2ZSIsIm1heERpc3QiLCJoYXVzIiwiZGlzdERlbHRhIiwiY2hlY2tQb3NpdGl2ZVZhbGlkIiwiY2hlY2tOZWdhdGl2ZVZhbGlkIiwiaW5wdXRDdXJ2ZSIsImdldFBvbHlnb25MaW5lcyIsImNoZWNrTWluaW11bURpc3RhbmNlIiwiZ2V0RXJyb3JJbmRpY2F0b3IiLCJnZXRFcnJvckxvY2F0aW9uIiwibGluZUV4dHJhY3RlciIsImdldEVycm9yTWVzc2FnZSIsIkJ1ZmZlclJlc3VsdFZhbGlkYXRvciIsIl9lcnJvck1zZyIsInN0YXRpY0FjY2Vzc29ycyQ0MCIsIk1BWF9FTlZfRElGRl9GUkFDIiwiY2hlY2tQb2x5Z29uYWwiLCJjaGVja0V4cGVjdGVkRW1wdHkiLCJjaGVja0VudmVsb3BlIiwiY2hlY2tBcmVhIiwiY2hlY2tEaXN0YW5jZSIsInBhZGRpbmciLCJleHBlY3RlZEVudiIsImJ1ZkVudiIsInJlcG9ydCIsImRpc3RWYWxpZCIsImlucHV0QXJlYSIsInJlc3VsdEFyZWEiLCJjaGVja05hbWUiLCJpc1ZhbGlkTXNnIiwidmFsaWRhdG9yIiwiQmFzaWNTZWdtZW50U3RyaW5nIiwiSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIiLCJfZmluZEFsbEludGVyc2VjdGlvbnMiLCJfaXNDaGVja0VuZFNlZ21lbnRzT25seSIsIl9pbnRlcmlvckludGVyc2VjdGlvbiIsIl9pbnRTZWdtZW50cyIsIl9pbnRlcnNlY3Rpb25zIiwiX2ludGVyc2VjdGlvbkNvdW50IiwiX2tlZXBJbnRlcnNlY3Rpb25zIiwiZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24iLCJzZXRDaGVja0VuZFNlZ21lbnRzT25seSIsImlzQ2hlY2tFbmRTZWdtZW50c09ubHkiLCJnZXRJbnRlcnNlY3Rpb25TZWdtZW50cyIsImdldEludGVyc2VjdGlvbnMiLCJzZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyIsImZpbmRBbGxJbnRlcnNlY3Rpb25zIiwic2V0S2VlcEludGVyc2VjdGlvbnMiLCJrZWVwSW50ZXJzZWN0aW9ucyIsImlzRW5kU2VnUHJlc2VudCIsImlzRW5kU2VnbWVudCIsImNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIiLCJmaW5kZXIiLCJjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIiLCJjcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyIiwiRmFzdE5vZGluZ1ZhbGlkYXRvciIsImV4ZWN1dGUiLCJpbnRTZWdzIiwiY29tcHV0ZUludGVyc2VjdGlvbnMiLCJFZGdlTm9kaW5nVmFsaWRhdG9yIiwiX252IiwidG9TZWdtZW50U3RyaW5ncyIsIkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlciIsIm1hcE9wIiwiX21hcE9wIiwibWFwcGVkIiwib3AiLCJtYXBwZXIiLCJMaW5lQnVpbGRlciIsIl9vcCIsIl9saW5lRWRnZXNMaXN0IiwiX3Jlc3VsdExpbmVMaXN0IiwicHRMb2NhdG9yIiwiY29sbGVjdExpbmVzIiwib3BDb2RlIiwiZ2V0R3JhcGgiLCJjb2xsZWN0TGluZUVkZ2UiLCJjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UiLCJsYWJlbElzb2xhdGVkTGluZSIsInRhcmdldEluZGV4IiwiZ2V0QXJnR2VvbWV0cnkiLCJidWlsZExpbmVzIiwiT3ZlcmxheU9wIiwiaXNSZXN1bHRPZk9wIiwiaXNDb3ZlcmVkQnlBIiwibGFiZWxJc29sYXRlZExpbmVzIiwiZWRnZXNMaXN0IiwiSU5URVJTRUNUSU9OIiwiUG9pbnRCdWlsZGVyIiwiX3Jlc3VsdFBvaW50TGlzdCIsImZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCIsImlzQ292ZXJlZEJ5TEEiLCJleHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzIiwiR2VvbWV0cnlUcmFuc2Zvcm1lciIsIl9wcnVuZUVtcHR5R2VvbWV0cnkiLCJfcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlIiwiX3ByZXNlcnZlQ29sbGVjdGlvbnMiLCJfcHJlc2VydmVUeXBlIiwidHJhbnNmb3JtUG9pbnQiLCJ0cmFuc2Zvcm1Db29yZGluYXRlcyIsInRyYW5zZm9ybVBvbHlnb24iLCJpc0FsbFZhbGlkTGluZWFyUmluZ3MiLCJ0cmFuc2Zvcm1MaW5lYXJSaW5nIiwiY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlIiwiZ2V0SW5wdXRHZW9tZXRyeSIsInRyYW5zZm9ybU11bHRpTGluZVN0cmluZyIsInRyYW5zR2VvbUxpc3QiLCJ0cmFuc2Zvcm1HZW9tIiwidHJhbnNmb3JtTGluZVN0cmluZyIsInRyYW5zZm9ybU11bHRpUG9pbnQiLCJ0cmFuc2Zvcm1NdWx0aVBvbHlnb24iLCJ0cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24iLCJ0cmFuc2Zvcm0iLCJzZXFTaXplIiwiTGluZVN0cmluZ1NuYXBwZXIiLCJfc25hcFRvbGVyYW5jZSIsIl9zcmNQdHMiLCJfYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMiLCJfaXNDbG9zZWQiLCJzcmNMaW5lIiwic25hcFRvbGVyYW5jZSIsInNyY1B0cyIsInNuYXBUb2xlcmFuY2UkMSIsInNuYXBWZXJ0aWNlcyIsInNyY0Nvb3JkcyIsInNyY1B0Iiwic25hcFZlcnQiLCJmaW5kU25hcEZvclZlcnRleCIsInNuYXBUbyIsInNuYXBTZWdtZW50cyIsImRpc3RpbmN0UHRDb3VudCIsImZpbmRTZWdtZW50SW5kZXhUb1NuYXAiLCJzbmFwSW5kZXgiLCJzZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyIsImFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzIiwiR2VvbWV0cnlTbmFwcGVyIiwic3JjR2VvbSIsIl9zcmNHZW9tIiwic3RhdGljQWNjZXNzb3JzJDQxIiwiU05BUF9QUkVDSVNJT05fRkFDVE9SIiwic25hcEdlb20iLCJleHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXMiLCJzbmFwVHJhbnMiLCJTbmFwVHJhbnNmb3JtZXIiLCJzbmFwVG9TZWxmIiwiY2xlYW5SZXN1bHQiLCJzbmFwcGVkR2VvbSIsImNvbXB1dGVTbmFwVG9sZXJhbmNlIiwicmluZ1B0cyIsIm1pblNlZ0xlbiIsImNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCIsInNuYXBUb2wiLCJwdFNldCIsInNlZ0xlbiIsInNuYXBwZXIwIiwic25hcHBlcjEiLCJjb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UiLCJjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSIsImZpeGVkU25hcFRvbCIsIm1pbkRpbWVuc2lvbiIsIkdlb21ldHJ5VHJhbnNmb3JtZXIkJDEiLCJpc1NlbGZTbmFwIiwiX3NuYXBQdHMiLCJfaXNTZWxmU25hcCIsInNuYXBMaW5lIiwic25hcHBlciIsIkNvbW1vbkJpdHMiLCJfaXNGaXJzdCIsIl9jb21tb25NYW50aXNzYUJpdHNDb3VudCIsIl9jb21tb25CaXRzIiwiX2NvbW1vblNpZ25FeHAiLCJnZXRDb21tb24iLCJudW1CaXRzIiwic2lnbkV4cEJpdHMiLCJudW1TaWduRXhwIiwibnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyIsInplcm9Mb3dlckJpdHMiLCJiaXRzIiwibnVtU3RyIiwidG9CaW5hcnlTdHJpbmciLCJwYWRTdHIiLCJiaXRTdHIiLCJnZXRCaXQiLCJtYXNrIiwibkJpdHMiLCJpbnZNYXNrIiwiemVyb2VkIiwibnVtMSIsIm51bTIiLCJDb21tb25CaXRzUmVtb3ZlciIsIl9jb21tb25Db29yZCIsIl9jY0ZpbHRlciIsIkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIiLCJzdGF0aWNBY2Nlc3NvcnMkNDIiLCJUcmFuc2xhdGVyIiwiYWRkQ29tbW9uQml0cyIsInRyYW5zIiwicmVtb3ZlQ29tbW9uQml0cyIsImludkNvb3JkIiwiZ2V0Q29tbW9uQ29vcmRpbmF0ZSIsIl9jb21tb25CaXRzWCIsIl9jb21tb25CaXRzWSIsInhwIiwieXAiLCJTbmFwT3ZlcmxheU9wIiwiX2NiciIsInNlbGZTbmFwIiwicmVtR2VvbSIsInByZXBhcmVSZXN1bHQiLCJwcmVwR2VvbSIsIm92ZXJsYXlPcCIsInVuaW9uIiwiVU5JT04iLCJzeW1EaWZmZXJlbmNlIiwiU1lNRElGRkVSRU5DRSIsImRpZmZlcmVuY2UiLCJESUZGRVJFTkNFIiwiU25hcElmTmVlZGVkT3ZlcmxheU9wIiwiaXNTdWNjZXNzIiwic2F2ZWRFeGNlcHRpb24iLCJNb25vdG9uZUNoYWluJDIiLCJTd2VlcExpbmVFdmVudCIsIl94VmFsdWUiLCJfZXZlbnRUeXBlIiwiX2luc2VydEV2ZW50IiwiX2RlbGV0ZUV2ZW50SW5kZXgiLCJfb2JqIiwiaW5zZXJ0RXZlbnQiLCJJTlNFUlQiLCJzdGF0aWNBY2Nlc3NvcnMkNDMiLCJpc0RlbGV0ZSIsInNldERlbGV0ZUV2ZW50SW5kZXgiLCJkZWxldGVFdmVudEluZGV4IiwiZ2V0T2JqZWN0IiwicGUiLCJnZXRJbnNlcnRFdmVudCIsImlzSW5zZXJ0IiwiaXNTYW1lTGFiZWwiLCJldiIsImdldERlbGV0ZUV2ZW50SW5kZXgiLCJFZGdlU2V0SW50ZXJzZWN0b3IiLCJTZWdtZW50SW50ZXJzZWN0b3IkMiIsIl9pbmNsdWRlUHJvcGVyIiwiX3JlY29yZElzb2xhdGVkIiwiX251bUludGVyc2VjdGlvbnMiLCJfYmR5Tm9kZXMiLCJfaXNEb25lIiwiX2lzRG9uZVdoZW5Qcm9wZXJJbnQiLCJpbmNsdWRlUHJvcGVyIiwicmVjb3JkSXNvbGF0ZWQiLCJzZXRJc0RvbmVJZlByb3BlckludCIsImlzRG9uZVdoZW5Qcm9wZXJJbnQiLCJpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCIsImlzQm91bmRhcnlQb2ludCIsInNldEJvdW5kYXJ5Tm9kZXMiLCJiZHlOb2RlczAiLCJiZHlOb2RlczEiLCJTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yIiwiRWRnZVNldEludGVyc2VjdG9yJCQxIiwiZXZlbnRzIiwibk92ZXJsYXBzIiwicHJlcGFyZUV2ZW50cyIsInByb2Nlc3NPdmVybGFwcyIsImVkZ2VzMCIsImVkZ2VzMSIsInNpJDEiLCJzaSQyIiwidGVzdEFsbFNlZ21lbnRzIiwiYWRkRWRnZSIsImVkZ2VTZXQiLCJldjAiLCJtYzAiLCJldjEiLCJlZGdlcyQxIiwiSW50ZXJ2YWxSVHJlZU5vZGUiLCJfbWluIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJzdGF0aWNBY2Nlc3NvcnMkNDUiLCJOb2RlQ29tcGFyYXRvciIsImdldE1pbiIsInF1ZXJ5TWluIiwicXVlcnlNYXgiLCJnZXRNYXgiLCJtaWQyIiwiSW50ZXJ2YWxSVHJlZUxlYWZOb2RlIiwiSW50ZXJ2YWxSVHJlZU5vZGUkJDEiLCJJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZSIsIl9ub2RlMSIsIl9ub2RlMiIsImJ1aWxkRXh0ZW50IiwiU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZSIsIl9sZWF2ZXMiLCJidWlsZFRyZWUiLCJidWlsZExldmVsIiwiYnVpbGRSb290IiwicHJpbnROb2RlIiwiQXJyYXlMaXN0VmlzaXRvciIsImdldEl0ZW1zIiwiSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciIsIkludGVydmFsSW5kZXhlZEdlb21ldHJ5Iiwic3RhdGljQWNjZXNzb3JzJDQ0IiwiU2VnbWVudFZpc2l0b3IiLCJyY2MiLCJfY291bnRlciIsImFkZExpbmUiLCJHZW9tZXRyeUdyYXBoIiwiUGxhbmFyR3JhcGgkJDEiLCJfcGFyZW50R2VvbSIsIl9saW5lRWRnZU1hcCIsIl9ib3VuZGFyeU5vZGVSdWxlIiwiX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGUiLCJfYXJnSW5kZXgiLCJfYm91bmRhcnlOb2RlcyIsIl9oYXNUb29GZXdQb2ludHMiLCJfaW52YWxpZFBvaW50IiwiX2FyZWFQdExvY2F0b3IiLCJwYXJlbnRHZW9tIiwiYXJnSW5kZXgkMSIsInBhcmVudEdlb20kMSIsImJvdW5kYXJ5Tm9kZVJ1bGUkMSIsImluc2VydEJvdW5kYXJ5UG9pbnQiLCJkZXRlcm1pbmVCb3VuZGFyeSIsImNvbXB1dGVTZWxmTm9kZXMiLCJjb21wdXRlUmluZ1NlbGZOb2RlcyIsImxpJDEiLCJjb21wdXRlUmluZ1NlbGZOb2RlcyQxIiwiaXNEb25lSWZQcm9wZXJJbnQiLCJlc2kiLCJjcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IiLCJpc1JpbmdzIiwiY29tcHV0ZUFsbFNlZ21lbnRzIiwiYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzIiwiY29tcHV0ZVNwbGl0RWRnZXMiLCJlZGdlbGlzdCIsImNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyIsImhhc1Rvb0Zld1BvaW50cyIsImluc2VydFBvaW50IiwiZ2V0SW52YWxpZFBvaW50IiwiZ2V0Qm91bmRhcnlQb2ludHMiLCJhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSIsImxyIiwiY3dMZWZ0IiwiY3dSaWdodCIsImVpSXQiLCJHZW9tZXRyeUdyYXBoT3AiLCJfcmVzdWx0UHJlY2lzaW9uTW9kZWwiLCJfYXJnIiwic2V0Q29tcHV0YXRpb25QcmVjaXNpb24iLCJnMCQyIiwiR2VvbWV0cnlNYXBwZXIiLCJNYXBPcCIsIm9wJDEiLCJtYXBwZWQkMSIsImdyIiwiX3Jlc3VsdEdlb20iLCJfcmVzdWx0UG9seUxpc3QiLCJjYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcyIsInJlc3VsdFBvaW50TGlzdCIsInJlc3VsdExpbmVMaXN0Iiwib3Bjb2RlIiwiY3JlYXRlRW1wdHlSZXN1bHQiLCJyZXBsYWNlQ29sbGFwc2VkRWRnZXMiLCJuZXdFZGdlcyIsInVwZGF0ZU5vZGVMYWJlbGxpbmciLCJvdmVybGF5T3BDb2RlIiwiY29tcHV0ZU92ZXJsYXkiLCJpbnNlcnRVbmlxdWVFZGdlcyIsImNvcHlQb2ludHMiLCJiYXNlU3BsaXRFZGdlcyIsImNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzIiwibGFiZWxJbmNvbXBsZXRlTm9kZXMiLCJmaW5kUmVzdWx0QXJlYUVkZ2VzIiwibGluZUJ1aWxkZXIiLCJwb2ludEJ1aWxkZXIiLCJsYWJlbEluY29tcGxldGVOb2RlIiwiZ3JhcGhOb2RlIiwibmV3Tm9kZSIsIm5pIiwiZ2VvbTEiLCJnb3YiLCJnZW9tT3YiLCJyZXN1bHREaW1lbnNpb24iLCJkaW0wIiwiZGltMSIsImdlb21GYWN0IiwibG9jMCIsImxvYzEiLCJsb2MwJDEiLCJsb2MxJDEiLCJGdXp6eVBvaW50TG9jYXRvciIsIl9nIiwiX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UiLCJfbGluZXdvcmsiLCJib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlIiwiZXh0cmFjdExpbmV3b3JrIiwiaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5IiwiZXh0cmFjdGVyIiwiUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIiLCJsaW5ld29yayIsImdldExpbmV3b3JrIiwiT2Zmc2V0UG9pbnRHZW5lcmF0b3IiLCJfZG9MZWZ0IiwiX2RvUmlnaHQiLCJleHRyYWN0UG9pbnRzIiwib2Zmc2V0UHRzIiwiY29tcHV0ZU9mZnNldFBvaW50cyIsInNldFNpZGVzVG9HZW5lcmF0ZSIsImRvTGVmdCIsImRvUmlnaHQiLCJtaWRYIiwibWlkWSIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsIk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IiLCJfbG9jRmluZGVyIiwiX2xvY2F0aW9uIiwiX2ludmFsaWRMb2NhdGlvbiIsIlRPTEVSQU5DRSIsIl90ZXN0Q29vcmRzIiwiY29tcHV0ZUJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UiLCJzdGF0aWNBY2Nlc3NvcnMkNDYiLCJyZXBvcnRSZXN1bHQiLCJleHBlY3RlZEludGVyaW9yIiwiYWRkVGVzdFB0cyIsIm92ZXJsYXlPcCQxIiwiaGFzTG9jYXRpb24iLCJpc1ZhbGlkUmVzdWx0IiwicHRHZW4iLCJyZXN1bHRJbkludGVyaW9yIiwiZ2V0SW52YWxpZExvY2F0aW9uIiwiR2VvbWV0cnlDb21iaW5lciIsIl9nZW9tRmFjdG9yeSIsIl9za2lwRW1wdHkiLCJfaW5wdXRHZW9tcyIsImV4dHJhY3RGYWN0b3J5IiwiZXh0cmFjdEVsZW1lbnRzIiwiZWxlbXMiLCJlbGVtR2VvbSIsImNvbWJpbmUiLCJjb21iaW5lciIsImNvbWJpbmVyJDEiLCJjcmVhdGVMaXN0IiwiY29tYmluZXIkMiIsIm9iajAiLCJvYmoxIiwib2JqMCQxIiwib2JqMSQxIiwib2JqMiIsImxpc3QkMSIsIkNhc2NhZGVkUG9seWdvblVuaW9uIiwiX2lucHV0UG9seXMiLCJzdGF0aWNBY2Nlc3NvcnMkNDciLCJTVFJUUkVFX05PREVfQ0FQQUNJVFkiLCJyZWR1Y2VUb0dlb21ldHJpZXMiLCJnZW9tVHJlZSIsInVuaW9uVHJlZSIsImV4dHJhY3RCeUVudmVsb3BlIiwiZGlzam9pbnRHZW9tcyIsImludGVyc2VjdGluZ0dlb21zIiwiZWxlbSIsInVuaW9uT3B0aW1pemVkIiwiZzBFbnYiLCJnMUVudiIsImNvbWJvIiwidW5pb25BY3R1YWwiLCJjb21tb25FbnYiLCJ1bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24iLCJpdGVtVHJlZSIsInVuaW9uQWxsIiwiYmluYXJ5VW5pb24iLCJ1bmlvblNhZmUiLCJyZXBlYXRlZFVuaW9uIiwicmVzdHJpY3RUb1BvbHlnb25zIiwiY29tbW9uIiwiZGlzam9pbnRQb2x5cyIsImcwSW50IiwiZzFJbnQiLCJvdmVyYWxsVW5pb24iLCJidWZmZXJVbmlvbiIsImdDb2xsIiwiZmFjdG9yeSQxIiwiZ0NvbGwkMSIsInVuaW9uQWxsJDEiLCJVbmlvbk9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/turf-jsts/jsts.mjs\n");

/***/ })

};
;