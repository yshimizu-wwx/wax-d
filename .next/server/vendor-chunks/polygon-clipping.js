"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polygon-clipping";
exports.ids = ["vendor-chunks/polygon-clipping"];
exports.modules = {

/***/ "(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/polygon-clipping/dist/polygon-clipping.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var splaytree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! splaytree */ \"(ssr)/./node_modules/splaytree/dist/splaytree.js\");\n/* harmony import */ var robust_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! robust-predicates */ \"(ssr)/./node_modules/robust-predicates/index.js\");\n\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */ const isInBbox = (bbox, point)=>{\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */ const getBboxOverlap = (b1, b2)=>{\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n    // find the middle two X values\n    const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n    // find the middle two Y values\n    const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n    // put those middle values together to get the overlap\n    return {\n        ll: {\n            x: lowerX,\n            y: lowerY\n        },\n        ur: {\n            x: upperX,\n            y: upperY\n        }\n    };\n};\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */ let epsilon = Number.EPSILON;\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */ const cmp = (a, b)=>{\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n        if (-epsilon < b && b < epsilon) {\n            return 0;\n        }\n    }\n    // check if they're flp equal\n    const ab = a - b;\n    if (ab * ab < EPSILON_SQ * a * b) {\n        return 0;\n    }\n    // normal comparison\n    return a < b ? -1 : 1;\n};\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */ class PtRounder {\n    constructor(){\n        this.reset();\n    }\n    reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n    }\n    round(x, y) {\n        return {\n            x: this.xRounder.round(x),\n            y: this.yRounder.round(y)\n        };\n    }\n}\nclass CoordRounder {\n    constructor(){\n        this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        // preseed with 0 so we don't end up with values < Number.EPSILON\n        this.round(0);\n    }\n    // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n    round(coord) {\n        const node = this.tree.add(coord);\n        const prevNode = this.tree.prev(node);\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n            this.tree.remove(coord);\n            return prevNode.key;\n        }\n        const nextNode = this.tree.next(node);\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n            this.tree.remove(coord);\n            return nextNode.key;\n        }\n        return coord;\n    }\n}\n// singleton available by import\nconst rounder = new PtRounder();\n/* Cross Product of two vectors with first point at origin */ const crossProduct = (a, b)=>a.x * b.y - a.y * b.x;\n/* Dot Product of two vectors with first point at origin */ const dotProduct = (a, b)=>a.x * b.x + a.y * b.y;\n/* Comparator for two vectors with same starting point */ const compareVectorAngles = (basePt, endPt1, endPt2)=>{\n    const res = (0,robust_predicates__WEBPACK_IMPORTED_MODULE_1__.orient2d)(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n    if (res > 0) return -1;\n    if (res < 0) return 1;\n    return 0;\n};\nconst length = (v)=>Math.sqrt(dotProduct(v, v));\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */ const sineOfAngle = (pShared, pBase, pAngle)=>{\n    const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n    };\n    const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */ const cosineOfAngle = (pShared, pBase, pAngle)=>{\n    const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n    };\n    const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */ const horizontalIntersection = (pt, v, y)=>{\n    if (v.y === 0) return null;\n    return {\n        x: pt.x + v.x / v.y * (y - pt.y),\n        y: y\n    };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */ const verticalIntersection = (pt, v, x)=>{\n    if (v.x === 0) return null;\n    return {\n        x: x,\n        y: pt.y + v.y / v.x * (x - pt.x)\n    };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */ const intersection$1 = (pt1, v1, pt2, v2)=>{\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n    // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n    const kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    const ve = {\n        x: pt2.x - pt1.x,\n        y: pt2.y - pt1.y\n    };\n    const d1 = crossProduct(ve, v1) / kross;\n    const d2 = crossProduct(ve, v2) / kross;\n    // take the average of the two calculations to minimize rounding error\n    const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;\n    const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;\n    const x = (x1 + x2) / 2;\n    const y = (y1 + y2) / 2;\n    return {\n        x: x,\n        y: y\n    };\n};\nclass SweepEvent {\n    // for ordering sweep events in the sweep event queue\n    static compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp;\n        // the points are the same, so link them if needed\n        if (a.point !== b.point) a.link(b);\n        // favor right events over left\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n        // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n        return Segment.compare(a.segment, b.segment);\n    }\n    // for ordering points in sweep line order\n    static comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n    }\n    // Warning: 'point' input will be modified and re-used (for performance)\n    constructor(point, isLeft){\n        if (point.events === undefined) point.events = [\n            this\n        ];\n        else point.events.push(this);\n        this.point = point;\n        this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n    }\n    link(other) {\n        if (other.point === this.point) {\n            throw new Error(\"Tried to link already linked events\");\n        }\n        const otherEvents = other.point.events;\n        for(let i = 0, iMax = otherEvents.length; i < iMax; i++){\n            const evt = otherEvents[i];\n            this.point.events.push(evt);\n            evt.point = this.point;\n        }\n        this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */ checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        const numEvents = this.point.events.length;\n        for(let i = 0; i < numEvents; i++){\n            const evt1 = this.point.events[i];\n            if (evt1.segment.consumedBy !== undefined) continue;\n            for(let j = i + 1; j < numEvents; j++){\n                const evt2 = this.point.events[j];\n                if (evt2.consumedBy !== undefined) continue;\n                if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n                evt1.segment.consume(evt2.segment);\n            }\n        }\n    }\n    getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        const events = [];\n        for(let i = 0, iMax = this.point.events.length; i < iMax; i++){\n            const evt = this.point.events[i];\n            if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n                events.push(evt);\n            }\n        }\n        return events;\n    }\n    /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */ getLeftmostComparator(baseEvent) {\n        const cache = new Map();\n        const fillCache = (linkedEvent)=>{\n            const nextEvent = linkedEvent.otherSE;\n            cache.set(linkedEvent, {\n                sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n                cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n            });\n        };\n        return (a, b)=>{\n            if (!cache.has(a)) fillCache(a);\n            if (!cache.has(b)) fillCache(b);\n            const { sine: asine, cosine: acosine } = cache.get(a);\n            const { sine: bsine, cosine: bcosine } = cache.get(b);\n            // both on or above x-axis\n            if (asine >= 0 && bsine >= 0) {\n                if (acosine < bcosine) return 1;\n                if (acosine > bcosine) return -1;\n                return 0;\n            }\n            // both below x-axis\n            if (asine < 0 && bsine < 0) {\n                if (acosine < bcosine) return -1;\n                if (acosine > bcosine) return 1;\n                return 0;\n            }\n            // one above x-axis, one below\n            if (bsine < asine) return -1;\n            if (bsine > asine) return 1;\n            return 0;\n        };\n    }\n}\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n    /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */ static compare(a, b) {\n        const alx = a.leftSE.point.x;\n        const blx = b.leftSE.point.x;\n        const arx = a.rightSE.point.x;\n        const brx = b.rightSE.point.x;\n        // check if they're even in the same vertical plane\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        const aly = a.leftSE.point.y;\n        const bly = b.leftSE.point.y;\n        const ary = a.rightSE.point.y;\n        const bry = b.rightSE.point.y;\n        // is left endpoint of segment B the right-more?\n        if (alx < blx) {\n            // are the two segments in the same horizontal plane?\n            if (bly < aly && bly < ary) return 1;\n            if (bly > aly && bly > ary) return -1;\n            // is the B left endpoint colinear to segment A?\n            const aCmpBLeft = a.comparePoint(b.leftSE.point);\n            if (aCmpBLeft < 0) return 1;\n            if (aCmpBLeft > 0) return -1;\n            // is the A right endpoint colinear to segment B ?\n            const bCmpARight = b.comparePoint(a.rightSE.point);\n            if (bCmpARight !== 0) return bCmpARight;\n            // colinear segments, consider the one with left-more\n            // left endpoint to be first (arbitrary?)\n            return -1;\n        }\n        // is left endpoint of segment A the right-more?\n        if (alx > blx) {\n            if (aly < bly && aly < bry) return -1;\n            if (aly > bly && aly > bry) return 1;\n            // is the A left endpoint colinear to segment B?\n            const bCmpALeft = b.comparePoint(a.leftSE.point);\n            if (bCmpALeft !== 0) return bCmpALeft;\n            // is the B right endpoint colinear to segment A?\n            const aCmpBRight = a.comparePoint(b.rightSE.point);\n            if (aCmpBRight < 0) return 1;\n            if (aCmpBRight > 0) return -1;\n            // colinear segments, consider the one with left-more\n            // left endpoint to be first (arbitrary?)\n            return 1;\n        }\n        // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n        if (aly < bly) return -1;\n        if (aly > bly) return 1;\n        // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n        if (arx < brx) {\n            const bCmpARight = b.comparePoint(a.rightSE.point);\n            if (bCmpARight !== 0) return bCmpARight;\n        }\n        // is the B right endpoint more left-more?\n        if (arx > brx) {\n            const aCmpBRight = a.comparePoint(b.rightSE.point);\n            if (aCmpBRight < 0) return 1;\n            if (aCmpBRight > 0) return -1;\n        }\n        if (arx !== brx) {\n            // are these two [almost] vertical segments with opposite orientation?\n            // if so, the one with the lower right endpoint comes first\n            const ay = ary - aly;\n            const ax = arx - alx;\n            const by = bry - bly;\n            const bx = brx - blx;\n            if (ay > ax && by < bx) return 1;\n            if (ay < ax && by > bx) return -1;\n        }\n        // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n        if (arx > brx) return 1;\n        if (arx < brx) return -1;\n        // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n        if (ary < bry) return -1;\n        if (ary > bry) return 1;\n        // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1;\n        // identical segment, ie a === b\n        return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */ constructor(leftSE, rightSE, rings, windings){\n        this.id = ++segmentId;\n        this.leftSE = leftSE;\n        leftSE.segment = this;\n        leftSE.otherSE = rightSE;\n        this.rightSE = rightSE;\n        rightSE.segment = this;\n        rightSE.otherSE = leftSE;\n        this.rings = rings;\n        this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n    }\n    static fromRing(pt1, pt2, ring) {\n        let leftPt, rightPt, winding;\n        // ordering the two points according to sweep line ordering\n        const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n        if (cmpPts < 0) {\n            leftPt = pt1;\n            rightPt = pt2;\n            winding = 1;\n        } else if (cmpPts > 0) {\n            leftPt = pt2;\n            rightPt = pt1;\n            winding = -1;\n        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n        const leftSE = new SweepEvent(leftPt, true);\n        const rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [\n            ring\n        ], [\n            winding\n        ]);\n    }\n    /* When a segment is split, the rightSE is replaced with a new sweep event */ replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n    }\n    bbox() {\n        const y1 = this.leftSE.point.y;\n        const y2 = this.rightSE.point.y;\n        return {\n            ll: {\n                x: this.leftSE.point.x,\n                y: y1 < y2 ? y1 : y2\n            },\n            ur: {\n                x: this.rightSE.point.x,\n                y: y1 > y2 ? y1 : y2\n            }\n        };\n    }\n    /* A vector from the left point to the right */ vector() {\n        return {\n            x: this.rightSE.point.x - this.leftSE.point.x,\n            y: this.rightSE.point.y - this.leftSE.point.y\n        };\n    }\n    isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */ comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        const lPt = this.leftSE.point;\n        const rPt = this.rightSE.point;\n        const v = this.vector();\n        // Exactly vertical segments.\n        if (lPt.x === rPt.x) {\n            if (point.x === lPt.x) return 0;\n            return point.x < lPt.x ? 1 : -1;\n        }\n        // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n        const yDist = (point.y - lPt.y) / v.y;\n        const xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0;\n        // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n        const xDist = (point.x - lPt.x) / v.x;\n        const yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */ getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        const tBbox = this.bbox();\n        const oBbox = other.bbox();\n        const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null;\n        // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n        const tlp = this.leftSE.point;\n        const trp = this.rightSE.point;\n        const olp = other.leftSE.point;\n        const orp = other.rightSE.point;\n        // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n        // do left endpoints match?\n        if (touchesThisLSE && touchesOtherLSE) {\n            // these two cases are for colinear segments with matching left\n            // endpoints, and one segment being longer than the other\n            if (touchesThisRSE && !touchesOtherRSE) return trp;\n            if (!touchesThisRSE && touchesOtherRSE) return orp;\n            // either the two segments match exactly (two trival intersections)\n            // or just on their left endpoint (one trivial intersection\n            return null;\n        }\n        // does this left endpoint matches (other doesn't)\n        if (touchesThisLSE) {\n            // check for segments that just intersect on opposing endpoints\n            if (touchesOtherRSE) {\n                if (tlp.x === orp.x && tlp.y === orp.y) return null;\n            }\n            // t-intersection on left endpoint\n            return tlp;\n        }\n        // does other left endpoint matches (this doesn't)\n        if (touchesOtherLSE) {\n            // check for segments that just intersect on opposing endpoints\n            if (touchesThisRSE) {\n                if (trp.x === olp.x && trp.y === olp.y) return null;\n            }\n            // t-intersection on left endpoint\n            return olp;\n        }\n        // trivial intersection on right endpoints\n        if (touchesThisRSE && touchesOtherRSE) return null;\n        // t-intersections on just one right endpoint\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp;\n        // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n        const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n        // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n        if (pt === null) return null;\n        // is the intersection found between the lines not on the segments?\n        if (!isInBbox(bboxOverlap, pt)) return null;\n        // round the the computed point if needed\n        return rounder.round(pt.x, pt.y);\n    }\n    /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */ split(point) {\n        const newEvents = [];\n        const alreadyLinked = point.events !== undefined;\n        const newLeftSE = new SweepEvent(point, true);\n        const newRightSE = new SweepEvent(point, false);\n        const oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n        // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n            newSeg.swapEvents();\n        }\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n            this.swapEvents();\n        }\n        // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n        if (alreadyLinked) {\n            newLeftSE.checkForConsuming();\n            newRightSE.checkForConsuming();\n        }\n        return newEvents;\n    }\n    /* Swap which event is left and right */ swapEvents() {\n        const tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n        for(let i = 0, iMax = this.windings.length; i < iMax; i++){\n            this.windings[i] *= -1;\n        }\n    }\n    /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */ consume(other) {\n        let consumer = this;\n        let consumee = other;\n        while(consumer.consumedBy)consumer = consumer.consumedBy;\n        while(consumee.consumedBy)consumee = consumee.consumedBy;\n        const cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n        if (cmp > 0) {\n            const tmp = consumer;\n            consumer = consumee;\n            consumee = tmp;\n        }\n        // make sure a segment doesn't consume it's prev\n        if (consumer.prev === consumee) {\n            const tmp = consumer;\n            consumer = consumee;\n            consumee = tmp;\n        }\n        for(let i = 0, iMax = consumee.rings.length; i < iMax; i++){\n            const ring = consumee.rings[i];\n            const winding = consumee.windings[i];\n            const index = consumer.rings.indexOf(ring);\n            if (index === -1) {\n                consumer.rings.push(ring);\n                consumer.windings.push(winding);\n            } else consumer.windings[index] += winding;\n        }\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer;\n        // mark sweep events consumed as to maintain ordering in sweep event queue\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */ prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;\n        else if (this.prev.isInResult()) this._prevInResult = this.prev;\n        else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n    }\n    beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n            rings: [],\n            windings: [],\n            multiPolys: []\n        };\n        else {\n            const seg = this.prev.consumedBy || this.prev;\n            this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n    }\n    afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        const beforeState = this.beforeState();\n        this._afterState = {\n            rings: beforeState.rings.slice(0),\n            windings: beforeState.windings.slice(0),\n            multiPolys: []\n        };\n        const ringsAfter = this._afterState.rings;\n        const windingsAfter = this._afterState.windings;\n        const mpsAfter = this._afterState.multiPolys;\n        // calculate ringsAfter, windingsAfter\n        for(let i = 0, iMax = this.rings.length; i < iMax; i++){\n            const ring = this.rings[i];\n            const winding = this.windings[i];\n            const index = ringsAfter.indexOf(ring);\n            if (index === -1) {\n                ringsAfter.push(ring);\n                windingsAfter.push(winding);\n            } else windingsAfter[index] += winding;\n        }\n        // calcualte polysAfter\n        const polysAfter = [];\n        const polysExclude = [];\n        for(let i = 0, iMax = ringsAfter.length; i < iMax; i++){\n            if (windingsAfter[i] === 0) continue; // non-zero rule\n            const ring = ringsAfter[i];\n            const poly = ring.poly;\n            if (polysExclude.indexOf(poly) !== -1) continue;\n            if (ring.isExterior) polysAfter.push(poly);\n            else {\n                if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n                const index = polysAfter.indexOf(ring.poly);\n                if (index !== -1) polysAfter.splice(index, 1);\n            }\n        }\n        // calculate multiPolysAfter\n        for(let i = 0, iMax = polysAfter.length; i < iMax; i++){\n            const mp = polysAfter[i].multiPoly;\n            if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n        return this._afterState;\n    }\n    /* Is this segment part of the final result? */ isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        const mpsBefore = this.beforeState().multiPolys;\n        const mpsAfter = this.afterState().multiPolys;\n        switch(operation.type){\n            case \"union\":\n                {\n                    // UNION - included iff:\n                    //  * On one side of us there is 0 poly interiors AND\n                    //  * On the other side there is 1 or more.\n                    const noBefores = mpsBefore.length === 0;\n                    const noAfters = mpsAfter.length === 0;\n                    this._isInResult = noBefores !== noAfters;\n                    break;\n                }\n            case \"intersection\":\n                {\n                    // INTERSECTION - included iff:\n                    //  * on one side of us all multipolys are rep. with poly interiors AND\n                    //  * on the other side of us, not all multipolys are repsented\n                    //    with poly interiors\n                    let least;\n                    let most;\n                    if (mpsBefore.length < mpsAfter.length) {\n                        least = mpsBefore.length;\n                        most = mpsAfter.length;\n                    } else {\n                        least = mpsAfter.length;\n                        most = mpsBefore.length;\n                    }\n                    this._isInResult = most === operation.numMultiPolys && least < most;\n                    break;\n                }\n            case \"xor\":\n                {\n                    // XOR - included iff:\n                    //  * the difference between the number of multipolys represented\n                    //    with poly interiors on our two sides is an odd number\n                    const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n                    this._isInResult = diff % 2 === 1;\n                    break;\n                }\n            case \"difference\":\n                {\n                    // DIFFERENCE included iff:\n                    //  * on exactly one side, we have just the subject\n                    const isJustSubject = (mps)=>mps.length === 1 && mps[0].isSubject;\n                    this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n                    break;\n                }\n            default:\n                throw new Error(`Unrecognized operation type found ${operation.type}`);\n        }\n        return this._isInResult;\n    }\n}\nclass RingIn {\n    constructor(geomRing, poly, isExterior){\n        if (!Array.isArray(geomRing) || geomRing.length === 0) {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.poly = poly;\n        this.isExterior = isExterior;\n        this.segments = [];\n        if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n        this.bbox = {\n            ll: {\n                x: firstPoint.x,\n                y: firstPoint.y\n            },\n            ur: {\n                x: firstPoint.x,\n                y: firstPoint.y\n            }\n        };\n        let prevPoint = firstPoint;\n        for(let i = 1, iMax = geomRing.length; i < iMax; i++){\n            if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n                throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n            }\n            let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n            // skip repeated points\n            if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n            this.segments.push(Segment.fromRing(prevPoint, point, this));\n            if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n            if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n            if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n            if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n            prevPoint = point;\n        }\n        // add segment from last to first if last is not the same as first\n        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n            this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n        }\n    }\n    getSweepEvents() {\n        const sweepEvents = [];\n        for(let i = 0, iMax = this.segments.length; i < iMax; i++){\n            const segment = this.segments[i];\n            sweepEvents.push(segment.leftSE);\n            sweepEvents.push(segment.rightSE);\n        }\n        return sweepEvents;\n    }\n}\nclass PolyIn {\n    constructor(geomPoly, multiPoly){\n        if (!Array.isArray(geomPoly)) {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.exteriorRing = new RingIn(geomPoly[0], this, true);\n        // copy by value\n        this.bbox = {\n            ll: {\n                x: this.exteriorRing.bbox.ll.x,\n                y: this.exteriorRing.bbox.ll.y\n            },\n            ur: {\n                x: this.exteriorRing.bbox.ur.x,\n                y: this.exteriorRing.bbox.ur.y\n            }\n        };\n        this.interiorRings = [];\n        for(let i = 1, iMax = geomPoly.length; i < iMax; i++){\n            const ring = new RingIn(geomPoly[i], this, false);\n            if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n            if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n            if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n            if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n            this.interiorRings.push(ring);\n        }\n        this.multiPoly = multiPoly;\n    }\n    getSweepEvents() {\n        const sweepEvents = this.exteriorRing.getSweepEvents();\n        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){\n            const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n            for(let j = 0, jMax = ringSweepEvents.length; j < jMax; j++){\n                sweepEvents.push(ringSweepEvents[j]);\n            }\n        }\n        return sweepEvents;\n    }\n}\nclass MultiPolyIn {\n    constructor(geom, isSubject){\n        if (!Array.isArray(geom)) {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        try {\n            // if the input looks like a polygon, convert it to a multipolygon\n            if (typeof geom[0][0][0] === \"number\") geom = [\n                geom\n            ];\n        } catch (ex) {\n        // The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n        }\n        this.polys = [];\n        this.bbox = {\n            ll: {\n                x: Number.POSITIVE_INFINITY,\n                y: Number.POSITIVE_INFINITY\n            },\n            ur: {\n                x: Number.NEGATIVE_INFINITY,\n                y: Number.NEGATIVE_INFINITY\n            }\n        };\n        for(let i = 0, iMax = geom.length; i < iMax; i++){\n            const poly = new PolyIn(geom[i], this);\n            if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n            if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n            if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n            if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n            this.polys.push(poly);\n        }\n        this.isSubject = isSubject;\n    }\n    getSweepEvents() {\n        const sweepEvents = [];\n        for(let i = 0, iMax = this.polys.length; i < iMax; i++){\n            const polySweepEvents = this.polys[i].getSweepEvents();\n            for(let j = 0, jMax = polySweepEvents.length; j < jMax; j++){\n                sweepEvents.push(polySweepEvents[j]);\n            }\n        }\n        return sweepEvents;\n    }\n}\nclass RingOut {\n    /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */ static factory(allSegments) {\n        const ringsOut = [];\n        for(let i = 0, iMax = allSegments.length; i < iMax; i++){\n            const segment = allSegments[i];\n            if (!segment.isInResult() || segment.ringOut) continue;\n            let prevEvent = null;\n            let event = segment.leftSE;\n            let nextEvent = segment.rightSE;\n            const events = [\n                event\n            ];\n            const startingPoint = event.point;\n            const intersectionLEs = [];\n            /* Walk the chain of linked events to form a closed ring */ while(true){\n                prevEvent = event;\n                event = nextEvent;\n                events.push(event);\n                /* Is the ring complete? */ if (event.point === startingPoint) break;\n                while(true){\n                    const availableLEs = event.getAvailableLinkedEvents();\n                    /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */ if (availableLEs.length === 0) {\n                        const firstPt = events[0].point;\n                        const lastPt = events[events.length - 1].point;\n                        throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n                    }\n                    /* Only one way to go, so cotinue on the path */ if (availableLEs.length === 1) {\n                        nextEvent = availableLEs[0].otherSE;\n                        break;\n                    }\n                    /* We must have an intersection. Check for a completed loop */ let indexLE = null;\n                    for(let j = 0, jMax = intersectionLEs.length; j < jMax; j++){\n                        if (intersectionLEs[j].point === event.point) {\n                            indexLE = j;\n                            break;\n                        }\n                    }\n                    /* Found a completed loop. Cut that off and make a ring */ if (indexLE !== null) {\n                        const intersectionLE = intersectionLEs.splice(indexLE)[0];\n                        const ringEvents = events.splice(intersectionLE.index);\n                        ringEvents.unshift(ringEvents[0].otherSE);\n                        ringsOut.push(new RingOut(ringEvents.reverse()));\n                        continue;\n                    }\n                    /* register the intersection */ intersectionLEs.push({\n                        index: events.length,\n                        point: event.point\n                    });\n                    /* Choose the left-most option to continue the walk */ const comparator = event.getLeftmostComparator(prevEvent);\n                    nextEvent = availableLEs.sort(comparator)[0].otherSE;\n                    break;\n                }\n            }\n            ringsOut.push(new RingOut(events));\n        }\n        return ringsOut;\n    }\n    constructor(events){\n        this.events = events;\n        for(let i = 0, iMax = events.length; i < iMax; i++){\n            events[i].segment.ringOut = this;\n        }\n        this.poly = null;\n    }\n    getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        let prevPt = this.events[0].point;\n        const points = [\n            prevPt\n        ];\n        for(let i = 1, iMax = this.events.length - 1; i < iMax; i++){\n            const pt = this.events[i].point;\n            const nextPt = this.events[i + 1].point;\n            if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n            points.push(pt);\n            prevPt = pt;\n        }\n        // ring was all (within rounding error of angle calc) colinear points\n        if (points.length === 1) return null;\n        // check if the starting point is necessary\n        const pt = points[0];\n        const nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        const step = this.isExteriorRing() ? 1 : -1;\n        const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        const iEnd = this.isExteriorRing() ? points.length : -1;\n        const orderedPoints = [];\n        for(let i = iStart; i != iEnd; i += step)orderedPoints.push([\n            points[i].x,\n            points[i].y\n        ]);\n        return orderedPoints;\n    }\n    isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n            const enclosing = this.enclosingRing();\n            this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n        return this._isExteriorRing;\n    }\n    enclosingRing() {\n        if (this._enclosingRing === undefined) {\n            this._enclosingRing = this._calcEnclosingRing();\n        }\n        return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */ _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        let leftMostEvt = this.events[0];\n        for(let i = 1, iMax = this.events.length; i < iMax; i++){\n            const evt = this.events[i];\n            if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n        let prevSeg = leftMostEvt.segment.prevInResult();\n        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        while(true){\n            // no segment found, thus no ring can enclose us\n            if (!prevSeg) return null;\n            // no segments below prev segment found, thus the ring of the prev\n            // segment must loop back around and enclose us\n            if (!prevPrevSeg) return prevSeg.ringOut;\n            // if the two segments are of different rings, the ring of the prev\n            // segment must either loop around us or the ring of the prev prev\n            // seg, which would make us and the ring of the prev peers\n            if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n                if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n                    return prevSeg.ringOut;\n                } else return prevSeg.ringOut.enclosingRing();\n            }\n            // two segments are from the same ring, so this was a penisula\n            // of that ring. iterate downward, keep searching\n            prevSeg = prevPrevSeg.prevInResult();\n            prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n    }\n}\nclass PolyOut {\n    constructor(exteriorRing){\n        this.exteriorRing = exteriorRing;\n        exteriorRing.poly = this;\n        this.interiorRings = [];\n    }\n    addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n    }\n    getGeom() {\n        const geom = [\n            this.exteriorRing.getGeom()\n        ];\n        // exterior ring was all (within rounding error of angle calc) colinear points\n        if (geom[0] === null) return null;\n        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){\n            const ringGeom = this.interiorRings[i].getGeom();\n            // interior ring was all (within rounding error of angle calc) colinear points\n            if (ringGeom === null) continue;\n            geom.push(ringGeom);\n        }\n        return geom;\n    }\n}\nclass MultiPolyOut {\n    constructor(rings){\n        this.rings = rings;\n        this.polys = this._composePolys(rings);\n    }\n    getGeom() {\n        const geom = [];\n        for(let i = 0, iMax = this.polys.length; i < iMax; i++){\n            const polyGeom = this.polys[i].getGeom();\n            // exterior ring was all (within rounding error of angle calc) colinear points\n            if (polyGeom === null) continue;\n            geom.push(polyGeom);\n        }\n        return geom;\n    }\n    _composePolys(rings) {\n        const polys = [];\n        for(let i = 0, iMax = rings.length; i < iMax; i++){\n            const ring = rings[i];\n            if (ring.poly) continue;\n            if (ring.isExteriorRing()) polys.push(new PolyOut(ring));\n            else {\n                const enclosingRing = ring.enclosingRing();\n                if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n                enclosingRing.poly.addInterior(ring);\n            }\n        }\n        return polys;\n    }\n}\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */ class SweepLine {\n    constructor(queue){\n        let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n        this.queue = queue;\n        this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](comparator);\n        this.segments = [];\n    }\n    process(event) {\n        const segment = event.segment;\n        const newEvents = [];\n        // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n        if (event.consumedBy) {\n            if (event.isLeft) this.queue.remove(event.otherSE);\n            else this.tree.remove(segment);\n            return newEvents;\n        }\n        const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n        if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n        let prevNode = node;\n        let nextNode = node;\n        let prevSeg = undefined;\n        let nextSeg = undefined;\n        // skip consumed segments still in tree\n        while(prevSeg === undefined){\n            prevNode = this.tree.prev(prevNode);\n            if (prevNode === null) prevSeg = null;\n            else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        }\n        // skip consumed segments still in tree\n        while(nextSeg === undefined){\n            nextNode = this.tree.next(nextNode);\n            if (nextNode === null) nextSeg = null;\n            else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n        if (event.isLeft) {\n            // Check for intersections against the previous segment in the sweep line\n            let prevMySplitter = null;\n            if (prevSeg) {\n                const prevInter = prevSeg.getIntersection(segment);\n                if (prevInter !== null) {\n                    if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n                    if (!prevSeg.isAnEndpoint(prevInter)) {\n                        const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){\n                            newEvents.push(newEventsFromSplit[i]);\n                        }\n                    }\n                }\n            }\n            // Check for intersections against the next segment in the sweep line\n            let nextMySplitter = null;\n            if (nextSeg) {\n                const nextInter = nextSeg.getIntersection(segment);\n                if (nextInter !== null) {\n                    if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n                    if (!nextSeg.isAnEndpoint(nextInter)) {\n                        const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){\n                            newEvents.push(newEventsFromSplit[i]);\n                        }\n                    }\n                }\n            }\n            // For simplicity, even if we find more than one intersection we only\n            // spilt on the 'earliest' (sweep-line style) of the intersections.\n            // The other intersection will be handled in a future process().\n            if (prevMySplitter !== null || nextMySplitter !== null) {\n                let mySplitter = null;\n                if (prevMySplitter === null) mySplitter = nextMySplitter;\n                else if (nextMySplitter === null) mySplitter = prevMySplitter;\n                else {\n                    const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n                }\n                // Rounding errors can cause changes in ordering,\n                // so remove afected segments and right sweep events before splitting\n                this.queue.remove(segment.rightSE);\n                newEvents.push(segment.rightSE);\n                const newEventsFromSplit = segment.split(mySplitter);\n                for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){\n                    newEvents.push(newEventsFromSplit[i]);\n                }\n            }\n            if (newEvents.length > 0) {\n                // We found some intersections, so re-do the current event to\n                // make sure sweep line ordering is totally consistent for later\n                // use with the segment 'prev' pointers\n                this.tree.remove(segment);\n                newEvents.push(event);\n            } else {\n                // done with left event\n                this.segments.push(segment);\n                segment.prev = prevSeg;\n            }\n        } else {\n            // event.isRight\n            // since we're about to be removed from the sweep line, check for\n            // intersections between our previous and next segments\n            if (prevSeg && nextSeg) {\n                const inter = prevSeg.getIntersection(nextSeg);\n                if (inter !== null) {\n                    if (!prevSeg.isAnEndpoint(inter)) {\n                        const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){\n                            newEvents.push(newEventsFromSplit[i]);\n                        }\n                    }\n                    if (!nextSeg.isAnEndpoint(inter)) {\n                        const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){\n                            newEvents.push(newEventsFromSplit[i]);\n                        }\n                    }\n                }\n            }\n            this.tree.remove(segment);\n        }\n        return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */ _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        const rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        const newEvents = seg.split(pt);\n        newEvents.push(rightSE);\n        // splitting can trigger consumption\n        if (seg.consumedBy === undefined) this.tree.add(seg);\n        return newEvents;\n    }\n}\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n    run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */ const multipolys = [\n            new MultiPolyIn(geom, true)\n        ];\n        for(let i = 0, iMax = moreGeoms.length; i < iMax; i++){\n            multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */ if (operation.type === \"difference\") {\n            // in place removal\n            const subject = multipolys[0];\n            let i = 1;\n            while(i < multipolys.length){\n                if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;\n                else multipolys.splice(i, 1);\n            }\n        }\n        /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */ if (operation.type === \"intersection\") {\n            // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n            //       it could be optimized to O(n * ln(n))\n            for(let i = 0, iMax = multipolys.length; i < iMax; i++){\n                const mpA = multipolys[i];\n                for(let j = i + 1, jMax = multipolys.length; j < jMax; j++){\n                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n                }\n            }\n        }\n        /* Put segment endpoints in a priority queue */ const queue = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](SweepEvent.compare);\n        for(let i = 0, iMax = multipolys.length; i < iMax; i++){\n            const sweepEvents = multipolys[i].getSweepEvents();\n            for(let j = 0, jMax = sweepEvents.length; j < jMax; j++){\n                queue.insert(sweepEvents[j]);\n                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n                    // prevents an infinite loop, an otherwise common manifestation of bugs\n                    throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n                }\n            }\n        }\n        /* Pass the sweep line over those endpoints */ const sweepLine = new SweepLine(queue);\n        let prevQueueSize = queue.size;\n        let node = queue.pop();\n        while(node){\n            const evt = node.key;\n            if (queue.size === prevQueueSize) {\n                // prevents an infinite loop, an otherwise common manifestation of bugs\n                const seg = evt.segment;\n                throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n            }\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n                // prevents an infinite loop, an otherwise common manifestation of bugs\n                throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n            }\n            if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n                // prevents an infinite loop, an otherwise common manifestation of bugs\n                throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n            }\n            const newEvents = sweepLine.process(evt);\n            for(let i = 0, iMax = newEvents.length; i < iMax; i++){\n                const evt = newEvents[i];\n                if (evt.consumedBy === undefined) queue.insert(evt);\n            }\n            prevQueueSize = queue.size;\n            node = queue.pop();\n        }\n        // free some memory we don't need anymore\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */ const ringsOut = RingOut.factory(sweepLine.segments);\n        const result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n    }\n}\n// singleton available by import\nconst operation = new Operation();\nconst union = function(geom) {\n    for(var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        moreGeoms[_key - 1] = arguments[_key];\n    }\n    return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function(geom) {\n    for(var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n        moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n    return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function(geom) {\n    for(var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n        moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n    return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function(subjectGeom) {\n    for(var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n        clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n    return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n    union: union,\n    intersection: intersection,\n    xor: xor,\n    difference: difference\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9kaXN0L3BvbHlnb24tY2xpcHBpbmcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNXO0FBRTdDOzs7OztDQUtDLEdBRUQsTUFBTUUsV0FBVyxDQUFDQyxNQUFNQztJQUN0QixPQUFPRCxLQUFLRSxFQUFFLENBQUNDLENBQUMsSUFBSUYsTUFBTUUsQ0FBQyxJQUFJRixNQUFNRSxDQUFDLElBQUlILEtBQUtJLEVBQUUsQ0FBQ0QsQ0FBQyxJQUFJSCxLQUFLRSxFQUFFLENBQUNHLENBQUMsSUFBSUosTUFBTUksQ0FBQyxJQUFJSixNQUFNSSxDQUFDLElBQUlMLEtBQUtJLEVBQUUsQ0FBQ0MsQ0FBQztBQUNyRztBQUVBOztvQkFFb0IsR0FDcEIsTUFBTUMsaUJBQWlCLENBQUNDLElBQUlDO0lBQzFCLHFDQUFxQztJQUNyQyxJQUFJQSxHQUFHSixFQUFFLENBQUNELENBQUMsR0FBR0ksR0FBR0wsRUFBRSxDQUFDQyxDQUFDLElBQUlJLEdBQUdILEVBQUUsQ0FBQ0QsQ0FBQyxHQUFHSyxHQUFHTixFQUFFLENBQUNDLENBQUMsSUFBSUssR0FBR0osRUFBRSxDQUFDQyxDQUFDLEdBQUdFLEdBQUdMLEVBQUUsQ0FBQ0csQ0FBQyxJQUFJRSxHQUFHSCxFQUFFLENBQUNDLENBQUMsR0FBR0csR0FBR04sRUFBRSxDQUFDRyxDQUFDLEVBQUUsT0FBTztJQUU3RiwrQkFBK0I7SUFDL0IsTUFBTUksU0FBU0YsR0FBR0wsRUFBRSxDQUFDQyxDQUFDLEdBQUdLLEdBQUdOLEVBQUUsQ0FBQ0MsQ0FBQyxHQUFHSyxHQUFHTixFQUFFLENBQUNDLENBQUMsR0FBR0ksR0FBR0wsRUFBRSxDQUFDQyxDQUFDO0lBQ3BELE1BQU1PLFNBQVNILEdBQUdILEVBQUUsQ0FBQ0QsQ0FBQyxHQUFHSyxHQUFHSixFQUFFLENBQUNELENBQUMsR0FBR0ksR0FBR0gsRUFBRSxDQUFDRCxDQUFDLEdBQUdLLEdBQUdKLEVBQUUs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Li9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9kaXN0L3BvbHlnb24tY2xpcHBpbmcuZXNtLmpzPzQxYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNwbGF5VHJlZSBmcm9tICdzcGxheXRyZWUnO1xuaW1wb3J0IHsgb3JpZW50MmQgfSBmcm9tICdyb2J1c3QtcHJlZGljYXRlcyc7XG5cbi8qKlxuICogQSBib3VuZGluZyBib3ggaGFzIHRoZSBmb3JtYXQ6XG4gKlxuICogIHsgbGw6IHsgeDogeG1pbiwgeTogeW1pbiB9LCB1cjogeyB4OiB4bWF4LCB5OiB5bWF4IH0gfVxuICpcbiAqL1xuXG5jb25zdCBpc0luQmJveCA9IChiYm94LCBwb2ludCkgPT4ge1xuICByZXR1cm4gYmJveC5sbC54IDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSBiYm94LnVyLnggJiYgYmJveC5sbC55IDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBiYm94LnVyLnk7XG59O1xuXG4vKiBSZXR1cm5zIGVpdGhlciBudWxsLCBvciBhIGJib3ggKGFrYSBhbiBvcmRlcmVkIHBhaXIgb2YgcG9pbnRzKVxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnQgb2Ygb3ZlcmxhcCwgYSBiYm94IHdpdGggaWRlbnRpY2FsIHBvaW50c1xuICogd2lsbCBiZSByZXR1cm5lZCAqL1xuY29uc3QgZ2V0QmJveE92ZXJsYXAgPSAoYjEsIGIyKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHRoZSBiYm94ZXMgb3ZlcmxhcCBhdCBhbGxcbiAgaWYgKGIyLnVyLnggPCBiMS5sbC54IHx8IGIxLnVyLnggPCBiMi5sbC54IHx8IGIyLnVyLnkgPCBiMS5sbC55IHx8IGIxLnVyLnkgPCBiMi5sbC55KSByZXR1cm4gbnVsbDtcblxuICAvLyBmaW5kIHRoZSBtaWRkbGUgdHdvIFggdmFsdWVzXG4gIGNvbnN0IGxvd2VyWCA9IGIxLmxsLnggPCBiMi5sbC54ID8gYjIubGwueCA6IGIxLmxsLng7XG4gIGNvbnN0IHVwcGVyWCA9IGIxLnVyLnggPCBiMi51ci54ID8gYjEudXIueCA6IGIyLnVyLng7XG5cbiAgLy8gZmluZCB0aGUgbWlkZGxlIHR3byBZIHZhbHVlc1xuICBjb25zdCBsb3dlclkgPSBiMS5sbC55IDwgYjIubGwueSA/IGIyLmxsLnkgOiBiMS5sbC55O1xuICBjb25zdCB1cHBlclkgPSBiMS51ci55IDwgYjIudXIueSA/IGIxLnVyLnkgOiBiMi51ci55O1xuXG4gIC8vIHB1dCB0aG9zZSBtaWRkbGUgdmFsdWVzIHRvZ2V0aGVyIHRvIGdldCB0aGUgb3ZlcmxhcFxuICByZXR1cm4ge1xuICAgIGxsOiB7XG4gICAgICB4OiBsb3dlclgsXG4gICAgICB5OiBsb3dlcllcbiAgICB9LFxuICAgIHVyOiB7XG4gICAgICB4OiB1cHBlclgsXG4gICAgICB5OiB1cHBlcllcbiAgICB9XG4gIH07XG59O1xuXG4vKiBKYXZhc2NyaXB0IGRvZXNuJ3QgZG8gaW50ZWdlciBtYXRoLiBFdmVyeXRoaW5nIGlzXG4gKiBmbG9hdGluZyBwb2ludCB3aXRoIHBlcmNpc2lvbiBOdW1iZXIuRVBTSUxPTi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvRVBTSUxPTlxuICovXG5cbmxldCBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT047XG5cbi8vIElFIFBvbHlmaWxsXG5pZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSBlcHNpbG9uID0gTWF0aC5wb3coMiwgLTUyKTtcbmNvbnN0IEVQU0lMT05fU1EgPSBlcHNpbG9uICogZXBzaWxvbjtcblxuLyogRkxQIGNvbXBhcmF0b3IgKi9cbmNvbnN0IGNtcCA9IChhLCBiKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHRoZXkncmUgYm90aCAwXG4gIGlmICgtZXBzaWxvbiA8IGEgJiYgYSA8IGVwc2lsb24pIHtcbiAgICBpZiAoLWVwc2lsb24gPCBiICYmIGIgPCBlcHNpbG9uKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiB0aGV5J3JlIGZscCBlcXVhbFxuICBjb25zdCBhYiA9IGEgLSBiO1xuICBpZiAoYWIgKiBhYiA8IEVQU0lMT05fU1EgKiBhICogYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gbm9ybWFsIGNvbXBhcmlzb25cbiAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJvdW5kcyBpbmNvbWluZyB2YWx1ZXMgc3VmZmljaWVudGx5IHNvIHRoYXRcbiAqIGZsb2F0aW5nIHBvaW50cyBwcm9ibGVtcyBhcmUsIGZvciB0aGUgbW9zdCBwYXJ0LCBhdm9pZGVkLlxuICpcbiAqIEluY29taW5nIHBvaW50cyBhcmUgaGF2ZSB0aGVpciB4ICYgeSB2YWx1ZXMgdGVzdGVkIGFnYWluc3RcbiAqIGFsbCBwcmV2aW91c2x5IHNlZW4geCAmIHkgdmFsdWVzLiBJZiBlaXRoZXIgaXMgJ3RvbyBjbG9zZSdcbiAqIHRvIGEgcHJldmlvdXNseSBzZWVuIHZhbHVlLCBpdCdzIHZhbHVlIGlzICdzbmFwcGVkJyB0byB0aGVcbiAqIHByZXZpb3VzbHkgc2VlbiB2YWx1ZS5cbiAqXG4gKiBBbGwgcG9pbnRzIHNob3VsZCBiZSByb3VuZGVkIGJ5IHRoaXMgY2xhc3MgYmVmb3JlIGJlaW5nXG4gKiBzdG9yZWQgaW4gYW55IGRhdGEgc3RydWN0dXJlcyBpbiB0aGUgcmVzdCBvZiB0aGlzIGFsZ29yaXRobS5cbiAqL1xuXG5jbGFzcyBQdFJvdW5kZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy54Um91bmRlciA9IG5ldyBDb29yZFJvdW5kZXIoKTtcbiAgICB0aGlzLnlSb3VuZGVyID0gbmV3IENvb3JkUm91bmRlcigpO1xuICB9XG4gIHJvdW5kKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54Um91bmRlci5yb3VuZCh4KSxcbiAgICAgIHk6IHRoaXMueVJvdW5kZXIucm91bmQoeSlcbiAgICB9O1xuICB9XG59XG5jbGFzcyBDb29yZFJvdW5kZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRyZWUgPSBuZXcgU3BsYXlUcmVlKCk7XG4gICAgLy8gcHJlc2VlZCB3aXRoIDAgc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGggdmFsdWVzIDwgTnVtYmVyLkVQU0lMT05cbiAgICB0aGlzLnJvdW5kKDApO1xuICB9XG5cbiAgLy8gTm90ZTogdGhpcyBjYW4gcm91bmRzIGlucHV0IHZhbHVlcyBiYWNrd2FyZHMgb3IgZm9yd2FyZHMuXG4gIC8vICAgICAgIFlvdSBtaWdodCBhc2ssIHdoeSBub3QgcmVzdHJpY3QgdGhpcyB0byBqdXN0IHJvdW5kaW5nXG4gIC8vICAgICAgIGZvcndhcmRzPyBXb3VsZG4ndCB0aGF0IGFsbG93IGxlZnQgZW5kcG9pbnRzIHRvIGFsd2F5c1xuICAvLyAgICAgICByZW1haW4gbGVmdCBlbmRwb2ludHMgZHVyaW5nIHNwbGl0dGluZyAobmV2ZXIgY2hhbmdlIHRvXG4gIC8vICAgICAgIHJpZ2h0KS4gTm8gLSBpdCB3b3VsZG4ndCwgYmVjYXVzZSB3ZSBzbmFwIGludGVyc2VjdGlvbnNcbiAgLy8gICAgICAgdG8gZW5kcG9pbnRzICh0byBlc3RhYmxpc2ggaW5kZXBlbmRlbmNlIGZyb20gdGhlIHNlZ21lbnRcbiAgLy8gICAgICAgYW5nbGUgZm9yIHQtaW50ZXJzZWN0aW9ucykuXG4gIHJvdW5kKGNvb3JkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMudHJlZS5hZGQoY29vcmQpO1xuICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy50cmVlLnByZXYobm9kZSk7XG4gICAgaWYgKHByZXZOb2RlICE9PSBudWxsICYmIGNtcChub2RlLmtleSwgcHJldk5vZGUua2V5KSA9PT0gMCkge1xuICAgICAgdGhpcy50cmVlLnJlbW92ZShjb29yZCk7XG4gICAgICByZXR1cm4gcHJldk5vZGUua2V5O1xuICAgIH1cbiAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMudHJlZS5uZXh0KG5vZGUpO1xuICAgIGlmIChuZXh0Tm9kZSAhPT0gbnVsbCAmJiBjbXAobm9kZS5rZXksIG5leHROb2RlLmtleSkgPT09IDApIHtcbiAgICAgIHRoaXMudHJlZS5yZW1vdmUoY29vcmQpO1xuICAgICAgcmV0dXJuIG5leHROb2RlLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBhdmFpbGFibGUgYnkgaW1wb3J0XG5jb25zdCByb3VuZGVyID0gbmV3IFB0Um91bmRlcigpO1xuXG4vKiBDcm9zcyBQcm9kdWN0IG9mIHR3byB2ZWN0b3JzIHdpdGggZmlyc3QgcG9pbnQgYXQgb3JpZ2luICovXG5jb25zdCBjcm9zc1Byb2R1Y3QgPSAoYSwgYikgPT4gYS54ICogYi55IC0gYS55ICogYi54O1xuXG4vKiBEb3QgUHJvZHVjdCBvZiB0d28gdmVjdG9ycyB3aXRoIGZpcnN0IHBvaW50IGF0IG9yaWdpbiAqL1xuY29uc3QgZG90UHJvZHVjdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG5cbi8qIENvbXBhcmF0b3IgZm9yIHR3byB2ZWN0b3JzIHdpdGggc2FtZSBzdGFydGluZyBwb2ludCAqL1xuY29uc3QgY29tcGFyZVZlY3RvckFuZ2xlcyA9IChiYXNlUHQsIGVuZFB0MSwgZW5kUHQyKSA9PiB7XG4gIGNvbnN0IHJlcyA9IG9yaWVudDJkKGJhc2VQdC54LCBiYXNlUHQueSwgZW5kUHQxLngsIGVuZFB0MS55LCBlbmRQdDIueCwgZW5kUHQyLnkpO1xuICBpZiAocmVzID4gMCkgcmV0dXJuIC0xO1xuICBpZiAocmVzIDwgMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcbmNvbnN0IGxlbmd0aCA9IHYgPT4gTWF0aC5zcXJ0KGRvdFByb2R1Y3QodiwgdikpO1xuXG4vKiBHZXQgdGhlIHNpbmUgb2YgdGhlIGFuZ2xlIGZyb20gcFNoYXJlZCAtPiBwQW5nbGUgdG8gcFNoYWVkIC0+IHBCYXNlICovXG5jb25zdCBzaW5lT2ZBbmdsZSA9IChwU2hhcmVkLCBwQmFzZSwgcEFuZ2xlKSA9PiB7XG4gIGNvbnN0IHZCYXNlID0ge1xuICAgIHg6IHBCYXNlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEJhc2UueSAtIHBTaGFyZWQueVxuICB9O1xuICBjb25zdCB2QW5nbGUgPSB7XG4gICAgeDogcEFuZ2xlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEFuZ2xlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgcmV0dXJuIGNyb3NzUHJvZHVjdCh2QW5nbGUsIHZCYXNlKSAvIGxlbmd0aCh2QW5nbGUpIC8gbGVuZ3RoKHZCYXNlKTtcbn07XG5cbi8qIEdldCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBmcm9tIHBTaGFyZWQgLT4gcEFuZ2xlIHRvIHBTaGFlZCAtPiBwQmFzZSAqL1xuY29uc3QgY29zaW5lT2ZBbmdsZSA9IChwU2hhcmVkLCBwQmFzZSwgcEFuZ2xlKSA9PiB7XG4gIGNvbnN0IHZCYXNlID0ge1xuICAgIHg6IHBCYXNlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEJhc2UueSAtIHBTaGFyZWQueVxuICB9O1xuICBjb25zdCB2QW5nbGUgPSB7XG4gICAgeDogcEFuZ2xlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEFuZ2xlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgcmV0dXJuIGRvdFByb2R1Y3QodkFuZ2xlLCB2QmFzZSkgLyBsZW5ndGgodkFuZ2xlKSAvIGxlbmd0aCh2QmFzZSk7XG59O1xuXG4vKiBHZXQgdGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgZ2l2ZW4gbGluZSAoZGVmaW5lZCBieSBhIHBvaW50IGFuZCB2ZWN0b3IpXG4gKiBjcm9zc2VzIHRoZSBob3Jpem9udGFsIGxpbmUgd2l0aCB0aGUgZ2l2ZW4geSBjb29yZGlhbnRlLlxuICogSW4gdGhlIGNhc2Ugb2YgcGFycmFsbGVsIGxpbmVzIChpbmNsdWRpbmcgb3ZlcmxhcHBpbmcgb25lcykgcmV0dXJucyBudWxsLiAqL1xuY29uc3QgaG9yaXpvbnRhbEludGVyc2VjdGlvbiA9IChwdCwgdiwgeSkgPT4ge1xuICBpZiAodi55ID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwdC54ICsgdi54IC8gdi55ICogKHkgLSBwdC55KSxcbiAgICB5OiB5XG4gIH07XG59O1xuXG4vKiBHZXQgdGhlIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgZ2l2ZW4gbGluZSAoZGVmaW5lZCBieSBhIHBvaW50IGFuZCB2ZWN0b3IpXG4gKiBjcm9zc2VzIHRoZSB2ZXJ0aWNhbCBsaW5lIHdpdGggdGhlIGdpdmVuIHggY29vcmRpYW50ZS5cbiAqIEluIHRoZSBjYXNlIG9mIHBhcnJhbGxlbCBsaW5lcyAoaW5jbHVkaW5nIG92ZXJsYXBwaW5nIG9uZXMpIHJldHVybnMgbnVsbC4gKi9cbmNvbnN0IHZlcnRpY2FsSW50ZXJzZWN0aW9uID0gKHB0LCB2LCB4KSA9PiB7XG4gIGlmICh2LnggPT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogcHQueSArIHYueSAvIHYueCAqICh4IC0gcHQueClcbiAgfTtcbn07XG5cbi8qIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lcywgZWFjaCBkZWZpbmVkIGJ5IGEgYmFzZSBwb2ludCBhbmQgYSB2ZWN0b3IuXG4gKiBJbiB0aGUgY2FzZSBvZiBwYXJyYWxsZWwgbGluZXMgKGluY2x1ZGluZyBvdmVybGFwcGluZyBvbmVzKSByZXR1cm5zIG51bGwuICovXG5jb25zdCBpbnRlcnNlY3Rpb24kMSA9IChwdDEsIHYxLCBwdDIsIHYyKSA9PiB7XG4gIC8vIHRha2Ugc29tZSBzaG9ydGN1dHMgZm9yIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGxpbmVzXG4gIC8vIHRoaXMgYWxzbyBlbnN1cmVzIHdlIGRvbid0IGNhbGN1bGF0ZSBhbiBpbnRlcnNlY3Rpb24gYW5kIHRoZW4gZGlzY292ZXJcbiAgLy8gaXQncyBhY3R1YWxseSBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGxpbmVcbiAgaWYgKHYxLnggPT09IDApIHJldHVybiB2ZXJ0aWNhbEludGVyc2VjdGlvbihwdDIsIHYyLCBwdDEueCk7XG4gIGlmICh2Mi54ID09PSAwKSByZXR1cm4gdmVydGljYWxJbnRlcnNlY3Rpb24ocHQxLCB2MSwgcHQyLngpO1xuICBpZiAodjEueSA9PT0gMCkgcmV0dXJuIGhvcml6b250YWxJbnRlcnNlY3Rpb24ocHQyLCB2MiwgcHQxLnkpO1xuICBpZiAodjIueSA9PT0gMCkgcmV0dXJuIGhvcml6b250YWxJbnRlcnNlY3Rpb24ocHQxLCB2MSwgcHQyLnkpO1xuXG4gIC8vIEdlbmVyYWwgY2FzZSBmb3Igbm9uLW92ZXJsYXBwaW5nIHNlZ21lbnRzLlxuICAvLyBUaGlzIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBTY2huZWlkZXIgYW5kIEViZXJseS5cbiAgLy8gaHR0cDovL3d3dy5jaW1lYy5vcmcuYXIvfm5jYWx2by9TY2huZWlkZXJfRWJlcmx5LnBkZiAtIHBnIDI0NFxuXG4gIGNvbnN0IGtyb3NzID0gY3Jvc3NQcm9kdWN0KHYxLCB2Mik7XG4gIGlmIChrcm9zcyA9PSAwKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdmUgPSB7XG4gICAgeDogcHQyLnggLSBwdDEueCxcbiAgICB5OiBwdDIueSAtIHB0MS55XG4gIH07XG4gIGNvbnN0IGQxID0gY3Jvc3NQcm9kdWN0KHZlLCB2MSkgLyBrcm9zcztcbiAgY29uc3QgZDIgPSBjcm9zc1Byb2R1Y3QodmUsIHYyKSAvIGtyb3NzO1xuXG4gIC8vIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBjYWxjdWxhdGlvbnMgdG8gbWluaW1pemUgcm91bmRpbmcgZXJyb3JcbiAgY29uc3QgeDEgPSBwdDEueCArIGQyICogdjEueCxcbiAgICB4MiA9IHB0Mi54ICsgZDEgKiB2Mi54O1xuICBjb25zdCB5MSA9IHB0MS55ICsgZDIgKiB2MS55LFxuICAgIHkyID0gcHQyLnkgKyBkMSAqIHYyLnk7XG4gIGNvbnN0IHggPSAoeDEgKyB4MikgLyAyO1xuICBjb25zdCB5ID0gKHkxICsgeTIpIC8gMjtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn07XG5cbmNsYXNzIFN3ZWVwRXZlbnQge1xuICAvLyBmb3Igb3JkZXJpbmcgc3dlZXAgZXZlbnRzIGluIHRoZSBzd2VlcCBldmVudCBxdWV1ZVxuICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgLy8gZmF2b3IgZXZlbnQgd2l0aCBhIHBvaW50IHRoYXQgdGhlIHN3ZWVwIGxpbmUgaGl0cyBmaXJzdFxuICAgIGNvbnN0IHB0Q21wID0gU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKGEucG9pbnQsIGIucG9pbnQpO1xuICAgIGlmIChwdENtcCAhPT0gMCkgcmV0dXJuIHB0Q21wO1xuXG4gICAgLy8gdGhlIHBvaW50cyBhcmUgdGhlIHNhbWUsIHNvIGxpbmsgdGhlbSBpZiBuZWVkZWRcbiAgICBpZiAoYS5wb2ludCAhPT0gYi5wb2ludCkgYS5saW5rKGIpO1xuXG4gICAgLy8gZmF2b3IgcmlnaHQgZXZlbnRzIG92ZXIgbGVmdFxuICAgIGlmIChhLmlzTGVmdCAhPT0gYi5pc0xlZnQpIHJldHVybiBhLmlzTGVmdCA/IDEgOiAtMTtcblxuICAgIC8vIHdlIGhhdmUgdHdvIG1hdGNoaW5nIGxlZnQgb3IgcmlnaHQgZW5kcG9pbnRzXG4gICAgLy8gb3JkZXJpbmcgb2YgdGhpcyBjYXNlIGlzIHRoZSBzYW1lIGFzIGZvciB0aGVpciBzZWdtZW50c1xuICAgIHJldHVybiBTZWdtZW50LmNvbXBhcmUoYS5zZWdtZW50LCBiLnNlZ21lbnQpO1xuICB9XG5cbiAgLy8gZm9yIG9yZGVyaW5nIHBvaW50cyBpbiBzd2VlcCBsaW5lIG9yZGVyXG4gIHN0YXRpYyBjb21wYXJlUG9pbnRzKGFQdCwgYlB0KSB7XG4gICAgaWYgKGFQdC54IDwgYlB0LngpIHJldHVybiAtMTtcbiAgICBpZiAoYVB0LnggPiBiUHQueCkgcmV0dXJuIDE7XG4gICAgaWYgKGFQdC55IDwgYlB0LnkpIHJldHVybiAtMTtcbiAgICBpZiAoYVB0LnkgPiBiUHQueSkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBXYXJuaW5nOiAncG9pbnQnIGlucHV0IHdpbGwgYmUgbW9kaWZpZWQgYW5kIHJlLXVzZWQgKGZvciBwZXJmb3JtYW5jZSlcbiAgY29uc3RydWN0b3IocG9pbnQsIGlzTGVmdCkge1xuICAgIGlmIChwb2ludC5ldmVudHMgPT09IHVuZGVmaW5lZCkgcG9pbnQuZXZlbnRzID0gW3RoaXNdO2Vsc2UgcG9pbnQuZXZlbnRzLnB1c2godGhpcyk7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIHRoaXMuaXNMZWZ0ID0gaXNMZWZ0O1xuICAgIC8vIHRoaXMuc2VnbWVudCwgdGhpcy5vdGhlclNFIHNldCBieSBmYWN0b3J5XG4gIH1cbiAgbGluayhvdGhlcikge1xuICAgIGlmIChvdGhlci5wb2ludCA9PT0gdGhpcy5wb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gbGluayBhbHJlYWR5IGxpbmtlZCBldmVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyRXZlbnRzID0gb3RoZXIucG9pbnQuZXZlbnRzO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gb3RoZXJFdmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBldnQgPSBvdGhlckV2ZW50c1tpXTtcbiAgICAgIHRoaXMucG9pbnQuZXZlbnRzLnB1c2goZXZ0KTtcbiAgICAgIGV2dC5wb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tGb3JDb25zdW1pbmcoKTtcbiAgfVxuXG4gIC8qIERvIGEgcGFzcyBvdmVyIG91ciBsaW5rZWQgZXZlbnRzIGFuZCBjaGVjayB0byBzZWUgaWYgYW55IHBhaXJcbiAgICogb2Ygc2VnbWVudHMgbWF0Y2gsIGFuZCBzaG91bGQgYmUgY29uc3VtZWQuICovXG4gIGNoZWNrRm9yQ29uc3VtaW5nKCkge1xuICAgIC8vIEZJWE1FOiBUaGUgbG9vcHMgaW4gdGhpcyBtZXRob2QgcnVuIE8obl4yKSA9PiBubyBnb29kLlxuICAgIC8vICAgICAgICBNYWludGFpbiBsaXR0bGUgb3JkZXJlZCBzd2VlcCBldmVudCB0cmVlcz9cbiAgICAvLyAgICAgICAgQ2FuIHdlIG1haW50YWluaW5nIGFuIG9yZGVyaW5nIHRoYXQgYXZvaWRzIHRoZSBuZWVkXG4gICAgLy8gICAgICAgIGZvciB0aGUgcmUtc29ydGluZyB3aXRoIGdldExlZnRtb3N0Q29tcGFyYXRvciBpbiBnZW9tLW91dD9cblxuICAgIC8vIENvbXBhcmUgZWFjaCBwYWlyIG9mIGV2ZW50cyB0byBzZWUgaWYgb3RoZXIgZXZlbnRzIGFsc28gbWF0Y2hcbiAgICBjb25zdCBudW1FdmVudHMgPSB0aGlzLnBvaW50LmV2ZW50cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FdmVudHM7IGkrKykge1xuICAgICAgY29uc3QgZXZ0MSA9IHRoaXMucG9pbnQuZXZlbnRzW2ldO1xuICAgICAgaWYgKGV2dDEuc2VnbWVudC5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbnVtRXZlbnRzOyBqKyspIHtcbiAgICAgICAgY29uc3QgZXZ0MiA9IHRoaXMucG9pbnQuZXZlbnRzW2pdO1xuICAgICAgICBpZiAoZXZ0Mi5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZXZ0MS5vdGhlclNFLnBvaW50LmV2ZW50cyAhPT0gZXZ0Mi5vdGhlclNFLnBvaW50LmV2ZW50cykgY29udGludWU7XG4gICAgICAgIGV2dDEuc2VnbWVudC5jb25zdW1lKGV2dDIuc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEF2YWlsYWJsZUxpbmtlZEV2ZW50cygpIHtcbiAgICAvLyBwb2ludC5ldmVudHMgaXMgYWx3YXlzIG9mIGxlbmd0aCAyIG9yIGdyZWF0ZXJcbiAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucG9pbnQuZXZlbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgZXZ0ID0gdGhpcy5wb2ludC5ldmVudHNbaV07XG4gICAgICBpZiAoZXZ0ICE9PSB0aGlzICYmICFldnQuc2VnbWVudC5yaW5nT3V0ICYmIGV2dC5zZWdtZW50LmlzSW5SZXN1bHQoKSkge1xuICAgICAgICBldmVudHMucHVzaChldnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGxpbmtlZCBldmVudHMgdGhhdCB3aWxsXG4gICAqIGZhdm9yIHRoZSBldmVudCB0aGF0IHdpbGwgZ2l2ZSB1cyB0aGUgc21hbGxlc3QgbGVmdC1zaWRlIGFuZ2xlLlxuICAgKiBBbGwgcmluZyBjb25zdHJ1Y3Rpb24gc3RhcnRzIGFzIGxvdyBhcyBwb3NzaWJsZSBoZWFkaW5nIHRvIHRoZSByaWdodCxcbiAgICogc28gYnkgYWx3YXlzIHR1cm5pbmcgbGVmdCBhcyBzaGFycCBhcyBwb3NzaWJsZSB3ZSdsbCBnZXQgcG9seWdvbnNcbiAgICogd2l0aG91dCB1bmNlc3NhcnkgbG9vcHMgJiBob2xlcy5cbiAgICpcbiAgICogVGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gaGFzIGEgY29tcHV0ZSBjYWNoZSBzdWNoIHRoYXQgaXQgYXZvaWRzXG4gICAqIHJlLWNvbXB1dGluZyBhbHJlYWR5LWNvbXB1dGVkIHZhbHVlcy5cbiAgICovXG4gIGdldExlZnRtb3N0Q29tcGFyYXRvcihiYXNlRXZlbnQpIHtcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWxsQ2FjaGUgPSBsaW5rZWRFdmVudCA9PiB7XG4gICAgICBjb25zdCBuZXh0RXZlbnQgPSBsaW5rZWRFdmVudC5vdGhlclNFO1xuICAgICAgY2FjaGUuc2V0KGxpbmtlZEV2ZW50LCB7XG4gICAgICAgIHNpbmU6IHNpbmVPZkFuZ2xlKHRoaXMucG9pbnQsIGJhc2VFdmVudC5wb2ludCwgbmV4dEV2ZW50LnBvaW50KSxcbiAgICAgICAgY29zaW5lOiBjb3NpbmVPZkFuZ2xlKHRoaXMucG9pbnQsIGJhc2VFdmVudC5wb2ludCwgbmV4dEV2ZW50LnBvaW50KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgIGlmICghY2FjaGUuaGFzKGEpKSBmaWxsQ2FjaGUoYSk7XG4gICAgICBpZiAoIWNhY2hlLmhhcyhiKSkgZmlsbENhY2hlKGIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaW5lOiBhc2luZSxcbiAgICAgICAgY29zaW5lOiBhY29zaW5lXG4gICAgICB9ID0gY2FjaGUuZ2V0KGEpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaW5lOiBic2luZSxcbiAgICAgICAgY29zaW5lOiBiY29zaW5lXG4gICAgICB9ID0gY2FjaGUuZ2V0KGIpO1xuXG4gICAgICAvLyBib3RoIG9uIG9yIGFib3ZlIHgtYXhpc1xuICAgICAgaWYgKGFzaW5lID49IDAgJiYgYnNpbmUgPj0gMCkge1xuICAgICAgICBpZiAoYWNvc2luZSA8IGJjb3NpbmUpIHJldHVybiAxO1xuICAgICAgICBpZiAoYWNvc2luZSA+IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGJvdGggYmVsb3cgeC1heGlzXG4gICAgICBpZiAoYXNpbmUgPCAwICYmIGJzaW5lIDwgMCkge1xuICAgICAgICBpZiAoYWNvc2luZSA8IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGFjb3NpbmUgPiBiY29zaW5lKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIG9uZSBhYm92ZSB4LWF4aXMsIG9uZSBiZWxvd1xuICAgICAgaWYgKGJzaW5lIDwgYXNpbmUpIHJldHVybiAtMTtcbiAgICAgIGlmIChic2luZSA+IGFzaW5lKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gIH1cbn1cblxuLy8gR2l2ZSBzZWdtZW50cyB1bmlxdWUgSUQncyB0byBnZXQgY29uc2lzdGVudCBzb3J0aW5nIG9mXG4vLyBzZWdtZW50cyBhbmQgc3dlZXAgZXZlbnRzIHdoZW4gYWxsIGVsc2UgaXMgaWRlbnRpY2FsXG5sZXQgc2VnbWVudElkID0gMDtcbmNsYXNzIFNlZ21lbnQge1xuICAvKiBUaGlzIGNvbXBhcmUoKSBmdW5jdGlvbiBpcyBmb3Igb3JkZXJpbmcgc2VnbWVudHMgaW4gdGhlIHN3ZWVwXG4gICAqIGxpbmUgdHJlZSwgYW5kIGRvZXMgc28gYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWE6XG4gICAqXG4gICAqIENvbnNpZGVyIHRoZSB2ZXJ0aWNhbCBsaW5lIHRoYXQgbGllcyBhbiBpbmZpbmVzdGltYWwgc3RlcCB0byB0aGVcbiAgICogcmlnaHQgb2YgdGhlIHJpZ2h0LW1vcmUgb2YgdGhlIHR3byBsZWZ0IGVuZHBvaW50cyBvZiB0aGUgaW5wdXRcbiAgICogc2VnbWVudHMuIEltYWdpbmUgc2xvd2x5IG1vdmluZyBhIHBvaW50IHVwIGZyb20gbmVnYXRpdmUgaW5maW5pdHlcbiAgICogaW4gdGhlIGluY3JlYXNpbmcgeSBkaXJlY3Rpb24uIFdoaWNoIG9mIHRoZSB0d28gc2VnbWVudHMgd2lsbCB0aGF0XG4gICAqIHBvaW50IGludGVyc2VjdCBmaXJzdD8gVGhhdCBzZWdtZW50IGNvbWVzICdiZWZvcmUnIHRoZSBvdGhlciBvbmUuXG4gICAqXG4gICAqIElmIG5laXRoZXIgc2VnbWVudCB3b3VsZCBiZSBpbnRlcnNlY3RlZCBieSBzdWNoIGEgbGluZSwgKGlmIG9uZVxuICAgKiBvciBtb3JlIG9mIHRoZSBzZWdtZW50cyBhcmUgdmVydGljYWwpIHRoZW4gdGhlIGxpbmUgdG8gYmUgY29uc2lkZXJlZFxuICAgKiBpcyBkaXJlY3RseSBvbiB0aGUgcmlnaHQtbW9yZSBvZiB0aGUgdHdvIGxlZnQgaW5wdXRzLlxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUoYSwgYikge1xuICAgIGNvbnN0IGFseCA9IGEubGVmdFNFLnBvaW50Lng7XG4gICAgY29uc3QgYmx4ID0gYi5sZWZ0U0UucG9pbnQueDtcbiAgICBjb25zdCBhcnggPSBhLnJpZ2h0U0UucG9pbnQueDtcbiAgICBjb25zdCBicnggPSBiLnJpZ2h0U0UucG9pbnQueDtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXkncmUgZXZlbiBpbiB0aGUgc2FtZSB2ZXJ0aWNhbCBwbGFuZVxuICAgIGlmIChicnggPCBhbHgpIHJldHVybiAxO1xuICAgIGlmIChhcnggPCBibHgpIHJldHVybiAtMTtcbiAgICBjb25zdCBhbHkgPSBhLmxlZnRTRS5wb2ludC55O1xuICAgIGNvbnN0IGJseSA9IGIubGVmdFNFLnBvaW50Lnk7XG4gICAgY29uc3QgYXJ5ID0gYS5yaWdodFNFLnBvaW50Lnk7XG4gICAgY29uc3QgYnJ5ID0gYi5yaWdodFNFLnBvaW50Lnk7XG5cbiAgICAvLyBpcyBsZWZ0IGVuZHBvaW50IG9mIHNlZ21lbnQgQiB0aGUgcmlnaHQtbW9yZT9cbiAgICBpZiAoYWx4IDwgYmx4KSB7XG4gICAgICAvLyBhcmUgdGhlIHR3byBzZWdtZW50cyBpbiB0aGUgc2FtZSBob3Jpem9udGFsIHBsYW5lP1xuICAgICAgaWYgKGJseSA8IGFseSAmJiBibHkgPCBhcnkpIHJldHVybiAxO1xuICAgICAgaWYgKGJseSA+IGFseSAmJiBibHkgPiBhcnkpIHJldHVybiAtMTtcblxuICAgICAgLy8gaXMgdGhlIEIgbGVmdCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEE/XG4gICAgICBjb25zdCBhQ21wQkxlZnQgPSBhLmNvbXBhcmVQb2ludChiLmxlZnRTRS5wb2ludCk7XG4gICAgICBpZiAoYUNtcEJMZWZ0IDwgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYUNtcEJMZWZ0ID4gMCkgcmV0dXJuIC0xO1xuXG4gICAgICAvLyBpcyB0aGUgQSByaWdodCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEIgP1xuICAgICAgY29uc3QgYkNtcEFSaWdodCA9IGIuY29tcGFyZVBvaW50KGEucmlnaHRTRS5wb2ludCk7XG4gICAgICBpZiAoYkNtcEFSaWdodCAhPT0gMCkgcmV0dXJuIGJDbXBBUmlnaHQ7XG5cbiAgICAgIC8vIGNvbGluZWFyIHNlZ21lbnRzLCBjb25zaWRlciB0aGUgb25lIHdpdGggbGVmdC1tb3JlXG4gICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIGlzIGxlZnQgZW5kcG9pbnQgb2Ygc2VnbWVudCBBIHRoZSByaWdodC1tb3JlP1xuICAgIGlmIChhbHggPiBibHgpIHtcbiAgICAgIGlmIChhbHkgPCBibHkgJiYgYWx5IDwgYnJ5KSByZXR1cm4gLTE7XG4gICAgICBpZiAoYWx5ID4gYmx5ICYmIGFseSA+IGJyeSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIGlzIHRoZSBBIGxlZnQgZW5kcG9pbnQgY29saW5lYXIgdG8gc2VnbWVudCBCP1xuICAgICAgY29uc3QgYkNtcEFMZWZ0ID0gYi5jb21wYXJlUG9pbnQoYS5sZWZ0U0UucG9pbnQpO1xuICAgICAgaWYgKGJDbXBBTGVmdCAhPT0gMCkgcmV0dXJuIGJDbXBBTGVmdDtcblxuICAgICAgLy8gaXMgdGhlIEIgcmlnaHQgZW5kcG9pbnQgY29saW5lYXIgdG8gc2VnbWVudCBBP1xuICAgICAgY29uc3QgYUNtcEJSaWdodCA9IGEuY29tcGFyZVBvaW50KGIucmlnaHRTRS5wb2ludCk7XG4gICAgICBpZiAoYUNtcEJSaWdodCA8IDApIHJldHVybiAxO1xuICAgICAgaWYgKGFDbXBCUmlnaHQgPiAwKSByZXR1cm4gLTE7XG5cbiAgICAgIC8vIGNvbGluZWFyIHNlZ21lbnRzLCBjb25zaWRlciB0aGUgb25lIHdpdGggbGVmdC1tb3JlXG4gICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHRoZSB0d28gbGVmdCBlbmRwb2ludHMgYXJlIGluIHRoZSBzYW1lXG4gICAgLy8gdmVydGljYWwgcGxhbmUsIGllIGFseCA9PT0gYmx4XG5cbiAgICAvLyBjb25zaWRlciB0aGUgbG93ZXIgbGVmdC1lbmRwb2ludCB0byBjb21lIGZpcnN0XG4gICAgaWYgKGFseSA8IGJseSkgcmV0dXJuIC0xO1xuICAgIGlmIChhbHkgPiBibHkpIHJldHVybiAxO1xuXG4gICAgLy8gbGVmdCBlbmRwb2ludHMgYXJlIGlkZW50aWNhbFxuICAgIC8vIGNoZWNrIGZvciBjb2xpbmVhcml0eSBieSB1c2luZyB0aGUgbGVmdC1tb3JlIHJpZ2h0IGVuZHBvaW50XG5cbiAgICAvLyBpcyB0aGUgQSByaWdodCBlbmRwb2ludCBtb3JlIGxlZnQtbW9yZT9cbiAgICBpZiAoYXJ4IDwgYnJ4KSB7XG4gICAgICBjb25zdCBiQ21wQVJpZ2h0ID0gYi5jb21wYXJlUG9pbnQoYS5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChiQ21wQVJpZ2h0ICE9PSAwKSByZXR1cm4gYkNtcEFSaWdodDtcbiAgICB9XG5cbiAgICAvLyBpcyB0aGUgQiByaWdodCBlbmRwb2ludCBtb3JlIGxlZnQtbW9yZT9cbiAgICBpZiAoYXJ4ID4gYnJ4KSB7XG4gICAgICBjb25zdCBhQ21wQlJpZ2h0ID0gYS5jb21wYXJlUG9pbnQoYi5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChhQ21wQlJpZ2h0IDwgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYUNtcEJSaWdodCA+IDApIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGFyeCAhPT0gYnJ4KSB7XG4gICAgICAvLyBhcmUgdGhlc2UgdHdvIFthbG1vc3RdIHZlcnRpY2FsIHNlZ21lbnRzIHdpdGggb3Bwb3NpdGUgb3JpZW50YXRpb24/XG4gICAgICAvLyBpZiBzbywgdGhlIG9uZSB3aXRoIHRoZSBsb3dlciByaWdodCBlbmRwb2ludCBjb21lcyBmaXJzdFxuICAgICAgY29uc3QgYXkgPSBhcnkgLSBhbHk7XG4gICAgICBjb25zdCBheCA9IGFyeCAtIGFseDtcbiAgICAgIGNvbnN0IGJ5ID0gYnJ5IC0gYmx5O1xuICAgICAgY29uc3QgYnggPSBicnggLSBibHg7XG4gICAgICBpZiAoYXkgPiBheCAmJiBieSA8IGJ4KSByZXR1cm4gMTtcbiAgICAgIGlmIChheSA8IGF4ICYmIGJ5ID4gYngpIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIGNvbGluZWFyIHNlZ21lbnRzIHdpdGggbWF0Y2hpbmcgb3JpZW50YXRpb25cbiAgICAvLyBjb25zaWRlciB0aGUgb25lIHdpdGggbW9yZSBsZWZ0LW1vcmUgcmlnaHQgZW5kcG9pbnQgdG8gYmUgZmlyc3RcbiAgICBpZiAoYXJ4ID4gYnJ4KSByZXR1cm4gMTtcbiAgICBpZiAoYXJ4IDwgYnJ4KSByZXR1cm4gLTE7XG5cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgdHdvIHR3byByaWdodCBlbmRwb2ludHMgYXJlIGluIHRoZSBzYW1lXG4gICAgLy8gdmVydGljYWwgcGxhbmUsIGllIGFyeCA9PT0gYnJ4XG5cbiAgICAvLyBjb25zaWRlciB0aGUgbG93ZXIgcmlnaHQtZW5kcG9pbnQgdG8gY29tZSBmaXJzdFxuICAgIGlmIChhcnkgPCBicnkpIHJldHVybiAtMTtcbiAgICBpZiAoYXJ5ID4gYnJ5KSByZXR1cm4gMTtcblxuICAgIC8vIHJpZ2h0IGVuZHBvaW50cyBpZGVudGljYWwgYXMgd2VsbCwgc28gdGhlIHNlZ21lbnRzIGFyZSBpZGVudGlhbFxuICAgIC8vIGZhbGwgYmFjayBvbiBjcmVhdGlvbiBvcmRlciBhcyBjb25zaXN0ZW50IHRpZS1icmVha2VyXG4gICAgaWYgKGEuaWQgPCBiLmlkKSByZXR1cm4gLTE7XG4gICAgaWYgKGEuaWQgPiBiLmlkKSByZXR1cm4gMTtcblxuICAgIC8vIGlkZW50aWNhbCBzZWdtZW50LCBpZSBhID09PSBiXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKiBXYXJuaW5nOiBhIHJlZmVyZW5jZSB0byByaW5nV2luZGluZ3MgaW5wdXQgd2lsbCBiZSBzdG9yZWQsXG4gICAqICBhbmQgcG9zc2libHkgd2lsbCBiZSBsYXRlciBtb2RpZmllZCAqL1xuICBjb25zdHJ1Y3RvcihsZWZ0U0UsIHJpZ2h0U0UsIHJpbmdzLCB3aW5kaW5ncykge1xuICAgIHRoaXMuaWQgPSArK3NlZ21lbnRJZDtcbiAgICB0aGlzLmxlZnRTRSA9IGxlZnRTRTtcbiAgICBsZWZ0U0Uuc2VnbWVudCA9IHRoaXM7XG4gICAgbGVmdFNFLm90aGVyU0UgPSByaWdodFNFO1xuICAgIHRoaXMucmlnaHRTRSA9IHJpZ2h0U0U7XG4gICAgcmlnaHRTRS5zZWdtZW50ID0gdGhpcztcbiAgICByaWdodFNFLm90aGVyU0UgPSBsZWZ0U0U7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMud2luZGluZ3MgPSB3aW5kaW5ncztcbiAgICAvLyBsZWZ0IHVuc2V0IGZvciBwZXJmb3JtYW5jZSwgc2V0IGxhdGVyIGluIGFsZ29yaXRobVxuICAgIC8vIHRoaXMucmluZ091dCwgdGhpcy5jb25zdW1lZEJ5LCB0aGlzLnByZXZcbiAgfVxuICBzdGF0aWMgZnJvbVJpbmcocHQxLCBwdDIsIHJpbmcpIHtcbiAgICBsZXQgbGVmdFB0LCByaWdodFB0LCB3aW5kaW5nO1xuXG4gICAgLy8gb3JkZXJpbmcgdGhlIHR3byBwb2ludHMgYWNjb3JkaW5nIHRvIHN3ZWVwIGxpbmUgb3JkZXJpbmdcbiAgICBjb25zdCBjbXBQdHMgPSBTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHMocHQxLCBwdDIpO1xuICAgIGlmIChjbXBQdHMgPCAwKSB7XG4gICAgICBsZWZ0UHQgPSBwdDE7XG4gICAgICByaWdodFB0ID0gcHQyO1xuICAgICAgd2luZGluZyA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXBQdHMgPiAwKSB7XG4gICAgICBsZWZ0UHQgPSBwdDI7XG4gICAgICByaWdodFB0ID0gcHQxO1xuICAgICAgd2luZGluZyA9IC0xO1xuICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGNyZWF0ZSBkZWdlbmVyYXRlIHNlZ21lbnQgYXQgWyR7cHQxLnh9LCAke3B0MS55fV1gKTtcbiAgICBjb25zdCBsZWZ0U0UgPSBuZXcgU3dlZXBFdmVudChsZWZ0UHQsIHRydWUpO1xuICAgIGNvbnN0IHJpZ2h0U0UgPSBuZXcgU3dlZXBFdmVudChyaWdodFB0LCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBTZWdtZW50KGxlZnRTRSwgcmlnaHRTRSwgW3JpbmddLCBbd2luZGluZ10pO1xuICB9XG5cbiAgLyogV2hlbiBhIHNlZ21lbnQgaXMgc3BsaXQsIHRoZSByaWdodFNFIGlzIHJlcGxhY2VkIHdpdGggYSBuZXcgc3dlZXAgZXZlbnQgKi9cbiAgcmVwbGFjZVJpZ2h0U0UobmV3UmlnaHRTRSkge1xuICAgIHRoaXMucmlnaHRTRSA9IG5ld1JpZ2h0U0U7XG4gICAgdGhpcy5yaWdodFNFLnNlZ21lbnQgPSB0aGlzO1xuICAgIHRoaXMucmlnaHRTRS5vdGhlclNFID0gdGhpcy5sZWZ0U0U7XG4gICAgdGhpcy5sZWZ0U0Uub3RoZXJTRSA9IHRoaXMucmlnaHRTRTtcbiAgfVxuICBiYm94KCkge1xuICAgIGNvbnN0IHkxID0gdGhpcy5sZWZ0U0UucG9pbnQueTtcbiAgICBjb25zdCB5MiA9IHRoaXMucmlnaHRTRS5wb2ludC55O1xuICAgIHJldHVybiB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiB0aGlzLmxlZnRTRS5wb2ludC54LFxuICAgICAgICB5OiB5MSA8IHkyID8geTEgOiB5MlxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IHRoaXMucmlnaHRTRS5wb2ludC54LFxuICAgICAgICB5OiB5MSA+IHkyID8geTEgOiB5MlxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiBBIHZlY3RvciBmcm9tIHRoZSBsZWZ0IHBvaW50IHRvIHRoZSByaWdodCAqL1xuICB2ZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMucmlnaHRTRS5wb2ludC54IC0gdGhpcy5sZWZ0U0UucG9pbnQueCxcbiAgICAgIHk6IHRoaXMucmlnaHRTRS5wb2ludC55IC0gdGhpcy5sZWZ0U0UucG9pbnQueVxuICAgIH07XG4gIH1cbiAgaXNBbkVuZHBvaW50KHB0KSB7XG4gICAgcmV0dXJuIHB0LnggPT09IHRoaXMubGVmdFNFLnBvaW50LnggJiYgcHQueSA9PT0gdGhpcy5sZWZ0U0UucG9pbnQueSB8fCBwdC54ID09PSB0aGlzLnJpZ2h0U0UucG9pbnQueCAmJiBwdC55ID09PSB0aGlzLnJpZ2h0U0UucG9pbnQueTtcbiAgfVxuXG4gIC8qIENvbXBhcmUgdGhpcyBzZWdtZW50IHdpdGggYSBwb2ludC5cbiAgICpcbiAgICogQSBwb2ludCBQIGlzIGNvbnNpZGVyZWQgdG8gYmUgY29saW5lYXIgdG8gYSBzZWdtZW50IGlmIHRoZXJlXG4gICAqIGV4aXN0cyBhIGRpc3RhbmNlIEQgc3VjaCB0aGF0IGlmIHdlIHRyYXZlbCBhbG9uZyB0aGUgc2VnbWVudFxuICAgKiBmcm9tIG9uZSAqIGVuZHBvaW50IHRvd2FyZHMgdGhlIG90aGVyIGEgZGlzdGFuY2UgRCwgd2UgZmluZFxuICAgKiBvdXJzZWx2ZXMgYXQgcG9pbnQgUC5cbiAgICpcbiAgICogUmV0dXJuIHZhbHVlIGluZGljYXRlczpcbiAgICpcbiAgICogICAxOiBwb2ludCBsaWVzIGFib3ZlIHRoZSBzZWdtZW50ICh0byB0aGUgbGVmdCBvZiB2ZXJ0aWNhbClcbiAgICogICAwOiBwb2ludCBpcyBjb2xpbmVhciB0byBzZWdtZW50XG4gICAqICAtMTogcG9pbnQgbGllcyBiZWxvdyB0aGUgc2VnbWVudCAodG8gdGhlIHJpZ2h0IG9mIHZlcnRpY2FsKVxuICAgKi9cbiAgY29tcGFyZVBvaW50KHBvaW50KSB7XG4gICAgaWYgKHRoaXMuaXNBbkVuZHBvaW50KHBvaW50KSkgcmV0dXJuIDA7XG4gICAgY29uc3QgbFB0ID0gdGhpcy5sZWZ0U0UucG9pbnQ7XG4gICAgY29uc3QgclB0ID0gdGhpcy5yaWdodFNFLnBvaW50O1xuICAgIGNvbnN0IHYgPSB0aGlzLnZlY3RvcigpO1xuXG4gICAgLy8gRXhhY3RseSB2ZXJ0aWNhbCBzZWdtZW50cy5cbiAgICBpZiAobFB0LnggPT09IHJQdC54KSB7XG4gICAgICBpZiAocG9pbnQueCA9PT0gbFB0LngpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHBvaW50LnggPCBsUHQueCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICAvLyBOZWFybHkgdmVydGljYWwgc2VnbWVudHMgd2l0aCBhbiBpbnRlcnNlY3Rpb24uXG4gICAgLy8gQ2hlY2sgdG8gc2VlIHdoZXJlIGEgcG9pbnQgb24gdGhlIGxpbmUgd2l0aCBtYXRjaGluZyBZIGNvb3JkaW5hdGUgaXMuXG4gICAgY29uc3QgeURpc3QgPSAocG9pbnQueSAtIGxQdC55KSAvIHYueTtcbiAgICBjb25zdCB4RnJvbVlEaXN0ID0gbFB0LnggKyB5RGlzdCAqIHYueDtcbiAgICBpZiAocG9pbnQueCA9PT0geEZyb21ZRGlzdCkgcmV0dXJuIDA7XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgLy8gQ2hlY2sgdG8gc2VlIHdoZXJlIGEgcG9pbnQgb24gdGhlIGxpbmUgd2l0aCBtYXRjaGluZyBYIGNvb3JkaW5hdGUgaXMuXG4gICAgY29uc3QgeERpc3QgPSAocG9pbnQueCAtIGxQdC54KSAvIHYueDtcbiAgICBjb25zdCB5RnJvbVhEaXN0ID0gbFB0LnkgKyB4RGlzdCAqIHYueTtcbiAgICBpZiAocG9pbnQueSA9PT0geUZyb21YRGlzdCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHBvaW50LnkgPCB5RnJvbVhEaXN0ID8gLTEgOiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFub3RoZXIgc2VnbWVudCwgcmV0dXJucyB0aGUgZmlyc3Qgbm9uLXRyaXZpYWwgaW50ZXJzZWN0aW9uXG4gICAqIGJldHdlZW4gdGhlIHR3byBzZWdtZW50cyAoaW4gdGVybXMgb2Ygc3dlZXAgbGluZSBvcmRlcmluZyksIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQSAnbm9uLXRyaXZpYWwnIGludGVyc2VjdGlvbiBpcyBvbmUgdGhhdCB3aWxsIGNhdXNlIG9uZSBvciBib3RoIG9mIHRoZVxuICAgKiBzZWdtZW50cyB0byBiZSBzcGxpdCgpLiBBcyBzdWNoLCAndHJpdmlhbCcgdnMuICdub24tdHJpdmlhbCcgaW50ZXJzZWN0aW9uOlxuICAgKlxuICAgKiAgICogZW5kcG9pbnQgb2Ygc2VnQSB3aXRoIGVuZHBvaW50IG9mIHNlZ0IgLS0+IHRyaXZpYWxcbiAgICogICAqIGVuZHBvaW50IG9mIHNlZ0Egd2l0aCBwb2ludCBhbG9uZyBzZWdCIC0tPiBub24tdHJpdmlhbFxuICAgKiAgICogZW5kcG9pbnQgb2Ygc2VnQiB3aXRoIHBvaW50IGFsb25nIHNlZ0EgLS0+IG5vbi10cml2aWFsXG4gICAqICAgKiBwb2ludCBhbG9uZyBzZWdBIHdpdGggcG9pbnQgYWxvbmcgc2VnQiAtLT4gbm9uLXRyaXZpYWxcbiAgICpcbiAgICogSWYgbm8gbm9uLXRyaXZpYWwgaW50ZXJzZWN0aW9uIGV4aXN0cywgcmV0dXJuIG51bGxcbiAgICogRWxzZSwgcmV0dXJuIG51bGwuXG4gICAqL1xuICBnZXRJbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAvLyBJZiBiYm94ZXMgZG9uJ3Qgb3ZlcmxhcCwgdGhlcmUgY2FuJ3QgYmUgYW55IGludGVyc2VjdGlvbnNcbiAgICBjb25zdCB0QmJveCA9IHRoaXMuYmJveCgpO1xuICAgIGNvbnN0IG9CYm94ID0gb3RoZXIuYmJveCgpO1xuICAgIGNvbnN0IGJib3hPdmVybGFwID0gZ2V0QmJveE92ZXJsYXAodEJib3gsIG9CYm94KTtcbiAgICBpZiAoYmJveE92ZXJsYXAgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgLy8gV2UgZmlyc3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBlbmRwb2ludHMgY2FuIGJlIGNvbnNpZGVyZWQgaW50ZXJzZWN0aW9ucy5cbiAgICAvLyBUaGlzIHdpbGwgJ3NuYXAnIGludGVyc2VjdGlvbnMgdG8gZW5kcG9pbnRzIGlmIHBvc3NpYmxlLCBhbmQgd2lsbFxuICAgIC8vIGhhbmRsZSBjYXNlcyBvZiBjb2xpbmVhcml0eS5cblxuICAgIGNvbnN0IHRscCA9IHRoaXMubGVmdFNFLnBvaW50O1xuICAgIGNvbnN0IHRycCA9IHRoaXMucmlnaHRTRS5wb2ludDtcbiAgICBjb25zdCBvbHAgPSBvdGhlci5sZWZ0U0UucG9pbnQ7XG4gICAgY29uc3Qgb3JwID0gb3RoZXIucmlnaHRTRS5wb2ludDtcblxuICAgIC8vIGRvZXMgZWFjaCBlbmRwb2ludCB0b3VjaCB0aGUgb3RoZXIgc2VnbWVudD9cbiAgICAvLyBub3RlIHRoYXQgd2UgcmVzdHJpY3QgdGhlICd0b3VjaGluZycgZGVmaW5pdGlvbiB0byBvbmx5IGFsbG93IHNlZ21lbnRzXG4gICAgLy8gdG8gdG91Y2ggZW5kcG9pbnRzIHRoYXQgbGllIGZvcndhcmQgZnJvbSB3aGVyZSB3ZSBhcmUgaW4gdGhlIHN3ZWVwIGxpbmUgcGFzc1xuICAgIGNvbnN0IHRvdWNoZXNPdGhlckxTRSA9IGlzSW5CYm94KHRCYm94LCBvbHApICYmIHRoaXMuY29tcGFyZVBvaW50KG9scCkgPT09IDA7XG4gICAgY29uc3QgdG91Y2hlc1RoaXNMU0UgPSBpc0luQmJveChvQmJveCwgdGxwKSAmJiBvdGhlci5jb21wYXJlUG9pbnQodGxwKSA9PT0gMDtcbiAgICBjb25zdCB0b3VjaGVzT3RoZXJSU0UgPSBpc0luQmJveCh0QmJveCwgb3JwKSAmJiB0aGlzLmNvbXBhcmVQb2ludChvcnApID09PSAwO1xuICAgIGNvbnN0IHRvdWNoZXNUaGlzUlNFID0gaXNJbkJib3gob0Jib3gsIHRycCkgJiYgb3RoZXIuY29tcGFyZVBvaW50KHRycCkgPT09IDA7XG5cbiAgICAvLyBkbyBsZWZ0IGVuZHBvaW50cyBtYXRjaD9cbiAgICBpZiAodG91Y2hlc1RoaXNMU0UgJiYgdG91Y2hlc090aGVyTFNFKSB7XG4gICAgICAvLyB0aGVzZSB0d28gY2FzZXMgYXJlIGZvciBjb2xpbmVhciBzZWdtZW50cyB3aXRoIG1hdGNoaW5nIGxlZnRcbiAgICAgIC8vIGVuZHBvaW50cywgYW5kIG9uZSBzZWdtZW50IGJlaW5nIGxvbmdlciB0aGFuIHRoZSBvdGhlclxuICAgICAgaWYgKHRvdWNoZXNUaGlzUlNFICYmICF0b3VjaGVzT3RoZXJSU0UpIHJldHVybiB0cnA7XG4gICAgICBpZiAoIXRvdWNoZXNUaGlzUlNFICYmIHRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIG9ycDtcbiAgICAgIC8vIGVpdGhlciB0aGUgdHdvIHNlZ21lbnRzIG1hdGNoIGV4YWN0bHkgKHR3byB0cml2YWwgaW50ZXJzZWN0aW9ucylcbiAgICAgIC8vIG9yIGp1c3Qgb24gdGhlaXIgbGVmdCBlbmRwb2ludCAob25lIHRyaXZpYWwgaW50ZXJzZWN0aW9uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBkb2VzIHRoaXMgbGVmdCBlbmRwb2ludCBtYXRjaGVzIChvdGhlciBkb2Vzbid0KVxuICAgIGlmICh0b3VjaGVzVGhpc0xTRSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHNlZ21lbnRzIHRoYXQganVzdCBpbnRlcnNlY3Qgb24gb3Bwb3NpbmcgZW5kcG9pbnRzXG4gICAgICBpZiAodG91Y2hlc090aGVyUlNFKSB7XG4gICAgICAgIGlmICh0bHAueCA9PT0gb3JwLnggJiYgdGxwLnkgPT09IG9ycC55KSByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHQtaW50ZXJzZWN0aW9uIG9uIGxlZnQgZW5kcG9pbnRcbiAgICAgIHJldHVybiB0bHA7XG4gICAgfVxuXG4gICAgLy8gZG9lcyBvdGhlciBsZWZ0IGVuZHBvaW50IG1hdGNoZXMgKHRoaXMgZG9lc24ndClcbiAgICBpZiAodG91Y2hlc090aGVyTFNFKSB7XG4gICAgICAvLyBjaGVjayBmb3Igc2VnbWVudHMgdGhhdCBqdXN0IGludGVyc2VjdCBvbiBvcHBvc2luZyBlbmRwb2ludHNcbiAgICAgIGlmICh0b3VjaGVzVGhpc1JTRSkge1xuICAgICAgICBpZiAodHJwLnggPT09IG9scC54ICYmIHRycC55ID09PSBvbHAueSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyB0LWludGVyc2VjdGlvbiBvbiBsZWZ0IGVuZHBvaW50XG4gICAgICByZXR1cm4gb2xwO1xuICAgIH1cblxuICAgIC8vIHRyaXZpYWwgaW50ZXJzZWN0aW9uIG9uIHJpZ2h0IGVuZHBvaW50c1xuICAgIGlmICh0b3VjaGVzVGhpc1JTRSAmJiB0b3VjaGVzT3RoZXJSU0UpIHJldHVybiBudWxsO1xuXG4gICAgLy8gdC1pbnRlcnNlY3Rpb25zIG9uIGp1c3Qgb25lIHJpZ2h0IGVuZHBvaW50XG4gICAgaWYgKHRvdWNoZXNUaGlzUlNFKSByZXR1cm4gdHJwO1xuICAgIGlmICh0b3VjaGVzT3RoZXJSU0UpIHJldHVybiBvcnA7XG5cbiAgICAvLyBOb25lIG9mIG91ciBlbmRwb2ludHMgaW50ZXJzZWN0LiBMb29rIGZvciBhIGdlbmVyYWwgaW50ZXJzZWN0aW9uIGJldHdlZW5cbiAgICAvLyBpbmZpbml0ZSBsaW5lcyBsYWlkIG92ZXIgdGhlIHNlZ21lbnRzXG4gICAgY29uc3QgcHQgPSBpbnRlcnNlY3Rpb24kMSh0bHAsIHRoaXMudmVjdG9yKCksIG9scCwgb3RoZXIudmVjdG9yKCkpO1xuXG4gICAgLy8gYXJlIHRoZSBzZWdtZW50cyBwYXJyYWxsZWw/IE5vdGUgdGhhdCBpZiB0aGV5IHdlcmUgY29saW5lYXIgd2l0aCBvdmVybGFwLFxuICAgIC8vIHRoZXkgd291bGQgaGF2ZSBhbiBlbmRwb2ludCBpbnRlcnNlY3Rpb24gYW5kIHRoYXQgY2FzZSB3YXMgYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG4gICAgaWYgKHB0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGlzIHRoZSBpbnRlcnNlY3Rpb24gZm91bmQgYmV0d2VlbiB0aGUgbGluZXMgbm90IG9uIHRoZSBzZWdtZW50cz9cbiAgICBpZiAoIWlzSW5CYm94KGJib3hPdmVybGFwLCBwdCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gcm91bmQgdGhlIHRoZSBjb21wdXRlZCBwb2ludCBpZiBuZWVkZWRcbiAgICByZXR1cm4gcm91bmRlci5yb3VuZChwdC54LCBwdC55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGUgZ2l2ZW4gc2VnbWVudCBpbnRvIG11bHRpcGxlIHNlZ21lbnRzIG9uIHRoZSBnaXZlbiBwb2ludHMuXG4gICAqICAqIEVhY2ggZXhpc3Rpbmcgc2VnbWVudCB3aWxsIHJldGFpbiBpdHMgbGVmdFNFIGFuZCBhIG5ldyByaWdodFNFIHdpbGwgYmVcbiAgICogICAgZ2VuZXJhdGVkIGZvciBpdC5cbiAgICogICogQSBuZXcgc2VnbWVudCB3aWxsIGJlIGdlbmVyYXRlZCB3aGljaCB3aWxsIGFkb3B0IHRoZSBvcmlnaW5hbCBzZWdtZW50J3NcbiAgICogICAgcmlnaHRTRSwgYW5kIGEgbmV3IGxlZnRTRSB3aWxsIGJlIGdlbmVyYXRlZCBmb3IgaXQuXG4gICAqICAqIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIHBvaW50cyBnaXZlbiB0byBzcGxpdCBvbiwgbmV3IHNlZ21lbnRzXG4gICAqICAgIGluIHRoZSBtaWRkbGUgd2lsbCBiZSBnZW5lcmF0ZWQgd2l0aCBuZXcgbGVmdFNFIGFuZCByaWdodFNFJ3MuXG4gICAqICAqIEFuIGFycmF5IG9mIHRoZSBuZXdseSBnZW5lcmF0ZWQgU3dlZXBFdmVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogV2FybmluZzogaW5wdXQgYXJyYXkgb2YgcG9pbnRzIGlzIG1vZGlmaWVkXG4gICAqL1xuICBzcGxpdChwb2ludCkge1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IFtdO1xuICAgIGNvbnN0IGFscmVhZHlMaW5rZWQgPSBwb2ludC5ldmVudHMgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdMZWZ0U0UgPSBuZXcgU3dlZXBFdmVudChwb2ludCwgdHJ1ZSk7XG4gICAgY29uc3QgbmV3UmlnaHRTRSA9IG5ldyBTd2VlcEV2ZW50KHBvaW50LCBmYWxzZSk7XG4gICAgY29uc3Qgb2xkUmlnaHRTRSA9IHRoaXMucmlnaHRTRTtcbiAgICB0aGlzLnJlcGxhY2VSaWdodFNFKG5ld1JpZ2h0U0UpO1xuICAgIG5ld0V2ZW50cy5wdXNoKG5ld1JpZ2h0U0UpO1xuICAgIG5ld0V2ZW50cy5wdXNoKG5ld0xlZnRTRSk7XG4gICAgY29uc3QgbmV3U2VnID0gbmV3IFNlZ21lbnQobmV3TGVmdFNFLCBvbGRSaWdodFNFLCB0aGlzLnJpbmdzLnNsaWNlKCksIHRoaXMud2luZGluZ3Muc2xpY2UoKSk7XG5cbiAgICAvLyB3aGVuIHNwbGl0dGluZyBhIG5lYXJseSB2ZXJ0aWNhbCBkb3dud2FyZC1mYWNpbmcgc2VnbWVudCxcbiAgICAvLyBzb21ldGltZXMgb25lIG9mIHRoZSByZXN1bHRpbmcgbmV3IHNlZ21lbnRzIGlzIHZlcnRpY2FsLCBpbiB3aGljaFxuICAgIC8vIGNhc2UgaXRzIGxlZnQgYW5kIHJpZ2h0IGV2ZW50cyBtYXkgbmVlZCB0byBiZSBzd2FwcGVkXG4gICAgaWYgKFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhuZXdTZWcubGVmdFNFLnBvaW50LCBuZXdTZWcucmlnaHRTRS5wb2ludCkgPiAwKSB7XG4gICAgICBuZXdTZWcuc3dhcEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAoU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKHRoaXMubGVmdFNFLnBvaW50LCB0aGlzLnJpZ2h0U0UucG9pbnQpID4gMCkge1xuICAgICAgdGhpcy5zd2FwRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLy8gaW4gdGhlIHBvaW50IHdlIGp1c3QgdXNlZCB0byBjcmVhdGUgbmV3IHN3ZWVwIGV2ZW50cyB3aXRoIHdhcyBhbHJlYWR5XG4gICAgLy8gbGlua2VkIHRvIG90aGVyIGV2ZW50cywgd2UgbmVlZCB0byBjaGVjayBpZiBlaXRoZXIgb2YgdGhlIGFmZmVjdGVkXG4gICAgLy8gc2VnbWVudHMgc2hvdWxkIGJlIGNvbnN1bWVkXG4gICAgaWYgKGFscmVhZHlMaW5rZWQpIHtcbiAgICAgIG5ld0xlZnRTRS5jaGVja0ZvckNvbnN1bWluZygpO1xuICAgICAgbmV3UmlnaHRTRS5jaGVja0ZvckNvbnN1bWluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RXZlbnRzO1xuICB9XG5cbiAgLyogU3dhcCB3aGljaCBldmVudCBpcyBsZWZ0IGFuZCByaWdodCAqL1xuICBzd2FwRXZlbnRzKCkge1xuICAgIGNvbnN0IHRtcEV2dCA9IHRoaXMucmlnaHRTRTtcbiAgICB0aGlzLnJpZ2h0U0UgPSB0aGlzLmxlZnRTRTtcbiAgICB0aGlzLmxlZnRTRSA9IHRtcEV2dDtcbiAgICB0aGlzLmxlZnRTRS5pc0xlZnQgPSB0cnVlO1xuICAgIHRoaXMucmlnaHRTRS5pc0xlZnQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMud2luZGluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICB0aGlzLndpbmRpbmdzW2ldICo9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8qIENvbnN1bWUgYW5vdGhlciBzZWdtZW50LiBXZSB0YWtlIHRoZWlyIHJpbmdzIHVuZGVyIG91ciB3aW5nXG4gICAqIGFuZCBtYXJrIHRoZW0gYXMgY29uc3VtZWQuIFVzZSBmb3IgcGVyZmVjdGx5IG92ZXJsYXBwaW5nIHNlZ21lbnRzICovXG4gIGNvbnN1bWUob3RoZXIpIHtcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzO1xuICAgIGxldCBjb25zdW1lZSA9IG90aGVyO1xuICAgIHdoaWxlIChjb25zdW1lci5jb25zdW1lZEJ5KSBjb25zdW1lciA9IGNvbnN1bWVyLmNvbnN1bWVkQnk7XG4gICAgd2hpbGUgKGNvbnN1bWVlLmNvbnN1bWVkQnkpIGNvbnN1bWVlID0gY29uc3VtZWUuY29uc3VtZWRCeTtcbiAgICBjb25zdCBjbXAgPSBTZWdtZW50LmNvbXBhcmUoY29uc3VtZXIsIGNvbnN1bWVlKTtcbiAgICBpZiAoY21wID09PSAwKSByZXR1cm47IC8vIGFscmVhZHkgY29uc3VtZWRcbiAgICAvLyB0aGUgd2lubmVyIG9mIHRoZSBjb25zdW1wdGlvbiBpcyB0aGUgZWFybGllciBzZWdtZW50XG4gICAgLy8gYWNjb3JkaW5nIHRvIHN3ZWVwIGxpbmUgb3JkZXJpbmdcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgY29uc3QgdG1wID0gY29uc3VtZXI7XG4gICAgICBjb25zdW1lciA9IGNvbnN1bWVlO1xuICAgICAgY29uc3VtZWUgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIGEgc2VnbWVudCBkb2Vzbid0IGNvbnN1bWUgaXQncyBwcmV2XG4gICAgaWYgKGNvbnN1bWVyLnByZXYgPT09IGNvbnN1bWVlKSB7XG4gICAgICBjb25zdCB0bXAgPSBjb25zdW1lcjtcbiAgICAgIGNvbnN1bWVyID0gY29uc3VtZWU7XG4gICAgICBjb25zdW1lZSA9IHRtcDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBjb25zdW1lZS5yaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmcgPSBjb25zdW1lZS5yaW5nc1tpXTtcbiAgICAgIGNvbnN0IHdpbmRpbmcgPSBjb25zdW1lZS53aW5kaW5nc1tpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29uc3VtZXIucmluZ3MuaW5kZXhPZihyaW5nKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgY29uc3VtZXIucmluZ3MucHVzaChyaW5nKTtcbiAgICAgICAgY29uc3VtZXIud2luZGluZ3MucHVzaCh3aW5kaW5nKTtcbiAgICAgIH0gZWxzZSBjb25zdW1lci53aW5kaW5nc1tpbmRleF0gKz0gd2luZGluZztcbiAgICB9XG4gICAgY29uc3VtZWUucmluZ3MgPSBudWxsO1xuICAgIGNvbnN1bWVlLndpbmRpbmdzID0gbnVsbDtcbiAgICBjb25zdW1lZS5jb25zdW1lZEJ5ID0gY29uc3VtZXI7XG5cbiAgICAvLyBtYXJrIHN3ZWVwIGV2ZW50cyBjb25zdW1lZCBhcyB0byBtYWludGFpbiBvcmRlcmluZyBpbiBzd2VlcCBldmVudCBxdWV1ZVxuICAgIGNvbnN1bWVlLmxlZnRTRS5jb25zdW1lZEJ5ID0gY29uc3VtZXIubGVmdFNFO1xuICAgIGNvbnN1bWVlLnJpZ2h0U0UuY29uc3VtZWRCeSA9IGNvbnN1bWVyLnJpZ2h0U0U7XG4gIH1cblxuICAvKiBUaGUgZmlyc3Qgc2VnbWVudCBwcmV2aW91cyBzZWdtZW50IGNoYWluIHRoYXQgaXMgaW4gdGhlIHJlc3VsdCAqL1xuICBwcmV2SW5SZXN1bHQoKSB7XG4gICAgaWYgKHRoaXMuX3ByZXZJblJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0O1xuICAgIGlmICghdGhpcy5wcmV2KSB0aGlzLl9wcmV2SW5SZXN1bHQgPSBudWxsO2Vsc2UgaWYgKHRoaXMucHJldi5pc0luUmVzdWx0KCkpIHRoaXMuX3ByZXZJblJlc3VsdCA9IHRoaXMucHJldjtlbHNlIHRoaXMuX3ByZXZJblJlc3VsdCA9IHRoaXMucHJldi5wcmV2SW5SZXN1bHQoKTtcbiAgICByZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0O1xuICB9XG4gIGJlZm9yZVN0YXRlKCkge1xuICAgIGlmICh0aGlzLl9iZWZvcmVTdGF0ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYmVmb3JlU3RhdGU7XG4gICAgaWYgKCF0aGlzLnByZXYpIHRoaXMuX2JlZm9yZVN0YXRlID0ge1xuICAgICAgcmluZ3M6IFtdLFxuICAgICAgd2luZGluZ3M6IFtdLFxuICAgICAgbXVsdGlQb2x5czogW11cbiAgICB9O2Vsc2Uge1xuICAgICAgY29uc3Qgc2VnID0gdGhpcy5wcmV2LmNvbnN1bWVkQnkgfHwgdGhpcy5wcmV2O1xuICAgICAgdGhpcy5fYmVmb3JlU3RhdGUgPSBzZWcuYWZ0ZXJTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmVmb3JlU3RhdGU7XG4gIH1cbiAgYWZ0ZXJTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fYWZ0ZXJTdGF0ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYWZ0ZXJTdGF0ZTtcbiAgICBjb25zdCBiZWZvcmVTdGF0ZSA9IHRoaXMuYmVmb3JlU3RhdGUoKTtcbiAgICB0aGlzLl9hZnRlclN0YXRlID0ge1xuICAgICAgcmluZ3M6IGJlZm9yZVN0YXRlLnJpbmdzLnNsaWNlKDApLFxuICAgICAgd2luZGluZ3M6IGJlZm9yZVN0YXRlLndpbmRpbmdzLnNsaWNlKDApLFxuICAgICAgbXVsdGlQb2x5czogW11cbiAgICB9O1xuICAgIGNvbnN0IHJpbmdzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLnJpbmdzO1xuICAgIGNvbnN0IHdpbmRpbmdzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLndpbmRpbmdzO1xuICAgIGNvbnN0IG1wc0FmdGVyID0gdGhpcy5fYWZ0ZXJTdGF0ZS5tdWx0aVBvbHlzO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJpbmdzQWZ0ZXIsIHdpbmRpbmdzQWZ0ZXJcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nID0gdGhpcy5yaW5nc1tpXTtcbiAgICAgIGNvbnN0IHdpbmRpbmcgPSB0aGlzLndpbmRpbmdzW2ldO1xuICAgICAgY29uc3QgaW5kZXggPSByaW5nc0FmdGVyLmluZGV4T2YocmluZyk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJpbmdzQWZ0ZXIucHVzaChyaW5nKTtcbiAgICAgICAgd2luZGluZ3NBZnRlci5wdXNoKHdpbmRpbmcpO1xuICAgICAgfSBlbHNlIHdpbmRpbmdzQWZ0ZXJbaW5kZXhdICs9IHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VhbHRlIHBvbHlzQWZ0ZXJcbiAgICBjb25zdCBwb2x5c0FmdGVyID0gW107XG4gICAgY29uc3QgcG9seXNFeGNsdWRlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSByaW5nc0FmdGVyLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKHdpbmRpbmdzQWZ0ZXJbaV0gPT09IDApIGNvbnRpbnVlOyAvLyBub24temVybyBydWxlXG4gICAgICBjb25zdCByaW5nID0gcmluZ3NBZnRlcltpXTtcbiAgICAgIGNvbnN0IHBvbHkgPSByaW5nLnBvbHk7XG4gICAgICBpZiAocG9seXNFeGNsdWRlLmluZGV4T2YocG9seSkgIT09IC0xKSBjb250aW51ZTtcbiAgICAgIGlmIChyaW5nLmlzRXh0ZXJpb3IpIHBvbHlzQWZ0ZXIucHVzaChwb2x5KTtlbHNlIHtcbiAgICAgICAgaWYgKHBvbHlzRXhjbHVkZS5pbmRleE9mKHBvbHkpID09PSAtMSkgcG9seXNFeGNsdWRlLnB1c2gocG9seSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcG9seXNBZnRlci5pbmRleE9mKHJpbmcucG9seSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHBvbHlzQWZ0ZXIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgbXVsdGlQb2x5c0FmdGVyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBwb2x5c0FmdGVyLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgbXAgPSBwb2x5c0FmdGVyW2ldLm11bHRpUG9seTtcbiAgICAgIGlmIChtcHNBZnRlci5pbmRleE9mKG1wKSA9PT0gLTEpIG1wc0FmdGVyLnB1c2gobXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWZ0ZXJTdGF0ZTtcbiAgfVxuXG4gIC8qIElzIHRoaXMgc2VnbWVudCBwYXJ0IG9mIHRoZSBmaW5hbCByZXN1bHQ/ICovXG4gIGlzSW5SZXN1bHQoKSB7XG4gICAgLy8gaWYgd2UndmUgYmVlbiBjb25zdW1lZCwgd2UncmUgbm90IGluIHRoZSByZXN1bHRcbiAgICBpZiAodGhpcy5jb25zdW1lZEJ5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2lzSW5SZXN1bHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHQ7XG4gICAgY29uc3QgbXBzQmVmb3JlID0gdGhpcy5iZWZvcmVTdGF0ZSgpLm11bHRpUG9seXM7XG4gICAgY29uc3QgbXBzQWZ0ZXIgPSB0aGlzLmFmdGVyU3RhdGUoKS5tdWx0aVBvbHlzO1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVU5JT04gLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogT24gb25lIHNpZGUgb2YgdXMgdGhlcmUgaXMgMCBwb2x5IGludGVyaW9ycyBBTkRcbiAgICAgICAgICAvLyAgKiBPbiB0aGUgb3RoZXIgc2lkZSB0aGVyZSBpcyAxIG9yIG1vcmUuXG4gICAgICAgICAgY29uc3Qgbm9CZWZvcmVzID0gbXBzQmVmb3JlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICBjb25zdCBub0FmdGVycyA9IG1wc0FmdGVyLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gbm9CZWZvcmVzICE9PSBub0FmdGVycztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImludGVyc2VjdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSU5URVJTRUNUSU9OIC0gaW5jbHVkZWQgaWZmOlxuICAgICAgICAgIC8vICAqIG9uIG9uZSBzaWRlIG9mIHVzIGFsbCBtdWx0aXBvbHlzIGFyZSByZXAuIHdpdGggcG9seSBpbnRlcmlvcnMgQU5EXG4gICAgICAgICAgLy8gICogb24gdGhlIG90aGVyIHNpZGUgb2YgdXMsIG5vdCBhbGwgbXVsdGlwb2x5cyBhcmUgcmVwc2VudGVkXG4gICAgICAgICAgLy8gICAgd2l0aCBwb2x5IGludGVyaW9yc1xuICAgICAgICAgIGxldCBsZWFzdDtcbiAgICAgICAgICBsZXQgbW9zdDtcbiAgICAgICAgICBpZiAobXBzQmVmb3JlLmxlbmd0aCA8IG1wc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGVhc3QgPSBtcHNCZWZvcmUubGVuZ3RoO1xuICAgICAgICAgICAgbW9zdCA9IG1wc0FmdGVyLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhc3QgPSBtcHNBZnRlci5sZW5ndGg7XG4gICAgICAgICAgICBtb3N0ID0gbXBzQmVmb3JlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IG1vc3QgPT09IG9wZXJhdGlvbi5udW1NdWx0aVBvbHlzICYmIGxlYXN0IDwgbW9zdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInhvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gWE9SIC0gaW5jbHVkZWQgaWZmOlxuICAgICAgICAgIC8vICAqIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG51bWJlciBvZiBtdWx0aXBvbHlzIHJlcHJlc2VudGVkXG4gICAgICAgICAgLy8gICAgd2l0aCBwb2x5IGludGVyaW9ycyBvbiBvdXIgdHdvIHNpZGVzIGlzIGFuIG9kZCBudW1iZXJcbiAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMobXBzQmVmb3JlLmxlbmd0aCAtIG1wc0FmdGVyLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IGRpZmYgJSAyID09PSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiZGlmZmVyZW5jZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRElGRkVSRU5DRSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogb24gZXhhY3RseSBvbmUgc2lkZSwgd2UgaGF2ZSBqdXN0IHRoZSBzdWJqZWN0XG4gICAgICAgICAgY29uc3QgaXNKdXN0U3ViamVjdCA9IG1wcyA9PiBtcHMubGVuZ3RoID09PSAxICYmIG1wc1swXS5pc1N1YmplY3Q7XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IGlzSnVzdFN1YmplY3QobXBzQmVmb3JlKSAhPT0gaXNKdXN0U3ViamVjdChtcHNBZnRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG9wZXJhdGlvbiB0eXBlIGZvdW5kICR7b3BlcmF0aW9uLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0luUmVzdWx0O1xuICB9XG59XG5cbmNsYXNzIFJpbmdJbiB7XG4gIGNvbnN0cnVjdG9yKGdlb21SaW5nLCBwb2x5LCBpc0V4dGVyaW9yKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGdlb21SaW5nKSB8fCBnZW9tUmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICB0aGlzLnBvbHkgPSBwb2x5O1xuICAgIHRoaXMuaXNFeHRlcmlvciA9IGlzRXh0ZXJpb3I7XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgZ2VvbVJpbmdbMF1bMF0gIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGdlb21SaW5nWzBdWzFdICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHJvdW5kZXIucm91bmQoZ2VvbVJpbmdbMF1bMF0sIGdlb21SaW5nWzBdWzFdKTtcbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiBmaXJzdFBvaW50LngsXG4gICAgICAgIHk6IGZpcnN0UG9pbnQueVxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IGZpcnN0UG9pbnQueCxcbiAgICAgICAgeTogZmlyc3RQb2ludC55XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcHJldlBvaW50ID0gZmlyc3RQb2ludDtcbiAgICBmb3IgKGxldCBpID0gMSwgaU1heCA9IGdlb21SaW5nLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBnZW9tUmluZ1tpXVswXSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZ2VvbVJpbmdbaV1bMV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb25cIik7XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnQgPSByb3VuZGVyLnJvdW5kKGdlb21SaW5nW2ldWzBdLCBnZW9tUmluZ1tpXVsxXSk7XG4gICAgICAvLyBza2lwIHJlcGVhdGVkIHBvaW50c1xuICAgICAgaWYgKHBvaW50LnggPT09IHByZXZQb2ludC54ICYmIHBvaW50LnkgPT09IHByZXZQb2ludC55KSBjb250aW51ZTtcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaChTZWdtZW50LmZyb21SaW5nKHByZXZQb2ludCwgcG9pbnQsIHRoaXMpKTtcbiAgICAgIGlmIChwb2ludC54IDwgdGhpcy5iYm94LmxsLngpIHRoaXMuYmJveC5sbC54ID0gcG9pbnQueDtcbiAgICAgIGlmIChwb2ludC55IDwgdGhpcy5iYm94LmxsLnkpIHRoaXMuYmJveC5sbC55ID0gcG9pbnQueTtcbiAgICAgIGlmIChwb2ludC54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcG9pbnQueDtcbiAgICAgIGlmIChwb2ludC55ID4gdGhpcy5iYm94LnVyLnkpIHRoaXMuYmJveC51ci55ID0gcG9pbnQueTtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICAvLyBhZGQgc2VnbWVudCBmcm9tIGxhc3QgdG8gZmlyc3QgaWYgbGFzdCBpcyBub3QgdGhlIHNhbWUgYXMgZmlyc3RcbiAgICBpZiAoZmlyc3RQb2ludC54ICE9PSBwcmV2UG9pbnQueCB8fCBmaXJzdFBvaW50LnkgIT09IHByZXZQb2ludC55KSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goU2VnbWVudC5mcm9tUmluZyhwcmV2UG9pbnQsIGZpcnN0UG9pbnQsIHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3dlZXBFdmVudHMoKSB7XG4gICAgY29uc3Qgc3dlZXBFdmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcbiAgICAgIHN3ZWVwRXZlbnRzLnB1c2goc2VnbWVudC5sZWZ0U0UpO1xuICAgICAgc3dlZXBFdmVudHMucHVzaChzZWdtZW50LnJpZ2h0U0UpO1xuICAgIH1cbiAgICByZXR1cm4gc3dlZXBFdmVudHM7XG4gIH1cbn1cbmNsYXNzIFBvbHlJbiB7XG4gIGNvbnN0cnVjdG9yKGdlb21Qb2x5LCBtdWx0aVBvbHkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VvbVBvbHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTtcbiAgICB9XG4gICAgdGhpcy5leHRlcmlvclJpbmcgPSBuZXcgUmluZ0luKGdlb21Qb2x5WzBdLCB0aGlzLCB0cnVlKTtcbiAgICAvLyBjb3B5IGJ5IHZhbHVlXG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgbGw6IHtcbiAgICAgICAgeDogdGhpcy5leHRlcmlvclJpbmcuYmJveC5sbC54LFxuICAgICAgICB5OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LmxsLnlcbiAgICAgIH0sXG4gICAgICB1cjoge1xuICAgICAgICB4OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LnVyLngsXG4gICAgICAgIHk6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gudXIueVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDEsIGlNYXggPSBnZW9tUG9seS5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmcgPSBuZXcgUmluZ0luKGdlb21Qb2x5W2ldLCB0aGlzLCBmYWxzZSk7XG4gICAgICBpZiAocmluZy5iYm94LmxsLnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSByaW5nLmJib3gubGwueDtcbiAgICAgIGlmIChyaW5nLmJib3gubGwueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHJpbmcuYmJveC5sbC55O1xuICAgICAgaWYgKHJpbmcuYmJveC51ci54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcmluZy5iYm94LnVyLng7XG4gICAgICBpZiAocmluZy5iYm94LnVyLnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSByaW5nLmJib3gudXIueTtcbiAgICAgIHRoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKHJpbmcpO1xuICAgIH1cbiAgICB0aGlzLm11bHRpUG9seSA9IG11bHRpUG9seTtcbiAgfVxuICBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICBjb25zdCBzd2VlcEV2ZW50cyA9IHRoaXMuZXh0ZXJpb3JSaW5nLmdldFN3ZWVwRXZlbnRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nU3dlZXBFdmVudHMgPSB0aGlzLmludGVyaW9yUmluZ3NbaV0uZ2V0U3dlZXBFdmVudHMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqTWF4ID0gcmluZ1N3ZWVwRXZlbnRzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICBzd2VlcEV2ZW50cy5wdXNoKHJpbmdTd2VlcEV2ZW50c1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzd2VlcEV2ZW50cztcbiAgfVxufVxuY2xhc3MgTXVsdGlQb2x5SW4ge1xuICBjb25zdHJ1Y3RvcihnZW9tLCBpc1N1YmplY3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VvbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gaWYgdGhlIGlucHV0IGxvb2tzIGxpa2UgYSBwb2x5Z29uLCBjb252ZXJ0IGl0IHRvIGEgbXVsdGlwb2x5Z29uXG4gICAgICBpZiAodHlwZW9mIGdlb21bMF1bMF1bMF0gPT09IFwibnVtYmVyXCIpIGdlb20gPSBbZ2VvbV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIC8vIFRoZSBpbnB1dCBpcyBlaXRoZXIgbWFsZm9ybWVkIG9yIGhhcyBlbXB0eSBhcnJheXMuXG4gICAgICAvLyBJbiBlaXRoZXIgY2FzZSwgaXQgd2lsbCBiZSBoYW5kbGVkIGxhdGVyIG9uLlxuICAgIH1cbiAgICB0aGlzLnBvbHlzID0gW107XG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgbGw6IHtcbiAgICAgICAgeDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0sXG4gICAgICB1cjoge1xuICAgICAgICB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHk6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBnZW9tLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcG9seSA9IG5ldyBQb2x5SW4oZ2VvbVtpXSwgdGhpcyk7XG4gICAgICBpZiAocG9seS5iYm94LmxsLnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSBwb2x5LmJib3gubGwueDtcbiAgICAgIGlmIChwb2x5LmJib3gubGwueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHBvbHkuYmJveC5sbC55O1xuICAgICAgaWYgKHBvbHkuYmJveC51ci54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcG9seS5iYm94LnVyLng7XG4gICAgICBpZiAocG9seS5iYm94LnVyLnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSBwb2x5LmJib3gudXIueTtcbiAgICAgIHRoaXMucG9seXMucHVzaChwb2x5KTtcbiAgICB9XG4gICAgdGhpcy5pc1N1YmplY3QgPSBpc1N1YmplY3Q7XG4gIH1cbiAgZ2V0U3dlZXBFdmVudHMoKSB7XG4gICAgY29uc3Qgc3dlZXBFdmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucG9seXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5U3dlZXBFdmVudHMgPSB0aGlzLnBvbHlzW2ldLmdldFN3ZWVwRXZlbnRzKCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgak1heCA9IHBvbHlTd2VlcEV2ZW50cy5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAgICAgc3dlZXBFdmVudHMucHVzaChwb2x5U3dlZXBFdmVudHNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3dlZXBFdmVudHM7XG4gIH1cbn1cblxuY2xhc3MgUmluZ091dCB7XG4gIC8qIEdpdmVuIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBzd2VlcCBsaW5lIHBhc3MsIGNvbXB1dGUgJiByZXR1cm4gYSBzZXJpZXNcbiAgICogb2YgY2xvc2VkIHJpbmdzIGZyb20gYWxsIHRoZSBzZWdtZW50cyBtYXJrZWQgdG8gYmUgcGFydCBvZiB0aGUgcmVzdWx0ICovXG4gIHN0YXRpYyBmYWN0b3J5KGFsbFNlZ21lbnRzKSB7XG4gICAgY29uc3QgcmluZ3NPdXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IGFsbFNlZ21lbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IGFsbFNlZ21lbnRzW2ldO1xuICAgICAgaWYgKCFzZWdtZW50LmlzSW5SZXN1bHQoKSB8fCBzZWdtZW50LnJpbmdPdXQpIGNvbnRpbnVlO1xuICAgICAgbGV0IHByZXZFdmVudCA9IG51bGw7XG4gICAgICBsZXQgZXZlbnQgPSBzZWdtZW50LmxlZnRTRTtcbiAgICAgIGxldCBuZXh0RXZlbnQgPSBzZWdtZW50LnJpZ2h0U0U7XG4gICAgICBjb25zdCBldmVudHMgPSBbZXZlbnRdO1xuICAgICAgY29uc3Qgc3RhcnRpbmdQb2ludCA9IGV2ZW50LnBvaW50O1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTEVzID0gW107XG5cbiAgICAgIC8qIFdhbGsgdGhlIGNoYWluIG9mIGxpbmtlZCBldmVudHMgdG8gZm9ybSBhIGNsb3NlZCByaW5nICovXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwcmV2RXZlbnQgPSBldmVudDtcbiAgICAgICAgZXZlbnQgPSBuZXh0RXZlbnQ7XG4gICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcblxuICAgICAgICAvKiBJcyB0aGUgcmluZyBjb21wbGV0ZT8gKi9cbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ID09PSBzdGFydGluZ1BvaW50KSBicmVhaztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGVMRXMgPSBldmVudC5nZXRBdmFpbGFibGVMaW5rZWRFdmVudHMoKTtcblxuICAgICAgICAgIC8qIERpZCB3ZSBoaXQgYSBkZWFkIGVuZD8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAqIEluZGljYXRlcyBzb21lIGVhcmxpZXIgcGFydCBvZiB0aGUgYWxnb3JpdGhtIG1hbGZ1bmN0aW9uZWQuICovXG4gICAgICAgICAgaWYgKGF2YWlsYWJsZUxFcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UHQgPSBldmVudHNbMF0ucG9pbnQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0UHQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLnBvaW50O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29tcGxldGUgb3V0cHV0IHJpbmcgc3RhcnRpbmcgYXQgWyR7Zmlyc3RQdC54fSxgICsgYCAke2ZpcnN0UHQueX1dLiBMYXN0IG1hdGNoaW5nIHNlZ21lbnQgZm91bmQgZW5kcyBhdGAgKyBgIFske2xhc3RQdC54fSwgJHtsYXN0UHQueX1dLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIE9ubHkgb25lIHdheSB0byBnbywgc28gY290aW51ZSBvbiB0aGUgcGF0aCAqL1xuICAgICAgICAgIGlmIChhdmFpbGFibGVMRXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXNbMF0ub3RoZXJTRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIFdlIG11c3QgaGF2ZSBhbiBpbnRlcnNlY3Rpb24uIENoZWNrIGZvciBhIGNvbXBsZXRlZCBsb29wICovXG4gICAgICAgICAgbGV0IGluZGV4TEUgPSBudWxsO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqTWF4ID0gaW50ZXJzZWN0aW9uTEVzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbkxFc1tqXS5wb2ludCA9PT0gZXZlbnQucG9pbnQpIHtcbiAgICAgICAgICAgICAgaW5kZXhMRSA9IGo7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBGb3VuZCBhIGNvbXBsZXRlZCBsb29wLiBDdXQgdGhhdCBvZmYgYW5kIG1ha2UgYSByaW5nICovXG4gICAgICAgICAgaWYgKGluZGV4TEUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbkxFID0gaW50ZXJzZWN0aW9uTEVzLnNwbGljZShpbmRleExFKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJpbmdFdmVudHMgPSBldmVudHMuc3BsaWNlKGludGVyc2VjdGlvbkxFLmluZGV4KTtcbiAgICAgICAgICAgIHJpbmdFdmVudHMudW5zaGlmdChyaW5nRXZlbnRzWzBdLm90aGVyU0UpO1xuICAgICAgICAgICAgcmluZ3NPdXQucHVzaChuZXcgUmluZ091dChyaW5nRXZlbnRzLnJldmVyc2UoKSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIHJlZ2lzdGVyIHRoZSBpbnRlcnNlY3Rpb24gKi9cbiAgICAgICAgICBpbnRlcnNlY3Rpb25MRXMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHBvaW50OiBldmVudC5wb2ludFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qIENob29zZSB0aGUgbGVmdC1tb3N0IG9wdGlvbiB0byBjb250aW51ZSB0aGUgd2FsayAqL1xuICAgICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBldmVudC5nZXRMZWZ0bW9zdENvbXBhcmF0b3IocHJldkV2ZW50KTtcbiAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXMuc29ydChjb21wYXJhdG9yKVswXS5vdGhlclNFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByaW5nc091dC5wdXNoKG5ldyBSaW5nT3V0KGV2ZW50cykpO1xuICAgIH1cbiAgICByZXR1cm4gcmluZ3NPdXQ7XG4gIH1cbiAgY29uc3RydWN0b3IoZXZlbnRzKSB7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBldmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBldmVudHNbaV0uc2VnbWVudC5yaW5nT3V0ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5wb2x5ID0gbnVsbDtcbiAgfVxuICBnZXRHZW9tKCkge1xuICAgIC8vIFJlbW92ZSBzdXBlcmZsdW91cyBwb2ludHMgKGllIGV4dHJhIHBvaW50cyBhbG9uZyBhIHN0cmFpZ2h0IGxpbmUpLFxuICAgIGxldCBwcmV2UHQgPSB0aGlzLmV2ZW50c1swXS5wb2ludDtcbiAgICBjb25zdCBwb2ludHMgPSBbcHJldlB0XTtcbiAgICBmb3IgKGxldCBpID0gMSwgaU1heCA9IHRoaXMuZXZlbnRzLmxlbmd0aCAtIDE7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gdGhpcy5ldmVudHNbaV0ucG9pbnQ7XG4gICAgICBjb25zdCBuZXh0UHQgPSB0aGlzLmV2ZW50c1tpICsgMV0ucG9pbnQ7XG4gICAgICBpZiAoY29tcGFyZVZlY3RvckFuZ2xlcyhwdCwgcHJldlB0LCBuZXh0UHQpID09PSAwKSBjb250aW51ZTtcbiAgICAgIHBvaW50cy5wdXNoKHB0KTtcbiAgICAgIHByZXZQdCA9IHB0O1xuICAgIH1cblxuICAgIC8vIHJpbmcgd2FzIGFsbCAod2l0aGluIHJvdW5kaW5nIGVycm9yIG9mIGFuZ2xlIGNhbGMpIGNvbGluZWFyIHBvaW50c1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSBzdGFydGluZyBwb2ludCBpcyBuZWNlc3NhcnlcbiAgICBjb25zdCBwdCA9IHBvaW50c1swXTtcbiAgICBjb25zdCBuZXh0UHQgPSBwb2ludHNbMV07XG4gICAgaWYgKGNvbXBhcmVWZWN0b3JBbmdsZXMocHQsIHByZXZQdCwgbmV4dFB0KSA9PT0gMCkgcG9pbnRzLnNoaWZ0KCk7XG4gICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gMSA6IC0xO1xuICAgIGNvbnN0IGlTdGFydCA9IHRoaXMuaXNFeHRlcmlvclJpbmcoKSA/IDAgOiBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBpRW5kID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gcG9pbnRzLmxlbmd0aCA6IC0xO1xuICAgIGNvbnN0IG9yZGVyZWRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gaVN0YXJ0OyBpICE9IGlFbmQ7IGkgKz0gc3RlcCkgb3JkZXJlZFBvaW50cy5wdXNoKFtwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnldKTtcbiAgICByZXR1cm4gb3JkZXJlZFBvaW50cztcbiAgfVxuICBpc0V4dGVyaW9yUmluZygpIHtcbiAgICBpZiAodGhpcy5faXNFeHRlcmlvclJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZW5jbG9zaW5nID0gdGhpcy5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICB0aGlzLl9pc0V4dGVyaW9yUmluZyA9IGVuY2xvc2luZyA/ICFlbmNsb3NpbmcuaXNFeHRlcmlvclJpbmcoKSA6IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0V4dGVyaW9yUmluZztcbiAgfVxuICBlbmNsb3NpbmdSaW5nKCkge1xuICAgIGlmICh0aGlzLl9lbmNsb3NpbmdSaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2VuY2xvc2luZ1JpbmcgPSB0aGlzLl9jYWxjRW5jbG9zaW5nUmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5jbG9zaW5nUmluZztcbiAgfVxuXG4gIC8qIFJldHVybnMgdGhlIHJpbmcgdGhhdCBlbmNsb3NlcyB0aGlzIG9uZSwgaWYgYW55ICovXG4gIF9jYWxjRW5jbG9zaW5nUmluZygpIHtcbiAgICAvLyBzdGFydCB3aXRoIHRoZSBlYWxpZXIgc3dlZXAgbGluZSBldmVudCBzbyB0aGF0IHRoZSBwcmV2U2VnXG4gICAgLy8gY2hhaW4gZG9lc24ndCBsZWFkIHVzIGluc2lkZSBvZiBhIGxvb3Agb2Ygb3Vyc1xuICAgIGxldCBsZWZ0TW9zdEV2dCA9IHRoaXMuZXZlbnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBpTWF4ID0gdGhpcy5ldmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBldnQgPSB0aGlzLmV2ZW50c1tpXTtcbiAgICAgIGlmIChTd2VlcEV2ZW50LmNvbXBhcmUobGVmdE1vc3RFdnQsIGV2dCkgPiAwKSBsZWZ0TW9zdEV2dCA9IGV2dDtcbiAgICB9XG4gICAgbGV0IHByZXZTZWcgPSBsZWZ0TW9zdEV2dC5zZWdtZW50LnByZXZJblJlc3VsdCgpO1xuICAgIGxldCBwcmV2UHJldlNlZyA9IHByZXZTZWcgPyBwcmV2U2VnLnByZXZJblJlc3VsdCgpIDogbnVsbDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gbm8gc2VnbWVudCBmb3VuZCwgdGh1cyBubyByaW5nIGNhbiBlbmNsb3NlIHVzXG4gICAgICBpZiAoIXByZXZTZWcpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBubyBzZWdtZW50cyBiZWxvdyBwcmV2IHNlZ21lbnQgZm91bmQsIHRodXMgdGhlIHJpbmcgb2YgdGhlIHByZXZcbiAgICAgIC8vIHNlZ21lbnQgbXVzdCBsb29wIGJhY2sgYXJvdW5kIGFuZCBlbmNsb3NlIHVzXG4gICAgICBpZiAoIXByZXZQcmV2U2VnKSByZXR1cm4gcHJldlNlZy5yaW5nT3V0O1xuXG4gICAgICAvLyBpZiB0aGUgdHdvIHNlZ21lbnRzIGFyZSBvZiBkaWZmZXJlbnQgcmluZ3MsIHRoZSByaW5nIG9mIHRoZSBwcmV2XG4gICAgICAvLyBzZWdtZW50IG11c3QgZWl0aGVyIGxvb3AgYXJvdW5kIHVzIG9yIHRoZSByaW5nIG9mIHRoZSBwcmV2IHByZXZcbiAgICAgIC8vIHNlZywgd2hpY2ggd291bGQgbWFrZSB1cyBhbmQgdGhlIHJpbmcgb2YgdGhlIHByZXYgcGVlcnNcbiAgICAgIGlmIChwcmV2UHJldlNlZy5yaW5nT3V0ICE9PSBwcmV2U2VnLnJpbmdPdXQpIHtcbiAgICAgICAgaWYgKHByZXZQcmV2U2VnLnJpbmdPdXQuZW5jbG9zaW5nUmluZygpICE9PSBwcmV2U2VnLnJpbmdPdXQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlNlZy5yaW5nT3V0O1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHByZXZTZWcucmluZ091dC5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHR3byBzZWdtZW50cyBhcmUgZnJvbSB0aGUgc2FtZSByaW5nLCBzbyB0aGlzIHdhcyBhIHBlbmlzdWxhXG4gICAgICAvLyBvZiB0aGF0IHJpbmcuIGl0ZXJhdGUgZG93bndhcmQsIGtlZXAgc2VhcmNoaW5nXG4gICAgICBwcmV2U2VnID0gcHJldlByZXZTZWcucHJldkluUmVzdWx0KCk7XG4gICAgICBwcmV2UHJldlNlZyA9IHByZXZTZWcgPyBwcmV2U2VnLnByZXZJblJlc3VsdCgpIDogbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBvbHlPdXQge1xuICBjb25zdHJ1Y3RvcihleHRlcmlvclJpbmcpIHtcbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IGV4dGVyaW9yUmluZztcbiAgICBleHRlcmlvclJpbmcucG9seSA9IHRoaXM7XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gW107XG4gIH1cbiAgYWRkSW50ZXJpb3IocmluZykge1xuICAgIHRoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKHJpbmcpO1xuICAgIHJpbmcucG9seSA9IHRoaXM7XG4gIH1cbiAgZ2V0R2VvbSgpIHtcbiAgICBjb25zdCBnZW9tID0gW3RoaXMuZXh0ZXJpb3JSaW5nLmdldEdlb20oKV07XG4gICAgLy8gZXh0ZXJpb3IgcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG4gICAgaWYgKGdlb21bMF0gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZ0dlb20gPSB0aGlzLmludGVyaW9yUmluZ3NbaV0uZ2V0R2VvbSgpO1xuICAgICAgLy8gaW50ZXJpb3IgcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG4gICAgICBpZiAocmluZ0dlb20gPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgZ2VvbS5wdXNoKHJpbmdHZW9tKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb207XG4gIH1cbn1cbmNsYXNzIE11bHRpUG9seU91dCB7XG4gIGNvbnN0cnVjdG9yKHJpbmdzKSB7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMucG9seXMgPSB0aGlzLl9jb21wb3NlUG9seXMocmluZ3MpO1xuICB9XG4gIGdldEdlb20oKSB7XG4gICAgY29uc3QgZ2VvbSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5wb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvbHlHZW9tID0gdGhpcy5wb2x5c1tpXS5nZXRHZW9tKCk7XG4gICAgICAvLyBleHRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcbiAgICAgIGlmIChwb2x5R2VvbSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBnZW9tLnB1c2gocG9seUdlb20pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbTtcbiAgfVxuICBfY29tcG9zZVBvbHlzKHJpbmdzKSB7XG4gICAgY29uc3QgcG9seXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgaWYgKHJpbmcucG9seSkgY29udGludWU7XG4gICAgICBpZiAocmluZy5pc0V4dGVyaW9yUmluZygpKSBwb2x5cy5wdXNoKG5ldyBQb2x5T3V0KHJpbmcpKTtlbHNlIHtcbiAgICAgICAgY29uc3QgZW5jbG9zaW5nUmluZyA9IHJpbmcuZW5jbG9zaW5nUmluZygpO1xuICAgICAgICBpZiAoIWVuY2xvc2luZ1JpbmcucG9seSkgcG9seXMucHVzaChuZXcgUG9seU91dChlbmNsb3NpbmdSaW5nKSk7XG4gICAgICAgIGVuY2xvc2luZ1JpbmcucG9seS5hZGRJbnRlcmlvcihyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvbHlzO1xuICB9XG59XG5cbi8qKlxuICogTk9URTogIFdlIG11c3QgYmUgY2FyZWZ1bCBub3QgdG8gY2hhbmdlIGFueSBzZWdtZW50cyB3aGlsZVxuICogICAgICAgIHRoZXkgYXJlIGluIHRoZSBTcGxheVRyZWUuIEFGQUlLLCB0aGVyZSdzIG5vIHdheSB0byB0ZWxsXG4gKiAgICAgICAgdGhlIHRyZWUgdG8gcmViYWxhbmNlIGl0c2VsZiAtIHRodXMgYmVmb3JlIHNwbGl0dGluZ1xuICogICAgICAgIGEgc2VnbWVudCB0aGF0J3MgaW4gdGhlIHRyZWUsIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLFxuICogICAgICAgIGRvIHRoZSBzcGxpdCwgdGhlbiByZS1pbnNlcnQgaXQuIChFdmVuIHRob3VnaCBzcGxpdHRpbmcgYVxuICogICAgICAgIHNlZ21lbnQgKnNob3VsZG4ndCogY2hhbmdlIGl0cyBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZVxuICogICAgICAgIHN3ZWVwIGxpbmUgdHJlZSwgdGhlIHJlYWxpdHkgaXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnMsXG4gKiAgICAgICAgaXQgc29tZXRpbWVzIGRvZXMuKVxuICovXG5cbmNsYXNzIFN3ZWVwTGluZSB7XG4gIGNvbnN0cnVjdG9yKHF1ZXVlKSB7XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFNlZ21lbnQuY29tcGFyZTtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgdGhpcy50cmVlID0gbmV3IFNwbGF5VHJlZShjb21wYXJhdG9yKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gIH1cbiAgcHJvY2VzcyhldmVudCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBldmVudC5zZWdtZW50O1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IFtdO1xuXG4gICAgLy8gaWYgd2UndmUgYWxyZWFkeSBiZWVuIGNvbnN1bWVkIGJ5IGFub3RoZXIgc2VnbWVudCxcbiAgICAvLyBjbGVhbiB1cCBvdXIgYm9keSBwYXJ0cyBhbmQgZ2V0IG91dFxuICAgIGlmIChldmVudC5jb25zdW1lZEJ5KSB7XG4gICAgICBpZiAoZXZlbnQuaXNMZWZ0KSB0aGlzLnF1ZXVlLnJlbW92ZShldmVudC5vdGhlclNFKTtlbHNlIHRoaXMudHJlZS5yZW1vdmUoc2VnbWVudCk7XG4gICAgICByZXR1cm4gbmV3RXZlbnRzO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gZXZlbnQuaXNMZWZ0ID8gdGhpcy50cmVlLmFkZChzZWdtZW50KSA6IHRoaXMudHJlZS5maW5kKHNlZ21lbnQpO1xuICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBzZWdtZW50ICMke3NlZ21lbnQuaWR9IGAgKyBgWyR7c2VnbWVudC5sZWZ0U0UucG9pbnQueH0sICR7c2VnbWVudC5sZWZ0U0UucG9pbnQueX1dIC0+IGAgKyBgWyR7c2VnbWVudC5yaWdodFNFLnBvaW50Lnh9LCAke3NlZ21lbnQucmlnaHRTRS5wb2ludC55fV0gYCArIFwiaW4gU3dlZXBMaW5lIHRyZWUuXCIpO1xuICAgIGxldCBwcmV2Tm9kZSA9IG5vZGU7XG4gICAgbGV0IG5leHROb2RlID0gbm9kZTtcbiAgICBsZXQgcHJldlNlZyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbmV4dFNlZyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNraXAgY29uc3VtZWQgc2VnbWVudHMgc3RpbGwgaW4gdHJlZVxuICAgIHdoaWxlIChwcmV2U2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZXZOb2RlID0gdGhpcy50cmVlLnByZXYocHJldk5vZGUpO1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSBwcmV2U2VnID0gbnVsbDtlbHNlIGlmIChwcmV2Tm9kZS5rZXkuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBwcmV2U2VnID0gcHJldk5vZGUua2V5O1xuICAgIH1cblxuICAgIC8vIHNraXAgY29uc3VtZWQgc2VnbWVudHMgc3RpbGwgaW4gdHJlZVxuICAgIHdoaWxlIChuZXh0U2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5leHROb2RlID0gdGhpcy50cmVlLm5leHQobmV4dE5vZGUpO1xuICAgICAgaWYgKG5leHROb2RlID09PSBudWxsKSBuZXh0U2VnID0gbnVsbDtlbHNlIGlmIChuZXh0Tm9kZS5rZXkuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBuZXh0U2VnID0gbmV4dE5vZGUua2V5O1xuICAgIH1cbiAgICBpZiAoZXZlbnQuaXNMZWZ0KSB7XG4gICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9ucyBhZ2FpbnN0IHRoZSBwcmV2aW91cyBzZWdtZW50IGluIHRoZSBzd2VlcCBsaW5lXG4gICAgICBsZXQgcHJldk15U3BsaXR0ZXIgPSBudWxsO1xuICAgICAgaWYgKHByZXZTZWcpIHtcbiAgICAgICAgY29uc3QgcHJldkludGVyID0gcHJldlNlZy5nZXRJbnRlcnNlY3Rpb24oc2VnbWVudCk7XG4gICAgICAgIGlmIChwcmV2SW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXNlZ21lbnQuaXNBbkVuZHBvaW50KHByZXZJbnRlcikpIHByZXZNeVNwbGl0dGVyID0gcHJldkludGVyO1xuICAgICAgICAgIGlmICghcHJldlNlZy5pc0FuRW5kcG9pbnQocHJldkludGVyKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzRnJvbVNwbGl0ID0gdGhpcy5fc3BsaXRTYWZlbHkocHJldlNlZywgcHJldkludGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzRnJvbVNwbGl0Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9ucyBhZ2FpbnN0IHRoZSBuZXh0IHNlZ21lbnQgaW4gdGhlIHN3ZWVwIGxpbmVcbiAgICAgIGxldCBuZXh0TXlTcGxpdHRlciA9IG51bGw7XG4gICAgICBpZiAobmV4dFNlZykge1xuICAgICAgICBjb25zdCBuZXh0SW50ZXIgPSBuZXh0U2VnLmdldEludGVyc2VjdGlvbihzZWdtZW50KTtcbiAgICAgICAgaWYgKG5leHRJbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghc2VnbWVudC5pc0FuRW5kcG9pbnQobmV4dEludGVyKSkgbmV4dE15U3BsaXR0ZXIgPSBuZXh0SW50ZXI7XG4gICAgICAgICAgaWYgKCFuZXh0U2VnLmlzQW5FbmRwb2ludChuZXh0SW50ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSB0aGlzLl9zcGxpdFNhZmVseShuZXh0U2VnLCBuZXh0SW50ZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKG5ld0V2ZW50c0Zyb21TcGxpdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCBldmVuIGlmIHdlIGZpbmQgbW9yZSB0aGFuIG9uZSBpbnRlcnNlY3Rpb24gd2Ugb25seVxuICAgICAgLy8gc3BpbHQgb24gdGhlICdlYXJsaWVzdCcgKHN3ZWVwLWxpbmUgc3R5bGUpIG9mIHRoZSBpbnRlcnNlY3Rpb25zLlxuICAgICAgLy8gVGhlIG90aGVyIGludGVyc2VjdGlvbiB3aWxsIGJlIGhhbmRsZWQgaW4gYSBmdXR1cmUgcHJvY2VzcygpLlxuICAgICAgaWYgKHByZXZNeVNwbGl0dGVyICE9PSBudWxsIHx8IG5leHRNeVNwbGl0dGVyICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBteVNwbGl0dGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHByZXZNeVNwbGl0dGVyID09PSBudWxsKSBteVNwbGl0dGVyID0gbmV4dE15U3BsaXR0ZXI7ZWxzZSBpZiAobmV4dE15U3BsaXR0ZXIgPT09IG51bGwpIG15U3BsaXR0ZXIgPSBwcmV2TXlTcGxpdHRlcjtlbHNlIHtcbiAgICAgICAgICBjb25zdCBjbXBTcGxpdHRlcnMgPSBTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHMocHJldk15U3BsaXR0ZXIsIG5leHRNeVNwbGl0dGVyKTtcbiAgICAgICAgICBteVNwbGl0dGVyID0gY21wU3BsaXR0ZXJzIDw9IDAgPyBwcmV2TXlTcGxpdHRlciA6IG5leHRNeVNwbGl0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRpbmcgZXJyb3JzIGNhbiBjYXVzZSBjaGFuZ2VzIGluIG9yZGVyaW5nLFxuICAgICAgICAvLyBzbyByZW1vdmUgYWZlY3RlZCBzZWdtZW50cyBhbmQgcmlnaHQgc3dlZXAgZXZlbnRzIGJlZm9yZSBzcGxpdHRpbmdcbiAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmUoc2VnbWVudC5yaWdodFNFKTtcbiAgICAgICAgbmV3RXZlbnRzLnB1c2goc2VnbWVudC5yaWdodFNFKTtcbiAgICAgICAgY29uc3QgbmV3RXZlbnRzRnJvbVNwbGl0ID0gc2VnbWVudC5zcGxpdChteVNwbGl0dGVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgbmV3RXZlbnRzLnB1c2gobmV3RXZlbnRzRnJvbVNwbGl0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld0V2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgaW50ZXJzZWN0aW9ucywgc28gcmUtZG8gdGhlIGN1cnJlbnQgZXZlbnQgdG9cbiAgICAgICAgLy8gbWFrZSBzdXJlIHN3ZWVwIGxpbmUgb3JkZXJpbmcgaXMgdG90YWxseSBjb25zaXN0ZW50IGZvciBsYXRlclxuICAgICAgICAvLyB1c2Ugd2l0aCB0aGUgc2VnbWVudCAncHJldicgcG9pbnRlcnNcbiAgICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICAgICAgbmV3RXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uZSB3aXRoIGxlZnQgZXZlbnRcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICBzZWdtZW50LnByZXYgPSBwcmV2U2VnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBldmVudC5pc1JpZ2h0XG5cbiAgICAgIC8vIHNpbmNlIHdlJ3JlIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3dlZXAgbGluZSwgY2hlY2sgZm9yXG4gICAgICAvLyBpbnRlcnNlY3Rpb25zIGJldHdlZW4gb3VyIHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnRzXG4gICAgICBpZiAocHJldlNlZyAmJiBuZXh0U2VnKSB7XG4gICAgICAgIGNvbnN0IGludGVyID0gcHJldlNlZy5nZXRJbnRlcnNlY3Rpb24obmV4dFNlZyk7XG4gICAgICAgIGlmIChpbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghcHJldlNlZy5pc0FuRW5kcG9pbnQoaW50ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSB0aGlzLl9zcGxpdFNhZmVseShwcmV2U2VnLCBpbnRlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50c0Zyb21TcGxpdC5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgbmV3RXZlbnRzLnB1c2gobmV3RXZlbnRzRnJvbVNwbGl0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFuZXh0U2VnLmlzQW5FbmRwb2ludChpbnRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50c0Zyb21TcGxpdCA9IHRoaXMuX3NwbGl0U2FmZWx5KG5leHRTZWcsIGludGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzRnJvbVNwbGl0Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0V2ZW50cztcbiAgfVxuXG4gIC8qIFNhZmVseSBzcGxpdCBhIHNlZ21lbnQgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGRhdGFzdHJ1Y3R1cmVzXG4gICAqIElFIC0gYSBzZWdtZW50IG90aGVyIHRoYW4gdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuICovXG4gIF9zcGxpdFNhZmVseShzZWcsIHB0KSB7XG4gICAgLy8gUm91bmRpbmcgZXJyb3JzIGNhbiBjYXVzZSBjaGFuZ2VzIGluIG9yZGVyaW5nLFxuICAgIC8vIHNvIHJlbW92ZSBhZmVjdGVkIHNlZ21lbnRzIGFuZCByaWdodCBzd2VlcCBldmVudHMgYmVmb3JlIHNwbGl0dGluZ1xuICAgIC8vIHJlbW92ZU5vZGUoKSBkb2Vzbid0IHdvcmssIHNvIGhhdmUgcmUtZmluZCB0aGUgc2VnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3c4ci9zcGxheS10cmVlL3B1bGwvNVxuICAgIHRoaXMudHJlZS5yZW1vdmUoc2VnKTtcbiAgICBjb25zdCByaWdodFNFID0gc2VnLnJpZ2h0U0U7XG4gICAgdGhpcy5xdWV1ZS5yZW1vdmUocmlnaHRTRSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gc2VnLnNwbGl0KHB0KTtcbiAgICBuZXdFdmVudHMucHVzaChyaWdodFNFKTtcbiAgICAvLyBzcGxpdHRpbmcgY2FuIHRyaWdnZXIgY29uc3VtcHRpb25cbiAgICBpZiAoc2VnLmNvbnN1bWVkQnkgPT09IHVuZGVmaW5lZCkgdGhpcy50cmVlLmFkZChzZWcpO1xuICAgIHJldHVybiBuZXdFdmVudHM7XG4gIH1cbn1cblxuLy8gTGltaXRzIG9uIGl0ZXJhdGl2ZSBwcm9jZXNzZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcyAtIHVzdWFsbHkgY2F1c2VkIGJ5IGZsb2F0aW5nLXBvaW50IG1hdGggcm91bmQtb2ZmIGVycm9ycy5cbmNvbnN0IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5QT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFIHx8IDEwMDAwMDA7XG5jb25zdCBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5QT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMgfHwgMTAwMDAwMDtcbmNsYXNzIE9wZXJhdGlvbiB7XG4gIHJ1bih0eXBlLCBnZW9tLCBtb3JlR2VvbXMpIHtcbiAgICBvcGVyYXRpb24udHlwZSA9IHR5cGU7XG4gICAgcm91bmRlci5yZXNldCgpO1xuXG4gICAgLyogQ29udmVydCBpbnB1dHMgdG8gTXVsdGlQb2x5IG9iamVjdHMgKi9cbiAgICBjb25zdCBtdWx0aXBvbHlzID0gW25ldyBNdWx0aVBvbHlJbihnZW9tLCB0cnVlKV07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBtb3JlR2VvbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBtdWx0aXBvbHlzLnB1c2gobmV3IE11bHRpUG9seUluKG1vcmVHZW9tc1tpXSwgZmFsc2UpKTtcbiAgICB9XG4gICAgb3BlcmF0aW9uLm51bU11bHRpUG9seXMgPSBtdWx0aXBvbHlzLmxlbmd0aDtcblxuICAgIC8qIEJCb3ggb3B0aW1pemF0aW9uIGZvciBkaWZmZXJlbmNlIG9wZXJhdGlvblxuICAgICAqIElmIHRoZSBiYm94IG9mIGEgbXVsdGlwb2x5Z29uIHRoYXQncyBwYXJ0IG9mIHRoZSBjbGlwcGluZyBkb2Vzbid0XG4gICAgICogaW50ZXJzZWN0IHRoZSBiYm94IG9mIHRoZSBzdWJqZWN0IGF0IGFsbCwgd2UgY2FuIGp1c3QgZHJvcCB0aGF0XG4gICAgICogbXVsdGlwbG95Z29uLiAqL1xuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJkaWZmZXJlbmNlXCIpIHtcbiAgICAgIC8vIGluIHBsYWNlIHJlbW92YWxcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBtdWx0aXBvbHlzWzBdO1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgd2hpbGUgKGkgPCBtdWx0aXBvbHlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZ2V0QmJveE92ZXJsYXAobXVsdGlwb2x5c1tpXS5iYm94LCBzdWJqZWN0LmJib3gpICE9PSBudWxsKSBpKys7ZWxzZSBtdWx0aXBvbHlzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBCQm94IG9wdGltaXphdGlvbiBmb3IgaW50ZXJzZWN0aW9uIG9wZXJhdGlvblxuICAgICAqIElmIHdlIGNhbiBmaW5kIGFueSBwYWlyIG9mIG11bHRpcG9seWdvbnMgd2hvc2UgYmJveCBkb2VzIG5vdCBvdmVybGFwLFxuICAgICAqIHRoZW4gdGhlIHJlc3VsdCB3aWxsIGJlIGVtcHR5LiAqL1xuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIikge1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBPKG5eMikgaW4gbnVtYmVyIG9mIHBvbHlnb25zLiBCeSBzb3J0aW5nIHRoZSBiYm94ZXMsXG4gICAgICAvLyAgICAgICBpdCBjb3VsZCBiZSBvcHRpbWl6ZWQgdG8gTyhuICogbG4obikpXG4gICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG11bHRpcG9seXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1wQSA9IG11bHRpcG9seXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMSwgak1heCA9IG11bHRpcG9seXMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgaWYgKGdldEJib3hPdmVybGFwKG1wQS5iYm94LCBtdWx0aXBvbHlzW2pdLmJib3gpID09PSBudWxsKSByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQdXQgc2VnbWVudCBlbmRwb2ludHMgaW4gYSBwcmlvcml0eSBxdWV1ZSAqL1xuICAgIGNvbnN0IHF1ZXVlID0gbmV3IFNwbGF5VHJlZShTd2VlcEV2ZW50LmNvbXBhcmUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbXVsdGlwb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHN3ZWVwRXZlbnRzID0gbXVsdGlwb2x5c1tpXS5nZXRTd2VlcEV2ZW50cygpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpNYXggPSBzd2VlcEV2ZW50cy5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAgICAgcXVldWUuaW5zZXJ0KHN3ZWVwRXZlbnRzW2pdKTtcbiAgICAgICAgaWYgKHF1ZXVlLnNpemUgPiBQT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFKSB7XG4gICAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmZpbml0ZSBsb29wIHdoZW4gcHV0dGluZyBzZWdtZW50IGVuZHBvaW50cyBpbiBhIHByaW9yaXR5IHF1ZXVlIFwiICsgXCIocXVldWUgc2l6ZSB0b28gYmlnKS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQYXNzIHRoZSBzd2VlcCBsaW5lIG92ZXIgdGhvc2UgZW5kcG9pbnRzICovXG4gICAgY29uc3Qgc3dlZXBMaW5lID0gbmV3IFN3ZWVwTGluZShxdWV1ZSk7XG4gICAgbGV0IHByZXZRdWV1ZVNpemUgPSBxdWV1ZS5zaXplO1xuICAgIGxldCBub2RlID0gcXVldWUucG9wKCk7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGNvbnN0IGV2dCA9IG5vZGUua2V5O1xuICAgICAgaWYgKHF1ZXVlLnNpemUgPT09IHByZXZRdWV1ZVNpemUpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgY29uc3Qgc2VnID0gZXZ0LnNlZ21lbnQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBvcCgpICR7ZXZ0LmlzTGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwifSBTd2VlcEV2ZW50IGAgKyBgWyR7ZXZ0LnBvaW50Lnh9LCAke2V2dC5wb2ludC55fV0gZnJvbSBzZWdtZW50ICMke3NlZy5pZH0gYCArIGBbJHtzZWcubGVmdFNFLnBvaW50Lnh9LCAke3NlZy5sZWZ0U0UucG9pbnQueX1dIC0+IGAgKyBgWyR7c2VnLnJpZ2h0U0UucG9pbnQueH0sICR7c2VnLnJpZ2h0U0UucG9pbnQueX1dIGZyb20gcXVldWUuYCk7XG4gICAgICB9XG4gICAgICBpZiAocXVldWUuc2l6ZSA+IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyBcIiArIFwiKHF1ZXVlIHNpemUgdG9vIGJpZykuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN3ZWVwTGluZS5zZWdtZW50cy5sZW5ndGggPiBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyBcIiArIFwiKHRvbyBtYW55IHN3ZWVwIGxpbmUgc2VnbWVudHMpLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IHN3ZWVwTGluZS5wcm9jZXNzKGV2dCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gbmV3RXZlbnRzW2ldO1xuICAgICAgICBpZiAoZXZ0LmNvbnN1bWVkQnkgPT09IHVuZGVmaW5lZCkgcXVldWUuaW5zZXJ0KGV2dCk7XG4gICAgICB9XG4gICAgICBwcmV2UXVldWVTaXplID0gcXVldWUuc2l6ZTtcbiAgICAgIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyBmcmVlIHNvbWUgbWVtb3J5IHdlIGRvbid0IG5lZWQgYW55bW9yZVxuICAgIHJvdW5kZXIucmVzZXQoKTtcblxuICAgIC8qIENvbGxlY3QgYW5kIGNvbXBpbGUgc2VnbWVudHMgd2UncmUga2VlcGluZyBpbnRvIGEgbXVsdGlwb2x5Z29uICovXG4gICAgY29uc3QgcmluZ3NPdXQgPSBSaW5nT3V0LmZhY3Rvcnkoc3dlZXBMaW5lLnNlZ21lbnRzKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTXVsdGlQb2x5T3V0KHJpbmdzT3V0KTtcbiAgICByZXR1cm4gcmVzdWx0LmdldEdlb20oKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gYXZhaWxhYmxlIGJ5IGltcG9ydFxuY29uc3Qgb3BlcmF0aW9uID0gbmV3IE9wZXJhdGlvbigpO1xuXG5jb25zdCB1bmlvbiA9IGZ1bmN0aW9uIChnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtb3JlR2VvbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1vcmVHZW9tc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJ1bmlvblwiLCBnZW9tLCBtb3JlR2VvbXMpO1xufTtcbmNvbnN0IGludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbW9yZUdlb21zID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBtb3JlR2VvbXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJpbnRlcnNlY3Rpb25cIiwgZ2VvbSwgbW9yZUdlb21zKTtcbn07XG5jb25zdCB4b3IgPSBmdW5jdGlvbiAoZ2VvbSkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG1vcmVHZW9tcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgbW9yZUdlb21zW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIHJldHVybiBvcGVyYXRpb24ucnVuKFwieG9yXCIsIGdlb20sIG1vcmVHZW9tcyk7XG59O1xuY29uc3QgZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzdWJqZWN0R2VvbSkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsaXBwaW5nR2VvbXMgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGNsaXBwaW5nR2VvbXNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJkaWZmZXJlbmNlXCIsIHN1YmplY3RHZW9tLCBjbGlwcGluZ0dlb21zKTtcbn07XG52YXIgaW5kZXggPSB7XG4gIHVuaW9uOiB1bmlvbixcbiAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gIHhvcjogeG9yLFxuICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlXG59O1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiU3BsYXlUcmVlIiwib3JpZW50MmQiLCJpc0luQmJveCIsImJib3giLCJwb2ludCIsImxsIiwieCIsInVyIiwieSIsImdldEJib3hPdmVybGFwIiwiYjEiLCJiMiIsImxvd2VyWCIsInVwcGVyWCIsImxvd2VyWSIsInVwcGVyWSIsImVwc2lsb24iLCJOdW1iZXIiLCJFUFNJTE9OIiwidW5kZWZpbmVkIiwiTWF0aCIsInBvdyIsIkVQU0lMT05fU1EiLCJjbXAiLCJhIiwiYiIsImFiIiwiUHRSb3VuZGVyIiwiY29uc3RydWN0b3IiLCJyZXNldCIsInhSb3VuZGVyIiwiQ29vcmRSb3VuZGVyIiwieVJvdW5kZXIiLCJyb3VuZCIsInRyZWUiLCJjb29yZCIsIm5vZGUiLCJhZGQiLCJwcmV2Tm9kZSIsInByZXYiLCJrZXkiLCJyZW1vdmUiLCJuZXh0Tm9kZSIsIm5leHQiLCJyb3VuZGVyIiwiY3Jvc3NQcm9kdWN0IiwiZG90UHJvZHVjdCIsImNvbXBhcmVWZWN0b3JBbmdsZXMiLCJiYXNlUHQiLCJlbmRQdDEiLCJlbmRQdDIiLCJyZXMiLCJsZW5ndGgiLCJ2Iiwic3FydCIsInNpbmVPZkFuZ2xlIiwicFNoYXJlZCIsInBCYXNlIiwicEFuZ2xlIiwidkJhc2UiLCJ2QW5nbGUiLCJjb3NpbmVPZkFuZ2xlIiwiaG9yaXpvbnRhbEludGVyc2VjdGlvbiIsInB0IiwidmVydGljYWxJbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb24kMSIsInB0MSIsInYxIiwicHQyIiwidjIiLCJrcm9zcyIsInZlIiwiZDEiLCJkMiIsIngxIiwieDIiLCJ5MSIsInkyIiwiU3dlZXBFdmVudCIsImNvbXBhcmUiLCJwdENtcCIsImNvbXBhcmVQb2ludHMiLCJsaW5rIiwiaXNMZWZ0IiwiU2VnbWVudCIsInNlZ21lbnQiLCJhUHQiLCJiUHQiLCJldmVudHMiLCJwdXNoIiwib3RoZXIiLCJFcnJvciIsIm90aGVyRXZlbnRzIiwiaSIsImlNYXgiLCJldnQiLCJjaGVja0ZvckNvbnN1bWluZyIsIm51bUV2ZW50cyIsImV2dDEiLCJjb25zdW1lZEJ5IiwiaiIsImV2dDIiLCJvdGhlclNFIiwiY29uc3VtZSIsImdldEF2YWlsYWJsZUxpbmtlZEV2ZW50cyIsInJpbmdPdXQiLCJpc0luUmVzdWx0IiwiZ2V0TGVmdG1vc3RDb21wYXJhdG9yIiwiYmFzZUV2ZW50IiwiY2FjaGUiLCJNYXAiLCJmaWxsQ2FjaGUiLCJsaW5rZWRFdmVudCIsIm5leHRFdmVudCIsInNldCIsInNpbmUiLCJjb3NpbmUiLCJoYXMiLCJhc2luZSIsImFjb3NpbmUiLCJnZXQiLCJic2luZSIsImJjb3NpbmUiLCJzZWdtZW50SWQiLCJhbHgiLCJsZWZ0U0UiLCJibHgiLCJhcngiLCJyaWdodFNFIiwiYnJ4IiwiYWx5IiwiYmx5IiwiYXJ5IiwiYnJ5IiwiYUNtcEJMZWZ0IiwiY29tcGFyZVBvaW50IiwiYkNtcEFSaWdodCIsImJDbXBBTGVmdCIsImFDbXBCUmlnaHQiLCJheSIsImF4IiwiYnkiLCJieCIsImlkIiwicmluZ3MiLCJ3aW5kaW5ncyIsImZyb21SaW5nIiwicmluZyIsImxlZnRQdCIsInJpZ2h0UHQiLCJ3aW5kaW5nIiwiY21wUHRzIiwicmVwbGFjZVJpZ2h0U0UiLCJuZXdSaWdodFNFIiwidmVjdG9yIiwiaXNBbkVuZHBvaW50IiwibFB0IiwiclB0IiwieURpc3QiLCJ4RnJvbVlEaXN0IiwieERpc3QiLCJ5RnJvbVhEaXN0IiwiZ2V0SW50ZXJzZWN0aW9uIiwidEJib3giLCJvQmJveCIsImJib3hPdmVybGFwIiwidGxwIiwidHJwIiwib2xwIiwib3JwIiwidG91Y2hlc090aGVyTFNFIiwidG91Y2hlc1RoaXNMU0UiLCJ0b3VjaGVzT3RoZXJSU0UiLCJ0b3VjaGVzVGhpc1JTRSIsInNwbGl0IiwibmV3RXZlbnRzIiwiYWxyZWFkeUxpbmtlZCIsIm5ld0xlZnRTRSIsIm9sZFJpZ2h0U0UiLCJuZXdTZWciLCJzbGljZSIsInN3YXBFdmVudHMiLCJ0bXBFdnQiLCJjb25zdW1lciIsImNvbnN1bWVlIiwidG1wIiwiaW5kZXgiLCJpbmRleE9mIiwicHJldkluUmVzdWx0IiwiX3ByZXZJblJlc3VsdCIsImJlZm9yZVN0YXRlIiwiX2JlZm9yZVN0YXRlIiwibXVsdGlQb2x5cyIsInNlZyIsImFmdGVyU3RhdGUiLCJfYWZ0ZXJTdGF0ZSIsInJpbmdzQWZ0ZXIiLCJ3aW5kaW5nc0FmdGVyIiwibXBzQWZ0ZXIiLCJwb2x5c0FmdGVyIiwicG9seXNFeGNsdWRlIiwicG9seSIsImlzRXh0ZXJpb3IiLCJzcGxpY2UiLCJtcCIsIm11bHRpUG9seSIsIl9pc0luUmVzdWx0IiwibXBzQmVmb3JlIiwib3BlcmF0aW9uIiwidHlwZSIsIm5vQmVmb3JlcyIsIm5vQWZ0ZXJzIiwibGVhc3QiLCJtb3N0IiwibnVtTXVsdGlQb2x5cyIsImRpZmYiLCJhYnMiLCJpc0p1c3RTdWJqZWN0IiwibXBzIiwiaXNTdWJqZWN0IiwiUmluZ0luIiwiZ2VvbVJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJzZWdtZW50cyIsImZpcnN0UG9pbnQiLCJwcmV2UG9pbnQiLCJnZXRTd2VlcEV2ZW50cyIsInN3ZWVwRXZlbnRzIiwiUG9seUluIiwiZ2VvbVBvbHkiLCJleHRlcmlvclJpbmciLCJpbnRlcmlvclJpbmdzIiwicmluZ1N3ZWVwRXZlbnRzIiwiak1heCIsIk11bHRpUG9seUluIiwiZ2VvbSIsImV4IiwicG9seXMiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwicG9seVN3ZWVwRXZlbnRzIiwiUmluZ091dCIsImZhY3RvcnkiLCJhbGxTZWdtZW50cyIsInJpbmdzT3V0IiwicHJldkV2ZW50IiwiZXZlbnQiLCJzdGFydGluZ1BvaW50IiwiaW50ZXJzZWN0aW9uTEVzIiwiYXZhaWxhYmxlTEVzIiwiZmlyc3RQdCIsImxhc3RQdCIsImluZGV4TEUiLCJpbnRlcnNlY3Rpb25MRSIsInJpbmdFdmVudHMiLCJ1bnNoaWZ0IiwicmV2ZXJzZSIsImNvbXBhcmF0b3IiLCJzb3J0IiwiZ2V0R2VvbSIsInByZXZQdCIsInBvaW50cyIsIm5leHRQdCIsInNoaWZ0Iiwic3RlcCIsImlzRXh0ZXJpb3JSaW5nIiwiaVN0YXJ0IiwiaUVuZCIsIm9yZGVyZWRQb2ludHMiLCJfaXNFeHRlcmlvclJpbmciLCJlbmNsb3NpbmciLCJlbmNsb3NpbmdSaW5nIiwiX2VuY2xvc2luZ1JpbmciLCJfY2FsY0VuY2xvc2luZ1JpbmciLCJsZWZ0TW9zdEV2dCIsInByZXZTZWciLCJwcmV2UHJldlNlZyIsIlBvbHlPdXQiLCJhZGRJbnRlcmlvciIsInJpbmdHZW9tIiwiTXVsdGlQb2x5T3V0IiwiX2NvbXBvc2VQb2x5cyIsInBvbHlHZW9tIiwiU3dlZXBMaW5lIiwicXVldWUiLCJhcmd1bWVudHMiLCJwcm9jZXNzIiwiZmluZCIsIm5leHRTZWciLCJwcmV2TXlTcGxpdHRlciIsInByZXZJbnRlciIsIm5ld0V2ZW50c0Zyb21TcGxpdCIsIl9zcGxpdFNhZmVseSIsIm5leHRNeVNwbGl0dGVyIiwibmV4dEludGVyIiwibXlTcGxpdHRlciIsImNtcFNwbGl0dGVycyIsImludGVyIiwiUE9MWUdPTl9DTElQUElOR19NQVhfUVVFVUVfU0laRSIsImVudiIsIlBPTFlHT05fQ0xJUFBJTkdfTUFYX1NXRUVQTElORV9TRUdNRU5UUyIsIk9wZXJhdGlvbiIsInJ1biIsIm1vcmVHZW9tcyIsIm11bHRpcG9seXMiLCJzdWJqZWN0IiwibXBBIiwiaW5zZXJ0Iiwic2l6ZSIsInN3ZWVwTGluZSIsInByZXZRdWV1ZVNpemUiLCJwb3AiLCJyZXN1bHQiLCJ1bmlvbiIsIl9sZW4iLCJfa2V5IiwiaW50ZXJzZWN0aW9uIiwiX2xlbjIiLCJfa2V5MiIsInhvciIsIl9sZW4zIiwiX2tleTMiLCJkaWZmZXJlbmNlIiwic3ViamVjdEdlb20iLCJfbGVuNCIsImNsaXBwaW5nR2VvbXMiLCJfa2V5NCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js\n");

/***/ })

};
;