"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/concaveman";
exports.ids = ["vendor-chunks/concaveman"];
exports.modules = {

/***/ "(ssr)/./node_modules/concaveman/index.js":
/*!******************************************!*\
  !*** ./node_modules/concaveman/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ concaveman)\n/* harmony export */ });\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ \"(ssr)/./node_modules/concaveman/node_modules/rbush/index.js\");\n/* harmony import */ var tinyqueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/tinyqueue/index.js\");\n/* harmony import */ var point_in_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! point-in-polygon */ \"(ssr)/./node_modules/point-in-polygon/index.js\");\n/* harmony import */ var robust_predicates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! robust-predicates */ \"(ssr)/./node_modules/robust-predicates/index.js\");\n\n\n\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n    // start with a convex hull of the points\n    const hull = fastConvexHull(points);\n    // index the points with an R-tree\n    const tree = new rbush__WEBPACK_IMPORTED_MODULE_0__[\"default\"](16);\n    tree.toBBox = function(a) {\n        return {\n            minX: a[0],\n            minY: a[1],\n            maxX: a[0],\n            maxY: a[1]\n        };\n    };\n    tree.compareMinX = function(a, b) {\n        return a[0] - b[0];\n    };\n    tree.compareMinY = function(a, b) {\n        return a[1] - b[1];\n    };\n    tree.load(points);\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    const queue = [];\n    let last;\n    for(let i = 0; i < hull.length; i++){\n        const p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n    // index the segments with an R-tree (for intersection checks)\n    const segTree = new rbush__WEBPACK_IMPORTED_MODULE_0__[\"default\"](16);\n    for(let i = 0; i < queue.length; i++)segTree.insert(updateBBox(queue[i]));\n    const sqConcavity = concavity * concavity;\n    const sqLenThreshold = lengthThreshold * lengthThreshold;\n    // process edges one by one\n    while(queue.length){\n        const node = queue.shift();\n        const a = node.p;\n        const b = node.next.p;\n        // skip the edge if it's already short enough\n        const sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n        const maxSqLen = sqLen / sqConcavity;\n        // find the best connection point for the current edge to flex inward to\n        const p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n    // convert the resulting hull linked list to an array of points\n    let node = last;\n    const concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    }while (node !== last);\n    concave.push(node.p);\n    return concave;\n}\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    const queue = new tinyqueue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([], compareDist);\n    let node = tree.data;\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while(node){\n        for(let i = 0; i < node.children.length; i++){\n            const child = node.children[i];\n            const dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n            queue.push({\n                node: child,\n                dist\n            });\n        }\n        while(queue.length && !queue.peek().node.children){\n            const item = queue.pop();\n            const p = item.node;\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            const d0 = sqSegDist(p, a, b);\n            const d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;\n        }\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n    return null;\n}\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    const d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    const d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    const d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    const d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;\n}\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    const minX = Math.min(a[0], b[0]);\n    const minY = Math.min(a[1], b[1]);\n    const maxX = Math.max(a[0], b[0]);\n    const maxY = Math.max(a[1], b[1]);\n    const edges = segTree.search({\n        minX,\n        minY,\n        maxX,\n        maxY\n    });\n    for(let i = 0; i < edges.length; i++){\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\nfunction cross(p1, p2, p3) {\n    return (0,robust_predicates__WEBPACK_IMPORTED_MODULE_3__.orient2d)(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    const p1 = node.p;\n    const p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    let left = points[0];\n    let top = points[0];\n    let right = points[0];\n    let bottom = points[0];\n    // find the leftmost, rightmost, topmost and bottommost points\n    for(let i = 0; i < points.length; i++){\n        const p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n    // filter out points that are inside the resulting quadrilateral\n    const cull = [\n        left,\n        top,\n        right,\n        bottom\n    ];\n    const filtered = cull.slice();\n    for(let i = 0; i < points.length; i++){\n        if (!point_in_polygon__WEBPACK_IMPORTED_MODULE_2__(points[i], cull)) filtered.push(points[i]);\n    }\n    // get convex hull around the filtered points\n    return convexHull(filtered);\n}\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    const node = {\n        p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n    const dx = p1[0] - p2[0], dy = p1[1] - p2[1];\n    return dx * dx + dy * dy;\n}\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n    let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;\n    if (dx !== 0 || dy !== 0) {\n        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n    dx = p[0] - x;\n    dy = p[1] - y;\n    return dx * dx + dy * dy;\n}\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const ux = x1 - x0;\n    const uy = y1 - y0;\n    const vx = x3 - x2;\n    const vy = y3 - y2;\n    const wx = x0 - x2;\n    const wy = y0 - y2;\n    const a = ux * ux + uy * uy;\n    const b = ux * vx + uy * vy;\n    const c = vx * vx + vy * vy;\n    const d = ux * wx + uy * wy;\n    const e = vx * wx + vy * wy;\n    const D = a * c - b * b;\n    let sN, tN;\n    let sD = D;\n    let tD = D;\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if (-d + b < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n    const sc = sN === 0 ? 0 : sN / sD;\n    const tc = tN === 0 ? 0 : tN / tD;\n    const cx = (1 - sc) * x0 + sc * x1;\n    const cy = (1 - sc) * y0 + sc * y1;\n    const cx2 = (1 - tc) * x2 + tc * x3;\n    const cy2 = (1 - tc) * y2 + tc * y3;\n    const dx = cx2 - cx;\n    const dy = cy2 - cy;\n    return dx * dx + dy * dy;\n}\nfunction compareByX(a, b) {\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\nfunction convexHull(points) {\n    points.sort(compareByX);\n    const lower = [];\n    for(let i = 0; i < points.length; i++){\n        while(lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0){\n            lower.pop();\n        }\n        lower.push(points[i]);\n    }\n    const upper = [];\n    for(let ii = points.length - 1; ii >= 0; ii--){\n        while(upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0){\n            upper.pop();\n        }\n        upper.push(points[ii]);\n    }\n    upper.pop();\n    lower.pop();\n    return lower.concat(upper);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwQjtBQUNJO0FBQ2dCO0FBQ0g7QUFFNUIsU0FBU0ksV0FBV0MsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLGVBQWU7SUFDakUsbUVBQW1FO0lBQ25FRCxZQUFZRSxLQUFLQyxHQUFHLENBQUMsR0FBR0gsY0FBY0ksWUFBWSxJQUFJSjtJQUV0RCxvRkFBb0Y7SUFDcEZDLGtCQUFrQkEsbUJBQW1CO0lBRXJDLHlDQUF5QztJQUN6QyxNQUFNSSxPQUFPQyxlQUFlUDtJQUU1QixrQ0FBa0M7SUFDbEMsTUFBTVEsT0FBTyxJQUFJYiw2Q0FBS0EsQ0FBQztJQUN2QmEsS0FBS0MsTUFBTSxHQUFHLFNBQVVDLENBQUM7UUFDckIsT0FBTztZQUNIQyxNQUFNRCxDQUFDLENBQUMsRUFBRTtZQUNWRSxNQUFNRixDQUFDLENBQUMsRUFBRTtZQUNWRyxNQUFNSCxDQUFDLENBQUMsRUFBRTtZQUNWSSxNQUFNSixDQUFDLENBQUMsRUFBRTtRQUNkO0lBQ0o7SUFDQUYsS0FBS08sV0FBVyxHQUFHLFNBQVVMLENBQUMsRUFBRU0sQ0FBQztRQUFJLE9BQU9OLENBQUMsQ0FBQyxFQUFFLEdBQUdNLENBQUMsQ0FBQyxFQUFFO0lBQUU7SUFDekRSLEtBQUtTLFdBQVcsR0FBRyxTQUFVUCxDQUFDLEVBQUVNLENBQUM7UUFBSSxPQUFPTixDQUFDLENBQUMsRUFBRSxHQUFHTSxDQUFDLENBQUMsRUFBRTtJQUFFO0lBRXpEUixLQUFLVSxJQUFJLENBQUNsQjtJQUVWLDZGQUE2RjtJQUM3RixNQUFNbUIsUUFBUSxFQUFFO0lBQ2hCLElBQUlDO0lBQ0osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlmLEtBQUtnQixNQUFNLEVBQUVELElBQUs7UUFDbEMsTUFBTUUsSUFBSWpCLElBQUksQ0FBQ2UsRUFBRTtRQUNqQmIsS0FBS2dCLE1BQU0sQ0FBQ0Q7UUFDWkgsT0FBT0ssV0FBV0YsR0FB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SUFBSSxLQUFLOEMsTUFBTWdELEtBQUssQ0FBQ0EsTUFBTTlGLE1BQU0sR0FBRyxFQUFFLEVBQUU4RixLQUFLLENBQUNBLE1BQU05RixNQUFNLEdBQUcsRUFBRSxFQUFFdEIsTUFBTSxDQUFDcUgsR0FBRyxLQUFLLEVBQUc7WUFDbEdELE1BQU03RCxHQUFHO1FBQ2I7UUFDQTZELE1BQU0xRixJQUFJLENBQUMxQixNQUFNLENBQUNxSCxHQUFHO0lBQ3pCO0lBRUFELE1BQU03RCxHQUFHO0lBQ1Q0RCxNQUFNNUQsR0FBRztJQUNULE9BQU80RCxNQUFNRyxNQUFNLENBQUNGO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdjMtYXBwLy4vbm9kZV9tb2R1bGVzL2NvbmNhdmVtYW4vaW5kZXguanM/ZWE2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQgUXVldWUgZnJvbSAndGlueXF1ZXVlJztcbmltcG9ydCBwb2ludEluUG9seWdvbiBmcm9tICdwb2ludC1pbi1wb2x5Z29uJztcbmltcG9ydCB7b3JpZW50MmR9IGZyb20gJ3JvYnVzdC1wcmVkaWNhdGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uY2F2ZW1hbihwb2ludHMsIGNvbmNhdml0eSwgbGVuZ3RoVGhyZXNob2xkKSB7XG4gICAgLy8gYSByZWxhdGl2ZSBtZWFzdXJlIG9mIGNvbmNhdml0eTsgaGlnaGVyIHZhbHVlIG1lYW5zIHNpbXBsZXIgaHVsbFxuICAgIGNvbmNhdml0eSA9IE1hdGgubWF4KDAsIGNvbmNhdml0eSA9PT0gdW5kZWZpbmVkID8gMiA6IGNvbmNhdml0eSk7XG5cbiAgICAvLyB3aGVuIGEgc2VnbWVudCBnb2VzIGJlbG93IHRoaXMgbGVuZ3RoIHRocmVzaG9sZCwgaXQgd29uJ3QgYmUgZHJpbGxlZCBkb3duIGZ1cnRoZXJcbiAgICBsZW5ndGhUaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgfHwgMDtcblxuICAgIC8vIHN0YXJ0IHdpdGggYSBjb252ZXggaHVsbCBvZiB0aGUgcG9pbnRzXG4gICAgY29uc3QgaHVsbCA9IGZhc3RDb252ZXhIdWxsKHBvaW50cyk7XG5cbiAgICAvLyBpbmRleCB0aGUgcG9pbnRzIHdpdGggYW4gUi10cmVlXG4gICAgY29uc3QgdHJlZSA9IG5ldyBSQnVzaCgxNik7XG4gICAgdHJlZS50b0JCb3ggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluWDogYVswXSxcbiAgICAgICAgICAgIG1pblk6IGFbMV0sXG4gICAgICAgICAgICBtYXhYOiBhWzBdLFxuICAgICAgICAgICAgbWF4WTogYVsxXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdHJlZS5jb21wYXJlTWluWCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfTtcbiAgICB0cmVlLmNvbXBhcmVNaW5ZID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9O1xuXG4gICAgdHJlZS5sb2FkKHBvaW50cyk7XG5cbiAgICAvLyB0dXJuIHRoZSBjb252ZXggaHVsbCBpbnRvIGEgbGlua2VkIGxpc3QgYW5kIHBvcHVsYXRlIHRoZSBpbml0aWFsIGVkZ2UgcXVldWUgd2l0aCB0aGUgbm9kZXNcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGxldCBsYXN0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gaHVsbFtpXTtcbiAgICAgICAgdHJlZS5yZW1vdmUocCk7XG4gICAgICAgIGxhc3QgPSBpbnNlcnROb2RlKHAsIGxhc3QpO1xuICAgICAgICBxdWV1ZS5wdXNoKGxhc3QpO1xuICAgIH1cblxuICAgIC8vIGluZGV4IHRoZSBzZWdtZW50cyB3aXRoIGFuIFItdHJlZSAoZm9yIGludGVyc2VjdGlvbiBjaGVja3MpXG4gICAgY29uc3Qgc2VnVHJlZSA9IG5ldyBSQnVzaCgxNik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykgc2VnVHJlZS5pbnNlcnQodXBkYXRlQkJveChxdWV1ZVtpXSkpO1xuXG4gICAgY29uc3Qgc3FDb25jYXZpdHkgPSBjb25jYXZpdHkgKiBjb25jYXZpdHk7XG4gICAgY29uc3Qgc3FMZW5UaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgKiBsZW5ndGhUaHJlc2hvbGQ7XG5cbiAgICAvLyBwcm9jZXNzIGVkZ2VzIG9uZSBieSBvbmVcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5wO1xuICAgICAgICBjb25zdCBiID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgLy8gc2tpcCB0aGUgZWRnZSBpZiBpdCdzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIGNvbnN0IHNxTGVuID0gZ2V0U3FEaXN0KGEsIGIpO1xuICAgICAgICBpZiAoc3FMZW4gPCBzcUxlblRocmVzaG9sZCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWF4U3FMZW4gPSBzcUxlbiAvIHNxQ29uY2F2aXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3QgY29ubmVjdGlvbiBwb2ludCBmb3IgdGhlIGN1cnJlbnQgZWRnZSB0byBmbGV4IGlud2FyZCB0b1xuICAgICAgICBjb25zdCBwID0gZmluZENhbmRpZGF0ZSh0cmVlLCBub2RlLnByZXYucCwgYSwgYiwgbm9kZS5uZXh0Lm5leHQucCwgbWF4U3FMZW4sIHNlZ1RyZWUpO1xuXG4gICAgICAgIC8vIGlmIHdlIGZvdW5kIGEgY29ubmVjdGlvbiBhbmQgaXQgc2F0aXNmaWVzIG91ciBjb25jYXZpdHkgbWVhc3VyZVxuICAgICAgICBpZiAocCAmJiBNYXRoLm1pbihnZXRTcURpc3QocCwgYSksIGdldFNxRGlzdChwLCBiKSkgPD0gbWF4U3FMZW4pIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3QgdGhlIGVkZ2UgZW5kcG9pbnRzIHRocm91Z2ggdGhpcyBwb2ludCBhbmQgYWRkIDIgbmV3IGVkZ2VzIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaW5zZXJ0Tm9kZShwLCBub2RlKSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb2ludCBhbmQgc2VnbWVudCBpbmRleGVzXG4gICAgICAgICAgICB0cmVlLnJlbW92ZShwKTtcbiAgICAgICAgICAgIHNlZ1RyZWUucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgc2VnVHJlZS5pbnNlcnQodXBkYXRlQkJveChub2RlKSk7XG4gICAgICAgICAgICBzZWdUcmVlLmluc2VydCh1cGRhdGVCQm94KG5vZGUubmV4dCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0aGUgcmVzdWx0aW5nIGh1bGwgbGlua2VkIGxpc3QgdG8gYW4gYXJyYXkgb2YgcG9pbnRzXG4gICAgbGV0IG5vZGUgPSBsYXN0O1xuICAgIGNvbnN0IGNvbmNhdmUgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGNvbmNhdmUucHVzaChub2RlLnApO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IGxhc3QpO1xuXG4gICAgY29uY2F2ZS5wdXNoKG5vZGUucCk7XG5cbiAgICByZXR1cm4gY29uY2F2ZTtcbn1cblxuZnVuY3Rpb24gZmluZENhbmRpZGF0ZSh0cmVlLCBhLCBiLCBjLCBkLCBtYXhEaXN0LCBzZWdUcmVlKSB7XG4gICAgY29uc3QgcXVldWUgPSBuZXcgUXVldWUoW10sIGNvbXBhcmVEaXN0KTtcbiAgICBsZXQgbm9kZSA9IHRyZWUuZGF0YTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBwb2ludCBSLXRyZWUgd2l0aCBhIGRlcHRoLWZpcnN0IHNlYXJjaCB1c2luZyBhIHByaW9yaXR5IHF1ZXVlXG4gICAgLy8gaW4gdGhlIG9yZGVyIG9mIGRpc3RhbmNlIHRvIHRoZSBlZGdlIChiLCBjKVxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gbm9kZS5sZWFmID8gc3FTZWdEaXN0KGNoaWxkLCBiLCBjKSA6IHNxU2VnQm94RGlzdChiLCBjLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA+IG1heERpc3QpIGNvbnRpbnVlOyAvLyBza2lwIHRoZSBub2RlIGlmIGl0J3MgZmFydGhlciB0aGFuIHdlIGV2ZXIgbmVlZFxuXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBkaXN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggJiYgIXF1ZXVlLnBlZWsoKS5ub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBwID0gaXRlbS5ub2RlO1xuXG4gICAgICAgICAgICAvLyBza2lwIGFsbCBwb2ludHMgdGhhdCBhcmUgYXMgY2xvc2UgdG8gYWRqYWNlbnQgZWRnZXMgKGEsYikgYW5kIChjLGQpLFxuICAgICAgICAgICAgLy8gYW5kIHBvaW50cyB0aGF0IHdvdWxkIGludHJvZHVjZSBzZWxmLWludGVyc2VjdGlvbnMgd2hlbiBjb25uZWN0ZWRcbiAgICAgICAgICAgIGNvbnN0IGQwID0gc3FTZWdEaXN0KHAsIGEsIGIpO1xuICAgICAgICAgICAgY29uc3QgZDEgPSBzcVNlZ0Rpc3QocCwgYywgZCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kaXN0IDwgZDAgJiYgaXRlbS5kaXN0IDwgZDEgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYiwgcCwgc2VnVHJlZSkgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYywgcCwgc2VnVHJlZSkpIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAobm9kZSkgbm9kZSA9IG5vZGUubm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURpc3QoYSwgYikge1xuICAgIHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgc2VnbWVudCBib3VuZGluZyBib3ggdG8gdGhlIGdpdmVuIG9uZVxuZnVuY3Rpb24gc3FTZWdCb3hEaXN0KGEsIGIsIGJib3gpIHtcbiAgICBpZiAoaW5zaWRlKGEsIGJib3gpIHx8IGluc2lkZShiLCBiYm94KSkgcmV0dXJuIDA7XG4gICAgY29uc3QgZDEgPSBzcVNlZ1NlZ0Rpc3QoYVswXSwgYVsxXSwgYlswXSwgYlsxXSwgYmJveC5taW5YLCBiYm94Lm1pblksIGJib3gubWF4WCwgYmJveC5taW5ZKTtcbiAgICBpZiAoZDEgPT09IDApIHJldHVybiAwO1xuICAgIGNvbnN0IGQyID0gc3FTZWdTZWdEaXN0KGFbMF0sIGFbMV0sIGJbMF0sIGJbMV0sIGJib3gubWluWCwgYmJveC5taW5ZLCBiYm94Lm1pblgsIGJib3gubWF4WSk7XG4gICAgaWYgKGQyID09PSAwKSByZXR1cm4gMDtcbiAgICBjb25zdCBkMyA9IHNxU2VnU2VnRGlzdChhWzBdLCBhWzFdLCBiWzBdLCBiWzFdLCBiYm94Lm1heFgsIGJib3gubWluWSwgYmJveC5tYXhYLCBiYm94Lm1heFkpO1xuICAgIGlmIChkMyA9PT0gMCkgcmV0dXJuIDA7XG4gICAgY29uc3QgZDQgPSBzcVNlZ1NlZ0Rpc3QoYVswXSwgYVsxXSwgYlswXSwgYlsxXSwgYmJveC5taW5YLCBiYm94Lm1heFksIGJib3gubWF4WCwgYmJveC5tYXhZKTtcbiAgICBpZiAoZDQgPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLm1pbihkMSwgZDIsIGQzLCBkNCk7XG59XG5cbmZ1bmN0aW9uIGluc2lkZShhLCBiYm94KSB7XG4gICAgcmV0dXJuIGFbMF0gPj0gYmJveC5taW5YICYmXG4gICAgICAgICAgIGFbMF0gPD0gYmJveC5tYXhYICYmXG4gICAgICAgICAgIGFbMV0gPj0gYmJveC5taW5ZICYmXG4gICAgICAgICAgIGFbMV0gPD0gYmJveC5tYXhZO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgZWRnZSAoYSxiKSBkb2Vzbid0IGludGVyc2VjdCBhbnkgb3RoZXIgZWRnZXNcbmZ1bmN0aW9uIG5vSW50ZXJzZWN0aW9ucyhhLCBiLCBzZWdUcmVlKSB7XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuXG4gICAgY29uc3QgZWRnZXMgPSBzZWdUcmVlLnNlYXJjaCh7bWluWCwgbWluWSwgbWF4WCwgbWF4WX0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoZWRnZXNbaV0ucCwgZWRnZXNbaV0ubmV4dC5wLCBhLCBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3Jvc3MocDEsIHAyLCBwMykge1xuICAgIHJldHVybiBvcmllbnQyZChwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIGVkZ2VzIChwMSxxMSkgYW5kIChwMixxMikgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgcmV0dXJuIHAxICE9PSBxMiAmJiBxMSAhPT0gcDIgJiZcbiAgICAgICAgY3Jvc3MocDEsIHExLCBwMikgPiAwICE9PSBjcm9zcyhwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgY3Jvc3MocDIsIHEyLCBwMSkgPiAwICE9PSBjcm9zcyhwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIHVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIGEgbm9kZSdzIGVkZ2VcbmZ1bmN0aW9uIHVwZGF0ZUJCb3gobm9kZSkge1xuICAgIGNvbnN0IHAxID0gbm9kZS5wO1xuICAgIGNvbnN0IHAyID0gbm9kZS5uZXh0LnA7XG4gICAgbm9kZS5taW5YID0gTWF0aC5taW4ocDFbMF0sIHAyWzBdKTtcbiAgICBub2RlLm1pblkgPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgIG5vZGUubWF4WCA9IE1hdGgubWF4KHAxWzBdLCBwMlswXSk7XG4gICAgbm9kZS5tYXhZID0gTWF0aC5tYXgocDFbMV0sIHAyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3BlZWQgdXAgY29udmV4IGh1bGwgYnkgZmlsdGVyaW5nIG91dCBwb2ludHMgaW5zaWRlIHF1YWRyaWxhdGVyYWwgZm9ybWVkIGJ5IDQgZXh0cmVtZSBwb2ludHNcbmZ1bmN0aW9uIGZhc3RDb252ZXhIdWxsKHBvaW50cykge1xuICAgIGxldCBsZWZ0ID0gcG9pbnRzWzBdO1xuICAgIGxldCB0b3AgPSBwb2ludHNbMF07XG4gICAgbGV0IHJpZ2h0ID0gcG9pbnRzWzBdO1xuICAgIGxldCBib3R0b20gPSBwb2ludHNbMF07XG5cbiAgICAvLyBmaW5kIHRoZSBsZWZ0bW9zdCwgcmlnaHRtb3N0LCB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgICAgIGlmIChwWzBdIDwgbGVmdFswXSkgbGVmdCA9IHA7XG4gICAgICAgIGlmIChwWzBdID4gcmlnaHRbMF0pIHJpZ2h0ID0gcDtcbiAgICAgICAgaWYgKHBbMV0gPCB0b3BbMV0pIHRvcCA9IHA7XG4gICAgICAgIGlmIChwWzFdID4gYm90dG9tWzFdKSBib3R0b20gPSBwO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgcG9pbnRzIHRoYXQgYXJlIGluc2lkZSB0aGUgcmVzdWx0aW5nIHF1YWRyaWxhdGVyYWxcbiAgICBjb25zdCBjdWxsID0gW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV07XG4gICAgY29uc3QgZmlsdGVyZWQgPSBjdWxsLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFwb2ludEluUG9seWdvbihwb2ludHNbaV0sIGN1bGwpKSBmaWx0ZXJlZC5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGNvbnZleCBodWxsIGFyb3VuZCB0aGUgZmlsdGVyZWQgcG9pbnRzXG4gICAgcmV0dXJuIGNvbnZleEh1bGwoZmlsdGVyZWQpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgbm9kZSBpbiBhIGRvdWJseSBsaW5rZWQgbGlzdFxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwLCBwcmV2KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgcCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgbWluWDogMCxcbiAgICAgICAgbWluWTogMCxcbiAgICAgICAgbWF4WDogMCxcbiAgICAgICAgbWF4WTogMFxuICAgIH07XG5cbiAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IHByZXYubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gcHJldjtcbiAgICAgICAgcHJldi5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBwcmV2Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGdldFNxRGlzdChwMSwgcDIpIHtcblxuICAgIGNvbnN0IGR4ID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgZHkgPSBwMVsxXSAtIHAyWzFdO1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gc3FTZWdEaXN0KHAsIHAxLCBwMikge1xuXG4gICAgbGV0IHggPSBwMVswXSxcbiAgICAgICAgeSA9IHAxWzFdLFxuICAgICAgICBkeCA9IHAyWzBdIC0geCxcbiAgICAgICAgZHkgPSBwMlsxXSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICBjb25zdCB0ID0gKChwWzBdIC0geCkgKiBkeCArIChwWzFdIC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyWzBdO1xuICAgICAgICAgICAgeSA9IHAyWzFdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHBbMF0gLSB4O1xuICAgIGR5ID0gcFsxXSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNlZ21lbnQgdG8gc2VnbWVudCBkaXN0YW5jZSwgcG9ydGVkIGZyb20gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDctX2Rpc3RhbmNlLmh0bWwgYnkgRGFuIFN1bmRheVxuZnVuY3Rpb24gc3FTZWdTZWdEaXN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHV4ID0geDEgLSB4MDtcbiAgICBjb25zdCB1eSA9IHkxIC0geTA7XG4gICAgY29uc3QgdnggPSB4MyAtIHgyO1xuICAgIGNvbnN0IHZ5ID0geTMgLSB5MjtcbiAgICBjb25zdCB3eCA9IHgwIC0geDI7XG4gICAgY29uc3Qgd3kgPSB5MCAtIHkyO1xuICAgIGNvbnN0IGEgPSB1eCAqIHV4ICsgdXkgKiB1eTtcbiAgICBjb25zdCBiID0gdXggKiB2eCArIHV5ICogdnk7XG4gICAgY29uc3QgYyA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgIGNvbnN0IGQgPSB1eCAqIHd4ICsgdXkgKiB3eTtcbiAgICBjb25zdCBlID0gdnggKiB3eCArIHZ5ICogd3k7XG4gICAgY29uc3QgRCA9IGEgKiBjIC0gYiAqIGI7XG5cbiAgICBsZXQgc04sIHROO1xuICAgIGxldCBzRCA9IEQ7XG4gICAgbGV0IHREID0gRDtcblxuICAgIGlmIChEID09PSAwKSB7XG4gICAgICAgIHNOID0gMDtcbiAgICAgICAgc0QgPSAxO1xuICAgICAgICB0TiA9IGU7XG4gICAgICAgIHREID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzTiA9IGIgKiBlIC0gYyAqIGQ7XG4gICAgICAgIHROID0gYSAqIGUgLSBiICogZDtcbiAgICAgICAgaWYgKHNOIDwgMCkge1xuICAgICAgICAgICAgc04gPSAwO1xuICAgICAgICAgICAgdE4gPSBlO1xuICAgICAgICAgICAgdEQgPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKHNOID4gc0QpIHtcbiAgICAgICAgICAgIHNOID0gc0Q7XG4gICAgICAgICAgICB0TiA9IGUgKyBiO1xuICAgICAgICAgICAgdEQgPSBjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHROIDwgMC4wKSB7XG4gICAgICAgIHROID0gMC4wO1xuICAgICAgICBpZiAoLWQgPCAwLjApIHNOID0gMC4wO1xuICAgICAgICBlbHNlIGlmICgtZCA+IGEpIHNOID0gc0Q7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc04gPSAtZDtcbiAgICAgICAgICAgIHNEID0gYTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodE4gPiB0RCkge1xuICAgICAgICB0TiA9IHREO1xuICAgICAgICBpZiAoKC1kICsgYikgPCAwLjApIHNOID0gMDtcbiAgICAgICAgZWxzZSBpZiAoLWQgKyBiID4gYSkgc04gPSBzRDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzTiA9IC1kICsgYjtcbiAgICAgICAgICAgIHNEID0gYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjID0gc04gPT09IDAgPyAwIDogc04gLyBzRDtcbiAgICBjb25zdCB0YyA9IHROID09PSAwID8gMCA6IHROIC8gdEQ7XG5cbiAgICBjb25zdCBjeCA9ICgxIC0gc2MpICogeDAgKyBzYyAqIHgxO1xuICAgIGNvbnN0IGN5ID0gKDEgLSBzYykgKiB5MCArIHNjICogeTE7XG4gICAgY29uc3QgY3gyID0gKDEgLSB0YykgKiB4MiArIHRjICogeDM7XG4gICAgY29uc3QgY3kyID0gKDEgLSB0YykgKiB5MiArIHRjICogeTM7XG4gICAgY29uc3QgZHggPSBjeDIgLSBjeDtcbiAgICBjb25zdCBkeSA9IGN5MiAtIGN5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQnlYKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSA/IGFbMV0gLSBiWzFdIDogYVswXSAtIGJbMF07XG59XG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gICAgcG9pbnRzLnNvcnQoY29tcGFyZUJ5WCk7XG5cbiAgICBjb25zdCBsb3dlciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChsb3dlci5sZW5ndGggPj0gMiAmJiBjcm9zcyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHBvaW50c1tpXSkgPD0gMCkge1xuICAgICAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG93ZXIucHVzaChwb2ludHNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHVwcGVyID0gW107XG4gICAgZm9yIChsZXQgaWkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICB3aGlsZSAodXBwZXIubGVuZ3RoID49IDIgJiYgY3Jvc3ModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2ludHNbaWldKSA8PSAwKSB7XG4gICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB1cHBlci5wdXNoKHBvaW50c1tpaV0pO1xuICAgIH1cblxuICAgIHVwcGVyLnBvcCgpO1xuICAgIGxvd2VyLnBvcCgpO1xuICAgIHJldHVybiBsb3dlci5jb25jYXQodXBwZXIpO1xufVxuIl0sIm5hbWVzIjpbIlJCdXNoIiwiUXVldWUiLCJwb2ludEluUG9seWdvbiIsIm9yaWVudDJkIiwiY29uY2F2ZW1hbiIsInBvaW50cyIsImNvbmNhdml0eSIsImxlbmd0aFRocmVzaG9sZCIsIk1hdGgiLCJtYXgiLCJ1bmRlZmluZWQiLCJodWxsIiwiZmFzdENvbnZleEh1bGwiLCJ0cmVlIiwidG9CQm94IiwiYSIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJjb21wYXJlTWluWCIsImIiLCJjb21wYXJlTWluWSIsImxvYWQiLCJxdWV1ZSIsImxhc3QiLCJpIiwibGVuZ3RoIiwicCIsInJlbW92ZSIsImluc2VydE5vZGUiLCJwdXNoIiwic2VnVHJlZSIsImluc2VydCIsInVwZGF0ZUJCb3giLCJzcUNvbmNhdml0eSIsInNxTGVuVGhyZXNob2xkIiwibm9kZSIsInNoaWZ0IiwibmV4dCIsInNxTGVuIiwiZ2V0U3FEaXN0IiwibWF4U3FMZW4iLCJmaW5kQ2FuZGlkYXRlIiwicHJldiIsIm1pbiIsImNvbmNhdmUiLCJjIiwiZCIsIm1heERpc3QiLCJjb21wYXJlRGlzdCIsImRhdGEiLCJjaGlsZHJlbiIsImNoaWxkIiwiZGlzdCIsImxlYWYiLCJzcVNlZ0Rpc3QiLCJzcVNlZ0JveERpc3QiLCJwZWVrIiwiaXRlbSIsInBvcCIsImQwIiwiZDEiLCJub0ludGVyc2VjdGlvbnMiLCJiYm94IiwiaW5zaWRlIiwic3FTZWdTZWdEaXN0IiwiZDIiLCJkMyIsImQ0IiwiZWRnZXMiLCJzZWFyY2giLCJpbnRlcnNlY3RzIiwiY3Jvc3MiLCJwMSIsInAyIiwicDMiLCJxMSIsInEyIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY3VsbCIsImZpbHRlcmVkIiwic2xpY2UiLCJjb252ZXhIdWxsIiwiZHgiLCJkeSIsIngiLCJ5IiwidCIsIngwIiwieTAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ1eCIsInV5IiwidngiLCJ2eSIsInd4Iiwid3kiLCJlIiwiRCIsInNOIiwidE4iLCJzRCIsInREIiwic2MiLCJ0YyIsImN4IiwiY3kiLCJjeDIiLCJjeTIiLCJjb21wYXJlQnlYIiwic29ydCIsImxvd2VyIiwidXBwZXIiLCJpaSIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/concaveman/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/concaveman/node_modules/quickselect/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/concaveman/node_modules/quickselect/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ quickselect)\n/* harmony export */ });\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */ function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n    while(right > left){\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */ let j = right;\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n        while(i < j){\n            swap(arr, i, j);\n            i++;\n            j--;\n            while(compare(arr[i], t) < 0)i++;\n            while(compare(arr[j], t) > 0)j--;\n        }\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */ function swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */ function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUNBOzs7Ozs7Ozs7O0NBVUMsR0FDYyxTQUFTQSxZQUFZQyxHQUFHLEVBQUVDLENBQUMsRUFBRUMsT0FBTyxDQUFDLEVBQUVDLFFBQVFILElBQUlJLE1BQU0sR0FBRyxDQUFDLEVBQUVDLFVBQVVDLGNBQWM7SUFFbEcsTUFBT0gsUUFBUUQsS0FBTTtRQUNqQixJQUFJQyxRQUFRRCxPQUFPLEtBQUs7WUFDcEIsTUFBTUssSUFBSUosUUFBUUQsT0FBTztZQUN6QixNQUFNTSxJQUFJUCxJQUFJQyxPQUFPO1lBQ3JCLE1BQU1PLElBQUlDLEtBQUtDLEdBQUcsQ0FBQ0o7WUFDbkIsTUFBTUssSUFBSSxNQUFNRixLQUFLRyxHQUFHLENBQUMsSUFBSUosSUFBSTtZQUNqQyxNQUFNSyxLQUFLLE1BQU1KLEtBQUtLLElBQUksQ0FBQ04sSUFBSUcsSUFBS0wsQ0FBQUEsSUFBSUssQ0FBQUEsSUFBS0wsS0FBTUMsQ0FBQUEsSUFBSUQsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJO1lBQ3hFLE1BQU1TLFVBQVVOLEtBQUtPLEdBQUcsQ0FBQ2YsTUFBTVEsS0FBS1EsS0FBSyxDQUFDakIsSUFBSU8sSUFBSUksSUFBSUwsSUFBSU87WUFDMUQsTUFBTUssV0FBV1QsS0FBS1UsR0FBRyxDQUFDakIsT0FBT08sS0FBS1EsS0FBSyxDQUFDakIsSUFBSSxDQUFDTSxJQUFJQyxDQUFBQSxJQUFLSSxJQUFJTCxJQUFJTztZQUNsRWYsWUFBWUMsS0FBS0MsR0FBR2UsU0FBU0csVUFBVWQ7UUFDM0M7UUFFQSxNQUFNZ0IsSUFBSXJCLEdBQUcsQ0FBQ0MsRUFBRTtRQUNoQixJQUFJcUIsSUFBSXBCO1FBQ1IsbUJBQW1CLEdBQ25CLElBQUlxQixJQUFJcEI7UUFFUnFCLEtBQUt4QixLQUFLRSxNQUFNRDtRQUNoQixJQUFJSSxRQUFRTCxHQUFHLENBQUNHLE1BQU0sRUFBRWtCLEtBQUssR0FBR0csS0FBS3hCLEtBQUtFLE1BQU1DO1FBRWhELE1BQU9tQixJQUFJQyxFQUFHO1lBQ1ZDLEtBQUt4QixLQUFLc0IsR0FBR0M7WUFDYkQ7WUFDQUM7WUFDQSxNQUFPbEIsUUFBUUwsR0FBRyxDQUFDc0IsRUFBRSxFQUFFRCxLQUFLLEVBQUdDO1lBQy9CLE1BQU9qQixRQUFRTCxHQUFHLENBQUN1QixFQUFFLEVBQUVGLEtBQUssRUFBR0U7UUFDbkM7UUFFQSxJQUFJbEIsUUFBUUwsR0FBRyxDQUFDRSxLQUFLLEVBQUVtQixPQUFPLEdBQUdHLEtBQUt4QixLQUFLRSxNQUFNcUI7YUFDNUM7WUFDREE7WUFDQUMsS0FBS3hCLEtBQUt1QixHQUFHcEI7UUFDakI7UUFFQSxJQUFJb0IsS0FBS3RCLEdBQUdDLE9BQU9xQixJQUFJO1FBQ3ZCLElBQUl0QixLQUFLc0IsR0FBR3BCLFFBQVFvQixJQUFJO0lBQzVCO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLEtBQUt4QixHQUFHLEVBQUVzQixDQUFDLEVBQUVDLENBQUM7SUFDbkIsTUFBTUUsTUFBTXpCLEdBQUcsQ0FBQ3NCLEVBQUU7SUFDbEJ0QixHQUFHLENBQUNzQixFQUFFLEdBQUd0QixHQUFHLENBQUN1QixFQUFFO0lBQ2Z2QixHQUFHLENBQUN1QixFQUFFLEdBQUdFO0FBQ2I7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNuQixlQUFlb0IsQ0FBQyxFQUFFQyxDQUFDO0lBQ3hCLE9BQU9ELElBQUlDLElBQUksQ0FBQyxJQUFJRCxJQUFJQyxJQUFJLElBQUk7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92My1hcHAvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvaW5kZXguanM/ZDE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogUmVhcnJhbmdlcyBpdGVtcyBzbyB0aGF0IGFsbCBpdGVtcyBpbiB0aGUgW2xlZnQsIGtdIGFyZSB0aGUgc21hbGxlc3QuXG4gKiBUaGUgay10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgKGsgLSBsZWZ0ICsgMSktdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUW119IGFyciB0aGUgYXJyYXkgdG8gcGFydGlhbGx5IHNvcnQgKGluIHBsYWNlKVxuICogQHBhcmFtIHtudW1iZXJ9IGsgbWlkZGxlIGluZGV4IGZvciBwYXJ0aWFsIHNvcnRpbmcgKGFzIGRlZmluZWQgYWJvdmUpXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlZnQ9MF0gbGVmdCBpbmRleCBvZiB0aGUgcmFuZ2UgdG8gc29ydFxuICogQHBhcmFtIHtudW1iZXJ9IFtyaWdodD1hcnIubGVuZ3RoLTFdIHJpZ2h0IGluZGV4XG4gKiBAcGFyYW0geyhhOiBULCBiOiBUKSA9PiBudW1iZXJ9IFtjb21wYXJlID0gKGEsIGIpID0+IGEgLSBiXSBjb21wYXJlIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCA9IDAsIHJpZ2h0ID0gYXJyLmxlbmd0aCAtIDEsIGNvbXBhcmUgPSBkZWZhdWx0Q29tcGFyZSkge1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICBjb25zdCB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICBjb25zdCBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIGNvbnN0IHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ID0gYXJyW2tdO1xuICAgICAgICBsZXQgaSA9IGxlZnQ7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VFtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKiBAcGFyYW0ge251bWJlcn0galxuICovXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIGNvbnN0IHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IGFcbiAqIEBwYXJhbSB7VH0gYlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiJdLCJuYW1lcyI6WyJxdWlja3NlbGVjdCIsImFyciIsImsiLCJsZWZ0IiwicmlnaHQiLCJsZW5ndGgiLCJjb21wYXJlIiwiZGVmYXVsdENvbXBhcmUiLCJuIiwibSIsInoiLCJNYXRoIiwibG9nIiwicyIsImV4cCIsInNkIiwic3FydCIsIm5ld0xlZnQiLCJtYXgiLCJmbG9vciIsIm5ld1JpZ2h0IiwibWluIiwidCIsImkiLCJqIiwic3dhcCIsInRtcCIsImEiLCJiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/concaveman/node_modules/quickselect/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/concaveman/node_modules/rbush/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/concaveman/node_modules/rbush/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RBush)\n/* harmony export */ });\n/* harmony import */ var quickselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quickselect */ \"(ssr)/./node_modules/concaveman/node_modules/quickselect/index.js\");\n\nclass RBush {\n    constructor(maxEntries = 9){\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n    all() {\n        return this._all(this.data, []);\n    }\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n        if (!intersects(bbox, node)) return result;\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n        while(node){\n            for(let i = 0; i < node.children.length; i++){\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n    collides(bbox) {\n        let node = this.data;\n        if (!intersects(bbox, node)) return false;\n        const nodesToSearch = [];\n        while(node){\n            for(let i = 0; i < node.children.length; i++){\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n        return false;\n    }\n    load(data) {\n        if (!(data && data.length)) return this;\n        if (data.length < this._minEntries) {\n            for(let i = 0; i < data.length; i++){\n                this.insert(data[i]);\n            }\n            return this;\n        }\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n        return this;\n    }\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n    remove(item, equalsFn) {\n        if (!item) return this;\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n        // depth-first iterative tree traversal\n        while(node || path.length){\n            if (!node) {\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n            if (node.leaf) {\n                const index = findItem(item, node.children, equalsFn);\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n            if (!goingUp && !node.leaf && contains(node, bbox)) {\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n            } else if (parent) {\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n            } else node = null; // nothing found\n        }\n        return this;\n    }\n    toBBox(item) {\n        return item;\n    }\n    compareMinX(a, b) {\n        return a.minX - b.minX;\n    }\n    compareMinY(a, b) {\n        return a.minY - b.minY;\n    }\n    toJSON() {\n        return this.data;\n    }\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n    _all(node, result) {\n        const nodesToSearch = [];\n        while(node){\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n    _build(items, left, right, height) {\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n        // split the items into M mostly square tiles\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n        multiSelect(items, left, right, N1, this.compareMinX);\n        for(let i = left; i <= right; i += N1){\n            const right2 = Math.min(i + N1 - 1, right);\n            multiSelect(items, i, right2, N2, this.compareMinY);\n            for(let j = i; j <= right2; j += N2){\n                const right3 = Math.min(j + N2 - 1, right2);\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n        calcBBox(node, this.toBBox);\n        return node;\n    }\n    _chooseSubtree(bbox, node, level, path) {\n        while(true){\n            path.push(node);\n            if (node.leaf || path.length - 1 === level) break;\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n            for(let i = 0; i < node.children.length; i++){\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n            node = targetNode || node.children[0];\n        }\n        return node;\n    }\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n        // split on node overflow; propagate upwards if necessary\n        while(level >= 0){\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n        this._chooseSplitAxis(node, m, M);\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([\n            node,\n            newNode\n        ]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n        for(let i = m; i <= M - m; i++){\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n                minArea = area < minArea ? area : minArea;\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n        return index || M - m;\n    }\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n        for(let i = m; i < M - m; i++){\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n        for(let i = M - m - 1; i >= m; i--){\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n        return margin;\n    }\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for(let i = level; i >= 0; i--){\n            extend(path[i], bbox);\n        }\n    }\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for(let i = path.length - 1, siblings; i >= 0; i--){\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n                } else this.clear();\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n    for(let i = 0; i < items.length; i++){\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n    for(let i = k; i < p; i++){\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n    return destNode;\n}\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\nfunction compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n}\nfunction bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n}\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\nfunction intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [\n        left,\n        right\n    ];\n    while(stack.length){\n        right = stack.pop();\n        left = stack.pop();\n        if (right - left <= n) continue;\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        (0,quickselect__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr, mid, left, right, compare);\n        stack.push(left, mid, mid, right);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFdkIsTUFBTUM7SUFDakJDLFlBQVlDLGFBQWEsQ0FBQyxDQUFFO1FBQ3hCLG1GQUFtRjtRQUNuRixJQUFJLENBQUNDLFdBQVcsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUdIO1FBQy9CLElBQUksQ0FBQ0ksV0FBVyxHQUFHRixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0csSUFBSSxDQUFDLElBQUksQ0FBQ0osV0FBVyxHQUFHO1FBQzVELElBQUksQ0FBQ0ssS0FBSztJQUNkO0lBRUFDLE1BQU07UUFDRixPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxFQUFFLEVBQUU7SUFDbEM7SUFFQUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1QsSUFBSUMsT0FBTyxJQUFJLENBQUNILElBQUk7UUFDcEIsTUFBTUksU0FBUyxFQUFFO1FBRWpCLElBQUksQ0FBQ0MsV0FBV0gsTUFBTUMsT0FBTyxPQUFPQztRQUVwQyxNQUFNRSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNQyxnQkFBZ0IsRUFBRTtRQUV4QixNQUFPSixLQUFNO1lBQ1QsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlMLEtBQUtNLFFBQVEsQ0FBQ0MsTUFBTSxFQUFFRixJQUFLO2dCQUMzQyxNQUFNRyxRQUFRUixLQUFLTSxRQUFRLENBQUNELEVBQUU7Z0JBQzlCLE1BQU1JLFlBQVlULEtBQUtVLElBQUksR0FBR1AsT0FBT0ssU0FBU0E7Z0JBRTlDLElBQUlOLFdBQVdILE1BQU1VLFlBQVk7b0JBQzdCLElBQUlULEtBQUtVLElBQUksRUFBRVQsT0FBT1UsSUFBSSxDQUFDSDt5QkFDdEIsSUFBSUksU0FBU2IsTUFBTVUsWUFBWSxJQUFJLENBQUNiLElBQUksQ0FBQ1ksT0FBT1A7eUJBQ2hERyxjQUFjTyxJQUFJLENBQUNI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QUksSUFBSWxFLEVBQUVrRSxJQUFJO0FBQzNCO0FBRUEsU0FBU3BHLFdBQVdrQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsT0FBT0EsRUFBRUMsSUFBSSxJQUFJRixFQUFFaUUsSUFBSSxJQUNoQmhFLEVBQUVHLElBQUksSUFBSUosRUFBRWtFLElBQUksSUFDaEJqRSxFQUFFZ0UsSUFBSSxJQUFJakUsRUFBRUUsSUFBSSxJQUNoQkQsRUFBRWlFLElBQUksSUFBSWxFLEVBQUVJLElBQUk7QUFDM0I7QUFFQSxTQUFTaEIsV0FBV2xCLFFBQVE7SUFDeEIsT0FBTztRQUNIQTtRQUNBYSxRQUFRO1FBQ1JULE1BQU07UUFDTjRCLE1BQU13QjtRQUNOdEIsTUFBTXNCO1FBQ051QyxNQUFNLENBQUN2QztRQUNQd0MsTUFBTSxDQUFDeEM7SUFDWDtBQUNKO0FBRUEseUdBQXlHO0FBQ3pHLHFFQUFxRTtBQUVyRSxTQUFTUixZQUFZaUQsR0FBRyxFQUFFM0QsSUFBSSxFQUFFQyxLQUFLLEVBQUUyRCxDQUFDLEVBQUViLE9BQU87SUFDN0MsTUFBTWMsUUFBUTtRQUFDN0Q7UUFBTUM7S0FBTTtJQUUzQixNQUFPNEQsTUFBTWxHLE1BQU0sQ0FBRTtRQUNqQnNDLFFBQVE0RCxNQUFNNUYsR0FBRztRQUNqQitCLE9BQU82RCxNQUFNNUYsR0FBRztRQUVoQixJQUFJZ0MsUUFBUUQsUUFBUTRELEdBQUc7UUFFdkIsTUFBTUUsTUFBTTlELE9BQU90RCxLQUFLRyxJQUFJLENBQUMsQ0FBQ29ELFFBQVFELElBQUcsSUFBSzRELElBQUksS0FBS0E7UUFDdkR2SCx1REFBV0EsQ0FBQ3NILEtBQUtHLEtBQUs5RCxNQUFNQyxPQUFPOEM7UUFFbkNjLE1BQU05RixJQUFJLENBQUNpQyxNQUFNOEQsS0FBS0EsS0FBSzdEO0lBQy9CO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92My1hcHAvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanM/ZTUwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcXVpY2tzZWxlY3QgZnJvbSAncXVpY2tzZWxlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSQnVzaCB7XG4gICAgY29uc3RydWN0b3IobWF4RW50cmllcyA9IDkpIHtcbiAgICAgICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAgICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMpO1xuICAgICAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cblxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9XG5cbiAgICBzZWFyY2goYmJveCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNvbnN0IHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGNvbGxpZGVzKGJib3gpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3Qgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRoaXMudG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzY3JhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnNlcnQoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgY29uc3QgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgICAgICAgbGV0IGksIHBhcmVudCwgZ29pbmdVcDtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7IC8vIGNoZWNrIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEl0ZW0oaXRlbSwgbm9kZS5jaGlsZHJlbiwgZXF1YWxzRm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZSwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9CQm94KGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH1cblxuICAgIGNvbXBhcmVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuICAgIGNvbXBhcmVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9XG5cbiAgICBmcm9tSlNPTihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9hbGwobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goLi4ubm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX2J1aWxkKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgY29uc3QgTiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgIGxldCBNID0gdGhpcy5fbWF4RW50cmllcztcbiAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIGNvbnN0IE4yID0gTWF0aC5jZWlsKE4gLyBNKTtcbiAgICAgICAgY29uc3QgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIF9jaG9vc2VTdWJ0cmVlKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIGxldCBtaW5BcmVhID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCB0YXJnZXROb2RlO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgX2luc2VydChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBpc05vZGUgPyBpdGVtIDogdGhpcy50b0JCb3goaXRlbSk7XG4gICAgICAgIGNvbnN0IGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXTtcbiAgICAgICAgY29uc3QgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSk7XG4gICAgICAgIG5ld05vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgIG5ld05vZGUubGVhZiA9IG5vZGUubGVhZjtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9XG5cbiAgICBfc3BsaXRSb290KG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW25vZGUsIG5ld05vZGVdKTtcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcbiAgICAgICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfVxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSkge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGxldCBtaW5PdmVybGFwID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBjb25zdCBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleCB8fCBNIC0gbTtcbiAgICB9XG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWDtcbiAgICAgICAgY29uc3QgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZO1xuICAgICAgICBjb25zdCB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCk7XG4gICAgICAgIGNvbnN0IHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH1cblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZSkge1xuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgY29uc3QgdG9CQm94ID0gdGhpcy50b0JCb3g7XG4gICAgICAgIGNvbnN0IGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KTtcbiAgICAgICAgY29uc3QgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCk7XG4gICAgICAgIGxldCBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfVxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbmRlbnNlKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtLCBpdGVtcywgZXF1YWxzRm4pIHtcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKSB7XG4gICAgaWYgKCFkZXN0Tm9kZSkgZGVzdE5vZGUgPSBjcmVhdGVOb2RlKG51bGwpO1xuICAgIGRlc3ROb2RlLm1pblggPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChsZXQgaSA9IGs7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICBjb25zdCBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpO1xuICAgIGNvbnN0IG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSk7XG4gICAgY29uc3QgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKTtcbiAgICBjb25zdCBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbbGVmdCwgcmlnaHRdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInF1aWNrc2VsZWN0IiwiUkJ1c2giLCJjb25zdHJ1Y3RvciIsIm1heEVudHJpZXMiLCJfbWF4RW50cmllcyIsIk1hdGgiLCJtYXgiLCJfbWluRW50cmllcyIsImNlaWwiLCJjbGVhciIsImFsbCIsIl9hbGwiLCJkYXRhIiwic2VhcmNoIiwiYmJveCIsIm5vZGUiLCJyZXN1bHQiLCJpbnRlcnNlY3RzIiwidG9CQm94Iiwibm9kZXNUb1NlYXJjaCIsImkiLCJjaGlsZHJlbiIsImxlbmd0aCIsImNoaWxkIiwiY2hpbGRCQm94IiwibGVhZiIsInB1c2giLCJjb250YWlucyIsInBvcCIsImNvbGxpZGVzIiwibG9hZCIsImluc2VydCIsIl9idWlsZCIsInNsaWNlIiwiaGVpZ2h0IiwiX3NwbGl0Um9vdCIsInRtcE5vZGUiLCJfaW5zZXJ0IiwiaXRlbSIsImNyZWF0ZU5vZGUiLCJyZW1vdmUiLCJlcXVhbHNGbiIsInBhdGgiLCJpbmRleGVzIiwicGFyZW50IiwiZ29pbmdVcCIsImluZGV4IiwiZmluZEl0ZW0iLCJzcGxpY2UiLCJfY29uZGVuc2UiLCJjb21wYXJlTWluWCIsImEiLCJiIiwibWluWCIsImNvbXBhcmVNaW5ZIiwibWluWSIsInRvSlNPTiIsImZyb21KU09OIiwiaXRlbXMiLCJsZWZ0IiwicmlnaHQiLCJOIiwiTSIsImNhbGNCQm94IiwibG9nIiwicG93IiwiTjIiLCJOMSIsInNxcnQiLCJtdWx0aVNlbGVjdCIsInJpZ2h0MiIsIm1pbiIsImoiLCJyaWdodDMiLCJfY2hvb3NlU3VidHJlZSIsImxldmVsIiwibWluQXJlYSIsIkluZmluaXR5IiwibWluRW5sYXJnZW1lbnQiLCJ0YXJnZXROb2RlIiwiYXJlYSIsImJib3hBcmVhIiwiZW5sYXJnZW1lbnQiLCJlbmxhcmdlZEFyZWEiLCJpc05vZGUiLCJpbnNlcnRQYXRoIiwiZXh0ZW5kIiwiX3NwbGl0IiwiX2FkanVzdFBhcmVudEJCb3hlcyIsIm0iLCJfY2hvb3NlU3BsaXRBeGlzIiwic3BsaXRJbmRleCIsIl9jaG9vc2VTcGxpdEluZGV4IiwibmV3Tm9kZSIsIm1pbk92ZXJsYXAiLCJiYm94MSIsImRpc3RCQm94IiwiYmJveDIiLCJvdmVybGFwIiwiaW50ZXJzZWN0aW9uQXJlYSIsImNvbXBhcmVOb2RlTWluWCIsImNvbXBhcmVOb2RlTWluWSIsInhNYXJnaW4iLCJfYWxsRGlzdE1hcmdpbiIsInlNYXJnaW4iLCJzb3J0IiwiY29tcGFyZSIsImxlZnRCQm94IiwicmlnaHRCQm94IiwibWFyZ2luIiwiYmJveE1hcmdpbiIsInNpYmxpbmdzIiwiaW5kZXhPZiIsImsiLCJwIiwiZGVzdE5vZGUiLCJtYXhYIiwibWF4WSIsImFyciIsIm4iLCJzdGFjayIsIm1pZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/concaveman/node_modules/rbush/index.js\n");

/***/ })

};
;