"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iceberg-js";
exports.ids = ["vendor-chunks/iceberg-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n    constructor(message, opts){\n        super(message);\n        this.name = \"IcebergError\";\n        this.status = opts.status;\n        this.icebergType = opts.icebergType;\n        this.icebergCode = opts.icebergCode;\n        this.details = opts.details;\n        this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [\n            500,\n            502,\n            504\n        ].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n    }\n    /**\n   * Returns true if the error is a 404 Not Found error.\n   */ isNotFound() {\n        return this.status === 404;\n    }\n    /**\n   * Returns true if the error is a 409 Conflict error.\n   */ isConflict() {\n        return this.status === 409;\n    }\n    /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */ isAuthenticationTimeout() {\n        return this.status === 419;\n    }\n};\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n    const url = new URL(path, baseUrl);\n    if (query) {\n        for (const [key, value] of Object.entries(query)){\n            if (value !== void 0) {\n                url.searchParams.set(key, value);\n            }\n        }\n    }\n    return url.toString();\n}\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n    if (!auth || auth.type === \"none\") {\n        return {};\n    }\n    if (auth.type === \"bearer\") {\n        return {\n            Authorization: `Bearer ${auth.token}`\n        };\n    }\n    if (auth.type === \"header\") {\n        return {\n            [auth.name]: auth.value\n        };\n    }\n    if (auth.type === \"custom\") {\n        return await auth.getHeaders();\n    }\n    return {};\n}\nfunction createFetchClient(options) {\n    const fetchFn = options.fetchImpl ?? globalThis.fetch;\n    return {\n        async request ({ method, path, query, body, headers }) {\n            const url = buildUrl(options.baseUrl, path, query);\n            const authHeaders = await buildAuthHeaders(options.auth);\n            const res = await fetchFn(url, {\n                method,\n                headers: {\n                    ...body ? {\n                        \"Content-Type\": \"application/json\"\n                    } : {},\n                    ...authHeaders,\n                    ...headers\n                },\n                body: body ? JSON.stringify(body) : void 0\n            });\n            const text = await res.text();\n            const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n            const data = isJson && text ? JSON.parse(text) : text;\n            if (!res.ok) {\n                const errBody = isJson ? data : void 0;\n                const errorDetail = errBody?.error;\n                throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n                    status: res.status,\n                    icebergType: errorDetail?.type,\n                    icebergCode: errorDetail?.code,\n                    details: errBody\n                });\n            }\n            return {\n                status: res.status,\n                headers: res.headers,\n                data\n            };\n        }\n    };\n}\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar NamespaceOperations = class {\n    constructor(client, prefix = \"\"){\n        this.client = client;\n        this.prefix = prefix;\n    }\n    async listNamespaces(parent) {\n        const query = parent ? {\n            parent: namespaceToPath(parent.namespace)\n        } : void 0;\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces`,\n            query\n        });\n        return response.data.namespaces.map((ns)=>({\n                namespace: ns\n            }));\n    }\n    async createNamespace(id, metadata) {\n        const request = {\n            namespace: id.namespace,\n            properties: metadata?.properties\n        };\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces`,\n            body: request\n        });\n        return response.data;\n    }\n    async dropNamespace(id) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n    }\n    async loadNamespaceMetadata(id) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n        });\n        return {\n            properties: response.data.properties\n        };\n    }\n    async namespaceExists(id) {\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createNamespaceIfNotExists(id, metadata) {\n        try {\n            return await this.createNamespace(id, metadata);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return;\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n    return namespace.join(\"\\x1f\");\n}\nvar TableOperations = class {\n    constructor(client, prefix = \"\", accessDelegation){\n        this.client = client;\n        this.prefix = prefix;\n        this.accessDelegation = accessDelegation;\n    }\n    async listTables(namespace) {\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n        });\n        return response.data.identifiers;\n    }\n    async createTable(namespace, request) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n            body: request,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async updateTable(id, request) {\n        const response = await this.client.request({\n            method: \"POST\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            body: request\n        });\n        return {\n            \"metadata-location\": response.data[\"metadata-location\"],\n            metadata: response.data.metadata\n        };\n    }\n    async dropTable(id, options) {\n        await this.client.request({\n            method: \"DELETE\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            query: {\n                purgeRequested: String(options?.purge ?? false)\n            }\n        });\n    }\n    async loadTable(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        const response = await this.client.request({\n            method: \"GET\",\n            path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n            headers\n        });\n        return response.data.metadata;\n    }\n    async tableExists(id) {\n        const headers = {};\n        if (this.accessDelegation) {\n            headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n        }\n        try {\n            await this.client.request({\n                method: \"HEAD\",\n                path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n                headers\n            });\n            return true;\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 404) {\n                return false;\n            }\n            throw error;\n        }\n    }\n    async createTableIfNotExists(namespace, request) {\n        try {\n            return await this.createTable(namespace, request);\n        } catch (error) {\n            if (error instanceof IcebergError && error.status === 409) {\n                return await this.loadTable({\n                    namespace: namespace.namespace,\n                    name: request.name\n                });\n            }\n            throw error;\n        }\n    }\n};\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n    /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */ constructor(options){\n        let prefix = \"v1\";\n        if (options.catalogName) {\n            prefix += `/${options.catalogName}`;\n        }\n        const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n        this.client = createFetchClient({\n            baseUrl,\n            auth: options.auth,\n            fetchImpl: options.fetch\n        });\n        this.accessDelegation = options.accessDelegation?.join(\",\");\n        this.namespaceOps = new NamespaceOperations(this.client, prefix);\n        this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n    }\n    /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */ async listNamespaces(parent) {\n        return this.namespaceOps.listNamespaces(parent);\n    }\n    /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */ async createNamespace(id, metadata) {\n        return this.namespaceOps.createNamespace(id, metadata);\n    }\n    /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */ async dropNamespace(id) {\n        await this.namespaceOps.dropNamespace(id);\n    }\n    /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */ async loadNamespaceMetadata(id) {\n        return this.namespaceOps.loadNamespaceMetadata(id);\n    }\n    /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */ async listTables(namespace) {\n        return this.tableOps.listTables(namespace);\n    }\n    /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTable(namespace, request) {\n        return this.tableOps.createTable(namespace, request);\n    }\n    /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */ async updateTable(id, request) {\n        return this.tableOps.updateTable(id, request);\n    }\n    /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */ async dropTable(id, options) {\n        await this.tableOps.dropTable(id, options);\n    }\n    /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */ async loadTable(id) {\n        return this.tableOps.loadTable(id);\n    }\n    /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */ async namespaceExists(id) {\n        return this.namespaceOps.namespaceExists(id);\n    }\n    /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */ async tableExists(id) {\n        return this.tableOps.tableExists(id);\n    }\n    /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */ async createNamespaceIfNotExists(id, metadata) {\n        return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n    }\n    /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */ async createTableIfNotExists(namespace, request) {\n        return this.tableOps.createTableIfNotExists(namespace, request);\n    }\n};\n// src/catalog/types.ts\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\nfunction parseDecimalType(type) {\n    const match = type.match(DECIMAL_REGEX);\n    if (!match) return null;\n    return {\n        precision: parseInt(match[1], 10),\n        scale: parseInt(match[2], 10)\n    };\n}\nfunction parseFixedType(type) {\n    const match = type.match(FIXED_REGEX);\n    if (!match) return null;\n    return {\n        length: parseInt(match[1], 10)\n    };\n}\nfunction isDecimalType(type) {\n    return DECIMAL_REGEX.test(type);\n}\nfunction isFixedType(type) {\n    return FIXED_REGEX.test(type);\n}\nfunction typesEqual(a, b) {\n    const decimalA = parseDecimalType(a);\n    const decimalB = parseDecimalType(b);\n    if (decimalA && decimalB) {\n        return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\n    }\n    const fixedA = parseFixedType(a);\n    const fixedB = parseFixedType(b);\n    if (fixedA && fixedB) {\n        return fixedA.length === fixedB.length;\n    }\n    return a === b;\n}\nfunction getCurrentSchema(metadata) {\n    return metadata.schemas.find((s)=>s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUM3QixJQUFJQSxlQUFlLGNBQWNDO0lBQy9CQyxZQUFZQyxPQUFPLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBR0YsS0FBS0UsTUFBTTtRQUN6QixJQUFJLENBQUNDLFdBQVcsR0FBR0gsS0FBS0csV0FBVztRQUNuQyxJQUFJLENBQUNDLFdBQVcsR0FBR0osS0FBS0ksV0FBVztRQUNuQyxJQUFJLENBQUNDLE9BQU8sR0FBR0wsS0FBS0ssT0FBTztRQUMzQixJQUFJLENBQUNDLG9CQUFvQixHQUFHTixLQUFLRyxXQUFXLEtBQUssaUNBQWlDO1lBQUM7WUFBSztZQUFLO1NBQUksQ0FBQ0ksUUFBUSxDQUFDUCxLQUFLRSxNQUFNLEtBQUtGLEtBQUtHLFdBQVcsRUFBRUksU0FBUyxtQkFBbUI7SUFDM0s7SUFDQTs7R0FFQyxHQUNEQyxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNOLE1BQU0sS0FBSztJQUN6QjtJQUNBOztHQUVDLEdBQ0RPLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQ1AsTUFBTSxLQUFLO0lBQ3pCO0lBQ0E7O0dBRUMsR0FDRFEsMEJBQTBCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDUixNQUFNLEtBQUs7SUFDekI7QUFDRjtBQUVBLG1CQUFtQjtBQUNuQixTQUFTUyxTQUFTQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsS0FBSztJQUNwQyxNQUFNQyxNQUFNLElBQUlDLElBQUlILE1BQU1EO0lBQzFCLElBQUlFLE9BQU87UUFDVCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNOLE9BQVE7WUFDaEQsSUFBSUksVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCSCxJQUFJTSxZQUFZ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O0lBQzFCLE1BQU1zRSxRQUFRdEUsS0FBS3NFLEtBQUssQ0FBQ0Y7SUFDekIsSUFBSSxDQUFDRSxPQUFPLE9BQU87SUFDbkIsT0FBTztRQUNMSyxRQUFRSCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTTSxjQUFjNUUsSUFBSTtJQUN6QixPQUFPbUUsY0FBY1UsSUFBSSxDQUFDN0U7QUFDNUI7QUFDQSxTQUFTOEUsWUFBWTlFLElBQUk7SUFDdkIsT0FBT29FLFlBQVlTLElBQUksQ0FBQzdFO0FBQzFCO0FBQ0EsU0FBUytFLFdBQVdDLENBQUMsRUFBRUMsQ0FBQztJQUN0QixNQUFNQyxXQUFXYixpQkFBaUJXO0lBQ2xDLE1BQU1HLFdBQVdkLGlCQUFpQlk7SUFDbEMsSUFBSUMsWUFBWUMsVUFBVTtRQUN4QixPQUFPRCxTQUFTWCxTQUFTLEtBQUtZLFNBQVNaLFNBQVMsSUFBSVcsU0FBU1QsS0FBSyxLQUFLVSxTQUFTVixLQUFLO0lBQ3ZGO0lBQ0EsTUFBTVcsU0FBU1YsZUFBZU07SUFDOUIsTUFBTUssU0FBU1gsZUFBZU87SUFDOUIsSUFBSUcsVUFBVUMsUUFBUTtRQUNwQixPQUFPRCxPQUFPVCxNQUFNLEtBQUtVLE9BQU9WLE1BQU07SUFDeEM7SUFDQSxPQUFPSyxNQUFNQztBQUNmO0FBQ0EsU0FBU0ssaUJBQWlCNUMsUUFBUTtJQUNoQyxPQUFPQSxTQUFTNkMsT0FBTyxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsQ0FBQyxDQUFDLFlBQVksS0FBSy9DLFFBQVEsQ0FBQyxvQkFBb0I7QUFDdEY7QUFFd0ksQ0FDeEksa0NBQWtDO0NBQ2xDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3YzLWFwcC8uL25vZGVfbW9kdWxlcy9pY2ViZXJnLWpzL2Rpc3QvaW5kZXgubWpzP2ZjYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9JY2ViZXJnRXJyb3IudHNcbnZhciBJY2ViZXJnRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0cykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiSWNlYmVyZ0Vycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRzLnN0YXR1cztcbiAgICB0aGlzLmljZWJlcmdUeXBlID0gb3B0cy5pY2ViZXJnVHlwZTtcbiAgICB0aGlzLmljZWJlcmdDb2RlID0gb3B0cy5pY2ViZXJnQ29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRzLmRldGFpbHM7XG4gICAgdGhpcy5pc0NvbW1pdFN0YXRlVW5rbm93biA9IG9wdHMuaWNlYmVyZ1R5cGUgPT09IFwiQ29tbWl0U3RhdGVVbmtub3duRXhjZXB0aW9uXCIgfHwgWzUwMCwgNTAyLCA1MDRdLmluY2x1ZGVzKG9wdHMuc3RhdHVzKSAmJiBvcHRzLmljZWJlcmdUeXBlPy5pbmNsdWRlcyhcIkNvbW1pdFN0YXRlXCIpID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDA0IE5vdCBGb3VuZCBlcnJvci5cbiAgICovXG4gIGlzTm90Rm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MDQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDkgQ29uZmxpY3QgZXJyb3IuXG4gICAqL1xuICBpc0NvbmZsaWN0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDA5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVycm9yIGlzIGEgNDE5IEF1dGhlbnRpY2F0aW9uIFRpbWVvdXQgZXJyb3IuXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0aW9uVGltZW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQxOTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3VybC50c1xuZnVuY3Rpb24gYnVpbGRVcmwoYmFzZVVybCwgcGF0aCwgcXVlcnkpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXRoLCBiYXNlVXJsKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuXG4vLyBzcmMvaHR0cC9jcmVhdGVGZXRjaENsaWVudC50c1xuYXN5bmMgZnVuY3Rpb24gYnVpbGRBdXRoSGVhZGVycyhhdXRoKSB7XG4gIGlmICghYXV0aCB8fCBhdXRoLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChhdXRoLnR5cGUgPT09IFwiYmVhcmVyXCIpIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJoZWFkZXJcIikge1xuICAgIHJldHVybiB7IFthdXRoLm5hbWVdOiBhdXRoLnZhbHVlIH07XG4gIH1cbiAgaWYgKGF1dGgudHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgIHJldHVybiBhd2FpdCBhdXRoLmdldEhlYWRlcnMoKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENsaWVudChvcHRpb25zKSB7XG4gIGNvbnN0IGZldGNoRm4gPSBvcHRpb25zLmZldGNoSW1wbCA/PyBnbG9iYWxUaGlzLmZldGNoO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIHJlcXVlc3Qoe1xuICAgICAgbWV0aG9kLFxuICAgICAgcGF0aCxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnNcbiAgICB9KSB7XG4gICAgICBjb25zdCB1cmwgPSBidWlsZFVybChvcHRpb25zLmJhc2VVcmwsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgYnVpbGRBdXRoSGVhZGVycyhvcHRpb25zLmF1dGgpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2hGbih1cmwsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uYm9keSA/IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSA6IHt9LFxuICAgICAgICAgIC4uLmF1dGhIZWFkZXJzLFxuICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgY29uc3QgaXNKc29uID0gKHJlcy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiKS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBkYXRhID0gaXNKc29uICYmIHRleHQgPyBKU09OLnBhcnNlKHRleHQpIDogdGV4dDtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IGVyckJvZHkgPSBpc0pzb24gPyBkYXRhIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbCA9IGVyckJvZHk/LmVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgSWNlYmVyZ0Vycm9yKFxuICAgICAgICAgIGVycm9yRGV0YWlsPy5tZXNzYWdlID8/IGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBpY2ViZXJnVHlwZTogZXJyb3JEZXRhaWw/LnR5cGUsXG4gICAgICAgICAgICBpY2ViZXJnQ29kZTogZXJyb3JEZXRhaWw/LmNvZGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJCb2R5XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBoZWFkZXJzOiByZXMuaGVhZGVycywgZGF0YSB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2NhdGFsb2cvbmFtZXNwYWNlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoKG5hbWVzcGFjZSkge1xuICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oXCJcdTAwMWZcIik7XG59XG52YXIgTmFtZXNwYWNlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cbiAgYXN5bmMgbGlzdE5hbWVzcGFjZXMocGFyZW50KSB7XG4gICAgY29uc3QgcXVlcnkgPSBwYXJlbnQgPyB7IHBhcmVudDogbmFtZXNwYWNlVG9QYXRoKHBhcmVudC5uYW1lc3BhY2UpIH0gOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcbiAgICAgIHF1ZXJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubmFtZXNwYWNlcy5tYXAoKG5zKSA9PiAoeyBuYW1lc3BhY2U6IG5zIH0pKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2UoaWQsIG1ldGFkYXRhKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIG5hbWVzcGFjZTogaWQubmFtZXNwYWNlLFxuICAgICAgcHJvcGVydGllczogbWV0YWRhdGE/LnByb3BlcnRpZXNcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXNgLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIGRyb3BOYW1lc3BhY2UoaWQpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydGllczogcmVzcG9uc2UuZGF0YS5wcm9wZXJ0aWVzXG4gICAgfTtcbiAgfVxuICBhc3luYyBuYW1lc3BhY2VFeGlzdHMoaWQpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCIsXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEljZWJlcmdFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL3RhYmxlcy50c1xuZnVuY3Rpb24gbmFtZXNwYWNlVG9QYXRoMihuYW1lc3BhY2UpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZS5qb2luKFwiXHUwMDFmXCIpO1xufVxudmFyIFRhYmxlT3BlcmF0aW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiLCBhY2Nlc3NEZWxlZ2F0aW9uKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uID0gYWNjZXNzRGVsZWdhdGlvbjtcbiAgfVxuICBhc3luYyBsaXN0VGFibGVzKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2BcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZGVudGlmaWVycztcbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuYWNjZXNzRGVsZWdhdGlvbikge1xuICAgICAgaGVhZGVyc1tcIlgtSWNlYmVyZy1BY2Nlc3MtRGVsZWdhdGlvblwiXSA9IHRoaXMuYWNjZXNzRGVsZWdhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2AsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgYm9keTogcmVxdWVzdFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBcIm1ldGFkYXRhLWxvY2F0aW9uXCI6IHJlc3BvbnNlLmRhdGFbXCJtZXRhZGF0YS1sb2NhdGlvblwiXSxcbiAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5kYXRhLm1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBhc3luYyBkcm9wVGFibGUoaWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXG4gICAgICBxdWVyeTogeyBwdXJnZVJlcXVlc3RlZDogU3RyaW5nKG9wdGlvbnM/LnB1cmdlID8/IGZhbHNlKSB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9hZFRhYmxlKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1ldGFkYXRhO1xuICB9XG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLmFjY2Vzc0RlbGVnYXRpb24pIHtcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIixcbiAgICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgyKGlkLm5hbWVzcGFjZSl9L3RhYmxlcy8ke2lkLm5hbWV9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UubmFtZXNwYWNlLCBuYW1lOiByZXF1ZXN0Lm5hbWUgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jYXRhbG9nL0ljZWJlcmdSZXN0Q2F0YWxvZy50c1xudmFyIEljZWJlcmdSZXN0Q2F0YWxvZyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSWNlYmVyZyBSRVNUIENhdGFsb2cgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNhdGFsb2cgY2xpZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHByZWZpeCA9IFwidjFcIjtcbiAgICBpZiAob3B0aW9ucy5jYXRhbG9nTmFtZSkge1xuICAgICAgcHJlZml4ICs9IGAvJHtvcHRpb25zLmNhdGFsb2dOYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpID8gb3B0aW9ucy5iYXNlVXJsIDogYCR7b3B0aW9ucy5iYXNlVXJsfS9gO1xuICAgIHRoaXMuY2xpZW50ID0gY3JlYXRlRmV0Y2hDbGllbnQoe1xuICAgICAgYmFzZVVybCxcbiAgICAgIGF1dGg6IG9wdGlvbnMuYXV0aCxcbiAgICAgIGZldGNoSW1wbDogb3B0aW9ucy5mZXRjaFxuICAgIH0pO1xuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IG9wdGlvbnMuYWNjZXNzRGVsZWdhdGlvbj8uam9pbihcIixcIik7XG4gICAgdGhpcy5uYW1lc3BhY2VPcHMgPSBuZXcgTmFtZXNwYWNlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4KTtcbiAgICB0aGlzLnRhYmxlT3BzID0gbmV3IFRhYmxlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4LCB0aGlzLmFjY2Vzc0RlbGVnYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgbmFtZXNwYWNlcyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCAtIE9wdGlvbmFsIHBhcmVudCBuYW1lc3BhY2UgdG8gbGlzdCBjaGlsZHJlbiB1bmRlclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBuYW1lc3BhY2UgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBMaXN0IGFsbCB0b3AtbGV2ZWwgbmFtZXNwYWNlc1xuICAgKiBjb25zdCBuYW1lc3BhY2VzID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpO1xuICAgKlxuICAgKiAvLyBMaXN0IG5hbWVzcGFjZXMgdW5kZXIgYSBwYXJlbnRcbiAgICogY29uc3QgY2hpbGRyZW4gPSBhd2FpdCBjYXRhbG9nLmxpc3ROYW1lc3BhY2VzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3ROYW1lc3BhY2VzKHBhcmVudCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5saXN0TmFtZXNwYWNlcyhwYXJlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG5hbWVzcGFjZSBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcbiAgICogQHJldHVybnMgUmVzcG9uc2UgY29udGFpbmluZyB0aGUgY3JlYXRlZCBuYW1lc3BhY2UgYW5kIGl0cyBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZU5hbWVzcGFjZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLm5hbWVzcGFjZSk7IC8vIFsnYW5hbHl0aWNzJ11cbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UucHJvcGVydGllcyk7IC8vIHsgb3duZXI6ICdkYXRhLXRlYW0nLCAuLi4gfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgbmFtZXNwYWNlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIFRoZSBuYW1lc3BhY2UgbXVzdCBiZSBlbXB0eSAoY29udGFpbiBubyB0YWJsZXMpIGJlZm9yZSBpdCBjYW4gYmUgZHJvcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gZHJvcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGF3YWl0IGNhdGFsb2cuZHJvcE5hbWVzcGFjZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBkcm9wTmFtZXNwYWNlKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5uYW1lc3BhY2VPcHMuZHJvcE5hbWVzcGFjZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG1ldGFkYXRhIGZvciBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBOYW1lc3BhY2UgbWV0YWRhdGEgaW5jbHVkaW5nIHByb3BlcnRpZXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZE5hbWVzcGFjZU1ldGFkYXRhKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhtZXRhZGF0YS5wcm9wZXJ0aWVzKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBsb2FkTmFtZXNwYWNlTWV0YWRhdGEoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMubG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgYWxsIHRhYmxlcyBpbiBhIG5hbWVzcGFjZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGxpc3QgdGFibGVzIGZyb21cbiAgICogQHJldHVybnMgQXJyYXkgb2YgdGFibGUgaWRlbnRpZmllcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCB0YWJsZXMgPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XG4gICAqIGNvbnNvbGUubG9nKHRhYmxlcyk7IC8vIFt7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSwgLi4uXVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxpc3RUYWJsZXMobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMubGlzdFRhYmxlcyhuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRhYmxlIGluIHRoZSBjYXRhbG9nLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFibGUgaW5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCB0YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHtcbiAgICogICAgIG5hbWU6ICdldmVudHMnLFxuICAgKiAgICAgc2NoZW1hOiB7XG4gICAqICAgICAgIHR5cGU6ICdzdHJ1Y3QnLFxuICAgKiAgICAgICBmaWVsZHM6IFtcbiAgICogICAgICAgICB7IGlkOiAxLCBuYW1lOiAnaWQnLCB0eXBlOiAnbG9uZycsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAqICAgICAgICAgeyBpZDogMiwgbmFtZTogJ3RpbWVzdGFtcCcsIHR5cGU6ICd0aW1lc3RhbXAnLCByZXF1aXJlZDogdHJ1ZSB9XG4gICAqICAgICAgIF0sXG4gICAqICAgICAgICdzY2hlbWEtaWQnOiAwXG4gICAqICAgICB9LFxuICAgKiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuICAgKiAgICAgICAnc3BlYy1pZCc6IDAsXG4gICAqICAgICAgIGZpZWxkczogW1xuICAgKiAgICAgICAgIHsgc291cmNlX2lkOiAyLCBmaWVsZF9pZDogMTAwMCwgbmFtZTogJ3RzX2RheScsIHRyYW5zZm9ybTogJ2RheScgfVxuICAgKiAgICAgICBdXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGFibGUncyBtZXRhZGF0YS5cbiAgICpcbiAgICogQ2FuIHVwZGF0ZSB0aGUgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgb3IgcHJvcGVydGllcyBvZiBhIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFVwZGF0ZSByZXF1ZXN0IHdpdGggZmllbGRzIHRvIG1vZGlmeVxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBsb2NhdGlvbiBhbmQgdXBkYXRlZCB0YWJsZSBtZXRhZGF0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy51cGRhdGVUYWJsZShcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSxcbiAgICogICB7XG4gICAqICAgICBwcm9wZXJ0aWVzOiB7ICdyZWFkLnNwbGl0LnRhcmdldC1zaXplJzogJzEzNDIxNzcyOCcgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2VbJ21ldGFkYXRhLWxvY2F0aW9uJ10pOyAvLyBzMzovLy4uLlxuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5tZXRhZGF0YSk7IC8vIFRhYmxlTWV0YWRhdGEgb2JqZWN0XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVGFibGUoaWQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy51cGRhdGVUYWJsZShpZCwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGEgdGFibGUgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBkcm9wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGRyb3BUYWJsZShpZCwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMudGFibGVPcHMuZHJvcFRhYmxlKGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogTG9hZHMgbWV0YWRhdGEgZm9yIGEgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gbG9hZFxuICAgKiBAcmV0dXJucyBUYWJsZSBtZXRhZGF0YSBpbmNsdWRpbmcgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgbG9jYXRpb24sIGV0Yy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9KTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEuc2NoZW1hKTtcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEubG9jYXRpb24pO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGxvYWRUYWJsZShpZCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxvYWRUYWJsZShpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG5hbWVzcGFjZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5hbWVzcGFjZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cubmFtZXNwYWNlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgbmFtZXNwYWNlRXhpc3RzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLm5hbWVzcGFjZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHRhYmxlIGV4aXN0cyBpbiB0aGUgY2F0YWxvZy5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGFibGUgaWRlbnRpZmllciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0YWJsZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cudGFibGVFeGlzdHMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xuICAgKiBjb25zb2xlLmxvZyhleGlzdHMpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgdGFibGVFeGlzdHMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy50YWJsZUV4aXN0cyhpZCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuYW1lc3BhY2UgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIElmIHRoZSBuYW1lc3BhY2UgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgdm9pZC4gSWYgY3JlYXRlZCwgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBPcHRpb25hbCBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgbmFtZXNwYWNlXG4gICAqIEByZXR1cm5zIFJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGNyZWF0ZWQgbmFtZXNwYWNlIGFuZCBpdHMgcHJvcGVydGllcywgb3Igdm9pZCBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxuICAgKiAgIHsgcHJvcGVydGllczogeyBvd25lcjogJ2RhdGEtdGVhbScgfSB9XG4gICAqICk7XG4gICAqIGlmIChyZXNwb25zZSkge1xuICAgKiAgIGNvbnNvbGUubG9nKCdDcmVhdGVkOicsIHJlc3BvbnNlLm5hbWVzcGFjZSk7XG4gICAqIH0gZWxzZSB7XG4gICAqICAgY29uc29sZS5sb2coJ0FscmVhZHkgZXhpc3RzJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhYmxlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBJZiB0aGUgdGFibGUgYWxyZWFkeSBleGlzdHMsIHJldHVybnMgaXRzIG1ldGFkYXRhIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgdG8gY3JlYXRlIHRoZSB0YWJsZSBpblxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRhYmxlIGNyZWF0aW9uIHJlcXVlc3QgaW5jbHVkaW5nIG5hbWUsIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIGV0Yy5cbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgZm9yIHRoZSBjcmVhdGVkIG9yIGV4aXN0aW5nIHRhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMoXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcbiAgICogICB7XG4gICAqICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICogICAgIHNjaGVtYToge1xuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcbiAgICogICAgICAgZmllbGRzOiBbXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBjcmVhdGVUYWJsZUlmTm90RXhpc3RzKG5hbWVzcGFjZSwgcmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KTtcbiAgfVxufTtcblxuLy8gc3JjL2NhdGFsb2cvdHlwZXMudHNcbnZhciBERUNJTUFMX1JFR0VYID0gL15kZWNpbWFsXFxzKlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpJC87XG52YXIgRklYRURfUkVHRVggPSAvXmZpeGVkXFxzKlxcW1xccyooXFxkKylcXHMqXFxdJC87XG5mdW5jdGlvbiBwYXJzZURlY2ltYWxUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKERFQ0lNQUxfUkVHRVgpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBwcmVjaXNpb246IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgc2NhbGU6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRml4ZWRUeXBlKHR5cGUpIHtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKEZJWEVEX1JFR0VYKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiBwYXJzZUludChtYXRjaFsxXSwgMTApXG4gIH07XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIERFQ0lNQUxfUkVHRVgudGVzdCh0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIEZJWEVEX1JFR0VYLnRlc3QodHlwZSk7XG59XG5mdW5jdGlvbiB0eXBlc0VxdWFsKGEsIGIpIHtcbiAgY29uc3QgZGVjaW1hbEEgPSBwYXJzZURlY2ltYWxUeXBlKGEpO1xuICBjb25zdCBkZWNpbWFsQiA9IHBhcnNlRGVjaW1hbFR5cGUoYik7XG4gIGlmIChkZWNpbWFsQSAmJiBkZWNpbWFsQikge1xuICAgIHJldHVybiBkZWNpbWFsQS5wcmVjaXNpb24gPT09IGRlY2ltYWxCLnByZWNpc2lvbiAmJiBkZWNpbWFsQS5zY2FsZSA9PT0gZGVjaW1hbEIuc2NhbGU7XG4gIH1cbiAgY29uc3QgZml4ZWRBID0gcGFyc2VGaXhlZFR5cGUoYSk7XG4gIGNvbnN0IGZpeGVkQiA9IHBhcnNlRml4ZWRUeXBlKGIpO1xuICBpZiAoZml4ZWRBICYmIGZpeGVkQikge1xuICAgIHJldHVybiBmaXhlZEEubGVuZ3RoID09PSBmaXhlZEIubGVuZ3RoO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjaGVtYShtZXRhZGF0YSkge1xuICByZXR1cm4gbWV0YWRhdGEuc2NoZW1hcy5maW5kKChzKSA9PiBzW1wic2NoZW1hLWlkXCJdID09PSBtZXRhZGF0YVtcImN1cnJlbnQtc2NoZW1hLWlkXCJdKTtcbn1cblxuZXhwb3J0IHsgSWNlYmVyZ0Vycm9yLCBJY2ViZXJnUmVzdENhdGFsb2csIGdldEN1cnJlbnRTY2hlbWEsIGlzRGVjaW1hbFR5cGUsIGlzRml4ZWRUeXBlLCBwYXJzZURlY2ltYWxUeXBlLCBwYXJzZUZpeGVkVHlwZSwgdHlwZXNFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJJY2ViZXJnRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdHMiLCJuYW1lIiwic3RhdHVzIiwiaWNlYmVyZ1R5cGUiLCJpY2ViZXJnQ29kZSIsImRldGFpbHMiLCJpc0NvbW1pdFN0YXRlVW5rbm93biIsImluY2x1ZGVzIiwiaXNOb3RGb3VuZCIsImlzQ29uZmxpY3QiLCJpc0F1dGhlbnRpY2F0aW9uVGltZW91dCIsImJ1aWxkVXJsIiwiYmFzZVVybCIsInBhdGgiLCJxdWVyeSIsInVybCIsIlVSTCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiYnVpbGRBdXRoSGVhZGVycyIsImF1dGgiLCJ0eXBlIiwiQXV0aG9yaXphdGlvbiIsInRva2VuIiwiZ2V0SGVhZGVycyIsImNyZWF0ZUZldGNoQ2xpZW50Iiwib3B0aW9ucyIsImZldGNoRm4iLCJmZXRjaEltcGwiLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJyZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJhdXRoSGVhZGVycyIsInJlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0ZXh0IiwiaXNKc29uIiwiZ2V0IiwiZGF0YSIsInBhcnNlIiwib2siLCJlcnJCb2R5IiwiZXJyb3JEZXRhaWwiLCJlcnJvciIsImNvZGUiLCJuYW1lc3BhY2VUb1BhdGgiLCJuYW1lc3BhY2UiLCJqb2luIiwiTmFtZXNwYWNlT3BlcmF0aW9ucyIsImNsaWVudCIsInByZWZpeCIsImxpc3ROYW1lc3BhY2VzIiwicGFyZW50IiwicmVzcG9uc2UiLCJuYW1lc3BhY2VzIiwibWFwIiwibnMiLCJjcmVhdGVOYW1lc3BhY2UiLCJpZCIsIm1ldGFkYXRhIiwicHJvcGVydGllcyIsImRyb3BOYW1lc3BhY2UiLCJsb2FkTmFtZXNwYWNlTWV0YWRhdGEiLCJuYW1lc3BhY2VFeGlzdHMiLCJjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyIsIm5hbWVzcGFjZVRvUGF0aDIiLCJUYWJsZU9wZXJhdGlvbnMiLCJhY2Nlc3NEZWxlZ2F0aW9uIiwibGlzdFRhYmxlcyIsImlkZW50aWZpZXJzIiwiY3JlYXRlVGFibGUiLCJ1cGRhdGVUYWJsZSIsImRyb3BUYWJsZSIsInB1cmdlUmVxdWVzdGVkIiwiU3RyaW5nIiwicHVyZ2UiLCJsb2FkVGFibGUiLCJ0YWJsZUV4aXN0cyIsImNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMiLCJJY2ViZXJnUmVzdENhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImVuZHNXaXRoIiwibmFtZXNwYWNlT3BzIiwidGFibGVPcHMiLCJERUNJTUFMX1JFR0VYIiwiRklYRURfUkVHRVgiLCJwYXJzZURlY2ltYWxUeXBlIiwibWF0Y2giLCJwcmVjaXNpb24iLCJwYXJzZUludCIsInNjYWxlIiwicGFyc2VGaXhlZFR5cGUiLCJsZW5ndGgiLCJpc0RlY2ltYWxUeXBlIiwidGVzdCIsImlzRml4ZWRUeXBlIiwidHlwZXNFcXVhbCIsImEiLCJiIiwiZGVjaW1hbEEiLCJkZWNpbWFsQiIsImZpeGVkQSIsImZpeGVkQiIsImdldEN1cnJlbnRTY2hlbWEiLCJzY2hlbWFzIiwiZmluZCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/iceberg-js/dist/index.mjs\n");

/***/ })

};
;