"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/earcut";
exports.ids = ["vendor-chunks/earcut"];
exports.modules = {

/***/ "(ssr)/./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\nfunction earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === signedArea(data, start, end, dim) > 0) {\n        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);\n    }\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else {\n            p = p.next;\n        }\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n    queue.sort(compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++){\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n    return outerNode;\n}\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n    var bridgeReverse = splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for(var i = 0, len = holeIndices.length; i < len; i++){\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++){\n            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkYseUJBQXNCLEdBQUdFO0FBRXpCLFNBQVNBLE9BQU9FLElBQUksRUFBRUMsV0FBVyxFQUFFQyxHQUFHO0lBRWxDQSxNQUFNQSxPQUFPO0lBRWIsSUFBSUMsV0FBV0YsZUFBZUEsWUFBWUcsTUFBTSxFQUM1Q0MsV0FBV0YsV0FBV0YsV0FBVyxDQUFDLEVBQUUsR0FBR0MsTUFBTUYsS0FBS0ksTUFBTSxFQUN4REUsWUFBWUMsV0FBV1AsTUFBTSxHQUFHSyxVQUFVSCxLQUFLLE9BQy9DTSxZQUFZLEVBQUU7SUFFbEIsSUFBSSxDQUFDRixhQUFhQSxVQUFVRyxJQUFJLEtBQUtILFVBQVVJLElBQUksRUFBRSxPQUFPRjtJQUU1RCxJQUFJRyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxHQUFHQyxHQUFHQztJQUVsQyxJQUFJZCxVQUFVRyxZQUFZWSxlQUFlbEIsTUFBTUMsYUFBYUssV0FBV0o7SUFFdkUsNkZBQTZGO0lBQzdGLElBQUlGLEtBQUtJLE1BQU0sR0FBRyxLQUFLRixLQUFLO1FBQ3hCUyxPQUFPRSxPQUFPYixJQUFJLENBQUMsRUFBRTtRQUNyQlksT0FBT0UsT0FBT2QsSUFBSSxDQUFDLEVBQUU7UUFFckIsSUFBSyxJQUFJbUIsSUFBSWpCLEtBQUtpQixJQUFJZCxVQUFVYyxLQUFLakIsSUFBSztZQUN0Q2EsSUFBSWYsSUFBSSxDQUFDbUIsRUFBRTtZQUNYSCxJQUFJaEIsSUFBSSxDQUFDbUIsSUFBSSxFQUFFO1lBQ2YsSUFBSUosSUFBSUosTUFBTUEsT0FBT0k7WUFDckIsSUFBSUMsSUFBSUosTUFBTUEsT0FBT0k7WUFDckIsSUFBSUQsSUFBSUYsTUFBTUEsT0FBT0U7WUFDckIsSUFBSUMsSUFBSUYsTUFBTUEsT0FBT0U7UUFDekI7UUFFQSxrR0FBa0c7UUFDbEdDLFVBQVVHLEtBQUtDLEdBQUcsQ0FB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Q3BFO1FBQ0EsSUFBSXBILElBQUksR0FBRztZQUNQbUgsYUFBYXRJLElBQUksQ0FBQ21CLElBQUksRUFBRSxDQUFDZixNQUFNO1lBQy9COEgsT0FBT0UsS0FBSyxDQUFDMUYsSUFBSSxDQUFDNEY7UUFDdEI7SUFDSjtJQUNBLE9BQU9KO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92My1hcHAvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanM/NzMzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICB2YXIgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIHZhciBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgeDAgPSBheCA8IGJ4ID8gKGF4IDwgY3ggPyBheCA6IGN4KSA6IChieCA8IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkwID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICB4MSA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTEgPSBheSA+IGJ5ID8gKGF5ID4gY3kgPyBheSA6IGN5KSA6IChieSA+IGN5ID8gYnkgOiBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKHgwLCB5MCwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIoeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBwID0gZWFyLnByZXZaLFxuICAgICAgICBuID0gZWFyLm5leHRaO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGJyaWRnZVJldmVyc2UgPSBzcGxpdFBvbHlnb24oYnJpZGdlLCBob2xlKTtcblxuICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgIGZpbHRlclBvaW50cyhicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQpO1xuICAgIHJldHVybiBmaWx0ZXJQb2ludHMoYnJpZGdlLCBicmlkZ2UubmV4dCk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG07XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiZcbiAgICAgICAgICAgICAgICAodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IChwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICAgIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IDApIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSAwO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZWFyY3V0IiwiZGVmYXVsdCIsImRhdGEiLCJob2xlSW5kaWNlcyIsImRpbSIsImhhc0hvbGVzIiwibGVuZ3RoIiwib3V0ZXJMZW4iLCJvdXRlck5vZGUiLCJsaW5rZWRMaXN0IiwidHJpYW5nbGVzIiwibmV4dCIsInByZXYiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwieCIsInkiLCJpbnZTaXplIiwiZWxpbWluYXRlSG9sZXMiLCJpIiwiTWF0aCIsIm1heCIsImVhcmN1dExpbmtlZCIsInN0YXJ0IiwiZW5kIiwiY2xvY2t3aXNlIiwibGFzdCIsInNpZ25lZEFyZWEiLCJpbnNlcnROb2RlIiwiZXF1YWxzIiwicmVtb3ZlTm9kZSIsImZpbHRlclBvaW50cyIsInAiLCJhZ2FpbiIsInN0ZWluZXIiLCJhcmVhIiwiZWFyIiwicGFzcyIsImluZGV4Q3VydmUiLCJzdG9wIiwiaXNFYXJIYXNoZWQiLCJpc0VhciIsInB1c2giLCJjdXJlTG9jYWxJbnRlcnNlY3Rpb25zIiwic3BsaXRFYXJjdXQiLCJhIiwiYiIsImMiLCJheCIsImJ4IiwiY3giLCJheSIsImJ5IiwiY3kiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInBvaW50SW5UcmlhbmdsZSIsIm1pbloiLCJ6T3JkZXIiLCJtYXhaIiwicHJldloiLCJuIiwibmV4dFoiLCJ6IiwiaW50ZXJzZWN0cyIsImxvY2FsbHlJbnNpZGUiLCJpc1ZhbGlkRGlhZ29uYWwiLCJzcGxpdFBvbHlnb24iLCJxdWV1ZSIsImxlbiIsImxpc3QiLCJnZXRMZWZ0bW9zdCIsInNvcnQiLCJjb21wYXJlWCIsImVsaW1pbmF0ZUhvbGUiLCJob2xlIiwiYnJpZGdlIiwiZmluZEhvbGVCcmlkZ2UiLCJicmlkZ2VSZXZlcnNlIiwiaHgiLCJoeSIsInF4IiwiSW5maW5pdHkiLCJtIiwibXgiLCJteSIsInRhbk1pbiIsInRhbiIsImFicyIsInNlY3RvckNvbnRhaW5zU2VjdG9yIiwic29ydExpbmtlZCIsInEiLCJlIiwidGFpbCIsIm51bU1lcmdlcyIsInBTaXplIiwicVNpemUiLCJpblNpemUiLCJsZWZ0bW9zdCIsInB4IiwicHkiLCJpbnRlcnNlY3RzUG9seWdvbiIsIm1pZGRsZUluc2lkZSIsInIiLCJwMSIsInAyIiwicTEiLCJxMiIsIm8xIiwic2lnbiIsIm8yIiwibzMiLCJvNCIsIm9uU2VnbWVudCIsIm1pbiIsIm51bSIsImluc2lkZSIsImEyIiwiTm9kZSIsImIyIiwiYW4iLCJicCIsImRldmlhdGlvbiIsInBvbHlnb25BcmVhIiwidHJpYW5nbGVzQXJlYSIsInN1bSIsImoiLCJmbGF0dGVuIiwicmVzdWx0IiwidmVydGljZXMiLCJob2xlcyIsImRpbWVuc2lvbnMiLCJob2xlSW5kZXgiLCJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/earcut/src/earcut.js\n");

/***/ })

};
;