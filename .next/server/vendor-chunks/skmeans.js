"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/skmeans";
exports.ids = ["vendor-chunks/skmeans"];
exports.modules = {

/***/ "(ssr)/./node_modules/skmeans/dist/node/distance.js":
/*!****************************************************!*\
  !*** ./node_modules/skmeans/dist/node/distance.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    /**\n  * Euclidean distance\n  */ eudist: function eudist(v1, v2, sqrt) {\n        var len = v1.length;\n        var sum = 0;\n        for(var i = 0; i < len; i++){\n            var d = (v1[i] || 0) - (v2[i] || 0);\n            sum += d * d;\n        }\n        // Square root not really needed\n        return sqrt ? Math.sqrt(sum) : sum;\n    },\n    mandist: function mandist(v1, v2, sqrt) {\n        var len = v1.length;\n        var sum = 0;\n        for(var i = 0; i < len; i++){\n            sum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n        }\n        // Square root not really needed\n        return sqrt ? Math.sqrt(sum) : sum;\n    },\n    /**\n  * Unidimensional distance\n  */ dist: function dist(v1, v2, sqrt) {\n        var d = Math.abs(v1 - v2);\n        return sqrt ? d : d * d;\n    }\n}; //# sourceMappingURL=distance.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvZGlzdGFuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsT0FBT0MsT0FBTyxHQUFHO0lBQ2hCOztFQUVDLEdBQ0RDLFFBQVEsU0FBU0EsT0FBT0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLElBQUk7UUFDbkMsSUFBSUMsTUFBTUgsR0FBR0ksTUFBTTtRQUNuQixJQUFJQyxNQUFNO1FBRVYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEtBQUtHLElBQUs7WUFDN0IsSUFBSUMsSUFBSSxDQUFDUCxFQUFFLENBQUNNLEVBQUUsSUFBSSxLQUFNTCxDQUFBQSxFQUFFLENBQUNLLEVBQUUsSUFBSTtZQUNqQ0QsT0FBT0UsSUFBSUE7UUFDWjtRQUNBLGdDQUFnQztRQUNoQyxPQUFPTCxPQUFPTSxLQUFLTixJQUFJLENBQUNHLE9BQU9BO0lBQ2hDO0lBQ0FJLFNBQVMsU0FBU0EsUUFBUVQsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLElBQUk7UUFDckMsSUFBSUMsTUFBTUgsR0FBR0ksTUFBTTtRQUNuQixJQUFJQyxNQUFNO1FBRVYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEtBQUtHLElBQUs7WUFDN0JELE9BQU9HLEtBQUtFLEdBQUcsQ0FBQyxDQUFDVixFQUFFLENBQUNNLEVBQUUsSUFBSSxLQUFNTCxDQUFBQSxFQUFFLENBQUNLLEVBQUUsSUFBSTtRQUMxQztRQUVBLGdDQUFnQztRQUNoQyxPQUFPSixPQUFPTSxLQUFLTixJQUFJLENBQUNHLE9BQU9BO0lBQ2hDO0lBR0E7O0VBRUMsR0FDRE0sTUFBTSxTQUFTQSxLQUFLWCxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsSUFBSTtRQUMvQixJQUFJSyxJQUFJQyxLQUFLRSxHQUFHLENBQUNWLEtBQUtDO1FBQ3RCLE9BQU9DLE9BQU9LLElBQUlBLElBQUlBO0lBQ3ZCO0FBQ0QsR0FDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92My1hcHAvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvZGlzdGFuY2UuanM/NTZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuICAqIEV1Y2xpZGVhbiBkaXN0YW5jZVxuICAqL1xuXHRldWRpc3Q6IGZ1bmN0aW9uIGV1ZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgbGVuID0gdjEubGVuZ3RoO1xuXHRcdHZhciBzdW0gPSAwO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGQgPSAodjFbaV0gfHwgMCkgLSAodjJbaV0gfHwgMCk7XG5cdFx0XHRzdW0gKz0gZCAqIGQ7XG5cdFx0fVxuXHRcdC8vIFNxdWFyZSByb290IG5vdCByZWFsbHkgbmVlZGVkXG5cdFx0cmV0dXJuIHNxcnQgPyBNYXRoLnNxcnQoc3VtKSA6IHN1bTtcblx0fSxcblx0bWFuZGlzdDogZnVuY3Rpb24gbWFuZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgbGVuID0gdjEubGVuZ3RoO1xuXHRcdHZhciBzdW0gPSAwO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0c3VtICs9IE1hdGguYWJzKCh2MVtpXSB8fCAwKSAtICh2MltpXSB8fCAwKSk7XG5cdFx0fVxuXG5cdFx0Ly8gU3F1YXJlIHJvb3Qgbm90IHJlYWxseSBuZWVkZWRcblx0XHRyZXR1cm4gc3FydCA/IE1hdGguc3FydChzdW0pIDogc3VtO1xuXHR9LFxuXG5cblx0LyoqXG4gICogVW5pZGltZW5zaW9uYWwgZGlzdGFuY2VcbiAgKi9cblx0ZGlzdDogZnVuY3Rpb24gZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgZCA9IE1hdGguYWJzKHYxIC0gdjIpO1xuXHRcdHJldHVybiBzcXJ0ID8gZCA6IGQgKiBkO1xuXHR9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGFuY2UuanMubWFwXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImV1ZGlzdCIsInYxIiwidjIiLCJzcXJ0IiwibGVuIiwibGVuZ3RoIiwic3VtIiwiaSIsImQiLCJNYXRoIiwibWFuZGlzdCIsImFicyIsImRpc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/distance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/skmeans/dist/node/kinit.js":
/*!*************************************************!*\
  !*** ./node_modules/skmeans/dist/node/kinit.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Distance = __webpack_require__(/*! ./distance.js */ \"(ssr)/./node_modules/skmeans/dist/node/distance.js\"), eudist = Distance.eudist, dist = Distance.dist;\nmodule.exports = {\n    kmrand: function kmrand(data, k) {\n        var map = {}, ks = [], t = k << 2;\n        var len = data.length;\n        var multi = data[0].length > 0;\n        while(ks.length < k && t-- > 0){\n            var d = data[Math.floor(Math.random() * len)];\n            var key = multi ? d.join(\"_\") : \"\" + d;\n            if (!map[key]) {\n                map[key] = true;\n                ks.push(d);\n            }\n        }\n        if (ks.length < k) throw new Error(\"Error initializating clusters\");\n        else return ks;\n    },\n    /**\n  * K-means++ initial centroid selection\n  */ kmpp: function kmpp(data, k) {\n        var distance = data[0].length ? eudist : dist;\n        var ks = [], len = data.length;\n        var multi = data[0].length > 0;\n        var map = {};\n        // First random centroid\n        var c = data[Math.floor(Math.random() * len)];\n        var key = multi ? c.join(\"_\") : \"\" + c;\n        ks.push(c);\n        map[key] = true;\n        // Retrieve next centroids\n        while(ks.length < k){\n            // Min Distances between current centroids and data points\n            var dists = [], lk = ks.length;\n            var dsum = 0, prs = [];\n            for(var i = 0; i < len; i++){\n                var min = Infinity;\n                for(var j = 0; j < lk; j++){\n                    var _dist = distance(data[i], ks[j]);\n                    if (_dist <= min) min = _dist;\n                }\n                dists[i] = min;\n            }\n            // Sum all min distances\n            for(var _i = 0; _i < len; _i++){\n                dsum += dists[_i];\n            }\n            // Probabilities and cummulative prob (cumsum)\n            for(var _i2 = 0; _i2 < len; _i2++){\n                prs[_i2] = {\n                    i: _i2,\n                    v: data[_i2],\n                    pr: dists[_i2] / dsum,\n                    cs: 0\n                };\n            }\n            // Sort Probabilities\n            prs.sort(function(a, b) {\n                return a.pr - b.pr;\n            });\n            // Cummulative Probabilities\n            prs[0].cs = prs[0].pr;\n            for(var _i3 = 1; _i3 < len; _i3++){\n                prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n            }\n            // Randomize\n            var rnd = Math.random();\n            // Gets only the items whose cumsum >= rnd\n            var idx = 0;\n            while(idx < len - 1 && prs[idx++].cs < rnd){}\n            ks.push(prs[idx - 1].v);\n        /*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */ }\n        return ks;\n    }\n}; //# sourceMappingURL=kinit.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUva2luaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyx5RUFBZSxHQUNsQ0MsU0FBU0YsU0FBU0UsTUFBTSxFQUN4QkMsT0FBT0gsU0FBU0csSUFBSTtBQUV4QkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2hCQyxRQUFRLFNBQVNBLE9BQU9DLElBQUksRUFBRUMsQ0FBQztRQUM5QixJQUFJQyxNQUFNLENBQUMsR0FDUEMsS0FBSyxFQUFFLEVBQ1BDLElBQUlILEtBQUs7UUFDYixJQUFJSSxNQUFNTCxLQUFLTSxNQUFNO1FBQ3JCLElBQUlDLFFBQVFQLElBQUksQ0FBQyxFQUFFLENBQUNNLE1BQU0sR0FBRztRQUU3QixNQUFPSCxHQUFHRyxNQUFNLEdBQUdMLEtBQUtHLE1BQU0sRUFBRztZQUNoQyxJQUFJSSxJQUFJUixJQUFJLENBQUNTLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLTixLQUFLO1lBQzdDLElBQUlPLE1BQU1MLFFBQVFDLEVBQUVLLElBQUksQ0FBQyxPQUFPLEtBQUtMO1lBQ3JDLElBQUksQ0FBQ04sR0FBRyxDQUFDVSxJQUFJLEVBQUU7Z0JBQ2RWLEdBQUcsQ0FBQ1UsSUFBSSxHQUFHO2dCQUNYVCxHQUFHVyxJQUFJLENBQUNOO1lBQ1Q7UUFDRDtRQUVBLElBQUlMLEdBQUdHLE1BQU0sR0FBR0wsR0FBRyxNQUFNLElBQUljLE1BQU07YUFBc0MsT0FBT1o7SUFDakY7SUFHQTs7RUFFQyxHQUNEYSxNQUFNLFNBQVNBLEtBQUtoQixJQUFJLEVBQUVDLENBQUM7UUFDMUIsSUFBSWdCLFdBQVdqQixJQUFJLENBQUMsRUFBRSxDQUFDTSxNQUFNLEdBQUdYLFNBQVNDO1FBQ3pDLElBQUlPLEtBQUssRUFBRSxFQUNQRSxNQUFNTCxLQUFLTSxNQUFNO1FBQ3JCLElBQUlDLFFBQVFQLElBQUksQ0FBQyxFQUFFLENBQUNNLE1BQU0sR0FBRztRQUM3QixJQUFJSixNQUFNLENBQUM7UUFFWCx3QkFBd0I7UUFDeEIsSUFBSWdCLElBQUlsQixJQUFJLENBQUNTLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLTixLQUFLO1FBQzdDLElBQUlPLE1BQU1MLFFBQVFXLEVBQUVMLElBQUksQ0FBQyxPQUFPLEtBQUtLO1FBQ3JDZixHQUFHVyxJQUFJLENBQUNJO1FBQ1JoQixHQUFHLENBQUNVLElBQUksR0FBRztRQUVYLDBCQUEwQjtRQUMxQixNQUFPVCxHQUFHRyxNQUFNLEdBQUdMLEVBQUc7WUFDckIsMERBQTBEO1lBQzFELElBQUlrQixRQUFRLEVBQUUsRUFDVkMsS0FBS2pCLEdBQUdHLE1BQU07WUFDbEIsSUFBSWUsT0FBTyxHQUNQQyxNQUFNLEVBQUU7WUFFWixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWxCLEtBQUtrQixJQUFLO2dCQUM3QixJQUFJQyxNQUFNQztnQkFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sSUFBSU0sSUFBSztvQkFDNUIsSUFBSUMsUUFBUVYsU0FBU2pCLElBQUksQ0FBQ3VCLEVBQUUsRUFBRXBCLEVBQUUsQ0FBQ3VCLEVBQUU7b0JBQ25DLElBQUlDLFNBQVNILEtBQUtBLE1BQU1HO2dCQUN6QjtnQkFDQVIsS0FBSyxDQUFDSSxFQUFFLEdBQUdDO1lBQ1o7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSyxJQUFJSSxLQUFLLEdBQUdBLEtBQUt2QixLQUFLdUIsS0FBTTtnQkFDaENQLFFBQVFGLEtBQUssQ0FBQ1MsR0FBRztZQUNsQjtZQUVBLDhDQUE4QztZQUM5QyxJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTXhCLEtBQUt3QixNQUFPO2dCQUNuQ1AsR0FBRyxDQUFDTyxJQUFJLEdBQUc7b0JBQUVOLEdBQUdNO29CQUFLQyxHQUFHOUIsSUFBSSxDQUFDNkIsSUFBSTtvQkFBRUUsSUFBSVosS0FBSyxDQUFDVSxJQUFJLEdBQUdSO29CQUFNVyxJQUFJO2dCQUFFO1lBQ2pFO1lBRUEscUJBQXFCO1lBQ3JCVixJQUFJVyxJQUFJLENBQUMsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO2dCQUN0QixPQUFPRCxFQUFFSCxFQUFFLEdBQUdJLEVBQUVKLEVBQUU7WUFDbkI7WUFFQSw0QkFBNEI7WUFDNUJULEdBQUcsQ0FBQyxFQUFFLENBQUNVLEVBQUUsR0FBR1YsR0FBRyxDQUFDLEVBQUUsQ0FBQ1MsRUFBRTtZQUNyQixJQUFLLElBQUlLLE1BQU0sR0FBR0EsTUFBTS9CLEtBQUsrQixNQUFPO2dCQUNuQ2QsR0FBRyxDQUFDYyxJQUFJLENBQUNKLEVBQUUsR0FBR1YsR0FBRyxDQUFDYyxNQUFNLEVBQUUsQ0FBQ0osRUFBRSxHQUFHVixHQUFHLENBQUNjLElBQUksQ0FBQ0wsRUFBRTtZQUM1QztZQUVBLFlBQVk7WUFDWixJQUFJTSxNQUFNNUIsS0FBS0UsTUFBTTtZQUVyQiwwQ0FBMEM7WUFDMUMsSUFBSTJCLE1BQU07WUFDVixNQUFPQSxNQUFNakMsTUFBTSxLQUFLaUIsR0FBRyxDQUFDZ0IsTUFBTSxDQUFDTixFQUFFLEdBQUdLLElBQUssQ0FBQztZQUM5Q2xDLEdBQUdXLElBQUksQ0FBQ1EsR0FBRyxDQUFDZ0IsTUFBTSxFQUFFLENBQUNSLENBQUM7UUFDdEI7Ozs7Ozs7Ozs7Ozs7OztHQWVBLEdBQ0Q7UUFFQSxPQUFPM0I7SUFDUjtBQUNELEdBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdjMtYXBwLy4vbm9kZV9tb2R1bGVzL3NrbWVhbnMvZGlzdC9ub2RlL2tpbml0LmpzP2QxNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBEaXN0YW5jZSA9IHJlcXVpcmUoXCIuL2Rpc3RhbmNlLmpzXCIpLFxuICAgIGV1ZGlzdCA9IERpc3RhbmNlLmV1ZGlzdCxcbiAgICBkaXN0ID0gRGlzdGFuY2UuZGlzdDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGttcmFuZDogZnVuY3Rpb24ga21yYW5kKGRhdGEsIGspIHtcblx0XHR2YXIgbWFwID0ge30sXG5cdFx0ICAgIGtzID0gW10sXG5cdFx0ICAgIHQgPSBrIDw8IDI7XG5cdFx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciBtdWx0aSA9IGRhdGFbMF0ubGVuZ3RoID4gMDtcblxuXHRcdHdoaWxlIChrcy5sZW5ndGggPCBrICYmIHQtLSA+IDApIHtcblx0XHRcdHZhciBkID0gZGF0YVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW4pXTtcblx0XHRcdHZhciBrZXkgPSBtdWx0aSA/IGQuam9pbihcIl9cIikgOiBcIlwiICsgZDtcblx0XHRcdGlmICghbWFwW2tleV0pIHtcblx0XHRcdFx0bWFwW2tleV0gPSB0cnVlO1xuXHRcdFx0XHRrcy5wdXNoKGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChrcy5sZW5ndGggPCBrKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbml0aWFsaXphdGluZyBjbHVzdGVyc1wiKTtlbHNlIHJldHVybiBrcztcblx0fSxcblxuXG5cdC8qKlxuICAqIEstbWVhbnMrKyBpbml0aWFsIGNlbnRyb2lkIHNlbGVjdGlvblxuICAqL1xuXHRrbXBwOiBmdW5jdGlvbiBrbXBwKGRhdGEsIGspIHtcblx0XHR2YXIgZGlzdGFuY2UgPSBkYXRhWzBdLmxlbmd0aCA/IGV1ZGlzdCA6IGRpc3Q7XG5cdFx0dmFyIGtzID0gW10sXG5cdFx0ICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciBtdWx0aSA9IGRhdGFbMF0ubGVuZ3RoID4gMDtcblx0XHR2YXIgbWFwID0ge307XG5cblx0XHQvLyBGaXJzdCByYW5kb20gY2VudHJvaWRcblx0XHR2YXIgYyA9IGRhdGFbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKV07XG5cdFx0dmFyIGtleSA9IG11bHRpID8gYy5qb2luKFwiX1wiKSA6IFwiXCIgKyBjO1xuXHRcdGtzLnB1c2goYyk7XG5cdFx0bWFwW2tleV0gPSB0cnVlO1xuXG5cdFx0Ly8gUmV0cmlldmUgbmV4dCBjZW50cm9pZHNcblx0XHR3aGlsZSAoa3MubGVuZ3RoIDwgaykge1xuXHRcdFx0Ly8gTWluIERpc3RhbmNlcyBiZXR3ZWVuIGN1cnJlbnQgY2VudHJvaWRzIGFuZCBkYXRhIHBvaW50c1xuXHRcdFx0dmFyIGRpc3RzID0gW10sXG5cdFx0XHQgICAgbGsgPSBrcy5sZW5ndGg7XG5cdFx0XHR2YXIgZHN1bSA9IDAsXG5cdFx0XHQgICAgcHJzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dmFyIG1pbiA9IEluZmluaXR5O1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxrOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgX2Rpc3QgPSBkaXN0YW5jZShkYXRhW2ldLCBrc1tqXSk7XG5cdFx0XHRcdFx0aWYgKF9kaXN0IDw9IG1pbikgbWluID0gX2Rpc3Q7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGlzdHNbaV0gPSBtaW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1bSBhbGwgbWluIGRpc3RhbmNlc1xuXHRcdFx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xuXHRcdFx0XHRkc3VtICs9IGRpc3RzW19pXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJvYmFiaWxpdGllcyBhbmQgY3VtbXVsYXRpdmUgcHJvYiAoY3Vtc3VtKVxuXHRcdFx0Zm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuOyBfaTIrKykge1xuXHRcdFx0XHRwcnNbX2kyXSA9IHsgaTogX2kyLCB2OiBkYXRhW19pMl0sIHByOiBkaXN0c1tfaTJdIC8gZHN1bSwgY3M6IDAgfTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCBQcm9iYWJpbGl0aWVzXG5cdFx0XHRwcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5wciAtIGIucHI7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQ3VtbXVsYXRpdmUgUHJvYmFiaWxpdGllc1xuXHRcdFx0cHJzWzBdLmNzID0gcHJzWzBdLnByO1xuXHRcdFx0Zm9yICh2YXIgX2kzID0gMTsgX2kzIDwgbGVuOyBfaTMrKykge1xuXHRcdFx0XHRwcnNbX2kzXS5jcyA9IHByc1tfaTMgLSAxXS5jcyArIHByc1tfaTNdLnByO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSYW5kb21pemVcblx0XHRcdHZhciBybmQgPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0XHQvLyBHZXRzIG9ubHkgdGhlIGl0ZW1zIHdob3NlIGN1bXN1bSA+PSBybmRcblx0XHRcdHZhciBpZHggPSAwO1xuXHRcdFx0d2hpbGUgKGlkeCA8IGxlbiAtIDEgJiYgcHJzW2lkeCsrXS5jcyA8IHJuZCkge31cblx0XHRcdGtzLnB1c2gocHJzW2lkeCAtIDFdLnYpO1xuXHRcdFx0LypcbiAgIGxldCBkb25lID0gZmFsc2U7XG4gICB3aGlsZSghZG9uZSkge1xuICAgXHQvLyB0aGlzIGlzIG91ciBuZXcgY2VudHJvaWRcbiAgIFx0YyA9IHByc1tpZHgtMV0udlxuICAgXHRrZXkgPSBtdWx0aT8gYy5qb2luKFwiX1wiKSA6IGAke2N9YDtcbiAgIFx0aWYoIW1hcFtrZXldKSB7XG4gICBcdFx0bWFwW2tleV0gPSB0cnVlO1xuICAgXHRcdGtzLnB1c2goYyk7XG4gICBcdFx0ZG9uZSA9IHRydWU7XG4gICBcdH1cbiAgIFx0ZWxzZSB7XG4gICBcdFx0aWR4Kys7XG4gICBcdH1cbiAgIH1cbiAgICovXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtzO1xuXHR9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2luaXQuanMubWFwXG4iXSwibmFtZXMiOlsiRGlzdGFuY2UiLCJyZXF1aXJlIiwiZXVkaXN0IiwiZGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiLCJrbXJhbmQiLCJkYXRhIiwiayIsIm1hcCIsImtzIiwidCIsImxlbiIsImxlbmd0aCIsIm11bHRpIiwiZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImtleSIsImpvaW4iLCJwdXNoIiwiRXJyb3IiLCJrbXBwIiwiZGlzdGFuY2UiLCJjIiwiZGlzdHMiLCJsayIsImRzdW0iLCJwcnMiLCJpIiwibWluIiwiSW5maW5pdHkiLCJqIiwiX2Rpc3QiLCJfaSIsIl9pMiIsInYiLCJwciIsImNzIiwic29ydCIsImEiLCJiIiwiX2kzIiwicm5kIiwiaWR4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/kinit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/skmeans/dist/node/main.js":
/*!************************************************!*\
  !*** ./node_modules/skmeans/dist/node/main.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*jshint esversion: 6 */ var Distance = __webpack_require__(/*! ./distance.js */ \"(ssr)/./node_modules/skmeans/dist/node/distance.js\"), ClusterInit = __webpack_require__(/*! ./kinit.js */ \"(ssr)/./node_modules/skmeans/dist/node/kinit.js\"), eudist = Distance.eudist, mandist = Distance.mandist, dist = Distance.dist, kmrand = ClusterInit.kmrand, kmpp = ClusterInit.kmpp;\nvar MAX = 10000;\n/**\n * Inits an array with values\n */ function init(len, val, v) {\n    v = v || [];\n    for(var i = 0; i < len; i++){\n        v[i] = val;\n    }\n    return v;\n}\nfunction skmeans(data, k, initial, maxit) {\n    var ks = [], old = [], idxs = [], dist = [];\n    var conv = false, it = maxit || MAX;\n    var len = data.length, vlen = data[0].length, multi = vlen > 0;\n    var count = [];\n    if (!initial) {\n        var _idxs = {};\n        while(ks.length < k){\n            var idx = Math.floor(Math.random() * len);\n            if (!_idxs[idx]) {\n                _idxs[idx] = true;\n                ks.push(data[idx]);\n            }\n        }\n    } else if (initial == \"kmrand\") {\n        ks = kmrand(data, k);\n    } else if (initial == \"kmpp\") {\n        ks = kmpp(data, k);\n    } else {\n        ks = initial;\n    }\n    do {\n        // Reset k count\n        init(k, 0, count);\n        // For each value in data, find the nearest centroid\n        for(var i = 0; i < len; i++){\n            var min = Infinity, _idx = 0;\n            for(var j = 0; j < k; j++){\n                // Multidimensional or unidimensional\n                var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n                if (dist <= min) {\n                    min = dist;\n                    _idx = j;\n                }\n            }\n            idxs[i] = _idx; // Index of the selected centroid for that value\n            count[_idx]++; // Number of values for this centroid\n        }\n        // Recalculate centroids\n        var sum = [], old = [], dif = 0;\n        for(var _j = 0; _j < k; _j++){\n            // Multidimensional or unidimensional\n            sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n            old[_j] = ks[_j];\n        }\n        // If multidimensional\n        if (multi) {\n            for(var _j2 = 0; _j2 < k; _j2++){\n                ks[_j2] = [];\n            } // Sum values and count for each centroid\n            for(var _i = 0; _i < len; _i++){\n                var _idx2 = idxs[_i], // Centroid for that item\n                vsum = sum[_idx2], // Sum values for this centroid\n                vect = data[_i]; // Current vector\n                // Accumulate value on the centroid for current vector\n                for(var h = 0; h < vlen; h++){\n                    vsum[h] += vect[h];\n                }\n            }\n            // Calculate the average for each centroid\n            conv = true;\n            for(var _j3 = 0; _j3 < k; _j3++){\n                var ksj = ks[_j3], // Current centroid\n                sumj = sum[_j3], // Accumulated centroid values\n                oldj = old[_j3], // Old centroid value\n                cj = count[_j3]; // Number of elements for this centroid\n                // New average\n                for(var _h = 0; _h < vlen; _h++){\n                    ksj[_h] = sumj[_h] / cj || 0; // New centroid\n                }\n                // Find if centroids have moved\n                if (conv) {\n                    for(var _h2 = 0; _h2 < vlen; _h2++){\n                        if (oldj[_h2] != ksj[_h2]) {\n                            conv = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            // Sum values and count for each centroid\n            for(var _i2 = 0; _i2 < len; _i2++){\n                var _idx3 = idxs[_i2];\n                sum[_idx3] += data[_i2];\n            }\n            // Calculate the average for each centroid\n            for(var _j4 = 0; _j4 < k; _j4++){\n                ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n            }\n            // Find if centroids have moved\n            conv = true;\n            for(var _j5 = 0; _j5 < k; _j5++){\n                if (old[_j5] != ks[_j5]) {\n                    conv = false;\n                    break;\n                }\n            }\n        }\n        conv = conv || --it <= 0;\n    }while (!conv);\n    return {\n        it: MAX - it,\n        k: k,\n        idxs: idxs,\n        centroids: ks\n    };\n}\nmodule.exports = skmeans; //# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLHNCQUFzQixHQUV0QixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyx5RUFBZSxHQUNsQ0MsY0FBY0QsbUJBQU9BLENBQUMsbUVBQVksR0FDbENFLFNBQVNILFNBQVNHLE1BQU0sRUFDeEJDLFVBQVVKLFNBQVNJLE9BQU8sRUFDMUJDLE9BQU9MLFNBQVNLLElBQUksRUFDcEJDLFNBQVNKLFlBQVlJLE1BQU0sRUFDM0JDLE9BQU9MLFlBQVlLLElBQUk7QUFFM0IsSUFBSUMsTUFBTTtBQUVWOztDQUVDLEdBQ0QsU0FBU0MsS0FBS0MsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLENBQUM7SUFDeEJBLElBQUlBLEtBQUssRUFBRTtJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxLQUFLRyxJQUFLO1FBQzdCRCxDQUFDLENBQUNDLEVBQUUsR0FBR0Y7SUFDUjtJQUFDLE9BQU9DO0FBQ1Q7QUFFQSxTQUFTRSxRQUFRQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsT0FBTyxFQUFFQyxLQUFLO0lBQ3ZDLElBQUlDLEtBQUssRUFBRSxFQUNQQyxNQUFNLEVBQUUsRUFDUkMsT0FBTyxFQUFFLEVBQ1RoQixPQUFPLEVBQUU7SUFDYixJQUFJaUIsT0FBTyxPQUNQQyxLQUFLTCxTQUFTVjtJQUNsQixJQUFJRSxNQUFNSyxLQUFLUyxNQUFNLEVBQ2pCQyxPQUFPVixJQUFJLENBQUMsRUFBRSxDQUFDUyxNQUFNLEVBQ3JCRSxRQUFRRCxPQUFPO0lBQ25CLElBQUlFLFFBQVEsRUFBRTtJQUVkLElBQUksQ0FBQ1YsU0FBUztRQUNiLElBQUlXLFFBQVEsQ0FBQztRQUNiLE1BQU9ULEdBQUdLLE1BQU0sR0FBR1IsRUFBRztZQUNyQixJQUFJYSxNQUFNQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS3RCO1lBQ3JDLElBQUksQ0FBQ2tCLEtBQUssQ0FBQ0Ms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b0JBQ1QsSUFBSyxJQUFJZ0MsTUFBTSxHQUFHQSxNQUFNN0IsTUFBTTZCLE1BQU87d0JBQ3BDLElBQUlILElBQUksQ0FBQ0csSUFBSSxJQUFJTCxHQUFHLENBQUNLLElBQUksRUFBRTs0QkFDMUJoQyxPQUFPOzRCQUNQO3dCQUNEO29CQUNEO2dCQUNEO1lBQ0Q7UUFDRCxPQUVLO1lBQ0gseUNBQXlDO1lBQ3pDLElBQUssSUFBSWlDLE1BQU0sR0FBR0EsTUFBTTdDLEtBQUs2QyxNQUFPO2dCQUNuQyxJQUFJQyxRQUFRbkMsSUFBSSxDQUFDa0MsSUFBSTtnQkFDckJoQixHQUFHLENBQUNpQixNQUFNLElBQUl6QyxJQUFJLENBQUN3QyxJQUFJO1lBQ3hCO1lBQ0EsMENBQTBDO1lBQzFDLElBQUssSUFBSUUsTUFBTSxHQUFHQSxNQUFNekMsR0FBR3lDLE1BQU87Z0JBQ2pDdEMsRUFBRSxDQUFDc0MsSUFBSSxHQUFHbEIsR0FBRyxDQUFDa0IsSUFBSSxHQUFHOUIsS0FBSyxDQUFDOEIsSUFBSSxJQUFJLEdBQUcsZUFBZTtZQUN0RDtZQUNBLCtCQUErQjtZQUMvQm5DLE9BQU87WUFDUCxJQUFLLElBQUlvQyxNQUFNLEdBQUdBLE1BQU0xQyxHQUFHMEMsTUFBTztnQkFDakMsSUFBSXRDLEdBQUcsQ0FBQ3NDLElBQUksSUFBSXZDLEVBQUUsQ0FBQ3VDLElBQUksRUFBRTtvQkFDeEJwQyxPQUFPO29CQUNQO2dCQUNEO1lBQ0Q7UUFDRDtRQUVEQSxPQUFPQSxRQUFRLEVBQUVDLE1BQU07SUFDeEIsUUFBUyxDQUFDRCxNQUFNO0lBRWhCLE9BQU87UUFDTkMsSUFBSWYsTUFBTWU7UUFDVlAsR0FBR0E7UUFDSEssTUFBTUE7UUFDTnNDLFdBQVd4QztJQUNaO0FBQ0Q7QUFFQXlDLE9BQU9DLE9BQU8sR0FBRy9DLFNBQ2pCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3YzLWFwcC8uL25vZGVfbW9kdWxlcy9za21lYW5zL2Rpc3Qvbm9kZS9tYWluLmpzPzYyZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qanNoaW50IGVzdmVyc2lvbjogNiAqL1xuXG52YXIgRGlzdGFuY2UgPSByZXF1aXJlKFwiLi9kaXN0YW5jZS5qc1wiKSxcbiAgICBDbHVzdGVySW5pdCA9IHJlcXVpcmUoXCIuL2tpbml0LmpzXCIpLFxuICAgIGV1ZGlzdCA9IERpc3RhbmNlLmV1ZGlzdCxcbiAgICBtYW5kaXN0ID0gRGlzdGFuY2UubWFuZGlzdCxcbiAgICBkaXN0ID0gRGlzdGFuY2UuZGlzdCxcbiAgICBrbXJhbmQgPSBDbHVzdGVySW5pdC5rbXJhbmQsXG4gICAga21wcCA9IENsdXN0ZXJJbml0LmttcHA7XG5cbnZhciBNQVggPSAxMDAwMDtcblxuLyoqXG4gKiBJbml0cyBhbiBhcnJheSB3aXRoIHZhbHVlc1xuICovXG5mdW5jdGlvbiBpbml0KGxlbiwgdmFsLCB2KSB7XG5cdHYgPSB2IHx8IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dltpXSA9IHZhbDtcblx0fXJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBza21lYW5zKGRhdGEsIGssIGluaXRpYWwsIG1heGl0KSB7XG5cdHZhciBrcyA9IFtdLFxuXHQgICAgb2xkID0gW10sXG5cdCAgICBpZHhzID0gW10sXG5cdCAgICBkaXN0ID0gW107XG5cdHZhciBjb252ID0gZmFsc2UsXG5cdCAgICBpdCA9IG1heGl0IHx8IE1BWDtcblx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoLFxuXHQgICAgdmxlbiA9IGRhdGFbMF0ubGVuZ3RoLFxuXHQgICAgbXVsdGkgPSB2bGVuID4gMDtcblx0dmFyIGNvdW50ID0gW107XG5cblx0aWYgKCFpbml0aWFsKSB7XG5cdFx0dmFyIF9pZHhzID0ge307XG5cdFx0d2hpbGUgKGtzLmxlbmd0aCA8IGspIHtcblx0XHRcdHZhciBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW4pO1xuXHRcdFx0aWYgKCFfaWR4c1tpZHhdKSB7XG5cdFx0XHRcdF9pZHhzW2lkeF0gPSB0cnVlO1xuXHRcdFx0XHRrcy5wdXNoKGRhdGFbaWR4XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGluaXRpYWwgPT0gXCJrbXJhbmRcIikge1xuXHRcdGtzID0ga21yYW5kKGRhdGEsIGspO1xuXHR9IGVsc2UgaWYgKGluaXRpYWwgPT0gXCJrbXBwXCIpIHtcblx0XHRrcyA9IGttcHAoZGF0YSwgayk7XG5cdH0gZWxzZSB7XG5cdFx0a3MgPSBpbml0aWFsO1xuXHR9XG5cblx0ZG8ge1xuXHRcdC8vIFJlc2V0IGsgY291bnRcblx0XHRpbml0KGssIDAsIGNvdW50KTtcblxuXHRcdC8vIEZvciBlYWNoIHZhbHVlIGluIGRhdGEsIGZpbmQgdGhlIG5lYXJlc3QgY2VudHJvaWRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgbWluID0gSW5maW5pdHksXG5cdFx0XHQgICAgX2lkeCA9IDA7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHQvLyBNdWx0aWRpbWVuc2lvbmFsIG9yIHVuaWRpbWVuc2lvbmFsXG5cdFx0XHRcdHZhciBkaXN0ID0gbXVsdGkgPyBldWRpc3QoZGF0YVtpXSwga3Nbal0pIDogTWF0aC5hYnMoZGF0YVtpXSAtIGtzW2pdKTtcblx0XHRcdFx0aWYgKGRpc3QgPD0gbWluKSB7XG5cdFx0XHRcdFx0bWluID0gZGlzdDtcblx0XHRcdFx0XHRfaWR4ID0gajtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWR4c1tpXSA9IF9pZHg7IC8vIEluZGV4IG9mIHRoZSBzZWxlY3RlZCBjZW50cm9pZCBmb3IgdGhhdCB2YWx1ZVxuXHRcdFx0Y291bnRbX2lkeF0rKzsgLy8gTnVtYmVyIG9mIHZhbHVlcyBmb3IgdGhpcyBjZW50cm9pZFxuXHRcdH1cblxuXHRcdC8vIFJlY2FsY3VsYXRlIGNlbnRyb2lkc1xuXHRcdHZhciBzdW0gPSBbXSxcblx0XHQgICAgb2xkID0gW10sXG5cdFx0ICAgIGRpZiA9IDA7XG5cdFx0Zm9yICh2YXIgX2ogPSAwOyBfaiA8IGs7IF9qKyspIHtcblx0XHRcdC8vIE11bHRpZGltZW5zaW9uYWwgb3IgdW5pZGltZW5zaW9uYWxcblx0XHRcdHN1bVtfal0gPSBtdWx0aSA/IGluaXQodmxlbiwgMCwgc3VtW19qXSkgOiAwO1xuXHRcdFx0b2xkW19qXSA9IGtzW19qXTtcblx0XHR9XG5cblx0XHQvLyBJZiBtdWx0aWRpbWVuc2lvbmFsXG5cdFx0aWYgKG11bHRpKSB7XG5cdFx0XHRmb3IgKHZhciBfajIgPSAwOyBfajIgPCBrOyBfajIrKykge1xuXHRcdFx0XHRrc1tfajJdID0gW107XG5cdFx0XHR9IC8vIFN1bSB2YWx1ZXMgYW5kIGNvdW50IGZvciBlYWNoIGNlbnRyb2lkXG5cdFx0XHRmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG5cdFx0XHRcdHZhciBfaWR4MiA9IGlkeHNbX2ldLFxuXHRcdFx0XHQgICAgLy8gQ2VudHJvaWQgZm9yIHRoYXQgaXRlbVxuXHRcdFx0XHR2c3VtID0gc3VtW19pZHgyXSxcblx0XHRcdFx0ICAgIC8vIFN1bSB2YWx1ZXMgZm9yIHRoaXMgY2VudHJvaWRcblx0XHRcdFx0dmVjdCA9IGRhdGFbX2ldOyAvLyBDdXJyZW50IHZlY3RvclxuXG5cdFx0XHRcdC8vIEFjY3VtdWxhdGUgdmFsdWUgb24gdGhlIGNlbnRyb2lkIGZvciBjdXJyZW50IHZlY3RvclxuXHRcdFx0XHRmb3IgKHZhciBoID0gMDsgaCA8IHZsZW47IGgrKykge1xuXHRcdFx0XHRcdHZzdW1baF0gKz0gdmVjdFtoXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIGZvciBlYWNoIGNlbnRyb2lkXG5cdFx0XHRjb252ID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGs7IF9qMysrKSB7XG5cdFx0XHRcdHZhciBrc2ogPSBrc1tfajNdLFxuXHRcdFx0XHQgICAgLy8gQ3VycmVudCBjZW50cm9pZFxuXHRcdFx0XHRzdW1qID0gc3VtW19qM10sXG5cdFx0XHRcdCAgICAvLyBBY2N1bXVsYXRlZCBjZW50cm9pZCB2YWx1ZXNcblx0XHRcdFx0b2xkaiA9IG9sZFtfajNdLFxuXHRcdFx0XHQgICAgLy8gT2xkIGNlbnRyb2lkIHZhbHVlXG5cdFx0XHRcdGNqID0gY291bnRbX2ozXTsgLy8gTnVtYmVyIG9mIGVsZW1lbnRzIGZvciB0aGlzIGNlbnRyb2lkXG5cblx0XHRcdFx0Ly8gTmV3IGF2ZXJhZ2Vcblx0XHRcdFx0Zm9yICh2YXIgX2ggPSAwOyBfaCA8IHZsZW47IF9oKyspIHtcblx0XHRcdFx0XHRrc2pbX2hdID0gc3VtaltfaF0gLyBjaiB8fCAwOyAvLyBOZXcgY2VudHJvaWRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZpbmQgaWYgY2VudHJvaWRzIGhhdmUgbW92ZWRcblx0XHRcdFx0aWYgKGNvbnYpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBfaDIgPSAwOyBfaDIgPCB2bGVuOyBfaDIrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZGpbX2gyXSAhPSBrc2pbX2gyXSkge1xuXHRcdFx0XHRcdFx0XHRjb252ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB1bmlkaW1lbnNpb25hbFxuXHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBTdW0gdmFsdWVzIGFuZCBjb3VudCBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0XHRmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW47IF9pMisrKSB7XG5cdFx0XHRcdFx0dmFyIF9pZHgzID0gaWR4c1tfaTJdO1xuXHRcdFx0XHRcdHN1bVtfaWR4M10gKz0gZGF0YVtfaTJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYXZlcmFnZSBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0XHRmb3IgKHZhciBfajQgPSAwOyBfajQgPCBrOyBfajQrKykge1xuXHRcdFx0XHRcdGtzW19qNF0gPSBzdW1bX2o0XSAvIGNvdW50W19qNF0gfHwgMDsgLy8gTmV3IGNlbnRyb2lkXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRmluZCBpZiBjZW50cm9pZHMgaGF2ZSBtb3ZlZFxuXHRcdFx0XHRjb252ID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgazsgX2o1KyspIHtcblx0XHRcdFx0XHRpZiAob2xkW19qNV0gIT0ga3NbX2o1XSkge1xuXHRcdFx0XHRcdFx0Y29udiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRjb252ID0gY29udiB8fCAtLWl0IDw9IDA7XG5cdH0gd2hpbGUgKCFjb252KTtcblxuXHRyZXR1cm4ge1xuXHRcdGl0OiBNQVggLSBpdCxcblx0XHRrOiBrLFxuXHRcdGlkeHM6IGlkeHMsXG5cdFx0Y2VudHJvaWRzOiBrc1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNrbWVhbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRpc3RhbmNlIiwicmVxdWlyZSIsIkNsdXN0ZXJJbml0IiwiZXVkaXN0IiwibWFuZGlzdCIsImRpc3QiLCJrbXJhbmQiLCJrbXBwIiwiTUFYIiwiaW5pdCIsImxlbiIsInZhbCIsInYiLCJpIiwic2ttZWFucyIsImRhdGEiLCJrIiwiaW5pdGlhbCIsIm1heGl0Iiwia3MiLCJvbGQiLCJpZHhzIiwiY29udiIsIml0IiwibGVuZ3RoIiwidmxlbiIsIm11bHRpIiwiY291bnQiLCJfaWR4cyIsImlkeCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInB1c2giLCJtaW4iLCJJbmZpbml0eSIsIl9pZHgiLCJqIiwiYWJzIiwic3VtIiwiZGlmIiwiX2oiLCJfajIiLCJfaSIsIl9pZHgyIiwidnN1bSIsInZlY3QiLCJoIiwiX2ozIiwia3NqIiwic3VtaiIsIm9sZGoiLCJjaiIsIl9oIiwiX2gyIiwiX2kyIiwiX2lkeDMiLCJfajQiLCJfajUiLCJjZW50cm9pZHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/main.js\n");

/***/ })

};
;